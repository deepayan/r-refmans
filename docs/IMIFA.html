<!DOCTYPE html><html><head><title>Help for package IMIFA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IMIFA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IMIFA-package'><p>IMIFA: Infinite Mixtures of Infinite Factor Analysers and Related Models</p></a></li>
<li><a href='#bnpControl'><p>Control settings for the Bayesian Nonparametric priors for infinite mixture models (or shrinkage priors for overfitted mixtures)</p></a></li>
<li><a href='#coffee'><p>Chemical composition of Arabica and Robusta coffee samples</p></a></li>
<li><a href='#G_moments'><p>1st &amp; 2nd Moments of the Pitman-Yor / Dirichlet Processes</p></a></li>
<li><a href='#G_priorDensity'><p>Plot Pitman-Yor / Dirichlet Process Priors</p></a></li>
<li><a href='#get_IMIFA_results'><p>Extract results, conduct posterior inference and compute performance metrics for MCMC samples of models from the IMIFA family</p></a></li>
<li><a href='#gumbel_max'><p>Simulate Cluster Labels from Unnormalised Log-Probabilities using the Gumbel-Max Trick</p></a></li>
<li><a href='#heat_legend'><p>Add a colour key legend to heatmap plots</p></a></li>
<li><a href='#IMIFA_news'><p>Show the NEWS file</p></a></li>
<li><a href='#is.cols'><p>Check for Valid Colours</p></a></li>
<li><a href='#is.posi_def'><p>Check Positive-(Semi)definiteness of a matrix</p></a></li>
<li><a href='#Ledermann'><p>Ledermann Bound</p></a></li>
<li><a href='#ltrgamma'><p>Left Truncated Gamma Distributions</p></a></li>
<li><a href='#mat2cols'><p>Convert a numeric matrix to colours</p></a></li>
<li><a href='#mcmc_IMIFA'><p>Adaptive Gibbs Sampler for Nonparametric Model-based Clustering using models from the IMIFA family</p></a></li>
<li><a href='#MGP_check'><p>Check the validity of Multiplicative Gamma Process (MGP) hyperparameters</p></a></li>
<li><a href='#mgpControl'><p>Control settings for the MGP prior and AGS for infinite factor models</p></a></li>
<li><a href='#mixfaControl'><p>Control settings for the IMIFA family of factor analytic mixtures</p></a></li>
<li><a href='#olive'><p>Fatty acid composition of Italian olive oils</p></a></li>
<li><a href='#pareto_scale'><p>Pareto Scaling</p></a></li>
<li><a href='#PGMM_dfree'><p>Estimate the Number of Free Parameters in Finite Factor Analytic Mixture Models (PGMM)</p></a></li>
<li><a href='#plot_cols'><p>Plots a matrix of colours</p></a></li>
<li><a href='#plot.Results_IMIFA'><p>Plotting output and parameters of inferential interest for IMIFA and related models</p></a></li>
<li><a href='#post_conf_mat'><p>Posterior Confusion Matrix</p></a></li>
<li><a href='#Procrustes'><p>Procrustes Transformation</p></a></li>
<li><a href='#psi_hyper'><p>Find sensible inverse gamma hyperparameters for variance/uniqueness parameters</p></a></li>
<li><a href='#rDirichlet'><p>Simulate Mixing Proportions from a Dirichlet Distribution</p></a></li>
<li><a href='#scores_MAP'><p>Decompose factor scores by cluster</p></a></li>
<li><a href='#shift_GA'><p>Moment Matching Parameters of Shifted Gamma Distributions</p></a></li>
<li><a href='#show_digit'><p>Show image of grayscale grid</p></a></li>
<li><a href='#show_IMIFA_digit'><p>Plot the posterior mean image</p></a></li>
<li><a href='#sim_IMIFA'><p>Simulate Data from a Mixture of Factor Analysers Structure</p></a></li>
<li><a href='#storeControl'><p>Set storage values for use with the IMIFA family of models</p></a></li>
<li><a href='#USPSdigits'><p>USPS handwritten digits</p></a></li>
<li><a href='#Zsimilarity'><p>Summarise MCMC samples of clustering labels with a similarity matrix and find the 'average' clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-12</td>
</tr>
<tr>
<td>Title:</td>
<td>Infinite Mixtures of Infinite Factor Analysers and Related
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides flexible Bayesian estimation of Infinite Mixtures of Infinite Factor Analysers and related models, for nonparametrically clustering high-dimensional data, introduced by Murphy et al. (2020) &lt;<a href="https://doi.org/10.1214%2F19-BA1179">doi:10.1214/19-BA1179</a>&gt;. The IMIFA model conducts Bayesian nonparametric model-based clustering with factor analytic covariance structures without recourse to model selection criteria to choose the number of clusters or cluster-specific latent factors, mostly via efficient Gibbs updates. Model-specific diagnostic tools are also provided, as well as many options for plotting results, conducting posterior inference on parameters of interest, posterior predictive checking, and quantifying uncertainty.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=IMIFA">https://cran.r-project.org/package=IMIFA</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Keefe-Murphy/IMIFA">https://github.com/Keefe-Murphy/IMIFA</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>matrixStats (&ge; 1.0.0), mclust (&ge; 5.4), mvnfast, Rfast (&ge;
1.9.8), slam, viridisLite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gmp (&ge; 0.5-4), knitr, mcclust, rmarkdown, Rmpfr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MainFunction.R' 'Diagnostics.R' 'FullConditionals.R'
'Gibbs_FA.R' 'Gibbs_IFA.R' 'Gibbs_IMFA.R' 'Gibbs_IMIFA.R'
'Gibbs_MFA.R' 'Gibbs_MIFA.R' 'Gibbs_OMFA.R' 'Gibbs_OMIFA.R'
'IMIFA.R' 'PlottingFunctions.R' 'SimulateData.R' 'data.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 13:31:20 UTC; Keefe</td>
</tr>
<tr>
<td>Author:</td>
<td>Keefe Murphy <a href="https://orcid.org/0000-0002-7709-3159"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Cinzia Viroli <a href="https://orcid.org/0000-0002-3278-5266"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Isobel Claire Gormley
    <a href="https://orcid.org/0000-0001-7713-681X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Keefe Murphy &lt;keefe.murphy@mu.ie&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='IMIFA-package'>IMIFA: Infinite Mixtures of Infinite Factor Analysers and Related Models</h2><span id='topic+IMIFA'></span><span id='topic+IMIFA-package'></span>

<h3>Description</h3>

<p>A package for Bayesian nonparametric clustering of high-dimensional data sets, providing functions for fitting, diagnostic tools and plotting for Infinite Mixtures of Infinite Factor Analysers and the full suite of related models introduced by Murphy et al. (2020) &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;. Allows model based clustering with factor analytic covariance structures without recourse to model selection criteria to choose the number of clusters or cluster-specific latent factors. Model-specific diagnostic tools are also provided, as well as many options for plotting results, conducting posterior inference on parameters of interest, posterior predictive checking, and quantifying uncertainty.
</p>


<h3>Details</h3>


<dl>
<dt>Type: </dt><dd><p>Package</p>
</dd>
<dt>Package: </dt><dd><p>IMIFA</p>
</dd>
<dt>Version: </dt><dd><p>2.2.0</p>
</dd>
<dt>Date: </dt><dd><p>2023-12-12 (this version), 2017-02-02 (original release)</p>
</dd>
<dt>Licence: </dt><dd><p>GPL (&gt;= 3)</p>
</dd>
</dl>



<h3>Usage</h3>

<p>The three most important functions in the <span class="pkg">IMIFA</span> package are: <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, for fitting the model, <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, for extracting results from objects of the <code>"IMIFA"</code> class generated by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, and the dedicated plotting function <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>, for plotting results pertaining to parameters of inferential interest from objects of class <code>"Results_IMIFA"</code> generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.
</p>
<p>Other functions also exist, e.g. for simulating data from a multivariate mixture of factor analysers, many functions for soliciting good priors, and many functions related to plotting.
</p>
<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>:
This function estimates models in the IMIFA family under the Bayesian paradigm. Most importantly, one must specify the <code>method</code> in the form of an acronym (e.g. <code>"MIFA"</code> for Mixtures of Infinite Factor Analysers) and ranges of values for range.G, the number of clusters, and range.Q, the number(s) of (cluster-specific) latent factors as required by said method.
</p>
<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>:
Raw simulation objects generated by mcmc_IMIFA() are passed to this function in order to extract results of interest and conduct further post-processing if necessary.
</p>
<p><code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>:
Results obtained from get_IMIFA_Results are passed to this function with the type of plot desired specified by <code>plot.meth</code> (e.g. <code>"trace"</code>) and the parameter of interest specified by <code>param</code> (e.g. <code>"loadings"</code>).
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p>Further details and examples are given in the associated vignette document:<br />
<code>vignette("IMIFA", package = "IMIFA")</code>
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy [aut, cre], Cinzia Viroli [ctb], Isobel Claire Gormley [ctb]
</p>
<p><strong>Maintainer</strong>: Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://cran.r-project.org/package=IMIFA">https://cran.r-project.org/package=IMIFA</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Keefe-Murphy/IMIFA">https://github.com/Keefe-Murphy/IMIFA</a>
</p>
</li></ul>


<hr>
<h2 id='bnpControl'>Control settings for the Bayesian Nonparametric priors for infinite mixture models (or shrinkage priors for overfitted mixtures)</h2><span id='topic+bnpControl'></span>

<h3>Description</h3>

<p>Supplies a list of arguments for use in <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> pertaining to the use of the Bayesian Nonparametric Pitman-Yor / Dirichlet process priors with the infinite mixture models <code>"IMFA"</code> and <code>"IMIFA"</code>. Certain arguments related to the Dirichlet concentration parameter for the overfitted mixtures <code>"OMFA"</code> and <code>"OMIFA"</code> can be supplied in this manner also.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bnpControl(learn.alpha = TRUE,
           alpha.hyper = c(2L, 4L),
           discount = 0,
           learn.d = TRUE,
           d.hyper = c(1L, 1L),
           ind.slice = TRUE,
           rho = 0.75,
           trunc.G = NULL,
           kappa = 0.5,
           IM.lab.sw = TRUE,
           thresh = FALSE,
           exchange = FALSE,
           zeta = NULL,
           tune.zeta = list(...),
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bnpControl_+3A_learn.alpha">learn.alpha</code></td>
<td>

<dl>
<dt>For the <code>"IMFA"</code> and <code>"IMIFA"</code> methods:</dt><dd><p>A logical indicating whether the Pitman-Yor / Dirichlet process concentration parameter is to be learned (defaults to <code>TRUE</code>), or remain fixed for the duration of the chain. If being learned, a Ga(a, b) prior is assumed for <code>alpha</code>; updates take place via Gibbs sampling when <code>discount</code> is zero and via Metropolis-Hastings when <code>discount &gt; 0</code>. If not being learned, <code>alpha</code> <em>must</em> be supplied.
</p>
<p>In the special case of <code>discount &lt; 0</code>, <code>alpha</code> must be supplied as a positive integer multiple of <code>abs(discount)</code>; in this instance, <code>learn.alpha</code> is forced to <code>TRUE</code> and <code>alpha</code> is updated with the changing number of components as the positive integer.</p>
</dd>
<dt>For the <code>"OMFA"</code> and <code>"OMIFA"</code> methods:</dt><dd><p>A logical indicating whether the Dirichlet concentration parameter is to be learned (defaults to <code>TRUE</code>) or remain fixed for the duration of the chain. If being learned, a Ga(a, b * G) is assumed for <code>alpha</code>, where G is the number of mixture components <code>range.G</code>, and updates take place via Metropolis-Hastings. If not being learned <code>alpha</code> <em>must</em> be supplied.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bnpControl_+3A_alpha.hyper">alpha.hyper</code></td>
<td>

<dl>
<dt>For the <code>"IMFA"</code> and <code>"IMIFA"</code> methods:</dt><dd><p>A vector of length 2 giving hyperparameters for the prior on the Pitman-Yor / Dirichlet process concentration parameter <code>alpha</code>. If <code>isTRUE(learn.alpha)</code>, these are shape and rate parameters of a Gamma distribution. Defaults to Ga(<code>2</code>, <code>4</code>). Choosing a larger rate is particularly important, as it encourages clustering. The prior is shifted to have support on (<code>-discount</code>, <code>Inf</code>) when non-zero <code>discount</code> is supplied and remains fixed (i.e. <code>learn.d=FALSE</code>) or when <code>learn.d=TRUE</code>.</p>
</dd>
<dt>For the <code>"OMFA"</code> and <code>"OMIFA"</code> methods:</dt><dd><p>A vector of length 2 giving hyperparameters a and b for the prior on the Dirichlet concentration parameter <code>alpha</code>. If <code>isTRUE(learn.alpha)</code>, these are shape and rate parameters of a Gamma distribution. Defaults to Ga(2, 4). Note that the supplied rate will be multiplied by <code>range.G</code>, to encourage clustering, such that the form of the prior is Ga(a, b * G).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bnpControl_+3A_discount">discount</code></td>
<td>
<p>The discount parameter used when generalising the Dirichlet process to the Pitman-Yor process. Defaults to 0, but typically must lie in the interval [0, 1). If greater than zero, <code>alpha</code> can be supplied greater than <code>-discount</code>. By default, Metropolis-Hastings steps are invoked for updating this parameter via <code>learn.d</code>.
</p>
<p>The special case of <code>discount &lt; 0</code> is allowed, in which case <code>learn.d=FALSE</code> is forced and <code>alpha</code> must be supplied as a positive integer multiple of <code>abs(discount)</code>. Fixing <code>discount &gt; 0.5</code> is discouraged (see <code>learn.alpha</code>).</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_learn.d">learn.d</code></td>
<td>
<p>Logical indicating whether the <code>discount</code> parameter is to be updated via Metropolis-Hastings (defaults to <code>TRUE</code>, unless <code>discount</code> is supplied as a negative value).</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_d.hyper">d.hyper</code></td>
<td>
<p>Hyperparameters for the Beta(a,b) prior on the <code>discount</code> parameter. Defaults to Beta(1,1), i.e. Uniform(0,1).</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_ind.slice">ind.slice</code></td>
<td>
<p>Logical indicating whether the independent slice-efficient sampler is to be employed (defaults, typically, to <code>TRUE</code>). If <code>FALSE</code> the dependent slice-efficient sampler is employed, whereby the slice sequence <code class="reqn">\xi_1,\ldots,\xi_g</code> is equal to the decreasingly ordered mixing proportions. When <code>thresh</code> &amp;/or <code>exchange</code> are set to <code>TRUE</code> (see below), this argument is forced to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_rho">rho</code></td>
<td>
<p>Parameter controlling the rate of geometric decay for the independent slice-efficient sampler, s.t. <code class="reqn">\xi=(1-\rho)\rho^{g-1}</code>. Must lie in the interval [0, 1). Higher values are associated with better mixing but longer run times. Defaults to <code>0.75</code>, but <code>0.5</code> is an interesting special case which guarantees that the slice sequence <code class="reqn">\xi_1,\ldots,\xi_g</code> is equal to the <em>expectation</em> of the decreasingly ordered mixing proportions. Only relevant when <code>ind.slice</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_trunc.g">trunc.G</code></td>
<td>
<p>The maximum number of allowable and storable clusters under the <code>"IMIFA"</code> and <code>"IMFA"</code> models. The number of active clusters to be sampled at each iteration is adaptively truncated, with <code>trunc.G</code> as an upper limit for storage reasons. Defaults to <code>max(min(N-1, 50), range.G))</code> and must satisfy <code>range.G &lt;= trunc.G &lt; N</code>. Note that large values of <code>trunc.G</code> may lead to memory capacity issues.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_kappa">kappa</code></td>
<td>
<p>The spike-and-slab prior distribution on the <code>discount</code> hyperparameter is assumed to be a mixture with point-mass at zero and a continuous Beta(a,b) distribution. <code>kappa</code> gives the weight of the point mass at zero (the 'spike'). Must lie in the interval [0,1]. Defaults to <code>0.5</code>. Only relevant when <code>isTRUE(learn.d)</code>. A value of 0 ensures non-zero discount values (i.e. Pitman-Yor) at all times, and <em>vice versa</em>. Note that <code>kappa</code> will default to exactly 0 if <code>alpha&lt;=0</code> and <code>learn.alpha=FALSE</code>.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_im.lab.sw">IM.lab.sw</code></td>
<td>
<p>Logical indicating whether the two forced label switching moves are to be implemented (defaults to <code>TRUE</code>) when running one of the infinite mixture models. Note: when <code>exchange=TRUE</code> (see below), this argument is instead forced to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_thresh">thresh</code></td>
<td>
<p>Logical indicating whether the threshold of Fall and Barat (2014) should be incorporated into the slice sampler. See the reference for details. This is an experimental feature (defaults to <code>FALSE</code>) and can work with or without <code>exchange</code> below. Setting <code>thresh=TRUE</code> is <strong>not</strong> recommended unless both <code>learn.alpha</code> and <code>learn.d</code> are <code>FALSE</code>. Setting <code>thresh</code> to <code>TRUE</code> also forces <code>ind.slice</code> to <code>FALSE</code> (see above).</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_exchange">exchange</code></td>
<td>
<p>Logical indicating whether the exchangeable slice sampler of Fall and Barat (2014) should be used instead. See the reference for details. This argument can work with or without <code>thresh=TRUE</code> above, though it is also an experimental argument and thus defaults to <code>FALSE</code>. When <code>TRUE</code>, the arguments <code>ind.slice</code> and <code>IM.lab.sw</code> (see above) are both forced to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_zeta">zeta</code></td>
<td>

<dl>
<dt>For the <code>"IMFA"</code> and <code>"IMIFA"</code> methods:</dt><dd><p>Tuning parameter controlling the acceptance rate of the random-walk proposal for the Metropolis-Hastings steps when <code>learn.alpha=TRUE</code>, where <code>2 * zeta</code> gives the full width of the uniform proposal distribution. These steps are only invoked when either <code>discount</code> is non-zero and fixed or <code>learn.d=TRUE</code>, otherwise <code>alpha</code> is learned by Gibbs updates. Must be strictly positive (if invoked). Defaults to <code>2</code>.</p>
</dd>
<dt>For the <code>"OMFA"</code> and <code>"OMIFA"</code> methods:</dt><dd><p>Tuning parameter controlling the standard deviation of the log-normal proposal for the Metropolis-Hastings steps when <code>learn.alpha=TRUE</code>. Must be strictly positive (if invoked). Defaults to <code>0.75</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="bnpControl_+3A_tune.zeta">tune.zeta</code></td>
<td>
<p>A list with the following named arguments, used for tuning <code>zeta</code> (which is either the width of the uniform proposal for the <code>"IMFA"</code> or <code>"IMIFA"</code> methods or the standard deviation of the log-normal proposal for the <code>"OMFA"</code> or <code>"OMIFA"</code> methods) for <code>alpha</code>, via diminishing Robbins-Monro type adaptation, when the <code>alpha</code> parameter is learned via Metropolis-Hastings steps:
</p>

<dl>
<dt><code>heat</code></dt><dd><p>The initial adaptation intensity/step-size, such that larger values lead to larger updates. Must be strictly greater than zero. Defaults to <code>1</code> if not supplied but other elements of <code>tune.zeta</code> are.</p>
</dd>
<dt><code>lambda</code></dt><dd><p>Iteration rescaling parameter which controls the speed at which adaptation diminishes, such that lower values cause the contribution of later iterations to diminish more slowly. Must lie in the interval (0.5, 1]. Defaults to 1 if not supplied but other elements of <code>tune.zeta</code> are.</p>
</dd>
<dt><code>target</code></dt><dd><p>The target acceptance rate. Must lie in the interval [0, 1]. Defaults to <code>0.441</code>, which is optimal for univariate targets, if not supplied but other elements of <code>tune.zeta</code> are.</p>
</dd>
<dt><code>start.zeta</code></dt><dd><p>The iteration at which diminishing adaptation begins. Defaults to <code>100</code>.</p>
</dd>
<dt><code>stop.zeta</code></dt><dd><p>The iteration at which diminishing adaptation is to stop completely. Defaults to <code>Inf</code>, such that diminishing adaptation is never explicitly made to stop. Must be greater than <code>start.zeta</code>.</p>
</dd>
</dl>

<p>At least one <code>tune.zeta</code> argument must be supplied for diminishing adaptation to be invoked. <code>tune.zeta</code> arguments are only relevant when <code>learn.alpha</code> is <code>TRUE</code> (and, for the <code>"IMFA"</code> and <code>"IMIFA"</code> methods, when either of the following is also true: the <code>discount</code> remains fixed at a non-zero value, or when <code>learn.d</code> is <code>TRUE</code> and <code>kappa &lt; 1</code>). Since Gibbs steps are invoked for updating <code>alpha</code> when <code>discount == 0</code> under the <code>"IMFA"</code> or <code>"IMIFA"</code> methods, adaption occurs according to a running count of the number of iterations with non-zero sampled <code>discount</code> values for those methods. As such, when a mix of Gibbs and MH updates are used, this tuning only targets the <code>target</code> acceptance rates for the MH steps; i.e. acceptances under the Gibbs framework will inflate the acceptance rate further.
</p>
<p>If diminishing adaptation is invoked, the posterior mean <code>zeta</code> will be stored. Since caution is advised when employing adaptation, note that acceptance rates of between 10-50% are generally considered adequate.</p>
</td></tr>
<tr><td><code id="bnpControl_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The crucial concentration parameter <code>alpha</code> is documented within the main <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> function, and is relevant to all of the <code>"IMIFA"</code>, <code>"IMFA"</code>, <code>"OMIFA"</code>, and <code>"OMFA"</code> methods.
</p>
<p>All arguments here are relevant to the <code>"IMFA"</code> and <code>"IMIFA"</code> methods, but the following are also related to the <code>"OMFA"</code> and <code>"OMIFA"</code> methods, and may behave differently in those instances: <code>learn.alpha</code>, <code>alpha.hyper</code>, <code>zeta</code>, and <code>tune.zeta</code>.
</p>


<h3>Value</h3>

<p>A named list in which the names are the names of the arguments related to the BNP prior(s) and the values are the values supplied to the arguments.
</p>


<h3>Note</h3>

<p>Certain supplied arguments will be subject to further checks within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. <code><a href="#topic+G_priorDensity">G_priorDensity</a></code> and <code><a href="#topic+G_moments">G_moments</a></code> can help with soliciting sensible DP/PYP priors.
</p>
<p>Under the <code>"IMFA"</code> and <code>"IMIFA"</code> methods, a Pitman-Yor process prior is specified by default. A Dirichlet process prior can be easily invoked when the <code>discount</code> is fixed at <code>0</code> and <code>learn.d=FALSE</code>. The normalized stable process can also be specified as a prior distribution, as a special case of the Pitman-Yor process, when <code>alpha</code> remains fixed at <code>0</code> and <code>learn.alpha=FALSE</code> (provided the <code>discount</code> is fixed at a strictly positive value or <code>learn.d=TRUE</code>). The special case of the Pitman-Yor process with negative <code>discount</code> is also allowed as an experimental feature for which caution is advised, though <code>learn.d</code> and <code>learn.alpha</code> are forced to <code>FALSE</code> and <code>TRUE</code>, respectively, in this instance.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Kalli, M., Griffin, J. E. and Walker, S. G. (2011) Slice sampling mixture models, <em>Statistics and Computing</em>, 21(1): 93-105.
</p>
<p>Fall, M. D. and Barat, E. (2014) Gibbs sampling methods for Pitman-Yor mixture models, <em>hal-00740770v2</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+G_priorDensity">G_priorDensity</a></code>, <code><a href="#topic+G_moments">G_moments</a></code>, <code><a href="#topic+mixfaControl">mixfaControl</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+storeControl">storeControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bnpctrl &lt;- bnpControl(learn.d=FALSE, ind.slice=FALSE, alpha.hyper=c(3, 3))

# data(olive)
# sim   &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000, BNP=bnpctrl)

# Alternatively specify these arguments directly
# sim   &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000, learn.d=FALSE,
#                     ind.slice=FALSE, alpha.hyper=c(3, 3))
</code></pre>

<hr>
<h2 id='coffee'>Chemical composition of Arabica and Robusta coffee samples</h2><span id='topic+coffee'></span>

<h3>Description</h3>

<p>Data on the chemical composition of coffee samples collected from around the world, comprising 43 samples from 29 countries. Each sample is either of the Arabica or Robusta variety. Twelve of the thirteen chemical constituents reported in the study are given. The omitted variable is total chlorogenic acid; it is generally the sum of the chlorogenic, neochlorogenic and isochlorogenic acid values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coffee)
</code></pre>


<h3>Format</h3>

<p>A data frame with 43 observations and 14 columns. The first two columns contain Variety (either Arabica or Robusta) and Country, respectively, while the remaining 12 columns contain the chemical properties.
</p>


<h3>References</h3>

<p>Streuli, H. (1973). Der heutige Stand der Kaffee-Chemie, In <em>Proceedings of the 6th International Colloquium on Coffee Chemistry</em>, June 4-June 9, 1973, Bogata, Colombia, pp. 61-72. Paris, France: Association Scientifique International du Café (ASIC).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coffee, package="IMIFA")
pairs(coffee[,-(1:2)], col=coffee$Variety)
</code></pre>

<hr>
<h2 id='G_moments'>1st &amp; 2nd Moments of the Pitman-Yor / Dirichlet Processes</h2><span id='topic+G_moments'></span><span id='topic+G_expected'></span><span id='topic+G_variance'></span><span id='topic+G_calibrate'></span>

<h3>Description</h3>

<p>Calculate the <em>a priori</em> expected number of clusters (<code>G_expected</code>) or the variance of the number of clusters (<code>G_variance</code>) under a PYP or DP prior for a sample of size <code>N</code> at given values of the concentration parameter <code>alpha</code> and optionally also the Pitman-Yor <code>discount</code> parameter. Useful for soliciting sensible priors (or fixed values) for <code>alpha</code> or <code>discount</code> under the <code>"IMFA"</code> and <code>"IMIFA"</code> methods for <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. Additionally, for a given sample size <code>N</code> and given expected number of clusters <code>EG</code>, <code>G_calibrate</code> elicits a value for the concentration parameter <code>alpha</code> <strong>or</strong> the <code>discount</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G_expected(N,
           alpha,
           discount = 0,
           MPFR = TRUE)

G_variance(N,
           alpha,
           discount = 0,
           MPFR = TRUE)

G_calibrate(N,
            EG,
            alpha = NULL,
            discount = 0,
            MPFR = TRUE,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_moments_+3A_n">N</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="G_moments_+3A_alpha">alpha</code></td>
<td>
<p>The concentration parameter. Must be specified (though not for <code>G_calibrate</code>) and must be strictly greater than <code>-discount</code>. The case <code>alpha=0</code> is accommodated. When <code>discount</code> is negative <code>alpha</code> must be a positive integer multiple of <code>abs(discount)</code>. See <strong>Details</strong> for behaviour for <code>G_calibrate</code>.</p>
</td></tr>
<tr><td><code id="G_moments_+3A_discount">discount</code></td>
<td>
<p>The discount parameter for the Pitman-Yor process. Must be less than 1, but typically lies in the interval [0, 1). Defaults to 0 (i.e. the Dirichlet process). When <code>discount</code> is negative <code>alpha</code> must be a positive integer multiple of <code>abs(discount)</code>. See <strong>Details</strong> for behaviour for <code>G_calibrate</code>.</p>
</td></tr>
<tr><td><code id="G_moments_+3A_mpfr">MPFR</code></td>
<td>
<p>Logical indicating whether the high-precision libraries <code><a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a></code> and <code>gmp</code> are invoked, at the expense of run-time. Defaults to <code>TRUE</code> and <strong>must</strong> be <code>TRUE</code> for <code>G_expected</code> when <code>alpha=0</code> or <code>G_variance</code> when <code>discount</code> is non-zero. For <code>G_calibrate</code>, it is <em>strongly recommended</em> to use <code>MPFR=TRUE</code> when <code>discount</code> is non-zero and strictly necessary when <code>alpha=0</code> is supplied. See <strong><code>Note</code></strong>.</p>
</td></tr>
<tr><td><code id="G_moments_+3A_eg">EG</code></td>
<td>
<p>The prior expected number of clusters. Must exceed <code>1</code> and be less than <code>N</code>.</p>
</td></tr>
<tr><td><code id="G_moments_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="stats.html#topic+uniroot">uniroot</a></code>, e.g. <code>maxiter</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments are vectorised. Users can also consult <code><a href="#topic+G_priorDensity">G_priorDensity</a></code> in order to solicit sensible priors.
</p>
<p>For <code>G_calibrate</code>, <strong>only one</strong> of <code>alpha</code> or <code>discount</code> can be supplied, and the function elicits a value for the opposing parameter which achieves the desired expected number of clusters <code>EG</code> for the given sample size <code>N</code>. By default, a value for <code>alpha</code> subject to <code>discount=0</code> (i.e. the Dirichlet process) is elicited. Note that <code>alpha</code> may not be a positive integer multiple of <code>discount</code> as it should be if <code>discount</code> is negative. See <strong>Examples</strong> below.
</p>


<h3>Value</h3>

<p>The expected number of clusters under the specified prior conditions (<code>G_expected</code>), or the variance of the number of clusters (<code>G_variance</code>), or the concentration parameter <code>alpha</code> <strong>or</strong> <code>discount</code> parameter achieving a particular expected number of clusters (<code>G_calibrate</code>).
</p>


<h3>Note</h3>

<p><code>G_variance</code> requires use of the <code><a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a></code> and <code>gmp</code> libraries for non-zero <code>discount</code> values. <code>G_expected</code> requires these libraries only for the <code>alpha=0</code> case. These libraries are <em>strongly recommended</em> (but they are not required) for <code>G_calbirate</code> when <code>discount</code> is non-zero, but they are required when <code>alpha=0</code> is supplied. Despite the high precision arithmetic used, the functions can still be unstable for large <code>N</code> and/or extreme values of <code>alpha</code> and/or <code>discount</code>. See the argument <code>MPFR</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>De Blasi, P., Favaro, S., Lijoi, A., Mena, R. H., Prunster, I., and Ruggiero, M. (2015) Are Gibbs-type priors the most natural generalization of the Dirichlet process?, <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 37(2): 212-229.
</p>
<p>Yamato, H. and Shibuya, M. (2000) Moments of some statistics of Pitman sampling formula, <em>Bulletin of Informatics and Cybernetics</em>, 32(1): 1-10.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+G_priorDensity">G_priorDensity</a></code>, <code><a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a></code>, <code><a href="stats.html#topic+uniroot">uniroot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Certain examples require the use of the Rmpfr library
suppressMessages(require("Rmpfr"))

G_expected(N=50, alpha=19.23356, MPFR=FALSE)
G_variance(N=50, alpha=19.23356, MPFR=FALSE)

G_expected(N=50, alpha=c(19.23356, 12.21619, 1),
           discount=c(0, 0.25, 0.7300045), MPFR=FALSE)
G_variance(N=50, alpha=c(19.23356, 12.21619, 1),
           discount=c(0, 0.25, 0.7300045), MPFR=c(FALSE, TRUE, TRUE))

# Examine the growth rate of the DP
DP   &lt;- sapply(c(1, 5, 10), function(i) G_expected(1:200, alpha=i, MPFR=FALSE))
matplot(DP, type="l", xlab="N", ylab="G")

# Examine the growth rate of the PYP
PY &lt;- sapply(c(0.25, 0.5, 0.75), function(i) G_expected(1:200, alpha=1, discount=i))
matplot(PY, type="l", xlab="N", ylab="G")

# Other special cases of the PYP are also facilitated
G_expected(N=50, alpha=c(27.1401, 0), discount=c(-27.1401/100, 0.8054448))
G_variance(N=50, alpha=c(27.1401, 0), discount=c(-27.1401/100, 0.8054448))

# Elicit values for alpha under a DP prior
G_calibrate(N=50, EG=25)

# Elicit values for alpha under a PYP prior
# G_calibrate(N=50, EG=25, discount=c(-27.1401/100, 0.25, 0.7300045))
# Elicit values for discount under a PYP prior
# G_calibrate(N=50, EG=25, alpha=c(12.21619, 1, 0), maxiter=2000)
</code></pre>

<hr>
<h2 id='G_priorDensity'>Plot Pitman-Yor / Dirichlet Process Priors</h2><span id='topic+G_priorDensity'></span>

<h3>Description</h3>

<p>Plots the prior distribution of the number of clusters under a Pitman-Yor / Dirichlet process prior, for a sample of size <code>N</code> at given values of the concentration parameter <code>alpha</code> and optionally also the <code>discount</code> parameter. Useful for soliciting sensible priors (or fixed values) for <code>alpha</code> or <code>discount</code> under the <code>"IMFA"</code> and <code>"IMIFA"</code> methods for <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G_priorDensity(N,
               alpha,
               discount = 0,
               show.plot = TRUE,
               type = "h")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_priorDensity_+3A_n">N</code></td>
<td>
<p>The sample size.</p>
</td></tr>
<tr><td><code id="G_priorDensity_+3A_alpha">alpha</code></td>
<td>
<p>The concentration parameter. Must be specified and must be strictly greater than <code>-discount</code>. The case <code>alpha=0</code> is accommodated. When <code>discount</code> is negative <code>alpha</code> must be a positive integer multiple of <code>abs(discount)</code>.</p>
</td></tr>
<tr><td><code id="G_priorDensity_+3A_discount">discount</code></td>
<td>
<p>The discount parameter for the Pitman-Yor process. Must be less than 1, but typically lies in the interval [0, 1). Defaults to 0 (i.e. the Dirichlet process). When <code>discount</code> is negative <code>alpha</code> must be a positive integer multiple of <code>abs(discount)</code>.</p>
</td></tr>
<tr><td><code id="G_priorDensity_+3A_show.plot">show.plot</code></td>
<td>
<p>Logical indicating whether the plot should be displayed (default = <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="G_priorDensity_+3A_type">type</code></td>
<td>
<p>The type of plot to be drawn, as per <code><a href="graphics.html#topic+plot">plot</a></code>. Defaults to <code>"h"</code>: histogram-like vertical lines.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All arguments are vectorised. Users can also consult <code><a href="#topic+G_expected">G_expected</a></code>, <code><a href="#topic+G_variance">G_variance</a></code>, and <code><a href="#topic+G_calibrate">G_calibrate</a></code> in order to solicit sensible priors.
</p>


<h3>Value</h3>

<p>A plot of the prior distribution if <code>show.plot</code> is <code>TRUE</code>. Density values are returned invisibly. Note that the density values may not strictly sum to one in certain cases, as values small enough to be represented as zero may well be returned.
</p>


<h3>Note</h3>

<p>The actual density values are returned invisibly. Therefore, they can be visualised as desired by the user even if <code>show.plot</code> is <code>FALSE</code>.
</p>
<p>Requires use of the <code><a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a></code> and <code>gmp</code> libraries; may encounter difficulty and slowness for large <code>N</code>, especially with non-zero <code>discount</code> values. Despite the high precision arithmetic used, the functions can be unstable for small values of <code>discount</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>De Blasi, P., Favaro, S., Lijoi, A., Mena, R. H., Prunster, I., and Ruggiero, M. (2015) Are Gibbs-type priors the most natural generalization of the Dirichlet process?, <em>IEEE Transactions on Pattern Analysis and Machine Intelligence</em>, 37(2): 212-229.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+G_moments">G_moments</a></code>, <code><a href="Rmpfr.html#topic+Rmpfr">Rmpfr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Dirichlet process priors for different values of alpha
(DP      &lt;- G_priorDensity(N=50, alpha=c(3, 10, 25)))

# Verify that these alpha/discount values produce Pitman-Yor process priors with the same mean
alpha    &lt;- c(19.23356, 6.47006, 1)
discount &lt;- c(0, 0.47002, 0.7300045)
G_expected(N=50, alpha=alpha, discount=discount)

# Now plot them to examine tail behaviour as discount increases
# Non-zero discount requires loading the "Rmpfr" library
suppressMessages(require("Rmpfr"))
(PY      &lt;- G_priorDensity(N=50, alpha=alpha, discount=discount, type="l"))

# Other special cases of the PYP are also facilitated
G_priorDensity(N=50, alpha=c(alpha, 27.1401, 0),
               discount=c(discount, -27.1401/100, 0.8054448), type="b")
</code></pre>

<hr>
<h2 id='get_IMIFA_results'>Extract results, conduct posterior inference and compute performance metrics for MCMC samples of models from the IMIFA family</h2><span id='topic+get_IMIFA_results'></span><span id='topic+print.Results_IMIFA'></span><span id='topic+summary.Results_IMIFA'></span>

<h3>Description</h3>

<p>This function post-processes simulations generated by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> for any of the IMIFA family of models. This includes accounting for label switching, and accounting for rotational invariance via Procrustean methods. It can be re-ran at little computational cost in order to extract different models explored by the sampler used for <code>sims</code>, without having to re-run the model itself. New results objects using different numbers of clusters and different numbers of factors (if visited by the model in question), or using different model selection criteria (if necessary) can be generated with ease. Posterior predictive checking of the appropriateness of the fitted model is also facilitated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_IMIFA_results(sims = NULL,
                  burnin = 0L,
                  thinning = 1L,
                  G = NULL,
                  Q = NULL,
                  criterion = c("bicm", "aicm", "dic", "bic.mcmc", "aic.mcmc"),
                  adapt = FALSE,
                  G.meth = c("mode", "median"),
                  Q.meth = c("mode", "median"),
                  conf.level = 0.95,
                  error.metrics = TRUE,
                  vari.rot = FALSE,
                  z.avgsim = FALSE,
                  zlabels = NULL,
                  nonempty = TRUE,
                  ...)

## S3 method for class 'Results_IMIFA'
print(x,
      ...)

## S3 method for class 'Results_IMIFA'
summary(object,
        MAP = TRUE,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_IMIFA_results_+3A_sims">sims</code></td>
<td>
<p>An object of class <code>"IMIFA"</code> generated by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_burnin">burnin</code></td>
<td>
<p>Optional additional number of iterations to discard. Defaults to 0, corresponding to no additional burnin. See <code><a href="#topic+mixfaControl">mixfaControl</a></code> for the default <code>burnin</code> settings used previously by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_thinning">thinning</code></td>
<td>
<p>Optional interval for extra thinning to be applied. Defaults to 1, corresponding to no additional thinning. See <code><a href="#topic+mixfaControl">mixfaControl</a></code> for the default <code>thinning</code> settings used previously by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_g">G</code></td>
<td>
<p>If this argument is not specified, results will be returned with the optimal number of clusters. If different numbers of clusters were explored in <code>sims</code> for the <code>"MFA"</code> or <code>"MIFA"</code> methods, supplying an integer value allows pulling out a specific solution with <code>G</code> clusters, even if the solution is sub-optimal.
</p>
<p>Similarly, this allows retrieval of samples corresponding to a solution, if visited, with <code>G</code> clusters for the <code>"OMFA"</code>, <code>"OMIFA"</code>, <code>"IMFA"</code> and <code>"IMIFA"</code> methods.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_q">Q</code></td>
<td>
<p>If this argument is not specified, results will be returned with the optimal number of factors. If different numbers of factors were explored in <code>sims</code> for the <code>"FA"</code>, <code>"MFA"</code>, <code>"OMFA"</code> or <code>"IMFA"</code> methods, this allows pulling out a specific solution with <code>Q</code> factors, even if the solution is sub-optimal.
</p>
<p>Similarly, this allows retrieval of samples corresponding to a solution, if visited, with <code>Q</code> factors for the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code> and <code>"IMIFA"</code> methods if adaptation has already taken place. Can be supplied as a scalar or a vector of values for each cluster.
</p>
<p>If adaptation didn't take place during model-fitting, <code>adapt=TRUE</code> can be supplied here to determine the optimal cluster-specific numbers of non-redundant factors (see below).</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to use for model selection, where model selection is only required if more than one model was run under the <code>"FA"</code>, <code>"MFA"</code>, <code>"MIFA"</code>, <code>"OMFA"</code> or <code>"IMFA"</code> methods when <code>sims</code> was created via <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. Defaults to <code>bicm</code>, but note that these are <em>all</em> calculated; this argument merely indicates which one will form the basis of the construction of the output.
</p>
<p>Note that the first three options here might exhibit bias in favour of zero-factor models for the finite factor <code>"FA"</code>, <code>"MFA"</code>, <code>"OMFA"</code> and <code>"IMFA"</code> methods and might exhibit bias in favour of one-cluster models for the <code>"MFA"</code> and <code>"MIFA"</code> methods. The <code>aic.mcmc</code> and <code>bic.mcmc</code> criteria will only be returned for finite factor models.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_adapt">adapt</code></td>
<td>
<p>A logical indicating if adaptation should be applied to the stored loadings and scores matrices to truncate the cluster-specific number(s) of non-redundant factors. This argument is only relevant if <code>adapt=FALSE</code> was used when initially fitting the model (otherwise, adaptation has already taken place during sampling, by default), and hence defaults to <code>FALSE</code> here. Relevant parameters from <code><a href="#topic+mgpControl">mgpControl</a></code> (namely <code>active.crit</code>, <code>eps</code>, <code>prop</code>, and <code>forceQg</code>) can be passed via the <code>...</code> construct, but will default to their values under <code><a href="#topic+mgpControl">mgpControl</a></code> if not specified. Note that <code>adapt=TRUE</code> is only invoked if the relevant parameters were stored via <code><a href="#topic+storeControl">storeControl</a></code> when running the model: loadings only for <code>active.crit="BD"</code>, loadings and scores for <code>active.crit="SC"</code> for <code>"IFA"</code> models.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_g.meth">G.meth</code></td>
<td>
<p>If the object in <code>sims</code> arises from the <code>"OMFA"</code>, <code>"OMIFA"</code>, <code>"IMFA"</code> or <code>"IMIFA"</code> methods, this argument determines whether the optimal number of clusters is given by the mode or median of the posterior distribution of <code>G</code>. Defaults to <code>"mode"</code>. Often the mode and median will agree in any case.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_q.meth">Q.meth</code></td>
<td>
<p>If the object in <code>sims</code> arises from the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code> or <code>"IMIFA"</code> methods, this argument determines whether the optimal number of latent factors is given by the mode or median of the posterior distribution of <code>Q</code>. Defaults to <code>"mode"</code>. Often the mode and median will agree in any case.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to be used throughout for credible intervals for all parameters of inferential interest, and error metrics if <code>error.metrics=TRUE</code>. Defaults to <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_error.metrics">error.metrics</code></td>
<td>
<p>A logical activating or deactivating posterior predictive checking: i.e. controlling whether metrics quantifying a) the posterior predictive reconstruction error (PPRE) between bin counts of the data and bin counts of replicate draws from the posterior distribution &amp; and b) the error between the empirical and estimated covariance matrices should be computed. These are computed for every <em>valid</em> retained iteration (see <code>Details</code>). Defaults to <code>TRUE</code>, but can be time-consuming for models which achieve clustering. These error metrics, and the uncertainty associated with them, can be visualised via <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>. Depending on what parameters were stored when calling <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, potentially not all error metrics will be available to compute.
</p>
<p>The Frobenius norm is used in the computation of the PPRE, by default, but the <code>type</code> of <code><a href="Matrix.html#topic+norm">norm</a></code> can be changed via the <code>...</code> construct below. So too can the breakpoints (<code>dbreaks</code>) used to bin the data and the posterior predictive replicate data sets. Some caution is advised in the latter case.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_vari.rot">vari.rot</code></td>
<td>
<p>Logical indicating whether the loadings matrix/matrices template(s) should be <code><a href="stats.html#topic+varimax">varimax</a></code> rotated first, prior to the Procrustes rotation steps. Defaults to <code>FALSE</code>. Not necessary at all for clustering purposes, or inference on the covariance matrix, but useful if interpretable inferences on the loadings matrix/matrices are desired. Arguments to <code><a href="stats.html#topic+varimax">varimax</a></code> can be passed via the <code>...</code> construct, but note that the argument <code>normalize</code> here defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_z.avgsim">z.avgsim</code></td>
<td>
<p>Logical (defaults to <code>FALSE</code>) indicating whether the clustering should also be summarised with a call to <code><a href="#topic+Zsimilarity">Zsimilarity</a></code> by the clustering with minimum mean squared error to the similarity matrix obtained by averaging the stored adjacency matrices, in addition to the MAP estimate.
</p>
<p>Note that the MAP clustering is computed <em>conditional</em> on the estimate of the number of clusters (whether that be the modal estimate or the estimate according to <code>criterion</code>) and other parameters are extracted conditional on this estimate of <code>G</code>: however, in contrast, the number of distinct clusters in the summarised labels obtained by specifying <code>z.avgsim=TRUE</code> may not necessarily coincide with the MAP estimate of <code>G</code>, but it may provide a useful alternative summary of the partitions explored during the chain, and the user is free to call <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> again with the new suggested <code>G</code> value.
</p>
<p>Please be warned that this feature requires loading the <code><a href="mcclust.html#topic+mcclust">mcclust</a></code> package. This is liable to take considerable time to compute, and may not even be possible if the number of observations &amp;/or number of stored iterations is large and the resulting matrix isn't sufficiently sparse. When <code>z.avgsim=TRUE</code>, both the summarised clustering and the similarity matrix are stored: the latter can be visualised as part of a call to <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_zlabels">zlabels</code></td>
<td>
<p>For any method that performs clustering, the true labels can be supplied if they are known in order to compute clustering performance metrics. This also has the effect of ordering the MAP labels (and thus the ordering of cluster-specific parameters) to most closely correspond to the true labels if supplied.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_nonempty">nonempty</code></td>
<td>
<p>For <code>"MFA"</code> and <code>"MIFA"</code> models ONLY: a logical indicating whether only iterations with non-empty components should be retained. Defaults to <code>TRUE</code>, but may lead to empty chains - conversely, <code>FALSE</code> may lead to empty components and related errors.</p>
</td></tr>
<tr><td><code id="get_IMIFA_results_+3A_x">x</code>, <code id="get_IMIFA_results_+3A_object">object</code>, <code id="get_IMIFA_results_+3A_map">MAP</code>, <code id="get_IMIFA_results_+3A_...">...</code></td>
<td>
<p>Arguments required for the <code>print.Results_IMIFA</code> and <code>summary.Results_IMIFA</code> functions: <code>x</code> and <code>object</code> are objects of class <code>"Results_IMIFA"</code> resulting from a call to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>. <code>MAP</code> is a logical which governs whether a table of the MAP classification is printed, while <code>...</code> gathers additional arguments to those functions.
</p>
<p>Users can also pass the <code>type</code> argument to the <code><a href="Matrix.html#topic+norm">norm</a></code> function when <code>isTRUE(error.metrics)</code> and the posterior predictive reconstruction error (PPRE) is calculated. By default the Frobenius norm (<code>type="F"</code>) is employed.
</p>
<p>When <code>adapt=TRUE</code> here, relevant arguments from <code><a href="#topic+mgpControl">mgpControl</a></code> (namely <code>active.crit</code>, <code>eps</code>, <code>prop</code>, and <code>forceQg</code>) can be supplied here too, though they retain their default values from <code><a href="#topic+mgpControl">mgpControl</a></code> otherwise.
</p>
<p>Finally, the <code>...</code> construct also allows arguments to <code><a href="stats.html#topic+varimax">varimax</a></code> to be passed to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> itself, when <code>isTRUE(vari.rot)</code>, or arguments to <code><a href="graphics.html#topic+hist">hist</a></code> when <code>isTRUE(error.metrics)</code>, in order to guide construction of the bins. Additionally, by passing the argument <code>dbreaks</code> via the <code>...</code> construct, the bins can be specified directly. However, caution is advised in doing so; in particular, the bins must be constructed on data which has been standardised in the same way as the data modelled within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function also performs post-hoc corrections for label switching, as well as post-hoc Procrustes rotation of loadings matrices and scores, in order to ensure sensible posterior parameter estimates, computes error metrics, constructs credible intervals, and generally transforms the raw <code>sims</code> object into an object of class <code>"Results_IMIFA"</code> in order to prepare the results for plotting via <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>.
</p>
<p>For the infinite factor methods, iterations where the maximum number of factors was greater than or equal to the maximum of the estimated cluster-specific factors are retained for posterior summaries of the scores, in order to preserve the estimated dimension of the scores matrices. Similarly, these are also the <em>valid</em> iterations used for the computation of the averages and credible intervals for the error metrics. For the finite factor models, <em>all</em> retained iterations are used in both instances (i.e. both for the scores and the error metrics).
</p>
<p>In all cases, only iterations with <code>G</code> non-empty components are retained.
</p>


<h3>Value</h3>

<p>An object of class <code>"Results_IMIFA"</code> to be passed to <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code> for visualising results. Dedicated <code>print</code> and <code>summary</code> functions also exist for objects of this class. The object, say <code>x</code>, is a list of lists, the most important components of which are:
</p>
<table>
<tr><td><code>Clust</code></td>
<td>
<p>Everything pertaining to clustering performance can be found here for all but the <code>"FA"</code> and <code>"IFA"</code> methods (or models where the estimate number of clusters is 1), in particular <code>x$Clust$MAP</code>, the MAP summary of the posterior clustering, the last valid sample of cluster labels <code>x$Clust$last.z</code>, the matrix of posterior cluster membership probabilities <code>x$Clust$post.prob</code>, and the posterior confusion matrix <code>x$Clust$PCM</code>.
</p>
<p>More detail is given if known <code>zlabels</code> are supplied: performance is always evaluated against the MAP clustering, with additional evaluation against the alternative clustering computed if <code>z.avgsim=TRUE</code>. Posterior summaries of the mixing proportions, and the concentration/discount parameters, if necessary, are also included here, as well as the last valid samples of each.</p>
</td></tr>
<tr><td><code>Error</code></td>
<td>
<p>Everything pertaining the model fit assessment can be found here, incl. the distribution of the PPRE values and associated bin counts for the replicate draws, as well as average error metrics (e.g. MSE, RMSE), and credible intervals quantifying the associated uncertainty, between the empirical and estimated covariance matrix/matrices, both of which are also included.</p>
</td></tr>
<tr><td><code>GQ.results</code></td>
<td>
<p>Everything pertaining to model choice can be found here, incl. posterior summaries for the estimated number of clusters and estimated number of factors, if applicable to the method employed. Model selection criterion values are also accessible here.</p>
</td></tr>
<tr><td><code>Means</code></td>
<td>
<p>Posterior summaries for the means, after conditioning on <code>G</code>.</p>
</td></tr>
<tr><td><code>Loadings</code></td>
<td>
<p>Posterior summaries for the factor loadings matrix/matrices, after conditioning on <code>G</code> and <code>Q</code>. Posterior mean loadings given by <code>x$Loadings$post.load</code> are given the <code><a href="stats.html#topic+loadings">loadings</a></code> class for printing purposes and thus the manner in which they are displayed can be modified.
</p>
<p>The number of iterations retained for posterior summaries of the loadings may vary for different clusters for the infinite factor methods, corresponding to iterations where the cluster-specific number of factors was greater than or equal to the modal estimate of the cluster-specific number of factors.</p>
</td></tr>
<tr><td><code>Scores</code></td>
<td>
<p>Posterior summaries for the latent factor scores, after conditioning on the maximum of the estimated number of cluster-specific factors. Summaries are given for the <em>single</em> matrix of factor scores. See <code><a href="#topic+scores_MAP">scores_MAP</a></code> to decompose these summaries into sub-matrices according to the MAP partition (for models which achieve clustering).
</p>
<p>For the infinite factor methods, iterations where the maximum number of factors was greater than or equal to the maximum of the estimated cluster-specific factors are retained for posterior summaries of the scores, in order to preserve the estimated dimension of the scores matrices.</p>
</td></tr>
<tr><td><code>Uniquenesses</code></td>
<td>
<p>Posterior summaries for the uniquenesses, after conditioning on <code>G</code>.</p>
</td></tr>
</table>
<p>The objects <code>Means</code>, <code>Loadings</code>, <code>Scores</code> and <code>Uniquenesses</code> (if stored when calling <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>!) also contain, as well as the posterior summaries, the entire chain of valid samples of each, as well as, for convenience, the last valid samples of each (after conditioning on the modal <code>G</code> and <code>Q</code> values, and accounting for label switching, and rotational invariance via Procrustes rotation).
</p>


<h3>Note</h3>

<p>For the <code>"IMIFA"</code>, <code>"IMFA"</code>, <code>"OMIFA"</code>, and <code>"OMFA"</code> methods, the retained mixing proportions are renormalised after conditioning on the modal <code>G</code>. This is especially necessary for the computation of the <code>error.metrics</code>, just note that the values on which posterior inference are conducted will ever so slightly differ from the actually sampled values.
</p>
<p>Due to the way the offline label-switching correction is performed, different runs of this function may give <em>very slightly</em> different results in terms of the cluster labellings (and by extension the parameters, which are permuted in the same way), but only if the chain was run for an extremely small number of iterations, well below the number required for convergence, and samples of the cluster labels match poorly across iterations (particularly if the number of clusters suggested by those sampled labels is high).
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code>, <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+Zsimilarity">Zsimilarity</a></code>, <code><a href="#topic+scores_MAP">scores_MAP</a></code>, <code><a href="#topic+sim_IMIFA_model">sim_IMIFA_model</a></code>, <code><a href="#topic+Procrustes">Procrustes</a></code>, <code><a href="stats.html#topic+varimax">varimax</a></code>, <code><a href="Matrix.html#topic+norm">norm</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+storeControl">storeControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(coffee)
# data(olive)

# Run a MFA model on the coffee data over a range of clusters and factors.
# simMFAcoffee  &lt;- mcmc_IMIFA(coffee, method="MFA", range.G=2:3, range.Q=0:3, n.iters=1000)

# Accept all defaults to extract the optimal model.
# resMFAcoffee  &lt;- get_IMIFA_results(simMFAcoffee)

# Instead let's get results for a 3-cluster model, allowing Q be chosen by aic.mcmc.
# resMFAcoffee2 &lt;- get_IMIFA_results(simMFAcoffee, G=3, criterion="aic.mcmc")

# Run an IMIFA model on the olive data, accepting all defaults.
# simIMIFAolive &lt;- mcmc_IMIFA(olive, method="IMIFA", n.iters=10000)

# Extract optimum results
# Estimate G &amp; Q by the median of their posterior distributions
# Construct 90% credible intervals and try to return the similarity matrix.
# resIMIFAolive &lt;- get_IMIFA_results(simIMIFAolive, G.meth="median", Q.meth="median",
#                                    conf.level=0.9, z.avgsim=TRUE)
# summary(resIMIFAolive)

# Simulate new data from the above model
# newdata       &lt;- sim_IMIFA_model(resIMIFAolive)

# Fit an IFA model without adaptation and examine results with and without post-hoc adaptation
# Use the "SC" criterion for determining the number of active factors
# simIFAnoadapt   &lt;- mcmc_IMIFA(olive, method="IFA", n.iters=10000, adapt=FALSE)
# resIFAnoadapt   &lt;- get_IMIFA_results(simIFAnoadapt)
# resIFApostadapt &lt;- get_IMIFA_results(simIFAnoadapt, adapt=TRUE, active.crit="SC")

# Compare to an IFA model with adaptive Gibbs sampling
# simIFAadapt     &lt;- mcmc_IMIFA(coffee, method="IFA", n.iters=10000, active.crit="BD")
# resIFAadapt     &lt;- get_IMIFA_results(simIFAadapt)
# plot(resIFAnoadapt, "GQ")
# plot(resIFApostadapt, "GQ")
# plot(resIFAadapt, "GQ")
</code></pre>

<hr>
<h2 id='gumbel_max'>Simulate Cluster Labels from Unnormalised Log-Probabilities using the Gumbel-Max Trick</h2><span id='topic+gumbel_max'></span>

<h3>Description</h3>

<p>Samples cluster labels for N observations from G clusters efficiently using log-probabilities and the so-called Gumbel-Max trick, without requiring that the log-probabilities be normalised; thus redundant computation can be avoided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gumbel_max(probs,
           slice = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gumbel_max_+3A_probs">probs</code></td>
<td>
<p>An N x G matrix of unnormalised probabilities on the log scale, where N is he number of observations that require labels to be sampled and G is the number of active clusters s.t. sampled labels can take values in <code>1:G</code>. Typically <code>N &gt; G</code>.</p>
</td></tr>
<tr><td><code id="gumbel_max_+3A_slice">slice</code></td>
<td>
<p>A logical indicating whether or not the indicator correction for slice sampling has been applied to <code>probs</code>. Defaults to <code>FALSE</code> but is <code>TRUE</code> for the <code>"IMIFA"</code> and <code>"IMFA"</code> methods under <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. Details of this correction are given in Murphy et. al. (2020). When set to <code>TRUE</code>, this results in a speed-improvement when <code>probs</code> contains non-finite values (e.g. <code>-Inf</code>, corresponding to zero on the probability scale).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computation takes place on the log scale for stability/underflow reasons (to ensure negligible probabilities won't cause computational difficulties); in any case, many functions for calculating multivariate normal densities already output on the log scale.
</p>


<h3>Value</h3>

<p>A vector of N sampled cluster labels, with the largest label no greater than G.
</p>


<h3>Note</h3>

<p>Though the function is available for standalone use, note that no checks take place, in order to speed up repeated calls to the function inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.
</p>
<p>If the normalising constant is required for another reason, e.g. to compute the log-likelihood, it can be calculated by summing the output obtained by calling <code><a href="matrixStats.html#topic+rowLogSumExps">rowLogSumExps</a></code> on <code>probs</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Yellott, J. I. Jr. (1977) The relationship between Luce's choice axiom, Thurstone's theory of comparative judgment, and the double exponential distribution, <em>Journal of Mathematical Psychology</em>, 15(2): 109-144.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="matrixStats.html#topic+rowLogSumExps">rowLogSumExps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create weights for 3 components
  G         &lt;- 3
  weights   &lt;- seq_len(G)

# Call gumbel_max() repeatedly to obtain samples of the labels, zs
  iters     &lt;- 10000
  zs        &lt;- replicate(iters, gumbel_max(probs=log(weights)))

# Compare answer to the normalised weights
  tabulate(zs, nbins=G)/iters
  (normalised &lt;- as.numeric(weights/sum(weights)))

# Simulate a matrix of Dirichlet weights &amp; the associated vector of N labels
  N       &lt;- 400
  G       &lt;- 8
  sizes   &lt;- seq(from=85, to=15, by=-10)
  weights &lt;- matrix(rDirichlet(N * G, alpha=1, nn=sizes), byrow=TRUE, nrow=N, ncol=G)
  (zs     &lt;- gumbel_max(probs=log(weights)))
</code></pre>

<hr>
<h2 id='heat_legend'>Add a colour key legend to heatmap plots</h2><span id='topic+heat_legend'></span>

<h3>Description</h3>

<p>Using only base graphics, this function appends a colour key legend for heatmaps produced by, for instance, <code><a href="#topic+plot_cols">plot_cols</a></code> or <code><a href="graphics.html#topic+image">image</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heat_legend(data,
            cols = NULL,
            breaks = NULL,
            cex.lab = 1,
            ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heat_legend_+3A_data">data</code></td>
<td>
<p>Either the data with which the heatmap was created or a vector containing its minimum and maximum values. Missing values are ignored.</p>
</td></tr>
<tr><td><code id="heat_legend_+3A_cols">cols</code></td>
<td>
<p>The colour palette used when the heatmap was created. By default, the same <code><a href="viridisLite.html#topic+viridis">viridis</a></code> default as in <code><a href="#topic+mat2cols">mat2cols</a></code> is used. Will be checked for validity by <code><a href="#topic+is.cols">is.cols</a></code>.</p>
</td></tr>
<tr><td><code id="heat_legend_+3A_breaks">breaks</code></td>
<td>
<p>Optional argument giving the break-points for the axis labels.</p>
</td></tr>
<tr><td><code id="heat_legend_+3A_cex.lab">cex.lab</code></td>
<td>
<p>Magnification of axis annotation, indicating the amount by which plotting text and symbols should be scaled relative to the default of 1.</p>
</td></tr>
<tr><td><code id="heat_legend_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Modifies an existing plot by adding a colour key legend.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+plot_cols">plot_cols</a></code>, <code><a href="#topic+mat2cols">mat2cols</a></code>, <code><a href="#topic+is.cols">is.cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a matrix and plot it with a legend
data &lt;- matrix(rnorm(50), nrow=10, ncol=5)
cols &lt;- heat.colors(12)[12:1]
par(mar=c(5.1, 4.1, 4.1, 3.1))

plot_cols(mat2cols(data, col=cols))
heat_legend(data, cols); box(lwd=2)
</code></pre>

<hr>
<h2 id='IMIFA_news'>Show the NEWS file</h2><span id='topic+IMIFA_news'></span>

<h3>Description</h3>

<p>Show the <code>NEWS</code> file of the <code>IMIFA</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IMIFA_news()
</code></pre>


<h3>Value</h3>

<p>The <code>IMIFA</code> <code>NEWS</code> file, provided the session is interactive.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>IMIFA_news()
</code></pre>

<hr>
<h2 id='is.cols'>Check for Valid Colours</h2><span id='topic+is.cols'></span>

<h3>Description</h3>

<p>Checks if the supplied vector contains valid colours.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cols(cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.cols_+3A_cols">cols</code></td>
<td>
<p>A vector of colours, usually as a character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of length <code>length(cols)</code> which is <code>TRUE</code> for entries which are valid colours and <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>all(is.cols(1:5))

all(is.cols(heat.colors(30)))

any(!is.cols(c("red", "green", "aquamarine")))
</code></pre>

<hr>
<h2 id='is.posi_def'>Check Positive-(Semi)definiteness of a matrix</h2><span id='topic+is.posi_def'></span>

<h3>Description</h3>

<p>Tests whether all eigenvalues of a symmetric matrix are positive (or strictly non-negative) to check for positive-definiteness and positive-semidefiniteness, respectively. If the supplied matrix doesn't satisfy the test, the nearest matrix which does can optionally be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.posi_def(x,
            tol = NULL,
            semi = FALSE,
            make = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.posi_def_+3A_x">x</code></td>
<td>
<p>A matrix, assumed to be real and symmetric.</p>
</td></tr>
<tr><td><code id="is.posi_def_+3A_tol">tol</code></td>
<td>
<p>Tolerance for singular values and for absolute eigenvalues - only those with values larger than tol are considered non-zero.
</p>
<p>(default: tol = <code>max(dim(x))*max(E)*.Machine$double.eps</code>, where <code>E</code> is the vector of absolute eigenvalues).</p>
</td></tr>
<tr><td><code id="is.posi_def_+3A_semi">semi</code></td>
<td>
<p>Logical switch to test for positive-semidefiniteness when <code>TRUE</code> or positive-definiteness when <code>FALSE</code> (the default).</p>
</td></tr>
<tr><td><code id="is.posi_def_+3A_make">make</code></td>
<td>
<p>Logical switch to return the nearest matrix which satisfies the test - if the test has been passed, this is of course just <code>x</code> itself, otherwise the nearest positive-(semi)definite matrix. Note that for reasons due to finite precision arithmetic, finding the nearest positive-definite and nearest positive-semidefinite matrices are effectively equivalent tasks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>isTRUE(make)</code>, a list with two components:
</p>
<table>
<tr><td><code>check</code></td>
<td>
<p>A logical value indicating whether the matrix satisfies the test.</p>
</td></tr>
<tr><td><code>X.new</code></td>
<td>
<p>The nearest matrix which satisfies the test (which may just be the input matrix itself.)</p>
</td></tr>
</table>
<p>Otherwise, only the logical value indicating whether the matrix satisfies the test is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x    &lt;- cov(matrix(rnorm(100), nrow=10, ncol=10))
is.posi_def(x)                                           #FALSE
is.posi_def(x, semi=TRUE)                                #TRUE

Xnew &lt;- is.posi_def(x, semi=FALSE, make=TRUE)$X.new
identical(x, Xnew)                                       #FALSE
identical(x, is.posi_def(x, semi=TRUE, make=TRUE)$X.new) #TRUE
</code></pre>

<hr>
<h2 id='Ledermann'>Ledermann Bound</h2><span id='topic+Ledermann'></span>

<h3>Description</h3>

<p>Returns the maximum number of latent factors in a factor analysis model for data of dimension <code>P</code> which actually achieves dimension reduction in terms of the number of covariance parameters. This Ledermann bound is given by the largest integer smaller than or equal to the solution <code class="reqn">k</code> of <code class="reqn">(M - k)^2 \geq M + k</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ledermann(P,
          isotropic = FALSE,
          int = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ledermann_+3A_p">P</code></td>
<td>
<p>Integer number of variables in data set. This argument is vectorised.</p>
</td></tr>
<tr><td><code id="Ledermann_+3A_isotropic">isotropic</code></td>
<td>
<p>Logical indicating whether uniquenesses are constrained to be isotropic, in which case the bound is simply <code class="reqn">P-1</code>. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Ledermann_+3A_int">int</code></td>
<td>
<p>Logical indicating if the result should be returned as an integer by applying the <code><a href="base.html#topic+floor">floor</a></code> function. Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ledermann bound when <code>istropic</code> is <code>FALSE</code> is given by <code class="reqn">P + 0.5\left(1 - \sqrt{8P  + 1}\right)</code>.
</p>


<h3>Value</h3>

<p>The Ledermann bound, a non-negative integer obtained using <code>floor</code>, or a vector of <code>length(P)</code> such bounds.
</p>


<h3>Note</h3>

<p>It has also been argued that the number of factors should not exceed <code>floor((P - 1)/2)</code>, which is a necessarily stricter condition.
</p>


<h3>References</h3>

<p>Anderson, T. W. and Rubin, H. (1956) Statistical inference in factor analysis. In Neyman, J. (Ed.), <em>Proceedings of the Third Berkeley Symposium on Mathematical Statistics and Probability</em>, Volume 3.5: Contributions to Econometrics, Industrial Research, and Psychometry, University of California Press, Berkeley, CA, U.S.A., pp. 111-150.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Ledermann(c(25, 50, 100))
floor((c(25, 50, 100) - 1) / 2) # stricter bounds

data(olive)
P &lt;- ncol(olive[,-(1:2)])
Ledermann(P)
Ledermann(P, int=FALSE)
floor((P - 1)/2) # stricter bound
</code></pre>

<hr>
<h2 id='ltrgamma'>Left Truncated Gamma Distributions</h2><span id='topic+ltrgamma'></span><span id='topic+rltrgamma'></span><span id='topic+exp_ltrgamma'></span>

<h3>Description</h3>

<p>Functions to draw pseudo-random numbers from, or calculate the expectation of, left-truncated gamma distributions (see Details below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rltrgamma(n,
          shape,
          rate = 1,
          trunc = 1)

exp_ltrgamma(shape,
             rate = 1,
             trunc = 1,
             inverse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ltrgamma_+3A_n">n</code></td>
<td>
<p>Number of observations to generate.</p>
</td></tr>
<tr><td><code id="ltrgamma_+3A_shape">shape</code></td>
<td>
<p>Shape parameter for the desired gamma distribution. Must be strictly positive</p>
</td></tr>
<tr><td><code id="ltrgamma_+3A_rate">rate</code></td>
<td>
<p>Rate parameter for the desired gamma distribution. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="ltrgamma_+3A_trunc">trunc</code></td>
<td>
<p>The point of left truncation (corresponding to <code class="reqn">\tau</code> below). Defaults to <code>1</code>. Must be non-negative. When <code>inverse</code> is <code>TRUE</code>, this becomes the point of <em>right</em> truncation.</p>
</td></tr>
<tr><td><code id="ltrgamma_+3A_inverse">inverse</code></td>
<td>
<p>A logical indicating whether to calculate the expectation for a right-truncated <em>inverse</em> gamma distribution instead of a left-truncated gamma distribution. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The left-truncated gamma distribution has PDF:
</p>
<p style="text-align: center;"><code class="reqn">f(x|\alpha, \beta) = \frac{\beta^\alpha}{(\Gamma(\alpha)-\Gamma(\alpha, \tau\beta))}x^{\alpha-1}e^{-x\beta}</code>
</p>

<p>for <code class="reqn">0\le\tau\le x</code>, and <code class="reqn">\min(\tau,\beta) &gt; 0</code>, where <code class="reqn">\alpha</code> and <code class="reqn">\beta</code> are the <code>shape</code> and <code>rate</code> parameters, respectively, <code class="reqn">\tau</code> is the cutoff point at which <code>trunc</code>ation occurs, and <code class="reqn">\Gamma(\alpha, \tau\beta)</code> is the upper incomplete gamma function.
</p>


<h3>Value</h3>

<p>For <code>rltrgamma</code>, a vector of length <code>n</code> giving draws from the left-truncated gamma distribution with the specified <code>shape</code> and <code>rate</code> parameters, and truncation point <code>trunc</code>.
</p>
<p>For <code>exp_ltrgamma</code>, the expected value of a left-truncated (inverse) gamma distribution.
</p>


<h3>Note</h3>

<p><code>rltrgamma</code> is invoked internally for the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code> models to draw column shrinkage parameters for all but the first loadings column under the MGP prior when <code>truncated=TRUE</code> (which is <strong>not</strong> the default) is supplied to <code><a href="#topic+mgpControl">mgpControl</a></code>, at the expense of slightly longer run times. <code>exp_ltrgamma</code> is used within <code><a href="#topic+MGP_check">MGP_check</a></code> to check the validity of the MGP hyperparameters when <code>truncated=TRUE</code> (which is again, <strong>not</strong> the default). Both functions always assume <code>trunc=1</code> for these internal usages.
</p>
<p>Note also that no arguments are recycled, i.e. all arguments must be of length <code>1</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Dagpunar, J. S. (1978) Sampling of variates from a truncated gamma distribution, <em>Statistical Computation and Simulation</em>, 8(1): 59-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+MGP_check">MGP_check</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate left-truncated Ga(3.1, 2.1, 1) variates
rltrgamma(n=10, shape=3.1, rate=2.1)

# Calculate the expectation of a Ga(3.1, 2.1, 1) distribution
exp_ltrgamma(shape=3.1, rate=2.1)

# Calculate the expectation of an inverse gamma distribution right-truncated at 2
exp_ltrgamma(shape=3.1, rate=2.1, trunc=2, inverse=TRUE)
</code></pre>

<hr>
<h2 id='mat2cols'>Convert a numeric matrix to colours</h2><span id='topic+mat2cols'></span>

<h3>Description</h3>

<p>Converts a matrix to a hex colour code representation for plotting using <code><a href="#topic+plot_cols">plot_cols</a></code>. Used internally by <code><a href="#topic+plot.Results_IMIFA">plot.Results_IMIFA</a></code> for plotting posterior mean loadings heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2cols(mat,
         cols = NULL,
         compare = FALSE,
         byrank = FALSE,
         breaks = NULL,
         na.col = "#808080FF",
         transparency = 1,
         ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2cols_+3A_mat">mat</code></td>
<td>
<p>Either a matrix or, when <code>compare</code> is <code>TRUE</code>, a list of matrices.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_cols">cols</code></td>
<td>
<p>The colour palette to be used. The default palette uses <code><a href="viridisLite.html#topic+viridis">viridis</a></code>. Will be checked for validity by <code><a href="#topic+is.cols">is.cols</a></code>.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_compare">compare</code></td>
<td>
<p>Logical switch used when desiring comparable colour representations (usually for comparable heat maps) across multiple matrices. Ensures plots will be calibrated to a common colour scale so that, for instance, the colour on the heat map of an entry valued at 0.7 in Matrix A corresponds exactly to the colour of a similar value in Matrix B. When <code>TRUE</code>, <code>mat</code> must be supplied as a list of matrices, which must have either the same number of rows, or the same number of columns.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_byrank">byrank</code></td>
<td>
<p>Logical indicating whether to convert the matrix itself or the sample ranks of the values therein. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_breaks">breaks</code></td>
<td>
<p>Number of gradations in colour to use. Defaults to <code>length(cols)</code>. Alternatively, a vector of breakpoints for use with <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_na.col">na.col</code></td>
<td>
<p>Colour to be used to represent missing data. Will be checked for validity by <code><a href="#topic+is.cols">is.cols</a></code>.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_transparency">transparency</code></td>
<td>
<p>A factor in [0, 1] modifying the opacity for overplotted lines. Defaults to 1 (i.e. no transparency). Only relevant when <code>cols</code> is not supplied, otherwise the supplied <code>cols</code> must already be adjusted for transparency.</p>
</td></tr>
<tr><td><code id="mat2cols_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of hex colour code representations, or a list of such matrices when <code>compare</code> is <code>TRUE</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_cols">plot_cols</a></code>, <code><a href="#topic+heat_legend">heat_legend</a></code>, <code><a href="#topic+is.cols">is.cols</a></code>, <code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a colour matrix using mat2cols()
mat      &lt;- matrix(rnorm(100), nrow=10, ncol=10)
mat[2,3] &lt;- NA
cols     &lt;- heat.colors(12)[12:1]
(matcol  &lt;- mat2cols(mat, cols=cols))

# Use plot_cols() to visualise the colours matrix
par(mar=c(5.1, 4.1, 4.1, 3.1))
plot_cols(matcol)

# Add a legend using heat_legend()
heat_legend(mat, cols=cols); box(lwd=2)

# Try comparing heat maps of multiple matrices
mat1     &lt;- cbind(matrix(rnorm(100, sd=c(4,2)),   nr=50, nc=2, byrow=TRUE), 0.1)
mat2     &lt;- cbind(matrix(rnorm(150, sd=c(7,5,3)), nr=50, nc=3, byrow=TRUE), 0.1)
mat3     &lt;- cbind(matrix(rnorm(50,  sd=1),        nr=50, nc=1, byrow=TRUE), 0.1)
mats     &lt;- list(mat1, mat2, mat3)
colmats  &lt;- mat2cols(mats, cols=cols, compare=TRUE)
par(mfrow=c(2, 3), mar=c(1, 2, 1, 2))

# Use common palettes (top row)
plot_cols(colmats[[1]]); heat_legend(range(mats), cols=cols); box(lwd=2)
plot_cols(colmats[[2]]); heat_legend(range(mats), cols=cols); box(lwd=2)
plot_cols(colmats[[3]]); heat_legend(range(mats), cols=cols); box(lwd=2)

# Use uncommon palettes (bottom row)
plot_cols(mat2cols(mat1, cols=cols)); heat_legend(range(mat1), cols=cols); box(lwd=2)
plot_cols(mat2cols(mat2, cols=cols)); heat_legend(range(mat2), cols=cols); box(lwd=2)
plot_cols(mat2cols(mat3, cols=cols)); heat_legend(range(mat3), cols=cols); box(lwd=2)
</code></pre>

<hr>
<h2 id='mcmc_IMIFA'>Adaptive Gibbs Sampler for Nonparametric Model-based Clustering using models from the IMIFA family</h2><span id='topic+mcmc_IMIFA'></span><span id='topic+print.IMIFA'></span><span id='topic+summary.IMIFA'></span>

<h3>Description</h3>

<p>Carries out Gibbs sampling for all models from the IMIFA family, facilitating model-based clustering with dimensionally reduced factor-analytic covariance structures, with automatic estimation of the number of clusters and cluster-specific factors as appropriate to the method employed. Factor analysis with one group (FA/IFA), finite mixtures (MFA/MIFA), overfitted mixtures (OMFA/OMIFA), infinite factor models which employ the multiplicative gamma process (MGP) shrinkage prior (IFA/MIFA/OMIFA/IMIFA), and infinite mixtures which employ Pitman-Yor / Dirichlet Process Mixture Models (IMFA/IMIFA) are all provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_IMIFA(dat,
           method = c("IMIFA", "IMFA",
                      "OMIFA", "OMFA",
                      "MIFA", "MFA",
                      "IFA", "FA",
                      "classify"),
           range.G = NULL,
           range.Q = NULL,
           MGP = mgpControl(...),
           BNP = bnpControl(...),
           mixFA = mixfaControl(...),
           alpha = NULL,
           storage = storeControl(...),
           ...)

## S3 method for class 'IMIFA'
print(x,
      ...)

## S3 method for class 'IMIFA'
summary(object,
        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_IMIFA_+3A_dat">dat</code></td>
<td>
<p>A matrix or data frame such that rows correspond to observations (<code>N</code>) and columns correspond to variables (<code>P</code>). Non-numeric variables will be discarded if they are explicitly coded as factors or ordinal factors; otherwise they will be treated as though they were continuous. Rows with missing entries will be also be automatically removed.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_method">method</code></td>
<td>
<p>An acronym for the type of model to fit where:
</p>

<dl>
<dt><code>"FA"</code></dt><dd><p>Factor Analysis</p>
</dd>
<dt><code>"IFA"</code></dt><dd><p>Infinite Factor Analysis</p>
</dd>
<dt><code>"MFA"</code></dt><dd><p>Mixtures of Factor Analysers</p>
</dd>
<dt><code>"MIFA"</code></dt><dd><p>Mixtures of Infinite Factor Analysers</p>
</dd>
<dt><code>"OMFA"</code></dt><dd><p>Overfitted Mixtures of Factor Analysers</p>
</dd>
<dt><code>"OMIFA"</code></dt><dd><p>Overfitted Mixtures of Infinite Factor Analysers</p>
</dd>
<dt><code>"IMFA"</code></dt><dd><p>Infinite Mixtures of Factor Analysers</p>
</dd>
<dt><code>"IMIFA"</code></dt><dd><p>Infinite Mixtures of Infinite Factor Analysers</p>
</dd>
</dl>

<p>In principle, of course, one could overfit the <code>"MFA"</code> or <code>"MIFA"</code> models, but it is recommend to use the corresponding model options which begin with &lsquo;O&rsquo; instead. Note that the <code>"classify"</code> method is not yet implemented.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_range.g">range.G</code></td>
<td>
<p>Depending on the method employed, either the range of values for the number of clusters, or the conservatively high starting value for the number of clusters. Defaults to (and must be!) <code>1</code> for the <code>"FA"</code> and <code>"IFA"</code> methods. For the <code>"MFA"</code> and <code>"MIFA"</code> models this is to be given as a range of candidate models to explore. For the <code>"OMFA"</code>, <code>"OMIFA"</code>, <code>"IMFA"</code>, and <code>"IMIFA"</code> models, this is the conservatively high number of clusters with which the chain is to be initialised (default = <code>max(25, ceiling(3 * log(N)))</code> for large N, or <code>min(N-1, ceiling(3 * log(N)))</code> for small N&lt;=50).
</p>
<p>For the <code>"OMFA"</code>, and <code>"OMIFA"</code> models this upper limit remains fixed for the entire length of the chain; the upper limit for the for the <code>"IMFA"</code> and <code>"IMIFA"</code> models can be specified via <code>trunc.G</code> (see <code><a href="#topic+bnpControl">bnpControl</a></code>), which must satisfy <code>range.G &lt;= trunc.G &lt; N</code>.
</p>
<p>If <code>length(range.G) * length(range.Q)</code> is large, consider not storing unnecessary parameters (via <code><a href="#topic+storeControl">storeControl</a></code>), or breaking up the range of models to be explored into chunks and sending each chunk to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> separately.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_range.q">range.Q</code></td>
<td>
<p>Depending on the method employed, either the range of values for the number of latent factors or, for methods ending in IFA, the conservatively high starting value for the number of cluster-specific factors, in which case the default starting value is <code>round(3 * log(P))</code>.
</p>
<p>For methods ending in IFA, different clusters can be modelled using different numbers of latent factors (incl. zero); for methods not ending in IFA it is possible to fit zero-factor models, corresponding to simple diagonal covariance structures. For instance, fitting the <code>"IMFA"</code> model with <code>range.Q=0</code> corresponds to a vanilla Pitman-Yor / Dirichlet Process Mixture Model.
</p>
<p>If <code>length(range.G) * length(range.Q)</code> is large, consider not storing unnecessary parameters (via <code><a href="#topic+storeControl">storeControl</a></code>), or breaking up the range of models to be explored into chunks and sending each chunk to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.
</p>
<p>See <code><a href="#topic+Ledermann">Ledermann</a></code> for bounds on <code>range.Q</code>; this is useful in both the finite factor and infinite factor settings, as one may wish to ensure the fixed number of factors, or upper limits on the number of factors, respectively, respects this bound to yield indentifiable solutions, particularly in low-dimensional settings. It has also been argued that <code>range.Q</code> should not exceed <code>floor((P - 1)/2)</code>. In both cases, a warning is returned.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_mgp">MGP</code></td>
<td>
<p>A list of arguments pertaining to the multiplicative gamma process (MGP) shrinkage prior and adaptive Gibbs sampler (AGS). For use with the infinite factor models <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code> only. Defaults are set by a call to <code><a href="#topic+mgpControl">mgpControl</a></code>, with further checking of validity by <code><a href="#topic+MGP_check">MGP_check</a></code> (though arguments can also be supplied here directly).</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_bnp">BNP</code></td>
<td>
<p>A list of arguments pertaining to the Bayesian Nonparametric Pitman-Yor / Dirichlet process priors, for use with the infinite mixture models <code>"IMFA"</code> and <code>"IMIFA"</code>, or select arguments related to the Dirichlet concentration parameter for the overfitted mixtures <code>"OMFA"</code> and <code>"OMIFA"</code>. Defaults are set by a call to <code><a href="#topic+bnpControl">bnpControl</a></code> (though arguments can also be supplied here directly).</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_mixfa">mixFA</code></td>
<td>
<p>A list of arguments pertaining to <em>all other</em> aspects of model fitting, e.g. MCMC settings, cluster initialisation, and hyperparameters common to every <code>method</code> in the <code>IMIFA</code> family. Defaults are set by a call to <code><a href="#topic+mixfaControl">mixfaControl</a></code> (though arguments can also be supplied here directly).</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_alpha">alpha</code></td>
<td>
<p>Depending on the method employed, either the hyperparameter of the Dirichlet prior for the cluster mixing proportions, or the Pitman-Yor / Dirichlet process concentration parameter. Defaults to <code>1</code> for the finite mixture models <code>"MFA"</code> and <code>"MIFA"</code>, and must be a strictly positive scalar. Not relevant for the <code>"FA"</code> and <code>"IFA"</code> methods.
</p>

<dl>
<dt>Under the <code>"IMFA"</code> and <code>"IMIFA"</code> models:</dt><dd><p><code>alpha</code> defaults to a simulation from the prior if <code>learn.alpha</code> is <code>TRUE</code>, otherwise <code>alpha</code> <em>must</em> be specified. Must be positive, unless non-zero <code>discount</code> is supplied or <code>learn.d=TRUE</code> (the default), in which case it must be greater than <code>-discount</code>. Under certain conditions, <code>alpha</code> can remain fixed at <code>0</code> (see <code><a href="#topic+bnpControl">bnpControl</a></code>). Additionally, when <code>discount</code> is negative, <code>alpha</code> must be a positive integer multiple of <code>abs(discount)</code> (default=<code>range.G * abs(discount)</code>).</p>
</dd>
<dt>Under the <code>"OMFA"</code> and <code>"OMIFA"</code> models:</dt><dd><p><code>alpha</code> defaults to a simulation from the prior if <code>learn.alpha</code> is <code>TRUE</code>, otherwise <code>alpha</code> defaults to <code>0.5/range.G</code>. If supplied, <code>alpha</code> must be positive, and you are supplying the numerator of <code>alpha/range.G</code>.
</p>
<p>If <code>alpha</code> remains fixed (i.e. <code>learn.alpha=FALSE</code>), <code>alpha</code> should be less than half the dimension (per cluster!) of the free parameters of the smallest model considered in order to ensure superfluous clusters are emptied (for <code>"OMFA"</code>, this corresponds to the smallest <code>range.Q</code>; for <code>"OMIFA"</code>, this corresponds to a zero-factor model) [see: <code><a href="#topic+PGMM_dfree">PGMM_dfree</a></code> and Rousseau and Mengersen (2011)].</p>
</dd>
</dl>

<p>See <code><a href="#topic+bnpControl">bnpControl</a></code> for further details of specifying <code>alpha</code> or specifying a prior for <code>alpha</code> under the <code>"IMFA"</code>, <code>"IMIFA"</code>, <code>"OMFA"</code>, or <code>"OMIFA"</code> methods.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_storage">storage</code></td>
<td>
<p>A vector of named logical indicators governing storage of parameters of interest for all models in the IMIFA family. Defaults are set by a call to <code><a href="#topic+storeControl">storeControl</a></code>. It may be useful not to store certain parameters if memory is an issue.</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_...">...</code></td>
<td>
<p>An alternative means of passing control parameters directly via the named arguments of <code><a href="#topic+mixfaControl">mixfaControl</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+bnpControl">bnpControl</a></code>, and <code><a href="#topic+storeControl">storeControl</a></code>. Do not pass the output from calls to those functions here!</p>
</td></tr>
<tr><td><code id="mcmc_IMIFA_+3A_x">x</code>, <code id="mcmc_IMIFA_+3A_object">object</code></td>
<td>
<p>Object of class <code>"IMIFA"</code>, for the <code>print.IMIFA</code> and <code>summary.IMIFA</code> functions, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a raw object of class <code>"IMIFA"</code> from which the optimal/modal model can be extracted by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>. Dedicated <code>print</code> and <code>summary</code> functions exist for objects of class <code>"IMIFA"</code>.
</p>


<h3>Value</h3>

<p>A list of lists of lists of class <code>"IMIFA"</code> to be passed to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>. If the returned object is <code>x</code>, candidate models are accessible via subsetting, where <code>x</code> is of the following form:
</p>
<p><code>x[[1:length(range.G)]][[1:length(range.Q)]]</code>.
</p>
<p>However, these objects of class &quot;IMIFA&quot; should rarely if ever be manipulated by hand - use of the <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> function is <em>strongly</em> advised.
</p>


<h3>Note</h3>

<p>Further control over the specification of advanced function arguments can be obtained with recourse to the following functions:
</p>

<dl>
<dt><strong><code><a href="#topic+mgpControl">mgpControl</a></code></strong></dt><dd><p>Supply arguments (with defaults) pertaining to the multiplicative gamma process (MGP) shrinkage prior and adaptive Gibbs sampler (AGS). For use with the infinite factor models <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code> only.</p>
</dd>
<dt><strong><code><a href="#topic+bnpControl">bnpControl</a></code></strong></dt><dd><p>Supply arguments (with defaults) pertaining to the Bayesian Nonparametric Pitman-Yor / Dirichlet process priors, for use with the infinite mixture models <code>"IMFA"</code> and <code>"IMIFA"</code>. Certain arguments related to the Dirichlet concentration parameter for the overfitted mixtures <code>"OMFA"</code> and <code>"OMIFA"</code> can be supplied in this manner also.</p>
</dd>
<dt><strong><code><a href="#topic+mixfaControl">mixfaControl</a></code></strong></dt><dd><p>Supply arguments (with defaults) pertaining to <em>all other</em> aspects of model fitting (e.g. MCMC settings, cluster initialisation, and hyperparameters common to every <code>method</code> in the <code>IMIFA</code> family.</p>
</dd>
<dt><strong><code><a href="#topic+storeControl">storeControl</a></code></strong></dt><dd><p>Supply logical indicators governing storage of parameters of interest for all models in the IMIFA family. It may be useful not to store certain parameters if memory is an issue (e.g. for large data sets or for a large number of MCMC iterations after burnin and thinning).</p>
</dd>
</dl>

<p>Note however that the named arguments of these functions can also be supplied directly. Parameter starting values are obtained by simulation from the relevant prior distribution specified in these control functions, though initial means and mixing proportions are computed empirically.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Bhattacharya, A. and Dunson, D. B. (2011) Sparse Bayesian infinite factor models, <em>Biometrika</em>, 98(2): 291-306.
</p>
<p>Kalli, M., Griffin, J. E. and Walker, S. G. (2011) Slice sampling mixture models, <em>Statistics and Computing</em>, 21(1): 93-105.
</p>
<p>Rousseau, J. and Mengersen, K. (2011) Asymptotic Behaviour of the posterior distribution in overfitted mixture models, <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 73(5): 689-710.
</p>
<p>McNicholas, P. D. and Murphy, T. B. (2008) Parsimonious Gaussian mixture models, <em>Statistics and Computing</em>, 18(3): 285-296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="#topic+mixfaControl">mixfaControl</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+bnpControl">bnpControl</a></code>, <code><a href="#topic+storeControl">storeControl</a></code>, <code><a href="#topic+Ledermann">Ledermann</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(olive)
# data(coffee)

# Fit an IMIFA model to the olive data. Accept all defaults.
# simIMIFA &lt;- mcmc_IMIFA(olive, method="IMIFA")
# summary(simIMIFA)

# Fit an IMIFA model assuming a Pitman-Yor prior.
# Control the balance between the DP and PY priors using the kappa parameter.
# simPY    &lt;- mcmc_IMIFA(olive, method="IMIFA", kappa=0.75)
# summary(simPY)

# Fit a MFA model to the scaled olive data, with isotropic uniquenesses (i.e. MPPCA).
# Allow diagonal covariance as a special case where range.Q = 0.
# Don't store the scores. Accept all other defaults.
# simMFA   &lt;- mcmc_IMIFA(olive, method="MFA", n.iters=10000, range.G=3:6, range.Q=0:3,
#                        score.switch=FALSE, centering=FALSE, uni.type="isotropic")

# Fit a MIFA model to the centered &amp; scaled coffee data, w/ cluster labels initialised by K-Means.
# Note that range.Q doesn't need to be specified. Allow IFA as a special case where range.G=1.
# simMIFA  &lt;- mcmc_IMIFA(coffee, method="MIFA", n.iters=10000, range.G=1:3, z.init="kmeans")

# Fit an IFA model to the centered and pareto scaled olive data.
# Note that range.G doesn't need to be specified. We can optionally supply a range.Q starting value.
# Enforce additional shrinkage using alpha.d1, alpha.d2, prop, and eps (via mgpControl()).
# simIFA   &lt;- mcmc_IMIFA(olive, method="IFA", n.iters=10000, range.Q=4, scaling="pareto",
#                        alpha.d1=2.5, alpha.d2=4, prop=0.6, eps=0.12)

# Fit an OMIFA model to the centered &amp; scaled coffee data.
# Supply a sufficiently small alpha value. Try varying other hyperparameters.
# Accept the default value for the starting number of factors,
# but supply a value for the starting number of clusters.
# Try constraining uniquenesses to be common across both variables and clusters.
# simOMIFA &lt;- mcmc_IMIFA(coffee, method="OMIFA", range.G=10, psi.alpha=3,
#                        phi.hyper=c(2, 1), alpha=0.8, uni.type="single")
</code></pre>

<hr>
<h2 id='MGP_check'>Check the validity of Multiplicative Gamma Process (MGP) hyperparameters</h2><span id='topic+MGP_check'></span>

<h3>Description</h3>

<p>Checks the hyperparameters for the multiplicative gamma process (MGP) shrinkage prior in order to ensure that the property of cumulative shrinkage (in expectation) holds, i.e. checks whether growing mass is assigned to small neighbourhoods of zero as the column index increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MGP_check(ad1,
          ad2,
          Q = 3L,
          phi.shape = NULL,
          phi.rate = NULL,
          sigma.shape = NULL,
          sigma.rate = NULL,
          bd1 = 1,
          bd2 = 1,
          truncated = FALSE,
          inverse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MGP_check_+3A_ad1">ad1</code>, <code id="MGP_check_+3A_ad2">ad2</code></td>
<td>
<p>Shape hyperparameters for <code class="reqn">\delta_1</code> and <code class="reqn">\delta_k \forall k\ge 2</code>, respectively.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_q">Q</code></td>
<td>
<p>Number of latent factors. Defaults to <code>3</code>, which is enough to check if the cumulative shrinkage property holds. Supply <code>Q</code> if the actual <em>a priori</em> expected shrinkage factors are of interest.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_phi.shape">phi.shape</code>, <code id="MGP_check_+3A_phi.rate">phi.rate</code></td>
<td>
<p>The shape and rate hyperparameters for the gamma prior on the local shrinkage parameters. Not necessary for checking if the cumulative shrinkage property holds, but worth supplying <em>both</em> if the actual <em>a priori</em> expected shrinkage factors are of interest. The default value(s) depends on the value of <code>inverse</code>, but are chosen in such a way that the local shrinkage has no effect on the expectation unless both are supplied. Cannot be incorporated into the expectation if <code>phi.shape &lt; 1</code> and <code>isTRUE(inverse)</code>.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_sigma.shape">sigma.shape</code>, <code id="MGP_check_+3A_sigma.rate">sigma.rate</code></td>
<td>
<p>The shape and rate hyperparameters for the gamma prior on the cluster shrinkage parameters. Not necessary for checking if the cumulative shrinkage property holds, but worth supplying <em>both</em> if the actual <em>a priori</em> expected shrinkage factors are of interest. The default value(s) depends on the value of <code>inverse</code>, but are chosen in such a way that the cluster shrinkage has no effect on the expectation unless both are supplied. Cannot be incorporated into the expectation if <code>sigma.shape &lt; 1</code> and <code>isTRUE(inverse)</code>.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_bd1">bd1</code>, <code id="MGP_check_+3A_bd2">bd2</code></td>
<td>
<p>Rate hyperparameters for <code class="reqn">\delta_1</code> and <code class="reqn">\delta_k \forall k\ge 2</code>, respectively. Both default to <code>1</code>.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_truncated">truncated</code></td>
<td>
<p>A logical value indicating whether the version of the MGP prior based on left-truncated gamma distributions is invoked (see <code><a href="#topic+ltrgamma">ltrgamma</a></code> and the Zhang et al. reference below). Defaults to <code>FALSE</code>. Note that, when <code>TRUE</code>, the expected shrinkage factors for the first loadings column are not affected and the conditions needed to pass this check for the parameters associated with subsequent columns are much less strict. Moreover, more desirable shrinkage properties are easily obtained.</p>
</td></tr>
<tr><td><code id="MGP_check_+3A_inverse">inverse</code></td>
<td>
<p>Logical indicator for whether the cumulative shrinkage property is assessed against the induced Inverse Gamma prior, the default, or in terms of the Gamma prior (which is incorrect). This is always <code>TRUE</code> when used inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>: the <code>FALSE</code> option exists only for demonstration purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is called inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> for the <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code> and <code>"IMIFA"</code> methods. This function is vectorised with respect to the arguments <code>ad1</code>, <code>ad2</code>, <code>phi.shape</code>, <code>phi.rate</code>, <code>sigma.shape</code>, <code>sigma.rate</code>, <code>bd1</code> and <code>bd2</code>.
</p>


<h3>Value</h3>

<p>A list of length 2 containing the following objects:
</p>
<table>
<tr><td><code>expectation</code></td>
<td>
<p>The vector (or list of vectors) of actual expected <em>a priori</em> shrinkage factors.</p>
</td></tr>
<tr><td><code>valid</code></td>
<td>
<p>A logical (or vector of logicals) indicating whether the cumulative shrinkage property holds (in expectation).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>It is <em>recommended</em> that <code>ad2</code> be moderately large relative to <code>ad1</code>, even if <code>valid</code> can sometimes be <code>TRUE</code> when this is not the case (e.g. when <code>truncated=TRUE</code>). Similarly, satisfying this condition is no guarantee that <code>valid</code> will be <code>TRUE</code>, unless <code>truncated=TRUE</code>. Therefore, a warning is returned if <code>ad1 &lt;= ad2</code>, regardless of the value taken by <code>valid</code>, when <code>truncated=FALSE</code> (the default).
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Durante, D. (2017). A note on the multiplicative gamma process, <em>Statistics &amp; Probability Letters</em>, 122: 198-204.
</p>
<p>Bhattacharya, A. and Dunson, D. B. (2011). Sparse Bayesian infinite factor models, <em>Biometrika</em>, 98(2): 291-306.
</p>
<p>Zhang, X., Dunson, D. B., and Carin, L. (2011) Tree-structured infinite sparse factor model. In Getoor, L. and Scheffer, T. (Eds.), <em>Proceedings of the 28th International Conference on Machine Learning (ICML 2011)</em>, June 28-July 2, 2011, Bellevue, WA, USA, pp. 785-792. Madison, WI, USA: Omnipress.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+ltrgamma">ltrgamma</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check if expected shrinkage under the MGP increases with the column index (WRONG approach!).
MGP_check(ad1=1.5, ad2=1.8, Q=10, phi.shape=3, inverse=FALSE)$valid   #TRUE

# Check if the induced IG prior on the MGP column shrinkage parameters
# is stochastically increasing, thereby inducing cumulative shrinkage (CORRECT approach!).
MGP_check(ad1=1.5, ad2=1.8, Q=10, phi.shape=3, inverse=TRUE)$valid    #FALSE

# Check again with a parameterisation that IS valid and examine the expected shrinkage values
(shrink &lt;- MGP_check(ad1=1.5, ad2=2.8, Q=10, phi.shape=2, phi.rate=0.5, inverse=TRUE))

# Check previously invalid parameterisation again using truncated version of the MGP prior
MGP_check(ad1=1.5, ad2=1.8, Q=10, phi.shape=3, truncated=TRUE)$valid  #TRUE
</code></pre>

<hr>
<h2 id='mgpControl'>Control settings for the MGP prior and AGS for infinite factor models</h2><span id='topic+mgpControl'></span>

<h3>Description</h3>

<p>Supplies a list of arguments for use in <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> pertaining to the use of the multiplicative gamma process (MGP) shrinkage prior and adaptive Gibbs sampler (AGS) for use with the infinite factor models <code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgpControl(alpha.d1 = 2.1,
           alpha.d2 = 3.1,
           phi.hyper = c(3, 2),
           sigma.hyper = c(3, 2),
           active.crit = c("BD", "SC"),
           prop = switch(active.crit, BD=0.7, SC=0.99),
           eps = 0.1,
           adapt = TRUE,
           forceQg = FALSE,
           cluster.shrink = TRUE,
           truncated = FALSE,
           b0 = 0.1,
           b1 = 5e-05,
           beta.d1 = 1,
           beta.d2 = 1,
           start.AGS = 2L,
           stop.AGS = Inf,
           delta0g = FALSE,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mgpControl_+3A_alpha.d1">alpha.d1</code></td>
<td>
<p>Shape hyperparameter of the column shrinkage on the first column of the loadings according to the MGP shrinkage prior. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>2.1</code>. For <code>"MIFA"</code> models, see <code>delta0g</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_alpha.d2">alpha.d2</code></td>
<td>
<p>Shape hyperparameter of the column shrinkage on the subsequent columns of the loadings according to the MGP shrinkage prior. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>3.1</code>. For <code>"MIFA"</code> models, see <code>delta0g</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_phi.hyper">phi.hyper</code></td>
<td>
<p>A vector of length 2 giving the shape and rate hyperparameters for the gamma prior on the local shrinkage parameters. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>c(3, 2)</code>. It is suggested that the rate be &lt;= shape minus 1 to induce local shrinkage, though the cumulative shrinkage property is unaffected by these hyperparameters. Excessively small values may lead to critical numerical issues and should thus be avoided; indeed it is <em>suggested</em> that the shape be &gt;=1.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_sigma.hyper">sigma.hyper</code></td>
<td>
<p>A vector of length 2 giving the shape and rate hyperparameters for the gamma prior on the cluster shrinkage parameters. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>c(3, 2)</code>. Again, it is <em>suggested</em> that the shape be &gt;= 1. Only relevant for the <code>"IMIFA"</code>, <code>"OMIFA"</code>, and <code>"MIFA"</code> methods when <code>isTRUE(cluster.shrink)</code>. Additionally, for the <code>"MIFA"</code> method when <code>delta0g=TRUE</code>, <code>sigma.hyper</code> can be supplied as a matrix with two rows and appropriate dimension or as a list of length <code>length(range.G)</code> of vectors of length 2 or matrices with two rows and appropriate dimensions.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_active.crit">active.crit</code></td>
<td>
<p>A character string indicating which criterion to use to determine the number of active factors during adaptive Gibbs sampling (i.e. only relevant when <code>adapt=TRUE</code>). This is <code>"BD"</code> by default, for the truncation criterion of Bhattacharya and Dunson (2011). The option <code>"SC"</code> is provided for the criterion of Schiavon and Canale (2020) but is currently <strong>only</strong> available when <code>method="IFA"</code> and is liable to be slightly slower (though more accurate).</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_prop">prop</code></td>
<td>
<p>Only relevant when <code>adapt=TRUE</code> and both the meaning and default behaviour change according to the value of <code>active.crit</code>:
</p>

<dl>
<dt><code>active.crit="BD"</code></dt><dd><p>Proportion of loadings elements within the neighbourhood <code>eps</code> of zero necessary to consider a loadings column redundant. Defaults to <code>floor(0.7 * P)/P</code>, where <code>P</code> is the number of variables in the data set. However, if the data set is univariate or bivariate, the default is <code>0.5</code> (see Note).</p>
</dd>
<dt><code>active.crit="SC"</code></dt><dd><p>Minimum proportion of variance which must be explained after truncating a loadings column. The smallest number of factors for which the proportion of variance explained exceeds <code>prop</code> are retained at each iteration. Defaults to <code>0.99</code>, unless the data set is univariate or bivariate, in which case the default is <code>0.5</code> (see Note).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="mgpControl_+3A_eps">eps</code></td>
<td>
<p>Only relevant when <code>adapt=TRUE</code> and <code>active.crit="BD"</code>. Neighbourhood epsilon of zero within which a loadings entry is considered negligible according to <code>prop</code>. Defaults to <code>0.1</code>. Must be positive.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_adapt">adapt</code></td>
<td>
<p>A logical value indicating whether adaptation of the number of cluster-specific factors is to take place when the MGP prior is employed. Defaults to <code>TRUE</code>. Specifying <code>FALSE</code> and supplying <code>range.Q</code> within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> provides a means to either approximate the infinite factor model with a fixed, high truncation level, or to use the MGP prior in a finite-factor context, however this is NOT recommended for the <code>"OMIFA"</code> and <code>"IMIFA"</code> methods. Note that users who specify <code>adapt=FALSE</code> here can later recover the (cluster-specific) numbers of non-redundant factors by supplying <code>adapt=TRUE</code> to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> provided the relevant parameters are stored via <code><a href="#topic+storeControl">storeControl</a></code> (<code>load.switch</code> for <code>active.crit="BD"</code>; <code>load.switch</code> and <code>score.switch</code> for <code>active.crit="SC"</code>), though this is not required. Generally, invoking <code>adapt</code> <em>during sampling</em> will reduce the computational burden significantly.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_forceqg">forceQg</code></td>
<td>
<p>A logical indicating whether the upper limit on the number of cluster-specific factors <code>Q</code> is also cluster-specific. This upper limit is determined the number of observations in the given cluster. Defaults to <code>FALSE</code>: when <code>TRUE</code>, the number of factors in each cluster is kept below the number of observations in each cluster, in addition to the bound defined by <code>range.Q</code>. Only relevant for the <code>"IMIFA"</code>, <code>"OMIFA"</code>, and <code>"MIFA"</code> methods, and only invoked when <code>adapt</code> is <code>TRUE</code>. May be useful for low-dimensional data sets for which identifiable solutions are desired. It is also advisable that the number of latent factors not exceed the associated <code><a href="#topic+Ledermann">Ledermann</a></code> bound, or the stricter bound <code>floor((P - 1)/2)</code>, but these restrictions are not enforced by <code>forceQg</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_cluster.shrink">cluster.shrink</code></td>
<td>
<p>A logical value indicating whether to place the prior specified by <code>sigma.hyper</code> on the cluster shrinkage parameters. Defaults to <code>TRUE</code>. Specifying <code>FALSE</code> is equivalent to fixing all cluster shrinkage parameters to <code>1</code>. Only relevant for the <code>"IMIFA"</code>, <code>"OMIFA"</code>, and <code>"MIFA"</code> methods. If invoked, the posterior mean cluster shrinkage factors will be reported.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_truncated">truncated</code></td>
<td>
<p>A logical value indicating whether the version of the MGP prior based on left-truncated gamma distributions is invoked (see Zhang et al. reference below and additional relevant documentation in <code><a href="#topic+ltrgamma">ltrgamma</a></code> and <code><a href="#topic+MGP_check">MGP_check</a></code>). Defaults to <code>FALSE</code>. Note that, when <code>TRUE</code>, the expected shrinkage factors for the first loadings column are not affected and the conditions needed to pass <code><a href="#topic+MGP_check">MGP_check</a></code> for the parameters associated with subsequent columns are much less strict. Moreover, more desirable shrinkage properties are easily obtained, at the expense of slightly longer run times.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_b0">b0</code>, <code id="mgpControl_+3A_b1">b1</code></td>
<td>
<p>Intercept &amp; slope parameters for the exponentially decaying adaptation probability:
</p>
<p><code>p(iter) = 1/exp(b0 + b1 * (iter - start.AGS))</code>.
</p>
<p>Defaults to <code>0.1</code> &amp; <code>0.00005</code>, respectively. Must be non-negative and strictly positive, respectively, to ensure diminishing adaptation.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_beta.d1">beta.d1</code></td>
<td>
<p>Rate hyperparameter of the column shrinkage on the first column of the loadings according to the MGP shrinkage prior. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>1</code>. For <code>"MIFA"</code> models, see <code>delta0g</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_beta.d2">beta.d2</code></td>
<td>
<p>Rate hyperparameter of the column shrinkage on the subsequent columns of the loadings according to the MGP shrinkage prior. Passed to <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure validity. Defaults to <code>1</code>. For <code>"MIFA"</code> models, see <code>delta0g</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_start.ags">start.AGS</code></td>
<td>
<p>The iteration at which adaptation under the AGS is to begin. Defaults to <code>burnin</code> for the <code>"IFA"</code> and <code>"MIFA"</code> methods, defaults to <code>2</code> for the <code>"OMIFA"</code> and <code>"IMIFA"</code> methods, and defaults to <code>2</code> for all methods if the data set is univariate or bivariate. Cannot exceed <code>burnin</code>; thus defaults to the same value as <code>burnin</code> if necessary.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_stop.ags">stop.AGS</code></td>
<td>
<p>The iteration at which adaptation under the AGS is to stop completely. Defaults to <code>Inf</code>, such that the AGS is never explicitly forced to stop (thereby overriding the diminishing adaptation probability after <code>stop.AGS</code>). Must be greater than <code>start.AGS</code>. The diminishing adaptation probability prior to <code>stop.AGS</code> is still governed by the arguments <code>b0</code> and <code>b1</code>.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_delta0g">delta0g</code></td>
<td>
<p>Logical indicating whether the <code>alpha.d1</code>, <code>alpha.d2</code>, <code>beta.d1</code>, <code>beta.d2</code>, and <code>sigma.hyper</code> hyperparameters can be cluster-specific (i.e., matrices of appropriate dimension for <code>sigma.hyper</code>, vectors of appropriate length for the other hyperparameters, or a list of length <code>length(range.G)</code> of such items). Defaults to <code>FALSE</code>. Only relevant for the <code>"MIFA"</code> method and only allowed when <code>z.list</code> is supplied within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. See <strong>Examples</strong> below.</p>
</td></tr>
<tr><td><code id="mgpControl_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list in which the names are the names of the arguments related to the MGP and AGS and the values are the values supplied to the arguments.
</p>


<h3>Note</h3>

<p>Certain supplied arguments will be subject to further checks by <code><a href="#topic+MGP_check">MGP_check</a></code> to ensure the cumulative shrinkage property of the MGP prior holds according to the given parameterisation.
</p>
<p>The adaptive Gibbs sampler (AGS) monitors the <code>prop</code> of loadings elements within the neighbourhood <code>eps</code> of 0 and discards columns or simulates new columns on this basis. However, if at any stage the number of group-specific latent factors reaches zero, the decision to add columns is instead based on a simple binary trial with probability <code>1-prop</code>, as there are no loadings entries to monitor.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Durante, D. (2017). A note on the multiplicative gamma process, <em>Statistics &amp; Probability Letters</em>, 122: 198-204.
</p>
<p>Bhattacharya, A. and Dunson, D. B. (2011) Sparse Bayesian infinite factor models, <em>Biometrika</em>, 98(2): 291-306.
</p>
<p>Schiavon, L. and Canale, A. (2020) On the truncation criteria in infinite factor models, <em>Stat</em>, 9:e298.
</p>
<p>Zhang, X., Dunson, D. B., and Carin, L. (2011) Tree-structured infinite sparse factor model. In Getoor, L. and Scheffer, T. (Eds.), <em>Proceedings of the 28th International Conference on Machine Learning (ICML 2011)</em>, June 28-July 2, 2011, Bellevue, WA, USA, pp. 785-792. Madison, WI, USA: Omnipress.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+Ledermann">Ledermann</a></code>, <code><a href="#topic+MGP_check">MGP_check</a></code>, <code><a href="#topic+ltrgamma">ltrgamma</a></code>, <code><a href="#topic+mixfaControl">mixfaControl</a></code>, <code><a href="#topic+bnpControl">bnpControl</a></code>, <code><a href="#topic+storeControl">storeControl</a></code>, <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mgpctrl &lt;- mgpControl(phi.hyper=c(2.5, 1), eps=1e-02, truncated=TRUE)

# data(olive)
# sim   &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000, MGP=mgpctrl)

# Alternatively specify these arguments directly
# sim   &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000,
#                     phi.hyper=c(2.5, 1), eps=1e-02, truncated=TRUE)

# Use delta0g for a MIFA model with supplied cluster labels
# sim2  &lt;- mcmc_IMIFA(olive, n.iters=5000, method="MIFA", range.G=3,
#                     z.list=olive$area, delta0g=TRUE, alpha.d1=4:2, alpha.d2=5:3
#                     sigma.hyper=matrix(c(4:6, rep(2, 3)), nrow=2, byrow=TRUE))
</code></pre>

<hr>
<h2 id='mixfaControl'>Control settings for the IMIFA family of factor analytic mixtures</h2><span id='topic+mixfaControl'></span>

<h3>Description</h3>

<p>Supplies a list of arguments for use in <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> pertaining to <em>ALL</em> methods in the <code>IMIFA</code> family: e.g. MCMC settings, cluster initialisation, generic hyperparameters for factor-analytic mixtures, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixfaControl(n.iters = 25000L,
             burnin = n.iters/5L,
             thinning = 2L,
             centering = TRUE,
             scaling = c("unit", "pareto", "none"),
             uni.type = c("unconstrained", "isotropic",
                          "constrained", "single"),
             psi.alpha = 2.5,
             psi.beta = NULL,
             mu.zero = NULL,
             sigma.mu = 1L,
             prec.mu = 0.01,
             sigma.l = 1L,
             z.init = c("hc", "kmeans", "list", "mclust", "priors"),
             z.list = NULL,
             equal.pro = FALSE,
             uni.prior = c("unconstrained", "isotropic"),
             mu0g = FALSE,
             psi0g = FALSE,
             drop0sd = TRUE,
             verbose = interactive(),
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixfaControl_+3A_n.iters">n.iters</code></td>
<td>
<p>The number of iterations to run the sampler for. Defaults to 25000.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_burnin">burnin</code></td>
<td>
<p>The number of burn-in iterations for the sampler. Defaults to <code>n.iters/5</code>. Note that chains can also be burned in later, using <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_thinning">thinning</code></td>
<td>
<p>The thinning interval used in the simulation. Defaults to 2. No thinning corresponds to 1. Note that chains can also be thinned later, using <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_centering">centering</code></td>
<td>
<p>A logical value indicating whether mean centering should be applied to the data, defaulting to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_scaling">scaling</code></td>
<td>
<p>The scaling to be applied - one of <code>"unit"</code>, <code>"none"</code> or <code>"pareto"</code>. Defaults to <code>"unit"</code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_uni.type">uni.type</code></td>
<td>
<p>This argument specifies the type of constraint, if any, to be placed on the uniquenesses/idiosyncratic variances, i.e. whether a general diagonal matrix or isotropic diagonal matrix is to be assumed, and in turn whether these matrices are constrained to be equal across clusters. The default <code>"unconstrained"</code> corresponds to factor analysis (and mixtures thereof), whereas <code>"isotropic"</code> corresponds to probabilistic principal components analysers (and mixtures thereof).
</p>
<p>Constraints <em>may</em> be particularly useful when <code>N &lt;= P</code>, though caution is advised when employing constraints for any of the infinite factor models, especially <code>"isotropic"</code> and <code>"single"</code>, which may lead to overestimation of the number of clusters &amp;/or factors if this specification is inappropriate. The four options correspond to the following 4 parsimonious Gaussian mixture models:
</p>

<dl>
<dt><code>"unconstrained"</code></dt><dd><p>(<strong>UUU</strong>) - variable-specific and cluster-specific: <code class="reqn">\Psi_g = \Psi_g</code>.</p>
</dd>
<dt><code>"isotropic"</code></dt><dd><p>(<strong>UUC</strong>) - cluster-specific, equal across variables: <code class="reqn">\Psi_g = \psi\mathcal{I}_p</code>.</p>
</dd>
<dt><code>"constrained"</code></dt><dd><p>(<strong>UCU</strong>) - variable-specific, equal across clusters: <code class="reqn">\Psi_g = \Psi</code>.</p>
</dd>
<dt><code>"single"</code></dt><dd><p>(<strong>UCC</strong>) - single value equal across clusters and variables: <code class="reqn">\Psi_g = \psi\mathcal{I}_p</code>.</p>
</dd>
</dl>

<p>The first letter <strong>U</strong> here corresponds to constraints on loadings (not yet implemented), the second letter corresponds to uniquenesses constrained/unconstrained across clusters, and the third letter corresponds to the isotropic constraint on the uniquenesses. Of course, only the third letter is of relevance for the single-cluster <code>"FA"</code> and <code>"IFA"</code> models, such that <code>"unconstrained"</code> and <code>"constrained"</code> are equivalent for these models, and so too are <code>"isotropic"</code> and <code>"single"</code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_psi.alpha">psi.alpha</code></td>
<td>
<p>The shape of the inverse gamma prior on the uniquenesses. Defaults to 2.5. Must be greater than 1 if <code>psi.beta</code> is <em>not</em> supplied. Otherwise be warned that values less than or equal to 1 may not bound uniquenesses sufficiently far away from 0, and the algorithm may therefore terminate. Also, excessively small values may lead to critical numerical issues and should thus be avoided.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_psi.beta">psi.beta</code></td>
<td>
<p>The scale of the inverse gamma prior on the uniquenesses. Can be either a single scalar parameter, a vector of variable specific scales, or (if <code>psi0g</code> is <code>TRUE</code>) a matrix of variable and cluster-specific scales (or a vector coercible to such a matrix) or a list of length <code>length(range.G)</code> of such items of appropriate dimensions. If this is not supplied, <code><a href="#topic+psi_hyper">psi_hyper</a></code> is invoked to choose sensible values, depending on the value of <code>uni.prior</code> and the data size and dimension and, for the <code>"MFA"</code> and <code>"MIFA"</code> models only, the value of <code>psi0g</code> (i.e., <code><a href="#topic+psi_hyper">psi_hyper</a></code> is applied per cluster if <code>psi0g</code> is <code>TRUE</code> and <code>psi.beta</code> is not supplied). Excessively small values may lead to critical numerical issues and should thus be avoided.
</p>
<p>Note that optional arguments to <code>psi_hyper</code> can be supplied via the <code>...</code> construct here.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_mu.zero">mu.zero</code></td>
<td>
<p>The mean of the prior distribution for the mean parameter. Either a scalar, a vector of appropriate dimension, or (if <code>mu0g</code> is <code>TRUE</code>) a matrix of variable-specific and cluster-specific hypermeans (or a vector coercible to such a matrix) or a list of length <code>length(range.G)</code> of such items of appropriate dimensions. Defaults to the sample mean of the data.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_sigma.mu">sigma.mu</code></td>
<td>
<p>The covariance of the prior distribution for the cluster mean parameters. Always assumed to be a diagonal matrix, and set to the identity matrix by default. Can also be a scalar by which the identity is multiplied, a vector of appropriate dimension; if supplied as a matrix, only the diagonal elements will be extracted. Specifying <code>sigma.mu=NULL</code> will use the diagonal entries of the sample covariance matrix: for unit-scaled data this is simply the identity again. See <code>prec.mu</code> for further control over the hypercovariance in the prior for the means.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_prec.mu">prec.mu</code></td>
<td>
<p>A scalar controlling the degree of flatness of the prior for the cluster means by scaling <code>sigma.mu</code> (i.e. multiplying every element of <code>sigma.mu</code> by <code>1/prec.mu</code>). Lower values lead to a more diffuse prior. Defaults to <code>0.01</code>, such that the prior is relatively non-informative by default. Of course, <code>prec.mu=1</code> nullifies any effect of this argument. The user can supply a scaled <code>sigma.mu</code> directly, but this argument is especially useful when specifying <code>sigma.mu=NULL</code>, such that the diagonal entries of the sample covariance matrix are used.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_sigma.l">sigma.l</code></td>
<td>
<p>A scalar controlling the diagonal covariance of the prior distribution for the loadings. Defaults to <code>1</code>, i.e. the identity; otherwise a diagonal matrix with non-zero entries all equal to <code>sigma.l</code> Only relevant for the finite factor methods.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_z.init">z.init</code></td>
<td>
<p>The method used to initialise the cluster labels. Defaults to model-based agglomerative hierarchical clustering via <code>"<a href="mclust.html#topic+hc">hc</a>"</code>. Other options include <code>"<a href="stats.html#topic+kmeans">kmeans</a>"</code> (with 10 random starts, by default), <code><a href="mclust.html#topic+Mclust">Mclust</a></code> via <code>"mclust"</code>, random initialisation via <code>"priors"</code>, and a user-supplied <code>"list"</code> (<code>z.list</code>). Not relevant for the <code>"FA"</code> and <code>"IFA"</code> methods. Arguments for the relevant functions can be passed via the <code>...</code> construct. For <code>"<a href="mclust.html#topic+hc">hc</a>"</code>, <code>VVV</code> is used by default, unless the data is high-dimensional, in which case the default is <code>EII</code>. The option <code>"priors"</code> may lead to empty components at initialisation, which will return an error.
</p>
<p>In any case, unless <code>z.list</code> is explicitly supplied, or <code>verbose</code> is <code>FALSE</code>, the initial cluster sizes will be printed to the screen to alert users to potentially bad initialisiations (e.g. heavily imbalanced initial cluster sizes).</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_z.list">z.list</code></td>
<td>
<p>A user supplied list of cluster labels. Only relevant if <code>z.init == "z.list"</code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_equal.pro">equal.pro</code></td>
<td>
<p>Logical variable indicating whether or not the mixing mixing proportions are to be equal across clusters in the model (default = <code>FALSE</code>). Only relevant for the <code>"MFA"</code> and <code>"MIFA"</code> methods.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_uni.prior">uni.prior</code></td>
<td>
<p>A switch indicating whether uniquenesses scale hyperparameters are to be <code>"unconstrained"</code> or <code>"isotropic"</code>, i.e. variable-specific or not. <code>"uni.prior"</code> must be <code>"isotropic"</code> if the last letter of <code>uni.type</code> is <strong>C</strong>, but can take either value otherwise. Defaults to correspond to the last letter of <code>uni.type</code> if that is supplied and <code>uni.prior</code> is not, otherwise defaults to <code>"unconstrained"</code> (though <code>"isotropic"</code> is recommended when <code>N &lt;= P</code>). Only relevant when <code>psi.beta</code> is not supplied and <code><a href="#topic+psi_hyper">psi_hyper</a></code> is therefore invoked (with optional arguments passable via the <code>...</code> construct).</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_mu0g">mu0g</code></td>
<td>
<p>Logical indicating whether the <code>mu.zero</code> hyperparameter can be cluster-specific. Defaults to <code>FALSE</code>. Only relevant for the <code>"MFA"</code> and <code>"MIFA"</code> methods when <code>z.list</code> is supplied. See <strong>Examples</strong> below.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_psi0g">psi0g</code></td>
<td>
<p>Logical indicating whether the <code>psi.beta</code> hyperparameter(s) can be cluster-specific. Defaults to <code>FALSE</code>. Only relevant for the <code>"MFA"</code> and <code>"MIFA"</code> methods when <code>z.list</code> is supplied and only allowable when <code>uni.type</code> is one of <code>unconstrained</code> or <code>isotropic</code>. See <strong>Examples</strong> below.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_drop0sd">drop0sd</code></td>
<td>
<p>Logical indicating whether to drop variables with no standard deviation (defaults to <code>TRUE</code>). This is <em>strongly</em> recommended, especially a) when <code>psi.beta</code> is not supplied &amp;/or <code>sigma.mu=NULL</code>, and either/both are therefore estimated using the empirical covariance matrix, &amp;/or b) if some form of posterior predictive checking is subsequently desired when calling <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_verbose">verbose</code></td>
<td>
<p>Logical indicating whether to print output (e.g. run times) and a progress bar to the screen while the sampler runs. By default is <code>TRUE</code> if the session is interactive, and <code>FALSE</code> otherwise. If <code>FALSE</code>, warnings and error messages will still be printed to the screen, but everything else will be suppressed.</p>
</td></tr>
<tr><td><code id="mixfaControl_+3A_...">...</code></td>
<td>
<p>Also catches unused arguments. A number of optional arguments can be also supplied here:
</p>

<ul>
<li><p>The additional <code><a href="#topic+psi_hyper">psi_hyper</a></code> argument <code>beta0</code>, especially when <code>N &lt;= P</code>.
</p>
</li>
<li><p>Additional arguments to be passed to <code><a href="mclust.html#topic+hc">hc</a></code> (<code>modelName</code> &amp; <code>use</code> only), to <code><a href="mclust.html#topic+Mclust">Mclust</a></code> (<code>modelNames</code>, and the arguments for <code><a href="mclust.html#topic+hc">hc</a></code> with which <code><a href="mclust.html#topic+Mclust">Mclust</a></code> is itself initialised - <code>modelName</code> &amp; <code>use</code>), or to <code><a href="stats.html#topic+kmeans">kmeans</a></code> (<code>iter.max</code> and <code>nstart</code> only), depending on the value of <code>z.init</code>.
</p>
</li>
<li><p>Additionally, when <code>z.init="mclust"</code>, <code>criterion</code> can be passed here (can be <code>"icl"</code> or <code>"bic"</code>, the default) to control how the optimum <code><a href="mclust.html#topic+Mclust">Mclust</a></code> model to initialise with is determined.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list in which the names are the names of the arguments and the values are the values of the arguments.
</p>


<h3>Note</h3>

<p>Users should be careful to note that data are mean-centered (<code>centering=TRUE</code>) and unit-scaled (<code>scaling="unit"</code>) by default when supplying other parameters among the list above, especially those related in any way to <code>psi.hyper</code>, or to the other control functions <code><a href="#topic+mgpControl">mgpControl</a></code> and <code><a href="#topic+bnpControl">bnpControl</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>McNicholas, P. D. and Murphy, T. B. (2008) Parsimonious Gaussian mixture models, <em>Statistics and Computing</em>, 18(3): 285-296.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+psi_hyper">psi_hyper</a></code>, <code><a href="mclust.html#topic+hc">hc</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="mclust.html#topic+Mclust">Mclust</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+bnpControl">bnpControl</a></code>, <code><a href="#topic+storeControl">storeControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mfctrl &lt;- mixfaControl(n.iters=200, prec.mu=1E-03, sigma.mu=NULL,
                       beta0=1, uni.type="constrained")

# data(olive)
# sim  &lt;- mcmc_IMIFA(olive, "IMIFA", mixFA=mfctrl)

# Alternatively specify these arguments directly
# sim  &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=200, prec.mu=1E-03,
#                    sigma.mu=NULL, beta0=1, uni.type="constrained")

# Use mu0g and psi0g for MIFA models with supplied cluster labels
# oliveScaled &lt;- as.data.frame(scale(olive[,-(1:2)]))
# sim2 &lt;- mcmc_IMIFA(olive, "MIFA", n.iters=200, range.G=c(3, 9),
#                    z.list=list(olive$area, olive$region), mu0g=TRUE, psi0g=TRUE,
#                    mu.zero=list(do.call(cbind, tapply(oliveScaled, olive$area,   colMeans)),
#                                 do.call(cbind, tapply(oliveScaled, olive$region, colMeans))))
</code></pre>

<hr>
<h2 id='olive'>Fatty acid composition of Italian olive oils</h2><span id='topic+olive'></span>

<h3>Description</h3>

<p>Data on the percentage composition of eight fatty acids found by lipid fraction of 572 Italian olive oils. The data come from three areas; within each area there are a number of constituent regions, of which there are 9 in total.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(olive)
</code></pre>


<h3>Format</h3>

<p>A data frame with 572 observations and 10 columns. The first columns gives the area (one of Southern Italy, Sardinia, and Northern Italy), the second gives the region, and the remaining 8 columns give the variables. Southern Italy comprises the North Apulia, Calabria, South Apulia, and Sicily regions, Sardinia is divided into Inland Sardinia and Coastal Sardinia and Northern Italy comprises the Umbria, East Liguria, and West Liguria regions.
</p>


<h3>References</h3>

<p>Forina, M., Armanino, C., Lanteri, S. and Tiscornia, E. (1983). Classification of olive oils from their fatty acid composition, In Martens, H. and H. Russrum Jr. (Eds.), <em>Food Research and Data Analysis: Proceedings from the IUFoST Symposium</em>, September 20-23, 1982, Oslo, Norway, pp. 189-214. London, UK: Applied Science Publishers.
</p>
<p>Forina, M. and Tiscornia, E. (1982). Pattern recognition methods in the prediction of Italian olive oil origin by their fatty acid content, <em>Annali di Chimica</em>, 72: 143-155.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(olive, package="IMIFA")
pairs(olive[,-(1:2)], col=olive$area)
region &lt;- as.numeric(olive$region)
pairs(olive[,-(1:2)],
      col=ifelse(region &lt; 5, 1, ifelse(region &lt; 7, 2, ifelse(region == 9, 4, 3))))
</code></pre>

<hr>
<h2 id='pareto_scale'>Pareto Scaling</h2><span id='topic+pareto_scale'></span>

<h3>Description</h3>

<p>Pareto scaling of a numeric matrix, with or without centering. Observations are scaled by the square-root of their column-wise standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto_scale(x,
             centering = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pareto_scale_+3A_x">x</code></td>
<td>
<p>A numeric matrix-like object.</p>
</td></tr>
<tr><td><code id="pareto_scale_+3A_centering">centering</code></td>
<td>
<p>A logical vector indicating whether centering is to be applied (default=<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Pareto scaled version of the matrix <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>van den Berg, R. A., Hoefsloot, H. C. J, Westerhuis, J. A., Smilde, A. K., and van der Werf, M.J. (2006) Centering, scaling, and transformations: improving the biological information content of metabolomics data. <em>BMC Genomics</em>, 7(142).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat  &lt;- pareto_scale(olive[,-(1:2)])
</code></pre>

<hr>
<h2 id='PGMM_dfree'>Estimate the Number of Free Parameters in Finite Factor Analytic Mixture Models (PGMM)</h2><span id='topic+PGMM_dfree'></span>

<h3>Description</h3>

<p>Estimates the dimension of the 'free' parameters in fully finite factor analytic mixture models, otherwise known as Parsimonious Gaussian Mixture Models (PGMM), typically necessary for the penalty term of various model selection criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PGMM_dfree(Q,
           P,
           G = 1L,
           method = c("UUU", "UUC", "UCU", "UCC", "CUU", "CUC",
                      "CCU", "CCC", "CCUU", "UCUU", "CUCU", "UUCU"),
           equal.pro = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PGMM_dfree_+3A_q">Q</code></td>
<td>
<p>The number of latent factors (which can be 0, corresponding to a model with diagonal covariance). This argument is vectorised.</p>
</td></tr>
<tr><td><code id="PGMM_dfree_+3A_p">P</code></td>
<td>
<p>The number of variables. Must be a single strictly positive integer.</p>
</td></tr>
<tr><td><code id="PGMM_dfree_+3A_g">G</code></td>
<td>
<p>The number of clusters. This defaults to 1. Must be a single strictly positive integer.</p>
</td></tr>
<tr><td><code id="PGMM_dfree_+3A_method">method</code></td>
<td>
<p>By default, calculation assumes the <code>UUU</code> model with unconstrained loadings and unconstrained diagonal uniquesseses (i.e. the factor analysis model). The seven other models detailed in McNicholas and Murphy (2008) are given too (of which currently the first four are accommodated within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>). The first letter denotes whether loadings are constrained/unconstrained across clusters; the second letter denotes the same for the uniquenesses; the final letter denotes whether uniquenesses are in turn constrained to be isotropic. Finally, the 4 extra 4-letter models from the EPGMM family (McNicholas and Murphy, 2010), are also included.</p>
</td></tr>
<tr><td><code id="PGMM_dfree_+3A_equal.pro">equal.pro</code></td>
<td>
<p>Logical variable indicating whether or not the mixing mixing proportions are equal across clusters in the model (default = <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>length(Q)</code> giving the total number of parameters, including means and mixing proportions, and not only covariance parameters. Set <code>equal.pro</code> to <code>FALSE</code> and subtract <code>G * P</code> from the result to determine the number of covariance parameters only.
</p>


<h3>Note</h3>

<p>This function is used to calculate the penalty terms for the <code>aic.mcmc</code> and <code>bic.mcmc</code> model selection criteria implemented in <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> for <em>finite</em> factor models (though <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> currently only implements the <code>UUU</code>, <code>UUC</code>, <code>UCU</code>, and <code>UCC</code> covariance structures). The function is vectorised with respect to the argument <code>Q</code>.
</p>
<p>Though the function is available for standalone use, note that no checks take place, in order to speed up repeated calls to the function inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>McNicholas, P. D. and Murphy, T. B. (2008) Parsimonious Gaussian mixture models, <em>Statistics and Computing</em>, 18(3): 285-296.
</p>
<p>McNicholas, P. D. and Murphy, T. B. (2010) Model-Based clustering of microarray expression data via latent Gaussian mixture models, <em>Bioinformatics</em>, 26(21): 2705-2712.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(UUU &lt;- PGMM_dfree(Q=0:5, P=50, G=3, method="UUU"))
(CCC &lt;- PGMM_dfree(Q=0:5, P=50, G=3, method="CCC", equal.pro=TRUE))
</code></pre>

<hr>
<h2 id='plot_cols'>Plots a matrix of colours</h2><span id='topic+plot_cols'></span>

<h3>Description</h3>

<p>Plots a matrix of colours as a heat map type image or as points. Intended for joint use with <code>mat2cols</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cols(cmat,
          na.col = "#808080FF",
          ptype = c("image", "points"),
          border.col = "#808080FF",
          dlabels = NULL,
          rlabels = FALSE,
          clabels = FALSE,
          pch = 15,
          cex = 3,
          label.cex = 0.6,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cols_+3A_cmat">cmat</code></td>
<td>
<p>A matrix of valid colours, with missing values coded as <code>NA</code> allowed. Vectors should be supplied as matrices with 1 row or column, as appropriate.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_na.col">na.col</code></td>
<td>
<p>Colour used for missing <code>NA</code> entries in <code>cmat</code>.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_ptype">ptype</code></td>
<td>
<p>Switch controlling output as either a heat map <code>"image"</code> (the default) or as <code>"points"</code>.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_border.col">border.col</code></td>
<td>
<p>Colour of border drawn around the plot.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_dlabels">dlabels</code>, <code id="plot_cols_+3A_rlabels">rlabels</code>, <code id="plot_cols_+3A_clabels">clabels</code></td>
<td>
<p>Vector of labels for the diagonals, rows, and columns, respectively.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_pch">pch</code></td>
<td>
<p>Point type used when <code>ptype="points"</code>.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_cex">cex</code></td>
<td>
<p>Point cex used when <code>ptype="points"</code>.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_label.cex">label.cex</code></td>
<td>
<p>Govens cex parameter used for labels.</p>
</td></tr>
<tr><td><code id="plot_cols_+3A_...">...</code></td>
<td>
<p>Further graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either an <code>"image"</code> or <code>"points"</code> type plot of the supplied colours.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mat2cols">mat2cols</a></code>, <code><a href="graphics.html#topic+image">image</a></code>, <code><a href="#topic+heat_legend">heat_legend</a></code>, <code><a href="#topic+is.cols">is.cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a colour matrix using mat2cols()
mat      &lt;- matrix(rnorm(100), nrow=10, ncol=10)
mat[2,3] &lt;- NA
cols     &lt;- heat.colors(12)[12:1]
(matcol  &lt;- mat2cols(mat, cols=cols))

# Use plot_cols() to visualise the colours matrix
par(mar=c(5.1, 4.1, 4.1, 3.1))
plot_cols(matcol)

# Add a legend using heat_legend()
heat_legend(mat, cols=cols); box(lwd=2)

# Replace colour of exact zero entries:
# Often important to call mat2cols() first (to include 0 in the cuts),
# then replace relevant entries with NA for plot_cols(), i.e.
mat[2,3] &lt;- 0
matcol2  &lt;- mat2cols(mat, cols=cols)
plot_cols(replace(matcol2, mat == 0, NA), na.col="blue")
heat_legend(mat, cols=cols); box(lwd=2)
</code></pre>

<hr>
<h2 id='plot.Results_IMIFA'>Plotting output and parameters of inferential interest for IMIFA and related models</h2><span id='topic+plot.Results_IMIFA'></span>

<h3>Description</h3>

<p>Plotting output and parameters of inferential interest for IMIFA and related models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Results_IMIFA'
plot(x,
     plot.meth = c("all", "correlation", "density", "errors", "GQ",
                   "means", "parallel.coords", "trace", "zlabels"),
     param = c("means", "scores", "loadings", "uniquenesses",
               "pis", "alpha", "discount"),
     g = NULL,
     mat = TRUE,
     zlabels = NULL,
     heat.map = TRUE,
     show.last = FALSE,
     palette = NULL,
     ind = NULL,
     fac = NULL,
     by.fac = FALSE,
     type = c("h", "n", "p", "l"),
     intervals = TRUE,
     common = TRUE,
     partial = FALSE,
     titles = TRUE,
     transparency = 0.75,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Results_IMIFA_+3A_x">x</code></td>
<td>
<p>An object of class <code>"Results_IMIFA"</code> generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_plot.meth">plot.meth</code></td>
<td>
<p>The type of plot to be produced for the <code>param</code> of interest, where <code>correlation</code> refers to ACF/PACF plots, <code>means</code> refers to posterior means, <code>density</code>, <code>trace</code> and <code>parallel.coords</code> are self-explanatory. <code>"all"</code> in this case, the default, refers to <code>"trace"</code>, <code>"density"</code>, <code>"means"</code>, and <code>"correlation"</code>. <code>"parallel.coords"</code> is only available when <code>param</code> is one of <code>"means"</code>, <code>"loadings"</code>, or <code>"uniquenesses"</code> - note that this method applies a small amount of horizontal jitter to avoid overplotting.
</p>
<p>Special types of plots which don't require a <code>param</code> are:
</p>

<dl>
<dt><code>"GQ"</code></dt><dd><p>for plotting the posterior summaries of the numbers of clusters/factors, if available.</p>
</dd>
<dt><code>"zlabels"</code></dt><dd><p>for plotting clustering uncertainties - in four different ways (incl. the posterior confusion matrix) - if clustering has taken place, with or without the clustering labels being supplied via the <code>zlabels</code> argument. If available, the average similarity matrix, reordered according to the MAP labels, is shown as a 5-th plot.</p>
</dd>
<dt><code>"errors"</code></dt><dd><p>for conducting posterior predictive checking of the appropriateness of the fitted model by visualising the posterior predictive reconstruction error (PPRE) &amp;/or histograms comparing the data to replicate draws from the posterior distribution &amp;/or error metrics quantifying the difference between the estimated and empirical covariance matrices. The type of plot(s) produced depends on how the <code>error.metrics</code> argument was supplied to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> and what parameters were stored.</p>
</dd>
</dl>

<p>The argument <code>g</code> can be used to cycle through the available plots in each case. <code>ind</code> can also be used to govern which variable is shown for the 2-nd plot.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_param">param</code></td>
<td>
<p>The parameter of interest for any of the following <code>plot.meth</code> options: <code>all</code>, <code>trace</code>, <code>density</code>, <code>means</code>, <code>correlation</code>. The <code>param</code> must have been stored when <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> was initially ran. Includes <code>pis</code> for methods where clustering takes place, and allows posterior inference on <code>alpha</code> (for the <code>"IMFA"</code>, <code>"IMIFA"</code>, <code>"OMFA"</code>, and <code>"OMIFA"</code> methods) and <code>discount</code> (for the <code>"IMFA"</code> and <code>"IMIFA"</code> methods). Otherwise <code>"means"</code>, <code>"scores"</code>, <code>"loadings"</code>, and <code>"uniquenesses"</code> can be plotted.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_g">g</code></td>
<td>
<p>Optional argument that allows specification of exactly which cluster the plot of interest is to be produced for. If not supplied, the user will be prompted to cycle through plots for all clusters. Also functions as an index for which plot to return when <code>plot.meth</code> is <code>GQ</code>, <code>zlabels</code>, or <code>errors</code> in much the same way.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_mat">mat</code></td>
<td>
<p>Logical indicating whether a <code><a href="graphics.html#topic+matplot">matplot</a></code> is produced (defaults to <code>TRUE</code>). If given as <code>FALSE</code>, <code>ind</code> is invoked.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_zlabels">zlabels</code></td>
<td>
<p>The true labels can be supplied if they are known. If this is not supplied, the function uses the labels that were supplied, if any, to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>. Only relevant when <code>plot.meth = "zlabels"</code>. When explicitly supplied, misclassified observations are highlighted in the first type of uncertainty plot (otherwise observations whose uncertainty exceed the inverse of the number of clusters are highlighted). For the second type of uncertainty plot, when <code>zlabels</code> are explicitly supplied, the uncertainty of misclassified observations is marked by vertical lines on the profile plot.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_heat.map">heat.map</code></td>
<td>
<p>A logical which controls plotting posterior mean loadings or posterior mean scores as a heatmap, or else as something akin to <code>link{plot(..., type="h")}</code>. Only relevant if <code>param = "loadings"</code> (in which case the default is <code>TRUE</code>) or <code>param = "scores"</code> (in which case the default is <code>FALSE</code>). Heatmaps are produced with the aid of <code><a href="#topic+mat2cols">mat2cols</a></code> and <code><a href="#topic+plot_cols">plot_cols</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_show.last">show.last</code></td>
<td>
<p>A logical indicator which defaults to <code>FALSE</code>, but when <code>TRUE</code> replaces any instance of the posterior mean with the last valid sample. Only relevant when <code>param</code> is one of <code>"means"</code> <code>"scores"</code>, <code>"loadings"</code>, <code>"uniquenesses"</code>, or <code>"pis"</code> and <code>plot.meth</code> is one of <code>"all"</code> or <code>"means"</code>. Also relevant for <code>"means"</code>, <code>"loadings"</code> and <code>"uniquenesses"</code> when <code>plot.meth</code> is <code>"parallel.coords"</code>. When <code>TRUE</code>, this has the effect of forcing <code>intervals</code> to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_palette">palette</code></td>
<td>
<p>An optional colour palette to be supplied if overwriting the default palette set inside the function by <code><a href="viridisLite.html#topic+viridis">viridis</a></code> is desired. It makes little sense to a supply a <code>palette</code> when <code>plot.meth="all"</code> and <code>param</code> is one of <code>"scores"</code> or <code>"loadings"</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_ind">ind</code></td>
<td>
<p>Either a single number indicating which variable to plot when <code>param</code> is one of <code>means</code> or <code>uniquenesses</code> (or <code>plot.meth="errors"</code>), or which cluster to plot if <code>param</code> is <code>pis</code>. If <code>scores</code> are plotted, a vector of length two giving which observation and factor to plot; if <code>loadings</code> are plotted, a vector of length two giving which variable and factor to plot. Will be recycled to length 2 if necessary. Also governs which two factors are displayed on posterior mean plots of the <code>"scores"</code> when <code>heat.map</code> is <code>FALSE</code>; otherwise only relevant when <code>mat</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_fac">fac</code></td>
<td>
<p>Optional argument that provides an alternative way to specify <code>ind[2]</code> when <code>mat</code> is <code>FALSE</code> and <code>param</code> is one of <code>scores</code> or <code>loadings</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_by.fac">by.fac</code></td>
<td>
<p>Optionally allows (mat)plotting of scores and loadings by factor - i.e. observation(s) (scores) or variable(s) (loadings) for a given factor, respectively, controlled by <code>ind</code> or <code>fac</code>) when set to <code>TRUE</code>. Otherwise all factor(s) are plotted for a given observation or variable when set to <code>FALSE</code> (the default), again controlled by <code>ind</code> or <code>fac</code>. Only relevant when <code>param</code> is one of <code>scores</code> or <code>loadings</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_type">type</code></td>
<td>
<p>The manner in which the plot is to be drawn, as per the <code>type</code> argument to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_intervals">intervals</code></td>
<td>
<p>Logical indicating whether credible intervals around the posterior mean(s) are to be plotted when <code>is.element(plot.meth, c("all", "means"))</code>. Defaults to <code>TRUE</code>, but can only be <code>TRUE</code> when <code>show.last</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_common">common</code></td>
<td>
<p>Logical indicating whether plots with <code>plot.meth="means"</code> (or the corresponding plots for <code>plot.meth="all"</code>) when <code>param</code> is one of <code>"means"</code>, <code>"scores"</code>, <code>"loadings"</code>, or <code>"uniquenesses"</code> are calibrated to a common scale based on the range of the <code>param</code> parameters across all clusters (defaults to <code>TRUE</code>, and only relevant when there are clusters). Otherwise, the only the range corresponding to the image being plotted is used to determine the scale.
</p>
<p>Note that this affects the <code>"loadings"</code> and <code>"scores"</code> plots regardless of the value of <code>heat.map</code>. An exception is the <code>"scores"</code> plots when <code>plot.meth="means"</code> and <code>heat.map</code> is <code>FALSE</code>, in which case <code>common</code> defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_partial">partial</code></td>
<td>
<p>Logical indicating whether plots of type <code>"correlation"</code> use the PACF. The default, <code>FALSE</code>, ensures the ACF is used. Only relevant when <code>plot.meth = "all"</code>, otherwise both plots are produced when <code>plot.meth = "correlation"</code>.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_titles">titles</code></td>
<td>
<p>Logical indicating whether default plot titles are to be used (<code>TRUE</code>), or suppressed (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_transparency">transparency</code></td>
<td>
<p>A factor in [0, 1] modifying the opacity for overplotted lines. Defaults to 0.75, unless semi-transparency is not supported. Only relevant when <code>palette</code> is not supplied, otherwise the supplied <code>palette</code> must already be adjusted for transparency.</p>
</td></tr>
<tr><td><code id="plot.Results_IMIFA_+3A_...">...</code></td>
<td>
<p>Other arguments typically passed to <code><a href="graphics.html#topic+plot">plot</a></code> or the <code>breaks</code> argument to <code><a href="#topic+mat2cols">mat2cols</a></code> and <code><a href="#topic+heat_legend">heat_legend</a></code> when heatmaps are plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The desired plot with appropriate output and summary statistics printed to the console screen.
</p>


<h3>Note</h3>

<p>Supplying the argument <code>zlabels</code> does <strong>not</strong> have the same effect of reordering the sampled parameters as it does if supplied directly to <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.
</p>
<p>When <code>mat</code> is <code>TRUE</code> and <code>by.fac</code> is <code>FALSE</code> (both defaults), the convention for dealing with overplotting for <code>trace</code> and <code>density</code> plots when <code>param</code> is either <code>scores</code> or <code>loadings</code> is to plot the last factor first, such that the first factor appears 'on top'.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="#topic+mat2cols">mat2cols</a></code>, <code><a href="#topic+plot_cols">plot_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the vignette associated with the package for more graphical examples:
# vignette("IMIFA", package = "IMIFA")

# data(olive)
# simIMIFA &lt;- mcmc_IMIFA(olive, method="IMIFA")
# resIMIFA &lt;- get_IMIFA_results(simIMIFA, z.avgsim=TRUE)

# Examine the posterior distribution(s) of the number(s) of clusters (G) &amp;/or latent factors (Q)
# For the IM(I)FA and OM(I)FA methods, this also plots the trace of the active/non-empty clusters
# plot(resIMIFA, plot.meth="GQ")
# plot(resIMIFA, plot.meth="GQ", g=2)

# Plot clustering uncertainty (and, if available, the similarity matrix)
# plot(resIMIFA, plot.meth="zlabels", zlabels=olive$area)

# Visualise the posterior predictive reconstruction error
# plot(resIMIFA, plot.meth="errors", g=1)

# Compare histograms of the data vs. replicate draw from the posterior for the 1st variable
# plot(resIMIFA, plot.meth="errors", g=2, ind=1)

# Visualise empirical vs. estimated covariance error metrics
# plot(resIMIFA, plot.meth="errors", g=3)

# Look at the trace, density, posterior mean, and correlation of various parameters of interest
# plot(resIMIFA, plot.meth="all", param="means", g=1)
# plot(resIMIFA, plot.meth="all", param="means", g=1, ind=2)
# plot(resIMIFA, plot.meth="trace", param="scores")
# plot(resIMIFA, plot.meth="trace", param="scores", by.fac=TRUE)
# plot(resIMIFA, plot.meth="mean", param="loadings", g=1)
# plot(resIMIFA, plot.meth="mean", param="loadings", g=1, heat.map=FALSE)
# plot(resIMIFA, plot.meth="parallel.coords", param="uniquenesses")
# plot(resIMIFA, plot.meth="density", param="pis", intervals=FALSE, partial=TRUE)
# plot(resIMIFA, plot.meth="all", param="alpha")
# plot(resIMIFA, plot.meth="all", param="discount")
</code></pre>

<hr>
<h2 id='post_conf_mat'>Posterior Confusion Matrix</h2><span id='topic+post_conf_mat'></span>

<h3>Description</h3>

<p>For a (<code>N * G</code>) matrix of posterior cluster membership probabilities, this function creates a (<code>G * G</code>) posterior confusion matrix, whose hk-th entry gives the average probability that observations with maximum posterior allocation h will be assigned to cluster k.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_conf_mat(z, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_conf_mat_+3A_z">z</code></td>
<td>
<p>A (<code>N * G</code>) matrix of posterior cluster membership probabilities whose (ig)-th entry gives the posterior probability that observation i belongs to cluster g. Entries must be valid probabilities in the interval [0,1]; missing values are not allowed.
</p>
<p>Otherwise, a list of such matrices can be supplied, where each matrix in the list has the same dimensions.</p>
</td></tr>
<tr><td><code id="post_conf_mat_+3A_scale">scale</code></td>
<td>
<p>A logical indicator whether the PCM should be rescaled by its row sums. When <code>TRUE</code> (the default), the benchmark matrix for comparison is the identity matrix of order <code>G</code>, corresponding to a situation with no uncertainty in the clustering. When <code>FALSE</code>, the row sums give the number of observations in each cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (<code>G * G</code>) posterior confusion matrix, whose hk-th entry gives the average probability that observations with maximum posterior allocation h will be assigned to cluster k. When <code>scale=TRUE</code>, the benchmark matrix for comparison is the identity matrix of order <code>G</code>, corresponding to a situation with no uncertainty in the clustering.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Ranciati, S., Vinciotti, V. and Wit, E., (2017) Identifying overlapping terrorist cells from the Noordin Top actor-event network, <em>Annals of Applied Statistics</em>, 14(3): 1516-1534.
</p>


<h3>See Also</h3>

<p><code>get_IMIFA_results</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data(olive)
# sim  &lt;- mcmc_IMIFA(olive, n.iters=1000)
# res  &lt;- get_IMIFA_results(sim)
# (PCM &lt;- post_conf_mat(res$Clust$post.prob))

# par(mar=c(5.1, 4.1, 4.1, 3.1))
# PCM  &lt;- replace(PCM, PCM == 0, NA)
# plot_cols(mat2cols(PCM, col=heat.colors(30, rev=TRUE), na.col=par()$bg)); box(lwd=2)
# heat_legend(PCM, cols=heat.colors(30, rev=TRUE))
# par(mar=c(5.1, 4.1, 4.1, 2.1))
</code></pre>

<hr>
<h2 id='Procrustes'>Procrustes Transformation</h2><span id='topic+Procrustes'></span>

<h3>Description</h3>

<p>This function performs a Procrustes transformation on a matrix <code>X</code> to minimize the squared distance between <code>X</code> and another comparable matrix <code>Xstar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Procrustes(X,
           Xstar,
           translate = FALSE,
           dilate = FALSE,
           sumsq = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Procrustes_+3A_x">X</code></td>
<td>
<p>The matrix to be transformed.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_xstar">Xstar</code></td>
<td>
<p>The target matrix.</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_translate">translate</code></td>
<td>
<p>Logical value indicating whether <code>X</code> should be translated (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_dilate">dilate</code></td>
<td>
<p>Logical value indicating whether <code>X</code> should be dilated (defaults to <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="Procrustes_+3A_sumsq">sumsq</code></td>
<td>
<p>Logical value indicating whether the sum of squared differences between <code>X</code> and <code>Xstar</code> should be calculated and returned.</p>
</td></tr>
</table>


<h3>Details</h3>


<p><code>R</code>, <code>tt</code>, and <code>d</code> are chosen so that:
</p>
<p style="text-align: center;"><code class="reqn">d \times \mathbf{X} \mathbf{R} + 1\hspace*{-3.5pt}1 \underline{t}^\top \approx X^\star</code>
</p>

<p><code>X.new</code> is given by:
</p>
<p style="text-align: center;"><code class="reqn">X_{\textrm{new}} = d \times \mathbf{X} \mathbf{R} + 1\hspace*{-3.5pt}1 \underline{t}^\top</code>
</p>




<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>X.new</code></td>
<td>
<p>The matrix that is the Procrustes transformed version of <code>X</code>.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>The rotation matrix.</p>
</td></tr>
<tr><td><code>t</code></td>
<td>
<p>The translation vector (if <code>isTRUE(translate)</code>).</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The scaling factor (is <code>isTRUE(dilate)</code>).</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>
<p>The sum of squared differences (if <code>isTRUE(sumsq)</code>).</p>
</td></tr>
</table>


<h3>Note</h3>

<p><code>X</code> is padded out with columns containing <code>0</code> if it has fewer columns than <code>Xstar</code>.
</p>


<h3>References</h3>

<p>Borg, I. and Groenen, P. J. F. (1997) <em>Modern Multidimensional Scaling: Theory and Applications</em>. Springer Series in Statistics. New York, NY, USA: Springer-Verlag, pp. 340-342.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Match two matrices, allowing translation and dilation
mat1     &lt;- diag(rnorm(10))
mat2     &lt;- 0.05 * matrix(rnorm(100), 10, 10) + mat1
proc     &lt;- Procrustes(X=mat1, Xstar=mat2, translate=TRUE, dilate=TRUE, sumsq=TRUE)

# Extract the transformed matrix, rotation matrix, translation vector and scaling factor
mat_new  &lt;- proc$X.new
mat_rot  &lt;- proc$R
mat_t    &lt;- proc$t
mat_d    &lt;- proc$d

# Compare the sum of squared differences to a Procrustean transformation with rotation only
mat_ss   &lt;- proc$ss
mat_ss2  &lt;- Procrustes(X=mat1, Xstar=mat2, sumsq=TRUE)$ss
</code></pre>

<hr>
<h2 id='psi_hyper'>Find sensible inverse gamma hyperparameters for variance/uniqueness parameters</h2><span id='topic+psi_hyper'></span>

<h3>Description</h3>

<p>Takes an inverse-Gamma shape hyperparameter, and an inverse covariance matrix (or estimate thereof), and finds data-driven scale hyperparameters in such a way that Heywood problems are avoided for factor analysis or probabilistic principal components analysis (and mixtures thereof).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi_hyper(shape,
          dat,
          type = c("unconstrained", "isotropic"),
          beta0 = 3,
          ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi_hyper_+3A_shape">shape</code></td>
<td>
<p>A positive shape hyperparameter.</p>
</td></tr>
<tr><td><code id="psi_hyper_+3A_dat">dat</code></td>
<td>
<p>The data matrix for which the inverse covariance matrix is to be estimated. If data are to be centered &amp;/or scaled within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, then <code>dat</code> must also be standardised in the same way.</p>
</td></tr>
<tr><td><code id="psi_hyper_+3A_type">type</code></td>
<td>
<p>A switch indicating whether a single scale (<code>isotropic</code>) or variable-specific scales (<code>unconstrained</code>) are to be derived. Both options are allowed under models in <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> with &quot;constrained&quot; or &quot;unconstrained&quot; uniquenesses, but only a single scale can be specified for models with &quot;isotropic&quot; or &quot;single&quot; uniquenesses.</p>
</td></tr>
<tr><td><code id="psi_hyper_+3A_beta0">beta0</code></td>
<td>
<p>See Note below. Must be a strictly positive numeric scalar. Defaults to <code>3</code>, but is only invoked when explicitly supplied or when the number of observations <code>N</code> is not greater than the number of variables <code>P</code> (or when inverting the sample covariance matrix somehow otherwise fails). In some cases, <code>beta0</code> should not be so small as to render the estimate of the inverse unstable.</p>
</td></tr>
<tr><td><code id="psi_hyper_+3A_...">...</code></td>
<td>
<p>Catches unused arguments. Advanced users can also supply the sample covariance matrix of <code>dat</code>, if available, through <code>...</code> via the argument <code>covar</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constraining uniquenesses to be isotropic provides the link between factor analysis and the probabilistic PCA model. When used in conjunction with <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> with &quot;isotropic&quot; or &quot;single&quot; uniquenesses, <code>type</code> must be <code>isotropic</code>, but for &quot;unconstrained&quot; or &quot;constrained&quot; uniquenesses, it's possible to specify either a single scale (<code>type="isotropic"</code>) or variable-specific scales (<code>type="unconstrained"</code>).
</p>
<p>Used internally by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> when its argument <code>psi_beta</code> is not supplied.
</p>


<h3>Value</h3>

<p>Either a single scale hyperparameter or <code>ncol(dat)</code> variable-specific scale hyperparameters.
</p>


<h3>Note</h3>

<p>When <code>N &gt; P</code>, where <code>N</code> is the number of observations and <code>P</code> is the number of variables, the inverse of the sample covariance matrix is used by default.
</p>
<p>When <code>N &lt;= P</code>, the inverse either does not exist or the estimate thereof is highly unstable. Thus, an estimate of the form <code class="reqn">\left(\beta_0 + \frac{N}{2}\right)\left(\beta_0\mathcal{I}_p + 0.5\sum_{i=1}^N x_i x_i^\top\right)^{-1}</code> is used instead.
</p>
<p>For unstandardised data, the estimate is instead constructed using a standardised version of the data, and the resulting inverse <em>correlation</em> matrix estimate is scaled appropriately by the diagonal entries of the sample covariance matrix of the original data.
</p>
<p>This estimate can also be used in <code>N &gt; P</code> cases by explicitly supplying <code>beta0</code>. It will also be used if inverting the sample covariance matrix fails in <code>N &gt; P</code> cases.
</p>
<p>The optional argument <code>beta0</code> can be supplied to <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> via the control function <code><a href="#topic+mixfaControl">mixfaControl</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>
<p>Fruwirth-Schnatter, S. and Lopes, H. F. (2010). Parsimonious Bayesian factor analysis when the number of factors is unknown, <em>Technical Report</em>. The University of Chicago Booth School of Business.
</p>
<p>Fruwirth-Schnatter, S. and Lopes, H. F. (2018). Sparse Bayesian factor analysis when the number of factors is unknown, <em>to appear</em>. &lt;<a href="https://arxiv.org/abs/1804.04231">arXiv:1804.04231</a>&gt;.
</p>
<p>Tipping, M. E. and Bishop, C. M. (1999). Probabilistic principal component analysis, <em>Journal of the Royal Statistical Society: Series B (Statistical Methodology)</em>, 61(3): 611-622.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+mixfaControl">mixfaControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(olive)
olive2  &lt;- olive[,-(1:2)]
shape   &lt;- 2.5
(scale1 &lt;- psi_hyper(shape=shape, dat=olive2))

# Try again with scaled data
olive_S &lt;- scale(olive2, center=TRUE, scale=TRUE)

# Use the inverse of the sample covariance matrix
(scale2 &lt;- psi_hyper(shape=shape, dat=olive_S))

# Use the estimated inverse covariance matrix
(scale3 &lt;- psi_hyper(shape=shape, dat=olive_S, beta0=3))

# In the normalised example, the mean uniquenesses (given by scale/(shape - 1)),
# can be interpreted as the prior proportion of the variance that is idiosyncratic
(prop1   &lt;- scale1/(shape - 1))
(prop2   &lt;- scale2/(shape - 1))
</code></pre>

<hr>
<h2 id='rDirichlet'>Simulate Mixing Proportions from a Dirichlet Distribution</h2><span id='topic+rDirichlet'></span>

<h3>Description</h3>

<p>Generates samples from the Dirichlet distribution with parameter <code>alpha</code> efficiently by simulating Gamma(<code>alpha</code>, 1) random variables and normalising them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rDirichlet(G,
           alpha,
           nn = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rDirichlet_+3A_g">G</code></td>
<td>
<p>The number of clusters for which weights need to be sampled.</p>
</td></tr>
<tr><td><code id="rDirichlet_+3A_alpha">alpha</code></td>
<td>
<p>The Dirichlet hyperparameter, either of length 1 or <code>G</code>. When the length of <code>alpha</code> is 1, this amounts to assuming an exchangeable prior, which doesn't favour one component over another. Be warned that this will be recycled if necessary. Larger values have the effect of making the returned samples more equal.</p>
</td></tr>
<tr><td><code id="rDirichlet_+3A_nn">nn</code></td>
<td>
<p>A vector giving the number of observations in each of G clusters so that Dirichlet posteriors rather than priors can be sampled from. This defaults to 0, i.e. simulation from the prior. Must be non-negative. Be warned that this will be recycled if necessary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Dirichlet vector of <code>G</code> weights which sum to 1.
</p>


<h3>Note</h3>

<p>Though the function is available for standalone use, note that few checks take place, in order to speed up repeated calls to the function inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. In particular, <code>alpha</code> and <code>nn</code> may be invisibly recycled.
</p>
<p>While small values of <code>alpha</code> have the effect of increasingly concentrating the mass onto fewer components, note that this function may return <code>NaN</code> for excessively small values of <code>alpha</code>, when <code>nn=0</code>; see the details of <code>rgamma</code> for small <code>shape</code> values.
</p>


<h3>References</h3>

<p>Devroye, L. (1986) <em>Non-Uniform Random Variate Generation</em>, New York, NY, USA: Springer-Verlag, p. 594.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>(prior      &lt;- rDirichlet(G=5, alpha=1))
(posterior  &lt;- rDirichlet(G=5, alpha=1, nn=c(20, 41, 32, 8, 12)))
(asymmetric &lt;- rDirichlet(G=5, alpha=c(3,4,5,1,2), nn=c(20, 41, 32, 8, 12)))
</code></pre>

<hr>
<h2 id='scores_MAP'>Decompose factor scores by cluster</h2><span id='topic+scores_MAP'></span>

<h3>Description</h3>

<p>Takes posterior summaries of the overall factor scores matrix and returns lists of sub-matrices corresponding to the <code>G</code>-cluster MAP partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scores_MAP(res,
           dropQ = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scores_MAP_+3A_res">res</code></td>
<td>
<p>An object of class <code>"Results_IMIFA"</code> generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="scores_MAP_+3A_dropq">dropQ</code></td>
<td>
<p>A logical indicating whether columns of the factor scores matrix should be dropped such that the number of columns in each sub-matrix corresponds to the cluster-specific number of factors (if the number of factors is indeed cluster-specific). When <code>FALSE</code> (the default), the number of columns instead remains common to all sub-matrices - given by the largest of the cluster-specific numbers of latent factors.
</p>
<p>Note that this argument is irrelevant (i.e. always <code>FALSE</code>) for the finite factor methods (<code>"FA"</code>, <code>"MFA"</code>, <code>"OMFA"</code>, and <code>"IMFA"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Under the models in the IMIFA family, there exists only one factor scores matrix. For the finite factor methods, this has dimensions <code>N * Q</code>.
</p>
<p>For the infinite factor methods (<code>"IFA"</code>, <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code>), the factor scores matrix has dimensions <code>N * Qmax</code>, where <code>Qmax</code> is the largest of the cluster-specific numbers of latent factors <code class="reqn">q_1,\ldots,q_g</code>. Entries of this matrix thus may have been padded out with zero entries, as appropriate, prior to the Procrustes rotation-based correction applied within <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> (thus now these entries will be near-zero).
</p>
<p>In partitioning rows of the factor scores matrix into the same clusters the corresponding observations themselves belong to according to the MAP clustering, the number of columns <em>may</em> vary according to the cluster-specific numbers of latent factors (depending on the value of <code>dropQ</code> and the method employed).
</p>


<h3>Value</h3>

<p>For models which achieve clustering, a list of lists (say <code>x</code>) decomposing the posterior mean scores (<code>x$post.eta</code>), the associated variance estimates (<code>x$var.eta</code>) and credible intervals (<code>x$ci.eta</code>), and the last valid sample of the scores (<code>x$last.eta</code>) into lists of length <code>G</code>, corresponding to the MAP clustering, with varying or common numbers of cluster-specific factors (depending on the value of <code>dropQ</code> and the method employed).
</p>
<p>For models with only one component, or the <code>"FA"</code> and <code>"IFA"</code> methods, scores cannot be decomposed, and posterior summaries of the scores will be returned unchanged.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coffee)
sim &lt;- mcmc_IMIFA(coffee, n.iters=1000)
res &lt;- get_IMIFA_results(sim)

# Examine the single posterior mean scores matrix
res$Scores$post.eta

# Decompose into G matrices, common numbers of columns
eta &lt;- scores_MAP(res)
eta$post.eta

# Allow the number of columns be cluster-specific
scores_MAP(res, dropQ=TRUE)$post.eta
</code></pre>

<hr>
<h2 id='shift_GA'>Moment Matching Parameters of Shifted Gamma Distributions</h2><span id='topic+shift_GA'></span>

<h3>Description</h3>

<p>This function takes shape and rate parameters of a Gamma distribution and modifies them to achieve the same expected value and variance when the left extent of the support of the distribution is shifted up or down.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_GA(shape,
         rate,
         shift = 0,
         param = c("rate", "scale"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_GA_+3A_shape">shape</code>, <code id="shift_GA_+3A_rate">rate</code></td>
<td>
<p>Shape and rate parameters a and b, respectively, of a Gamma(a, b) distribution. Both must be strictly positive.</p>
</td></tr>
<tr><td><code id="shift_GA_+3A_shift">shift</code></td>
<td>
<p>Modifier, such that the Gamma distribution has support on (<code>shift</code>, <code class="reqn">\infty</code>). Can be positive or negative, though typically negative and small.</p>
</td></tr>
<tr><td><code id="shift_GA_+3A_param">param</code></td>
<td>
<p>Switch controlling whether the supplied <code>rate</code> parameter is indeed a rate, or actually a scale parameter. Also governs whether the output is given in terms of rate or scale. Defaults to <code>"rate"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of length 2, containing the modified shape and rate parameters, respectively.
</p>


<h3>Note</h3>

<p>This function is invoked within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> when <code>discount</code> is <em>fixed</em> at a non-zero value and <code>learn.alpha=TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Shift a Ga(shape=4, rate=2) distribution to the left by 1;
# achieving the same expected value of 2 and variance of 1.
shift_GA(4, 2, -1)
</code></pre>

<hr>
<h2 id='show_digit'>Show image of grayscale grid</h2><span id='topic+show_digit'></span>

<h3>Description</h3>

<p>Plots an image of a grayscale grid representation of a digit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_digit(dat,
           col = NULL,
           ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_digit_+3A_dat">dat</code></td>
<td>
<p>A <code>matrix</code> or <code>data.frame</code> with the same number of rows and columns (or a vector which can be coerced to such a format), representing a grayscale map of a single digit.</p>
</td></tr>
<tr><td><code id="show_digit_+3A_col">col</code></td>
<td>
<p>The colour scale to be used. Defaults to <code>grey(seq(1, 0, length = ncol(dat)))</code>.</p>
</td></tr>
<tr><td><code id="show_digit_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to <code><a href="#topic+mat2cols">mat2cols</a></code> and/or <code><a href="#topic+plot_cols">plot_cols</a></code> (e.g. <code>na.col</code>) when <code>dat</code> is a matrix or <code><a href="graphics.html#topic+image">image</a></code> when <code>dat</code> is a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The desired image representation of the digit.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USPSdigits">USPSdigits</a></code>, <code><a href="#topic+show_IMIFA_digit">show_IMIFA_digit</a></code>, <code><a href="#topic+mat2cols">mat2cols</a></code>, <code><a href="#topic+plot_cols">plot_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(USPSdigits)

# Plot the first digit
show_digit(USPSdigits$train[1,-1])

# Visualise the overall mean
show_digit(colMeans(USPSdigits$train[,-1]))
</code></pre>

<hr>
<h2 id='show_IMIFA_digit'>Plot the posterior mean image</h2><span id='topic+show_IMIFA_digit'></span>

<h3>Description</h3>

<p>Plots the posterior mean of a given cluster from an <code>"IMIFA"</code>-related model fit to a digit data set in the form of a square grayscale grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_IMIFA_digit(res,
                 G = 1,
                 what = c("mean", "last"),
                 dat = NULL,
                 ind = NULL,
                 ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show_IMIFA_digit_+3A_res">res</code></td>
<td>
<p>An object of class <code>"Results_IMIFA"</code> generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
<tr><td><code id="show_IMIFA_digit_+3A_g">G</code></td>
<td>
<p>The index of the cluster for which the posterior mean digit is to be represented.</p>
</td></tr>
<tr><td><code id="show_IMIFA_digit_+3A_what">what</code></td>
<td>
<p>A switch controlling whether the <code>"mean"</code> or <code>"last"</code> valid sample is to be plotted.</p>
</td></tr>
<tr><td><code id="show_IMIFA_digit_+3A_dat">dat</code></td>
<td>
<p>The full grayscale grid data set (prior to centering and scaling). Necessary when <code>ind</code> is supplied or if pixels with standard deviation of 0 exist in the data set (which will have been automatically removed by <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>).</p>
</td></tr>
<tr><td><code id="show_IMIFA_digit_+3A_ind">ind</code></td>
<td>
<p>The index of columns of <code>dat</code> which were discarded prior to fitting the <code>"IMIFA"</code>-related model via <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. Can be a vector of column indices of <code>dat</code> or an equivalent vector of logicals. The discarded pixels are replaced by the column-means corresponding to <code>ind</code> among images assigned to the given cluster <code>G</code>.</p>
</td></tr>
<tr><td><code id="show_IMIFA_digit_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed, via <code><a href="#topic+show_digit">show_digit</a></code>, to <code><a href="#topic+mat2cols">mat2cols</a></code> and/or <code><a href="#topic+plot_cols">plot_cols</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to <code><a href="#topic+show_digit">show_digit</a></code> which supplies the posterior mean digit of a given cluster from a <code>"IMIFA"</code> model.
</p>


<h3>Value</h3>

<p>The desired image representation of the posterior mean digit (or the last valid sample) from the desired cluster.
</p>


<h3>Note</h3>

<p>Note that both centering and scaling of the original data prior to modelling is accounted for in reconstructing the means, but <code>dat</code>, if necessary, must be the raw data prior to pre-processing.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+USPSdigits">USPSdigits</a></code>, <code><a href="#topic+show_digit">show_digit</a></code>, <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+mat2cols">mat2cols</a></code>, <code><a href="#topic+plot_cols">plot_cols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the USPS data and discard peripheral digits
data(USPSdigits)
ylab  &lt;- USPSdigits$train[,1]
train &lt;- USPSdigits$train[,-1]
ind   &lt;- apply(train, 2, sd) &gt; 0.7
dat   &lt;- train[,ind]

# Fit an IMIFA model (warning: quite slow!)
# sim &lt;- mcmc_IMIFA(dat, n.iters=1000, prec.mu=1e-03, z.init="kmeans",
#                   centering=FALSE, scaling="none")
# res &lt;- get_IMIFA_results(sim, zlabels=ylab)

# Examine the posterior mean image of the first two clusters
# show_IMIFA_digit(res, dat=train, ind=ind)
# show_IMIFA_digit(res, dat=train, ind=ind, G=2)
</code></pre>

<hr>
<h2 id='sim_IMIFA'>Simulate Data from a Mixture of Factor Analysers Structure</h2><span id='topic+sim_IMIFA'></span><span id='topic+sim_IMIFA_data'></span><span id='topic+sim_IMIFA_model'></span>

<h3>Description</h3>

<p>Functions to simulate data of any size and dimension from a (infinite) mixture of (infinite) factor analysers parameterisation or fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_IMIFA_data(N = 300L,
               G = 3L,
               P = 50L,
               Q = rep(floor(log(P)), G),
               pis = rep(1/G, G),
               mu = NULL,
               psi = NULL,
               loadings = NULL,
               scores = NULL,
               nn = NULL,
               loc.diff = 2,
               non.zero = P,
               forceQg = TRUE,
               method = c("conditional", "marginal"))

sim_IMIFA_model(res,
                method = c("conditional", "marginal"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_IMIFA_+3A_n">N</code>, <code id="sim_IMIFA_+3A_g">G</code>, <code id="sim_IMIFA_+3A_p">P</code></td>
<td>
<p>Desired overall number of observations, number of clusters, and number of variables in the simulated data set. All must be a single integer.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_q">Q</code></td>
<td>
<p>Desired number of cluster-specific latent factors in the simulated data set. Can be specified either as a single integer if all clusters are to have the same number of factors, or a vector of length <code>G</code>. Defaults to <code>floor(log(P))</code> in each cluster. Should be less than the associated <code><a href="#topic+Ledermann">Ledermann</a></code> bound and the number of observations in the corresponding cluster. The argument <code>forceQg</code> can be used to enforce this upper limit. It is also advisable that <code>Q &lt;= floor((P - 1)/2)</code>, but this restriction is not enforced by <code>forceQg</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_pis">pis</code></td>
<td>
<p>Mixing proportions of the clusters in the data set if <code>G</code> &gt; 1. Must sum to 1. Defaults to <code>rep(1/G, G)</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_mu">mu</code></td>
<td>
<p>True values of the mean parameters, either as a single value, a vector of length <code>G</code>, a vector of length <code>P</code>, or a <code>G * P</code> matrix. If <code>mu</code> is missing, <code>loc.diff</code> is invoked to simulate distinct means for each cluster by default.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_psi">psi</code></td>
<td>
<p>True values of uniqueness parameters, either as a single value, a vector of length <code>G</code>, a vector of length <code>P</code>, or a <code>G * P</code> matrix. As such the user can specify uniquenesses as a diagonal or isotropic matrix, and further constrain uniquenesses across clusters if desired. If <code>psi</code> is missing, uniquenesses are simulated via <code>1/rgamma(P, 2, 1)</code> within each cluster by default.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_loadings">loadings</code></td>
<td>
<p>True values of the loadings matrix/matrices. Must be supplied in the form of a list of numeric matrices when <code>G &gt; 1</code>, otherwise a single matrix. Matrices must contain <code>P</code> rows and the number of columns must correspond to the values in <code>Q</code>. If <code>loadings</code> are not supplied, such matrices are populated with standard normal random variates by default (see <code>non.zero</code>).</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_scores">scores</code></td>
<td>
<p>True values of the latent factor scores, as a <code>N * max(Q)</code> numeric matrix. If <code>scores</code> are not supplied, such a matrix is populated with standard normal random variates by default. Only relevant when <code>method="conditional"</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_nn">nn</code></td>
<td>
<p>An alternative way to specify the size of each cluster, by giving the exact number of observations in each cluster explicitly. Must sum to <code>N</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_loc.diff">loc.diff</code></td>
<td>
<p>A parameter to control the closeness of the clusters in terms of the difference in their location vectors. Only relevant if <code>mu</code> is NOT supplied. Defaults to <code>2</code>.
</p>
<p>More specifically, <code>loc.diff</code> (if invoked) is invoked as follows: means are simulated with the vector of cluster-specific hypermeans given by:
</p>
<p><code>scale(1:G, center=TRUE, scale=FALSE) * loc.diff</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_non.zero">non.zero</code></td>
<td>
<p>Controls the number of non-zero entries in each loadings column (per cluster) <strong>only</strong> when <code>loadings</code> is not explicitly supplied. Values must be integers in the interval <code>[1,P]</code>. Defaults to <code>P</code>. The positions of the zeros are randomised, and non-zero entries are drawn from a standard normal.
</p>
<p>Must be given as a list of length <code>G</code> of vectors of length corresponding to <code>Q</code> when <code>G&gt;1</code>. Can be given either as such a list or simply a vector of length <code>Q</code> when <code>G=1</code>. Alternatively, a single integer can be supplied, common across all loadings columns across all clusters. In any case, <code>non.zero</code> will be affected by <code>forceQg=TRUE</code> by default (see below).</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_forceqg">forceQg</code></td>
<td>
<p>A logical indicating whether the upper limit on the number of cluster-specific factors <code>Q</code> is enforced. Defaults to <code>TRUE</code> for <code>sim_IMIFA_data</code>, but is always <code>FALSE</code> for <code>sim_IMIFA_model</code>. Note that when <code>forceQg=TRUE</code> is invoked, <code>non.zero</code> (see above) is also affected. This upper limit is determined by the <code><a href="#topic+Ledermann">Ledermann</a></code> bound and that <code>Q</code> must be less than the number of observations in the given cluster. It is also advisable that <code>Q &lt;= floor((P - 1)/2)</code>, but this restriction is not enforced by <code>forceQg</code>.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_method">method</code></td>
<td>
<p>A switch indicating whether the mixture to be simulated from is the conditional distribution of the data given the latent variables (default), or simply the marginal distribution of the data.</p>
</td></tr>
<tr><td><code id="sim_IMIFA_+3A_res">res</code></td>
<td>
<p>An object of class <code>"Results_IMIFA"</code> generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sim_IMIFA_model</code> is a simple wrapper to <code>sim_IMIFA_data</code> which uses the estimated parameters of a fitted IMIFA related model, as generated by <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>. The necessary parameters must have been originally stored via <code><a href="#topic+storeControl">storeControl</a></code> in the creation of <code>res</code>.
</p>


<h3>Value</h3>

<p>Invisibly returns a <code>data.frame</code> with <code>N</code> observations (rows) of <code>P</code> variables (columns). The true values of the parameters which generated these data are also stored as attributes.
</p>


<h3>Note</h3>

<p><code>N</code>, <code>G</code>, <code>P</code> &amp; <code>Q</code> will <strong>NOT</strong> be inferred from the supplied parameters <code>pis</code>, <code>mu</code>, <code>psi</code>, <code>loadings</code>, <code>scores</code> &amp; <code>nn</code> - rather, the parameters' length/dimensions must adhere to the supplied values of <code>N</code>, <code>G</code>, <code>P</code> &amp; <code>Q</code>.
</p>
<p>Missing values are not allowed in any of <code>pis</code>, <code>mu</code>, <code>psi</code>, <code>loadings</code>, <code>scores</code> &amp; <code>nn</code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Murphy, K., Viroli, C., and Gormley, I. C. (2020) Infinite mixtures of infinite factor analysers, <em>Bayesian Analysis</em>, 15(3): 937-963. &lt;<a href="https://doi.org/10.1214/19-BA1179">doi:10.1214/19-BA1179</a>&gt;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> for fitting an IMIFA related model to the simulated data set.
</p>
<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> for generating input for <code>sim_IMIFA_model</code>.
</p>
<p><code><a href="#topic+Ledermann">Ledermann</a></code> for details on the upper-bound for <code>Q</code>. Note that this function accounts for isotropic uniquenesses, if <code>psi</code> is supplied in that manner, in computing this bound.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate 100 observations from 3 balanced clusters with cluster-specific numbers of latent factors
# Specify isotropic uniquenesses within each cluster
# Supply cluster means directly
sim_data  &lt;- sim_IMIFA_data(N=100, G=3, P=20, Q=c(2, 2, 5), psi=1:3,
                            mu=matrix(rnorm(60, -2 + 1:3, 1), nrow=20, ncol=3, byrow=TRUE))
names(attributes(sim_data))
labels    &lt;- attr(sim_data, "Labels")

# Visualise the data in two-dimensions
plot(cmdscale(dist(sim_data), k=2), col=labels)

# Examine the overlap with a pairs plot of 5 randomly chosen variables
pairs(sim_data[,sample(1:20, 5)], col=labels)

# Fit a MIFA model to this data
# tmp     &lt;- mcmc_IMIFA(sim_data, method="MIFA", range.G=3, n.iters=5000)

# Simulate from this model
# res     &lt;- get_IMIFA_results(tmp, zlabels=labels)
# sim_mod &lt;- sim_IMIFA_model(res)
</code></pre>

<hr>
<h2 id='storeControl'>Set storage values for use with the IMIFA family of models</h2><span id='topic+storeControl'></span>

<h3>Description</h3>

<p>Supplies a list of values for logical switches indicating whether parameters of interest (means, scores, loadings, uniquenesses, and mixing proportions) should be stored when running models from the IMIFA family via <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. It may be useful not to store certain parameters if memory is an issue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>storeControl(mu.switch = TRUE,
             score.switch = TRUE,
             load.switch = TRUE,
             psi.switch = TRUE,
             pi.switch = TRUE,
             update.mu = mu.switch,
             ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="storeControl_+3A_mu.switch">mu.switch</code></td>
<td>
<p>Logical indicating whether the means are to be stored (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="storeControl_+3A_score.switch">score.switch</code></td>
<td>
<p>Logical indicating whether the factor scores are to be stored.
</p>
<p>As the array containing each sampled scores matrix tends to be amongst the largest objects to be stored, this defaults to <code>FALSE</code> inside <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code> when <code>length(range.G) * length(range.Q) &gt; 10</code>, otherwise the default is <code>TRUE</code>. For the <code>"MIFA"</code>, <code>"OMIFA"</code>, and <code>"IMIFA"</code> methods, setting this switch to <code>FALSE</code> also offers a slight speed-up.
</p>
<p>Unlike other parameters, the scores need not be stored for posterior predictive checking (see Note below).</p>
</td></tr>
<tr><td><code id="storeControl_+3A_load.switch">load.switch</code></td>
<td>
<p>Logical indicating whether the factor loadings are to be stored (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="storeControl_+3A_psi.switch">psi.switch</code></td>
<td>
<p>Logical indicating whether the uniquenesses are to be stored (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="storeControl_+3A_pi.switch">pi.switch</code></td>
<td>
<p>Logical indicating whether the mixing proportions are to be stored (defaults to <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="storeControl_+3A_update.mu">update.mu</code></td>
<td>
<p>Logical indicating whether the means should be updated. Only relevant for the <code>"FA"</code> and <code>"IFA"</code> methods when <code>centering=TRUE</code> in <code><a href="#topic+mixfaControl">mixfaControl</a></code>, otherwise means are always updated. Setting <code>update.mu=FALSE</code> forces <code>mu.switch</code> to <code>FALSE</code>, but <code>mu.switch=FALSE</code> can still be used in conjunction with <code>update.mu=TRUE</code>.</p>
</td></tr>
<tr><td><code id="storeControl_+3A_...">...</code></td>
<td>
<p>Catches unused arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+storeControl">storeControl</a></code> is provided for assigning values for IMIFA models within <code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>. It may be useful not to store certain parameters if memory is an issue (e.g. for large data sets or for a large number of MCMC iterations after burnin and thinning).
</p>


<h3>Value</h3>

<p>A named vector in which the names are the names of the storage switches and the values are logicals indicating whether that parameter is to be stored. The list also contains as an attribute a logical for each switch indicating whether it was actually supplied (<code>TRUE</code>) or the default was accepted (<code>FALSE</code>).
</p>


<h3>Note</h3>

<p>Posterior inference and plotting won't be possible for parameters not stored.
</p>
<p>Non-storage of parameters will almost surely prohibit the computation of posterior predictive checking error metrics within <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> also. In particular, if such error metrics are desired, <code>psi.switch</code> must be <code>TRUE</code> for all but the <code>"FA"</code> and <code>"IFA"</code> models, <code>mu.switch</code> must be <code>TRUE</code> except in situations where <code>update.mu=FALSE</code> is allowed, <code>load.switch</code> must be <code>TRUE</code> for all but the entirely zero-factor models, and <code>pi.switch</code> must be <code>TRUE</code> for models with clustering structure and unequal mixing proportions for all but the PPRE metric. <code>score.switch=TRUE</code> is not required for any posterior predictive checking.
</p>
<p>If post-hoc adaptation is invoked in <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code> on a model fitted without adaptation, <code>store.switch=TRUE</code> is not required unless <code>active.crit="SC"</code> (for <code>"IFA"</code> models only); <code>load.switch=TRUE</code> is required for both <code>active.crit="BD"</code> and <code>active.crit="SC"</code>.
</p>
<p>Finally, if loadings are not stored but scores are, caution is advised when examining posterior scores as Procrustes rotation will not occur within <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_IMIFA">mcmc_IMIFA</a></code>, <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="#topic+mixfaControl">mixfaControl</a></code>, <code><a href="#topic+mgpControl">mgpControl</a></code>, <code><a href="#topic+bnpControl">bnpControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stctrl &lt;- storeControl(score.switch=FALSE)

# data(olive)
# sim  &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000, storage=stctrl)

# Alternatively specify these arguments directly
# sim  &lt;- mcmc_IMIFA(olive, "IMIFA", n.iters=5000, score.switch=FALSE)
</code></pre>

<hr>
<h2 id='USPSdigits'>USPS handwritten digits</h2><span id='topic+USPSdigits'></span>

<h3>Description</h3>

<p>Training and test sets for the United States Postal Service (USPS) handwritten digits data, with 8-bit 16x16 grayscale grid representations of image scans of the digits &quot;0&quot; through &quot;9&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(USPSdigits)
</code></pre>


<h3>Format</h3>

<p>A list of length 2 with the following elements, each one a <code>data.frame</code>:
</p>

<dl>
<dt><code>train</code></dt><dd><p>The training set of 7,291 digits.</p>
</dd>
<dt><code>test</code></dt><dd><p>The test set of 2,007 digits.</p>
</dd></dl>

<p>Each <code>data.frame</code> contains the known digit labels in its first column.
</p>
<p>The remaining 256 columns give the concatenation of the 16x16 grid.
</p>
<p>Pixels are scaled such that [-1,1] corresponds to [white,black].
</p>


<h3>References</h3>

<p>Hastie, T., Tibshirani, R., and Friedman, J. (2001). <em>The Elements of Statistical Learning</em> (2<sup>nd</sup> edition). Springer Series in Statistics. New York, NY, USA: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+show_digit">show_digit</a></code>, <code><a href="#topic+show_IMIFA_digit">show_IMIFA_digit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the data and record the labels
data(USPSdigits, package="IMIFA")
ylab  &lt;- USPSdigits$train[,1]
train &lt;- USPSdigits$train[,-1]

# Examine the effect of discarding peripheral pixels
SDs   &lt;- apply(train, 2, sd)
ind   &lt;- SDs &gt; 0.7
dat   &lt;- train[,ind]

hist(SDs, breaks=200, xlim=c(0, 1))
rect(0.7, 0, 1, 12, col=2, density=25)

show_digit(ind) # retained pixels are shown in black
</code></pre>

<hr>
<h2 id='Zsimilarity'>Summarise MCMC samples of clustering labels with a similarity matrix and find the 'average' clustering</h2><span id='topic+Zsimilarity'></span>

<h3>Description</h3>

<p>This function takes a Monte Carlo sample of cluster labels, computes an average similarity matrix and returns the clustering with minimum mean squared error to this average. The <code><a href="mcclust.html#topic+mcclust">mcclust</a></code> package <strong>must</strong> be loaded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Zsimilarity(zs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Zsimilarity_+3A_zs">zs</code></td>
<td>
<p>A matrix containing samples of clustering labels where the columns correspond to the number of observations (N) and the rows correspond to the number of iterations (M).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a Monte Carlo sample of cluster labels, converts them to adjacency matrices, and computes a similarity matrix as an average of the adjacency matrices. The dimension of the similarity matrix is invariant to label switching and the number of clusters in each sample, desirable features when summarising partitions of Bayesian nonparametric models such as IMIFA. As a summary of the posterior clustering, the clustering with minimum mean squared error to this 'average' clustering is reported.
</p>
<p>A heatmap of <code>z.sim</code> may provide a useful visualisation, if appropriately ordered. The user is also invited to perform hierarchical clustering using <code><a href="stats.html#topic+hclust">hclust</a></code> after first converting this similarity matrix to a distance matrix - &quot;complete&quot; linkage is recommended. Alternatively, <code><a href="mclust.html#topic+hc">hc</a></code> could be used.
</p>


<h3>Value</h3>

<p>A list containing three elements:
</p>
<table>
<tr><td><code>z.avg</code></td>
<td>
<p>The 'average' clustering, with minimum squared distance to <code>z.sim</code>.</p>
</td></tr>
<tr><td><code>z.sim</code></td>
<td>
<p>The N x N similarity matrix, in a sparse format (see <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code>).</p>
</td></tr>
<tr><td><code>MSE.z</code></td>
<td>
<p>A vector of length M recording the MSEs between each clustering and the 'average' clustering.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code><a href="mcclust.html#topic+mcclust">mcclust</a></code> package <strong>must</strong> be loaded.
</p>
<p>This is liable to take quite some time to run, especially if the number of observations &amp;/or number of iterations is large. Depending on how distinct the clusters are, <code>z.sim</code> may be stored better in a non-sparse format. This function can optionally be called inside <code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>.
</p>


<h3>Author(s)</h3>

<p>Keefe Murphy - &lt;<a href="mailto:keefe.murphy@mu.ie">keefe.murphy@mu.ie</a>&gt;
</p>


<h3>References</h3>

<p>Carmona, C., Nieto-barajas, L. and Canale, A. (2018) Model based approach for household clustering with mixed scale variables. <em>Advances in Data Analysis and Classification</em>, 13(2): 559-583.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_IMIFA_results">get_IMIFA_results</a></code>, <code><a href="slam.html#topic+simple_triplet_matrix">simple_triplet_matrix</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="mclust.html#topic+hc">hc</a></code>, <code><a href="mcclust.html#topic+comp.psm">comp.psm</a></code>, <code><a href="mcclust.html#topic+cltoSim">cltoSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Run a IMIFA model and extract the sampled cluster labels
# data(olive)
# sim    &lt;- mcmc_IMIFA(olive, method="IMIFA", n.iters=5000)
# zs     &lt;- sim[[1]][[1]]$z.store

# Get the similarity matrix and visualise it
# zsimil &lt;- Zsimilarity(zs)
# z.sim  &lt;- as.matrix(zsimil$z.sim)
# z.col  &lt;- mat2cols(z.sim, cols=heat.colors(30, rev=TRUE))
# z.col[z.sim == 0] &lt;- NA
# plot_cols(z.col, na.col=par()$bg); box(lwd=2)

# Extract the clustering with minimum squared distance to this
# 'average' and evaluate its performance against the true labels
# table(zsimil$z.avg, olive$area)

# Perform hierarchical clustering on the distance matrix
# Hcl    &lt;- hclust(as.dist(1 - z.sim), method="complete")
# plot(Hcl)
# table(cutree(Hcl, k=3), olive$area)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
