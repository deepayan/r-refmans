<!DOCTYPE html><html><head><title>Help for package ICEbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICEbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clusterICE'>
<p>Clustering of ICE and d-ICE curves by kmeans.</p></a></li>
<li><a href='#dice'>
<p>Creates an object of class <code>dice</code>.</p></a></li>
<li><a href='#ice'>
<p>Creates an object of class <code>ice</code>.</p></a></li>
<li><a href='#plot.dice'>
<p>Create a plot of a <code>dice</code> object.</p></a></li>
<li><a href='#plot.ice'>
<p>Plotting of <code>ice</code> objects.</p></a></li>
<li><a href='#print.dice'>
<p>Print method for <code>dice</code> objects.</p></a></li>
<li><a href='#print.ice'>
<p>Print method for <code>ice</code> objects.</p></a></li>
<li><a href='#summary.dice'>
<p>Summary function for <code>dice</code> objects.</p></a></li>
<li><a href='#summary.ice'>
<p>Summary function for <code>ice</code> objects.</p></a></li>
<li><a href='#WhiteWine'><p>Data concerning white wine.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Individual Conditional Expectation Plot Toolbox</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Alex Goldstein, Adam Kapelner, Justin Bleich</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam Kapelner &lt;kapelner@qc.cuny.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements Individual Conditional Expectation (ICE) plots, a tool for visualizing the model estimated by any supervised learning algorithm. ICE plots refine Friedman's partial dependence plot by graphing the functional relationship between the predicted response and a covariate of interest for individual observations. Specifically, ICE plots highlight the variation in the fitted values across the range of a covariate of interest, suggesting where and to what extent they may exist.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>sfsmisc</td>
</tr>
<tr>
<td>Suggests:</td>
<td>randomForest, MASS</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-22 14:00:12 UTC; kapel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 14:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='clusterICE'>
Clustering of ICE and d-ICE curves by kmeans.
</h2><span id='topic+clusterICE'></span>

<h3>Description</h3>

<p>Clustering if ICE and d-ICE curves by kmeans. All curves are centered to have mean 0
and then kmeans is applied to the curves with the specified number of clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterICE(ice_obj, nClusters, plot = TRUE, plot_margin = 0.05, 
           colorvec, plot_pdp = FALSE, x_quantile = FALSE, 
           avg_lwd = 3, centered = FALSE, 
           plot_legend = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterICE_+3A_ice_obj">ice_obj</code></td>
<td>

<p>Object of class <code>ice</code> or <code>dice</code> to cluster.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_nclusters">nClusters</code></td>
<td>

<p>Number of clusters to find.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code>, plots the clusters.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_plot_margin">plot_margin</code></td>
<td>

<p>Extra margin to pass to <code>ylim</code> as a fraction of the range of cluster centers.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_colorvec">colorvec</code></td>
<td>

<p>Optional vector of colors to use for each cluster.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_plot_pdp">plot_pdp</code></td>
<td>

<p>If <code>TRUE</code>, the PDP (<code>ice</code> object) or d-PDP (<code>dice</code> object) 
is plotted with a dotted black line and highlighted in yellow.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_x_quantile">x_quantile</code></td>
<td>

<p>If <code>TRUE</code>, the plot is drawn with the x-axis taken to be <code>quantile(gridpts)</code>. If <code>FALSE</code>,
the predictor's original scale is used.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_avg_lwd">avg_lwd</code></td>
<td>

<p>Average line width to use when plotting the cluster means.  Line width is proportional to the cluster's
size.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_centered">centered</code></td>
<td>

<p>If <code>TRUE</code>, all cluster means are shifted to be to be 0 at the minimum value of the predictor.
If <code>FALSE</code>, the original cluster means are used. 
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_plot_legend">plot_legend</code></td>
<td>

<p>If <code>TRUE</code> a legend mapping line colors to the proportion of the data in each cluster is 
added to the plot.
</p>
</td></tr>
<tr><td><code id="clusterICE_+3A_...">...</code></td>
<td>
<p>Additional arguments for plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The ouput of the <code>kmeans</code> call (a list of class <code>kmeans</code>).
</p>


<h3>See Also</h3>

<p>ice, dice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ICEbox)
require(randomForest)
require(MASS) #has Boston Housing data, Pima

data(Boston) #Boston Housing data
X = Boston
y = X$medv
X$medv = NULL

## build a RF:
bh_rf = randomForest(X, y)

## Create an 'ice' object for the predictor "age":
bh.ice = ice(object = bh_rf, X = X, y = y, predictor = "age",
            frac_to_build = .1) 

## cluster the curves into 2 groups.
clusterICE(bh.ice, nClusters = 2, plot_legend = TRUE)

## cluster the curves into 3 groups, start all at 0.
clusterICE(bh.ice, nClusters = 3, plot_legend = TRUE, center = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='dice'>
Creates an object of class <code>dice</code>.
</h2><span id='topic+dice'></span>

<h3>Description</h3>

<p>Estimates the partial derivative function for each curve in an <code>ice</code> object.
See Goldstein et al (2013) for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dice(ice_obj, DerivEstimator)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dice_+3A_ice_obj">ice_obj</code></td>
<td>

<p>Object of class <code>ice</code>. This function generates partial derivative 
estimates for each row in <code>ice_obj$ice_curves</code>.
</p>
</td></tr>
<tr><td><code id="dice_+3A_derivestimator">DerivEstimator</code></td>
<td>

<p>Optional function with a single argument <code>y</code>.  Returns the estimated 
partial derivative of a function sampled at the points (<code>ice_obj$gridpts</code>,<code>y</code>).
If omitted, the default (a) smooths (<code>ice_obj$gridpts</code>,<code>y</code>) using
<code>supsmu</code> and then (b) uses the <code>D1tr</code> function (&quot;discrete 
first derivative using simple difference ratios&quot;)  found in the <code>sfsmisc</code>
package to estimate the derivative.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>dice</code> with the following elements. Most are passed directly through
from <code>ice_object</code> and exist to enable various plotting facilities.
</p>
<table>
<tr><td><code>d_ice_curves</code></td>
<td>
<p>Matrix of dimension <code>nrow(Xice)</code> by <code>length(gridpts)</code>.
Each row corresponds to an observation's d-ICE curve, estimated at the values of <code>predictor</code> in <code>gridpts</code>.</p>
</td></tr>
<tr><td><code>xj</code></td>
<td>
<p>The actual values of <code>predictor</code> observed in the data in the order
of <code>Xice</code>.</p>
</td></tr>
<tr><td><code>actual_deriv</code></td>
<td>
<p>Vector of length <code>nrow(Xice)</code> containing the estimated partial derivatives
at the value of the <code>predictor</code> actually found in <code>Xice</code>.</p>
</td></tr>
<tr><td><code>sd_deriv</code></td>
<td>
<p>Vector of length <code>length(gridpts)</code> with the cross-observation sd of partial derivative
estimates.  For instance <code>sd_deriv[1]</code> equals <code>sd(d_ice_curves[,1])</code>.</p>
</td></tr>
<tr><td><code>logodds</code></td>
<td>
<p>Passed from <code>ice_object</code>.  If <code>TRUE</code>, <code>d_ice_curves</code> are
estimated derivatives of the centered log-odds.</p>
</td></tr>
<tr><td><code>gridpts</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>predictor</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>xlab</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>nominal_axis</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>range_y</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>Xice</code></td>
<td>
<p>Passed from <code>ice_object</code>.</p>
</td></tr>
<tr><td><code>dpdp</code></td>
<td>
<p>The estimated partial derivative of the PDP.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E., Peeking
Inside the Black Box: Visualizing Statistical Learning With Plots of
Individual Conditional Expectation. (2014) Journal of Computational
and Graphical Statistics, in press <br />
</p>
<p>Martin Maechler et al. sfsmisc: Utilities from Seminar fuer Statistik ETH Zurich. 
R package version 1.0-24.
</p>


<h3>See Also</h3>

<p>plot.dice, print.dice, summary.dice
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run: 
# same examples as for 'ice', but now create a derivative estimate as well.
require(ICEbox)
require(randomForest)
require(MASS) #has Boston Housing data, Pima

########  regression example
data(Boston) #Boston Housing data
X = Boston
y = X$medv
X$medv = NULL

## build a RF:
bhd_rf_mod = randomForest(X, y)

## Create an 'ice' object for the predictor "age":
bhd.ice = ice(object = bhd_rf_mod, X = X, y = y, predictor = "age", frac_to_build = .1)

# make a dice object:
bhd.dice = dice(bhd.ice)

#### classification example
data(Pima.te)  #Pima Indians diabetes classification
y = Pima.te$type
X = Pima.te
X$type = NULL

## build a RF:
pima_rf = randomForest(x = X, y = y)

## Create an 'ice' object for the predictor "skin":
# For classification we plot the centered log-odds. If we pass a predict
# function that returns fitted probabilities, setting logodds = TRUE instructs
# the function to set each ice curve to the centered log-odds of the fitted 
# probability. 
pima.ice = ice(object = pima_rf, X = X, predictor = "skin", logodds = TRUE,
                    predictfcn = function(object, newdata){ 
                         predict(object, newdata, type = "prob")[, 2]
                    }
              )

# make a dice object:
pima.dice = dice(pima.ice)

## End(Not run)

</code></pre>

<hr>
<h2 id='ice'>
Creates an object of class <code>ice</code>.
</h2><span id='topic+ice'></span>

<h3>Description</h3>

<p>Creates an <code>ice</code> object with individual conditional expectation curves
for the passed model object, <code>X</code> matrix, predictor, and response.  See
Goldstein et al (2013) for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ice(object, X, y, predictor, predictfcn, verbose = TRUE, frac_to_build = 1, 
             indices_to_build = NULL, num_grid_pts, logodds = FALSE, probit = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ice_+3A_object">object</code></td>
<td>

<p>The fitted model to estimate ICE curves for.
</p>
</td></tr>
<tr><td><code id="ice_+3A_x">X</code></td>
<td>

<p>The design matrix we wish to estimate ICE curves for. Rows are observations, columns are
predictors.  Typically this is taken to be <code>object</code>'s training data, but this is not
strictly necessary.
</p>
</td></tr>
<tr><td><code id="ice_+3A_y">y</code></td>
<td>

<p>Optional vector of the response values <code>object</code> was trained on.  It is used
to compute y-axis ranges that are useful for plotting.  If not passed, the range
of predicted values is used and a warning is printed.
</p>
</td></tr>
<tr><td><code id="ice_+3A_predictor">predictor</code></td>
<td>

<p>The column number or variable name in <code>X</code> of the predictor of interest, 
(<code class="reqn">x_S = X[, j]</code>).
</p>
</td></tr>
<tr><td><code id="ice_+3A_predictfcn">predictfcn</code></td>
<td>

<p>Optional function that accepts two arguments, <code>object</code> and <code>newdata</code>, and
returns an <code>N</code> vector of <code>object</code>'s predicted response for data <code>newdata</code>. 
If this argument is not passed, the procedure attempts to find a generic <code>predict</code> 
function corresponding to <code>class(object)</code>.
</p>
</td></tr>
<tr><td><code id="ice_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, prints messages about the procedure's progress.
</p>
</td></tr>
<tr><td><code id="ice_+3A_frac_to_build">frac_to_build</code></td>
<td>

<p>Number between 0 and 1, with 1 as default.  For large <code>X</code> matrices or fitted models
that are slow to make predictions, specifying <code>frac_to_build</code> less than 1 will choose
a subset of the observations to build curves for. The subset is chosen such that the remaining
observations' values of <code>predictor</code> are evenly spaced throughout the quantiles of the
full <code>X[,predictor]</code> vector.  
</p>
</td></tr>
<tr><td><code id="ice_+3A_indices_to_build">indices_to_build</code></td>
<td>

<p>Vector of indices, <code class="reqn">\subset \{1, \ldots, nrow(X)\}</code> specifying which observations to build ICE curves for. As this is an alternative to setting <code>frac_to_build</code>, both 
cannot be specified.
</p>
</td></tr>
<tr><td><code id="ice_+3A_num_grid_pts">num_grid_pts</code></td>
<td>

<p>Optional number of values in the range of <code>predictor</code> at which to estimate each curve. 
If missing, the curves are estimated at each unique value of <code>predictor</code> 
in the <code>X</code> observations we estimate ICE curves for.
</p>
</td></tr>
<tr><td><code id="ice_+3A_logodds">logodds</code></td>
<td>

<p>If <code>TRUE</code>, for classification creates PDPs by plotting the centered log-odds implied by the fitted 
probabilities. We assume that the generic or passed predict function 
returns probabilities, and so the flag tells us to transform these to centered logits after 
the predictions are generated. Note: <code>probit</code> cannot be <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ice_+3A_probit">probit</code></td>
<td>

<p>If <code>TRUE</code>, for classification creates PDPs by plotting the probit implied by the fitted 
probabilities. We assume that the generic or passed predict function 
returns probabilities, and so the flag tells us to transform these to probits after 
the predictions are generated. Note: <code>logodds</code> cannot be <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ice_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to <code>object</code>'s generic predict function.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>ice</code> with the following elements.
</p>
<table>
<tr><td><code>gridpts</code></td>
<td>
<p>Sorted values of <code>predictor</code> at which each curve is estimated. Duplicates
are removed &ndash; by definition, elements of <code>gridpts</code> are unique.</p>
</td></tr>
<tr><td><code>ice_curves</code></td>
<td>
<p>Matrix of dimension <code>nrow(X)</code> by <code>length(gridpts)</code>.
Each row corresponds to an observation's ICE curve, estimated at the values of <code>predictor</code> in 
<code>gridpts</code>.</p>
</td></tr>
<tr><td><code>xj</code></td>
<td>
<p>The actual values of <code>predictor</code> observed in the data in the order
of <code>Xice</code>.</p>
</td></tr>
<tr><td><code>actual_predictions</code></td>
<td>
<p>Vector of length <code>nrow(X)</code> containing the model's 
predictions at the actual value of the predictors in the order of <code>Xice</code>.</p>
</td></tr>
<tr><td><code>xlab</code></td>
<td>
<p>String with the predictor name corresponding to <code>predictor</code>. If <code>predictor</code>
is a column number, <code>xlab</code> is set to <code>colnames(X)[, predictor]</code>.</p>
</td></tr>
<tr><td><code>nominal_axis</code></td>
<td>
<p>If <code>TRUE</code>, <code>length(gridpts)</code> is 5 or fewer; otherwise <code>FALSE</code>.
When <code>TRUE</code> the <code>plot</code> function treats the x-axis as if x is nominal.</p>
</td></tr>
<tr><td><code>range_y</code></td>
<td>
<p>If <code>y</code> was passed, the range of the response.  Otherwise it defaults to be <br />
<code>max(ice_curves)</code> - <code>min(ice_curves)</code> and a message is printed to the console.</p>
</td></tr>
<tr><td><code>sd_y</code></td>
<td>
<p>If <code>y</code> was passed, the standard deviation of the response.  Otherwise it is defaults to
<code>sd(actual_predictions)</code> and a message is printed to the console.</p>
</td></tr>
<tr><td><code>Xice</code></td>
<td>
<p>A matrix containing the subset of <code>X</code> for which ICE curves are estimated. 
Observations are ordered to be increasing in <code>predictor</code>.  This ordering is the same one 
as in <code>ice_curves</code>, <code>xj</code> and <code>actual_predictions</code>, meaning for all these objects
the <code>i</code>-th element refers to the same observation in <code>X</code>.</p>
</td></tr>
<tr><td><code>pdp</code></td>
<td>
<p>A vector of size <code>length(gridpts)</code> which is a numerical approximation to the partial 
dependence function (PDP) corresponding to the estimated ICE curves. See Goldstein et al (2013) for a discussion
of how the PDP is a form of post-processing. See Friedman (2001) for a description of PDPs.</p>
</td></tr>
<tr><td><code>predictor</code></td>
<td>
<p>Same as the argument, see argument description.</p>
</td></tr>
<tr><td><code>logodds</code></td>
<td>
<p>Same as the argument, see argument description.</p>
</td></tr>
<tr><td><code>indices_to_build</code></td>
<td>
<p>Same as the argument, see argument description.</p>
</td></tr>
<tr><td><code>frac_to_build</code></td>
<td>
<p>Same as the argument, see argument description.</p>
</td></tr>
<tr><td><code>predictfcn</code></td>
<td>
<p>Same as the argument, see argument description.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Jerome Friedman. Greedy Function Approximation: A Gradient Boosting Machine. The Annals of Statistics,
29(5): 1189-1232, 2001.
</p>
<p>Goldstein, A., Kapelner, A., Bleich, J., and Pitkin, E., Peeking
Inside the Black Box: Visualizing Statistical Learning With Plots of
Individual Conditional Expectation. (2014) Journal of Computational
and Graphical Statistics, in press
</p>


<h3>See Also</h3>

<p>plot.ice, print.ice, summary.ice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ICEbox)
require(randomForest)
require(MASS) #has Boston Housing data, Pima

########  regression example
data(Boston) #Boston Housing data
X = Boston
y = X$medv
X$medv = NULL

## build a RF:
bhd_rf_mod = randomForest(X, y)

## Create an 'ice' object for the predictor "age":
bhd.ice = ice(object = bhd_rf_mod, X = X, y = y, predictor = "age", frac_to_build = .1) 

#### classification example
data(Pima.te)  #Pima Indians diabetes classification
y = Pima.te$type
X = Pima.te
X$type = NULL

## build a RF:
pima_rf_mod = randomForest(x = X, y = y)

## Create an 'ice' object for the predictor "skin":
# For classification we plot the centered log-odds. If we pass a predict
# function that returns fitted probabilities, setting logodds = TRUE instructs
# the function to set each ice curve to the centered log-odds of the fitted 
# probability.
pima.ice = ice(object = pima_rf_mod, X = X, predictor = "skin", logodds = TRUE,
                    predictfcn = function(object, newdata){ 
                         predict(object, newdata, type = "prob")[, 2]
                    }
              )


## End(Not run)
</code></pre>

<hr>
<h2 id='plot.dice'>
Create a plot of a <code>dice</code> object.
</h2><span id='topic+plot.dice'></span>

<h3>Description</h3>

<p>Plotting of <code>dice</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dice'
plot(x, plot_margin = 0.05, frac_to_plot = 1, 
      plot_sd = TRUE, plot_orig_pts_deriv = TRUE, pts_preds_size = 1.5, 
      colorvec, color_by = NULL, x_quantile = TRUE, plot_dpdp = TRUE, 
      rug_quantile = seq(from = 0, to = 1, by = 0.1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dice_+3A_x">x</code></td>
<td>

<p>Object of class <code>dice</code> to plot.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_plot_margin">plot_margin</code></td>
<td>

<p>Extra margin to pass to <code>ylim</code> as a fraction of the range of <code>x$d_ice_curves</code>.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_frac_to_plot">frac_to_plot</code></td>
<td>

<p>If <code>frac_to_plot</code> is less than 1, randomly plot <code>frac_to_plot</code> fraction of the
curves in <code>x$d_ice_curves</code>.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_plot_sd">plot_sd</code></td>
<td>

<p>If <code>TRUE</code>, plot the cross-observation sd of partial derivatives below the derivative plots.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_plot_orig_pts_deriv">plot_orig_pts_deriv</code></td>
<td>

<p>If <code>TRUE</code>, marks each curve at the location of the derivative estimate at the
location of <code>predictor</code> actually occurring in the data. If <code>FALSE</code>
no mark is drawn.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_pts_preds_size">pts_preds_size</code></td>
<td>

<p>Size of points to make if <code>plot_orig_pts_deriv</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_colorvec">colorvec</code></td>
<td>

<p>Optional vector of colors to use for each curve.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_color_by">color_by</code></td>
<td>

<p>Optional variable name (or column number) in <code>Xice</code> to color curves by. If the <code>color_by</code>
variable has 10 or fewer unique values, a discrete set of colors is used for each value and a legend is 
printed and returned. If there are more values, curves are colored from light to dark corresponding 
to low to high values of the variable specified by <code>color_by</code>.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_x_quantile">x_quantile</code></td>
<td>

<p>If <code>TRUE</code>, the plot is drawn with the x-axis taken to be <code>quantile(gridpts)</code>. If <code>FALSE</code>,
the predictor's original scale is used.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_plot_dpdp">plot_dpdp</code></td>
<td>

<p>If <code>TRUE</code>, the estimated derivative of the PDP is plotted and highlighted in yellow.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_rug_quantile">rug_quantile</code></td>
<td>

<p>If not null, tick marks are drawn on the x-axis corresponding to the vector of quantiles specified by this parameter.
Forced to <code>NULL</code> when <code>x_quantile</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.dice_+3A_...">...</code></td>
<td>

<p>Additional plotting arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>plot_points_indices</code></td>
<td>
<p>Row numbers of <code>Xice</code> of those observations presented in the plot.</p>
</td></tr>
<tr><td><code>legend_text</code></td>
<td>
<p>If the <code>color_by</code> argument was used, 
a legend describing the map between the <code>color_by</code> predictor
and curve colors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ICEbox)
require(randomForest)
require(MASS) #has Boston Housing data, Pima

data(Boston) #Boston Housing data
X = Boston
y = X$medv
X$medv = NULL

## build a RF:
bhd_rf_mod = randomForest(X, y)

## Create an 'ice' object for the predictor "age":
bhd.ice = ice(object = bhd_rf_mod, X = X, y = y, predictor = "age", frac_to_build = .1) 

# estimate derivatives, then plot.
bhd.dice = dice(bhd.ice)
plot(bhd.dice)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.ice'>
Plotting of <code>ice</code> objects.
</h2><span id='topic+plot.ice'></span>

<h3>Description</h3>

<p>Plotting of <code>ice</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ice'
plot(x, plot_margin = 0.05, frac_to_plot = 1, 
	 plot_points_indices = NULL, plot_orig_pts_preds = TRUE, 
     pts_preds_size = 1.5, colorvec, color_by = NULL, 
     x_quantile = TRUE, plot_pdp = TRUE,
     centered = FALSE, prop_range_y = TRUE, 
     rug_quantile = seq(from = 0, to = 1, by = 0.1),
     centered_percentile = 0, 
     point_labels = NULL, point_labels_size = NULL, 
     prop_type,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ice_+3A_x">x</code></td>
<td>

<p>Object of class <code>ice</code> to plot.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_plot_margin">plot_margin</code></td>
<td>

<p>Extra margin to pass to <code>ylim</code> as a fraction of the range of <code>x$ice_curves</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_frac_to_plot">frac_to_plot</code></td>
<td>

<p>If <code>frac_to_plot</code> is less than 1, randomly plot <code>frac_to_plot</code> fraction of the
curves in <code>x$ice_curves</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_plot_points_indices">plot_points_indices</code></td>
<td>

<p>If not <code>NULL</code>, this plots only the indices of interest. If not <code>NULL</code>, <code>frac_to_plot</code> must be 1 otherwise
an error is thrown. Default is <code>NULL</code>. 
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_plot_orig_pts_preds">plot_orig_pts_preds</code></td>
<td>

<p>If <code>TRUE</code>, marks each curve at the location of the observation's actual fitted value. If <code>FALSE</code>,
no mark is drawn.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_pts_preds_size">pts_preds_size</code></td>
<td>

<p>Size of points to make if <code>plot_origin_pts_preds</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_colorvec">colorvec</code></td>
<td>

<p>Optional vector of colors to use for each curve.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_color_by">color_by</code></td>
<td>

<p>Optional variable name in <code>Xice</code>, column number in <code>Xice</code>, or data vector of the correct length to color curves by. 
If the <code>color_by</code>
variable has 10 or fewer unique values, a discrete set of colors is used for each value and a legend is 
printed and returned. If there are more values, curves are colored from light to dark corresponding 
to low to high values of the variable specified by <code>color_by</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_x_quantile">x_quantile</code></td>
<td>

<p>If <code>TRUE</code>, the plot is drawn with the x-axis taken to be <code>quantile(gridpts)</code>. If <code>FALSE</code>,
the predictor's original scale is used.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_plot_pdp">plot_pdp</code></td>
<td>

<p>If <code>TRUE</code>, the PDP is plotted and highlighted in yellow.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_centered">centered</code></td>
<td>

<p>If <code>TRUE</code>, all curves are re-centered to be 0 at the quantile given by <br /> <code>centered_percentile</code>.
See Goldstein et al (2013) for details and examples. If <code>FALSE</code>, the original <code>ice_curves</code> are plotted. 
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_prop_range_y">prop_range_y</code></td>
<td>

<p>When <code>TRUE</code> and <code>centered=TRUE</code> as well, the range of the right vertical axis displays the
centered values as a fraction of the sd of the fitted values on actual observations if <code>prop_type</code>
is missing or set to <code>"sd"</code>.  If <code>prop_type</code> is set to <code>"range"</code>, the right axis displays the
centered values as a fraction of the range of the fitted values over the actual observations.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_centered_percentile">centered_percentile</code></td>
<td>

<p>The percentile of <code>predictor</code> for which all <code>ice_curves</code> are &quot;pinched together&quot; and set to be 0.
Default is .01.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_point_labels">point_labels</code></td>
<td>

<p>If not <code>NULL</code>, labels to plot next to each point. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_point_labels_size">point_labels_size</code></td>
<td>

<p>If not <code>NULL</code>, size of labels to plot next to each point. Default is <code>NULL</code> which means it's the size of <code>pts_preds_size</code>.  
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_rug_quantile">rug_quantile</code></td>
<td>

<p>If not <code>NULL</code>, tick marks are drawn on the x-axis corresponding to the vector of quantiles specified by this parameter.
Forced to <code>NULL</code> when <code>x_quantile</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_prop_type">prop_type</code></td>
<td>

<p>Scaling factor for the right vertical axis in centered plots if <code>prop_range_y</code> is <code>TRUE</code>.  Can be one of 
<code>"sd"</code> (default) or <code>"range"</code>.  Ignored if <code>centered</code> and <code>prop_range_y</code> are not both <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.ice_+3A_...">...</code></td>
<td>

<p>Other arguments to be passed to the <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements.
</p>
<table>
<tr><td><code>plot_points_indices</code></td>
<td>
<p>Row numbers of <code>Xice</code> of those observations presented in the plot.</p>
</td></tr>
<tr><td><code>legend_text</code></td>
<td>
<p>If the <code>color_by</code> argument was used, 
a legend describing the map between the <code>color_by</code> predictor
and curve colors.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>ice
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(ICEbox)
require(randomForest)
require(MASS) #has Boston Housing data, Pima

data(Boston) #Boston Housing data
X = Boston
y = X$medv
X$medv = NULL

## build a RF:
bhd_rf_mod = randomForest(X, y)

## Create an 'ice' object for the predictor "age":
bhd.ice = ice(object = bhd_rf_mod, X = X, y = y, predictor = "age",
            frac_to_build = .1) 

## plot
plot(bhd.ice, x_quantile = TRUE, plot_pdp = TRUE, frac_to_plot = 1) 

## centered plot
plot(bhd.ice, x_quantile = TRUE, plot_pdp = TRUE, frac_to_plot = 1, 
		centered = TRUE) 

## color the curves by high and low values of 'rm'.
# First create an indicator variable which is 1 if the number of 
# rooms is greater than the median:
median_rm = median(X$rm)
bhd.ice$Xice$I_rm = ifelse(bhd.ice$Xice$rm &gt; median_rm, 1, 0)  

plot(bhd.ice, frac_to_plot = 1, centered = TRUE, prop_range_y = TRUE,  
            x_quantile = T, plot_orig_pts_preds = T, color_by = "I_rm")
bhd.ice = ice(object = bhd_rf_mod, X = X, y = y, predictor = "age",
            frac_to_build = 1)             
plot(bhd.ice, frac_to_plot = 1, centered = TRUE, prop_range_y = TRUE,  
            x_quantile = T, plot_orig_pts_preds = T, color_by = y)            

## End(Not run)
</code></pre>

<hr>
<h2 id='print.dice'>
Print method for <code>dice</code> objects.
</h2><span id='topic+print.dice'></span>

<h3>Description</h3>

<p>Prints a summary of a <code>dice</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dice'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.dice_+3A_x">x</code></td>
<td>

<p>Object of class <code>dice</code>.
</p>
</td></tr>
<tr><td><code id="print.dice_+3A_...">...</code></td>
<td>

<p>Ignored for now.
</p>
</td></tr>
</table>

<hr>
<h2 id='print.ice'>
Print method for <code>ice</code> objects.
</h2><span id='topic+print.ice'></span>

<h3>Description</h3>

<p>Prints a summary of an <code>ice</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ice'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ice_+3A_x">x</code></td>
<td>

<p>Object of class <code>ice</code>.
</p>
</td></tr>
<tr><td><code id="print.ice_+3A_...">...</code></td>
<td>

<p>Ignored for now.
</p>
</td></tr>
</table>

<hr>
<h2 id='summary.dice'>
Summary function for <code>dice</code> objects.
</h2><span id='topic+summary.dice'></span>

<h3>Description</h3>

<p>Alias of <code>print</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dice'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dice_+3A_object">object</code></td>
<td>

<p>Object of class <code>dice</code>.
</p>
</td></tr>
<tr><td><code id="summary.dice_+3A_...">...</code></td>
<td>

<p>Ignored for now.
</p>
</td></tr>
</table>

<hr>
<h2 id='summary.ice'>
Summary function for <code>ice</code> objects.
</h2><span id='topic+summary.ice'></span>

<h3>Description</h3>

<p>Alias of <code>print</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ice'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ice_+3A_object">object</code></td>
<td>

<p>Object of class <code>ice</code>.
</p>
</td></tr>
<tr><td><code id="summary.ice_+3A_...">...</code></td>
<td>

<p>Ignored for now.
</p>
</td></tr>
</table>

<hr>
<h2 id='WhiteWine'>Data concerning white wine.</h2><span id='topic+WhiteWine'></span>

<h3>Description</h3>

<p>The WhiteWine data frame has 4898 rows and 12 columns and
concerns white wines from a region in Portugal. The response 
variable, quality, is a wine quality metric, taken to be the median
preference score of three blind tasters on a scale of 1-10. The 11 covariates
are physicochemical metrics of wine quality such as citric acid content, 
sulphates, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(WhiteWine)</code></pre>


<h3>Format</h3>

<p>A data frame of 4898 cases on 12 variables.</p>


<h3>Source</h3>

<p>K Bache and M Lichman. UCI machine learning repository, 2013. 
http://archive.ics.uci.edu/ml
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
