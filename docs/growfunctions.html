<!DOCTYPE html><html><head><title>Help for package growfunctions</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {growfunctions}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#growfunctions-package'><p>Bayesian Non-Parametric Models for Estimating a Set of Denoised, Latent Functions</p>
From an Observed Collection of Domain-Indexed Time-Series</a></li>
<li><a href='#cluster_plot'><p>Plot estimated functions for experimental units faceted by cluster versus data to assess fit.</p></a></li>
<li><a href='#cps'><p>Monthly employment counts from 1990 - 2013 from the Current Population Survey</p></a></li>
<li><a href='#fit_compare'><p>Side-by-side plot panels that compare latent function</p>
values to data for different estimation models</a></li>
<li><a href='#gen_informative_sample'><p>Generate a finite population and take an informative single or two-stage sample.</p></a></li>
<li><a href='#gmrfdpcountPost'><p>Run a Bayesian functional data model under an instrinsic GMRF prior whose precision</p>
parameters employ a DP prior for a COUNT data response type where:
y ~ poisson(E*exp(Psi))
Psi ~ N(gamma,tau_e^-1)
which is a Poisson-lognormal model</a></li>
<li><a href='#gmrfdpgrow'><p>Bayesian instrinsic Gaussian Markov Random Field model for dependent time-indexed functions</p></a></li>
<li><a href='#gmrfdpPost'><p>Run a Bayesian functional data model under an instrinsic GMRF prior whose precision parameters</p>
employ a DP prior</a></li>
<li><a href='#gpBFixPost'><p>Run a Bayesian functional data model under a GP prior with a fixed clustering structure</p>
that co-samples latent functions, <code>bb_i</code>.</a></li>
<li><a href='#gpdpbPost'><p>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</p></a></li>
<li><a href='#gpdpgrow'><p>Bayesian non-parametric dependent Gaussian process model for time-indexed functional data</p></a></li>
<li><a href='#gpdpPost'><p>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</p></a></li>
<li><a href='#gpFixPost'><p>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</p></a></li>
<li><a href='#gpPost'><p>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</p></a></li>
<li><a href='#informative_plot'><p>Plot credible intervals for parameters to compare ignoring with weighting an informative sample</p></a></li>
<li><a href='#MSPE'><p>Compute normalized mean squared prediction error based on accuracy to impute missing data values</p></a></li>
<li><a href='#plot_cluster'><p>Plot estimated functions, faceted by cluster numbers, for a known clustering</p></a></li>
<li><a href='#predict_functions'><p>Use the model-estimated covariance parameters from gpdpgrow() or gmrdpgrow to predict the function at</p>
future time points.</a></li>
<li><a href='#predict_functions.gmrfdpgrow'><p>Use the model-estimated iGMRF precision parameters from gmrfdpgrow() to predict the iGMRF function at</p>
future time points.  Inputs the <code>gmrfdpgrow</code> object of estimated parameters.</a></li>
<li><a href='#predict_functions.gpdpgrow'><p>Use the model-estimated GP covariance parameters from gpdpgrow() to predict the GP function at</p>
future time points.  Inputs the <code>gpdpgrow</code> object of estimated parameters.</a></li>
<li><a href='#predict_plot'><p>Plot estimated functions both at estimated and predicted time points with 95% credible intervals.</p></a></li>
<li><a href='#samples'><p>Produce samples of MCMC output</p></a></li>
<li><a href='#samples.gmrfdpgrow'><p>Produce samples of MCMC output</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Non-Parametric Dependent Models for Time-Indexed
Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.16</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Terrance Savitsky</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Terrance Savitsky &lt;tds151@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates a collection of time-indexed functions under
    either of Gaussian process (GP) or intrinsic Gaussian Markov
    random field (iGMRF) prior formulations where a Dirichlet process
    mixture allows sub-groupings of the functions to share the same
    covariance or precision parameters.  The GP and iGMRF formulations
    both support any number of additive covariance or precision terms,
    respectively, expressing either or both of multiple trend and
    seasonality.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2), Rcpp (&ge; 0.11.6)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.16), RcppArmadillo (&ge; 0.8.400.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>spam(&ge; 2.7-0), ggplot2(&ge; 1.0.1), reshape2(&ge; 1.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat(&ge; 0.8.1)</td>
</tr>
<tr>
<td>Collate:</td>
<td>'MSPE.R' 'cps.R' 'gen_informative_sample.R' 'gpdpgrow.R'
'gmrfdpgrow.R' 'gp_car_fit_compare_facet.R' 'gp_cluster_plot.R'
'gp_informative_compare_plot.R' 'help.R' 'plot_cluster.R'
'predict_plot.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-12 12:39:43 UTC; Savitsky_T</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-12 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='growfunctions-package'>Bayesian Non-Parametric Models for Estimating a Set of Denoised, Latent Functions 
From an Observed Collection of Domain-Indexed Time-Series</h2><span id='topic+growfunctions-package'></span><span id='topic+growfunctions'></span><span id='topic+package-growfunctions'></span>

<h3>Description</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> growfunctions</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.16</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-12-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Details</h3>

<p>Parameterizes a model for a collection of noisy time-series indexed by 
domain or observation unit as an additive function process plus 
noise process.  The latent functions are modeled under both
Gaussian process (GP) and intrinsic Gaussian Markov random (iGMRF) 
field priors.  Dependence is estimated among the set of functions by 
selecting a prior, G, on the covariance or precision
parameters of the GP and iGMRF, respectively, where G receives a 
Dirichlet process (DP) prior. The resulting marginal prior on the 
functions is a nonparametric scale mixture over the 
covariance or precision parameters, with G the unknown mixing measure.  
Draws from a DP are almost surely discrete, allowing for ties 
(interpreted as clusters) among the covariance or
precision parameters indexed by domain or observation unit.  
Functions are included that permit additional inference on the 
clustering properties over the domains. The mixture models 
allow specification of multiple additive latent functions for 
each of the GP and iGMRF DP mixture formulations. Each 
function (under a GP prior) may be specified with a covariance 
function selected from a set of available options that allow 
for combinations of trend and seasonal components.  
The same is true for precision matrix 
constructions under the iGMRF DP mixture.
</p>
<p>ESTIMATION FUNCTIONS
</p>
<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code> performs Bayesian nonparametric estimation of a set of dependent, denoised
latent functions under a DP mixture of GP's in an unsupervised fashion based on user input of
an <code>N x T</code> data matrix, <code>y</code>, where <code>N</code> denotes the number of domains or units
and <code>T</code> denotes the number of time points.  The DP prior estimates the dependent structure 
among the covariance parameters generating each <code>T x 1</code> function across the <code>N</code> domains.
The user may specify multiple latent functions in an additive 
regression formulation, where
each covariance kernel may be selected from the squared exponential (<code>"se"</code>), the
rational quadratic (<code>"rq"</code>), or a quasi-periodic (product of a period and 
squared exponential
to allow the periodic kernel to evolve) (<code>"sn"</code>).
</p>
<p><code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code> also inputs an <code>N x T</code> data matrix, <code>y</code>, but replaces the 
GP prior used in <code>gpdpgrow()</code> with an iGMRF prior.  The DP mixture is over the precision 
parameter, <code>kappa</code>, that multiplies a fixed matrix, <code>Q</code>, which specifies 
the length-scale
of dependence.  The user may specify multiple functions in an additive formulation, 
each with its own precision matrix.  The precision matrix is specified 
via two options.  Input <code>q_type</code> 
indicates whether the precision matrix is a <em>trend</em>  (<code>"tr"</code>) 
precision matrix or a 
<em>seasonal</em> (<code>"sn"</code>) precision matrix. Integer innput <code>q_order</code> 
controls the length scale of the estimated functions and specifies the 
difference order of the precision matrix in the case of <code>q_type = "tr"</code>, 
or the periodicity, in the case <code>q_type = "sn"</code>.  Typically, <code>q_order</code> is set to
<code>1</code> or <code>2</code> when <code>q_type = "tr"</code>, though other values are possible.  An optional
<code>N x R</code> predictor matrix, ksi, may be input to adjust the prior for cluster assignments,
<code>s</code>, to produce a dependent product partition model.
</p>
<p><code><a href="#topic+MSPE">MSPE</a></code> Inputs a <code>gpdpgrow()</code> or <code>gmrfdpgrow()</code> object estimated where
some data values deliberately set to missing (<code>NA</code>) and produces an out-of-sample 
mean square prediction error (MSPE), and a normalized MSPE (normalized by the variance of
the missing test set). Both <code>gpdpgrow()</code> and <code>gmrfdpgrow()</code> returned objects also
include a leave-one-out log-pseudo marginal likelihood <code>LPML</code> fit statistic estimated
on the training set (so that no data are required to be left out).  One would expect the
<code>nMSPE</code> statistic to provide a greater penalty for model complexity since it is computed
on data not used for estimation.
</p>
<p><code><a href="#topic+predict_functions">predict_functions</a></code> Uses the model-estimated GP covariance parameters from 
<code>gpdpgrow()</code> or iGMRF precision parameters from <code>gmrfdpgrow()</code>
to predict functions at <em>future</em> time points beyond the range of the data 
from their posterior predictive distributions. Both <code>gpdpgrow()</code> and <code>gmrfdpgrow()</code>
will predict missing function values in the range of the data.  
</p>
<p>PLOT FUNCTIONS
</p>
<p><code><a href="#topic+cluster_plot">cluster_plot</a></code> inputs a returned object from either of <code>gpdpgrow()</code> or
<code>gmrfdpgrow()</code> and produces two plots.  The first plot creates panels for the clusters
and aggregates line plots of posterior mean estimates for member denoised functions.  
An optional 
smoother may be drawn through the set of functions in each panel to differentiate the
patterns expressed across clusters.  A second plot renders the estimated posterior mean
values (with an option for credible intervals) for a single or group of randomly-selected
latent functions against the actual data values, <code>y</code>.
</p>
<p><code><a href="#topic+informative_plot">informative_plot</a></code> inputs a list of returned objects, all from either
of <code>gpdpgrow()</code> or <code>gmrfdpgrow()</code> (where the model type, GP or 
iGMRF, is communicated with input <code>model</code>) that compares 
credible intervals for covariance or precision
parameters where the data are drawn from an informative 
sampling design (rather than as <em>iid</em>), so that the distribution 
for the population is not the same as that for
the sample.  One model conducts estimation in a fashion that ignores the informative
design and the other incorporates sampling weights to account for the informativeness.
Comparing the resulting estimated credible intervals provides a means to assess the 
sensitivity of estimated parameters to the sampling design.  The set of objects are
labeled with <code>objects_labels</code> with allowable inputs <code>c("ignore","weight","iid")</code>.
One of the objects must have label <code>"ignore"</code>, and the other must have label,
<code>weight</code>. An additional object may also be input that is estimated from an iid sample
drawn from the same population as the informative sample used for estimation under
objects <code>"ignore"</code> and <code>"weight"</code>.  Both informative and iid samples are generated
from the synthetic data function, <code>gen_informative_sample()</code>.
</p>
<p><code><a href="#topic+fit_compare">fit_compare</a></code> inputs a list of returned objects, each from either
<code>gpdpgrow()</code> or <code>gmrfdpgrow()</code>, and plots the posterior mean estimate
for a randomly-selected latent function as compared to the actual data in a set
panels indexed by cluster and object.  Allows comparison of fit performance of
functions to data across varied model specifications.
</p>
<p><code><a href="#topic+predict_plot">predict_plot</a></code> uses a returned object from <code>predict_functions()</code>
to plot both estimated and predicted function values (with the option for 
credible intervals) where the prediction interval is outside the range of data. 
The plot function, <code><a href="#topic+cluster_plot">cluster_plot</a></code>, should be used where 
the predicted values are in the range
of the data (and may, hence, be treated as missing values.  The estimated functions are
plotted in <code>cluster_plot</code> for the missing, as well as observed, data points).
</p>
<p>DATA SETS (and functions to generate synthetic data sets)
</p>
<p><code><a href="#topic+cps">cps</a></code> Data derived from the Current Population Survey (CPS) administered 
to households in
local areas within each of 51 states.  These data capture a rectangular matrix of 
monthly-indexed
all-other employment direct estimates computed from the set of household responses.  
The data capture
156 month observations (from 2000 - 2013) for each of the 51 states.  Two objects are included:
<code>y_raw</code> contains the 51 x 156 matrix of all-other employment counts.  
<code>y</code> contains the 51 x 156 matrix of all-other 
employment counts are standardization to (0,1), by state, to all
them to be modeled together.
</p>
<p><code><a href="#topic+gen_informative_sample">gen_informative_sample</a></code> Generates an <code>N x T</code> population data matrix, 
<code>y</code>, and an associated <code>n x T</code> sample data matrix, <code>y_obs</code>, where the 
sample is drawn using a 1 or 2-stage informative process.  The 1-stage sample uses
unequal probability stratified sampling, while the 2-stage process samples the first stage
in blocks, while the second stage samples with unequal probability from strata for selected
blocks.  Both block and strata memberships for population units are generated based on the
variance of their time-series, <code>y</code>.  The resulting sample is informative because the
block and cluster memberships and selection probabilities are determined based on <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>References</h3>

<p>Terrance D. Savitsky (2016) Bayesian Nonparametric Mixture Estimation for Time-Indexed 
Functional Data in R, <em>Journal of Statistical Software</em>, Volume 72, Number 2, 
pages 1 &ndash; 34, <a href="https://doi.org/10.18637/jss.v072.i02">doi:10.18637/jss.v072.i02</a>.
</p>
<p>T. D. Savitsky, D. Toth (2016) Bayesian Estimation 
Under Informative Sampling, <em>Electronic Journal of
Statistics</em>, Volume 10, Number 1.
</p>
<p>T. D. Savitsky (2016) Bayesian Non-parametric Functional Mixture
Estimation for Time-indexed data. submitted to: Survey Methodology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count 
## data for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, 
## associated with 
## the years 2011 - 2013
## to examine the state level 
## employment levels 
## during the "great recession"
y_short &lt;- cps$y[,(cps$yr_label %in% 
                  c(2011:2013))]

## run DP mixture of GP's to estimate 
## posterior distributions 
## for model parameters
## uses default setting of a single 
## "rational quadratic" 
## covariance formula
## A short number of iterations is used 
## for illustration
## Run for 500 iterations with half 
## as burn-in to 
## get a more useful result
res_gp     &lt;- gpdpgrow(
                   y = y_short, 
                   n.iter = 3, 
                   n.burn = 1, 
                   n.thin = 1, 
                   n.tune = 0)  
## 2 plots of estimated functions: 
## 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected 
## functions
fit_plots_gp   &lt;- cluster_plot( 
  object = res_gp, units_name = "state", 
  units_label = cps$st, single_unit = FALSE, 
  credible = TRUE )
                                   
## Run the DP mixture of iGMRF's 
## to estimate posterior 
## distributions for model parameters
## Under default RW2(kappa) = order 2 trend 
## precision term
## A short number of iterations 
## is used for illustration
## Run for 2000 iterations with 
## half as burn-in to 
## get a more useful result
res_gmrf &lt;- gmrfdpgrow(
                 y = y_short, 
                 n.iter = 11, 
                 n.burn = 4, 
                 n.thin = 1) 
                                     
## 2 plots of estimated functions: 
## 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of 
## randomly-selected functions
fit_plots_gmrf &lt;- cluster_plot( 
  object = res_gmrf, units_name = "state", 
  units_label = cps$st, single_unit = FALSE, 
  credible = TRUE )                                    
                                     
## visual comparison of fit performance 
## between gpdpgrow() and gmrfdpgrow()
## or any two objects returned from any
## combination of these estimation
## functions
objects        &lt;- vector("list",2)
objects[[1]]   &lt;- res_gmrf
objects[[2]]   &lt;- res_gp
label.object   &lt;- c("gmrf_tr2","gp_rq")
## the map data.frame 
## object from fit_plots gp 
## includes a field that 
## identifies cluster assignments
## for each unit (or domain)
H        &lt;- fit_plots_gp$map$cluster
fit_plot_compare_facet &lt;- 
fit_compare( objects = objects, 
 H = H, label.object = label.object,
 y.axis.label = "normalized y",
 units_name = "state", units_label = cps$st)                                
}

</code></pre>

<hr>
<h2 id='cluster_plot'>Plot estimated functions for experimental units faceted by cluster versus data to assess fit.</h2><span id='topic+cluster_plot'></span>

<h3>Description</h3>

<p>Uses as input the output object from the gpdpgrow() and gmrfdpgrow() functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_plot(
  object,
  N_clusters = NULL,
  time_points = NULL,
  units_name = "unit",
  units_label = NULL,
  date_field = NULL,
  x.axis.label = NULL,
  y.axis.label = NULL,
  smoother = TRUE,
  sample_rate = 1,
  single_unit = FALSE,
  credible = FALSE,
  num_plot = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluster_plot_+3A_object">object</code></td>
<td>
<p>A <code>gpdpgrow</code> or <code>gmrfdpgrow</code> object.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_n_clusters">N_clusters</code></td>
<td>
<p>Denotes the number of largest sized (in terms of membership) clusters to plot.
Defaults to all clusters.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_time_points">time_points</code></td>
<td>
<p>Inputs a vector of common time points at which the collections of functions were
observed (with the possibility of intermittent missingness).  The length of <code>time_points</code>
should be equal to the number of columns in the data matrix, <code>y</code>.  Defaults to 
<code>time_points = 1:ncol(y)</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_units_name">units_name</code></td>
<td>
<p>The plot label for observation units.  Defaults to <code>units_name = "function"</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_units_label">units_label</code></td>
<td>
<p>A vector of labels to apply to the observation units with length equal to the number of
unique units.  Defaults to sequential numeric values as input with data, <code>y</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_date_field">date_field</code></td>
<td>
<p>A vector of <code>Date</code> values for labeling the x-axis tick marks.
Defaults to <code>1:T</code>  .</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_x.axis.label">x.axis.label</code></td>
<td>
<p>Text label for x-axis. Defaults to <code>"time"</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>Text label for y-axis. Defaults to <code>"function values"</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_smoother">smoother</code></td>
<td>
<p>A scalar boolean input indicating whether to co-plot a smoother line 
through the functions in each cluster.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_sample_rate">sample_rate</code></td>
<td>
<p>A numeric value in (0,1] indicating percent of functions to randomly sample within
each cluster to address over-plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_single_unit">single_unit</code></td>
<td>
<p>A scalar boolean indicating whether to plot the fitted vs data curve for
only a single experimental units (versus a random sample of 6). 
Defaults to <code>single_unit = FALSE</code>.</p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_credible">credible</code></td>
<td>
<p>A scalar boolean indicating whether to plot 95 percent credible intervals for
estimated functions, <code>bb</code>, when plotting fitted functions versus data.  Defaults to
<code>credible = FALSE</code></p>
</td></tr>
<tr><td><code id="cluster_plot_+3A_num_plot">num_plot</code></td>
<td>
<p>A scalar integer indicating how many randomly-selected functions to plot
(each in it's own plot panel) in the plot of functions versus the observed time series
in the case that <code>single_unit == TRUE</code>.
Defaults to <code>num_plot = 6</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the plot of estimated functions, faceted by cluster,
and the associated <code>data.frame</code> object.
</p>
<table>
<tr><td><code>p.cluster</code></td>
<td>
<p>A <code>ggplot2</code> plot object</p>
</td></tr>
<tr><td><code>dat.cluster</code></td>
<td>
<p>A <code>data.frame</code> object used to generate <code>p.cluster</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count data for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, associated with 
## the years 2008 - 2013
## to examine the state level employment levels 
## during the "great recession"
y_short             &lt;- cps$y[,(cps$yr_label %in% c(2008:2013))]

## Run the DP mixture of iGMRF's to estimate posterior 
## distributions for model parameters
## Under default RW2(kappa) = order 2 trend 
## precision term
res_gmrf            &lt;- gmrfdpgrow(y = y_short, 
                                     n.iter = 40, 
                                     n.burn = 20, 
                                     n.thin = 1) 
                                     
## 2 plots of estimated functions: 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected functions
fit_plots_gmrf      &lt;- cluster_plot( object = res_gmrf, 
                                     units_name = "state", 
                                     units_label = cps$st, 
                                     single_unit = FALSE, 
                                     credible = TRUE )   
}
</code></pre>

<hr>
<h2 id='cps'>Monthly employment counts from 1990 - 2013 from the Current Population Survey</h2><span id='topic+cps'></span>

<h3>Description</h3>

<p>Monthly employment counts published by the U.S. Bureau of Labor Statistics in the 
Current Population Survey (CPS) for each of <code>N = 51</code> states (including the District
of Columbia).  This dataset covers <code>T = 278</code> months from <em>1990</em> the first two
months of <em>2013</em>.  The data include a <code>N x T</code> matrix, <code>y_raw</code>, of raw employment counts, 
as well as set of standardized values, <code>y</code>, where the standardization is done within state.  
The standardized data matrix is used in our <code><a href="#topic+gpdpgrow">gpdpgrow</a></code> and <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
estimating functions because the standardization facilitates comparisons of the time-series across
states.
</p>


<h3>Format</h3>

<p>A list object of 5 objects supporting a data matrix of N = 51 state time series for
T = 278 months.
</p>


<h3>Details</h3>


<ul>
<li><p> y. An <code>(N = 51) x (T = 278)</code> matrix of standardized employment count 
estimates for <code>N = 51</code> states for <code>T = 278</code> months, beginning in 1990. The counts
are standardized to (0,1) for each state series
</p>
</li>
<li><p> y_raw. An <code>N x T</code> matrix of estimated monthly employment counts for <code>N = 51</code>
states.
</p>
</li>
<li><p> st. Two-digit labels for each of the <code>N</code> states in the order presented in 
<code>y</code> and <code>y_raw</code>.
</p>
</li>
<li><p> dte. A <code>Date</code> vector of length <code>T</code> that presents the set of dates (in <code>y-m-d</code> 
format) associated to the <code>T</code> time points presented in <code>y</code> and <code>y_raw</code>.
</p>
</li>
<li><p> yr. A number vector listing sequence of years, <em>1990 - 2013</em> included in the data set.
</p>
</li>
<li><p> yr_label. A numerical vector of length <code>T = 278</code> with year labels for each 
monthly employment count in the <code>cps</code> data set. 
</p>
</li></ul>


<hr>
<h2 id='fit_compare'>Side-by-side plot panels that compare latent function 
values to data for different estimation models</h2><span id='topic+fit_compare'></span>

<h3>Description</h3>

<p>Uses as input the output object from the gpdpgrow() and 
gmrfdpgrow() functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_compare(
  objects,
  H = NULL,
  label.object = c("gp_rq", "gmrf_rw2"),
  units_name = "Observation_Unit",
  units_label = NULL,
  date_field = NULL,
  x.axis.label = NULL,
  y.axis.label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_compare_+3A_objects">objects</code></td>
<td>
<p>A list input where each element is a returned object
from estimation with either of <code>gpdpgrow</code> or 
<code>gmrfdpgrow</code> or an object that contains true 
<code>N x T</code> matrix of true latent
function values, <code>f</code>.  This latter input 
is only needed if want to compare 
estimated to true latent function values.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_h">H</code></td>
<td>
<p>An <code>N x 1</code> with entries in <code>1,...,M</code> of cluster 
assignments for the <code>N</code>
units of <code>y</code> under a known clustering.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_label.object">label.object</code></td>
<td>
<p>A character vector of length equal to <code>objects</code> 
that contains labels for each element of <code>objects</code> 
to be used in rendering comparison plots.
Defaults to <code>label.object = c("gp_rq","gmrf_rw2")</code>.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_units_name">units_name</code></td>
<td>
<p>A character input that provides a label 
for the set of <code>N</code> observation units.
Defaults to <code>units_name = "Observation_Unit"</code>.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_units_label">units_label</code></td>
<td>
<p>A vector of labels to apply to the observation units 
with length equal to the 
number of unique units.  Defaults to sequential 
numeric values as input with data, <code>y</code>.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_date_field">date_field</code></td>
<td>
<p>A vector of <code>Date</code> values for labeling the x-axis tick marks.
Defaults to <code>1:T</code>  .</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_x.axis.label">x.axis.label</code></td>
<td>
<p>Text label for x-axis. Defaults to <code>"time"</code>.</p>
</td></tr>
<tr><td><code id="fit_compare_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>Text label for y-axis. Defaults to <code>"function values"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the plot of estimated functions, faceted by cluster,
and the associated <code>data.frame</code> object.
</p>
<table>
<tr><td><code>p.t</code></td>
<td>
<p>A <code>ggplot2</code> plot object</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>A <code>data.frame</code> object that contains clustering structure of
observation units.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count data 
## for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, 
## associated with 
## the years 2009 - 2013
## to examine the state level 
## employment levels 
## during the "great recession"
y_short &lt;- cps$y[,(cps$yr_label %in% 
                 c(2010:2013))]

## run DP mixture of GP's to 
## estimate posterior distributions 
## for model parameters
## uses default setting of a 
## single "rational quadratic" 
## covariance formula
res_gp         &lt;- gpdpgrow(
                     y = y_short, 
                     n.iter = 3, 
                     n.burn = 1, 
                     n.thin = 1, 
                     n.tune = 0)  
## 2 plots of estimated functions: 
## 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected 
## functions
fit_plots_gp   &lt;- cluster_plot( 
 object = res_gp,  units_name = "state", 
 units_label = cps$st, single_unit = FALSE, 
 credible = TRUE )
                                   
## Run the DP mixture of iGMRF's to 
## estimate posterior 
## distributions for model parameters
## Under default 
## RW2(kappa) = order 2 trend 
## precision term
res_gmrf     &lt;- gmrfdpgrow(y = y_short, 
                       n.iter = 13, 
                       n.burn = 4, 
                       n.thin = 1) 
                                     
## 2 plots of estimated functions: 
## 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected functions
fit_plots_gmrf   &lt;- cluster_plot( object = res_gmrf, 
  units_name = "state", units_label = cps$st, 
  single_unit = FALSE, 
  credible = TRUE )                                    
                                     
## visual comparison of fit performance 
## between gpdpgrow() and gmrfdpgrow()
## or any two objects returned from any
## combination of these estimation
## functions
objects        &lt;- vector("list",2)
objects[[1]]   &lt;- res_gmrf
objects[[2]]   &lt;- res_gp
label.object   &lt;- c("gmrf_tr2","gp_rq")
## the map data.frame object 
## from fit_plots gp 
## includes a field that 
## identifies cluster assignments
## for each unit (or domain)
H        &lt;- fit_plots_gp$map$cluster
fit_plot_compare_facet &lt;- 
fit_compare( objects = objects, 
 H = H, label.object = label.object,
 y.axis.label = "normalized y",
 units_name = "state", units_label = cps$st)                                  
}
</code></pre>

<hr>
<h2 id='gen_informative_sample'>Generate a finite population and take an informative single or two-stage sample.</h2><span id='topic+gen_informative_sample'></span>

<h3>Description</h3>

<p>Used to compare performance of sample design-weighted and unweighted estimation procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_informative_sample(
  clustering = TRUE,
  two_stage = FALSE,
  theta = c(0.2, 0.7, 1),
  M = 3,
  theta_star = matrix(c(0.3, 0.3, 0.3, 0.31, 0.72, 2.04, 0.58, 0.83, 1), 3, 3, byrow =
    TRUE),
  gp_type = "rq",
  N = 10000,
  T = 15,
  L = 10,
  R = 8,
  I = 4,
  n = 750,
  noise_to_signal = 0.05,
  incl_gradient = "medium"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_informative_sample_+3A_clustering">clustering</code></td>
<td>
<p>Boolean input on whether want population generated from clusters of covariance 
parameters.  Defaults to <code>clustering = FALSE</code></p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_two_stage">two_stage</code></td>
<td>
<p>Boolean input on whether want two stage sampling, with first stage defining set
of <code>L</code> blocks, where membership in blocks determined by quantiles of observation unit
variance functions.  (They are structured like strata, though they are sub-sampled).</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_theta">theta</code></td>
<td>
<p>A numeric vector of global covariance parameters in the case of <code>clustering = FALSE</code>.
The length, <code>P</code>, of <code>theta</code> must be consistent with the selected <code>gp_type</code>.  
Defaults to <code>theta = c(0.30.7,1.0)</code> in the case of <code>clustering = FALSE</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_m">M</code></td>
<td>
<p>Scalar input denoting number of clusters to employ if <code>clustering = TRUE</code>. Defaults to
<code>M = 3</code></p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_theta_star">theta_star</code></td>
<td>
<p>An <em>P x M</em> matrix of cluster location values associated with the choice of 
<code>M</code> and the selected <code>gp_type</code>. Defaults to 
<code>matrix(c(0.3,0.3,0.3,0.31,0.72,2.04,0.58,0.83,1.00),3,3,byrow=TRUE))</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_gp_type">gp_type</code></td>
<td>
<p>Input of choice for covariance matrix formulation to be used to generate the functions
for the <code>N</code> population units.  Choices are <code>c("se","rq")</code>, where <code>"se"</code> denotes
the squared exponential covariance function and <code>"rq"</code> denotes the rational quadratic.
Defaults to <code>gp_type = "se"</code></p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_n">N</code></td>
<td>
<p>A scalar input denoting the number of population units (or establishments).</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_t">T</code></td>
<td>
<p>A scalar input denoting the number of time points in each of <code>N</code>, <em>T x 1</em> functions
that contribute to the <em>N x T</em> population data matrix, <code>y</code>.  Defaults to <code>T = 15</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_l">L</code></td>
<td>
<p>A scalar input that denotes the number of blocks in which to assign the population
units to be sub-sampled in the first stage of sampling.  
Defaults to <code>L = 10</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_r">R</code></td>
<td>
<p>A scalar input that denotes the number of blocks to sample from <code>L  = 10</code> with
probability proportional to the average variance of member functions in each block.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_i">I</code></td>
<td>
<p>A scalar input denoting the number of strata to form within each block.  Population units
are divided into equally-sized strata based on variance quantiles. Defaults to <code>I  = 4</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_n">n</code></td>
<td>
<p>Sample size to be generated.  Both an informative sample under either single
(<code>two_stage = FALSE</code>) or 2-stage (<code>two_stage = TRUE</code>) sample is taken, along with
a non-informative, <em>iid</em> sample of the same size (<code>n</code>) from the finite population
(generated with (<code>clustering = TRUE</code>) or without clustering). Defaults to <code>n = 770</code>.</p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_noise_to_signal">noise_to_signal</code></td>
<td>
<p>A numeric input in the interval, <code>(0,1)</code>, denoting the ratio of noise
variance to the average variance of the generated functions, <code>bb_i</code>.  Defaults to 
<code>noise_to_signal = 0.05</code></p>
</td></tr>
<tr><td><code id="gen_informative_sample_+3A_incl_gradient">incl_gradient</code></td>
<td>
<p>A character input on whether stratum probabilities from lowest-to-highest
is to <code>"high"</code>, in which case they are proportional to the exponential of the
cluster number.  If set to <code>"medium"</code> , the inclusion probabilities are proportional
to the square of the cluster number.  Note that population units are assigned to each
stratum proportional to a progressively increasing quantile variance.  The 
<code>incl_gradient</code> setting is used for both <code>two_stage = TRUE</code>, in which
case it is applied to strata within block, as well as <code>two_stage = FALSE</code>,
in which case a simple stratified random sample is conducted.  Defaults to 
<code>incl_gradient = "medium"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object named <code>dat_sim</code> containing objects related to the generated sample
finite population, the informative sample and the non-informative, <em>iid</em>, sample. 
Some important objects, include:
</p>
<table>
<tr><td><code>H</code></td>
<td>
<p>A vector of length <code>N</code>, the population size, with cluster assignments
for each establishment (unit) in <code>1,..M</code> clusters.</p>
</td></tr>
<tr><td><code>map.tot</code></td>
<td>
<p>A <code>data.frame</code> object including unit label identifiers
(under <code>establishment</code>),
the cluster assignment (if <code>clustering = TRUE</code>), 
the block (if<code>two_stage = TRUE</code>) and stratum assignments 
and the sample inclusion probabilities.</p>
</td></tr>
<tr><td><code>map.obs</code></td>
<td>
<p>A <code>data.frame</code> object configured the same as <code>map.tot</code>, only
confined to those establishments/units selected into the <em>informative</em>
sample of size <code>n</code>.</p>
</td></tr>
<tr><td><code>map.iid</code></td>
<td>
<p>A <code>data.frame</code> object configured the same as <code>map.tot</code>, only
confined to those establishments/units selected into the <em>non-informative</em>,
iid sample of size <code>n</code>.</p>
</td></tr>
<tr><td><code>(y</code>, <code>bb)</code></td>
<td>
<p><em>N x T</em> <code>matrix</code> objects containing data responses and de-noised '
functions, respectively, for each of the <code>N</code> population units. The order
of the <code>N</code> units is consistent with <code>map</code>.</p>
</td></tr>
<tr><td><code>(y_obs</code>, <code>bb_obs)</code></td>
<td>
<p><em>N x T</em> <code>matrix</code> objects containing observed responses and de-noised '
functions, respectively, for each of the <code>n</code> units sampled under an
informative sampling design. The order of the <code>n</code> units is consistent
with <code>map_obs</code>.</p>
</td></tr>
<tr><td><code>(y_iid</code>, <code>bb_iid)</code></td>
<td>
<p><em>N x T</em> <code>matrix</code> objects containing observed responses and de-noised '
functions, respectively, for each of the <code>n</code> units sampled under a
non-informative / iid sampling design. The order of the <code>n</code> units is consistent
with <code>map_iid</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(growfunctions)
## use gen_informative_sample() to generate an 
## N X T population drawn from a dependent GP
## By default, 3 clusters are used to generate 
## the population.
## A single stage stratified random sample of size n 
## is drawn from the population using I = 4 strata. 
## The resulting sample is informative in that the 
## distribution for this sample is
## different from the population from which 
## it was drawn because the strata inclusion
## probabilities are proportional to a feature 
## of the response, y (in the case, the variance.
## The stratified random sample over-samples 
## large variance strata).
## (The user may also select a 2-stage 
## sample with the first stage
## sampling "blocks" of the population and 
## the second stage sampling strata within blocks). 
dat_sim        &lt;- gen_informative_sample(N = 10000, 
                                n = 500, T = 10,
                                noise_to_signal = 0.1)

## extract n x T observed sample under informative
## stratified sampling design.
y_obs                       &lt;- dat_sim$y_obs
T                           &lt;- ncol(y_obs)

## End(Not run)
</code></pre>

<hr>
<h2 id='gmrfdpcountPost'>Run a Bayesian functional data model under an instrinsic GMRF prior whose precision
parameters employ a DP prior for a COUNT data response type where:
y ~ poisson(E*exp(Psi))
Psi ~ N(gamma,tau_e^-1)
which is a Poisson-lognormal model</h2><span id='topic+gmrfdpcountPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmrfdpcountPost(
  y,
  E,
  ksi,
  ipr,
  C,
  D,
  q_order,
  q_type,
  n.iter,
  n.burn,
  n.thin,
  M_init,
  w_star,
  q_shape,
  q_rate,
  tau_shape,
  tau_rate,
  dp_shape,
  dp_rate,
  nu,
  Rep,
  progress,
  jitter,
  kappa_fast,
  stable_launch
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmrfdpcountPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_e">E</code></td>
<td>
<p>A multivariate offset variable, specified as an <em>N x T</em> matrix, in the case
that <code>y</code> is of type count data.  The offset will be used to model the <code>y</code>
as under a poisson lognormal where <code>y ~ Pois(E*exp(Psi))</code>.  Defaults to <code>NULL</code>,
in which case the response type is assumed continuous.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_ksi">ksi</code></td>
<td>
<p>An <em>N x P</em> matrix of N observations of P predictors to be used
in prior probability of co-clustering of set of N, T x 1 observations. 
Defaults to <code>ksi = NULL</code> such that predictors are not used to a priori
determine co-clustering probabilities.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_c">C</code></td>
<td>
<p>A list object of length, <code>K</code>, the number of iGMRF precision terms.
Each entry contains a <em>T x T</em> normalized adjacency matrix.  The diagonal entries are
<code>0</code> and row <code>i</code> contains the weight for each entry <code>!=i</code> divided by the sum
of the weights.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_d">D</code></td>
<td>
<p>A <em>K x T</em> matrix, where <code>K</code> denotes the number of iGMRF terms.
Row <code>k</code> contains the <code>T</code> elements of the diagonal of the term-<code>k</code>
precision matrix, <code>Q_k</code>.
Will increase with order and be equal, except for boundary corrections.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_q_order">q_order</code></td>
<td>
<p>An integer vector where each entry contains the order of the associated <code>K</code>
iGMRF precision terms
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_q_type">q_type</code></td>
<td>
<p>A vector of length <code>K</code>, the number of iGMRF precision terms, with each entry 
indicating whether the associated term is a trend (<code>"tr"</code>) or 
seasonality (<code>"sn"</code>) term.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_m_init">M_init</code></td>
<td>
<p>Starting value of number of clusters for sampling cluster assignments.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_w_star">w_star</code></td>
<td>
<p>Integer value denoting the number of cluster locations to sample ahead of 
observations in the auxiliary Gibbs sampler used to sample the number of clusters
and associated cluster assignments.  A higher value reduces samplin auto-correlation, 
but increases computational burden.  Defaults to <code>w_star = 2</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_q_shape">q_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_q_rate">q_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_tau_shape">tau_shape</code></td>
<td>
<p>The value (in (0,infty)) for the shape hyperparameter for the Gamma prior on the error
precision parameter. Defaults to <code>tau_shape = 1.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_tau_rate">tau_rate</code></td>
<td>
<p>The rate parameter of the Gamma prior distribution on <code>tau_e</code>. 
Defaults to <code>tau_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter.
The rate parameter is set of <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter. 
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_nu">nu</code></td>
<td>
<p>The degree of freedom parameter for the Huang and Wand prior on precision
matrix locations, <code>Lambda_star</code>, in the case that predictors, <code>ksi</code>,
are entered to instantiate a predictor-dependent prior for co-clustering.
Default value is <code>4</code></p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_rep">Rep</code></td>
<td>
<p>The number of times to draw samples of the <code>N x T</code> log-mean
parameters, <code>Psi</code>, for each MCMC iteration
under a Poisson-lognormal model when the response
type for <code>y</code> is count (not continuous)
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_jitter">jitter</code></td>
<td>
<p>A scalar double indicating amount of jitter to subract from the posterior 
rate and shape hyperparameters of <code>tau_e</code> to stabilize computation.  
Defaults to <code>jitter = 0.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_kappa_fast">kappa_fast</code></td>
<td>
<p>Boolean for whether to generate rate hyperparameter from full conditionals
versus joint Gaussian (on random effects, <code>bb</code>, given <code>kappa</code>.  The
former is faster, but numerically less stable. 
Defaults to <code>kappa_fast = FALSE</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpcountPost_+3A_stable_launch">stable_launch</code></td>
<td>
<p>A boolean indicator on whether to generate initial values for
<code>N x T</code> log-mean, <code>Psi</code>, when <code>y</code> are count data from a Gaussian
prior distribution, which can induce numerical launch instabilities, or whether 
to initialize as <code>y/E</code> (where missing values in <code>y</code> are imputed).
Defaults to <code>stable_launch = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gmrfdpgrow'>Bayesian instrinsic Gaussian Markov Random Field model for dependent time-indexed functions</h2><span id='topic+gmrfdpgrow'></span><span id='topic+gmrfdpgrow.default'></span>

<h3>Description</h3>

<p>Estimates a collection of time-indexed functions under intrinsic Gaussian Markov random
field prior formulations where a Dirichlet process mixture allows sub-groupings of the functions to share the same 
iGMRF precision parameter.  The iGMRF formulation supports any number of additive precision terms,
expressing either or both of multiple trend and seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmrfdpgrow(
  y,
  ksi,
  E,
  ipr,
  q_order,
  q_type,
  q_shape,
  q_rate,
  tau_shape,
  tau_rate,
  dp_shape,
  dp_rate,
  M_init,
  w_star,
  n.iter,
  n.burn,
  n.thin,
  nu,
  Rep,
  progress,
  jitter,
  kappa_fast,
  stable_launch
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmrfdpgrow_+3A_y">y</code></td>
<td>
<p>A multivariate continuous response, specified as an <em>N x T</em> matrix, where <code>N</code>
denotes the number of functions and <code>T</code>, the number of time points per function. Intermittent 
missing-at-random values are allowed and will be estimated from the posterior
predictive distribution.  Missing cells should be denoted with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_ksi">ksi</code></td>
<td>
<p>An <em>N x P</em> matrix of N observations of P predictors to be used
in prior probability of co-clustering of set of N, T x 1 observations. 
Defaults to <code>ksi = NULL</code> such that predictors are not used to a priori
determine co-clustering probabilities.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_e">E</code></td>
<td>
<p>A multivariate offset variable, specified as an <em>N x T</em> matrix, in the case
that <code>y</code> is of type count data.  The offset will be used to model the <code>y</code>
as under a poisson lognormal where <code>y ~ Pois(E*exp(Psi))</code>.  Defaults to <code>NULL</code>,
in which case the response type is assumed continuous.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit 
in the case the observed data were acquired through an informative sampling design, so 
that unbiased inference about the population requires adjustments to the observed sample
Defaults to <code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_q_order">q_order</code></td>
<td>
<p>An integer vector of length <code>K</code> to select the order for each iGMRF precision term.
e.g. If the first term is a RW2 and there is a second is a 3-month seasonality term, where the time
points are indexed by month, then <code>q_order = c(2,3)</code>.  Defaults to <code>q_order = 2</code></p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_q_type">q_type</code></td>
<td>
<p>A vector of length <code>K</code>, the number of iGMRF precision terms, with each entry 
indicating whether the associated term is a trend (<code>"tr"</code>) or seasonality (<code>"sn"</code>) term.
So all entries must be one of <code>c("tr","sn")</code>. Defaults to <code>q_type = "tr"</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_q_shape">q_shape</code></td>
<td>
<p>The value (in (0,infty)) for the shape hyperparameter for the Gamma base distribution for
the iGMRF scale parameters, <code>kappa_star(k,m)</code>, where <code>k</code> denotes the term
and <code>m</code>, the cluster.  Defaults to <code>q_shape = 0.3</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_q_rate">q_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>kappa_star</code>. 
Defaults to <code>q_rate = 0.0005</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_tau_shape">tau_shape</code></td>
<td>
<p>The value (in (0,infty)) for the shape hyperparameter for the Gamma prior on the error
precision parameter. Defaults to <code>tau_shape = 1.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_tau_rate">tau_rate</code></td>
<td>
<p>The rate parameter of the Gamma prior distribution on <code>tau_e</code>. 
Defaults to <code>tau_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the Gamma prior on the DP concentration parameter, 
<code>conc</code>. Defaults to <code>dp_shape = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the Gamma prior on the DP concentration parameter, 
<code>conc</code>. Defaults to <code>dp_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_m_init">M_init</code></td>
<td>
<p>Starting number of clusters of <code>nrow(y)</code> units to initialize sampler.
Defaults to <code>M_init = nrow(y)</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_w_star">w_star</code></td>
<td>
<p>Integer value denoting the number of cluster locations to sample ahead of 
observations in the auxiliary Gibbs sampler used to sample the number of clusters
and associated cluster assignments.  A higher value reduces sampling auto-correlation, 
but increases computational burden.  Defaults to <code>w_star = 2</code>.  The auxiliary
Gibbs sampler is only used in the case that <code>!is.null(ksi)</code>, for predictor-
assisted clustering; otherwise, the full conditionals for cluster assigment are
conjugate.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_n.iter">n.iter</code></td>
<td>
<p>Total number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_n.burn">n.burn</code></td>
<td>
<p>Number of MCMC iterations to discard.
<code>gmrfdpgrow</code> will return <code>(n.iter - n.burn)</code> posterior samples.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_n.thin">n.thin</code></td>
<td>
<p>Gap between successive sampling iterations to save.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_nu">nu</code></td>
<td>
<p>The degree of freedom parameter for the Huang and Wand prior on precision
<code>R x R</code> matrix locations, <code>Lambda_star</code>, 
in the case that <code>N x R</code> predictors, <code>ksi</code>,
are entered to instantiate a predictor-dependent prior for co-clustering.
Default value is <code>4</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_rep">Rep</code></td>
<td>
<p>The number of times to draw samples of the <code>N x T</code> log-mean
parameters, <code>Psi</code>, for each MCMC iteration
under a Poisson-lognormal model when the response
type for <code>y</code> is count (not continuous), which is indicated by inputing
an offset matrix, <code>E</code>.
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_progress">progress</code></td>
<td>
<p>A boolean value denoting whether to display a progress bar during model execution.
Defaults to <code>progress = true</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_jitter">jitter</code></td>
<td>
<p>A scalar double indicating amount of jitter to subract from the posterior 
rate and shape hyperparameters of <code>tau_e</code> to stabilize computation.  
Defaults to <code>jitter = 0.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_kappa_fast">kappa_fast</code></td>
<td>
<p>Boolean for whether to generate rate hyperparameter from full conditionals
versus joint Gaussian (on random effects, <code>bb</code>, given <code>kappa</code>.  The
former is faster, but numerically less stable. 
Defaults to <code>kappa_fast = FALSE</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpgrow_+3A_stable_launch">stable_launch</code></td>
<td>
<p>A boolean indicator on whether to generate initial values for
<code>N x T</code> log-mean, <code>Psi</code>, when <code>y</code> are count data from a Gaussian
prior distribution, which can induce numerical launch instabilities, or whether 
to initialize as <code>y/E</code> (where missing values in <code>y</code> are imputed).
Defaults to <code>stable_launch = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 <code>gmrfdpgrow</code> object, for which many methods are available to return and view results.  
Generic functions applied to an object, <code>res</code> of class <code>gmrfdpgrow</code>, includes:
</p>
<table>
<tr><td><code>plot(res)</code></td>
<td>
<p> returns results plots, including fit functions versus data and allocation
of fitted functions into clusters</p>
</td></tr>
<tr><td><code>samples(res)</code></td>
<td>
<p> contains (<code>n.iter - n.burn</code>) posterior sampling iterations 
for every model parameter</p>
</td></tr>
<tr><td><code>resid(res)</code></td>
<td>
<p> contains the model residuals.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The intended focus for this package are data composed of observed noisy functions (each of 
length <code>T</code>) for a set of experimental units where the functions may express dependence
among the experimental units
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a> Daniell toth <a href="mailto:danielltoth@yahoo.com">danielltoth@yahoo.com</a>
</p>


<h3>References</h3>

<p>T. D. Savitsky and D. Toth (2014) Bayesian Non-parametric Models for Collections of Time-
indexed Functions. submitted to: JRSS Series A (Statistics in Society).
</p>
<p>T. D. Savitsky (2014) Bayesian Non-parametric Functional Mixture
Estimation for Time-indexed data. submitted to: Annals of Applied Statistics.
</p>
<p>T. D. Savitsky (2014) Bayesian Non-Parametric Mixture Estimation for Time-Indexed Functional
Data for <code>R</code>. Submitted to: Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count data for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, associated 
## with the years 2008 - 2013
## to examine the state level employment levels 
## during the "great recession"
y_short   &lt;- cps$y[,(cps$yr_label %in% c(2008:2013))]

## Run the DP mixture of iGMRF's to estimate posterior 
## distributions for model parameters
## Under default RW2(kappa) = order 2 trend 
## precision term
## Run for 1500 iterations, with half as burn-in for a
## more useful (converged) result.
res_gmrf            &lt;- gmrfdpgrow(y = y_short, 
                                     n.iter = 40, 
                                     n.burn = 20, 
                                     n.thin = 1) 
                                     
## 2 plots of estimated functions: 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected functions
fit_plots_gmrf      &lt;- cluster_plot( object = res_gmrf, 
                                     units_name = "state", 
                                     units_label = cps$st, 
                                     single_unit = FALSE, 
                                     credible = TRUE )    
}
</code></pre>

<hr>
<h2 id='gmrfdpPost'>Run a Bayesian functional data model under an instrinsic GMRF prior whose precision parameters
employ a DP prior</h2><span id='topic+gmrfdpPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmrfdpPost(
  y,
  ksi,
  ipr,
  C,
  D,
  q_order,
  q_type,
  n.iter,
  n.burn,
  n.thin,
  M_init,
  w_star,
  q_shape,
  q_rate,
  tau_shape,
  tau_rate,
  dp_shape,
  dp_rate,
  nu,
  progress,
  jitter,
  kappa_fast
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmrfdpPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_ksi">ksi</code></td>
<td>
<p>An <em>N x P</em> matrix of N observations of P predictors to be used
in prior probability of co-clustering of set of N, T x 1 observations. 
Defaults to <code>ksi = NULL</code> such that predictors are not used to a priori
determine co-clustering probabilities.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_c">C</code></td>
<td>
<p>A list object of length, <code>K</code>, the number of iGMRF precision terms.
Each entry contains a <em>T x T</em> normalized adjacency matrix.  The diagonal entries are
<code>0</code> and row <code>i</code> contains the weight for each entry <code>!=i</code> divided by the sum
of the weights.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_d">D</code></td>
<td>
<p>A <em>K x T</em> matrix, where <code>K</code> denotes the number of iGMRF terms.
Row <code>k</code> contains the <code>T</code> elements of the diagonal of the term-<code>k</code>
precision matrix, <code>Q_k</code>.
Will increase with order and be equal, except for boundary corrections.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_q_order">q_order</code></td>
<td>
<p>An integer vector where each entry contains the order of the associated <code>K</code>
iGMRF precision terms
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_q_type">q_type</code></td>
<td>
<p>A vector of length <code>K</code>, the number of iGMRF precision terms, with each entry 
indicating whether the associated term is a trend (<code>"tr"</code>) or 
seasonality (<code>"sn"</code>) term.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_m_init">M_init</code></td>
<td>
<p>Starting value of number of clusters for sampling cluster assignments.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_w_star">w_star</code></td>
<td>
<p>Integer value denoting the number of cluster locations to sample ahead of 
observations in the auxiliary Gibbs sampler used to sample the number of clusters
and associated cluster assignments.  A higher value reduces samplin auto-correlation, 
but increases computational burden.  Defaults to <code>w_star = 2</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_q_shape">q_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_q_rate">q_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_tau_shape">tau_shape</code></td>
<td>
<p>The value (in (0,infty)) for the shape hyperparameter for the Gamma prior on the error
precision parameter. Defaults to <code>tau_shape = 1.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_tau_rate">tau_rate</code></td>
<td>
<p>The rate parameter of the Gamma prior distribution on <code>tau_e</code>. 
Defaults to <code>tau_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter.
The rate parameter is set of <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter. 
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_nu">nu</code></td>
<td>
<p>The degree of freedom parameter for the Huang and Wand prior on precision
matrix locations, <code>Lambda_star</code>, in the case that predictors, <code>ksi</code>,
are entered to instantiate a predictor-dependent prior for co-clustering.
Default value is <code>4</code></p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_jitter">jitter</code></td>
<td>
<p>A scalar double indicating amount of jitter to subract from the posterior 
rate and shape hyperparameters of <code>tau_e</code> to stabilize computation.  
Defaults to <code>jitter = 0.0</code>.</p>
</td></tr>
<tr><td><code id="gmrfdpPost_+3A_kappa_fast">kappa_fast</code></td>
<td>
<p>Boolean for whether to generate rate hyperparameter from full conditionals
versus joint Gaussian (on random effects, <code>bb</code>, given <code>kappa</code>.  The
former is faster, but numerically less stable. 
Defaults to <code>kappa_fast = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gpBFixPost'>Run a Bayesian functional data model under a GP prior with a fixed clustering structure
that co-samples latent functions, <code>bb_i</code>.</h2><span id='topic+gpBFixPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpBFixPost(
  y,
  ipr,
  Omega_t,
  Omega_s,
  gp_mod,
  jitter,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  lower,
  upper,
  w,
  n_slice_iter,
  y_index,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  progress,
  s
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpBFixPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions. <code>y</code> may\
have intermittant missing values. They should be input with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_omega_t">Omega_t</code></td>
<td>
<p>A <em>T x T</em> matrix of squared Eucidean distances for <code>T</code> time points</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_omega_s">Omega_s</code></td>
<td>
<p>A <code>list</code> object of length <code>L_s</code>, where each contains the <em>T x T</em>
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_gp_mod">gp_mod</code></td>
<td>
<p>An <em>L x 1</em> numeric vector denoting the selected covariance function for each
of <code>L</code> terms.  <code>gp_mod = 1</code> is <code>"rq"</code>.  <code>gp_mod = 2</code> is <code>"se"</code>.
<code>gp_mod = 3</code> is <code>"sn"</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_jitter">jitter</code></td>
<td>
<p>Numeric value added to diagonals of GP covariance matrix to stabilize inversion.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_lower">lower</code></td>
<td>
<p>Minimum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_upper">upper</code></td>
<td>
<p>Maximum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_w">w</code></td>
<td>
<p>Tuning parameter for slice sampling interval width used for GP 
covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_n_slice_iter">n_slice_iter</code></td>
<td>
<p>Maximum number of steps to widen slice samplind width for
GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_y_index">y_index</code></td>
<td>
<p>List object where each contains index of time points to use in <code>n</code>
progressively coarser distribution for sampling <code>kappa</code> in tempered update steps.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_n.tune">n.tune</code></td>
<td>
<p>The number of tuning iterations to update the slice sampler width, <code>w</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
<tr><td><code id="gpBFixPost_+3A_s">s</code></td>
<td>
<p>An integer vector inputting cluster membership structure if select <code>fix == TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gpdpbPost'>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</h2><span id='topic+gpdpbPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpdpbPost(
  y,
  ipr,
  Omega_t,
  Omega_s,
  gp_mod,
  jitter,
  b_move,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  lower,
  upper,
  w_star,
  w,
  n_slice_iter,
  y_index,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  M_init,
  dp_shape,
  dp_rate,
  progress
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpdpbPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions. <code>y</code> may\
have intermittant missing values. They should be input with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_omega_t">Omega_t</code></td>
<td>
<p>A <em>T x T</em> matrix of squared Eucidean distances for <code>T</code> time points</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_omega_s">Omega_s</code></td>
<td>
<p>A <code>list</code> object of length <code>L_s</code>, where each contains the <em>T x T</em>
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_gp_mod">gp_mod</code></td>
<td>
<p>An <em>L x 1</em> numeric vector denoting the selected covariance function for each
of <code>L</code> terms.  <code>gp_mod = 1</code> is <code>"rq"</code>.  <code>gp_mod = 2</code> is <code>"se"</code>.
<code>gp_mod = 3</code> is <code>"sn"</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_jitter">jitter</code></td>
<td>
<p>Numeric value added to diagonals of GP covariance matrix to stabilize inversion.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_b_move">b_move</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to sample GP functions, <code>(bb_i)</code>
in a <em>T x 1</em> Gibbs step or through elliptical slice sampling.
<code>b_move = 1</code> samples in a Gibbs step. Defaults to <code>b_move = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_lower">lower</code></td>
<td>
<p>Minimum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_upper">upper</code></td>
<td>
<p>Maximum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_w_star">w_star</code></td>
<td>
<p>Tuning parameter for number of locations to sample not linked to observations
in the auxiliary Gibbs sampler for cluster assignments.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_w">w</code></td>
<td>
<p>Tuning parameter for slice sampling interval width used for GP 
covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_n_slice_iter">n_slice_iter</code></td>
<td>
<p>Maximum number of steps to widen slice samplind width for
GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_y_index">y_index</code></td>
<td>
<p>List object where each contains index of time points to use in <code>n</code>
progressively coarser distribution for sampling <code>kappa</code> in tempered update steps.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_n.tune">n.tune</code></td>
<td>
<p>The number of tuning iterations to update the slice sampler width, <code>w</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_m_init">M_init</code></td>
<td>
<p>Starting value of number of clusters for sampling cluster assignments.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter.
The rate parameter is set of <code>1</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter. 
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gpdpbPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gpdpgrow'>Bayesian non-parametric dependent Gaussian process model for time-indexed functional data</h2><span id='topic+gpdpgrow'></span><span id='topic+gpdpgrow.default'></span>

<h3>Description</h3>

<p>Estimates a collection of time-indexed functions with Gaussian process (GP) formulations 
where a Dirichlet process mixture allows sub-groupings of the functions to share the same 
GP covariance parameters.  The GP formulation supports any number of additive GP covariance terms,
expressing either or both of multiple trend and seasonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpdpgrow(
  y,
  ipr,
  time_points,
  gp_cov,
  sn_order,
  jitter,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  dp_shape,
  dp_rate,
  M_init,
  lower,
  upper,
  sub_size,
  w_star,
  w,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  progress,
  b_move,
  cluster,
  s
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpdpgrow_+3A_y">y</code></td>
<td>
<p>A multivariate continuous response, specified as an <em>N x T</em> matrix, where <code>N</code>
denotes the number of functions and <code>T</code>, the number of time points per function. Intermittent 
missing-at-random values are allowed and will be estimated from the posterior
predictive distribution.  Missing cells should be denoted with <code>NA</code>.  The sampling of
missing values requires co-sampling the functions, <code>bb</code>, while these functions are 
marginalized out for sampling under the case of no missing data.  So the sampler will run
more slowly in the case of intermittent missingness.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_time_points">time_points</code></td>
<td>
<p>Inputs a vector of common time points at which the collections of functions were
observed (with the possibility of intermittent missingness).  The length of <code>time_points</code>
should be equal to the number of columns in the data matrix, <code>y</code>.  Defaults to 
<code>time_points = 1:ncol(y)</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_gp_cov">gp_cov</code></td>
<td>
<p>A vector of length <code>L</code> to select the covariance function for each of
<code>L</code> terms. Allowed inputs are <code>c("rq","se","sn")</code>, where &quot;rq&quot; denotes the 
rational quadratic covariance function, &quot;se&quot;, the square exponential, and &quot;sn&quot;, seasonality.
The seasonality covariance is a quasi-periodic multiplicative combination of a fixed length-
scale periodic covariance kernel (where the period length is specified in 'sn_order') and
a squared exponential kernel (of varying length-scale) to allow the periodicity in the seasonal
term to evolve.  e.g. If 4 terms are wanted - 2 trend terms with &quot;se&quot; and 2 seasonality terms, the input would be
<code>gp_cov = c("se","se","sn","sn")</code>. Defaults to <code>gp_cov = "rq"</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_sn_order">sn_order</code></td>
<td>
<p>A vector of length <code>L_s</code>, the number of terms in <code>gp_cov</code> where <code>"sn"</code>
is selected, that denotes the seasonality order for each term; e.g. if the two &quot;sn&quot; terms above 
are for 3 and 12 month seasonality, respectively, for monthly data, then 
<code>sn_order = c(3,12)</code>. Defaults to <code>sn_order = NULL</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_jitter">jitter</code></td>
<td>
<p>A scalar numerical value added to the diagonal elements of the T x T GP covariance 
matrix to stabilize computation.  Defaults to <code>jitter = 0.01</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the DP prior on
the P x N matrix of GP covariance parameters (where P 
denotes the number of parameters for each of the N experimental units).
Defaults to <code>gp_shape = 1</code></p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on GP covariance parameters. 
Defaults to <code>gp_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the Gamma prior on the DP concentration parameter, 
<code>conc</code>. Defaults to <code>dp_shape = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the Gamma prior on the DP concentration parameter, 
<code>conc</code>. Defaults to <code>dp_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_m_init">M_init</code></td>
<td>
<p>Starting number of clusters of <code>nrow(y)</code> units to initialize sampler.
Defaults to <code>M_init = nrow(y)</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_lower">lower</code></td>
<td>
<p>The lower end of the range to be used in conditionally sampling the GP covariance 
parameters (<code>kappa,tau_e</code>) in the slice sampler.  Defaults to <code>lower = 0</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_upper">upper</code></td>
<td>
<p>The upper end of the range to be used in conditionally sampling the GP covariance
parameters (<code>kappa,tau_e</code>) in the slice sampler.  Defaults to <code>upper = 1e10</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_sub_size">sub_size</code></td>
<td>
<p>Integer vector whose length, <code>n</code>, equals the number of progressively coarser
GP covariance matrices to use for tempered sampling steps in an alternative space to sample the
GP covariance parameters.  Each entry denotes the number of sub-sample time points in <code>T</code>
to draw under a latin hypercube design from the <em>N x T</em> data matrix, <code>y</code> to employ
for that distribution; for example, suppose <code>T = 300</code>.  <code>sub_size = c(100,50)</code>, 
would randomly select first <code>100</code> and then <code>50</code> time points from <code>y</code> to use
for each of the <code>n = 2</code> distributions.  Defaults to 
<code>sub_size = c(floor(0.25*T),floor(0.1*T))</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_w_star">w_star</code></td>
<td>
<p>Integer value denoting the number of cluster locations to sample ahead of 
observations in the auxiliary Gibbs sampler used to sample the number of clusters
and associated cluster assignments.  A higher value reduces samplin auto-correlation, but
increases computational burden.  Defaults to <code>w_star = 2</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_w">w</code></td>
<td>
<p>Numeric value denoting the step width used to construct the interval from
which to draw a sample for each GP covariance parameter in the slice sampler.  This
value is adaptively updated in the sampler tuning stage for each parameter to be equal
to the difference in the 0.95 and 0.05 sample quantiles for each of 5 block updates.
Defaults to <code>w = 1.5</code>.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_n.iter">n.iter</code></td>
<td>
<p>Total number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_n.burn">n.burn</code></td>
<td>
<p>Number of MCMC iterations to discard.
<code>gpdpgrow</code> will return <code>(n.iter - n.burn)</code> posterior samples.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_n.thin">n.thin</code></td>
<td>
<p>Gap between successive sampling iterations to save.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_n.tune">n.tune</code></td>
<td>
<p>Number of iterations (before ergodic chain instantiated) to adapt <code>w</code>, separately,
for each covariance term, <code>p = 1,...,P</code>.  Sets each <code>w_p</code> to lie in the 90 percent credible 
interval computed from the tuning sample (that is divided into 5 blocks so that <code>w_p</code> is 
successively updated in each block of runs).</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_progress">progress</code></td>
<td>
<p>A boolean value denoting whether to display a progress bar during model execution.
Defaults to <code>progress = TRUE</code></p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_b_move">b_move</code></td>
<td>
<p>A boolean value denoting whether to sample the GP function, <code>bb</code>, in <em>T x 1</em>
Gibbs steps <code>b_move = TRUE</code> or through elliptical slice sampling.  
Defaults to <code>b_move = TRUE</code>. Only used in the case there is any intermittent missingness;
otherwise <code>bb</code> is marginalized out of the sampler and post-sampled from the its predictive
distribution.</p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_cluster">cluster</code></td>
<td>
<p>A boolean value denoting whether to employ DP mix model over set of GP functions or
to just use GP model with no clustering of covariance function parameters.  
Defaults to <code>cluster = TRUE</code></p>
</td></tr>
<tr><td><code id="gpdpgrow_+3A_s">s</code></td>
<td>
<p>An <em>N x 1</em> integer vector that inputs a fixed clustering, rather than sampling it.
Defaults to <code>s = NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>S3 <code>gpdpgrow</code> object, for which many methods are available to return and view results.  Generic functions applied
to an object, <code>res</code> of class <code>gpdpgrow</code>, includes:
</p>
<table>
<tr><td><code>samples(res)</code></td>
<td>
<p> contains (<code>n.iter - n.burn</code>) posterior sampling iterations 
for every model parameter</p>
</td></tr>
<tr><td><code>resid(res)</code></td>
<td>
<p> contains the model residuals.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The intended focus for this package are data composed of observed noisy functions (each of 
length <code>T</code>) for a set of experimental units where the functions may express dependence
among the experimental units
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a> Daniell Toth <a href="mailto:danielltoth@yahoo.com">danielltoth@yahoo.com</a>
</p>


<h3>References</h3>

<p>T. D. Savitsky and D. Toth (2014) Bayesian Non-parametric Models for Collections of Time-
indexed Functions. submitted to: JRSS Series A (Statistics in Society).
</p>
<p>T. D. Savitsky (2014) Bayesian Non-parametric Functional Mixture
Estimation for Time-indexed data. submitted to: Annals of Applied Statistics.
</p>
<p>T. D. Savitsky (2014) Bayesian Non-Parametric Mixture Estimation for Time-Indexed Functional
Data for <code>R</code>. Submitted to: Journal of Statistical Software.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count data for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, associated with 
## the years 2011 - 2013
## to examine the state level employment 
## levels during the "great recession"
y_short   &lt;- cps$y[,(cps$yr_label %in% c(2011:2013))]

## uses default setting of a single "rational quadratic" covariance
## run for 500 iterations, with half discarded as burn-in to 
## obtain a more useful result.
res_gp               &lt;- gpdpgrow(y = y_short, 
                                 n.iter = 4, 
                                 n.burn = 1, 
                                 n.thin = 1, 
                                 n.tune = 0)  

## Two plots of estimated functions, 
## 1. faceted by cluster 
## 2. fitted functions vs noisy observations
## first plot will plot estimated denoised function, 
## bb_i, for a single (randomly-selected) "state"
fit_plots_gp        &lt;- cluster_plot( object = res_gp,  
                           units_name = "state", 
                           units_label = cps$st, 
                           single_unit = TRUE, 
                           credible = TRUE )
## second plot will randomly select 6 states 
## and plot their estimated denoised functions, bb_i.
## with setting "single_unit = FALSE". 
## (Option "num_plot" may be set to plot 
## any integer number of 
## randomly-selected units.)
fit_plots_gp        &lt;- cluster_plot( object = res_gp,  
                                     units_name = "state", 
                                     units_label = cps$st, 
                                     single_unit = FALSE, 
                                     credible = TRUE )

}
</code></pre>

<hr>
<h2 id='gpdpPost'>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</h2><span id='topic+gpdpPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpdpPost(
  y,
  ipr,
  Omega_t,
  Omega_s,
  gp_mod,
  jitter,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  lower,
  upper,
  w_star,
  w,
  n_slice_iter,
  y_index,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  M_init,
  dp_shape,
  dp_rate,
  progress
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpdpPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_omega_t">Omega_t</code></td>
<td>
<p>A <em>T x T</em> matrix of squared Eucidean distances for <code>T</code> time points</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_omega_s">Omega_s</code></td>
<td>
<p>A <code>list</code> object of length <code>L_s</code>, where each contains the <em>T x T</em>
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_gp_mod">gp_mod</code></td>
<td>
<p>An <em>L x 1</em> numeric vector denoting the selected covariance function for each
of <code>L</code> terms.  <code>gp_mod = 1</code> is <code>"rq"</code>.  <code>gp_mod = 2</code> is <code>"se"</code>.
<code>gp_mod = 3</code> is <code>"sn"</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_jitter">jitter</code></td>
<td>
<p>Numeric value added to diagonals of GP covariance matrix to stabilize inversion.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_lower">lower</code></td>
<td>
<p>Minimum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_upper">upper</code></td>
<td>
<p>Maximum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_w_star">w_star</code></td>
<td>
<p>Tuning parameter for number of locations to sample not linked to observations
in the auxiliary Gibbs sampler for cluster assignments.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_w">w</code></td>
<td>
<p>Tuning parameter for slice sampling interval width used for GP 
covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_n_slice_iter">n_slice_iter</code></td>
<td>
<p>Maximum number of steps to widen slice samplind width for
GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_y_index">y_index</code></td>
<td>
<p>List object where each contains index of time points to use in <code>n</code>
progressively coarser distribution for sampling <code>kappa</code> in tempered update steps.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_n.tune">n.tune</code></td>
<td>
<p>The number of tuning iterations to update the slice sampler width, <code>w</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_m_init">M_init</code></td>
<td>
<p>Starting value of number of clusters for sampling cluster assignments.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_dp_shape">dp_shape</code></td>
<td>
<p>The shape parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter.
The rate parameter is set of <code>1</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_dp_rate">dp_rate</code></td>
<td>
<p>The rate parameter for the <code class="reqn">\Gamma</code> prior on the DP concentration parameter. 
Default value is <code>1</code>.</p>
</td></tr>
<tr><td><code id="gpdpPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gpFixPost'>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</h2><span id='topic+gpFixPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpFixPost(
  y,
  ipr,
  Omega_t,
  Omega_s,
  gp_mod,
  jitter,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  lower,
  upper,
  w,
  n_slice_iter,
  y_index,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  progress,
  s
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpFixPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_omega_t">Omega_t</code></td>
<td>
<p>A <em>T x T</em> matrix of squared Eucidean distances for <code>T</code> time points</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_omega_s">Omega_s</code></td>
<td>
<p>A <code>list</code> object of length <code>L_s</code>, where each contains the <em>T x T</em>
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_gp_mod">gp_mod</code></td>
<td>
<p>An <em>L x 1</em> numeric vector denoting the selected covariance function for each
of <code>L</code> terms.  <code>gp_mod = 1</code> is <code>"rq"</code>.  <code>gp_mod = 2</code> is <code>"se"</code>.
<code>gp_mod = 3</code> is <code>"sn"</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_jitter">jitter</code></td>
<td>
<p>Numeric value added to diagonals of GP covariance matrix to stabilize inversion.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_lower">lower</code></td>
<td>
<p>Minimum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_upper">upper</code></td>
<td>
<p>Maximum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_w">w</code></td>
<td>
<p>Tuning parameter for slice sampling interval width used for GP 
covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_n_slice_iter">n_slice_iter</code></td>
<td>
<p>Maximum number of steps to widen slice samplind width for
GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_y_index">y_index</code></td>
<td>
<p>List object where each contains index of time points to use in <code>n</code>
progressively coarser distribution for sampling <code>kappa</code> in tempered update steps.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_n.tune">n.tune</code></td>
<td>
<p>The number of tuning iterations to update the slice sampler width, <code>w</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
<tr><td><code id="gpFixPost_+3A_s">s</code></td>
<td>
<p>An integer vector inputting cluster membership structure if select <code>fix == TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='gpPost'>Run a Bayesian functional data model under a GP prior whose parameters employ a DP prior</h2><span id='topic+gpPost'></span>

<h3>Description</h3>

<p>An internal function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpPost(
  y,
  ipr,
  Omega_t,
  Omega_s,
  gp_mod,
  jitter,
  gp_shape,
  gp_rate,
  noise_shape,
  noise_rate,
  lower,
  upper,
  w,
  n_slice_iter,
  y_index,
  n.iter,
  n.burn,
  n.thin,
  n.tune,
  progress
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpPost_+3A_y">y</code></td>
<td>
<p>An <em>N x T</em> matrix of N observations of <em>T x 1</em> functions</p>
</td></tr>
<tr><td><code id="gpPost_+3A_ipr">ipr</code></td>
<td>
<p>An optional input vector of inclusion probabilities for each observation unit in the case
the observed data were acquired through an informative sampling design, so that unbiased
inference about the population requires adjustments to the observed sample.  Defaults to
<code>ipr = rep(1,nrow(y))</code> indicating an iid sample.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_omega_t">Omega_t</code></td>
<td>
<p>A <em>T x T</em> matrix of squared Eucidean distances for <code>T</code> time points</p>
</td></tr>
<tr><td><code id="gpPost_+3A_omega_s">Omega_s</code></td>
<td>
<p>A <code>list</code> object of length <code>L_s</code>, where each contains the <em>T x T</em>
matrix of Euclidean distances associated to each seasonal covariance term.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_gp_mod">gp_mod</code></td>
<td>
<p>An <em>L x 1</em> numeric vector denoting the selected covariance function for each
of <code>L</code> terms.  <code>gp_mod = 1</code> is <code>"rq"</code>.  <code>gp_mod = 2</code> is <code>"se"</code>.
<code>gp_mod = 3</code> is <code>"sn"</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_jitter">jitter</code></td>
<td>
<p>Numeric value added to diagonals of GP covariance matrix to stabilize inversion.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_gp_shape">gp_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_gp_rate">gp_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution for the <code>kappa_star</code>
locations used to sample the DP prior on the <code>P</code> GP covariance parameters, 
<code>kappa</code>, for each experimental unit.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_noise_shape">noise_shape</code></td>
<td>
<p>The shape parameter of the Gamma base distribution on <code>tau_e</code>, the
model noise precision parameter. Defaults to <code>noise_shape = 3</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_noise_rate">noise_rate</code></td>
<td>
<p>The rate parameter of the Gamma base distribution on <code>tau_e</code>, the model
noise precision parameter.  Defaults to <code>noise_rate = 1</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_lower">lower</code></td>
<td>
<p>Minimum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_upper">upper</code></td>
<td>
<p>Maximum in range of support for GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_w">w</code></td>
<td>
<p>Tuning parameter for slice sampling interval width used for GP 
covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_n_slice_iter">n_slice_iter</code></td>
<td>
<p>Maximum number of steps to widen slice samplind width for
GP covariance parameters, <code>kappa</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_y_index">y_index</code></td>
<td>
<p>List object where each contains index of time points to use in <code>n</code>
progressively coarser distribution for sampling <code>kappa</code> in tempered update steps.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_n.iter">n.iter</code></td>
<td>
<p>The number of MCMC sampling iterations</p>
</td></tr>
<tr><td><code id="gpPost_+3A_n.burn">n.burn</code></td>
<td>
<p>The number of warm-up iterations to discard</p>
</td></tr>
<tr><td><code id="gpPost_+3A_n.thin">n.thin</code></td>
<td>
<p>The interval or step size of post-burn-in samples to return</p>
</td></tr>
<tr><td><code id="gpPost_+3A_n.tune">n.tune</code></td>
<td>
<p>The number of tuning iterations to update the slice sampler width, <code>w</code>.</p>
</td></tr>
<tr><td><code id="gpPost_+3A_progress">progress</code></td>
<td>
<p>An indicator in <code>{0,1}</code> denoting whether to display a progress bar during model execution.
<code>progress = 1</code> displays a progress bar. Defaults to <code>progress = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res A list object containing MCMC runs for all model parameters.
</p>


<h3>Note</h3>

<p>Intended as an internal function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>

<hr>
<h2 id='informative_plot'>Plot credible intervals for parameters to compare ignoring with weighting an informative sample</h2><span id='topic+informative_plot'></span>

<h3>Description</h3>

<p>Uses as input the output object from the gpdpgrow() and gmrfdpgrow() functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>informative_plot(
  objects = NULL,
  objects_labels = c("ignore", "weight"),
  map = NULL,
  units_name = NULL,
  model = "gp",
  true_star = NULL,
  map_true = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="informative_plot_+3A_objects">objects</code></td>
<td>
<p>A list of objects, either all outputs from gpdpgrow(), or all from gmrfdpgrow().
<code>objects</code> includes a model estimated under ignoring the informativeness of the 
sampling design and another that employs weighting to account for the informativeness.
An additional object may be added to represent a separate &quot;iid&quot; (or non-informative)
sample from the same population, which will typically be available if the dataset
was generated as synthetic data using function, &quot;gen_informative_sample()&quot;.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_objects_labels">objects_labels</code></td>
<td>
<p>A character vector of length equal to <code>objects</code> that provides
labels for each entry in <code>objects</code>.  Allowed entries in <code>objects_labels</code> 
are <code>c("ignore","weight","iid")</code>, where &quot;ignore&quot; denotes a model that ignores
the informativeness, while &quot;weight&quot; denotes a model that employs sampling weights and
&quot;iid&quot; denotes a model run on a non-informative, iid sample from the same population.
Defaults to <code>objects_labels = c("ignore","weight")</code>.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_map">map</code></td>
<td>
<p>A list matrices, where each entry is produced 
from <code>cluster_plot(object)$map</code>. It is comprised of
unit labels and cluster assignments for each object in <code>objects</code>.
The length of <code>map</code> must be equal to the length of <code>objects</code>.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_units_name">units_name</code></td>
<td>
<p>The label in each &quot;map&quot; matrix for the observation units. Will be the same as the
<code>units_name</code> entry for the previously run, <code>cluster_plot()</code> function.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_model">model</code></td>
<td>
<p>A scalar character input indicating the estimation model for <em>all</em> of the entries
in <code>objects</code>. Allowable values for <code>model</code> are c(&quot;gp&quot;,&quot;gmrf&quot;). Defaults to
<code>model = "gp"</code>.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_true_star">true_star</code></td>
<td>
<p>An optional, <em>P x M</em>  matrix, of true parameter location values, where
<code>P</code> denotes the number of parameters per cluster and <code>M</code> denotes the number of
clusters.  For example, in <code>model = "gp"</code> with a single, rational quadratic covariance,
<code>P = 3</code> and if there are 3 clusters, then <code>M = 3</code>.  For a <code>model = "gmrf"</code>,
with a single covariance, <code>P = 1</code>.</p>
</td></tr>
<tr><td><code id="informative_plot_+3A_map_true">map_true</code></td>
<td>
<p>An optional <code>data.frame</code> object with <code>n</code> rows, the size of the
informative sample used for <code>c("ignore","weight")</code> objects that maps the
<code>units_name</code> to a true cluster.  <code>map_true</code> must have 2 columns (and the
rest are ignored), one must be named the same value as input for <code>units_name</code>.
The second column must be named, <code>cluster</code>.  If the true values derive
from running <code>gen_informative_sample()</code> as the source of the true values,
one may just input the <code>map_obs</code> <code>data.frame</code> that is listed in the object
returned by <code>gen_informative_sample()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the plot of estimated functions, faceted by cluster,
and the associated <code>data.frame</code> object.
</p>
<table>
<tr><td><code>p.compare</code></td>
<td>
<p>A <code>ggplot2</code> plot object</p>
</td></tr>
<tr><td><code>dat.compare</code></td>
<td>
<p>A <code>data.frame</code> object used to generate <code>p.compare</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(growfunctions)
## use gen_informative_sample() to generate an 
## N X T population drawn from a dependent GP
## By default, 3 clusters are used to generate 
## the population.
## A single stage stratified random sample of size n 
## is drawn from the population using I = 4 strata. 
## The resulting sample is informative in that the 
## distribution for this sample is
## different from the population from which 
## it was drawn because the strata inclusion
## probabilities are proportional to a feature 
## of the response, y (in the case, the variance.
## The stratified random sample over-samples 
## large variance strata).
## (The user may also select a 2-stage 
## sample with the first stage
## sampling "blocks" of the population and 
## the second stage sampling strata within blocks). 
dat_sim        &lt;- gen_informative_sample(N= 10000, 
                                n = 500, T = 5,
                                noise_to_signal = 0.1)

y_obs                       &lt;- dat_sim$y_obs
T                           &lt;- ncol(y_obs)

an informative sampling design that inputs inclusion
probabilities, ipr
res_gp_w            &lt;- gpdpgrow(y = y_obs, 
                               ipr = dat_sim$map_obs$incl_prob, 
                               n.iter = 5, n.burn = 2,  
                               n.thin = 1, n.tune = 0)
and fit vs. data for experimental units
fit_plots_w         &lt;- cluster_plot( object = res_gp_w,  
                           units_name = "establishment", 
                           units_label = dat_sim$map_obs$establishment, 
                           single_unit = FALSE, credible = TRUE )

## estimate parameters ignoring sampling design
res_gp_i            &lt;- gpdpgrow(y = y_obs, 
                               n.iter = 5, n.burn = 2, 
                               n.thin = 1, n.tune = 0)
## plots of estimated functions, faceted by cluster and fit vs. 
## data for experimental units
fit_plots_i         &lt;- cluster_plot( object = res_gp_i,  
                                    units_name = "establishment", 
                                    units_label = dat_sim$map_obs$establishment, 
                                    single_unit = FALSE, credible = TRUE )

## We also draw an iid (non-informative, exchangeable) 
## sample from the same population to 
## compare estimation results to our weighted 
## (w) and unweighted/ignoring (i) models

## estimate parameters under an iid sampling design
res_gp_iid          &lt;- gpdpgrow(y = dat_sim$y_iid, 
                               n.iter = 5, n.burn = 2,   
                               n.thin = 1, n.tune = 0)
## plots of estimated functions, faceted by cluster and 
## fit vs. data for experimental units
fit_plots_iid       &lt;- cluster_plot( object = res_gp_iid,  
                           units_name = "establishment", 
                           units_label = dat_sim$map_iid$establishment, 
                           single_unit = FALSE, credible = TRUE )

## compare estimations of covariance parameter credible 
## intervals when ignoring informativeness vs.
## weighting to account for informativeness
objects                  &lt;- map &lt;- vector("list",3)
objects[[1]]             &lt;- res_gp_i
objects[[2]]             &lt;- res_gp_iid
objects[[3]]             &lt;- res_gp_w
map[[1]]                 &lt;- fit_plots_i$map
map[[2]]                 &lt;- fit_plots_iid$map
map[[3]]                 &lt;- fit_plots_w$map
objects_labels           &lt;- c("ignore","iid","weight")

parms_plots_compare      &lt;- informative_plot( objects = objects, 
                                objects_labels = objects_labels,
                                map = map, units_name = "establishment", 
                                model = "gp",
                                true_star = dat_sim$theta_star, 
                                map_true = dat_sim$map_obs)


## End(Not run)
</code></pre>

<hr>
<h2 id='MSPE'>Compute normalized mean squared prediction error based on accuracy to impute missing data values</h2><span id='topic+MSPE'></span>

<h3>Description</h3>

<p>Uses as input the output object from the gpdpgrow() and gmrfdpgrow() functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSPE(object, y_true, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MSPE_+3A_object">object</code></td>
<td>
<p>A <code>gpdpgrow</code> or <code>gmrfdpgrow</code> object.</p>
</td></tr>
<tr><td><code id="MSPE_+3A_y_true">y_true</code></td>
<td>
<p>An <code>N x T</code> numeric matrix of test set values.</p>
</td></tr>
<tr><td><code id="MSPE_+3A_pos">pos</code></td>
<td>
<p>An <code>N x T</code> matrix with all entries either <code>0</code> or <code>1</code>, where a <code>1</code>
indexes a missing entry or test point in <code>y_true</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing various MSPE fit statistics that measure the accuracy of 
of predicting the values in <code>y_true</code> indexed by <code>pos</code>.
</p>
<table>
<tr><td><code>SSE</code></td>
<td>
<p>Sum of squared errors based on <em>full</em> <code>N x T</code>, <code>y_true - y_hat</code>.</p>
</td></tr>
<tr><td><code>MSE</code></td>
<td>
<p>Mean squared error computed from <code>SSE</code>.</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>Square root of <code>MSE</code>.</p>
</td></tr>
<tr><td><code>SSPE</code></td>
<td>
<p>Sum of squared prediction error based on missing values.</p>
</td></tr>
<tr><td><code>MSPE</code></td>
<td>
<p>Mean squared prediction error based on missing values.</p>
</td></tr>
<tr><td><code>nMSPE</code></td>
<td>
<p>Mean squared prediction error based on missing values that is 
normalized by the variance of the test observations to produce a value in 
<code>[0,1]</code>.</p>
</td></tr>
<tr><td><code>RMSPE</code></td>
<td>
<p>Square root of <code>MSPE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>{
library(growfunctions)

## load the monthly employment count data for a collection of 
## U.S. states from the Current 
## Population Survey (cps)
data(cps)
## subselect the columns of N x T, y, associated with 
## the years 2009 - 2013
## to examine the state level employment 
## levels during the "great recession"
y_short   &lt;- cps$y[,(cps$yr_label %in% c(2009:2013))]

## dimensions
T         &lt;- ncol(y_short)  ## time points per unit
N         &lt;- nrow(y_short)  ## number of units

## Demonstrate estimation of intermittent missing data 
## from posterior predictive distribution by randomly
## selecting 10 percent of entries in y_short and 
## setting them to NA.

## randomly assign missing positions in y.
## assume every unit has equal number of 
## missing positions
## randomly select number of missing 
## observations for each unit
m_factor  &lt;- .1
M         &lt;- floor(m_factor*N*T)
m_vec     &lt;- rep(floor(M/N),N)
if( sum(m_vec) &lt; M )
{
    m_left              &lt;- M - sum(m_vec)
    pos_i               &lt;- sample(1:N, m_left, 
                                replace = FALSE)
     m_vec[pos_i]        &lt;- m_vec[pos_i] + 1
} # end conditional statement on whether all 
  # missing cells allocated
  # randomly select missing 
  # positions for each unit
pos       &lt;- matrix(0,N,T)
for( i in 1:N )
{
    sel_ij              &lt;- sample(3:(T-3), m_vec[i], 
                           replace = FALSE) 
                           ## avoid edge effects
    pos[i,sel_ij]       &lt;- 1
}

## configure N x T matrix, y_obs, with 10 percent missing 
## observations (filled with NA)
## to use for sampling.  Entries in y_short 
## that are set to missing (NA) are
## determined by entries of "1" in the 
## N x T matrix, pos.
y_obs               &lt;- y_short
y_obs[pos == 1]     &lt;- NA       

## Conduct dependent GP model estimation under 
## missing observations in y_obs.
## We illustrate the ability to have multiple 
## function or covariance terms
## by seting gp_cov = c("se","sn"), which indicates 
## the first term is a
## squared exponential ("se") trend covariance term 
## and the "sn" is a seasonality
## term.  The setting, sn_order = 4, indicates the 
## length scale of the seasonality
## term is 4 month.  The season term is actually 
## "quasi" seasonal, in that the
## seasonal covariance kernel is multiplied by a 
## squared exponential, which allows
## the pattern of seasonality to evolve over time.
res_gp_2               &lt;- gpdpgrow(y = y_obs, 
                                  gp_cov=c("se","sn"), 
                                  sn_order = 4, 
                                  n.iter = 10, 
                                  n.burn = 4, 
                                  n.thin = 1, 
                                  n.tune = 0) 

## 2 plots of estimated functions: 1. faceted by cluster and fit;
## 2.  data for experimental units.
## for a group of randomly-selected functions
fit_plots_gp_2        &lt;- cluster_plot( object = res_gp_2,  
                                      units_name = "state", 
                                      units_label = cps$st, 
                                      single_unit = TRUE, 
                                      credible = TRUE )
                                      
## Compute out-of-sample fit statistic, normalized mean-square 
## prediction error (MSPE)
## The normalized MSPE will take the predicted values 
## for the entries in y_short purposefully
## set to NA and will subtract them from the known true 
## values in y_short (and square them).
## This MSE on predicted (test) data is then 
## divided by the variance of the test observations
## to output something akin to a percent error.
( nmspe_gp  &lt;- MSPE(res_gp_2, y_short, pos)$nMSPE )    
}
</code></pre>

<hr>
<h2 id='plot_cluster'>Plot estimated functions, faceted by cluster numbers, for a known clustering</h2><span id='topic+plot_cluster'></span>

<h3>Description</h3>

<p>An internal function of the <code>growfunctions</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cluster(
  y,
  H,
  sort = FALSE,
  sample_rate = 0.05,
  y.axis.label = NULL,
  smoother = TRUE,
  fade = 0.2,
  cluster_order = NULL,
  plot_render = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cluster_+3A_y">y</code></td>
<td>
<p>An <code>N x T</code> matrix for a collection of functions.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_h">H</code></td>
<td>
<p>An <code>N x 1</code> with entries in <code>1,...,M</code> of cluster assignments for the <code>N</code>
units of <code>y</code> under a known clustering.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_sort">sort</code></td>
<td>
<p>An optional boolean input on whether to sort the cluster-indexed plot panels 
of function by size of cluster.  Defaults <code>sort = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_sample_rate">sample_rate</code></td>
<td>
<p>An optional numeric value in (0,1] indicating percent of functions to 
randomly sample within each cluster to address over-plotting.  Defaults to 1.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>An optional text label for y-axis. Defaults to <code>"function values"</code>.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_smoother">smoother</code></td>
<td>
<p>An optional scalar boolean input indicating whether to co-plot a smoother line 
through the functions in each cluster.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_fade">fade</code></td>
<td>
<p>An optional numeric input in <code>(0,1)</code> indicating the degree of fading to apply to the
plots of functions in each cluster-indexed panel.  Defaults to <code>fade = 0.2</code>.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_cluster_order">cluster_order</code></td>
<td>
<p>An optional numeric vector of length <code>M</code>, the number of clusters, 
indicating the order, from-to-right, for plotting the cluster-indexed panels.</p>
</td></tr>
<tr><td><code id="plot_cluster_+3A_plot_render">plot_render</code></td>
<td>
<p>An optional boolean input indicating whether to render the plot.
Defaults to <code>plot_render = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the plot of estimated functions, faceted by cluster,
and the associated <code>data.frame</code> object.
</p>
<table>
<tr><td><code>p.basis</code></td>
<td>
<p>A <code>ggplot2</code> plot object</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>A <code>data.frame</code> object listing the unit and associated cluster membership.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>

<hr>
<h2 id='predict_functions'>Use the model-estimated covariance parameters from gpdpgrow() or gmrdpgrow to predict the function at
future time points.</h2><span id='topic+predict_functions'></span>

<h3>Description</h3>

<p>This is the generic predict_functions method. See the following functions
for the details about different data structures:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_functions(object, J, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_functions_+3A_object">object</code></td>
<td>
<p>Object of class <code>gpdpgrow</code> or<code>gmrfdpgrow()</code>.</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_j">J</code></td>
<td>
<p>Scalar denoting number of draws to take from posterior predictive for each unit.
Defaults to <code>J = 500</code>.</p>
</td></tr>
<tr><td><code id="predict_functions_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code><a href="#topic+predict_functions.gpdpgrow">predict_functions.gpdpgrow</a></code> for objects of class <code>gpdpgrow</code>
</p>
</li>
<li> <p><code><a href="#topic+predict_functions.gmrfdpgrow">predict_functions.gmrfdpgrow</a></code> for objects of class <code>gmrfdpgrow</code>
</p>
</li></ul>


<hr>
<h2 id='predict_functions.gmrfdpgrow'>Use the model-estimated iGMRF precision parameters from gmrfdpgrow() to predict the iGMRF function at
future time points.  Inputs the <code>gmrfdpgrow</code> object of estimated parameters.</h2><span id='topic+predict_functions.gmrfdpgrow'></span>

<h3>Description</h3>

<p>A companion function to <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmrfdpgrow'
predict_functions(object, J = 500, T_test, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_functions.gmrfdpgrow_+3A_object">object</code></td>
<td>
<p>Object of class <code>gmrfdpgrow</code> returned from model run of <code>gmrfdpgrow()</code></p>
</td></tr>
<tr><td><code id="predict_functions.gmrfdpgrow_+3A_j">J</code></td>
<td>
<p>Scalar denoting number of draws to take from posterior predictive for each unit.
Defaults to <code>J = 500</code>.</p>
</td></tr>
<tr><td><code id="predict_functions.gmrfdpgrow_+3A_t_test">T_test</code></td>
<td>
<p>The number of equally-spaced time points to predict the iGMRF functions ahead of 
of the functions estimated at <code>T_train</code> time points.</p>
</td></tr>
<tr><td><code id="predict_functions.gmrfdpgrow_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  A list object containing containing two matrices; the first is a P x (N*T)
matrix of predicted function values for each of P sampled iterations.  N is 
slow index and denotes the number of experimental units.  The second matrix is
an N x T average over the P sampled draws, composed in Rao-Blackwellized fashion.
</p>


<h3>Note</h3>

<p>Intended as a companion function for <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code> for prediction
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(growfunctions)
data(cps)
y_short   &lt;- cps$y[,(cps$yr_label %in% c(2010:2013))]
t_train   &lt;- ncol(y_short)
N         &lt;- nrow(y_short)
t_test    &lt;- 4
 
## Model Runs

res_gmrf            = gmrfdpgrow(y = y_short, 
                                q_order = c(2,4), 
                                q_type = c("tr","sn"), 
                                n.iter = 100, 
                                n.burn = 50, 
                                n.thin = 1) 
## Prediction Model Runs
T_test             &lt;- 4

pred_gmrf          &lt;- predict_functions( object = res_gmrf,
                                     J = 1000, 
                                     T_test = T_test )

## plot estimated and predicted functions
plot_gmrf       &lt;- predict_plot(object = pred_gmrf, 
                               units_label = cps$st, 
                               single_unit = TRUE, 
                               credible = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict_functions.gpdpgrow'>Use the model-estimated GP covariance parameters from gpdpgrow() to predict the GP function at
future time points.  Inputs the <code>gpdpgrow</code> object of estimated parameters.</h2><span id='topic+predict_functions.gpdpgrow'></span>

<h3>Description</h3>

<p>A companion function to <code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gpdpgrow'
predict_functions(
  object,
  J = 500,
  test_times,
  time_points = NULL,
  sn_order = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_functions.gpdpgrow_+3A_object">object</code></td>
<td>
<p>Object of class <code>gpdpgrow</code> returned from model run of <code>gpdpgrow()</code></p>
</td></tr>
<tr><td><code id="predict_functions.gpdpgrow_+3A_j">J</code></td>
<td>
<p>Scalar denoting number of draws to take from posterior predictive for each unit.
Defaults to <code>J = 500</code>.</p>
</td></tr>
<tr><td><code id="predict_functions.gpdpgrow_+3A_test_times">test_times</code></td>
<td>
<p>A numeric vector holding test times at which to predict GP function values
Will use the estimated covariance parameters from the training data to predict
functions at the test_times for the <code>N</code> observation units.</p>
</td></tr>
<tr><td><code id="predict_functions.gpdpgrow_+3A_time_points">time_points</code></td>
<td>
<p>Inputs a vector of common time points at which the collections of functions were
observed (with the possibility of intermittent missingness).  The length of <code>time_points</code>
should be equal to the number of columns in the data matrix, <code>y</code>.  Defaults to 
<code>time_points = 1:ncol(y)</code>.</p>
</td></tr>
<tr><td><code id="predict_functions.gpdpgrow_+3A_sn_order">sn_order</code></td>
<td>
<p>An integer vector of length, <code>L_s</code>, equal to the number of seasonal terms.
Conveys the order of the seasonality for each term on the scale of T; for example,
if T is dimensioned in months, and one wishes to model quarterly seasonality, then
the applicable seasonality term would be of order <code>3</code>.</p>
</td></tr>
<tr><td><code id="predict_functions.gpdpgrow_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out  A list object containing containing two matrices; the first is a K x (N*T)
matrix of predicted function values for each of K sampled iterations.  N is 
slow index and denotes the number of experimental units.  The second matrix is
an N x T average over the K sampled draws, composed in Rao-Blackwellized fashion.
</p>


<h3>Note</h3>

<p>Intended as a companion function for <code><a href="#topic+gpdpgrow">gpdpgrow</a></code> for prediction
</p>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(growfunctions)
data(cps)
y_short   &lt;- cps$y[,(cps$yr_label %in% c(2010:2013))]
t_train   &lt;- ncol(y_short)
N         &lt;- nrow(y_short)
t_test    &lt;- 4
 
## Model Runs
res_gp              = gpdpgrow(y = y_short
                              n.iter = 50, 
                              n.burn = 25, 
                              n.thin = 1, 
                              n.tune = 0) 

## Prediction Model Runs
T_test             &lt;- 4
T_yshort           &lt;- ncol(y_short)
pred_gp            &lt;- predict_functions( object = res_gp, 
                       test_times = (T_yshort+1):(T_yshort+T_test) )

## plot estimated and predicted functions
plot_gp         &lt;- predict_plot(object = pred_gp, 
                               units_label = cps$st, 
                               single_unit = FALSE, 
                               credible = TRUE)  

## End(Not run)
</code></pre>

<hr>
<h2 id='predict_plot'>Plot estimated functions both at estimated and predicted time points with 95% credible intervals.</h2><span id='topic+predict_plot'></span>

<h3>Description</h3>

<p>Uses as input the output object from the gpdpgrow.predict() and 
gmrfdpgrow.predict() methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_plot(
  object = NULL,
  units_label = NULL,
  type_label = c("fitted", "predicted"),
  time_points = NULL,
  date_label = NULL,
  x.axis.label = NULL,
  y.axis.label = NULL,
  single_unit = FALSE,
  credible = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_plot_+3A_object">object</code></td>
<td>
<p>A <code>gpdpgrow.predict</code> or <code>gmrfdpgrow.predict</code> object, obtained from 
<code>predict_functions(object,...)</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_units_label">units_label</code></td>
<td>
<p>A vector of labels to apply to experimental units with length equal to the number of
unique units.  Defaults to sequential numeric values as input with data, <code>y</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_type_label">type_label</code></td>
<td>
<p>A character vector assigning a &quot;fitted&quot; or &quot;predicted
label for the <code>time_points</code> input. Defaults to <code>type_label = c("fitted","predicted")</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_time_points">time_points</code></td>
<td>
<p>A list input of length 2 with each entry containing a numeric vector
of times -  one for the observed times for the set of &quot;fitted&quot; functions and the other denotes 
time values at which &quot;predicted&quot; values were rendered for the functions.  This input variable
only applies to <code>gpdpgrow</code> objects and not <code>gmrfdpgrow</code> objects because the latter 
covariance structure is based on adjacency for equally-spaced time points.
Defaults to <code>1:T_train</code> for the list entry pointed to &quot;fitted&quot; and 
<code>(T_train+1):(T_train + T_test)</code> for the list entry pointed to &quot;predicted&quot;.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_date_label">date_label</code></td>
<td>
<p>A vector of <code>Date</code> values for labeling the x-axis tick marks.
Defaults to <code>1:T</code>  .</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_x.axis.label">x.axis.label</code></td>
<td>
<p>Text label for x-axis. Defaults to <code>"time"</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_y.axis.label">y.axis.label</code></td>
<td>
<p>Text label for y-axis. Defaults to <code>"function values"</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_single_unit">single_unit</code></td>
<td>
<p>A scalar boolean indicating whether to plot the fitted vs data curve for
only a single experimental units (versus a random sample of 6). 
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_plot_+3A_credible">credible</code></td>
<td>
<p>A scalar boolean indicating whether to plot 95 percent credible intervals for
estimated functions, <code>bb</code>, when plotting fitted functions versus data.  Defaults to
<code>credible = TRUE</code>  .</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the plot of estimated functions, faceted by cluster,
and the associated <code>data.frame</code> object.
</p>
<table>
<tr><td><code>p.cluster</code></td>
<td>
<p>A <code>ggplot2</code> plot object</p>
</td></tr>
<tr><td><code>dat.cluster</code></td>
<td>
<p>A <code>data.frame</code> object used to generate <code>p.cluster</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Terrance Savitsky <a href="mailto:tds151@gmail.com">tds151@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpdpgrow">gpdpgrow</a></code>, <code><a href="#topic+gmrfdpgrow">gmrfdpgrow</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(growfunctions)
data(cps)
y_short             &lt;- cps$y[,(cps$yr_label %in% c(2008:2013))]
t_train             &lt;- ncol(y_short)
N                   &lt;- nrow(y_short)
t_test              &lt;- 4
 
## Model Runs

res_gmrf            &lt;- gmrfdpgrow(y = y_short, 
                                q_order = c(2,4), 
                                q_type = c("tr","sn"), 
                                n.iter = 40, 
                                n.burn = 20, 
                                n.thin = 1) 

res_gp              &lt;- gpdpgrow(y = y_short
                              n.iter = 10, 
                              n.burn = 4, 
                              n.thin = 1, 
                              n.tune = 0) 

## Prediction Model Runs
T_test             &lt;- 4

pred_gmrf          &lt;- predict_functions( object = res_gmrf,
                                     J = 1000, 
                                     T_test = T_test )

T_yshort           &lt;- ncol(y_short)
pred_gp            &lt;- predict_functions( object = res_gp, 
                     test_times = (T_yshort+1):(T_yshort+T_test) )

## plot estimated and predicted functions
plot_gmrf       &lt;- predict_plot(object = pred_gmrf, 
                               units_label = cps$st, 
                               single_unit = TRUE, 
                               credible = FALSE)

plot_gp         &lt;- predict_plot(object = pred_gp, 
                               units_label = cps$st, 
                               single_unit = FALSE, 
                               credible = TRUE)  

## End(Not run)
</code></pre>

<hr>
<h2 id='samples'>Produce samples of MCMC output</h2><span id='topic+samples'></span><span id='topic+samples.gpdpgrow'></span>

<h3>Description</h3>

<p>provides posterior sampled values for every model parameter of a
<code>gpdpgrow</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samples(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples_+3A_object">object</code></td>
<td>
<p>A <code>gpdpgrow</code> object</p>
</td></tr>
<tr><td><code id="samples_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>

<hr>
<h2 id='samples.gmrfdpgrow'>Produce samples of MCMC output</h2><span id='topic+samples.gmrfdpgrow'></span>

<h3>Description</h3>

<p>provides posterior sampled values for every model parameter of a
<code>gmrfdpgrow</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gmrfdpgrow'
samples(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples.gmrfdpgrow_+3A_object">object</code></td>
<td>
<p>A <code>gmrfdpgrow</code> object</p>
</td></tr>
<tr><td><code id="samples.gmrfdpgrow_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
