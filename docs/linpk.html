<!DOCTYPE html><html><head><title>Help for package linpk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {linpk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.pkprofile'><p>Coerce a <code>pkprofile</code> to a <code>data.frame</code></p></a></li>
<li><a href='#blockdiag'><p>Construct a block-diagonal matrix.</p></a></li>
<li><a href='#cor2cov'><p>Convert from standard deviation and correlation matrix to covariance matrix.</p></a></li>
<li><a href='#dose.frame'><p>Get the doses from a PK profile.</p></a></li>
<li><a href='#finalstate'><p>Get the final state or time of a PK profile.</p></a></li>
<li><a href='#generateETA'><p>Generate individual random effects from a multivariate normal distribution.</p></a></li>
<li><a href='#halflife'><p>Half-lives of a linear PK system.</p></a></li>
<li><a href='#linpkApp'><p>Runs the interactive shiny app.</p></a></li>
<li><a href='#LTmat'><p>Construct a symmetric matrix from its lower triangle.</p></a></li>
<li><a href='#pkprofile'><p>Generate a concentration-time profile.</p></a></li>
<li><a href='#pkprofile-methods'><p>Printing and plotting methods for class <code>pkprofile</code>.</p></a></li>
<li><a href='#pkprofile.pkprofile'><p>Continue an existing concentration-time profile.</p></a></li>
<li><a href='#secondary'><p>Derive secondary PK parameters.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-04</td>
</tr>
<tr>
<td>Title:</td>
<td>Generate Concentration-Time Profiles from Linear PK Systems</td>
</tr>
<tr>
<td>Author:</td>
<td>Benjamin Rich [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Rich &lt;mail@benjaminrich.net&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/benjaminrich/linpk">https://github.com/benjaminrich/linpk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/benjaminrich/linpk/issues">https://github.com/benjaminrich/linpk/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Generate concentration-time profiles from linear pharmacokinetic
  (PK) systems, possibly with first-order absorption or zero-order infusion,
  possibly with one or more peripheral compartments, and possibly under
  steady-state conditions. Single or multiple doses may be specified. Secondary
  (derived) PK parameters (e.g. Cmax, Ctrough, AUC, Tmax, half-life, etc.) are
  computed.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics,utils,mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,rmarkdown,shiny</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-04 13:56:55 UTC; ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-12-04 14:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.pkprofile'>Coerce a <code>pkprofile</code> to a <code>data.frame</code></h2><span id='topic+as.data.frame.pkprofile'></span>

<h3>Description</h3>

<p>Coerce a <code>pkprofile</code> to a <code>data.frame</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkprofile'
as.data.frame(x, ..., col.names = c("time", "conc"), .state = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.pkprofile_+3A_x">x</code></td>
<td>
<p>An object of class <code>pkprofile</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.pkprofile_+3A_...">...</code></td>
<td>
<p>Further arguments passed along.</p>
</td></tr>
<tr><td><code id="as.data.frame.pkprofile_+3A_col.names">col.names</code></td>
<td>
<p>Character vector of length 2 giving the names for the time and concentration columns.</p>
</td></tr>
<tr><td><code id="as.data.frame.pkprofile_+3A_.state">.state</code></td>
<td>
<p>Include the complete state along with <code>time</code> and <code>conc</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>time</code> and <code>conc</code> (or the
names specified in <code>col.names</code>). If <code>.state == TRUE</code>, then the
complete state is appended (as a matrix column).
</p>

<hr>
<h2 id='blockdiag'>Construct a block-diagonal matrix.</h2><span id='topic+blockdiag'></span>

<h3>Description</h3>

<p>Construct a block-diagonal matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockdiag(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockdiag_+3A_...">...</code></td>
<td>
<p>Any number of square matrices making up the diagonal blocks of
the matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A block-diagonal matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>blockdiag(matrix(1, 2, 2), 2, matrix(3, 4, 4))
</code></pre>

<hr>
<h2 id='cor2cov'>Convert from standard deviation and correlation matrix to covariance matrix.</h2><span id='topic+cor2cov'></span>

<h3>Description</h3>

<p>Convert from standard deviation and correlation matrix to covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2cov(cor, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2cov_+3A_cor">cor</code></td>
<td>
<p>A correlation matrix. If <code>sd</code> is missing, the diagonal
entries are taken to be the standard deviations, otherwise they are ignored.</p>
</td></tr>
<tr><td><code id="cor2cov_+3A_sd">sd</code></td>
<td>
<p>A vector of standard deviations (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cor2cov(matrix(c(1, 0.5, 0.5, 1), 2, 2), 0.1)
</code></pre>

<hr>
<h2 id='dose.frame'>Get the doses from a PK profile.</h2><span id='topic+dose.frame'></span>

<h3>Description</h3>

<p>Get the doses from a PK profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose.frame(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dose.frame_+3A_x">x</code></td>
<td>
<p>A object of class <code><a href="#topic+pkprofile">pkprofile</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the realized doses, one per row. The
<code>data.frame</code> has all the columns described in <code><a href="#topic+pkprofile">pkprofile</a></code>,
except <code>addl</code>, since all additional doses have been expanded to
individual rows. It also has a <code>conc</code> column with the simulated
concentration at the time of the dose.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pkprofile">pkprofile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.obs &lt;- seq(0, 6*24, 0.5)
y &lt;- pkprofile(t.obs, cl=0.5, vc=11, ka=1.3,
    dose=list(t.dose=c(0, 24*2 + 14), amt=c(100, 50), addl=c(4, 0), ii=24))
dose.frame(y)
</code></pre>

<hr>
<h2 id='finalstate'>Get the final state or time of a PK profile.</h2><span id='topic+finalstate'></span><span id='topic+finaltime'></span>

<h3>Description</h3>

<p>Get the final state or time of a PK profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalstate(x)

finaltime(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finalstate_+3A_x">x</code></td>
<td>
<p>A object of class <code><a href="#topic+pkprofile">pkprofile</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector containing the state of each compartment at
the final observation time (<code>finalstate</code>), or the final observation
time itself (<code>finaltime</code>).
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+pkprofile">pkprofile</a></code> for generating a PK profile.
</p>
</li>
<li> <p><code><a href="#topic+pkprofile.pkprofile">pkprofile.pkprofile</a></code> for appending to an existing PK profile.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Administer a dose at time 0 and a second dose using the final state
# from the first dose (at 12h) as the initial state for the second dose.
t.obs &lt;- seq(0, 12, 0.1)
y &lt;- pkprofile(t.obs, cl=0.25, vc=5, ka=1, dose=list(t.dose=0, amt=1))
finalstate(y)
y2 &lt;- pkprofile(t.obs, cl=0.25, vc=5, ka=1, dose=list(t.dose=0, amt=1), initstate=finalstate(y))
plot(y, xlim=c(0, 24), ylim=c(0, max(y2)), col="blue")  # First dose
lines(t.obs+12, y2, col="red")                          # Second dose

# Add a vertical line to show where the first profile ends.
abline(v=finaltime(y), col="gray75", lty=2)
</code></pre>

<hr>
<h2 id='generateETA'>Generate individual random effects from a multivariate normal distribution.</h2><span id='topic+generateETA'></span>

<h3>Description</h3>

<p>Generate individual random effects from a multivariate normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateETA(n, omegaLT, omega = LTmat(omegaLT), eta.names = colnames(omega))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateETA_+3A_n">n</code></td>
<td>
<p>The number of individuals.</p>
</td></tr>
<tr><td><code id="generateETA_+3A_omegalt">omegaLT</code></td>
<td>
<p>A numeric vector giving the elements of the lower triangle
of the covariance matrix by row.</p>
</td></tr>
<tr><td><code id="generateETA_+3A_omega">omega</code></td>
<td>
<p>The covariance matrix.</p>
</td></tr>
<tr><td><code id="generateETA_+3A_eta.names">eta.names</code></td>
<td>
<p>A character vector of names for each random effect
(defaults to the column names of <code>omega</code>, or if <code>NULL</code> then to
ETA1, ETA2, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code class="reqn">n \times p</code> matrix, where each row contains the vector of random
effects for one individual (<code class="reqn">p</code> is the size of the covariance matrix).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LTmat">LTmat</a></code>
<code><a href="#topic+blockdiag">blockdiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>omegaLT &lt;- c(0.123, 0.045, 0.678)
generateETA(10, omegaLT)
</code></pre>

<hr>
<h2 id='halflife'>Half-lives of a linear PK system.</h2><span id='topic+halflife'></span>

<h3>Description</h3>

<p>Half-lives of a linear PK system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halflife(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="halflife_+3A_x">x</code></td>
<td>
<p>A object of class <code><a href="#topic+pkprofile">pkprofile</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector containing the half-lives for the different
phases of the system. The number of phases generally equal the number of
compartments, plus one for the absorption phase if the system has first
order absorption (i.e. if <code>ka</code> is specified). The values are returned
sorted in ascending order, so the first corresponds to the alpha phase,
the second beta, the third gamma, and so on. The absorption half-life, if
present, comes last (it can also be identified by comparing it to the value
of <code>log(2)/ka</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- pkprofile(0, cl=0.25, vc=5, ka=1.1)
halflife(y)
log(2)/1.1

y &lt;- pkprofile(0, cl=0.25, vc=5, ka=0.01)  # Flip-flop kinetics
halflife(y)
log(2)/0.01

# Three-compartment model
y &lt;- pkprofile(0, cl=2, vc=10, q=c(0.5, 0.3), vp=c(30, 40))
halflife(y)

# The terminal half-life can be used to obtain the terminal slope of the
# concentration-time curve on the semi-log scale:
t.obs &lt;- seq(0, 36, 0.1)
y &lt;- pkprofile(t.obs, cl=0.25, vc=5, ka=1, dose=list(t.dose=0, amt=1))
plot(log2(y))
abline(-2.247927, -1/halflife(y)[1], col=adjustcolor("blue", 0.2), lwd=12)

</code></pre>

<hr>
<h2 id='linpkApp'>Runs the interactive shiny app.</h2><span id='topic+linpkApp'></span>

<h3>Description</h3>

<p>Runs the interactive shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linpkApp(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linpkApp_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>shiny::runApp()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Called for its side effects.
</p>


<h3>Note</h3>

<p>The app requires the following packages:
</p>

<ul>
<li><p> 'shiny'
</p>
</li>
<li><p> 'shinyjs'
</p>
</li>
<li><p> 'shinyAce'
</p>
</li>
<li><p> 'dygraphs'
</p>
</li></ul>

<p>Make they are installed or the app won't work.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
linpkApp()

## End(Not run)
</code></pre>

<hr>
<h2 id='LTmat'>Construct a symmetric matrix from its lower triangle.</h2><span id='topic+LTmat'></span>

<h3>Description</h3>

<p>Construct a symmetric matrix from its lower triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LTmat(LT, .names = attr(LT, ".names"), .colnames = .names, .rownames = .names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LTmat_+3A_lt">LT</code></td>
<td>
<p>A numeric vector giving the elements of the lower triangle of the
matrix by row (see examples).</p>
</td></tr>
<tr><td><code id="LTmat_+3A_.names">.names</code>, <code id="LTmat_+3A_.colnames">.colnames</code>, <code id="LTmat_+3A_.rownames">.rownames</code></td>
<td>
<p>Optionally, specify row and column names of the resulting matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A symmetric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LTmat(1:6)
</code></pre>

<hr>
<h2 id='pkprofile'>Generate a concentration-time profile.</h2><span id='topic+pkprofile'></span><span id='topic+pkprofile.default'></span><span id='topic+pkprofile.matrix'></span>

<h3>Description</h3>

<p>This function generates concentration-time profiles from a linear
pharmacokinetic (PK) system, possibly with first-order absorption or
zero-order infusion, possibly with one or more peripheral compartments, and
possibly under steady-state conditions. Single or multiple doses may be
specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pkprofile(...)

## Default S3 method:
pkprofile(
  t.obs = seq(0, 24, 0.1),
  cl = 1,
  vc = 5,
  q = numeric(0),
  vp = numeric(0),
  ka = 0,
  dose = list(t.dose = 0, amt = 1, rate = 0, dur = 0, ii = 24, addl = 0, ss = 0, cmt = 0,
    lag = 0, f = 1),
  sc = vc,
  initstate = NULL,
  ...
)

## S3 method for class 'matrix'
pkprofile(
  A,
  t.obs = seq(0, 24, 0.1),
  dose = list(t.dose = 0, amt = 1, rate = 0, dur = 0, ii = 24, addl = 0, ss = 0, cmt = 0,
    lag = 0, f = 1),
  defdose = 1,
  sc = 1,
  initstate = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkprofile_+3A_...">...</code></td>
<td>
<p>Further arguments passed along to other methods.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_t.obs">t.obs</code></td>
<td>
<p>A numeric vector of times at which to observe concentrations.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_cl">cl</code></td>
<td>
<p>Central clearance parameter.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_vc">vc</code></td>
<td>
<p>Central volume parameter.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_q">q</code></td>
<td>
<p>Inter-compartmental clearance. Can be a vector for more than one
peripheral compartment, or empty for none. Must match <code>vp</code> in length.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_vp">vp</code></td>
<td>
<p>Peripheral volume. Can be a vector for more than one
peripheral compartment, or empty for none. Must match <code>q</code> in length.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_ka">ka</code></td>
<td>
<p>First-order absorption rate parameter. Set to 0 to indicate
that there is no first-order absorption (i.e. bolus or infusion).</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_dose">dose</code></td>
<td>
<p>A <code>list</code> or <code>data.frame</code> containing dose information.
May contain the following elements:
</p>

<dl>
<dt><code>t.dose</code></dt><dd><p>Dose time (default 0).</p>
</dd>
<dt><code>amt</code></dt><dd><p>Dose amount (default 1).</p>
</dd>
<dt><code>rate</code></dt><dd><p>Rate of zero-order infusion, or 0 to ignore (default 0).
Only one of <code>rate</code> and <code>dur</code> should be specified unless <code>amt</code> is missing.</p>
</dd>
<dt><code>dur</code></dt><dd><p>Duration of zero-order infusion, or 0 to ignore (default 0).
Only one of <code>rate</code> and <code>dur</code> should be specified unless <code>amt</code> is missing.</p>
</dd>
<dt><code>ii</code></dt><dd><p>Interdose interval (default 24). Only used if addl or ss are used.</p>
</dd>
<dt><code>addl</code></dt><dd><p>Number of <em>additional</em> doses (default 0). The
total number of doses given is <code>addl + 1</code>.</p>
</dd>
<dt><code>ss</code></dt><dd><p>Indicates that a dose is given under steady-state
conditions (default 0 or FALSE; converted to <code>logical</code> internally).</p>
</dd>
<dt><code>cmt</code></dt><dd><p>The number of the compartment into which the dose is
administered. The default value is 0, which indicates the depot
compartment for first-order absorption (i.e. <code>ka &gt; 0</code>), and central
compartment otherwise.</p>
</dd>
<dt><code>lag</code></dt><dd><p>Time lag (default 0).</p>
</dd>
<dt><code>f</code></dt><dd><p>Bioavailable fraction (default 1).</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="pkprofile_+3A_sc">sc</code></td>
<td>
<p>A scaling constant for the central compartment. Concentrations are
obtained by dividing amounts by this constant.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_initstate">initstate</code></td>
<td>
<p>A numeric vector containing values to initialize the
compartments.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_a">A</code></td>
<td>
<p>A matrix of first-order rate constants between the compartments.</p>
</td></tr>
<tr><td><code id="pkprofile_+3A_defdose">defdose</code></td>
<td>
<p>The default dose compartment when the compartment is
missing or 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pkprofile&quot;, which is simply a numeric vector of
concentration values with some attributes attached to it.
This object has its own methods for <code>print</code>, <code>plot</code>, <code>lines</code> and <code>points</code>.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>pkprofile(default)</code>: Default method.
</p>
</li>
<li> <p><code>pkprofile(matrix)</code>: Matrix method.
</p>
</li></ul>


<h3>Warning</h3>

<p>Pay attention to the default arguments. They are there for convenience, but
may lead to undesired results if one is not careful.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+halflife">halflife</a></code>
</p>
</li>
<li> <p><code><a href="#topic+secondary">secondary</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.pkprofile">print.pkprofile</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.pkprofile">plot.pkprofile</a></code>
</p>
</li>
<li> <p><code><a href="#topic+lines.pkprofile">lines.pkprofile</a></code>
</p>
</li>
<li> <p><code><a href="#topic+points.pkprofile">points.pkprofile</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Default values, a bolus injection
y &lt;- pkprofile()
plot(y)

t.obs &lt;- seq(0, 24, 0.1)
dur &lt;- 1
amt &lt;- 1
ka &lt;- 1
cl &lt;- 0.25
vc &lt;- 5
q &lt;- 2.5
vp &lt;- 10

# One-compartment model with first-order absorption, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, ka=ka, dose=list(amt=amt))
plot(y)

# Two-compartment model with first-order absorption, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, vp=vp, q=q, ka=ka, dose=list(amt=amt))
plot(y)

# One-compartment model with zero-order infusion, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, dose=list(dur=dur, amt=amt))
plot(y)

# Two-compartment model with zero-order infusion, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, vp=vp, q=q, dose=list(dur=dur, amt=amt))
plot(y)

# Two-compartment model with bolus injection, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, vp=vp, q=q, dose=list(amt=amt))
plot(y)

# Two-compartment model with bolus injection into the peripheral compartment, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, vp=vp, q=q, dose=list(amt=amt, cmt=2))
plot(y)

# Two-compartment model with zero-order infusion into the peripheral compartment, single dose
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, vp=vp, q=q, dose=list(amt=amt, cmt=2, dur=dur))
plot(y)

t.obs &lt;- seq(0, 24*6, 1)

# One-compartment model with first-order absorption, multiple doses
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, ka=ka, dose=list(t.dose=seq(0, 24*5, 12), amt=amt))
plot(y)

# One-compartment model with first-order absorption, multiple doses specified by addl and ii
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, ka=ka, dose=list(t.dose=0, amt=amt, addl=9, ii=12))
plot(y, type="b")
points(y, col="blue")

# One-compartment model with first-order absorption, multiple doses under steady-state conditions
yss &lt;- pkprofile(t.obs, cl=cl, vc=vc, ka=ka, dose=list(t.dose=0, amt=amt, addl=9, ii=12, ss=1))
lines(yss, col="red")
points(yss, col="green")

# One-compartment model with zero-order infusion, multiple doses specified by addl and ii
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, dose=list(dur=dur, amt=amt, addl=9, ii=12))
plot(y, log="y")

# One-compartment model with zero-order infusion, multiple doses  under steady-state conditions
yss &lt;- pkprofile(t.obs, cl=cl, vc=vc, dose=list(dur=dur, amt=amt, addl=9, ii=12, ss=1))
lines(yss, col="red")

</code></pre>

<hr>
<h2 id='pkprofile-methods'>Printing and plotting methods for class <code>pkprofile</code>.</h2><span id='topic+pkprofile-methods'></span><span id='topic+print.pkprofile'></span><span id='topic+plot.pkprofile'></span><span id='topic+lines.pkprofile'></span><span id='topic+points.pkprofile'></span>

<h3>Description</h3>

<p>Printing and plotting methods for class <code>pkprofile</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkprofile'
print(x, ...)

## S3 method for class 'pkprofile'
plot(x, y, ...)

## S3 method for class 'pkprofile'
lines(x, y, ...)

## S3 method for class 'pkprofile'
points(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkprofile-methods_+3A_x">x</code></td>
<td>
<p>An object of class <code>pkprofile</code>.</p>
</td></tr>
<tr><td><code id="pkprofile-methods_+3A_y">y</code></td>
<td>
<p>Any other object. Specifying <code>y</code> causes the default method to
be called instead (effectively overriding the class-specific behaviour).</p>
</td></tr>
</table>

<hr>
<h2 id='pkprofile.pkprofile'>Continue an existing concentration-time profile.</h2><span id='topic+pkprofile.pkprofile'></span>

<h3>Description</h3>

<p>This method can be used to append to an existing PK profile, for instance to
simulate a PK profile with parameters that change over time. Each time the
parameters change, a new call to this method is used to advance the system
with the new parameter values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pkprofile'
pkprofile(obj, t.obs = finaltime(obj) + seq(0, 24, 0.1), ..., append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pkprofile.pkprofile_+3A_obj">obj</code></td>
<td>
<p>An object returned from a previous call to <code><a href="#topic+pkprofile">pkprofile</a></code>.</p>
</td></tr>
<tr><td><code id="pkprofile.pkprofile_+3A_t.obs">t.obs</code></td>
<td>
<p>A numeric vector of times at which to observe concentrations.</p>
</td></tr>
<tr><td><code id="pkprofile.pkprofile_+3A_...">...</code></td>
<td>
<p>Further arguments passed along.</p>
</td></tr>
<tr><td><code id="pkprofile.pkprofile_+3A_append">append</code></td>
<td>
<p>Should the new profile be appended to the current samples?
Otherwise, only the new samples are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;pkprofile&quot;.
</p>


<h3>Warning</h3>

<p>The new parameters take effect at the time when the previous profile ends.
If the previous profile ends before the new sampling starts, the <em>new</em>
parameters will be used to advance the system to the start of the new
sampling.
</p>
<p>Any ongoing zero-order infusion at the end of the previous profile is
dropped. The remaining infusion amount will NOT be carried forward.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pkprofile">pkprofile</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t.obs &lt;- seq(0, 24, 0.1)
amt &lt;- 1
ka &lt;- 1
cl &lt;- 0.25
vc &lt;- 5

# One-compartment model with first-order absorption
# First dose at time 0
y &lt;- pkprofile(t.obs, cl=cl, vc=vc, ka=ka, dose=list(t.dose=0, amt=amt))

# Second dose at 24h with a lower clearance
y &lt;- pkprofile(y, t.obs+24, cl=0.5*cl, vc=vc, ka=ka, dose=list(t.dose=24, amt=amt))

# Third dose at 48h with a higher clearance
y &lt;- pkprofile(y, t.obs+48, cl=2*cl, vc=vc, ka=ka, dose=list(t.dose=48, amt=amt))
plot(y)

</code></pre>

<hr>
<h2 id='secondary'>Derive secondary PK parameters.</h2><span id='topic+secondary'></span>

<h3>Description</h3>

<p>Derive secondary PK parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>secondary(x, From = NULL, To = NULL, include.dose.times = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="secondary_+3A_x">x</code></td>
<td>
<p>A object of class <code><a href="#topic+pkprofile">pkprofile</a></code>.</p>
</td></tr>
<tr><td><code id="secondary_+3A_from">From</code></td>
<td>
<p>A vector of interval start times. The defaults is the times of the doses.</p>
</td></tr>
<tr><td><code id="secondary_+3A_to">To</code></td>
<td>
<p>A vector of interval end times. The defaults is the time of the next dose,
or last observation time.</p>
</td></tr>
<tr><td><code id="secondary_+3A_include.dose.times">include.dose.times</code></td>
<td>
<p>Should dose times (and end of infusion times) be
considered in addition to the simulation times?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with one row for each time interval and with the
following columns:
</p>

<dl>
<dt><code>From</code></dt><dd><p>The time of the start of the interval. Can differ from
the specified start time because it always corresponds to an actual data
point.</p>
</dd>
<dt><code>To</code></dt><dd><p>The time of the end of the interval. Can differ from the
specified end time because it always corresponds to an actual data point.</p>
</dd>
<dt><code>N</code></dt><dd><p>The number of distinct data points in the interval used to
derive <code>AUC</code>, <code>Cmax</code>, etc.</p>
</dd>
<dt><code>Ctrough</code></dt><dd><p>Concentration at the time of dose (i.e. just prior
to the dose). Only present if the start of the interval corresponds to a
dose time.</p>
</dd>
<dt><code>Cmin</code></dt><dd><p>Minimum concentration over the interval.</p>
</dd>
<dt><code>Tmin</code></dt><dd><p>Time of the minimum concentration over the interval.</p>
</dd>
<dt><code>Cmax</code></dt><dd><p>Maximum concentration over the interval.</p>
</dd>
<dt><code>Tmax</code></dt><dd><p>Time of the maximum concentration over the interval.</p>
</dd>
<dt><code>Cave</code></dt><dd><p>Average concentration over the interval (calculated by
the trapezoid rule).</p>
</dd>
<dt><code>AUC</code></dt><dd><p>Area under the concentration-time curve over the
interval (calculated by the trapezoid rule).</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>t.obs &lt;- seq(0, 24*4, 0.1)
y &lt;- pkprofile(t.obs, cl=0.25, vc=5, ka=1, dose=list(t.dose=0, amt=1, addl=6, ii=12))
secondary(y)
secondary(y, 0, 48)
secondary(y, 0, Inf)
sum(secondary(y)$AUC)  # Same as above
plot(y)
with(secondary(y), points(Tmax, Cmax, pch=19, col="blue"))
with(secondary(y), points(Tmin, Cmin, pch=19, col="red"))
with(secondary(y), points(From, Ctrough, pch=19, col="green"))
with(secondary(y), points(From + 6, Cave, pch=19, col="purple", cex=2))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
