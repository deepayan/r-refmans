<!DOCTYPE html><html lang="en"><head><title>Help for package plothelper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {plothelper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABCxy'><p>Symmetrical Transformation</p></a></li>
<li><a href='#add_slash_n'><p>Adding Slash_n inside Strings</p></a></li>
<li><a href='#annotation_shading_polygon'><p>Layer for Drawing a Single</p>
Irregular Polygon
with Shading Colors</a></li>
<li><a href='#annotation_transparent_text'><p>Layer for Transparent Text</p></a></li>
<li><a href='#ANYxy'><p>Generating Groups of Coordinates for Any Polygon</p></a></li>
<li><a href='#count_each_column'><p>Counting Each Column and Summarizing in a Matrix</p></a></li>
<li><a href='#ellipsexy'><p>Generating Coordinates of Multiple Ellipses or Circles</p></a></li>
<li><a href='#enlarge_raster'><p>Enlarge a Color Matrix</p></a></li>
<li><a href='#geom_circle_cm'><p>Geom Layer for Circle with Absolute Size</p></a></li>
<li><a href='#geom_ellipse_cm'><p>Geom Layer for Ellipse with Absolute Size</p></a></li>
<li><a href='#geom_multi_raster'><p>Geom Layer for Drawing Multiple Rasters</p></a></li>
<li><a href='#geom_rect_cm'><p>Geom Layer for Rectangle with Absolute Size</p></a></li>
<li><a href='#geom_shading_bar'><p>Geom Layer for Drawing Shading Barplot</p></a></li>
<li><a href='#get_click_color'><p>Obtaining the Colors of Positions Clicked</p></a></li>
<li><a href='#get_gg_label'><p>Checking Min, Max, Labels and Label Positions</p></a></li>
<li><a href='#gg_shading_bar'><p>Drawing Barplot with Shading Colors</p></a></li>
<li><a href='#image_col_numeric'><p>Colorize an Image according to Gray Scale</p></a></li>
<li><a href='#image_crop_click'><p>Cut out a Subregion of an Image by Mouse Click</p></a></li>
<li><a href='#image_keep_color'><p>Keep Some Colors Unchanged and Make</p>
Others into Grayscale</a></li>
<li><a href='#image_locator'><p>Get the Width and Height of the</p>
Mouse Clicked Points</a></li>
<li><a href='#image_modify_hsv'><p>Modify the H, S, V Values of a</p>
Color Vector or an Image</a></li>
<li><a href='#image_modify_local'><p>Modify Only a Subregion of an Image</p></a></li>
<li><a href='#image_modify_local2'><p>Modify both a Subregion  and the Whole</p>
of an Image</a></li>
<li><a href='#image_modify_rgb'><p>Modify R, G, B Values of an Image</p></a></li>
<li><a href='#image_modify_rgb_v'><p>Modify R, G, B Values according to</p>
V values</a></li>
<li><a href='#image_transparent_inverse'><p>Keep Certain Colors Unchanged</p>
and Make Others Transparent</a></li>
<li><a href='#raster_alpha'><p>Combine a Matrix of Colors and</p>
a Matrix of Alpha Values</a></li>
<li><a href='#rectxy'><p>Generating Coordinates of Multiple Rectangles</p></a></li>
<li><a href='#resize_to_standard'><p>Resize an Image According to the Other Image or to Ratios</p></a></li>
<li><a href='#rotatexy'><p>Rotation Transformation</p></a></li>
<li><a href='#round_text'><p>Converting Numeric Values into Characters with the Same Digits</p></a></li>
<li><a href='#scale_free'><p>Scale values into a Certain Location</p></a></li>
<li><a href='#shading_raster'><p>Create a Shading Raster with a Palette</p></a></li>
<li><a href='#showcolor'><p>Show a Color Palette</p></a></li>
<li><a href='#spathxy'><p>Reordering Points to Form a &quot;s&quot; Shape</p></a></li>
<li><a href='#stretchxy'><p>Stretching Transformation</p></a></li>
<li><a href='#sunshinexy'><p>Generating Lines Which Link One Points to Many</p></a></li>
<li><a href='#textgif'><p>Simple Text &quot;.gif&quot; File</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>New Plots Based on 'ggplot2' and Functions to Create Regular
Shapes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-05-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiang Wu &lt;textidea@sina.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>An extension to 'ggplot2' and 'magick'. It contains 
    three groups of functions: Functions in the first group draw 'ggplot2' - based plots: geom_shading_bar() draws barplot 
	with shading colors in each bar. geom_rect_cm(), geom_circle_cm() and geom_ellipse_cm() draw rectangles, circles 
	and ellipses with centimeter as their unit. Thus their sizes do not change when the coordinate system or the aspect ratio 
	changes. annotation_transparent_text() draws labels with transparent texts. annotation_shading_polygon() draws irregular 
	polygons with shading colors. Functions in the second group generate coordinates for regular shapes and make linear transformations. Functions in the third group are 'magick' - based functions facilitating image processing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/githubwwwjjj/plothelper/blob/master/README.md">https://github.com/githubwwwjjj/plothelper/blob/master/README.md</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), ggplot2 (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, ggfittext (&ge; 0.8.1), magick, grid, gridExtra, scales,
farver</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>true</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-05-07 18:00:37 UTC; useruser</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiang Wu [aut, cre] (from Capital Normal University)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-08 08:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABCxy'>Symmetrical Transformation</h2><span id='topic+ABCxy'></span>

<h3>Description</h3>

<p>A1 and A2 are symmetrical on the two sides of 
Ax+By+C=0. The input of the function is A1, and 
the result is A2. The function also works when the 
line is horizontal or vertical.
Note: the two shapes are symmetrical 
only when <code>ggplot2::coord_fixed()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ABCxy(
  x,
  A,
  B,
  C,
  p1 = NULL,
  p2 = NULL,
  f = NULL,
  group = TRUE,
  todf = TRUE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ABCxy_+3A_x">x</code></td>
<td>
<p>the input. It can be a data frame, matrix, tibble object, 
or a list of 
these kinds of objects. Each object must have exactly 2 columns 
and must be numeric without NA.
If it has more than 2 columns, only the first 2 columns 
will be used.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_a">A</code></td>
<td>
<p>for Ax+By+C=0.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_b">B</code></td>
<td>
<p>for Ax+By+C=0.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_c">C</code></td>
<td>
<p>for Ax+By+C=0.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_p1">p1</code></td>
<td>
<p>if A, B, C are not given, you can also give two points 
p1 and p2 on the supposed Ax+By+C=0 line. Note: if A, B, C, p1, 
p2 are all given, the given A, B, C will be ignored. It must be 
a vector of length 2. The first element is x and the second is y.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_p2">p2</code></td>
<td>
<p>see <code>p1</code>.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_f">f</code></td>
<td>
<p>argument passed to <code>split</code> to divide a data frame 
into a list of data frames. It should be a vector whose length is 
equal to the number of rows of x (if x is a data frame).</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_group">group</code></td>
<td>
<p>default is TRUE. It indicates 
whether to add a 3rd column named 
&quot;g&quot; to label the group number of each group of points. It is useful 
when using <code>aes(...group=g)</code> with 'ggplot2'.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE. It indicates whether to 
combine the output (a list) into a data frame.</p>
</td></tr>
<tr><td><code id="ABCxy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>todf = TRUE</code>, the output will be a data frame
with coordinates of possibly several polygons, otherwise, 
it will be a list of data frames. Data frames have 2 columns
named &quot;x&quot; and &quot;y&quot;, and if <code>group = TRUE</code>, a third column 
named &quot;g&quot; is added indicating group numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat1=data.frame(x=c(0, 2, 2, 0), y=c(0, 0, 1, 1))
dat2=ABCxy(dat1, -1, -1, 3)
ggplot()+
	coord_fixed()+
	geom_polygon(data=dat1, aes(x=x, y=y), fill="red")+
	geom_polygon(data=dat2, aes(x=x, y=y), fill="blue")+
	geom_abline(intercept=3, slope=-1)		
dat3=ABCxy(dat1, p1=c(0, 1), p2=c(-0.5, 0), todf=TRUE)
ggplot()+
	coord_fixed()+
	geom_polygon(data=dat1, aes(x=x, y=y), fill="red")+
	geom_polygon(data=dat3, aes(x=x, y=y), fill="blue")+
	geom_abline(intercept=1, slope=2)
</code></pre>

<hr>
<h2 id='add_slash_n'>Adding Slash_n inside Strings</h2><span id='topic+add_slash_n'></span>

<h3>Description</h3>

<p>This function simply adds change-line
signs inside strings, so 
that they can be put vertically as the texts 
of x-axis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_slash_n(x, delete_space = TRUE, vertical_line = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_slash_n_+3A_x">x</code></td>
<td>
<p>a character vector</p>
</td></tr>
<tr><td><code id="add_slash_n_+3A_delete_space">delete_space</code></td>
<td>
<p>whether to delete spaces.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="add_slash_n_+3A_vertical_line">vertical_line</code></td>
<td>
<p>whether to 
change <code>-</code> into <code>|</code>. 
Default is TRUE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lab=add_slash_n(c("a b-c", "d - ef ", "n"))
</code></pre>

<hr>
<h2 id='annotation_shading_polygon'>Layer for Drawing a Single 
Irregular Polygon 
with Shading Colors</h2><span id='topic+annotation_shading_polygon'></span>

<h3>Description</h3>

<p><code>ggplot2::annotation_raster</code> can only 
draw shading rectangles. However, this 
function can draw polygons of any shape 
with shading colors. See the <code>shape</code> 
argument and the <code>raster</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_shading_polygon(
  shape = data.frame(c(-1, 1, 0), c(0, 0, 1.732)),
  xmin = NULL,
  xmax = NULL,
  ymin = NULL,
  ymax = NULL,
  raster = NULL,
  interpolate = TRUE,
  result_interpolate = TRUE,
  shape_trim = NULL,
  raster_trim = NULL,
  result_trim = NULL,
  result = c("layer", "magick"),
  width = 800,
  height = NULL,
  res = 72
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotation_shading_polygon_+3A_shape">shape</code></td>
<td>
<p>the polygon can be 
a data frame (or matrix object, or tbl_df object) 
with x and y coordinates (that is, with two columns), 
a plot created by ggplot or an image 
read into R by <code>magick::image_read</code>.
If it is a plot created by ggplot, its axes can 
be of numeric, discrete or date/datetime type; 
however, when the type is date/datetime, 
the plot should not use <code>ggplot2::coord_fixed</code>.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_xmin">xmin</code></td>
<td>
<p>the left side of the position to 
put the polygon. When 
<code>shape</code> is something like a data frame, 
you do not need to set xmin, xmax, ymin and ymax, 
for the function will generate these values according 
to the coordinates in the polygon.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_xmax">xmax</code></td>
<td>
<p>the right side.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_ymin">ymin</code></td>
<td>
<p>the bottom side.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_ymax">ymax</code></td>
<td>
<p>the top side.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_raster">raster</code></td>
<td>
<p>the shading colors. 
It can be a raster object, 
a matrix of colors, a ggplot plot or an 
image read into R by 
<code>magick::image_read</code>.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_interpolate">interpolate</code></td>
<td>
<p>the <code>interpolate</code>
argument used by <code>ggplot2::annotation_raster</code>
when the <code>raster</code> argument is a matrix or 
raster.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_result_interpolate">result_interpolate</code></td>
<td>
<p>whether to interpolate in the 
final result which is essentially an output of 
<code>ggplot2::annotation_raster</code>. Default is TRUE.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_shape_trim">shape_trim</code></td>
<td>
<p>this argument 
decides whether to trim edges 
of <code>shape</code>.
It should be a number 
between 0 and 100. Default is NULL. If it is NULL, 
no trimming will be done.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_raster_trim">raster_trim</code></td>
<td>
<p>whether to trim raster. 
Most of the time we do want to trim the raster.
However, the <code>magick::image_trim</code> function 
sometimes trims wrongly. So you may want to turn 
it off. Default is NULL.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_result_trim">result_trim</code></td>
<td>
<p>how to trim the 
final result. If you find your 
figure loses some parts, you can try to turn this off. 
Default is NULL.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_result">result</code></td>
<td>
<p>when it is &quot;layer&quot;, the function is a
ggplot layer. When it is &quot;magick&quot;, the function only 
create an image.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_width">width</code></td>
<td>
<p>the width which will be passed 
to <code>magick::image_graph</code>. Most of the time you do 
not need to modify this. Default is 800. HOWEVER, if the 
final polygon has fuzzy edges, try to enlarge <code>width</code> 
to make them look better.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_height">height</code></td>
<td>
<p>the height which will be passed 
to <code>magick::image_graph</code>. DO SEE Details below 
to see how to use this parameter.</p>
</td></tr>
<tr><td><code id="annotation_shading_polygon_+3A_res">res</code></td>
<td>
<p>resolution in pixels which will be passed to 
<code>magick::image_graph</code>. Default is 72.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>height</code> can be used in the 
following ways: 
</p>

<ul>
<li><p> (1) an integer which will be 
directly passed to <code>image::graph</code>.
</p>
</li>
<li><p> (2) a character-like integer, 
e.g., <code>height = "0.5"</code>. Suppose <code>width = 400</code>, 
the height that will be used is 400*0.5 = 200. 
This effectively prevents the image from becoming 
too large.
</p>
</li>
<li><p> (3) <code>height = "coord_fixed"</code>. 
the ratio between height and width will 
be (top-bottom)/(right-left). And top, bottom,  
right and left are extreme values of <code>shape</code> 
when the latter is of class data.frame/matrix/gg.
</p>
</li>
<li><p> (4) <code>height = "image"</code>. the width and height 
will be the width and height of raster when raster is 
a magick object.
</p>
</li>
<li><p> (5) <code>height = NULL</code>, the default. 
Now height is computed automatically. 
A ratio is computed first,  
ratio = (top-bottom)/(right-left). if the ratio is larger 
than 5 or smaller than 0.2, then height will be 
width*5 or width*0.2; else, the height will be treated 
in the same way as in (3) above. If <code>shape</code> is 
of class gg and it has uses <code>coord_flip()</code>, the 
height will be automatically adjusted. All these works 
are needed to prevent the image from becoming too large.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
poly=ellipsexy(-1, 0, a=1, b=1)
m=matrix(rainbow(7))
ggplot()+
	coord_fixed()+
	annotation_shading_polygon(
		poly, raster=m
	)+
	annotation_shading_polygon(
		poly, raster=m, 
		xmin=1, xmax=5, 
		ymin=-1, ymax=1, 
	)
#
# Example 2, only an image
tt=annotation_shading_polygon(
	poly, result="magick", 
	width=280, height=280
)
#
# Example 3, both shape and raster are 
# ggplot plots.
p1=ggplot()+geom_tile(aes(x=1: 5, y=1: 5))
p2=ggplot()+geom_polygon(aes(x=c(0, 1, 1, 0), 
		y=c(0, 0, 1, 1)), fill="red")+theme_void()
ggplot()+coord_fixed()+
	annotation_shading_polygon(
		shape=p1, 
		xmin=1, xmax=10, 
		ymin=1, ymax=5, 
		raster=p2
	)

</code></pre>

<hr>
<h2 id='annotation_transparent_text'>Layer for Transparent Text</h2><span id='topic+annotation_transparent_text'></span>

<h3>Description</h3>

<p>Suppose there is a colored rectangle
with some texts and 
you want the texts to be transparent so that 
the colors of the background can be seen. Now 
you can use this function. The function 
can be used as a ggplot layer or a generator 
of image. NOTE: when the function is 
used as a layer, it uses 
<code>ggplot2::annotation_raster</code> to 
do the drawing, so you must 
set limits for the x axis and the y axis. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotation_transparent_text(
  label,
  xmin,
  xmax,
  ymin,
  ymax,
  bg = "black",
  alpha = 0.5,
  operator = "out",
  interpolate = TRUE,
  result_interpolate = TRUE,
  expand = c(0.05, 0.05),
  family = "SimHei",
  fontface = 1,
  reflow = FALSE,
  place = "center",
  label_trim = NULL,
  bg_trim = NULL,
  result = c("layer", "magick"),
  width = 800,
  height = NULL,
  res = 72,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="annotation_transparent_text_+3A_label">label</code></td>
<td>
<p>the text.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_xmin">xmin</code></td>
<td>
<p>the left side of the rectangle.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_xmax">xmax</code></td>
<td>
<p>the right side of the rectangle.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_ymin">ymin</code></td>
<td>
<p>the bottom side of the rectangle.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_ymax">ymax</code></td>
<td>
<p>the top side of the rectangle.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_bg">bg</code></td>
<td>
<p>the colors of the rectangle. It can be 
a character vector of colors, a matrix of colors, 
an object of raster class or even a image 
read into R through <code>magick::image_read</code>.
Default is color black.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_alpha">alpha</code></td>
<td>
<p>it is only used 
when <code>bg</code> is a character 
vector. Default is 0.5.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_operator">operator</code></td>
<td>
<p>the argument used by 
<code>magick::image_composite</code>. It should be 
&quot;out&quot; (default) or &quot;in&quot;. The former makes the texts 
transparent, the latter creates shading texts.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_interpolate">interpolate</code></td>
<td>
<p>when <code>bg</code> is 
a matrix, a image or 
a raster, this parameter is used and 
will be passed to <code>ggplot2::annotation_raster</code> 
to draw a colored rectangle. Default is TRUE.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_result_interpolate">result_interpolate</code></td>
<td>
<p>whether to use interpolate 
in the final result. Default is TRUE.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_expand">expand</code></td>
<td>
<p>sometimes 
it is needed to slightly expand the x position and 
y position to put the text so that they can be 
shown nicely. 
It should be two values used by x and y
respectively. Default is 0.05 and 0.05.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_family">family</code></td>
<td>
<p>family of text. Default is SimHei 
which ensures that Chinese texts can be shown.
However, you can change it to others, 
e. g., sans, serif, mono.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_fontface">fontface</code></td>
<td>
<p>fontface.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_reflow">reflow</code></td>
<td>
<p>whether to change lines 
automatically. It will be passed to 
<code>ggfittext::geom_fit_text</code>. Default is FALSE.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_place">place</code></td>
<td>
<p>position adjustment used by 
<code>ggfittext:;geom_fit_text</code>.
The value is one of &quot;center&quot;, &quot;middle&quot; (= &quot;center&quot;), 
&quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot;, &quot;bottomright&quot;, 
&quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_label_trim">label_trim</code></td>
<td>
<p>whether to trim <code>label</code>. 
The default is NULL which means no trimming. 
But if you want to remove all edges around label, 
you should give <code>label_trim</code> a value which will 
be passed to <code>magick::image_trim</code>. However, 
most of the time you do not need this parameter.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_bg_trim">bg_trim</code></td>
<td>
<p>whether to trim <code>bg</code>. Most 
of the time we do want to trim it. However, the 
<code>magick::image_trim</code> function sometimes 
trims wrongly. So you can turn it off. NOTE: the default 
value of <code>bg_trim</code> is NULL, which means 
DO NOT TRIM.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_result">result</code></td>
<td>
<p>when it is &quot;layer&quot;, the function can be 
used as a ggplot layer. When it is &quot;magick&quot;, the result 
is only an image which is created by the magick package.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_width">width</code></td>
<td>
<p>the width of 
the text rectangle. It will be passed 
to <code>magick::image_graph</code>. Most of the time you do 
not need to modify this. Default is 800.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_height">height</code></td>
<td>
<p>the height of the 
text rectangle. It will be passed 
to <code>magick::image_graph</code>. 
Default is NULL, which means 
it will be computed automatically. DO SEE Details below 
to learn how to handle this parameter.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_res">res</code></td>
<td>
<p>resolution in pixels which will be passed 
to <code>magick::image_graph</code>. Default is 72.</p>
</td></tr>
<tr><td><code id="annotation_transparent_text_+3A_...">...</code></td>
<td>
<p>arguments which will be passed to 
<code>ggfittex::geom_fit_text</code>. Most often used are 
<code>angle</code> (0 to 360), <code>lineheight</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>height</code> can be used in the 
following ways: 
</p>

<ul>
<li><p> (1) an integer which will be 
directly passed to <code>magick::image_graph</code>.
</p>
</li>
<li><p> (2) a character-like integer, 
e.g., <code>height = "0.5"</code>. Suppose <code>width = 400</code>, 
the height that will be used is 400*0.5 = 200. 
This effectively prevents the image from becoming 
too large.
</p>
</li>
<li><p> (3) <code>height = "coord_fixed"</code>. 
the ratio between height and width will 
be (ymax-ymin)/(xmax-xmin).
</p>
</li>
<li><p> (4) <code>height = "image"</code>. the width and height 
will be the width and height of <code>bg</code> when 
the latter is a magick object.
</p>
</li>
<li><p> (5) <code>height = NULL</code>, the default. 
Now height is computed automatically. 
If <code>bg</code> is a magick object, the width 
and height of the image will be used. 
If <code>bg</code> is not a magick object, 
a ratio is computed first,  
ratio = (ymax-ymin)/(xmax-xmin). if the ratio is larger 
than 5 or smaller than 0.2, then height will be 
width*5 or width*0.2; else, the height will be treated 
in the same way as in (3) above. All these works 
are needed to prevent the image from becoming too large.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1
m=matrix(rainbow(7), nrow=1)
ggplot()+coord_fixed()+
	xlim(0, 7)+ylim(-2, 4)+theme_void()+
	annotation_raster(
		raster=m, 
		xmin=0, ymin=-3, 
		xmax=7, ymax=5, 
		interpolate=TRUE
	)+
	annotation_transparent_text(
		label="R\nDATA\nVISUALIZATION", 
		xmin=0, xmax=7, 
		ymin=-1, ymax=3, 
		family="sans", fontface=2, alpha=0.8, 
		place="left", expand=c(0.08, 0.02)
	)
# 
# Example 2, this time the result is only an image.
tt=annotation_transparent_text(
	label="abcdefg", 
	xmin=1, xmax=8, 
	ymin=1, ymax=4, 
	alpha=0.6, 
	result="magick"
)
#
# Example 3, the rectangle is a matrix.
m=colorRampPalette(c("yellow", "purple"))(10)
ggplot()+coord_fixed(expand=FALSE)+
	theme(panel.background=element_rect(fill="red"))+
	annotation_transparent_text(
		label="hehehaha", 
		xmin=1, xmax=8, 
		ymin=1, ymax=4, 
		bg=m, alpha=1
	)
#
# Example 4, height is too large.
# Now you should explicitly set 
# width and height, otherwise, the 
# characters will become too flat.
x=c(0, 5, 10)
y=c(0, 500, 1000)
ggplot()+ylim(0, 4000)+
	geom_point(aes(x, y))+
	annotation_transparent_text(label="ha ha\nhe he", 
		xmin=0, xmax=10, ymin=1000, ymax=4000, bg="black", 
		width=300, height=150
	) # do not set height=NULL here

</code></pre>

<hr>
<h2 id='ANYxy'>Generating Groups of Coordinates for Any Polygon</h2><span id='topic+ANYxy'></span>

<h3>Description</h3>

<p>Given your function to create a multiple of
points (for example, points to form a polygon), this 
function generates x and y coordinates for 
groups of points of the same type with different parameters.
The output of this function can be shown by 
<code>ellipsexy</code> and <code>rectxy</code> in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ANYxy(myfun = NULL, ..., MoreArgs = NULL, group = TRUE, todf = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ANYxy_+3A_myfun">myfun</code></td>
<td>
<p>your function to generate a single polygon.
Note: <b>the value of each argument of your function 
must be a single-value vector. And the result of your 
function should be a data frame!</b>. See examples.</p>
</td></tr>
<tr><td><code id="ANYxy_+3A_...">...</code></td>
<td>
<p>named parameters used by your function. These 
parameters will be passed to <code>mapply</code>.</p>
</td></tr>
<tr><td><code id="ANYxy_+3A_moreargs">MoreArgs</code></td>
<td>
<p>this will be passed to the <code>MoreArgs</code> 
argument of <code>mapply</code>.</p>
</td></tr>
<tr><td><code id="ANYxy_+3A_group">group</code></td>
<td>
<p>default is TRUE which means a column 
named &quot;g&quot; will be added to each data frame. This facilitates 
further drawing using <code>aes(..., group = g)</code>.</p>
</td></tr>
<tr><td><code id="ANYxy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE which means to combine the 
result into a data frame. Otherwise, the result is a list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
# First, you need a function to generate
# x and y coordinates for a single group
# of points.
x_square=function(start, end, A, B){
	x=seq(start, end, 0.1)
	data.frame(x=x, y=A*(x^2)+B)
}
# All the arguments of your function 
# (here, start, end, A, B) should only accept
# vectors of length 1. And, the result of 
# your function should be a data frame
# of x and y coordinates 
# (here, coordinates of curves).
dat=ANYxy(myfun=x_square, 
	start=-1, end=1, A=c(1, 2), MoreArgs=list(B=1), 
	group=TRUE, todf=TRUE)
ggplot(dat)+geom_line(aes(x, y, group=g, color=factor(g)))
</code></pre>

<hr>
<h2 id='count_each_column'>Counting Each Column and Summarizing in a Matrix</h2><span id='topic+count_each_column'></span>

<h3>Description</h3>

<p>This function counts the frequencies of each element of each 
column of a data frame or matrix. The frequencies of 
missing values and the 0 frequencies of non-existent 
values are also included in the final result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_each_column(x, answer = NULL, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_each_column_+3A_x">x</code></td>
<td>
<p>a data frame or matrix with at least 1 row and 
1 column. NOTE: all column should belong to the same 
class (numeric, character). 
However, if <code>checks = TRUE</code>, character and 
factor variables can co-exist and logical values are also OK. 
If a column has nothing but 
NA, it should be remove; otherwise, an error will be raised.</p>
</td></tr>
<tr><td><code id="count_each_column_+3A_answer">answer</code></td>
<td>
<p>the values whose frequencies you 
want to know, e. g., &quot;agree&quot; and &quot;disagree&quot; 
in your survey data. Default is NULL which means 
all possible answers in the whole data will be used.</p>
</td></tr>
<tr><td><code id="count_each_column_+3A_checks">checks</code></td>
<td>
<p>whether to check the validity of the 
input data. Default is TRUE. Do not turn it off unless you 
are sure that your data has no logical variables or factor 
variables and each column has at least 1 non-missing value.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># values that do not appear in 
# the data can also be counted.
# a factor will be transformed into
# a character variable automatically.
x1=c("a", "b", "a", "b", NA)
x2=factor(x1)
x3=c("1", "3", "2", "1", "a")
dat=data.frame(x1, x2, x3, stringsAsFactors=FALSE)
res=count_each_column(dat, answer=c("c", "d", NA, "a"))
# logical value is OK.
x1=c(TRUE, TRUE, TRUE)
x2=c(TRUE, NA, NA)
dat=data.frame(x1, x2)
res=count_each_column(dat)
res=count_each_column(dat, c(TRUE, FALSE))
</code></pre>

<hr>
<h2 id='ellipsexy'>Generating Coordinates of Multiple Ellipses or Circles</h2><span id='topic+ellipsexy'></span>

<h3>Description</h3>

<p>If radius a is equal to radius b, then the shape
will be a circle. 
Note: the shapes are correct  
only when <code>ggplot2::coord_fixed()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ellipsexy(
  x = 0,
  y = 0,
  a = 2,
  b = 1,
  start = 0,
  end = 6.283185,
  angle = 0,
  n = 40,
  xytype = "middle",
  fan = FALSE,
  group = TRUE,
  todf = TRUE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ellipsexy_+3A_x">x</code></td>
<td>
<p>the x coordinates of relative points. 
Its length can be larger than 1.
See <code>xytype</code>.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_y">y</code></td>
<td>
<p>the y coordinates of relative points. 
Its length can be larger than 1.
See <code>xytype</code>.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_a">a</code></td>
<td>
<p>the radius that is parallel to 
x-axis before rotation. Its length can be larger than 1.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_b">b</code></td>
<td>
<p>the radius that is parallel to 
y-axis before rotation. Its length can be larger than 1.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_start">start</code></td>
<td>
<p>default is 0. The angle of the starting 
point of the arc. Its length can be larger than 1.
Note: &quot;radian = degree * pi / 180&quot;.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_end">end</code></td>
<td>
<p>default is 6.283185. The angle of the ending 
point of the arc.
Its length can be 
larger than 1.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_angle">angle</code></td>
<td>
<p>default is 0. The rotation angle in radian.
Its length can be larger than 1.
Note: &quot;radian = degree * pi / 180&quot;. 
The rotation direction is anti-clockwise.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_n">n</code></td>
<td>
<p>default is 40. The number of points used to 
draw an arc. The larger, the smoother.
It must at least be 4. However, when <code>checks</code> is 
FALSE, this check is ignored.
NOTE: to draw a triangle, you must use 
<code>ellipsexy(n=4, fan=FALSE)</code>, 
as the first and 4th points are so close. 
Similarly, to draw a rectangle, 
use <code>ellipsexy(n=5, fan=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_xytype">xytype</code></td>
<td>
<p>should be one of &quot;middle/center&quot; (default), 
&quot;bottomleft&quot;, &quot;middleleft/left/centerleft&quot;. 
It indicates the type of argument 
of the middle point of an ellipse. If it is &quot;middleleft&quot;, x and 
y are the middle-left coordinates before rotation. If it is 
&quot;bottomleft&quot;, x and y are the coordinates of the 
bottom-left corner of the rectangle that walls the ellipse.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_fan">fan</code></td>
<td>
<p>default is FALSE. If it is TRUE, the coordinates 
of the middle of an ellipse is added to the output 
data frame. Meanwhile, if, say, you set n = 50, then n 
becomes 49 automatically because the last position is reserved 
for the middle. This helps draw a fan.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_group">group</code></td>
<td>
<p>default is TRUE. It indicates 
whether to add a 3rd column named 
&quot;g&quot; to label the group number of each group of points. It is useful 
when using <code>aes(...group=g)</code> with 'ggplot2'.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE. It indicates whether to 
combine the output (a list) into a data frame.</p>
</td></tr>
<tr><td><code id="ellipsexy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>todf = TRUE</code>, the output will be a data frame
with coordinates of possibly several polygons, otherwise, 
it will be a list of data frames. Data frames have 2 columns
named &quot;x&quot; and &quot;y&quot;, and if <code>group = TRUE</code>, a third column 
named &quot;g&quot; is added indicating group numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat1=ellipsexy(x=1, y=1, 
a=seq(1, 4, length.out=8), angle=seq(0, pi, length.out=8), 
	xytype="middleleft", n=30, todf=TRUE)		
ggplot()+coord_fixed()+
	geom_polygon(show.legend=FALSE, 
		data=dat1, aes(x=x, y=y, group=g, fill=factor(g)), alpha=0.3)
</code></pre>

<hr>
<h2 id='enlarge_raster'>Enlarge a Color Matrix</h2><span id='topic+enlarge_raster'></span>

<h3>Description</h3>

<p>This is a convenient wrapper of 
<code>colorRampPalette</code> to enlarge 
a color matrix or raster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enlarge_raster(x, n = c(10, 10), row_first = TRUE, space = "rgb")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="enlarge_raster_+3A_x">x</code></td>
<td>
<p>a color matrix or raster. It should
have at least 1 row and 1 column with no NAs.</p>
</td></tr>
<tr><td><code id="enlarge_raster_+3A_n">n</code></td>
<td>
<p>a vector with 2 numbers. If it has 1 number, 
the number will be repeated twice. The two numbers 
indicate how many colors you will get in the result per 
row and per column. Default is <code>c(10, 10)</code>.</p>
</td></tr>
<tr><td><code id="enlarge_raster_+3A_row_first">row_first</code></td>
<td>
<p>enlarge rows first or enlarge columns 
first? Default is TRUE. The results are almost the same, 
so you do not need to change this.</p>
</td></tr>
<tr><td><code id="enlarge_raster_+3A_space">space</code></td>
<td>
<p>the <code>space</code> 
parameter used by <code>colorRampPalette</code>. It can be 
&quot;rgb&quot; (default) or &quot;Lab&quot;.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
# the original matrix
m=matrix(c(
	"red", "yellow", "green", 
	"blue", "purple", "cyan", 
	"black", "orange", "grey"), byrow=TRUE, nrow=3)
# enlarge the matrix
mm=enlarge_raster(m, c(15, 15), space="Lab")
ggplot()+xlim(0, 10)+ylim(0, 5)+coord_fixed()+
	annotation_raster(mm, 
		xmin=0, xmax=10, ymin=0, ymax=5, interpolate=TRUE)
</code></pre>

<hr>
<h2 id='geom_circle_cm'>Geom Layer for Circle with Absolute Size</h2><span id='topic+geom_circle_cm'></span>

<h3>Description</h3>

<p>This layer uses centimeter as unit to draw circles so 
that the size and shape will not be influenced by 
the change of the coordinate systems 
(even when a polar system is used). 
Note: this function does not have 
<code>linetype</code> and <code>n</code> arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_circle_cm(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  linetype = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_circle_cm_+3A_mapping">mapping</code></td>
<td>
<p>aes mapping.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_stat">stat</code></td>
<td>
<p>stat.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_position">position</code></td>
<td>
<p>position.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to remove NA values.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show legend.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>logical, whether to inherit aes from ggplot().</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_linetype">linetype</code></td>
<td>
<p>should always be NULL.
because it will not be used.</p>
</td></tr>
<tr><td><code id="geom_circle_cm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepted properties are: 
</p>

<ul>
<li><p> (1) <code>rcm</code> radius in centimeter.
</p>
</li>
<li><p> (2) <code>color</code> color of the outline.
</p>
</li>
<li><p> (3) <code>fill</code> color inside the shape.
</p>
</li>
<li><p> (4) <code>alpha</code> alpha of color and fill.
</p>
</li>
<li><p> (5) <code>size</code> line width of the outline.
</p>
</li>
<li><p> (6) <code>x</code> x coordinates of the middle points. 
</p>
</li>
<li><p> (7) <code>y</code> y coordinates of the middle points.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat=data.frame(x=1: 10, y=rep(5, 10), R=rep(c(0.5, 1), 5))
ggplot(dat)+xlim(0, 11)+ylim(1, 9)+
	geom_circle_cm(aes(x=x, y=y, fill=factor(R)), rcm=dat$R, alpha=0.5)
</code></pre>

<hr>
<h2 id='geom_ellipse_cm'>Geom Layer for Ellipse with Absolute Size</h2><span id='topic+geom_ellipse_cm'></span>

<h3>Description</h3>

<p>This layer uses centimeter as unit to draw ellipse so 
that its size and shape will not be influenced by 
the coordinate systems 
(even when a polar system is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_ellipse_cm(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_ellipse_cm_+3A_mapping">mapping</code></td>
<td>
<p>aes mapping.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_stat">stat</code></td>
<td>
<p>stat.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_position">position</code></td>
<td>
<p>position.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to remove NA values.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show legend.</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>logical, whether to inherit aes from ggplot().</p>
</td></tr>
<tr><td><code id="geom_ellipse_cm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepted properties are: 
</p>

<ul>
<li><p> (1) <code>rcm</code> radius in centimeter.
</p>
</li>
<li><p> (2) <code>ab</code> it means to what extent 
radius a of an ellipse is larger than radius b.
However, its true meaning is the aspect ratio which 
is used by <code>gridExtra::ellipseGrob</code> and indicates 
the extent to which y dimension is flattened. So, say, 
when <code>ab = 2</code>, radius a is larger than b, but it is 
not exactly 2 times larger. 
</p>
</li>
<li><p> (3) <code>color</code> color of the the outline.
</p>
</li>
<li><p> (4) <code>fill</code> color inside the shape.
</p>
</li>
<li><p> (5) <code>alpha</code> alpha of color and fill.
</p>
</li>
<li><p> (6) <code>size</code> line width of the outline.
</p>
</li>
<li><p> (7) <code>linetype</code> line type.
</p>
</li>
<li><p> (8) <code>angle</code> angle of rotation from 0
degree and in anti-clockwise direction.
</p>
</li>
<li><p> (9) <code>n</code> the number of points to 
draw the shape. Note: it must be written inside 
the <code>aes(...)</code> function.
</p>
</li>
<li><p> (10) <code>x</code> x coordinates of middle points. 
</p>
</li>
<li><p> (11) <code>y</code> y coordinates of middle points.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat=data.frame(x=c(1, 3, 5, 7, 9), y=rep(5, 5)) 
ggplot(dat)+xlim(0, 11)+ylim(1, 9)+
	geom_ellipse_cm(aes(x=x, y=y), fill="red", ab=seq(1, 4, length.out=5))  
ggplot(dat)+xlim(0, 11)+ylim(1, 9)+
	geom_ellipse_cm(aes(x=x, y=y, fill=factor(x)), ab=3, angle=c(0, pi/4, pi/3, pi/2, 0.75*pi))
</code></pre>

<hr>
<h2 id='geom_multi_raster'>Geom Layer for Drawing Multiple Rasters</h2><span id='topic+geom_multi_raster'></span>

<h3>Description</h3>

<p>Unlike <code>annotation_raster</code> which 
draws only 1 raster, this layer 
draws one or more rasters at the same time. 
The data must be a tbl object created by 
package tibble and the reason is that, 
as we must give each rectangle a 
vector of colors, the column that 
contains these vectors of colors must 
be a list rather than a vector. A list can 
be a column for tbl object, not for 
a normal data frame. See examples.
Accepted properties are: 
</p>

<ul>
<li><p> (1) <code>xmin</code>.
</p>
</li>
<li><p> (2) <code>xmax</code>.
</p>
</li>
<li><p> (3) <code>ymin</code>.
</p>
</li>
<li><p> (4) <code>ymax</code>.
</p>
</li>
<li><p> (5) <code>raster</code>. a list with 1 or more 
rasters. If you have only 1 raster, you also 
have to put it into a list. 
Each raster should be 
a matrix, a raster object, a character vector 
or a magick object read into R by 
<code>magick::image_read</code>. 
You can also use a data frame created by 
package tibble to combine
<code>xmin, xmax, ymin, ymax, raster</code>.
</p>
</li>
<li><p> (6) <code>interpolate</code>. It is the same 
as that in <code>annotation_raster</code> except 
that the default value is TRUE. It can be 
used either inside or outside 
the <code>aes(...)</code> function. Its length must be 
either 1 or the same as the number of 
rasters.
</p>
</li>
<li><p> (7) <code>flip</code>. The default is FALSE. 
You only need to use TRUE when you 
use <code>coord_flip</code>. Used outside the 
<code>aes(...)</code> function.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>geom_multi_raster(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  flip = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_multi_raster_+3A_mapping">mapping</code></td>
<td>
<p>aes mapping.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_data">data</code></td>
<td>
<p>data. It should be a tbl object.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_stat">stat</code></td>
<td>
<p>stat.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_position">position</code></td>
<td>
<p>position.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to remove NA values.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_show.legend">show.legend</code></td>
<td>
<p>This will not be used 
because the layer does not 
create any legend.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>logical, 
whether to inherit aes from ggplot().</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_flip">flip</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_multi_raster_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: use vectors and a list. 
mycolor=list(
	c1=matrix(c("red", "blue", "green", "yellow"), nrow=2), 
	c2=matrix(c("green", "yellow")), 
	c3=matrix(c("purple", "red")))
xmin=1: 3
xmax=(1: 3)+0.8 
ymin=c(0, 1, 2)
ymax=c(1, 3, 5)
ggplot()+
	geom_multi_raster(aes(xmin=xmin, xmax=xmax, 
	ymin=ymin, ymax=ymax, raster=mycolor))
#
# Example 2: the same as example 1
# except flip=TRUE.
ggplot()+coord_flip()+
	geom_multi_raster(aes(xmin=xmin, xmax=xmax, 
	ymin=ymin, ymax=ymax, raster=mycolor), flip=TRUE)
</code></pre>

<hr>
<h2 id='geom_rect_cm'>Geom Layer for Rectangle with Absolute Size</h2><span id='topic+geom_rect_cm'></span>

<h3>Description</h3>

<p>This layer uses centimeter as unit to draw rectangles so 
that the size and shape will not be influenced by 
the coordinate systems 
(even when a polar system is used).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_rect_cm(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_rect_cm_+3A_mapping">mapping</code></td>
<td>
<p>aes mapping.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_data">data</code></td>
<td>
<p>data.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_stat">stat</code></td>
<td>
<p>stat.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_position">position</code></td>
<td>
<p>position.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to remove NA values.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_show.legend">show.legend</code></td>
<td>
<p>whether to show legend.</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>logical, whether to inherit aes from ggplot().</p>
</td></tr>
<tr><td><code id="geom_rect_cm_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Accepted properties are: 
</p>

<ul>
<li><p> (1) <code>width</code> width in centimeter.
</p>
</li>
<li><p> (2) <code>height</code> height in centimeter.
</p>
</li>
<li><p> (3) <code>color</code> color of the outline.
</p>
</li>
<li><p> (4) <code>fill</code> color inside the shape.
</p>
</li>
<li><p> (5) <code>alpha</code> alpha of color and fill.
</p>
</li>
<li><p> (6) <code>size</code> line width of outline.
</p>
</li>
<li><p> (7) <code>linetype</code> line type.
</p>
</li>
<li><p> (8) <code>hjust</code> horizontal adjustment, 
default is 0.5 which means no adjustment.
</p>
</li>
<li><p> (9) <code>vjust</code> vertical adjustment, 
default is 0.5 which means no adjustment.
</p>
</li>
<li><p> (10) <code>x</code> x coordinates of middle points. 
</p>
</li>
<li><p> (11) <code>y</code> y coordinates of middle points.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
ggplot()+xlim(-0.5, 10.5)+
	geom_rect_cm(aes(x=1: 10, y=rep(4, 10)), fill="red", height=rep(1: 2, each=5), 
		vjust=rep(c(0, 0.5), 5))+
	geom_point(aes(x=1: 10, y=rep(4, 10)), color="green")
</code></pre>

<hr>
<h2 id='geom_shading_bar'>Geom Layer for Drawing Shading Barplot</h2><span id='topic+geom_shading_bar'></span>

<h3>Description</h3>

<p>This function is similar to 
<code>geom_bar(aes(x, y), stat="identity")</code> 
except that it draws bars with shading colors. 
Unlike <code>gg_shading_bar</code> which 
is a convenient function, this function
is used as a ggplot layer. 
Accepted properties are different from those 
in <code>geom_multi_raster</code> and 
<code>gg_shading_bar</code>. 
</p>

<ul>
<li><p> (1) <code>x</code>. It is the same as that in 
<code>geom_bar</code>.
</p>
</li>
<li><p> (2) <code>y</code>. It is the same as that in 
<code>geom_bar</code>.
</p>
</li>
<li><p> (3) <code>raster</code>. It should be 
a list with 1 or more character vectors of 
colors. If the list only has 1 vector, 
all the bars will use the same shading pattern. 
If you 
have, for example, 5 bars to draw, then you 
have to put 5 vectors of colors into a list.
If you use a data frame, it must be a 
data frame made by package tibble, and 
the column for <code>raster</code> should be 
a list.
</p>
</li>
<li><p> (4) <code>width</code>. It is the same 
as that in <code>geom_bar</code>.
</p>
</li>
<li><p> (5) <code>flip</code>. The default is FALSE. 
You only need to use TRUE when you 
use <code>coord_flip</code>. Use outside the 
<code>aes(...)</code> function.
</p>
</li>
<li><p> (6) <code>modify_raster</code>. If 
it is TRUE (default), colors 
will be smoothed using the value of <code>smooth</code>. 
If <code>raster</code> has enough colors, you can set 
this to FALSE. It is the same as that in 
<code>gg_shading_bar</code>.
</p>
</li>
<li><p> (7) <code>equal_scale</code>. The 
default is FALSE. When it is 
TRUE, a bar will use a certain part of the shading 
colors according to a global scale. It is the same 
as that in <code>gg_shading_bar</code>.
</p>
</li>
<li><p> (8) <code>smooth</code>. The 
default is 15. The number of 
shading colors each bar has. The bigger, the better.
It is the same as that in <code>gg_shading_bar</code>.
</p>
</li>
<li><p> (9) <code>space</code>. The color space that is 
used. It can be &quot;rgb&quot; (default) or &quot;Lab&quot;.
</p>
</li>
<li><p> (10) <code>orientation</code>. This parameter 
mimics the same parameter used in 
<code>geom_bar</code>, though acts differently. 
This enables to flip the x axis and y axis without 
using <code>coord_flip</code>. If it is NA or &quot;x&quot; (default), 
it supposes x = SOME LABELS and y = SOME VALUES. 
If it is &quot;y&quot;, you must set x = SOME VALUES and 
y = SOME LABELS. These effects are the same as 
<code>geom_bar</code>.
</p>
</li></ul>

<p>NOTE: the function does interpolation as default, so  
you does not need to 
use <code>interpolate</code> parameter.
And, unlike <code>gg_shading_bar</code>, this function 
does not draw lines around rectangles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_shading_bar(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.9,
  flip = FALSE,
  modify_raster = TRUE,
  smooth = 15,
  equal_scale = FALSE,
  space = "rgb",
  orientation = "x",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geom_shading_bar_+3A_mapping">mapping</code></td>
<td>
<p>aes mapping.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_data">data</code></td>
<td>
<p>data. It should be a tbl object.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_stat">stat</code></td>
<td>
<p>stat.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_position">position</code></td>
<td>
<p>position. The parameter will 
not be used here.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, whether to remove NA values.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_show.legend">show.legend</code></td>
<td>
<p>This will not be used 
because the layer does not 
create any legend.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>logical, 
whether to inherit aes from ggplot().</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_width">width</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_flip">flip</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_modify_raster">modify_raster</code></td>
<td>
<p>see description 
or <code>gg_shading_bar</code>.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_smooth">smooth</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_equal_scale">equal_scale</code></td>
<td>
<p>see description
or <code>gg_shading_bar</code>.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_space">space</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_orientation">orientation</code></td>
<td>
<p>see description.</p>
</td></tr>
<tr><td><code id="geom_shading_bar_+3A_...">...</code></td>
<td>
<p>additional parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1: use vectors.
x=c("b", "a", "c", "d", "e")
y=c(2, 1, 3, 5, 4)
raster=list(c("blue", "red"), c("green", "orange"), 
	c("cyan", "yellow"), c("purple", "orangered"), c("grey", "red"))
ggplot()+
	geom_shading_bar(aes(x=x, y=y, raster=raster), smooth=40)
#
# Example 2: other parameters
x=1: 5
y=c(1, 2, -3, 5, 4)
raster=list(c("blue", "red"))
ggplot()+
	geom_shading_bar(aes(x=x, y=y, raster=raster), 
		smooth=50, width=0.6, equal_scale=TRUE)+
	scale_x_continuous(breaks=1: 5, labels=letters[1: 5])
</code></pre>

<hr>
<h2 id='get_click_color'>Obtaining the Colors of Positions Clicked</h2><span id='topic+get_click_color'></span>

<h3>Description</h3>

<p>The function draws an image and asks the user 
to click on the positions whose colors the user 
wants to know. NOTE: after clicking, you must 
press Esc button to continue. The result is a vector
of colors in hex mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_click_color(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_click_color_+3A_x">x</code></td>
<td>
<p>a raster object, or an image loaded by
<code>magick::image_read</code> or the filename of 
that image.</p>
</td></tr>
</table>

<hr>
<h2 id='get_gg_label'>Checking Min, Max, Labels and Label Positions</h2><span id='topic+get_gg_label'></span>

<h3>Description</h3>

<p>Given a numeric vector or a ggplot object, the function
will check the range, labels and label 
positions (the same as major grid lines) that 
will used on the axis. The result is a length 5 list for 
min limit, max limit, labels, major grid-line positions, 
all (major and minor) grid-line positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gg_label(
  a = NULL,
  b = NULL,
  v = NULL,
  gg = NULL,
  mult = 0.05,
  add = 0,
  axis = "y"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_gg_label_+3A_a">a</code></td>
<td>
<p>extreme values of a numeric vector. Note: only 
one of <code>a</code>, <code>v</code>, <code>gg</code> can be non-NULL.
It can also be a gg object.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_b">b</code></td>
<td>
<p>another extreme value if <code>a</code> is not NULL.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_v">v</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_gg">gg</code></td>
<td>
<p>a gg object created by ggplot function.
Which value will be checked depends on <code>axis</code>.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_mult">mult</code></td>
<td>
<p>default is 0.05 and should be of length 
1 or 2. It mimics the <code>mult</code> argument of 
<code>ggplot2::expansion</code>. It is only used when 
a is numeric or v is non-NULL.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_add">add</code></td>
<td>
<p>default is 0. It mimics the <code>add</code> 
argument of <code>ggplot2::expansion</code>.</p>
</td></tr>
<tr><td><code id="get_gg_label_+3A_axis">axis</code></td>
<td>
<p>if <code>gg</code> is used or <code>a</code> is a 
ggplot object, 
which axis will 
be checked? It can be &quot;x&quot; or &quot;y&quot; (default).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>get_gg_label(a=1, b=1000)
# The following three have the same results.
get_gg_label(a=1, b=1000, mult=0)
get_gg_label(v=c(1, 500, 1000), mult=0)
p=ggplot()+geom_point(aes(1: 3, c(1, 500, 1000)))+
  scale_y_continuous(expand=expansion(mult=0))
get_gg_label(gg=p)
</code></pre>

<hr>
<h2 id='gg_shading_bar'>Drawing Barplot with Shading Colors</h2><span id='topic+gg_shading_bar'></span>

<h3>Description</h3>

<p>In ordinary barplot, each bar has only one color.
This function aims to draw a barplot whose bars 
have shading effect. Note: unlike 
<code>ggplot2::geom_bar</code>, this function can only 
deals with a vector of frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_shading_bar(
  v,
  labels = NULL,
  raster = NULL,
  flip = FALSE,
  change_order = "normal",
  equal_scale = FALSE,
  smooth = 15,
  interpolate = TRUE,
  width = 0.8,
  color = NA,
  linetype = 1,
  size = 1,
  modify_raster = TRUE,
  space = "rgb",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gg_shading_bar_+3A_v">v</code></td>
<td>
<p>a vector of item frequencies.
Negative values are OK.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_labels">labels</code></td>
<td>
<p>a vector of item names.
Its length should be equal to that of <code>v</code>.
If it is NULL, default names will be used.
If it is of class numeric or factor, it will be 
transformed to a character vector.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_raster">raster</code></td>
<td>
<p>a list. The length of the list 
should be equal to that of <code>v</code>. 
Each element of the list should be 
a color vector corresponding to a value 
in <code>v</code>. If it is a vector, it will be 
automatically transformed to a list. 
If its length is 1, but the length of 
<code>v</code> is, say, 3, then it will be 
automatically repeated for 3 times.
Let us suppose <code>v = 5</code> 
and <code>raster = list(c("green", "red"))</code>.
This means the starting side of the bar is 
green and the far side is red. See examples.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_flip">flip</code></td>
<td>
<p>default is FALSE and the bars 
are vertical. When it is TRUE, the bars are 
horizontal. Note: when using this function, 
<b>DO NOT USE</b> 
<code>ggplot2::coord_flip</code> !</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_change_order">change_order</code></td>
<td>
<p>when it is &quot;normal&quot; (default), 
the drawing order is the order of <code>v</code>.
When it is &quot;big&quot;, big values will be drawn first.
When it is &quot;small&quot;, small values will be drawn first.
When it is &quot;rev&quot;, the inverse order of <code>v</code> 
will be used.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_equal_scale">equal_scale</code></td>
<td>
<p>default is FALSE. When it is 
TRUE, a bar will use a certain part of the shading 
colors according to a global scale. See examples.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_smooth">smooth</code></td>
<td>
<p>default is 15. The number of 
shading colors each bar has. The bigger, the better.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_interpolate">interpolate</code></td>
<td>
<p>when it is TRUE (default), it 
makes the colors smoother.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_width">width</code></td>
<td>
<p>the width of each bar. It should be 
between 0 and 1.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_color">color</code></td>
<td>
<p>color of the outlines of the bars.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_linetype">linetype</code></td>
<td>
<p>line type of the outlines 
of the bars.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_size">size</code></td>
<td>
<p>line width of the outlines of the bars.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_modify_raster">modify_raster</code></td>
<td>
<p>if it is TRUE (default), colors 
will be smoothed using the value of <code>smooth</code>. 
If <code>raster</code> has enough colors, you can set 
this to FALSE.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_space">space</code></td>
<td>
<p>the <code>space</code> parameter used by 
<code>colorRampPalette</code>. It should be 
&quot;rgb&quot; (default) or &quot;Lab&quot;.</p>
</td></tr>
<tr><td><code id="gg_shading_bar_+3A_...">...</code></td>
<td>
<p>additional arguments used by 
<code>ggplot2::coord_flip</code> when <code>flip = TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
x=c(10, 30, 25, 6)
lab=c("children", "youth", "middle", "aged")
r=list(c("cyan", "red"), c("blue", "yellow"), 
	c("green", "orange"), c("grey", "black"))
#
## (1) change_order
# change_order = "ordinary", the default
p1=gg_shading_bar(v=x, labels=lab)
# change_order = "big"
p2=gg_shading_bar(v=x, labels=lab, change_order="big")
# flip and let the largest on the top
p3=gg_shading_bar(v=x, labels=lab, 
	change_order="small", flip=TRUE)
#
## (2) how to use argument raster
p1=gg_shading_bar(v=x, labels=lab, raster=r)
p2=gg_shading_bar(v=x, labels=lab, raster=c("green","red"))
#
## (3) how to use argument equal_scale
# equal_scale = FALSE
# the far side of each bar is red
gg_shading_bar(c(3, 5), raster=c("green", "red"))
# equal_scale = TRUE
# the far side of the shorter bar 
# is not red. Rather, it is something
#' between red and green
gg_shading_bar(c(3, 5), raster=c("green", "red"), 
	equal_scale=TRUE)
</code></pre>

<hr>
<h2 id='image_col_numeric'>Colorize an Image according to Gray Scale</h2><span id='topic+image_col_numeric'></span>

<h3>Description</h3>

<p>A color image can be converted to one with 
different degrees of gray. Then, colors in a 
palette can be added according to the gray 
degrees. The function is a simple wrapper 
of <code>scales::col_numeric</code>. The pixels 
which are deliberately assigned 
&quot;transparent&quot; in the original magick image will 
always kept unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_col_numeric(
  x,
  palette = c("purple", "yellow"),
  n = 256,
  alpha = FALSE,
  result = "magick",
  res = 144
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_col_numeric_+3A_x">x</code></td>
<td>
<p>an image
read into R by <code>magick::image_read</code>.</p>
</td></tr>
<tr><td><code id="image_col_numeric_+3A_palette">palette</code></td>
<td>
<p>two or more colors. The default is 
c(&quot;purple&quot;, &quot;yellow&quot;) which means the deeper colors
on the image will become purple and the lighter 
yellow.</p>
</td></tr>
<tr><td><code id="image_col_numeric_+3A_n">n</code></td>
<td>
<p>the max num of colors that will be used. 
The default is 256. Note, the number of colors that 
really exist may be smaller than this number.</p>
</td></tr>
<tr><td><code id="image_col_numeric_+3A_alpha">alpha</code></td>
<td>
<p>whether 
transparency is used. Transparency
only exists when <code>alpha = TRUE</code> and your 
image is in the format (e. g., png) that supports 
transparency. The default is FALSE.</p>
</td></tr>
<tr><td><code id="image_col_numeric_+3A_result">result</code></td>
<td>
<p>if it is &quot;magick&quot; (default), the result 
is a picture of the same type used by package magick.
If it is &quot;raster&quot;, the result is a matrix that can be 
used as a raster by <code>ggplot2::annotation_raster</code>.</p>
</td></tr>
<tr><td><code id="image_col_numeric_+3A_res">res</code></td>
<td>
<p>resolution that is used by 
<code>magick::image_graph</code>. The default is 144.</p>
</td></tr>
</table>

<hr>
<h2 id='image_crop_click'>Cut out a Subregion of an Image by Mouse Click</h2><span id='topic+image_crop_click'></span>

<h3>Description</h3>

<p>This function is a wrapper of 
<code>magick::image_crop</code>. While the 
latter asks you to set a <code>geometry</code> 
parameter, this function enables you 
to set the four sides of a subregion only 
by click the mouse. You must click at 
least 2 times (that is, click on 2 different
points to define a rectangle). After clicking, 
please press Esc on your keyboard. You 
can also designate an irregular polygon 
by mouse with at least 3 clicks. If it is 
irregular, you MUST click on positions 
in order (something like that, when you 
draw a polygon in R, you must input 
the positions of points in order).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_crop_click(x, only_value = FALSE, rectangle = TRUE, trim = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_crop_click_+3A_x">x</code></td>
<td>
<p>an image read into R by 
<code>magick::image_read</code> or an image  
modified by functions in the magick 
package.</p>
</td></tr>
<tr><td><code id="image_crop_click_+3A_only_value">only_value</code></td>
<td>
<p>the default is FALSE, 
which will return the subregion. If you set it to 
TRUE, the result is only four values with 
the order: left, right, top, bottom.</p>
</td></tr>
<tr><td><code id="image_crop_click_+3A_rectangle">rectangle</code></td>
<td>
<p>whether the cropped 
area is a rectangle (default is TRUE). If 
it is FALSE, the subregion can be irregular.</p>
</td></tr>
<tr><td><code id="image_crop_click_+3A_trim">trim</code></td>
<td>
<p>this is only used when 
<code>rectangle</code> is FALSE. It decides whether 
the irregular subregion is to be trimmed. If it 
is FALSE (default), no trimming will be done. 
If it is a 0 to 100 value, 
<code>magick::image_trim</code> will be used, whose 
<code>fuzz</code> argument is equal to <code>trim</code>. 
If it is TRUE (not 1), trimming will be done 
according to the mouse click you have made.</p>
</td></tr>
</table>

<hr>
<h2 id='image_keep_color'>Keep Some Colors Unchanged and Make 
Others into Grayscale</h2><span id='topic+image_keep_color'></span>

<h3>Description</h3>

<p>This function keeps pixels with certain 
colors unchanged and transforms 
others into grayscale.
The function is in fact a wrapper of 
<code>magick::image_transparent</code>, so it 
uses the latter's <code>color</code> and <code>fuzz</code>
parameters. NOTE: the function only works 
for fully opaque or fully 
transparent (labelled as &quot;transparent&quot;) pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_keep_color(x, color = NULL, fuzz = 10, result = "magick")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_keep_color_+3A_x">x</code></td>
<td>
<p>an image read into R 
by <code>magick::image_read</code>.</p>
</td></tr>
<tr><td><code id="image_keep_color_+3A_color">color</code></td>
<td>
<p>the same 
as <code>magick::image_transparent</code>.
You can use 1 or more colors.</p>
</td></tr>
<tr><td><code id="image_keep_color_+3A_fuzz">fuzz</code></td>
<td>
<p>the same 
as <code>magick::image_transparent</code>. 
However, Its length must either be 1 or the same 
as <code>color</code>.</p>
</td></tr>
<tr><td><code id="image_keep_color_+3A_result">result</code></td>
<td>
<p>if it is &quot;magick&quot; (default), the result is 
a magick image, if it is &quot;raster&quot;, the result is a matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='image_locator'>Get the Width and Height of the
Mouse Clicked Points</h2><span id='topic+image_locator'></span>

<h3>Description</h3>

<p>This function simply gets the width and 
height values of the points on which you click.
The result is a list of two vectors, the first 
vector is for width, the second for height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_locator(x, rectangle = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_locator_+3A_x">x</code></td>
<td>
<p>a raster object, or an image loaded by
<code>magick::image_read</code> or the filename of 
that image.</p>
</td></tr>
<tr><td><code id="image_locator_+3A_rectangle">rectangle</code></td>
<td>
<p>if it is FALSE (default), 
the result list 
contains the width and height values. 
If it is TRUE, only the left, right, top, bottom values 
of the rectangle 
designated by your clicking are returned.</p>
</td></tr>
</table>

<hr>
<h2 id='image_modify_hsv'>Modify the H, S, V Values of a 
Color Vector or an Image</h2><span id='topic+image_modify_hsv'></span>

<h3>Description</h3>

<p>The function modifies the H (0 - 1), S, V values 
of a vector of colors or an image. The 
three channels can be modified separately.
However, the most frequently used is 
only the V modification.
The ways to modify include: setting values 
to some specified values (set_*), adding (add_*), 
multiplying the original values (mult_*), 
rescaling the original values (rescale_*), 
using a function to recompute values (fun_*). 
The most useful way is to use some internal 
curves that mimic those PS-like apps.
DO see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_modify_hsv(
  x,
  set_h = NULL,
  add_h = NULL,
  mult_h = NULL,
  rescale_h = NULL,
  fun_h = NULL,
  set_s = NULL,
  add_s = NULL,
  mult_s = NULL,
  rescale_s = NULL,
  fun_s = NULL,
  set_v = NULL,
  add_v = NULL,
  mult_v = NULL,
  rescale_v = NULL,
  fun_v = NULL,
  result = "magick",
  res = 144
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_modify_hsv_+3A_x">x</code></td>
<td>
<p>an image created by <code>image_read</code> or 
other functions in package magick. Alternatively, it 
can be a vector of colors.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_set_h">set_h</code></td>
<td>
<p>set H values with specific values.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_add_h">add_h</code></td>
<td>
<p>add specific 
values to current H values.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_mult_h">mult_h</code></td>
<td>
<p>multiply the current values 
with specific values.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_rescale_h">rescale_h</code></td>
<td>
<p>a length 2 numeric vector 
specifying the desired range of H values, 
e. g., <code>rescale_h = c(0.6, 0.95)</code> which 
will make the smallest original value to 
be 0.6, and the largest, 0.95. Alternatively, 
it can be your own scaling function.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_fun_h">fun_h</code></td>
<td>
<p>your own modifying function 
(e. g., <code>fun_h = sqrt</code>). Alternatively, it can 
be a list that designates how to use internal 
curves. See Details.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_set_s">set_s</code>, <code id="image_modify_hsv_+3A_add_s">add_s</code>, <code id="image_modify_hsv_+3A_mult_s">mult_s</code>, <code id="image_modify_hsv_+3A_rescale_s">rescale_s</code>, <code id="image_modify_hsv_+3A_fun_s">fun_s</code></td>
<td>
<p>parameters 
to change S values. Used in the same way as those 
for H. See above.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_set_v">set_v</code>, <code id="image_modify_hsv_+3A_add_v">add_v</code>, <code id="image_modify_hsv_+3A_mult_v">mult_v</code>, <code id="image_modify_hsv_+3A_rescale_v">rescale_v</code>, <code id="image_modify_hsv_+3A_fun_v">fun_v</code></td>
<td>
<p>parameters 
to change V values. Used in the same way as those 
for H. See above.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_result">result</code></td>
<td>
<p>the default is &quot;magick&quot;, the output is 
a magick picture. When it is &quot;raster&quot;, a matrix is created 
which can be use as a raster 
for <code>ggplot2::annotation_raster</code>.</p>
</td></tr>
<tr><td><code id="image_modify_hsv_+3A_res">res</code></td>
<td>
<p>when the result is a magick picture, the 
<code>res</code> parameter used by <code>magick::image_graph</code>.
Default is 144.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fun_*</code> can be a function or 
a named list which tells the 
function which internal function is to be used. 
You must ensure values used by the function 
specified by you to be in the range [0, 1] for 
H, S, V modification and [0, 255] for R, G, B
modification. Also, you'd better make sure 
the output values of the function are in 
</p>
<p>When <code>fun_*</code> is a list, it should be written in the 
following way: 
</p>

<ul>
<li><p> (1) <code>fun_* = list(fun = "s", c1 = -2, 
c2 = 2, domain = c(0, 1))</code> An &quot;s&quot; curve will be 
used. c1 points out how to deal with values below 
0.5, c2 with values above 0.5. For c1 and c2, a value 
larger than 0 means a curvature towards y = 1, and 
a value smaller than 0 means a curvature towards
y = 0. So, c1 &lt; 0 and c2 &gt; 0 will make an s shape 
curve. c1 and c2 can be any number, though 
those with absolute values below 4 are quite 
good (default is -2 and 2). 0 means no change. 
domain specifies the 
value domain to put the result. The default is 
c(0, 1) which means not to rescale, thus
0.1 is 0.1. However, if you 
set <code>domain = c(0.5, 1)</code>, 
then 0.1 will be 0.55. If you do not know how 
to set domain, just ignore it.
</p>
</li>
<li><p> (2) <code>fun_* = list(fun = "circle", 
value = 0.5)</code> When the fun 
is &quot;circle&quot; or &quot;c&quot;, an arc will be used. value must 
be a number between -1 and 1 (default is 0.5). 
A number larger than 0 means the curvature is 
towards y = 1, and a number smaller than 0 means 
it is towards y = 0. value should not be 0.
</p>
</li>
<li><p> (3) <code>list(fun_* = "linear", x0 = 0.4, 
y0 = 0.6)</code> This makes a linear modification except 
that there is a breakpoint. The default point is 
(0.4, 0.6) which means: suppose all the original numbers
and output numbers are in the [0, 1] range and 
the points with their x position smaller than 0.4 will 
be put along the line that links (0, 0) and (0.4, 0.6), 
and, those with x position larger than 0.4 will be put 
along the line that links (0.4, 0.6) and (1, 1). 
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# First create an image
library(magick)
mycolor=grDevices::hsv(0, s=seq(0.1, 0.9, 0.1), 
	v=seq(0.1, 0.9, 0.1))
img=image_graph(width=400, height=400)
print(showcolor(mycolor)+theme_void())
dev.off()
# Now increase S values with 
# an internal circle curve and 
# set V values between [0.5, 1].
res=image_modify_hsv(img, 
	fun_s=list("circle", value=1), 
	rescale_v=c(0.5, 1))

</code></pre>

<hr>
<h2 id='image_modify_local'>Modify Only a Subregion of an Image</h2><span id='topic+image_modify_local'></span>

<h3>Description</h3>

<p>The function allows you to modify a subregion  
of your image (or, the opposite, keep the 
subregion unchanged while modifying other parts).
You can set the four sides of the subregion 
or an irregular polygon by 
mouse click. If it is irregular, you MUST 
click in order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_modify_local(
  x,
  FUN,
  geometry = "click",
  local = "local",
  rectangle = TRUE,
  trim = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_modify_local_+3A_x">x</code></td>
<td>
<p>an image read into R by 
<code>magick::image_read</code> or an image  
modified by functions in the magick 
package.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_fun">FUN</code></td>
<td>
<p>the function used to 
modify <code>x</code>. NOTE: the result 
of <code>FUN</code> must be of the same 
class as <code>x</code> and its width and 
height must not be changed during 
modification.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_geometry">geometry</code></td>
<td>
<p>this parameter is 
different from the one used in package 
magick. Here, in this function, you can 
set <code>geometry = "click"</code> if you want 
to show which part you want to modify 
by mouse click (see 
function <code>image_crop_click</code> for how to 
use mouse click). Otherwise, you can use 
a length 4 vector with the exact order: left, 
right, top, bottom.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_local">local</code></td>
<td>
<p>if it is 1 or &quot;local&quot;, only a subregion 
of your image will be modified. If it is 2
or &quot;other&quot;, keep the subregion unchanged while 
modifying other parts. If it is 3 or &quot;subregion&quot;, 
the result is only the modified subregion, not the 
whole image.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_rectangle">rectangle</code></td>
<td>
<p>if it is TRUE (default), the 
subregion is a rectangle. If it is FALSE, 
the subregion can be an irregular polygon 
designated by your mouse click.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_trim">trim</code></td>
<td>
<p>whether to trim the subregion. 
This is only used when <code>local</code>
is 3 or &quot;subregion&quot;. It helps remove 
the transparent parts. See <code>image_crop_click</code>
to know how to use this parameter.</p>
</td></tr>
<tr><td><code id="image_modify_local_+3A_...">...</code></td>
<td>
<p>extra parameters used by 
<code>FUN</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='image_modify_local2'>Modify both a Subregion  and the Whole
of an Image</h2><span id='topic+image_modify_local2'></span>

<h3>Description</h3>

<p>The function is similar to 
<code>image_modify_local</code> but with different 
parameters. It modifies both a subregion  
of the image and the whole image, and then 
combines them. The subregion can be chosen 
either by numeric values or by mouse click ,which 
is the same as <code>image_modify_local</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_modify_local2(x, FUN1, FUN2 = NULL, geometry = "click", rectangle = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_modify_local2_+3A_x">x</code></td>
<td>
<p>an image read into R by 
<code>magick::image_read</code> or an image  
modified by functions in the magick 
package.</p>
</td></tr>
<tr><td><code id="image_modify_local2_+3A_fun1">FUN1</code></td>
<td>
<p>a function to modify 
a subregion of <code>x</code>. NOTE: the result 
of these functions must be of the same class 
as <code>x</code> and should not change the sizes 
of the subregion.</p>
</td></tr>
<tr><td><code id="image_modify_local2_+3A_fun2">FUN2</code></td>
<td>
<p>a function to modify 
the whole image, which must not change 
the size of the image. If it is NULL (default), 
nothing will do to the whole image.</p>
</td></tr>
<tr><td><code id="image_modify_local2_+3A_geometry">geometry</code></td>
<td>
<p>this parameter is 
different from the one used in package 
magick. Here, in this function, you can 
set <code>geometry = "click"</code> if you want 
to show which part is the subregion 
by mouse click (see 
function <code>image_crop_click</code> for how to 
use mouse click). Otherwise, you can use 
a length 4 vector with the exact order: left, 
right, top, bottom.</p>
</td></tr>
<tr><td><code id="image_modify_local2_+3A_rectangle">rectangle</code></td>
<td>
<p>if it is TRUE (default), 
the subregion is a rectangle area. If 
it is FALSE, the subregion is 
an irregular polygon area, and, now 
<code>geometry</code> is ignored, you must 
designate the area by mouse click.</p>
</td></tr>
</table>

<hr>
<h2 id='image_modify_rgb'>Modify R, G, B Values of an Image</h2><span id='topic+image_modify_rgb'></span>

<h3>Description</h3>

<p>The function modifies the R, G, B values 
of an image and is used in the same 
way as <code>image_modify_hsv</code> 
in this package. The 
three channels can be modified separately.
The ways to modify include: setting values 
to some specified values (set_*), adding (add_*), 
multiplying the original values (mult_*), 
rescaling the original values (rescale_*), 
using a function to recompute values (fun_*). 
The most useful way is to use some internal 
curves that mimic those PS-like apps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_modify_rgb(
  x,
  set_r = NULL,
  add_r = NULL,
  mult_r = NULL,
  rescale_r = NULL,
  fun_r = NULL,
  set_g = NULL,
  add_g = NULL,
  mult_g = NULL,
  rescale_g = NULL,
  fun_g = NULL,
  set_b = NULL,
  add_b = NULL,
  mult_b = NULL,
  rescale_b = NULL,
  fun_b = NULL,
  result = "magick",
  res = 144
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_modify_rgb_+3A_x">x</code></td>
<td>
<p>an image created 
by <code>magick::image_read</code> or 
other functions in package magick.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_set_r">set_r</code></td>
<td>
<p>set r values with specific values.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_add_r">add_r</code></td>
<td>
<p>add specific 
values to current R values.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_mult_r">mult_r</code></td>
<td>
<p>multiply the current values 
with specific values.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_rescale_r">rescale_r</code></td>
<td>
<p>a length 2 numeric vector 
specifying the desired range of R values, 
e. g., <code>rescale_r = c(180, 240)</code> which 
will make the smallest original value to 
be 180, and the largest, 240. Alternatively, 
it can be your own scaling function.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_fun_r">fun_r</code></td>
<td>
<p>your own modifying function 
(e. g., <code>fun_r = sqrt</code>). Alternatively, it can 
be a list that designates how to use internal 
curves. See <code><a href="#topic+image_modify_hsv">image_modify_hsv</a></code>.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_set_g">set_g</code>, <code id="image_modify_rgb_+3A_add_g">add_g</code>, <code id="image_modify_rgb_+3A_mult_g">mult_g</code>, <code id="image_modify_rgb_+3A_rescale_g">rescale_g</code>, <code id="image_modify_rgb_+3A_fun_g">fun_g</code></td>
<td>
<p>parameters 
to change G values. Used in the same way as those 
for R. See above.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_set_b">set_b</code>, <code id="image_modify_rgb_+3A_add_b">add_b</code>, <code id="image_modify_rgb_+3A_mult_b">mult_b</code>, <code id="image_modify_rgb_+3A_rescale_b">rescale_b</code>, <code id="image_modify_rgb_+3A_fun_b">fun_b</code></td>
<td>
<p>parameters 
to change B values. Used in the same way as those 
for R. See above.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_result">result</code></td>
<td>
<p>the default is &quot;magick&quot;, the output is 
a magick picture. When it is &quot;raster&quot;, a matrix is created 
which can be use as a raster 
for <code>ggplot2::annotation_raster</code>.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_+3A_res">res</code></td>
<td>
<p>when the result is a magick picture, the 
<code>res</code> parameter used by <code>magick::image_graph</code>.
Default is 144.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several internal curves can be used. 
Please see the Details part 
of <code><a href="#topic+image_modify_hsv">image_modify_hsv</a></code>.
</p>

<hr>
<h2 id='image_modify_rgb_v'>Modify R, G, B Values according to 
V values</h2><span id='topic+image_modify_rgb_v'></span>

<h3>Description</h3>

<p>While the <code><a href="#topic+image_modify_rgb">image_modify_rgb</a></code> 
function modifies R, G, B with reference to 
the original values, 
<code>image_modify_rgb_v</code> also takes into 
account the brightness (V) values. It is similar 
to those apps which divide an image into 
a bright part and a dark part (and, for 
example, you can increase red in the 
bright part and decrease red in the 
dark part.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_modify_rgb_v(
  x,
  fun_r = NULL,
  fun_g = NULL,
  fun_b = NULL,
  alpha = FALSE,
  rescale_v = NULL,
  result = "magick",
  res = 144
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_modify_rgb_v_+3A_x">x</code></td>
<td>
<p>an image created 
by <code>magick::image_read</code> or 
other functions in package magick.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_v_+3A_fun_r">fun_r</code>, <code id="image_modify_rgb_v_+3A_fun_g">fun_g</code>, <code id="image_modify_rgb_v_+3A_fun_b">fun_b</code></td>
<td>
<p>a function or a list which 
designates an internal curve. See the Details part of 
<code><a href="#topic+image_modify_hsv">image_modify_hsv</a></code>.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_v_+3A_alpha">alpha</code></td>
<td>
<p>whether to allow 
the output colors have transparency. Default is FALSE.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_v_+3A_rescale_v">rescale_v</code></td>
<td>
<p>You can rescale the V values before 
modifying colors. A desired range of V values can 
be given, 
e. g., <code>rescale_v = c(0.2, 1)</code> which 
will make the smallest original value to 
be 0.2, and the largest, 1. Alternatively, 
it can be your own scaling function.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_v_+3A_result">result</code></td>
<td>
<p>the default is &quot;magick&quot;, the output is 
a magick picture. When it is &quot;raster&quot;, a matrix is created 
which can be use as a raster 
for <code>ggplot2::annotation_raster</code>.</p>
</td></tr>
<tr><td><code id="image_modify_rgb_v_+3A_res">res</code></td>
<td>
<p>when the result is a magick picture, the 
<code>res</code> parameter used by <code>magick::image_graph</code>.
Default is 144.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses custom functions 
or internal curves to 
make modification. See the Details part 
of <code><a href="#topic+image_modify_hsv">image_modify_hsv</a></code> to 
know how to use them. Note: values will 
be coerced to be in the [0, 255] range with 
no warning. For example, the original value 
is 240 and it becomes 280 in the output, then 
it will be set to 255 automatically.
</p>

<hr>
<h2 id='image_transparent_inverse'>Keep Certain Colors Unchanged
and Make Others Transparent</h2><span id='topic+image_transparent_inverse'></span>

<h3>Description</h3>

<p>This function is an inverse version of 
<code>magick::image_transparent</code>.
While the latter makes certain colors 
transparent, the former keeps them 
unchanged and make others transparent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_transparent_inverse(x, color, fuzz = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="image_transparent_inverse_+3A_x">x</code></td>
<td>
<p>a magick image.</p>
</td></tr>
<tr><td><code id="image_transparent_inverse_+3A_color">color</code></td>
<td>
<p>one or more colors you want 
want to keep unchanged.</p>
</td></tr>
<tr><td><code id="image_transparent_inverse_+3A_fuzz">fuzz</code></td>
<td>
<p>color tolerance between 0 and 100.
Its length must be 1 or the same as <code>color</code>
(which 
means you can have different fuzz values for 
different colors).
Suppose your color is white. If fuzz=0, then only 
white will be kept unchanged; if fuzz=10, colors 
similar to white will also kept unchanged.</p>
</td></tr>
</table>

<hr>
<h2 id='raster_alpha'>Combine a Matrix of Colors and 
a Matrix of Alpha Values</h2><span id='topic+raster_alpha'></span>

<h3>Description</h3>

<p>The function is a wrapper of 
<code>scales::alpha</code>. While the latter 
only works on vectors, the former 
can combine a matrix of colors and 
a matrix of alpha values as long as the two 
have the same numbers of rows and 
columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_alpha(color, alpha, result = "raster", res = 144)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster_alpha_+3A_color">color</code></td>
<td>
<p>a matrix of colors, a 
raster or an image read into R by 
<code>magick::image_read</code>.</p>
</td></tr>
<tr><td><code id="raster_alpha_+3A_alpha">alpha</code></td>
<td>
<p>either a single value (e.g., 0.4)
or a matrix of alpha values. The matrix 
should have the same numbers of rows 
and columns as <code>color</code>.</p>
</td></tr>
<tr><td><code id="raster_alpha_+3A_result">result</code></td>
<td>
<p>if it is &quot;raster&quot;, the result will 
be a matrix which can be used by
<code>annotation_raster</code> (default), if it is 
&quot;magick&quot;, the result is a magick image.</p>
</td></tr>
<tr><td><code id="raster_alpha_+3A_res">res</code></td>
<td>
<p>the <code>res</code> parameter used 
by <code>magick::image_graph</code> when <code>result</code>
is &quot;magick&quot;. Default is 144.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A color matrix
co=c("red", "yellow", "green", "blue")
co=rbind(co, co, co)
# An alpha matrix
alp=c(1, 0.6, 0.3, 0.1)
alp=rbind(alp, alp, alp)
# Now combine the two
result=raster_alpha(co, alp)
</code></pre>

<hr>
<h2 id='rectxy'>Generating Coordinates of Multiple Rectangles</h2><span id='topic+rectxy'></span>

<h3>Description</h3>

<p>Note: the shapes are correct  
only when <code>ggplot2::coord_fixed()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectxy(
  x = 0,
  y = 0,
  a = 1,
  b = 1,
  angle = 0,
  xytype = "middle",
  group = TRUE,
  todf = TRUE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rectxy_+3A_x">x</code></td>
<td>
<p>the x coordinates of relative points. 
Its length can be larger than 1.
See <code>xytype</code>.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_y">y</code></td>
<td>
<p>the y coordinates of relative points. 
Its length can be larger than 1.
See <code>xytype</code>.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_a">a</code></td>
<td>
<p>the side that is parallel to 
x-axis before rotation. Its length can be larger than 1.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_b">b</code></td>
<td>
<p>the side that is parallel to 
y-axis before rotation. Its length can be larger than 1.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_angle">angle</code></td>
<td>
<p>default is 0. The rotation angle in radian.
Note: &quot;radian = degree * pi / 180&quot;. Its length can be 
larger than 1.
The rotation direction is anti-clockwise.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_xytype">xytype</code></td>
<td>
<p>should be one of &quot;middle/center&quot; (default), 
&quot;bottomleft&quot;, &quot;middleleft/centerleft/left&quot;. 
It indicates the type of argument 
of the middle point of an shape. If it is &quot;middleleft&quot;, x and 
y are the middle-left coordinates before rotation. If it is 
&quot;bottomleft&quot;, x and y are the coordinates of the 
bottom-left corner.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_group">group</code></td>
<td>
<p>default is TRUE. It indicates 
whether to add a 3rd column named 
&quot;g&quot; to label the group number of each group of points. It is useful 
when using <code>aes(...group=g)</code> with 'ggplot2'.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE. It indicates whether to 
combine the output (a list) into a data frame.</p>
</td></tr>
<tr><td><code id="rectxy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>todf = TRUE</code>, the output will be a data frame
with coordinates of possibly several polygons, otherwise, 
it will be a list of data frames. Data frames have 2 columns
named &quot;x&quot; and &quot;y&quot;, and if <code>group = TRUE</code>, a third column 
named &quot;g&quot; is added indicating group numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat1=rectxy(x=4, y=3, a=2, b=1, angle=0, xytype="bottomleft", todf=TRUE) 
dat2=rectxy(x=4, y=3, a=2, b=1, angle=pi/6, xytype="bottomleft", todf=TRUE)
ggplot()+
	geom_polygon(data=dat1, aes(x=x, y=y), fill="red", alpha=0.3)+
	geom_polygon(data=dat2, aes(x=x, y=y), fill="blue", alpha=0.3)+	
	coord_fixed()
</code></pre>

<hr>
<h2 id='resize_to_standard'>Resize an Image According to the Other Image or to Ratios</h2><span id='topic+resize_to_standard'></span>

<h3>Description</h3>

<p>Simple wrapper of <code>magick::image_resize</code>.
See the parameters below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resize_to_standard(x, standard = 0.5, what = "all", scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="resize_to_standard_+3A_x">x</code></td>
<td>
<p>the image you want to resize.</p>
</td></tr>
<tr><td><code id="resize_to_standard_+3A_standard">standard</code></td>
<td>
<p>either the image whose size is the 
standard or two ratios. When it specifies two ratios, 
it should be a numeric vector whose first and second 
elements are multipliers for width and height. For 
example, x's width and height are 100 and 60, and 
<code>standard = c(0.5, 3)</code>, then the result 
image's width and height will be 50 and 180. If one of 
the two number is NA, then the dimension represented 
by this NA will be modified automatically.</p>
</td></tr>
<tr><td><code id="resize_to_standard_+3A_what">what</code></td>
<td>
<p>this parameter is used only when 
<code>standard</code> is an image. It specifies 
the way to resize. When it 
is &quot;width&quot;, let x's width be the same 
as <code>standard</code>; whether its height is 
automatically scaled depends on <code>scale</code>.
When it is &quot;height&quot;, 
let x's height be the same as <code>standard</code>; whether
its width is automatically scaled 
depends on <code>scale</code>. When it is  &quot;all&quot; (or &quot;both&quot;), 
the default, 
let x's width and height
be the same as <code>standard</code>. When it is two number 
linked with a &quot;_&quot;, it means resizing a according to 
b's width and height multiplied. For example, 
if it is &quot;3_2&quot; and b's width and height are 50, 70, then 
the result's width and height are 50 * 3 = 150, 
70 * 2 = 140. Forms like &quot;_2&quot; or &quot;3_&quot; are also accepted.</p>
</td></tr>
<tr><td><code id="resize_to_standard_+3A_scale">scale</code></td>
<td>
<p>Default is TRUE. It is only used when 
only one of width and height is to 
be modified. This parameter 
decides whether the image is automatically scaled.</p>
</td></tr>
</table>

<hr>
<h2 id='rotatexy'>Rotation Transformation</h2><span id='topic+rotatexy'></span>

<h3>Description</h3>

<p>A2 (output) is the result of rotating A1 (input) 
around a point.
Note: the two shapes look 
the same (though with different angles) 
only when <code>ggplot2::coord_fixed()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotatexy(
  x,
  angle = pi/4,
  xmiddle = 0,
  ymiddle = 0,
  f = NULL,
  group = TRUE,
  todf = TRUE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rotatexy_+3A_x">x</code></td>
<td>
<p>the input. It can be a data frame, matrix, tibble object, 
or a list of 
these kinds of objects. Each object must have exactly 2 columns 
and must be numeric without NA.
If it has more than 2 columns, only the first 2 columns 
will be used.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_angle">angle</code></td>
<td>
<p>default is pi/4. The rotation angle in radian.
Note: &quot;radian = degree * pi / 180&quot;. Its length can be 
larger than 1.
The rotation direction is anti-clockwise.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_xmiddle">xmiddle</code></td>
<td>
<p>the x coordinates of rotation centers.
Its length can be 
larger than 1.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_ymiddle">ymiddle</code></td>
<td>
<p>the y coordinates of rotation centers.
Its length can be 
larger than 1.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_f">f</code></td>
<td>
<p>argument passed to <code>split</code> to divide a data frame 
into a list of data frames. It should be a vector whose length is 
equal to the number of rows of x (if x is a data frame).</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_group">group</code></td>
<td>
<p>default is TRUE. It indicates 
whether to add a 3rd column named 
&quot;g&quot; to label the group number of each group of points. It is useful 
when using <code>aes(...group=g)</code> with 'ggplot2'.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE. It indicates whether to 
combine the output (a list) into a data frame.</p>
</td></tr>
<tr><td><code id="rotatexy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>todf = TRUE</code>, the output will be a data frame
with coordinates of possibly several polygons, otherwise, 
it will be a list of data frames. Data frames have 2 columns
named &quot;x&quot; and &quot;y&quot;, and if <code>group = TRUE</code>, a third column 
named &quot;g&quot; is added indicating group numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat1=data.frame(x=c(0, 4, 4, 0), y=c(0, 0, 2, 2))
dat2=data.frame(x=c(5, 6, 6, 5), y=c(4, 4, 8, 8))
dat3=rotatexy(list(dat1, dat2), angle=c(pi, pi/4), 
	xmiddle=c(0, 5), ymiddle=c(0, 4), todf=TRUE)
ggplot()+
	coord_fixed()+
	geom_polygon(data=dat1, aes(x=x, y=y), fill="red", alpha=0.2)+
	geom_polygon(data=dat2, aes(x=x, y=y), fill="blue", alpha=0.2)+
	geom_polygon(show.legend=FALSE, data=dat3, 
		aes(x=x, y=y, group=g, fill=factor(g)), alpha=0.2)
</code></pre>

<hr>
<h2 id='round_text'>Converting Numeric Values into Characters with the Same Digits</h2><span id='topic+round_text'></span>

<h3>Description</h3>

<p>This simple function is to facilitate something like 
decimal horizontal adjustment 
which demands each value has the 
same digits after the decimal point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_text(x, digits = 2, na = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="round_text_+3A_x">x</code></td>
<td>
<p>a vector of numeric values.</p>
</td></tr>
<tr><td><code id="round_text_+3A_digits">digits</code></td>
<td>
<p>digits which is to be passed 
to <code>round</code>. It should not be smaller than 0.</p>
</td></tr>
<tr><td><code id="round_text_+3A_na">na</code></td>
<td>
<p>how to show NAs. The default is 
to show &quot; NA&quot;, however, you can change it 
to &quot;NA&quot; or simply <code>NA</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>v=c(3, 3.1, 3.456, 3.452, 3.77, NA, 0, 10.56332)
res=round_text(v, 2, na=NA)
</code></pre>

<hr>
<h2 id='scale_free'>Scale values into a Certain Location</h2><span id='topic+scale_free'></span>

<h3>Description</h3>

<p>A simple function to put numeric values into 
a certain interval. Suppose you have 
20, 60, 80, 100, and you want them to be in the 
interval of [0, 1], so you can get 0, 0.5, 0.75, 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_free(
  x,
  left = 0,
  right = 1,
  reverse = FALSE,
  xmin = NULL,
  xmax = NULL,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale_free_+3A_x">x</code></td>
<td>
<p>a numeric vector or a numeric matrix, 
data frame, tibble object.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_left">left</code></td>
<td>
<p>the smallest value of the the interval. 
If <code>x</code> has n columns, then <code>left</code>
is expected to 
be of length n. However, if it is shorter, it will be 
repeated to reach that length.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_right">right</code></td>
<td>
<p>the largest value of the the interval. 
If <code>x</code> has n columns, then <code>right</code>
is expected to 
be of length n. However, if it is shorter, it will be 
repeated to reach that length.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_reverse">reverse</code></td>
<td>
<p>whether to assign values in a 
reverse way. Default is FALSE. 
If <code>x</code> has n columns, then <code>reverse</code>
is expected to 
be of length n. However, if it is shorter, it will be 
repeated to reach that length.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_xmin">xmin</code></td>
<td>
<p>the min value. Default is NULL, 
which means use the min value of <code>x</code>. However, 
sometimes the min value of <code>x</code> may not be the 
true min value. Suppose the two scores of a 
100-point test are 59, 87, then the true min score is 0 
and the true max score is 100. Thus you must 
add <code>xmin = 0, xmax = 100</code>. 
If <code>reverse = TRUE</code> (that is, 0 is better than 100), 
also add <code>xmin = 0, xmax = 100</code>.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_xmax">xmax</code></td>
<td>
<p>the same meaning as <code>xmin</code>, 
but for max value.</p>
</td></tr>
<tr><td><code id="scale_free_+3A_na.rm">na.rm</code></td>
<td>
<p>used by <code>min</code> and <code>max</code>. 
Default is FALSE.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>y=scale_free(c(-1, 0, 2))
y=scale_free(c(-1, 0, 2), rev=TRUE)
#
# x is a data frame.
x=data.frame(
	c(-1, 0, 0, 0, 2), c(-1, 0, 0, 0, 2), 
	c(-2, 0, 2, 4, 6), c(-2, 0, 2, 4, 6)
)
y=scale_free(x, 
	left=0, right=10, 
	reverse=c(FALSE, TRUE, FALSE, TRUE)
)
y=scale_free(x, 
	left=c(0, 0, 100, 100), right=c(10, 100, 200, 200), 
	reverse=c(FALSE, TRUE, FALSE, TRUE)
)
</code></pre>

<hr>
<h2 id='shading_raster'>Create a Shading Raster with a Palette</h2><span id='topic+shading_raster'></span>

<h3>Description</h3>

<p>The function is a simple wrapper of 
<code>scales::col_numeric</code>.
The function creates a matrix of colors 
that can be used to draw a shading rectangle.
There are 2 ways to use the function, see 
the following parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shading_raster(
  nr = NULL,
  nc = NULL,
  middle = NULL,
  palette = c("blue", "red"),
  mat = NULL,
  FUN = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shading_raster_+3A_nr">nr</code></td>
<td>
<p>method 1 to use 
this function is to use <code>nr</code>, <code>nc</code>, 
<code>middle</code>. Suppose there is a matrix 
with <code>nr</code> rows and <code>nc</code> columns.
A cell whose position in the matrix is designated 
by <code>middle</code>. Then, this cell gets the first 
color of <code>palette</code>, and other cells get shading 
colors according to their distances between them 
and <code>middle</code>. Method 2 to use this 
function is to use <code>mat</code>. The biggest cell 
gets the first color and other cells get shading colors.</p>
</td></tr>
<tr><td><code id="shading_raster_+3A_nc">nc</code></td>
<td>
<p>see <code>nr</code>.</p>
</td></tr>
<tr><td><code id="shading_raster_+3A_middle">middle</code></td>
<td>
<p>see <code>nr</code>. The parameter 
should be a length 2 vector designating the 
row number and column number of a cell.</p>
</td></tr>
<tr><td><code id="shading_raster_+3A_palette">palette</code></td>
<td>
<p>two or more colors used to make 
shading colors.</p>
</td></tr>
<tr><td><code id="shading_raster_+3A_mat">mat</code></td>
<td>
<p>see <code>nr</code>.</p>
</td></tr>
<tr><td><code id="shading_raster_+3A_fun">FUN</code></td>
<td>
<p>the default NULL makes the colors 
distributed in a linear way. However, <code>FUN</code>
can be a single parameter function which 
transforms the numeric values, such as 
<code>log</code>, <code>sqrt</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Use method 1.
r=shading_raster(nr=31, nc=60, middle=c(10, 55), 
	palette=c("darkorange", "red", "purple"))
ggplot()+xlim(0, 8)+ylim(0, 6)+
	annotation_raster(r, xmin=-Inf, xmax=Inf, 
	ymin=-Inf, ymax=Inf, interpolate=TRUE)
 # Use method 2.
r=matrix(c(
	1, 2, 3, 4, 5, 6, 7, 8, 
	1, 2, 3, 4, 5, 6, 7, 8, 
	1, 1, 1, 1, 1, 1, 1, 1), 
	nrow=3, byrow=TRUE)
r=shading_raster(mat=r, palette=c("green", "blue"))
</code></pre>

<hr>
<h2 id='showcolor'>Show a Color Palette</h2><span id='topic+showcolor'></span>

<h3>Description</h3>

<p>Simple function to show colors. NOTE: 
do not add <code>coord_flip()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showcolor(x, label_size = 15, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="showcolor_+3A_x">x</code></td>
<td>
<p>a character vector of colors.</p>
</td></tr>
<tr><td><code id="showcolor_+3A_label_size">label_size</code></td>
<td>
<p>size of text on 
x-axis to show color names.</p>
</td></tr>
<tr><td><code id="showcolor_+3A_...">...</code></td>
<td>
<p>other arguments passed to 
<code>geom_bar</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># A palette used by David Hockney
co=c("#833822", "#C03800", "#D3454C", 
	"#DC6A30", "#F29856", "#FEEF70", 
	"#A5D56D", "#16D670", "#00932F", 
	"#03592E", "#04B7B0", "#007BA9", 
	"#EC46BF", "#6A2C8F"
)
showcolor(co, label_size=10)
</code></pre>

<hr>
<h2 id='spathxy'>Reordering Points to Form a &quot;s&quot; Shape</h2><span id='topic+spathxy'></span>

<h3>Description</h3>

<p>This is a convenient function to generate points with
x and y coordinates (which form a 2-column data.frame).
It is much like <code>expand.grid</code>. The points generated 
by <code>expand.grid</code> always in this &quot;s&quot; order: the bottom 
line, form left to right, and the second line, from left to right.
However, <code>spathxy</code> allows you choose the order you 
want. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spathxy(
  x,
  y,
  first = "right",
  second = "top",
  change_line = FALSE,
  stringsAsFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="spathxy_+3A_x">x</code></td>
<td>
<p>a vector of values to be paired with y.</p>
</td></tr>
<tr><td><code id="spathxy_+3A_y">y</code></td>
<td>
<p>a vector of values to be paired with x.</p>
</td></tr>
<tr><td><code id="spathxy_+3A_first">first</code></td>
<td>
<p>the first direction. It may be one of 
&quot;right&quot;, &quot;left&quot;, &quot;top&quot;, &quot;bottom&quot;. Default is &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="spathxy_+3A_second">second</code></td>
<td>
<p>the second direction. It may be one of 
&quot;right&quot;, &quot;left&quot;, &quot;top&quot;, &quot;bottom&quot;. Default is &quot;top&quot;.</p>
</td></tr>
<tr><td><code id="spathxy_+3A_change_line">change_line</code></td>
<td>
<p>tail-to-tail or tail-to-head. Default 
is FALSE which means tail-to-tail. See examples.</p>
</td></tr>
<tr><td><code id="spathxy_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>to be passed to <code>data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>always a 3-column data frame. Column x 
and y are coordinates of points; column index contains 
the index number of points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
#
# dat1 is generated by expand.grid
# Note the difference between dat1 and dat2.
# dat3 is the same as dat1.
dat1=expand.grid(1: 3, 1: 7)
colnames(dat1)=c("x", "y")
dat2=spathxy(1: 3, 1: 7, 
	change_line=FALSE, first="right", second="top")
dat3=spathxy(1: 3, 1: 7, 
	change_line=TRUE, first="right", second="top")
#
mycolor=rainbow(nrow(dat1), end=0.6)
ggplot(dat1)+geom_path(aes(x, y), color=mycolor, size=3)
ggplot(dat2)+geom_path(aes(x, y), color=mycolor, size=3)
ggplot(dat3)+geom_path(aes(x, y), color=mycolor, size=3)
</code></pre>

<hr>
<h2 id='stretchxy'>Stretching Transformation</h2><span id='topic+stretchxy'></span>

<h3>Description</h3>

<p>A2 (output) is the result of enlarging (or shrinking) A1 (input) 
in x dimension and y dimension.
Note: the two shapes manifest enlarging or 
shrinking effect 
only when <code>ggplot2::coord_fixed()</code> is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stretchxy(
  x,
  xlarge = 2,
  ylarge = 2,
  f = NULL,
  group = TRUE,
  todf = TRUE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stretchxy_+3A_x">x</code></td>
<td>
<p>the input. It can be a data frame, matrix, tibble object, 
or a list of 
these kinds of objects. Each object must have exactly 2 columns 
and must be numeric without NA.
If it has more than 2 columns, only the first 2 columns 
will be used.</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_xlarge">xlarge</code></td>
<td>
<p>the enlarging extent in x dimension.
If it is smaller than 1, the shape will be shrinking.</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_ylarge">ylarge</code></td>
<td>
<p>the enlarging extent in y dimension.
If it is smaller than 1, the shape will be shrinking.</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_f">f</code></td>
<td>
<p>argument passed to <code>split</code> to divide a data frame 
into a list of data frames. It should be a vector whose length is 
equal to the number of rows of x (if x is a data frame).</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_group">group</code></td>
<td>
<p>default is TRUE. It indicates 
whether to add a 3rd column named 
&quot;g&quot; to label the group number of each group of points. It is useful 
when using <code>aes(...group=g)</code> with 'ggplot2'.</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_todf">todf</code></td>
<td>
<p>default is TRUE. It indicates whether to 
combine the output (a list) into a data frame.</p>
</td></tr>
<tr><td><code id="stretchxy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>todf = TRUE</code>, the output will be a data frame
with coordinates of possibly several polygons, otherwise, 
it will be a list of data frames. Data frames have 2 columns
named &quot;x&quot; and &quot;y&quot;, and if <code>group = TRUE</code>, a third column 
named &quot;g&quot; is added indicating group numbers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
dat1=data.frame(x=c(0, 1, 1), y=c(0, 0, 1))
dat2=data.frame(x=c(4, 5, 5, 4), y=c(0, 0, 3, 3))
dat3=stretchxy(list(dat1, dat2), xlarge=3, ylarge=c(3, 2), todf=TRUE)
ggplot()+coord_fixed()+
	geom_polygon(data=dat1, aes(x, y), fill="red", alpha=0.3)+
	geom_polygon(data=dat2, aes(x, y), fill="blue", alpha=0.3)+
	geom_polygon(data=dat3, aes(x, y, fill=g, group=g), fill="blue", alpha=0.3)	
</code></pre>

<hr>
<h2 id='sunshinexy'>Generating Lines Which Link One Points to Many</h2><span id='topic+sunshinexy'></span>

<h3>Description</h3>

<p>Suppose there is a middle point a, this function 
simultaneous generates points on lines that start 
from a to other points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sunshinexy(
  x = 0,
  y = 0,
  outer = data.frame(1, 1),
  n = 10,
  delete_n = 0,
  distance = FALSE,
  checks = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sunshinexy_+3A_x">x</code></td>
<td>
<p>the x coordinate of the middle points. 
It should be of length 1.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_y">y</code></td>
<td>
<p>the y coordinate of the middle points. 
It should be of length 1.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_outer">outer</code></td>
<td>
<p>the other points. It can be a data frame, 
It must have exactly 2 columns 
and must be numeric without NA.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_n">n</code></td>
<td>
<p>default is 10. The number of points per line.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_delete_n">delete_n</code></td>
<td>
<p>default is 0. The number of points to be deleted. 
Suppose a line has p1, p2, p3, p4, p5 points on it with 
p1 as the starting point. if delete_n is 2, then p1 and p2 
will be deleted. Note: <code>n - delete_n</code> 
must be larger than 1.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_distance">distance</code></td>
<td>
<p>default is FALSE. If it is TRUE, a column 
named &quot;distance&quot; is added which indicates the distances from 
the middle point to other points.</p>
</td></tr>
<tr><td><code id="sunshinexy_+3A_checks">checks</code></td>
<td>
<p>default is TRUE. It indicates whether 
to check input validity. Do not turn it off unless you are sure 
that the input is OK.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame that has 3 columns.
The first and second columns are 
named &quot;x&quot; and &quot;y&quot;, the third column is  
named &quot;g&quot; indicating group numbers.
If <code>distance = TRUE</code>, a fourth column is added 
which indicates the distances from 
the middle point to other points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ggplot2)
p=c(1, 1, 0, -1, -1, -1, 0, 1)
q=c(0, 1, 1, 1, 0, -1, -1, -1)
pq=data.frame(cbind(p, q))
dat=sunshinexy(outer=pq, n=20, delete_n=5, distance=TRUE)
ggplot()+coord_fixed()+theme_void()+
	geom_point(data=pq, aes(p, q), size=4)+
	geom_line(show.legend=FALSE, data=dat, aes(x, y, group=g, color=distance), size=2)+
	scale_color_continuous(low="blue", high="red")
</code></pre>

<hr>
<h2 id='textgif'>Simple Text &quot;.gif&quot; File</h2><span id='topic+textgif'></span>

<h3>Description</h3>

<p>This is a wrapper of functions in package
ggfittext and magick. The output is 
a &quot;.gif&quot; with changing texts and colors.
Characters are automatically enlarged or 
shrunk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>textgif(
  text,
  text_color = NULL,
  bg_color = NULL,
  reflow = FALSE,
  width = 200,
  height = 100,
  family = "SimHei",
  fontface = 1,
  fps = 2,
  output = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="textgif_+3A_text">text</code></td>
<td>
<p>must be a character vector.</p>
</td></tr>
<tr><td><code id="textgif_+3A_text_color">text_color</code></td>
<td>
<p>colors of the texts. Its 
length must be the same as that of 
<code>text</code>.</p>
</td></tr>
<tr><td><code id="textgif_+3A_bg_color">bg_color</code></td>
<td>
<p>background color 
of the texts. It should have the same 
length as <code>text</code>.</p>
</td></tr>
<tr><td><code id="textgif_+3A_reflow">reflow</code></td>
<td>
<p>default is FALSE. If it is 
TRUE, <code>ggfittext::geom_fit_text</code> will 
automatically separate characters into 
several lines. However, you can separate 
lines manually by using line 
break.</p>
</td></tr>
<tr><td><code id="textgif_+3A_width">width</code></td>
<td>
<p>the width of the 
final gif object. Default is 200.
NOTE: how texts are adjusted in the text box 
depends on the values of width and height.</p>
</td></tr>
<tr><td><code id="textgif_+3A_height">height</code></td>
<td>
<p>the height of the 
final gif object. Default is 100.</p>
</td></tr>
<tr><td><code id="textgif_+3A_family">family</code></td>
<td>
<p>default is &quot;SimHei&quot; so that 
Chinese characters can be shown. However, 
some computers may not be able to use this 
family. And, this family ignores fontface.
For Latin words, the built-in families 
are &quot;serif&quot;, &quot;sans&quot; and &quot;mono&quot;, and more can 
be found by typing &quot;?Hershey&quot;.</p>
</td></tr>
<tr><td><code id="textgif_+3A_fontface">fontface</code></td>
<td>
<p>1 (default) for plain, 
2 for bold, 3 for italic, 4 for bold italic.</p>
</td></tr>
<tr><td><code id="textgif_+3A_fps">fps</code></td>
<td>
<p>the larger the faster. It should 
be a factor of 100, say, 2 (default), 4, 5, 10, 
rather than 3, 6, 7.</p>
</td></tr>
<tr><td><code id="textgif_+3A_output">output</code></td>
<td>
<p>if it is NULL (default), 
an object is created. Otherwise, object will not 
only be created but also be saved with a 
file name (&quot;.gif&quot;) represented by this argument.</p>
</td></tr>
<tr><td><code id="textgif_+3A_...">...</code></td>
<td>
<p>extra arguments used by 
<code>ggfittext::geom_fit_text</code>, 
e. g., angle (0 to 360), lineheight.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
mytext=c("AAA", "BBB", "CCC")
color1=c("orange", "red", "white")
color2=c("black", "blue", "green")
g1=textgif(mytext, text_color=color1, bg_color=color2, 
	width=180, height=120, fps=2, family="serif")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
