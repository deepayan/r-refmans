<!DOCTYPE html><html lang="en"><head><title>Help for package adapt4pv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adapt4pv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adapt4pv-package'><p>Adaptive approaches for signal detection in PharmacoVigilance</p></a></li>
<li><a href='#adapt_bic'><p>fit an adaptive lasso with adaptive weights derived from lasso-bic</p></a></li>
<li><a href='#adapt_cisl'><p>fit an adaptive lasso with adaptive weights derived from CISL</p></a></li>
<li><a href='#adapt_cv'><p>fit an adaptive lasso with adaptive weights derived from lasso-cv</p></a></li>
<li><a href='#adapt_univ'><p>fit an adaptive lasso with adaptive weights derived from univariate coefficients</p></a></li>
<li><a href='#cisl'><p>Class Imbalanced Subsampling Lasso</p></a></li>
<li><a href='#data_PV'><p>Simulated data for the adapt4pv package</p></a></li>
<li><a href='#est_ps_bic'><p>propensity score estimation in high dimension with automated covariates selection using lasso-bic</p></a></li>
<li><a href='#est_ps_hdps'><p>propensity score estimation in high dimension with automated covariates selection using hdPS</p></a></li>
<li><a href='#est_ps_xgb'><p>propensity score estimation in high dimension using gradient tree boosting</p></a></li>
<li><a href='#lasso_bic'><p>fit a lasso regression and use standard BIC for variable selection</p></a></li>
<li><a href='#lasso_cv'><p>wrap function for <code>cv.glmnet</code></p></a></li>
<li><a href='#lasso_perm'><p>fit a lasso regression and use standard permutation of the outcome for variable selection</p></a></li>
<li><a href='#ps_adjust'><p>adjustment on propensity score</p></a></li>
<li><a href='#ps_adjust_one'><p>adjustment on propensity score for one drug exposure</p></a></li>
<li><a href='#ps_pond'><p>weihting on propensity score</p></a></li>
<li><a href='#ps_pond_one'><p>weihting on propensity score for one drug exposure</p></a></li>
<li><a href='#summary_stat'><p>Summary statistics for main adapt4pv package functions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Adaptive Approaches for Signal Detection in Pharmacovigilance</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), Matrix (&ge; 1.0-6), glmnet (&ge; 3.0-2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>speedglm, xgboost, doParallel, foreach</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of several pharmacovigilance signal detection methods based on adaptive lasso. Additional lasso-based and propensity score-based signal detection approaches are also supplied. See Courtois et al &lt;<a href="https://doi.org/10.1186%2Fs12874-021-01450-3">doi:10.1186/s12874-021-01450-3</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Emeline Courtois [cre],
  Ismaïl Ahmed [aut],
  Hervé Perdry [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emeline Courtois &lt;courtoise@iarc.who.int&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-30 07:26:33 UTC; emeli</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-30 10:50:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='adapt4pv-package'>Adaptive approaches for signal detection in PharmacoVigilance</h2><span id='topic+adapt4pv-package'></span>

<h3>Description</h3>

<p>This package fits adaptive lasso approaches in high dimension for signal detection in
pharmacovigilance.
In addition to classical implementations found in the litterature, we implemented
two approaches particularly appropriated to variable selections framework, which
is the one that stands in pharmacovigilance.
We also supply in this package signal detection approaches based on lasso regression
and propensity score in high dimension.
</p>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer:
Emeline Courtois &lt;emeline.courtois@inserm.fr&gt;
</p>

<hr>
<h2 id='adapt_bic'>fit an adaptive lasso with adaptive weights derived from lasso-bic</h2><span id='topic+adapt_bic'></span>

<h3>Description</h3>

<p>Fit a first lasso regression and use Bayesian Information Criterion to determine '
adaptive weights (see <code>lasso_bic</code> function for more details),
then run an adaptive lasso with this penalty weighting.
BIC is used for the adaptive lasso for variable selection.
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
Depends on the <code>glmnet</code> and <code>relax.glmnet</code> function from the package
<code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_bic(x, y, gamma = 1, maxp = 50, path = TRUE, betaPos = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_bic_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_gamma">gamma</code></td>
<td>
<p>Tunning parameter to defined the penalty weights. See details below.
Default is set to 1.</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_maxp">maxp</code></td>
<td>
<p>A limit on how many relaxed coefficients are allowed.
Default is 50, in <code>glmnet</code> option default is 'n-3', where 'n' is the sample size.</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_path">path</code></td>
<td>
<p>Since <code>glmnet</code> does not do stepsize optimization, the Newton
algorithm can get stuck and not converge, especially with relaxed fits.
With <code>path=TRUE</code>, each relaxed fit on a particular set of variables
is computed pathwise using the original sequence of lambda values
(with a zero attached to the end). Default is <code>path=TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_bic_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code> from package
<code>glmnet</code> other than <code>penalty.factor</code>,
<code>family</code>, <code>maxp</code> and <code>path</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive weight for a given covariate i is defined by
</p>
<p style="text-align: center;"><code class="reqn">w_i = 1/|\beta^{BIC}_i|^\gamma</code>
</p>
<p> where
<code class="reqn">\beta^{BIC}_i</code> is the NON PENALIZED regression coefficient
associated to covariate <code class="reqn">i</code> obtained with lasso-bic.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"adaptive"</code>.
</p>
<table role = "presentation">
<tr><td><code>aws</code></td>
<td>
<p>Numeric vector of penalty weights derived from lasso-bic.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Character, indicates which criterion is used with the
adaptive lasso for variable selection. For <code>adapt_bic</code> function, <code>criterion</code>
is &quot;bic&quot;.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the adaptive lasso.
If <code>criterion</code> = &quot;cv&quot; the regression coefficients are PENALIZED, if
<code>criterion</code> = &quot;bic&quot; the regression coefficients are UNPENALIZED.
Length equal to nvars. Could be NA if adaptive weights are all equal to infinity.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected
with this adaptive approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in <code>beta</code>.
Covariates are ordering according to the p-values (two-sided if <code>betaPos = FALSE</code> ,
one-sided if <code>betaPos = TRUE</code>) in the classical multiple logistic regression
model that minimzes the BIC in the adaptive lasso.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
ab &lt;- adapt_bic(x = drugs, y = ae, maxp = 50)


</code></pre>

<hr>
<h2 id='adapt_cisl'>fit an adaptive lasso with adaptive weights derived from CISL</h2><span id='topic+adapt_cisl'></span>

<h3>Description</h3>

<p>Compute the CISL procedure (see <code>cisl</code> for more details) to determine
adaptive penalty weights, then run an adaptive lasso with this penalty weighting.
BIC is used for the adaptive lasso for variable selection.
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
Depends on the <code>glmnet</code> function from the package <code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_cisl(
  x,
  y,
  cisl_nB = 100,
  cisl_dfmax = 50,
  cisl_nlambda = 250,
  cisl_ncore = 1,
  maxp = 50,
  path = TRUE,
  betaPos = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_cisl_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_cisl_nb">cisl_nB</code></td>
<td>
<p><code>nB</code> option in <code>cisl</code> function. Default is 100.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_cisl_dfmax">cisl_dfmax</code></td>
<td>
<p><code>dfmax</code> option in <code>cisl</code> function. Default is 50.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_cisl_nlambda">cisl_nlambda</code></td>
<td>
<p><code>nlambda</code> option in <code>cisl</code> function. Default is 250.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_cisl_ncore">cisl_ncore</code></td>
<td>
<p><code>ncore</code> option in <code>cisl</code> function. Default is 1.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_maxp">maxp</code></td>
<td>
<p>A limit on how many relaxed coefficients are allowed.
Default is 50, in <code>glmnet</code> option default is 'n-3', where 'n' is the sample size.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_path">path</code></td>
<td>
<p>Since <code>glmnet</code> does not do stepsize optimization, the Newton
algorithm can get stuck and not converge, especially with relaxed fits. With <code>path=TRUE</code>,
each relaxed fit on a particular set of variables is computed pathwise using the original sequence
of lambda values (with a zero attached to the end). Default is <code>path=TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_cisl_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code>
from package <code>glmnet</code> other than <code>penalty.factor</code>,
<code>family</code>, <code>maxp</code> and <code>path</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The CISL procedureis first implemented with its default value except for
<code>dfmax</code> and <code>nlambda</code> through parameters <code>cisl_dfmax</code> and
<code>cisl_nlambda</code>.
In addition, the <code>betaPos</code> parameter is set to FALSE in <code>cisl</code>.
For each covariate <code class="reqn">i</code>, <code>cisl_nB</code> values of the CISL quantity <code class="reqn">\tau_i</code>
are estimated.
The adaptive weight for a given covariate <code class="reqn">i</code> is defined by
</p>
<p style="text-align: center;"><code class="reqn">w_i = 1- 1/cisl_nB \sum_{b=1, .., cisl_nB} 1 [ \tau^b_i &gt;0  ]</code>
</p>

<p>If <code class="reqn">\tau_i</code> is the null vector, the associated adaptve weights in infinty.
If <code class="reqn">\tau_i</code> is always positive, rather than &quot;forcing&quot; the variable into
the model, we set the corresponding adaptive weight to 1/<code>cisl_nB</code>.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"adaptive"</code>.
</p>
<table role = "presentation">
<tr><td><code>aws</code></td>
<td>
<p>Numeric vector of penalty weights derived from CISL.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Character, indicates which criterion is used with the
adaptive lasso for variable selection. For <code>adapt_cisl</code> function,
<code>criterion</code> is &quot;bic&quot;.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the adaptive lasso.
If <code>criterion</code> = &quot;cv&quot; the regression coefficients are PENALIZED, if
<code>criterion</code> = &quot;bic&quot; the regression coefficients are UNPENALIZED.
Length equal to nvars. Could be NA if adaptive weights are all equal to infinity.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected
with this adaptive approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in <code>beta</code>.
Covariates are ordering according to the p-values (two-sided if <code>betaPos = FALSE</code> ,
one-sided if <code>betaPos = TRUE</code>) in the classical multiple logistic regression
model that minimzes the BIC in the adaptive lasso.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
acisl &lt;- adapt_cisl(x = drugs, y = ae, cisl_nB = 50, maxp=10)


</code></pre>

<hr>
<h2 id='adapt_cv'>fit an adaptive lasso with adaptive weights derived from lasso-cv</h2><span id='topic+adapt_cv'></span>

<h3>Description</h3>

<p>Fit a first lasso regression with cross-validation to determine adaptive weights.
Run a cross-validation to determine an optimal lambda.
Two options for implementing cross-validation for the adaptive lasso are possible through the <code>type_cv</code> parameter (see bellow).
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
The cross-validation criterion used is deviance.
Depends on the <code>cv.glmnet</code> function from the package <code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_cv(
  x,
  y,
  gamma = 1,
  nfolds = 5,
  foldid = NULL,
  type_cv = "proper",
  betaPos = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_cv_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_gamma">gamma</code></td>
<td>
<p>Tunning parameter to defined the penalty weights. See details below.
Default is set to 1.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds - default is 5. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds=3</code>.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector of values between 1 and <code>nfolds</code>
identifying what fold each observation is in. If supplied, <code>nfolds</code> can
be missing.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_type_cv">type_cv</code></td>
<td>
<p>Character, indicates which implementation of cross-validation is performed for the adaptive lasso:  a &quot;naive&quot; one,
where adaptive weights obtained on the full data are used, and a &quot;proper&quot; one, where adaptive weights are calculated for each training sets.
Could be either &quot;naive&quot; or &quot;proper&quot;.
Default is &quot;proper&quot;.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_cv_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code>  from package <code>glmnet</code> other than <code>nfolds</code>, <code>foldid</code>,
<code>penalty.factor</code>, <code>standardize</code>, <code>intercept</code>  and <code>family</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive weight for a given covariate i is defined by
</p>
<p style="text-align: center;"><code class="reqn">w_i = 1/|\beta^{CV}_i|^\gamma</code>
</p>
<p> where
<code class="reqn">\beta^{CV}_i</code> is the PENALIZED regression coefficient associated
to covariate <code class="reqn">i</code> obtained with cross-validation.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"adaptive"</code>.
</p>
<table role = "presentation">
<tr><td><code>aws</code></td>
<td>
<p>Numeric vector of penalty weights derived from cross-validation.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Character, indicates which criterion is used with the
adaptive lasso for variable selection. For <code>adapt_cv</code> function, <code>criterion</code>
is &quot;cv&quot;.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the adaptive lasso.
If <code>criterion</code> = &quot;cv&quot; the regression coefficients are PENALIZED, if
<code>criterion</code> = &quot;bic&quot; the regression coefficients are UNPENALIZED.
Length equal to nvars. Could be NA if adaptive weights are all equal to infinity.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected
with this adaptive approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in <code>beta</code>.
Covariates are ordering according to magnitude of their regression
coefficients absolute value in the adaptive lasso.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
acv &lt;- adapt_cv(x = drugs, y = ae, nfolds = 5)


</code></pre>

<hr>
<h2 id='adapt_univ'>fit an adaptive lasso with adaptive weights derived from univariate coefficients</h2><span id='topic+adapt_univ'></span>

<h3>Description</h3>

<p>Compute odd-ratios between each covariate of <code>x</code> and <code>y</code> then derived
adaptive weights to incorporate in an adaptive lasso.
BIC or cross-validation could either be used for the adaptive lasso for variable selection.
Two options for implementing cross-validation for the adaptive lasso are possible through the <code>type_cv</code> parameter (see bellow).
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
The cross-validation criterion used is deviance.
Depends on the <code>glmnet</code> and <code>relax.glmnet</code> function from the package
<code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_univ(
  x,
  y,
  gamma = 1,
  criterion = "bic",
  maxp = 50,
  path = TRUE,
  nfolds = 5,
  foldid = NULL,
  type_cv = "proper",
  betaPos = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adapt_univ_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_gamma">gamma</code></td>
<td>
<p>Tunning parameter to defined the penalty weights. See details below.
Default is set to 1.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_criterion">criterion</code></td>
<td>
<p>Character, indicates which criterion is used with the
adaptive lasso for variable selection. Could be either &quot;bic&quot; or &quot;cv&quot;.
Default is &quot;bic&quot;</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_maxp">maxp</code></td>
<td>
<p>Used only if <code>criterion</code> = &quot;bic&quot;, ignored if <code>criterion</code> = &quot;cv&quot;.
A limit on how many relaxed coefficients are allowed. Default is 50, in <code>glmnet</code>
option default is 'n-3', where 'n' is the sample size.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_path">path</code></td>
<td>
<p>Used only if <code>criterion</code> = &quot;bic&quot;, ignored if <code>criterion</code> = &quot;cv&quot;.
Since <code>glmnet</code> does not do stepsize optimization, the Newton
algorithm can get stuck and not converge, especially with relaxed fits.
With <code>path=TRUE</code>, each relaxed fit on a particular set of variables
is computed pathwise using the original sequence of lambda values
(with a zero attached to the end). Default is <code>path=TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_nfolds">nfolds</code></td>
<td>
<p>Used only if <code>criterion</code> = &quot;cv&quot;, ignored if <code>criterion</code> = &quot;bic&quot;.
Number of folds - default is 5. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds=3</code>.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_foldid">foldid</code></td>
<td>
<p>Used only if <code>criterion</code> = &quot;cv&quot;, ignored if <code>criterion</code> = &quot;bic&quot;.
An optional vector of values between 1 and <code>nfolds</code>
identifying what fold each observation is in. If supplied, <code>nfolds</code> can
be missing.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_type_cv">type_cv</code></td>
<td>
<p>Used only if <code>criterion</code> = &quot;cv&quot;, ignored if <code>criterion</code> = &quot;bic&quot;.
Character, indicates which implementation of cross-validation is performed for the adaptive lasso:  a &quot;naive&quot; one,
where adaptive weights obtained on the full data are used, and a &quot;proper&quot; one, where adaptive weights are calculated for each training sets.
Could be either &quot;naive&quot; or &quot;proper&quot;.
Default is &quot;proper&quot;.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="adapt_univ_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code> from package
<code>glmnet</code> other than <code>family</code>, <code>maxp</code>, <code>standardize</code>, <code>intercept</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive weight for a given covariate i is defined by
</p>
<p style="text-align: center;"><code class="reqn">w_i = 1/|\beta^{univ}_i|^\gamma</code>
</p>
<p> where
<code class="reqn">\beta^{univ}_i = log(OR_i)</code>, with
<code class="reqn">OR_i</code> is the odd-ratio associated to covariate <code class="reqn">i</code>
with the outcome.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"adaptive"</code>.
</p>
<table role = "presentation">
<tr><td><code>aws</code></td>
<td>
<p>Numeric vector of penalty weights derived from odds-ratios.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>criterion</code></td>
<td>
<p>Character, same as input. Could be either &quot;bic&quot; or &quot;cv&quot;.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the adaptive lasso.
If <code>criterion</code> = &quot;cv&quot; the regression coefficients are PENALIZED, if
<code>criterion</code> = &quot;bic&quot; the regression coefficients are UNPENALIZED.
Length equal to nvars. Could be NA if adaptive weights are all equal to infinity.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected
with this adaptive approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in <code>beta</code>.
If <code>criterion</code> = &quot;bic&quot;, covariates are ordering according to magnitude of their regression
coefficients absolute value in the adaptive lasso.
If <code>criterion</code> = &quot;bic&quot;, covariates are ordering according to the p-values (two-sided if <code>betaPos = FALSE</code> ,
one-sided if <code>betaPos = TRUE</code>) in the classical multiple logistic regression
model that minimzes the BIC in the adaptive lasso.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
au &lt;- adapt_univ(x = drugs, y = ae, criterion ="cv", nfolds = 3)

</code></pre>

<hr>
<h2 id='cisl'>Class Imbalanced Subsampling Lasso</h2><span id='topic+cisl'></span>

<h3>Description</h3>

<p>Implementation of CISL and the stability selection according to subsampling options.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cisl(
  x,
  y,
  r = 4,
  nB = 100,
  dfmax = 50,
  nlambda = 250,
  nMin = 0,
  replace = TRUE,
  betaPos = TRUE,
  ncore = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cisl_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an
observation vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="cisl_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="cisl_+3A_r">r</code></td>
<td>
<p>Number of control in the CISL sampling. Default is 4.
See details below for other implementations.</p>
</td></tr>
<tr><td><code id="cisl_+3A_nb">nB</code></td>
<td>
<p>Number of sub-samples. Default is 100.</p>
</td></tr>
<tr><td><code id="cisl_+3A_dfmax">dfmax</code></td>
<td>
<p>Corresponds to the maximum size of the models visited with the
lasso (E in the paper). Default is 50.</p>
</td></tr>
<tr><td><code id="cisl_+3A_nlambda">nlambda</code></td>
<td>
<p>Number of lambda values as is <code>glmnet</code> documentation.
Default is 250.</p>
</td></tr>
<tr><td><code id="cisl_+3A_nmin">nMin</code></td>
<td>
<p>Minimum number of events for a covariate to be considered.
Default is 0, all the covariates from <code>x</code> are considered.</p>
</td></tr>
<tr><td><code id="cisl_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement? Default is TRUE.</p>
</td></tr>
<tr><td><code id="cisl_+3A_betapos">betaPos</code></td>
<td>
<p>If <code>betaPos=TRUE</code>, variable selection is based on positive
regression coefficient.
Else, variable selection is based on non-zero regression coefficient.
Default is TRUE.</p>
</td></tr>
<tr><td><code id="cisl_+3A_ncore">ncore</code></td>
<td>
<p>The number of calcul units used for parallel computing.
This has to be set to 1 if the <code>parallel</code> package is not available.
Default is 1.
WARNING: parallel computing is not supported for windows machines!</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CISL is a variation of the stability method adapted to characteristics of pharmacovigilance databases.
Tunning <code>r = 4</code> and <code>replace = TRUE</code> are used to implement our CISL sampling.
For instance, <code>r = NULL</code> and <code>replace = FALSE</code> can be used to
implement the <code class="reqn">n \over 2</code> sampling in Stability Selection.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"cisl"</code>.
</p>
<table role = "presentation">
<tr><td><code>prob</code></td>
<td>
<p>Matrix of dimension nvars x <code>nB</code>.
Quantity compute by CISL for each covariate, for each subsample.</p>
</td></tr>
<tr><td><code>q05</code></td>
<td>
<p>5 <code class="reqn">\%</code> quantile of the CISL quantity for each covariates.
Numeric, length equal to nvars.</p>
</td></tr>
<tr><td><code>q10</code></td>
<td>
<p>10 <code class="reqn">\%</code> quantile of the CISL quantity for each covariates.
Numeric, length equal to nvars.</p>
</td></tr>
<tr><td><code>q15</code></td>
<td>
<p>15 <code class="reqn">\%</code> quantile of the CISL quantity for each covariates.
Numeric, length equal to nvars.</p>
</td></tr>
<tr><td><code>q20</code></td>
<td>
<p>20 <code class="reqn">\%</code> quantile of the CISL quantity for each covariates.
Numeric, length equal to nvars.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ismail Ahmed
</p>


<h3>References</h3>

<p>Ahmed, I., Pariente, A., &amp; Tubert-Bitter, P. (2018). &quot;Class-imbalanced subsampling lasso algorithm for discovering adverse drug reactions&quot;.
<em>Statistical Methods in Medical Research</em>. 27(3), 785–797, <a href="https://doi.org/10.1177/0962280216643116">doi:10.1177/0962280216643116</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
lcisl &lt;- cisl(x = drugs, y = ae, nB = 50)

</code></pre>

<hr>
<h2 id='data_PV'>Simulated data for the adapt4pv package</h2><span id='topic+data_PV'></span><span id='topic+X'></span><span id='topic+Y'></span>

<h3>Description</h3>

<p>Simple simulated data, used to demonstrate the features of
functions from adapt4cv package.
</p>


<h3>Format</h3>


<dl>
<dt>X</dt><dd><p>large sparse and binary matrix with 117160 rows and 300 columns.
Drug matrix exposure: each row corresponds to an individual and
each column corresponds to a drug.</p>
</dd>
<dt>Y</dt><dd><p>large spase and binary vector of length 117160. Indicator of
the presence/absence of an adverse event for ech individual.
Only the first 30 drugs (out of the 300)
are associated with the outcome.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ExamplePvData)


</code></pre>

<hr>
<h2 id='est_ps_bic'>propensity score estimation in high dimension with automated covariates selection using lasso-bic</h2><span id='topic+est_ps_bic'></span>

<h3>Description</h3>

<p>Estimate a propensity score to a given drug exposure by
(i) selecting among other drug covariates in <code>x</code> which ones to
include in the PS estimation model automatically using lasso-bic
approach,
(ii) estimating a score using a classical logistic regression
with the afore selected covariates.
Internal function, not supposed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_ps_bic(idx_expo, x, penalty = rep(1, nvars - 1), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_ps_bic_+3A_idx_expo">idx_expo</code></td>
<td>
<p>Index of the column in <code>x</code> that corresponds to the
drug covariate for which we aim at estimating the PS.</p>
</td></tr>
<tr><td><code id="est_ps_bic_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="est_ps_bic_+3A_penalty">penalty</code></td>
<td>
<p>TEST OPTION penalty weights in the variable selection to
include in the PS.</p>
</td></tr>
<tr><td><code id="est_ps_bic_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code> from package
<code>glmnet</code> other than <code>penalty.factor</code>,
<code>family</code>, <code>maxp</code> and <code>path</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>betaPos</code> option of <code>lasso_bic</code> function is set to
<code>FALSE</code> and <code>maxp</code> is set to 20.
For optimal storage, the returned elements <code>indicator_expo</code> and
<code>score</code> are Matrix with ncol = 1.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps", "bic"</code>.
</p>
<table role = "presentation">
<tr><td><code>expo_name</code></td>
<td>
<p>Character, name of the drug exposure for which the PS was
estimated. Correspond to <code>colnames(x)[idx_expo]</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>indicator_expo</code></td>
<td>
<p>One-column Matrix object.
Indicator of the drug exposure for which the PS was estimated.
Defined by <code>x[, idx_expo]</code>.</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>score_variables</code></td>
<td>
<p>Character vector, names of covariates(s) selected
with the lasso-bic approach to include in the PS estimation model.
Could be empty.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>One-column Matrix object, the estimated score.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
psb2 &lt;- est_ps_bic(idx_expo = 2, x = drugs)
psb2$score_variables #selected variables to include in the PS model of drug_2

</code></pre>

<hr>
<h2 id='est_ps_hdps'>propensity score estimation in high dimension with automated covariates selection using hdPS</h2><span id='topic+est_ps_hdps'></span>

<h3>Description</h3>

<p>Estimate a propensity score to a given drug exposure by
(i) selecting among other drug covariates in <code>x</code> which ones to
include in the PS estimation model automatically using hdPS algorithm,
(ii) estimating a score using a classical logistic regression
with the afore selected covariates.
Internal function, not supposed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_ps_hdps(idx_expo, x, y, keep_total = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_ps_hdps_+3A_idx_expo">idx_expo</code></td>
<td>
<p>Index of the column in <code>x</code> that corresponds to the
drug covariate for which we aim at estimating the PS.</p>
</td></tr>
<tr><td><code id="est_ps_hdps_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="est_ps_hdps_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="est_ps_hdps_+3A_keep_total">keep_total</code></td>
<td>
<p>number of covariates to include in the PS estimation
model according to the hdps algorithm ordering. Default is 20.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compared to the situation of the classic use of hdps
(i) there is only one dimension (the co-exposition matrix)
(ii) no need to expand covariates since they are already binary.
In other words, in our situation hdps consists in the &quot;prioritize covariates&quot;
step from the original algorithm, using Bross formula.
We consider the correction on the interpretation on this formula made
by Richard Wyss (drug epi).
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps", "hdps"</code>.
</p>
<table role = "presentation">
<tr><td><code>expo_name</code></td>
<td>
<p>Character, name of the drug exposure for which the PS was
estimated. Correspond to <code>colnames(x)[idx_expo]</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>indicator_expo</code></td>
<td>
<p>One-column Matrix object. Indicator of the drug
exposure for which the PS was estimated.
Defined by <code>x[, idx_expo]</code>.</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>score_variables</code></td>
<td>
<p>Character vector, names of covariates(s)
selected with the hdPS algorithm to include in the PS estimation model.
Could be empty.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>One-column Matrix object, the estimated score.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>References</h3>

<p>Schneeweiss, S., Rassen, J. A., Glynn, R. J., Avorn, J., Mogun, H., Brookhart, M. A. (2009).
&quot;High-dimensional propensity score adjustment in studies of treatment effects using health care claims data&quot;.
<em>Epidemiology</em>. 20, 512–522, <a href="https://doi.org/10.1097/EDE.0b013e3181a663cc">doi:10.1097/EDE.0b013e3181a663cc</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
pshdps2 &lt;- est_ps_hdps(idx_expo = 2, x = drugs, y = ae, keep_total = 10)
pshdps2$score_variables #selected variables to include in the PS model of drug_2

</code></pre>

<hr>
<h2 id='est_ps_xgb'>propensity score estimation in high dimension using gradient tree boosting</h2><span id='topic+est_ps_xgb'></span>

<h3>Description</h3>

<p>Estimate a propensity score to a given drug exposure (treatment)
with extreme gradient boosting.
Depends on <code>xgboost</code> package.
Internal function, not supposed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_ps_xgb(
  idx_expo,
  x,
  parameters = list(eta = 0.1, max_depth = 6, objective = "binary:logistic", nthread =
    1),
  nrounds = 200,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="est_ps_xgb_+3A_idx_expo">idx_expo</code></td>
<td>
<p>Index of the column in <code>x</code> that corresponds to the
drug covariate for which we aim at estimating the PS.</p>
</td></tr>
<tr><td><code id="est_ps_xgb_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an
observation vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="est_ps_xgb_+3A_parameters">parameters</code></td>
<td>
<p>correspond to <code>params</code> in <code>xgb.train</code> function.
The complete list of parameters is available at
<a href="http://xgboost.readthedocs.io/en/latest/parameter.html">http://xgboost.readthedocs.io/en/latest/parameter.html</a>.
Default is a list with <code>eta=0.1</code> (learning rate),
<code>max_depth = 6</code> (maximum length of a tree),
<code>objective = "binary:logistic"</code>
and  <code>nthread = 1</code> (number of threads for parallelization).</p>
</td></tr>
<tr><td><code id="est_ps_xgb_+3A_nrounds">nrounds</code></td>
<td>
<p>Maximum number of boosting iterations. Default is 200.</p>
</td></tr>
<tr><td><code id="est_ps_xgb_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>xgb.train</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"ps", "xgb"</code>.
</p>
<table role = "presentation">
<tr><td><code>expo_name</code></td>
<td>
<p>Character, name of the drug exposure for which the PS was
estimated. Correspond to <code>colnames(x)[idx_expo]</code></p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>indicator_expo</code></td>
<td>
<p>One-column Matrix object. Indicator of the drug
exposure for which the PS was estimated.
Defined by <code>x[, idx_expo]</code>.</p>
</td></tr></table>
<p>.
</p>
<table role = "presentation">
<tr><td><code>score_variables</code></td>
<td>
<p>Character vector, names of covariates(s) used in
a at list one tree in the gradient tree boosting algorithm.
Obtained with <code>xgb.importance</code> function from <code>xgboost</code> package.</p>
</td></tr>
<tr><td><code>score</code></td>
<td>
<p>One-column Matrix object, the estimated score.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
psxgb2 &lt;- est_ps_xgb(idx_expo = 2, x = drugs, nrounds = 100)
psxgb2$score_variables #selected variables to include in the PS model of drug_2


</code></pre>

<hr>
<h2 id='lasso_bic'>fit a lasso regression and use standard BIC for variable selection</h2><span id='topic+lasso_bic'></span>

<h3>Description</h3>

<p>Fit a lasso regression and use the Bayesian Information Criterion (BIC)
to select a subset of selected covariates.
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
Depends on the <code>glmnet</code> and <code>relax.glmnet</code> functions from the package <code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso_bic(x, y, maxp = 50, path = TRUE, betaPos = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso_bic_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="lasso_bic_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="lasso_bic_+3A_maxp">maxp</code></td>
<td>
<p>A limit on how many relaxed coefficients are allowed.
Default is 50, in <code>glmnet</code> option default is 'n-3', where 'n' is the sample size.</p>
</td></tr>
<tr><td><code id="lasso_bic_+3A_path">path</code></td>
<td>
<p>Since <code>glmnet</code> does not do stepsize optimization, the Newton
algorithm can get stuck and not converge, especially with relaxed fits. With <code>path=TRUE</code>,
each relaxed fit on a particular set of variables is computed pathwise using the original sequence
of lambda values (with a zero attached to the end). Default is <code>path=TRUE</code>.</p>
</td></tr>
<tr><td><code id="lasso_bic_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lasso_bic_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code> from package
<code>glmnet</code> other than <code>family</code>, <code>maxp</code>
and <code>path</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each tested penalisation parameter <code class="reqn">\lambda</code>, a standard version of the BIC
is implemented.
</p>
<p style="text-align: center;"><code class="reqn">BIC_\lambda = - 2 l_\lambda + df(\lambda) * ln (N)</code>
</p>

<p>where <code class="reqn">l_\lambda</code> is the log-likelihood of the non-penalized multiple logistic
regression model that includes the set of covariates with a non-zero coefficient
in the penalised regression coefficient vector associated to <code class="reqn">\lambda</code>,
and  <code class="reqn">df(\lambda)</code> is the number of covariates with a non-zero coefficient
in the penalised regression coefficient vector associated to <code class="reqn">\lambda</code>,
The optimal set of covariates according to this approach is the one associated with
the classical multiple logistic regression model which minimizes the BIC.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"log.lasso"</code>.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the lasso.
In <code>lasso_bic</code> function, the regression coefficients are UNPENALIZED.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected with the
lasso-bic approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in <code>beta</code>.
Covariates are ordering according to the p-values (two-sided if <code>betaPos = FALSE</code> ,
one-sided if <code>betaPos = TRUE</code>) in the classical multiple logistic regression
model that minimzes the BIC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
lb &lt;- lasso_bic(x = drugs, y = ae, maxp = 20)


</code></pre>

<hr>
<h2 id='lasso_cv'>wrap function for <code>cv.glmnet</code></h2><span id='topic+lasso_cv'></span>

<h3>Description</h3>

<p>Fit a first cross-validation on lasso regression and return selected covariates.
Can deal with very large sparse data matrices.
Intended for binary reponse only (option <code>family = "binomial"</code> is forced).
Depends on the <code>cv.glmnet</code> function from the package <code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso_cv(x, y, nfolds = 5, foldid = NULL, betaPos = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso_cv_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="lasso_cv_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="lasso_cv_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds - default is 5. Although <code>nfolds</code> can be
as large as the sample size (leave-one-out CV), it is not recommended for
large datasets. Smallest value allowable is <code>nfolds=3</code>.</p>
</td></tr>
<tr><td><code id="lasso_cv_+3A_foldid">foldid</code></td>
<td>
<p>An optional vector of values between 1 and <code>nfolds</code>
identifying what fold each observation is in.
If supplied, <code>nfolds</code> can be missing.</p>
</td></tr>
<tr><td><code id="lasso_cv_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be positively
associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lasso_cv_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>cv.glmnet</code>
from package <code>glmnet</code> other than <code>nfolds</code>, <code>foldid</code>,
and <code>family</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object with S3 class <code>"log.lasso"</code>.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the lasso.
In <code>lasso_cv</code> function, the regression coefficients are PENALIZED.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected with the
lasso-cv approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in
<code>beta</code>.
Covariates are ordering according to magnitude of their regression
coefficients absolute value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
lcv &lt;- lasso_cv(x = drugs, y = ae, nfolds = 3)


</code></pre>

<hr>
<h2 id='lasso_perm'>fit a lasso regression and use standard permutation of the outcome for variable selection</h2><span id='topic+lasso_perm'></span>

<h3>Description</h3>

<p>Performed K lasso logistic regression with K different permuted version of the outcome.
For earch of the lasso regression, the <code class="reqn">\lambda_max</code>(i.e. the smaller
<code class="reqn">\lambda</code> such as all penalized regression coefficients are shrunk to zero)
is obtained.
The median value of these K  <code class="reqn">\lambda_max</code> is used to for variable selection
in the lasso regression with the non-permuted outcome.
Depends on the <code>glmnet</code> function from the package <code>glmnet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso_perm(x, y, K = 20, keep = NULL, betaPos = TRUE, ncore = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lasso_perm_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_k">K</code></td>
<td>
<p>Number of permutations of <code>y</code>. Default is 20.</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_keep">keep</code></td>
<td>
<p>Do some variables of <code>x</code> have to be permuted in the same way
as <code>y</code>? Default is NULL, means no.
If yes, must be a vector of covariates indices. TEST OPTION</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be positively
associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_ncore">ncore</code></td>
<td>
<p>The number of calcul units used for parallel computing.
Default is 1, no parallelization is implemented.</p>
</td></tr>
<tr><td><code id="lasso_perm_+3A_...">...</code></td>
<td>
<p>Other arguments that can be passed to <code>glmnet</code>
from package <code>glmnet</code> other than <code>family</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The selected <code class="reqn">\lambda</code> with this approach is defined as the closest
<code class="reqn">\lambda</code> from the median value of the K <code class="reqn">\lambda_max</code> obtained
with permutation of the outcome.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"log.lasso"</code>.
</p>
<table role = "presentation">
<tr><td><code>beta</code></td>
<td>
<p>Numeric vector of regression coefficients in the lasso
In <code>lasso_perm</code> function, the regression coefficients are PENALIZED.
Length equal to nvars.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s) selected with the
lasso-perm approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a positive regression
coefficient in <code>beta</code>.
Else this set is the covariates with a non null regression coefficient in
<code>beta</code>.
Covariates are ordering according to magnitude of their regression
coefficients absolute value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>References</h3>

<p>Sabourin, J. A., Valdar, W., &amp; Nobel, A. B. (2015). &quot;A permutation approach for selecting the penalty parameter in penalized model selection&quot;.
<em>Biometrics</em>. 71(4), 1185–1194, <a href="https://doi.org/10.1111/biom.12359">doi:10.1111/biom.12359</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
lp &lt;- lasso_perm(x = drugs, y = ae, K = 10)


</code></pre>

<hr>
<h2 id='ps_adjust'>adjustment on propensity score</h2><span id='topic+ps_adjust'></span>

<h3>Description</h3>

<p>Implement the adjustment on propensity score for all the drug exposures
of the input drug matrix <code>x</code> which have more than a given
number of co-occurence with the outcome.
The binary outcome is regressed on a drug exposure and its
estimated PS, for each drug exposure considered after filtering.
With this approach, a p-value is obtained for each drug and a
variable selection is performed over the corrected for multiple
comparisons p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_adjust(
  x,
  y,
  n_min = 3,
  betaPos = TRUE,
  est_type = "bic",
  threshold = 0.05,
  ncore = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps_adjust_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_n_min">n_min</code></td>
<td>
<p>Numeric, Minimal number of co-occurence between a drug
covariate and the outcome y to estimate its score. See details belows.
Default is 3.</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_est_type">est_type</code></td>
<td>
<p>Character, indicates which approach is used to estimate
the PS.
Could be either &quot;bic&quot;, &quot;hdps&quot; or &quot;xgb&quot;.
Default is &quot;bic&quot;.</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for the p-values. Default is 0.05.</p>
</td></tr>
<tr><td><code id="ps_adjust_+3A_ncore">ncore</code></td>
<td>
<p>The number of calcul units used for parallel computing.
Default is 1, no parallelization is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PS could be estimated in different ways: using lasso-bic approach,
the hdps algorithm or gradient tree boosting.
The scores are estimated using the default parameter values of
<code>est_ps_bic</code>, <code>est_ps_hdps</code> and <code>est_ps_xgb</code> functions
(see documentation for details).
We apply the same filter and the same multiple testing correction as in
the paper UPCOMING REFERENCE: first, PS are estimated only for drug covariates which have
more than <code>n_min</code> co-occurence with the outcome <code>y</code>.
Adjustment on the PS is performed for these covariates and
one sided or two-sided (depend on <code>betaPos</code> parameter)
p-values are obtained.
The p-values of the covariates not retained after filtering are set to 1.
All these p-values are then adjusted for multiple comparaison with the
Benjamini-Yekutieli correction.
COULD BE VERY LONG. Since this approach (i) estimate a score for several
drug covariates and (ii) perform an adjustment on these scores,
parallelization is highly recommanded.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps", "adjust", "*"</code>, where
<code>"*"</code> is <code>"bic"</code>, <code>"hdps"</code> or <code>"xgb"</code>according on how the
score were estimated.
</p>
<table role = "presentation">
<tr><td><code>estimates</code></td>
<td>
<p>Regression coefficients associated with
the drug covariates. Numeric, length equal to the number of selected
variables with this approach.
Some elements could be NA if
(i) the corresponding covariate was filtered out,
(ii) adjustment model did not converge. Trying to estimate the score in
a different way could help, but it's not insured.</p>
</td></tr>
<tr><td><code>corrected_pvals</code></td>
<td>
<p>One sided p-values if <code>betaPos = TRUE</code>,
two-sided p-values if <code>betaPos = FALSE</code> adjusted for multiple testing.
Numeric, length equal to nvars.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s)
selected with the ps-adjust approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a
corrected one-sided p-value lower than <code>threshold</code>.
Else this set is the covariates with a
corrected two-sided p-value lower than <code>threshold</code>.
Covariates are ordering according to their corrected p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>References</h3>

<p>Benjamini, Y., &amp; Yekuteli, D. (2001). &quot;The Control of the False Discovery Rate in Multiple Testing under Dependency&quot;.
<em>The Annals of Statistics</em>. 29(4), 1165–1188, doi: <a href="https://doi.org/10.1214/aos/1013699998">doi:10.1214/aos/1013699998</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
adjps &lt;- ps_adjust(x = drugs, y = ae, n_min = 10)

</code></pre>

<hr>
<h2 id='ps_adjust_one'>adjustment on propensity score for one drug exposure</h2><span id='topic+ps_adjust_one'></span>

<h3>Description</h3>

<p>Implement the adjustment on propensity score for one drug exposure.
The binary outcome is regressed on the drug exposure of interest and
its estimated PS.
Internal function, not supposed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_adjust_one(ps_est, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps_adjust_one_+3A_ps_est">ps_est</code></td>
<td>
<p>An object of class <code>"ps", "*"</code> where <code>"*"</code> is
<code>"bic"</code>, <code>"hdps"</code> or <code>"xgb"</code> according on how the
score was estimated, respective outputs of internal functions
<code>est_ps_bic</code>, <code>est_ps_hdps</code>, <code>est_ps_xgb</code>.
It is a list with the following elements :
* score_type: character, name of the drug exposure for which the PS was
estimated.
* indicator_expo: indicator of the drugs exposure for which the
PS was estimated. One-column Matrix object.
* score_variables: Character vector, names of covariate(s) selected
to include in the PS estimation model. Could be empty.
*score: One-column Matrix object, the estimated score.</p>
</td></tr>
<tr><td><code id="ps_adjust_one_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PS could be estimated in different ways: using lasso-bic approach,
the hdPS algorithm or gradient tree boosting using functions
<code>est_ps_bic</code>, <code>est_ps_hdps</code> and <code>est_ps_xgb</code>
respectivelly.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps","adjust" </code>
</p>
<table role = "presentation">
<tr><td><code>expo_name</code></td>
<td>
<p>Character, name of the drug exposure for which the PS
was estimated.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Regression coefficient associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
<tr><td><code>pval_1sided</code></td>
<td>
<p>One sided p-value associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
<tr><td><code>pval_2sided</code></td>
<td>
<p>Two sided p-value associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
</table>
<p>Could return NA if the adjustment on the PS did not converge.
</p>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
pshdps2 &lt;- est_ps_hdps(idx_expo = 2, x = drugs, y = ae, keep_total = 10)
adjps2 &lt;- ps_adjust_one(ps_est = pshdps2, y = ae)
adjps2$estimate #estimated strength of association between drug_2 and the outcome by PS adjustment

</code></pre>

<hr>
<h2 id='ps_pond'>weihting on propensity score</h2><span id='topic+ps_pond'></span>

<h3>Description</h3>

<p>Implement the weighting on propensity score with Matching Weights (MW)
or the Inverse Probability of Treatment Weighting (IPTW) for all the
drug exposures of the input drug matrix <code>x</code> which have more
than a given number of co-occurence with the outcome.
The binary outcome is regressed on a drug exposure through a
classical weighted regression, for each drug exposure
considered after filtering.
With this approach, a p-value is obtained for each drug and a
variable selection is performed over the corrected for multiple
comparisons p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_pond(
  x,
  y,
  n_min = 3,
  betaPos = TRUE,
  weights_type = c("mw", "iptw"),
  truncation = FALSE,
  q = 0.025,
  est_type = "bic",
  threshold = 0.05,
  ncore = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps_pond_+3A_x">x</code></td>
<td>
<p>Input matrix, of dimension nobs x nvars. Each row is an observation
vector. Can be in sparse matrix format (inherit from class
<code>"sparseMatrix"</code> as in package <code>Matrix</code>).</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_n_min">n_min</code></td>
<td>
<p>Numeric, Minimal number of co-occurence between a drug covariate
and the outcome y to estimate its score. See details belows.
Default is 3.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_betapos">betaPos</code></td>
<td>
<p>Should the covariates selected by the procedure be
positively associated with the outcome ? Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_weights_type">weights_type</code></td>
<td>
<p>Character. Indicates which type of weighting
is implemented. Could be either &quot;mw&quot; or &quot;iptw&quot;.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_truncation">truncation</code></td>
<td>
<p>Bouleen, should we do weight truncation?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_q">q</code></td>
<td>
<p>If <code>truncation</code> is <code>TRUE</code>, quantile value for
weight truncation. Ignored if <code>truncation</code> is <code>FALSE</code>.
Default is 2.5 <code class="reqn">\%</code>.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_est_type">est_type</code></td>
<td>
<p>Character, indicates which approach is used to estimate
the propensity score.
Could be either &quot;bic&quot;, &quot;hdps&quot; or &quot;xgb&quot;.
Default is &quot;bic&quot;.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for the p-values. Default is 0.05.</p>
</td></tr>
<tr><td><code id="ps_pond_+3A_ncore">ncore</code></td>
<td>
<p>The number of calcul units used for parallel computing.
Default is 1, no parallelization is implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MW are defined by
</p>
<p style="text-align: center;"><code class="reqn">mw_i = min(PS_i, 1-PS_i)/[(expo_i) * PS_i + (1-expo_i) * (1-PS_i) ] </code>
</p>

<p>and weights from IPTW by
</p>
<p style="text-align: center;"><code class="reqn">iptw_i = expo_i/PS_i + (1-expo_i)/(1-PS_i)  </code>
</p>

<p>where <code class="reqn">expo_i</code> is the drug exposure indicator.
The PS could be estimated in different ways: using lasso-bic approach,
the hdps algorithm or gradient tree boosting.
The scores are estimated using the default parameter values of
<code>est_ps_bic</code>, <code>est_ps_hdps</code> and <code>est_ps_xgb</code> functions
(see documentation for details).
We apply the same filter and the same multiple testing correction as in
the paper UPCOMING REFERENCE: first, PS are estimated only for drug covariates which have
more than <code>n_min</code> co-occurence with the outcome <code>y</code>.
Adjustment on the PS is performed for these covariates and
one sided or two-sided (depend on <code>betaPos</code> parameter)
p-values are obtained.
The p-values of the covariates not retained after filtering are set to 1.
All these p-values are then adjusted for multiple comparaison with the
Benjamini-Yekutieli correction.
COULD BE VERY LONG. Since this approach (i) estimate a score for several
drug covariates and (ii) perform an adjustment on these scores,
parallelization is highly recommanded.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps", "*" ,"**" </code>,
where <code>"*"</code> is <code>"mw"</code> or <code>"iptw"</code>, same as the
input parameter <code>weights_type</code>, and <code>"**"</code> is
<code>"bic"</code>, <code>"hdps"</code> or <code>"xgb"</code> according on how the
score was estimated.
</p>
<table role = "presentation">
<tr><td><code>estimates</code></td>
<td>
<p>Regression coefficients associated with
the drug covariates. Numeric, length equal to the number of selected
variables with this approach.
Some elements could be NA if
(i) the corresponding covariate was filtered out,
(ii) weigted regression did not converge. Trying to estimate
the score in a different way could help, but it's not insured.</p>
</td></tr>
<tr><td><code>corrected_pvals</code></td>
<td>
<p>One sided p-values if <code>betaPos = TRUE</code>,
two-sided p-values if <code>betaPos = FALSE</code> adjusted for multiple testing.
Numeric, length equal to nvars.</p>
</td></tr>
<tr><td><code>selected_variables</code></td>
<td>
<p>Character vector, names of variable(s)
selected with the weighting on PS based approach.
If <code>betaPos = TRUE</code>, this set is the covariates with a
corrected one-sided p-value lower than <code>threshold</code>.
Else this set is the covariates with a
corrected two-sided p-value lower than <code>threshold</code>.
Covariates are ordering according to their corrected p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>References</h3>

<p>Benjamini, Y., &amp; Yekuteli, D. (2001). &quot;The Control of the False Discovery Rate in Multiple Testing under Dependency&quot;.
<em>The Annals of Statistics</em>. 29(4), 1165–1188, doi: <a href="https://doi.org/10.1214/aos/1013699998">doi:10.1214/aos/1013699998</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
pondps &lt;- ps_pond(x = drugs, y = ae, n_min = 10, weights_type = "iptw")


</code></pre>

<hr>
<h2 id='ps_pond_one'>weihting on propensity score for one drug exposure</h2><span id='topic+ps_pond_one'></span>

<h3>Description</h3>

<p>Implement the weighting on propensity score with Matching Weights (MW)
or the Inverse Probability of Treatment Weighting (IPTW) for
one drug exposure.
The binary outcome is regressed on the drug exposure of interest
through a classical weighted regression.
Internal function, not supposed to be used directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps_pond_one(
  ps_est,
  y,
  weights_type = c("mw", "iptw"),
  truncation = FALSE,
  q = 0.025
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ps_pond_one_+3A_ps_est">ps_est</code></td>
<td>
<p>An object of class <code>"ps", "*"</code> where <code>"*"</code> is
<code>"bic"</code>, <code>"hdps"</code> or <code>"xgb"</code> according on how the
score was estimated, respective outputs of internal functions
<code>est_ps_bic</code>, <code>est_ps_hdps</code>, <code>est_ps_xgb</code>.
It is a list with the following elements :
* score_type: character, name of the drug exposure for which the PS was
estimated.
* indicator_expo: indicator of the drugs exposure for which the
PS was estimated. One-column Matrix object.
* score_variables: Character vector, names of covariate(s) selected
to include in the PS estimation model. Could be empty.
*score: One-column Matrix object, the estimated score.</p>
</td></tr>
<tr><td><code id="ps_pond_one_+3A_y">y</code></td>
<td>
<p>Binary response variable, numeric.</p>
</td></tr>
<tr><td><code id="ps_pond_one_+3A_weights_type">weights_type</code></td>
<td>
<p>Character. Indicates which type of weighting
is implemented. Could be either &quot;mw&quot; or &quot;iptw&quot;.</p>
</td></tr>
<tr><td><code id="ps_pond_one_+3A_truncation">truncation</code></td>
<td>
<p>Bouleen, should we do weight truncation?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ps_pond_one_+3A_q">q</code></td>
<td>
<p>If <code>truncation</code> is <code>TRUE</code>, quantile value for
weight truncation. Ignored if <code>truncation</code> is <code>FALSE</code>.
Default is 2.5 <code class="reqn">\%</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The MW are defined by
</p>
<p style="text-align: center;"><code class="reqn">mw_i = min(PS_i, 1-PS_i)/[(expo_i) * PS_i + (1-expo_i) * (1-PS_i) ] </code>
</p>

<p>and weights from IPTW by
</p>
<p style="text-align: center;"><code class="reqn">iptw_i = expo_i/PS_i + (1-expo_i)/(1-PS_i)  </code>
</p>

<p>where <code class="reqn">expo_i</code> is the drug exposure indicator.
The PS could be estimated in different ways: using lasso-bic approach,
the hdPS algorithm or gradient tree boosting using functions
<code>est_ps_bic</code>, <code>est_ps_hdps</code> and <code>est_ps_xgb</code>
respectivelly.
</p>


<h3>Value</h3>

<p>An object with S3 class <code>"ps","*" </code>,
where <code>"*"</code> is <code>"mw"</code> or <code>"iptw"</code>, same as the
input parameter <code>weights_type</code>
</p>
<table role = "presentation">
<tr><td><code>expo_name</code></td>
<td>
<p>Character, name of the drug exposure for which the PS
was estimated.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>Regression coefficient associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
<tr><td><code>pval_1sided</code></td>
<td>
<p>One sided p-value associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
<tr><td><code>pval_2sided</code></td>
<td>
<p>Two sided p-value associated with the drug exposure
in adjustment on PS.</p>
</td></tr>
</table>
<p>Could return NA if the adjustment on the PS did not converge.
</p>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
pshdps2 &lt;- est_ps_hdps(idx_expo = 2, x = drugs, y = ae, keep_total = 10)
pondps2 &lt;- ps_pond_one(ps_est = pshdps2, y = ae, weights_type = "iptw")
pondps2$estimate #estimated strength of association between drug_2 and the outcome by PS weighting

</code></pre>

<hr>
<h2 id='summary_stat'>Summary statistics for main adapt4pv package functions</h2><span id='topic+summary_stat'></span>

<h3>Description</h3>

<p>Return the Sensitivity and the False Discovery Rate of an approach
implemeted by the main functions of adapt4pv package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_stat(object, true_pos, q = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary_stat_+3A_object">object</code></td>
<td>
<p>An object of class <code>"log.lasso"</code>,
<code>"cisl"</code>, <code>"adaptive"</code> and <code>"*", "ps","**" </code> where
<code>"*"</code> is either <code>"adjust"</code>, <code>"iptw"</code> or <code>"mw"</code>
and <code>"**"</code> is either <code>"bic"</code>, <code>"hdps"</code> or <code>"xgb"</code>.</p>
</td></tr>
<tr><td><code id="summary_stat_+3A_true_pos">true_pos</code></td>
<td>
<p>Character vector, names of the true positives
controls</p>
</td></tr>
<tr><td><code id="summary_stat_+3A_q">q</code></td>
<td>
<p>Quantile value for variable selection with
an object of class <code>"cisl"</code>.
Possible values are 5, 10, 15, 20. Default is 10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame wich details for the signal detection method
implemented in <code>object</code>: its number of generated signals, its
sensitivity and its false discovery rate.
</p>


<h3>Author(s)</h3>

<p>Emeline Courtois <br /> Maintainer: Emeline Courtois
<a href="mailto:emeline.courtois@inserm.fr">emeline.courtois@inserm.fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(15)
drugs &lt;- matrix(rbinom(100*20, 1, 0.2), nrow = 100, ncol = 20)
colnames(drugs) &lt;- paste0("drugs",1:ncol(drugs))
ae &lt;- rbinom(100, 1, 0.3)
lcv &lt;- lasso_cv(x = drugs, y = ae, nfolds = 3)
summary_stat(object = lcv, true_pos = colnames(drugs)[1:10])
# the data are not simulated in such a way that there are true positives


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
