<!DOCTYPE html><html><head><title>Help for package aplpack</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {aplpack}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bagplot'><p> bagplot, a bivariate boxplot</p></a></li>
<li><a href='#bagplot.pairs'><p><code>pairs</code> plot with bagplots</p></a></li>
<li><a href='#boxplot2D'><p> Boxplot of projection of two dimensional data</p></a></li>
<li><a href='#faces'><p>    Chernoff Faces</p></a></li>
<li><a href='#hdepth'><p> hdepth of points</p></a></li>
<li><a href='#iconplot'>
<p>Icon Plots for Visualization of Contingency Tables</p></a></li>
<li><a href='#plothulls'><p>plothulls for data peeling</p></a></li>
<li><a href='#plotsummary'><p>  graphical summaries of variables of a data set</p></a></li>
<li><a href='#puticon'>
<p>Add Icon(s) to a Plot</p></a></li>
<li><a href='#skyline.hist'>
<p><code>skyline.hist</code> computes a skyline plot which is special histogram.</p></a></li>
<li><a href='#slider'><p>slider / button control widgets</p></a></li>
<li><a href='#slider.bootstrap.lm.plot'><p>interactive bootstapping for lm</p></a></li>
<li><a href='#slider.brush'><p>interactive brushing functions</p></a></li>
<li><a href='#slider.hist'><p>interactive histogram and density traces</p></a></li>
<li><a href='#slider.lowess.plot'><p>interactive lowess smoothing</p></a></li>
<li><a href='#slider.smooth.plot.ts'><p>interactive Tukey smoothing</p></a></li>
<li><a href='#slider.split.plot.ts'><p>interactive splitting of time series</p></a></li>
<li><a href='#slider.stem.leaf'>
<p>construction of stem and leaf display interactively</p></a></li>
<li><a href='#slider.zoom.plot.ts'><p>interactive zooming of time series</p></a></li>
<li><a href='#spin3R'><p> spin3R</p></a></li>
<li><a href='#stem.leaf'><p>stem and leaf display and back to back stem and leaf display</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Another Plot Package: 'Bagplots', 'Iconplots', 'Summaryplots',
Slider Functions and Others</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Hans Peter Wolf [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hans Peter Wolf &lt;pwolf@wiwi.uni-bielefeld.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>tkrplot, jpeg, png, splines, utils, tcltk</td>
</tr>
<tr>
<td>Description:</td>
<td>Some functions for drawing some special plots:
   The function 'bagplot' plots a bagplot,
   'faces' plots chernoff faces,
   'iconplot' plots a representation of a frequency table or a data matrix,
   'plothulls' plots hulls of a bivariate data set,
   'plotsummary' plots a graphical summary of a data set,
   'puticon' adds icons to a plot,
   'skyline.hist' combines several histograms of a one dimensional data set in one plot,
   'slider' functions supports some interactive graphics,
   'spin3R' helps an inspection of a 3-dim point cloud,
   'stem.leaf' plots a stem and leaf plot,
   'stem.leaf.backback' plots back-to-back versions of stem and leaf plot.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml">https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-30 09:53:17 UTC; pwolf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-30 14:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bagplot'> bagplot, a bivariate boxplot </h2><span id='topic+bagplot'></span><span id='topic+compute.bagplot'></span><span id='topic+plot.bagplot'></span>

<h3>Description</h3>

<p><code>compute.bagplot()</code> computes an object describing a bagplot 
of a bivariate data set. <code>plot.bagplot()</code> plots a bagplot object. 
<code>bagplot()</code> computes and plots a bagplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bagplot(x, y, factor = 3, na.rm = FALSE, approx.limit = 300,  
       show.outlier = TRUE, show.whiskers = TRUE, 
       show.looppoints = TRUE, show.bagpoints = TRUE,
       show.loophull = TRUE, show.baghull = TRUE, 
       create.plot = TRUE, add = FALSE, pch = 16, cex = 0.4, 
       dkmethod = 2, precision = 1, verbose = FALSE, 
       debug.plots = "no",   col.loophull="#aaccff", 
       col.looppoints="#3355ff", col.baghull="#7799ff", 
       col.bagpoints="#000088", transparency=FALSE, 
       show.center = TRUE, ...
)
compute.bagplot(x, y, factor = 3, na.rm = FALSE, approx.limit = 300, 
       dkmethod=2,precision=1,verbose=FALSE,debug.plots="no")
## S3 method for class 'bagplot'
plot(x,  
       show.outlier = TRUE, show.whiskers = TRUE, 
       show.looppoints = TRUE, show.bagpoints = TRUE,
       show.loophull = TRUE, show.baghull = TRUE, 
       add = FALSE, pch = 16, cex = 0.4, verbose = FALSE, 
       col.loophull="#aaccff", col.looppoints="#3355ff", 
       col.baghull="#7799ff", col.bagpoints="#000088", 
       transparency=FALSE, 
       show.center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bagplot_+3A_x">x</code></td>
<td>
<p> x values of a data set; 
in <code>bagplot</code>: an object of class <code>bagplot</code>
computed by <code>compute.bagplot</code> </p>
</td></tr>
<tr><td><code id="bagplot_+3A_y">y</code></td>
<td>
<p> y values of the data set </p>
</td></tr> 
<tr><td><code id="bagplot_+3A_factor">factor</code></td>
<td>
<p> factor defining the loop </p>
</td></tr>
<tr><td><code id="bagplot_+3A_na.rm">na.rm</code></td>
<td>
<p> if TRUE 'NA' values are removed otherwise exchanged by median</p>
</td></tr>
<tr><td><code id="bagplot_+3A_approx.limit">approx.limit</code></td>
<td>
<p> if the number of data points exceeds 
<code>approx.limit</code> a sample is used to compute 
some of the quantities; default: 300 </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.outlier">show.outlier</code></td>
<td>
<p> if TRUE outlier are shown </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.whiskers">show.whiskers</code></td>
<td>
<p> if TRUE whiskers are shown </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.looppoints">show.looppoints</code></td>
<td>
<p> if TRUE loop points are plottet </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.bagpoints">show.bagpoints</code></td>
<td>
<p> if TRUE bag points are plottet </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.loophull">show.loophull</code></td>
<td>
<p> if TRUE the loop is plotted </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.baghull">show.baghull</code></td>
<td>
<p> if TRUE the bag is plotted </p>
</td></tr>
<tr><td><code id="bagplot_+3A_create.plot">create.plot</code></td>
<td>
<p> if FALSE no plot is created </p>
</td></tr>
<tr><td><code id="bagplot_+3A_add">add</code></td>
<td>
<p> if TRUE the bagplot is added to an existing plot </p>
</td></tr>
<tr><td><code id="bagplot_+3A_pch">pch</code></td>
<td>
<p> sets the plotting character </p>
</td></tr>
<tr><td><code id="bagplot_+3A_cex">cex</code></td>
<td>
<p> sets characters size</p>
</td></tr>
<tr><td><code id="bagplot_+3A_dkmethod">dkmethod</code></td>
<td>
<p> 1 or 2, there are two method of  
approximating the bag, method 1 is very rough (only based on observations </p>
</td></tr>
<tr><td><code id="bagplot_+3A_precision">precision</code></td>
<td>
<p> precision of approximation, default: 1 </p>
</td></tr>
<tr><td><code id="bagplot_+3A_verbose">verbose</code></td>
<td>
<p> automatic commenting of calculations </p>
</td></tr>
<tr><td><code id="bagplot_+3A_debug.plots">debug.plots</code></td>
<td>
<p> if TRUE additional plots describing 
intermediate results are constructed </p>
</td></tr>
<tr><td><code id="bagplot_+3A_col.loophull">col.loophull</code></td>
<td>
<p> color of loop hull </p>
</td></tr>
<tr><td><code id="bagplot_+3A_col.looppoints">col.looppoints</code></td>
<td>
<p> color of the points of the loop </p>
</td></tr>
<tr><td><code id="bagplot_+3A_col.baghull">col.baghull</code></td>
<td>
<p> color of bag hull </p>
</td></tr>
<tr><td><code id="bagplot_+3A_col.bagpoints">col.bagpoints</code></td>
<td>
<p> color of the points of the bag </p>
</td></tr>
<tr><td><code id="bagplot_+3A_transparency">transparency</code></td>
<td>
<p> see section details </p>
</td></tr>
<tr><td><code id="bagplot_+3A_show.center">show.center</code></td>
<td>
<p> if TRUE the center is shown </p>
</td></tr>
<tr><td><code id="bagplot_+3A_...">...</code></td>
<td>
<p> additional graphical parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bagplot is a bivariate generalization of the well known
boxplot. It has been proposed by Rousseeuw, Ruts, and Tukey.
In the bivariate case the box of the boxplot changes to a 
convex polygon, the bag of bagplot. In the bag are 50 percent
of all points. The fence separates points within the fence from 
points outside. It is computed by increasing the
the bag. The loop is defined as the convex hull containing 
all points inside the fence. 
If all points are on a straight line you get a classical
boxplot.
<code>bagplot()</code> plots bagplots that are very similar 
to the one described in Rousseeuw et al. 
Remarks:
The two dimensional median is approximated.
For large data sets the error will be very small.
On the other hand it is not very wise to make a (graphical) 
summary of e.g. 10 bivariate data points.
In case you want to plot multiple (overlapping) bagplots, 
you may want plots that are semi-transparent. For this 
you can use the <code>transparency</code> flag. 
If <code>transparency==TRUE</code> the alpha layer is set to '99' (hex).
This causes the bagplots to appear semi-transparent, 
but ONLY if the output device is PDF and opened using:
<code>pdf(file="filename.pdf", version="1.4")</code>. 
For this reason, the default is <code>transparency==FALSE</code>. 
This feature as well as the arguments
to specify different colors has been proposed by Wouter Meuleman.
</p>


<h3>Value</h3>

<p><code>compute.bagplot</code> returns an object of class
<code>bagplot</code> that could be plotted by 
<code>plot.bagplot()</code>.
An object of the bagplot class is a list with the following 
elements: <code>center</code> is a two dimensional vector with 
the coordinates of the center. <code>hull.center</code> is a 
two column matrix, the rows are the coordinates of the
corners of the center region. <code>hull.bag</code> and 
<code>hull.loop</code> contain the coordinates of the hull of the bag
and the hull of the loop. <code>pxy.bag</code> shows you the 
coordinates of the points of the bag. <code>pxy.outer</code> is 
the two column matrix of the points that are within the 
fence. <code>pxy.outlier</code> represent the outliers. The vector
<code>hdepths</code> shows the depths of data points. <code>is.one.dim</code>
is <code>TRUE</code> if the data set is (nearly) one dimensional. 
The dimensionality is decided by analysing the result of <code>prcomp</code>
which is stored in the element <code>prdata</code>. <code>xy</code> shows you 
the data that are used for the bagplot. In the case of very large
data sets subsets of the data are used for constructing the 
bagplot. A data set is very large if there are more data points
than <code>approx.limit</code>. <code>xydata</code> are the input data structured 
in a two column matrix.
</p>


<h3>Note</h3>

<p>Version of bagplot: 10/2012 </p>


<h3>Author(s)</h3>

<p> Peter Wolf </p>


<h3>References</h3>

<p> P. J. Rousseeuw, I. Ruts, J. W. Tukey (1999):
The bagplot: a bivariate boxplot, The American
Statistician, vol. 53, no. 4, 382&ndash;387 </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+boxplot">boxplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # example: 100 random points and one outlier
  dat&lt;-cbind(rnorm(100)+100,rnorm(100)+300)
  dat&lt;-rbind(dat,c(105,295))
  bagplot(dat,factor=2.5,create.plot=TRUE,approx.limit=300,
     show.outlier=TRUE,show.looppoints=TRUE,
     show.bagpoints=TRUE,dkmethod=2,
     show.whiskers=TRUE,show.loophull=TRUE,
     show.baghull=TRUE,verbose=FALSE)
  # example of Rousseeuw et al., see R-package rpart
  cardata &lt;- structure(as.integer( c(2560,2345,1845,2260,2440,
   2285, 2275, 2350, 2295, 1900, 2390, 2075, 2330, 3320, 2885,
   3310, 2695, 2170, 2710, 2775, 2840, 2485, 2670, 2640, 2655,
   3065, 2750, 2920, 2780, 2745, 3110, 2920, 2645, 2575, 2935,
   2920, 2985, 3265, 2880, 2975, 3450, 3145, 3190, 3610, 2885,
   3480, 3200, 2765, 3220, 3480, 3325, 3855, 3850, 3195, 3735,
   3665, 3735, 3415, 3185, 3690, 97, 114, 81, 91, 113, 97, 97,
   98, 109, 73, 97, 89, 109, 305, 153, 302, 133, 97, 125, 146,
   107, 109, 121, 151, 133, 181, 141, 132, 133, 122, 181, 146,
   151, 116, 135, 122, 141, 163, 151, 153, 202, 180, 182, 232,
   143, 180, 180, 151, 189, 180, 231, 305, 302, 151, 202, 182,
   181, 143, 146, 146)), .Dim = as.integer(c(60, 2)), 
   .Dimnames = list(NULL, c("Weight", "Disp.")))
  bagplot(cardata,factor=3,show.baghull=TRUE,
    show.loophull=TRUE,precision=1,dkmethod=2)
  title("car data Chambers/Hastie 1992")
  # points of y=x*x
  bagplot(x=1:30,y=(1:30)^2,verbose=FALSE,dkmethod=2)
  # one dimensional subspace
  bagplot(x=1:100,y=1:100)
</code></pre>

<hr>
<h2 id='bagplot.pairs'> <code>pairs</code> plot with bagplots </h2><span id='topic+bagplot.pairs'></span>

<h3>Description</h3>

<p><code>bagplot.pairs</code> calls <code>pairs</code> and use bagplot() as panel function. 
It can be used for the inspection of data matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bagplot.pairs(dm, trim = 0.0, main, numeric.only = TRUE, 
                factor = 3, approx.limit = 300, pch = 16, 
                cex = 0.8, precision = 1, col.loophull = "#aaccff",
                col.looppoints = "#3355ff", col.baghull = "#7799ff",
                col.bagpoints = "#000088", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bagplot.pairs_+3A_dm">dm</code></td>
<td>
<p> datamatrix, columns contain values of the variables </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_trim">trim</code></td>
<td>
<p> fraction or vector of fractions of data points 
that should be removed from the variables before computing </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_main">main</code></td>
<td>
<p> title of the plot </p>
</td></tr> 
<tr><td><code id="bagplot.pairs_+3A_numeric.only">numeric.only</code></td>
<td>
<p> if TRUE only numerical variables will be used. Otherwise an 
transformation to numeric will be performed.</p>
</td></tr> 
<tr><td><code id="bagplot.pairs_+3A_factor">factor</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_approx.limit">approx.limit</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_pch">pch</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_cex">cex</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_precision">precision</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_col.loophull">col.loophull</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_col.looppoints">col.looppoints</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_col.baghull">col.baghull</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_col.bagpoints">col.bagpoints</code></td>
<td>
<p> see help of bagplot </p>
</td></tr>
<tr><td><code id="bagplot.pairs_+3A_...">...</code></td>
<td>
<p> further arguments to be passed to <code>pairs</code> </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bagplot.pairs</code> is a cover function which calls <code>pairs</code> and uses 
<code>bagplot</code> to display the data.
</p>


<h3>Value</h3>

<p>The data which has been used for the plot.
</p>


<h3>Note</h3>

<p>Feel free to have a look inside of bagplot.pairs and 
to improve it according to your ideas.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf </p>


<h3>See Also</h3>

   <p><code><a href="#topic+bagplot">bagplot</a></code>, <code><a href="graphics.html#topic+pairs">pairs</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'> # bagplot.pairs(freeny)
  # bagplot.pairs(trees,col.baghull="green", col.loophull="lightgreen")
</code></pre>

<hr>
<h2 id='boxplot2D'> Boxplot of projection of two dimensional data </h2><span id='topic+boxplot2D'></span>

<h3>Description</h3>

<p>boxplot2D computes summary statistics of a one dimensional 
projection of a two dimensional data set and plots a sloped
boxplot of the statistics into the scatterplot of the two 
dimensional data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    boxplot2D(xy, add.to.plot = TRUE, box.size = 10, box.shift = 0, 
    angle = 0, angle.type = "0", tukey.style = TRUE, coef.out = 1.5, 
    coef.h.out = 3, design = "sl", na.rm=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boxplot2D_+3A_xy">xy</code></td>
<td>
 <p><code>(nx2)</code>-matrix, two dimensional data set  </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_add.to.plot">add.to.plot</code></td>
<td>
<p> if <code>TRUE</code> the boxplot is added to
the actual plot of the graphics device </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_box.size">box.size</code></td>
<td>
<p> height of the box (of the boxplot) </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_box.shift">box.shift</code></td>
<td>
<p> shift of boxplot perpendicular to the 
projection direction </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_angle">angle</code></td>
<td>
<p> direction of projection in units defined by 
angle.type </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_angle.type">angle.type</code></td>
<td>
 
<p><code>"0"</code>: angle in (0,2*pi),
<code>"1"</code>: clock-like: angle.typ.0==2*pi*angle.typ.1/12,  
<code>"2"</code>: degrees: angle.typ.0==2*pi*angle.typ.2/360, 
<code>"3"</code>: by fraction: delta.y/delta.x
</p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_tukey.style">tukey.style</code></td>
<td>
<p> if <code>TRUE</code> outliers are defined as described 
in Tukey (1977)
</p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_coef.out">coef.out</code></td>
<td>
<p> outliers are values that are more than
<code>coef.out*boxwidth</code> away from the box, default: 
<code>coef.out=1.5</code>  </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_coef.h.out">coef.h.out</code></td>
<td>
<p> heavy outliers are values that are more
than <code>coef.h.out*boxwidth</code> away from the box,
default: <code>coef.h.out=3</code>   </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_design">design</code></td>
<td>
<p> if <code>sl</code> then parallelogram else box  </p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_na.rm">na.rm</code></td>
<td>
<p> if TRUE 'NA' values are removed otherwise exchanged by mean</p>
</td></tr>
<tr><td><code id="boxplot2D_+3A_...">...</code></td>
<td>
<p> additional graphical parameters </p>
</td></tr>
</table>


<h3>Note</h3>

<p> version 08/2003 </p>


<h3>Author(s)</h3>

<p>Peter Wolf </p>


<h3>References</h3>

<p>Tukey, J.
<em>Exploratory Data Analysis.</em>
Addison-Wesley, 1977.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+boxplot">boxplot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'> xy&lt;-cbind(1:100, (1:100)+rnorm(100,,5))
 par(pty="s")
 plot(xy,xlim=c(-50,150),ylim=c(-50,150))
 boxplot2D(xy,box.shift=-30,angle=3,angle.typ=1)
 boxplot2D(xy,box.shift=20,angle=1,angle.typ=1)
 boxplot2D(xy,box.shift=50,angle=5,angle.typ=1)
 par(pty="m")
</code></pre>

<hr>
<h2 id='faces'>    Chernoff Faces    </h2><span id='topic+faces'></span><span id='topic+plot.faces'></span>

<h3>Description</h3>

<p><code>faces</code> represent the rows of a data matrix by faces.
<code>plot.faces</code> plots faces into a scatterplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faces(xy, which.row, fill = FALSE, face.type = 1, nrow.plot, ncol.plot, 
    scale = TRUE, byrow = FALSE, main, labels, print.info = TRUE, 
    na.rm = FALSE, ncolors = 20, col.nose = rainbow(ncolors), 
    col.eyes = rainbow(ncolors, start = 0.6, end = 0.85), 
    col.hair = terrain.colors(ncolors), col.face = heat.colors(ncolors), 
    col.lips = rainbow(ncolors, start = 0, end = 0.2), 
    col.ears = rainbow(ncolors, start = 0, end = 0.2), plot.faces = TRUE, cex = 2) 
## S3 method for class 'faces'
plot(x, x.pos, y.pos, face.type = 1, width = 1, height = 1, labels, 
        ncolors = 20, col.nose = rainbow(ncolors), col.eyes = rainbow(ncolors, 
        start = 0.6, end = 0.85), col.hair = terrain.colors(ncolors), 
        col.face = heat.colors(ncolors), col.lips = rainbow(ncolors, 
        start = 0, end = 0.2), col.ears = rainbow(ncolors, start = 0, 
        end = 0.2), cex = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faces_+3A_xy">xy</code></td>
<td>
   <p><code>xy</code> data matrix, rows represent individuals and columns variables  </p>
</td></tr>
<tr><td><code id="faces_+3A_which.row">which.row</code></td>
<td>
<p>   defines a permutation of the rows of the input matrix   </p>
</td></tr>
<tr><td><code id="faces_+3A_fill">fill</code></td>
<td>
   <p><code>if(fill==TRUE)</code>, only the first <code>nc</code> attributes of the faces are
transformed, <code>nc</code> is the number of columns of <code>xy</code>   </p>
</td></tr>
<tr><td><code id="faces_+3A_face.type">face.type</code></td>
<td>
<p>  an integer between 0 and 2 with the meanings: 
0 = line drawing faces, 
1 = the elements of the faces are painted,
2 = Santa Claus faces are drawn </p>
</td></tr>
<tr><td><code id="faces_+3A_nrow.plot">nrow.plot</code></td>
<td>
<p>   number of columns of faces on graphics device   </p>
</td></tr>
<tr><td><code id="faces_+3A_ncol.plot">ncol.plot</code></td>
<td>
<p>   number of rows of faces   </p>
</td></tr>
<tr><td><code id="faces_+3A_scale">scale</code></td>
<td>
   <p><code>if(scale==TRUE)</code>, variables will be normalized   </p>
</td></tr>
<tr><td><code id="faces_+3A_byrow">byrow</code></td>
<td>
   <p><code>if(byrow==TRUE)</code>, <code>xy</code> will be transposed   </p>
</td></tr>
<tr><td><code id="faces_+3A_main">main</code></td>
<td>
<p>   title   </p>
</td></tr>
<tr><td><code id="faces_+3A_labels">labels</code></td>
<td>
<p>   character strings to use as names for the faces   </p>
</td></tr>
<tr><td><code id="faces_+3A_print.info">print.info</code></td>
<td>
<p>   if TRUE information about usage of variables for face elements are printed </p>
</td></tr>
<tr><td><code id="faces_+3A_na.rm">na.rm</code></td>
<td>
<p> if TRUE 'NA' values are removed otherwise exchanged by mean of data</p>
</td></tr>
<tr><td><code id="faces_+3A_plot.faces">plot.faces</code></td>
<td>
<p>   if <code>FALSE</code> no face is plotted  </p>
</td></tr>
<tr><td><code id="faces_+3A_cex">cex</code></td>
<td>
<p>   size of labels of faces </p>
</td></tr>
<tr><td><code id="faces_+3A_x">x</code></td>
<td>
<p> an object of class <code>faces</code> computed by <code>faces</code>   </p>
</td></tr>
<tr><td><code id="faces_+3A_x.pos">x.pos</code></td>
<td>
<p> x coordinates of positions of faces  </p>
</td></tr>
<tr><td><code id="faces_+3A_y.pos">y.pos</code></td>
<td>
<p> y coordinates of positions of faces  </p>
</td></tr>
<tr><td><code id="faces_+3A_width">width</code></td>
<td>
<p> width of the faces </p>
</td></tr>
<tr><td><code id="faces_+3A_height">height</code></td>
<td>
<p> height of the faces </p>
</td></tr>
<tr><td><code id="faces_+3A_ncolors">ncolors</code></td>
<td>
<p> number of colors in the palettes for painting the elements of the faces </p>
</td></tr>
<tr><td><code id="faces_+3A_col.nose">col.nose</code></td>
<td>
<p> palette of colors for painting the nose </p>
</td></tr>
<tr><td><code id="faces_+3A_col.eyes">col.eyes</code></td>
<td>
<p> palette of colors for painting the eyes </p>
</td></tr>
<tr><td><code id="faces_+3A_col.hair">col.hair</code></td>
<td>
<p> palette of colors for painting the hair </p>
</td></tr>
<tr><td><code id="faces_+3A_col.face">col.face</code></td>
<td>
<p> palette of colors for painting the face </p>
</td></tr>
<tr><td><code id="faces_+3A_col.lips">col.lips</code></td>
<td>
<p> palette of colors for painting the lips </p>
</td></tr>
<tr><td><code id="faces_+3A_col.ears">col.ears</code></td>
<td>
<p> palette of colors for painting the ears </p>
</td></tr>
<tr><td><code id="faces_+3A_...">...</code></td>
<td>
<p> additional graphical arguments </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Explanation of parameters:
1-height of face,
2-width of face,
3-shape of face,
4-height of mouth,
5-width of mouth,
6-curve of smile,
7-height of eyes,
8-width of eyes,
9-height of hair,
10-width of hair,
11-styling of hair,
12-height of nose,
13-width of nose,
14-width of ears,
15-height of ears. 
</p>
<p>For painting elements of a face the colors of are found by 
averaging of sets of variables: 
(7,8)-eyes:iris, (1,2,3)-lips, 
(14,15)-ears, (12,13)-nose, (9,10,11)-hair, (1,2)-face.
</p>
<p>Further details can be found in the literate program of <code>faces</code>.
</p>


<h3>Value</h3>

<p>list of two elements: The first element <code>out$faces</code> 
is a list of standardized faces of <code>class faces</code>,
this object could be plotted by plot.faces;
a plot of faces is created on the graphics device if 
<code>plot.faces=TRUE</code>.
The second list is short description of the effects of the variables.
</p>


<h3>Note</h3>

<p> version 01/2009   </p>


<h3>Author(s)</h3>

<p>   H. P. Wolf    </p>


<h3>References</h3>

<p>  Chernoff, H. (1973): The use of faces to represent statistiscal assoziation,
JASA, 68, pp 361&ndash;368.
The smooth curves are computed by an algorithm found in
Ralston, A. and Rabinowitz, P. (1985):
A first course in numerical analysis, McGraw-Hill, pp 76ff.
<a href="https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml">https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml</a>
</p>


<h3>See Also</h3>

<p>   &mdash;    </p>


<h3>Examples</h3>

<pre><code class='language-R'>
faces()
faces(face.type=1)

faces(rbind(1:3,5:3,3:5,5:7))

data(longley)
faces(longley[1:9,],face.type=0)
faces(longley[1:9,],face.type=1)

plot(longley[1:16,2:3],bty="n")
a&lt;-faces(longley[1:16,],plot=FALSE)
plot.faces(a,longley[1:16,2],longley[1:16,3],width=35,height=30)

set.seed(17)
faces(matrix(sample(1:1000,128,),16,8),main="random faces")

a&lt;-faces(rbind(1:3,5:3,3:5,5:7),plot.faces=FALSE)
plot(0:5,0:5,type="n")
plot(a,x.pos=1:4,y.pos=1:4,1.5,0.7)
# during Christmastime
faces(face.type=2)
</code></pre>

<hr>
<h2 id='hdepth'> hdepth of points </h2><span id='topic+hdepth'></span>

<h3>Description</h3>

<p><code>hdepth()</code> computes the h-depths of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdepth(tp, data, number.of.directions=181)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hdepth_+3A_tp">tp</code></td>
<td>
<p> two column matrix of the coordinates of points which h-depths are needed </p>
</td></tr> 
<tr><td><code id="hdepth_+3A_data">data</code></td>
<td>
<p> two column matrix of the coordinates of the points of a data set</p>
</td></tr> 
<tr><td><code id="hdepth_+3A_number.of.directions">number.of.directions</code></td>
<td>
<p> number of directions to be checked </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>hdepth</code> computes the h-depths of the points
<code>tp</code> relative to data set <code>data</code>. If <code>data</code> is 
missing <code>tp</code> will also be taken as data set.
</p>


<h3>Value</h3>

<p>the h-depths of the test points
</p>


<h3>Note</h3>

<p>Version of bagplot: 12/2012 </p>


<h3>Author(s)</h3>

<p> Peter Wolf </p>


<h3>See Also</h3>

 <p><code><a href="#topic+bagplot">bagplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # computation of h-depths
  data &lt;- cbind(rnorm(40), rnorm(40)) 
  xy &lt;- cbind(runif(50,-2,2),runif(50,-2,2))
  bagplot(data); text(xy, as.character(hdepth(xy,data)))
</code></pre>

<hr>
<h2 id='iconplot'>
Icon Plots for Visualization of Contingency Tables
</h2><span id='topic+iconplot'></span>

<h3>Description</h3>

<p>An icon plot is a graphical representation of a contingency table.
<code>iconplot(</code> computes a icon plot of a data matrix (matrix or data frame) or of 
an object of class <code>table</code>. 
Based on argument <code>grp.xy</code> the data set is split into groups.  Similarly the 
graphics region is divided into panels.  Then the elements of the groups are 
visualized within the associated panels.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  iconplot(data
 ,  grp.xy = 2 ~ 1                               
 ,  grp.color = NULL                             
 ,  grp.icon = NULL                               
 ,  colors                                    
 ,  icons                                      
 ,  vars.to.factors
 ,  panel.reverse.y = FALSE                      
 ,  panel.space.factor = 0.05                        
 ,  panel.prop.to.size = c(FALSE, FALSE)  
 ,  panel.margin = 0.03
 ,  panel.frame = TRUE                                   
 ,  panel.adjust = c(0.5, 0.5)
 ,  icon.horizontal = TRUE                        
 ,  icon.stack.type = c("lt", "lb", "rt", "rb")[1]
 ,  icon.cex = NA                                 
 ,  icon.aspect = 1                              
 ,  icon.stack.len = NA                           
 ,  icon.space.factor = 0.3 
 ,  icon.grey.levels = 2 
 ,  icon.frame = TRUE                         
 ,  icon.draft = TRUE                                 
 ,  lab.side = c("bl", "br", "tl", "tr")[1]      
 ,  lab.parallel = c(TRUE, TRUE)           
 ,  lab.cex = 1                                  
 ,  lab.boxes = 2                                
 ,  lab.color = c("#CCCCCC", "white")       
 ,  lab.type = c("expanded", "compact")[2] 
 ,  lab.n.max = c(20, 30)
 ,  lab.legend = c("cols","rows","skewed","horizontal","vertical")[2]
 ,  packer = c("icons", "numbers", "panel.legend", "stars")[1]   
 ,  panel.text =  NULL
 ,  mar = rep(1, 4)                            
 ,  main                                                  
 ,  verbose = !TRUE
 ,  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iconplot_+3A_data">data</code></td>
<td>

<p>a data matrix, a data frame or an object of class <code>table</code>. 
Note: If the column or dimension names are elements of the 
following set of reserved names: <br />
<code>.sign, .fraction, .color, .icon, .job.no, .x0, .x1, .y0, .y1</code><br />
strange results may occur; therefore, avoid these variable names. 
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_grp.xy">grp.xy</code></td>
<td>

<p>a formula specifying how the data set is divided into groups and 
defines in which panel an element of the data is represented. 
The formula <code>y1 ~ x1</code> means that the data set is split
according to the levels of the variables <code>y1</code> and <code>x1</code> into groups. 
If <code>n.level.y1</code> and <code>n.level.x1</code> are the numbers of levels of the 
two variables the plotting region is divided like a chessboard into 
<code>n.level.y1</code> rows and <code>n.level.x1</code> columns. 
In this way we get <code>n.level.y1 * n.level.x1</code> fields that are called panels.
In each of the panels the elements of the associated group are represented 
by pictogram elements or icons. 
</p>
<p>If the argument <code>grp.xy</code> hasn't been set by default the first variable 
of the data set defines the grouping of the data along the x-axis and 
the second one the grouping along the y-axis.
</p>
<p>Instead of variable names the indices of the variables can be used.
</p>
<p>The definition of recursive groupings is allowed and is expressed 
by operator <code>"+"</code>:
<code>y ~ 3 + 4</code> means that the horizontal range of the graphical region 
is split twice: At first the segmentation of the region is computed 
according to variable 3, in the second step the subranges of step 1 
will be divided as a function of the levels of variable 4.
</p>
<p>A <code>"0"</code> on one side of the <code>~</code> character indicates that 
no splitting of the correspondent region is desired.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_grp.color">grp.color</code></td>
<td>

<p>defines how the data are grouped with respect to coloring. The name 
of the variable used for coloring the icons (or pictogram elements) 
has to be assigned to <code>grp.color</code>.
<code>colors[i]</code> defines the color of the icon belonging to the level <code>i</code> 
of the variable fixed by <code>grp.color</code>.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_grp.icon">grp.icon</code></td>
<td>

<p>defines how the data are grouped with respect the associated icon. 
The name of the variable used for selecting symbols or icons has to be fixed 
by argument <code>icons</code>. The symbol (icon) representing an observation 
depends on its level of the variable specified by <code>grp.icon</code>. <br />
If additional variables &ndash; separated by a <code>+</code> character &ndash; are found 
the values of these variables will be used in the call of a icon
generating function. For details see paragraph 'Details'.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_colors">colors</code></td>
<td>

<p>set of colors used for pictogram elements.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icons">icons</code></td>
<td>

<p>defines the icons or the set of icons used by <code>iconplot</code>. 
If <code>icons</code> is a vector <code>icons[i]</code> is used to represent the observations
whose level of the variable fixed by <code>grp.icon</code> is <code>i</code>.
There are some alternatives to define the icons or pictogram elements: <br />
* default: 
the default symbol is a rectangle.<br />
* vector of numbers: 
numbers specify plotting characters of the graphics system similar to 
<code>points(..., pch = 13)</code>. <br />
* list of raster images: 
the images are used as icons. <br />
* character vector: 
<code>icons[i]</code> with an extension indicating a <code>pnm</code>, <code>ppm</code>, <code>jpg</code> or 
<code>png</code> image file: <code>iconplot</code> tries to use the image of the file as icon.<br />
Otherwise <code>icons[i]</code> is interpreted as the name of an internal icon generating 
function.<br />
* list of functions:
<code>icons[i]</code> is interpreted as an icon generating function and is called to 
compute the icon for level <code>i</code>.<br />
* list of icon descriptions. For details see paragraph &quot;Details&quot;.<br />
Note: If an image file is defined by an internet link it is temporarily downloaded
using <code>tempfile()</code> and <code>download.file()</code>.<br />
Note: Mixtures of these alternative definition don't work usually. Therefore, it is
recommended to use one type of definition only.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_vars.to.factors">vars.to.factors</code></td>
<td>

<p>controls the transformation of variables to factors. 
If missing it is set to <code>TRUE</code> for each of the relevant variables.
If <code>vars.to.factors</code> is a vector and if its elements don't have names
the variables <code>1:length(vars.to.factors)</code> are transformed. <br />
If <code>vars.to.factors</code> consists of named elements the names indicate 
the variables to be transformed. <br />
If <code>vars.to.factors[i] == FALSE</code> variable <code>i</code> will not be transformed. <br />
If <code>vars.to.factors[i] == 1</code> variable <code>i</code> is transformed to a factor. <br />
If <code>vars.to.factors[i] &lt; 1</code> the range of variable <code>i</code> is cut into groups 
in a way that we approximately get <code>round(1/vars.to.factors[i])</code> groups and 
each of the groups approximately contain <code>100 * vars.to.factors[i]</code> percent 
of the data.
If <code>vars.to.factors[i] &gt; 1</code> the range of variable <code>i</code> will be cut into 
<code>floor(vars.to.factors[i])</code> subranges of equal size and 
you get a factor variable with <code>floor(vars.to.factors[i])</code> levels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.reverse.y">panel.reverse.y</code></td>
<td>

<p>logical, if <code>TRUE</code> the vertical axis is reversed.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.space.factor">panel.space.factor</code></td>
<td>

<p>relative space inserted between the panels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.prop.to.size">panel.prop.to.size</code></td>
<td>

<p>a vector containing two elements which controls the sizes of the panels. 
The first entry determines the widths of the panels and the second one their heights.<br />
<code>panel.prop.to.size[1] == 0</code> means all panels are of the same width.  <br />
If <code>panel.prop.to.size[2] == 0</code> the panels are of the same height. 
A value of 1 indicates that sizes should be computed proportional to the 
frequencies of the levels. 
Otherwise the sizes of the panels are fixed proportional to: <br />
<code>frequencies^panel.prop.to.size</code>.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.margin">panel.margin</code></td>
<td>

<p>controls the margins around the regions of the panels.  If this argument is 
a vector of length four the elements refer to the four sides of the plot: 
bottom, left, top, and right. If this argument is set to <code>c(0, 0.1, 0.5, 0)</code>
we get no additional margin below the panels and on the right-hand side. 
However, there will be an upper margin of size <code>100 * 0.5</code> percent of 
the height of the area containing the panels and a margin of size code100 * 0.1 
percent of the width on the left-hand is provided. 
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.frame">panel.frame</code></td>
<td>

<p>logical, if <code>TRUE</code> a border line is drawn around each of the panels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.adjust">panel.adjust</code></td>
<td>

<p>controls the adjustment of the panels within their regions.
This argument modifies the internal coordinates and do usually not 
change the appearance of the plot.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_panel.text">panel.text</code></td>
<td>

<p>vector of strings. The text <code>panel.text[i]</code> is written into <code>panel[i]</code>. 
The texts can be used for short describitions of the contents of the panels. 
To get an idea of the numbering of the panels you can set <code>panel.text = 1:20</code>.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.horizontal">icon.horizontal</code></td>
<td>

<p>logical, if <code>TRUE</code> the stacks of icons or pictogram elements are plotted 
horizontally.  This argument effects the way how icons are put into the panels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.stack.type">icon.stack.type</code></td>
<td>

<p>defines the method of plotting the stacks of icons: 
&quot;r&quot; or &quot;l&quot; are shortcuts for &quot;right&quot; or &quot;left&quot;.
&quot;t&quot;, &quot;b&quot; correspond to &quot;top&quot; and &quot;bottom&quot;, respectively. 
Note: Fractional parts of frequencies are represented by smaller icons. 
Adding the letter <code>"s"</code> (as a abbreviation for &quot;shrinkage&quot;) to the argument 
<code>icon.stack.type</code> both dimensions of the icons are reduced.
If <code>icon.stack.type</code> is a vector its elements define the different types 
of stacking for the panels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.cex">icon.cex</code></td>
<td>

<p>size of icons; this argument is similar to <code>cex</code> of <code>points()</code>.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.aspect">icon.aspect</code></td>
<td>

<p>aspect ratio of icons: width / height.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.stack.len">icon.stack.len</code></td>
<td>

<p>maximal number of icons gathered to build a stack. If this length is decreased
the number of stacks (rows or columns of icons) will increase.
</p>
</td></tr> 
<tr><td><code id="iconplot_+3A_icon.space.factor">icon.space.factor</code></td>
<td>

<p>relative space between two icons.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.grey.levels">icon.grey.levels</code></td>
<td>

<p>controls the coloring of icons of class raster or images. 
An image from a file is transformed to black-and-white and then recolored by 
<code>color</code>; if <code>is.na(color)</code> the original image is used.
<code>icon.grey.levels</code> defines the grey levels of the black-and-white image as well as 
the recoloring.
If <code>icon.grey.levels</code> is a single decimal value and is in (0,1) the pixels 
which levels are greater than <code>icon.grey.levels</code> are recolored by <code>color</code>.
If <code>icon.grey.levels</code> is a single decimal value and is in (-1,0) the pixels 
which levels are less than <code>abs(icon.grey.levels)</code> are recolored by <code>color</code>.
If <code>icon.grey.levels</code> consists of two decimal values in (0,1) pixels 
which level are within the intervall of the values are recolored by <code>color</code>.
If <code>icon.grey.levels</code> is an integer <code>icon.grey.levels &gt; 1</code> a vector of 
equal spaced fractions in (0,1) is created.
If <code>icon.grey.levels</code> is an integer <code>icon.grey.levels &lt; -1</code> a vector of 
limits in (0,1)
is created in a way that the observed frequencies of the classes defined by the 
limits are equal.
If <code>icon.grey.levels</code> is a vector and <code>all(icon.grey.levels &lt; 1)</code> 
<code>puticon</code> tries to create different intensities of <code>color</code> for recoloring pixels.
</p>
</td></tr> 
<tr><td><code id="iconplot_+3A_icon.frame">icon.frame</code></td>
<td>

<p>logical, if <code>TRUE</code> a border is drawn around each of the pictograms.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_icon.draft">icon.draft</code></td>
<td>

<p>logical, if <code>TRUE</code> raster images are generated by calling 
<code>rasterImage()</code> with the setting <code>interpolate = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_mar">mar</code></td>
<td>

<p>this argument is delivered to the graphics device via <code>par()</code> and manipulates 
the margins of the plot.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_main">main</code></td>
<td>

<p>defines the title of the plot.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.side">lab.side</code></td>
<td>

<p>defines one or two sides that are used for margin information: 
&quot;l&quot; indicates the &quot;left&quot; side, &quot;b&quot; identifies the &quot;bottom&quot;
as well as &quot;r&quot; the &quot;right&quot; and &quot;t&quot; the &quot;top&quot; side.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.parallel">lab.parallel</code></td>
<td>

<p>logical, if <code>FALSE</code> margin labels are perpendicularly constructed to the axes. 
If <code>lab.parallel</code> is a vector the first element is used 
for controlling the labels of the bottom or top side and 
the second one specifies the orientation of the y-labels. 
If one elements is set to 0.5 the labels of the last <code>xy</code> grouping variable 
are printed perpendicularly only.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.legend">lab.legend</code></td>
<td>

<p>a character string indicating the kind of legend out of the vector <br />
<code>c("cols", "rows", "skewed", "horizontal", "vertical")</code>. <br />
Assigning a number of the set <code>1:5</code> to the argument is interpreted as an
index of the set of the five types of legends.<br />
<code>"cols"</code>: vertical legends, side by side at the bottom side of the plot. <br />
<code>"rows"</code>: horizontal legends, line by line at the bottom side of the plot. <br />
<code>"skewed"</code>: horizontal legends, line by line and the level names are rotated. <br />
<code>"horizontal"</code>: horizontal legends, side by side at the bottom side of the plot.<br />
<code>"vertical"</code>: vertical legends, line by line at the right side of the plot.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.cex">lab.cex</code></td>
<td>

<p>sets the size of the characters of the labels and the legends.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.boxes">lab.boxes</code></td>
<td>

<p>defines the types of boxes around the margin labels: 
<code>lab.boxes == 0</code>: no boxes are drawn. <br />
<code>lab.boxes &gt;= 1</code>: small boxes around the labels are drawn. <br />
<code>lab.boxes &gt;= 2</code>: big boxes around the labels are drawn. <br />
<code>lab.boxes %% 1</code>: defines the size of the separation line 
between the names of the variables and the names of the levels.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.color">lab.color</code></td>
<td>

<p>The first element defines the color of the box containing the names of variables or 
levels in the margins. The second element sets the color of the separation line 
between the variable names and the level names within the margins.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.type">lab.type</code></td>
<td>

<p>defines the design style of margin labeling: 
&quot;c&quot; or &quot;e&quot; are shortcuts for &quot;compact&quot; or &quot;expanded&quot;.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_lab.n.max">lab.n.max</code></td>
<td>

<p>is an integer vector consisting of three elements. 
The first element sets the number of characters 
during printing the labels of the levels. The second element
defines the maximal number of level names to be plotted in the margins.
<code>lab.n.max[3]</code> limits the number of labels of the color- or icon-legend.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_packer">packer</code></td>
<td>

<p>defines the packer(s) which are used to fill the panels. 
If &quot;icons&quot; is an element of <code>packer</code> the observations will be represented 
by icons, pictogram elements or symbols. <br />
If the character string &quot;numbers&quot; is found in <code>packer</code> in each of the panels
the numbers of its observations will be printed into the areas of the panels.<br />
The packer &quot;panel.legend&quot; plots the level combinations into the panels.
This may be a useful feature as long as the number of the panels is small.
Otherwise the texts of level combinations will overlap each other. 
The argument <code>cex</code> controls the size of the text strings.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_verbose">verbose</code></td>
<td>

<p>logical, if <code>TRUE</code> internal information is printed during the computation.
</p>
</td></tr>
<tr><td><code id="iconplot_+3A_...">...</code></td>
<td>

<p>arguments that will be passed to the graphics functions and suitable ones to 
the icon generating functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>iconplot()</code> constructs an icon plot of a data matrix and a contingency table.
In an icon plot each observation of the data set is represented by a small symbol 
or an image called pictogram or icon.  A cell of a contingency table is visualized 
by a set of icons.  The icons of a cell are plotted within a rectangular region
which we call panel and an icon plot consists of a lot of panels containing
the icons of the cells.
</p>
<p>Similar to the layout of contingency tables the set of panels are arranged 
in a grid-like manner.  Considering a high dimensional contingency table you can 
concentrate on some of the variables and can construct suitable margin tables.
Equivalently you can build a lot of icon plots to emphasize your viewpoint.
By varying the actual arguments of <code>iconplot()</code> a huge set of appearances 
of plots results and the nicest one for your purpose can be choosen.
<code>table</code>, <code>matrix</code> or <code>data frames</code> can be used as data input   
of <code>iconplot()</code>. Tables are allowed to have fractional or negative entries; 
these cases may occur by computing the difference of two tables or by changing 
the units of counting. Internally a table will be expanded to a data matrix. 
Fractional numbers are coded in a data matrix by the additional column or variable 
<code>.fraction</code>, to handle negative numbers the new variable <code>.sign</code> is added.
</p>
<p>The argument <code>grp.xy</code> of <code>iconplot</code> defines the variables used for grouping 
and splitting the data dependent on the levels of the specified variables. 
Each group is represented within a panel as stated above. Let's have a look at an example:
Consider you have a 2x3 contigency table and would like to represent it by an icon plot.
So a plot to be constructed should have 2x3 panels and the number of icons of the panels 
should be given by the cell entries.  To get an icon plot with desired panel structure 
you define the xy-grouping by <code>grp.xy = 1 ~ 2</code>. 
This means: The data set has to be split according to the two levels of the first variable
and the y-range of the plot has to be divided in two rows of panels. 
On the other side the second variable defines the grouping concerning the 
the x-range and three columns of panels appear.  As a result a icon plot is generated 
that consists of six panels arranged in two rows and three columns.
The panels of a fixed level of the first variable are placed side by side, 
whereas the panels of a fixed level of the second variable are stacked one upon 
the other and a layout known from a chessboard results. As an example try: 
<code>x &lt;- as.table(matrix(1:6, 2, 3)); iconplot(x, grp.xy = 1 ~ 2)</code>
<code>grp.xy = 0 ~ 1 + 2</code> leads a double grouping on the
x-axis and no vertical grouping. <code>grp.xy = 1 + 2 ~ 3 + 4</code> presums four or more
variables and splits the graphics region twice along the x- and twice along 
the y-direction.
</p>
<p>Within a panel the entry of one cell is represented. 
Several arguments control the way how the icons are placed in a panel.
The absolute size of the icons can be defined by <code>icon.cex</code>.
<code>icon.aspect</code> fixes the aspect ratio of the pictograms (width / height).
The elements in a panel are assembled into stacks; 
the maximal length of these stacks can be set by <code>icon.stack.len</code>; 
horizontal stacks are plotted if <code>icon.horizontal</code> is <code>TRUE</code>. 
Framing icons and spacing between them is controlled by the arguments
<code>icon.frame</code> and <code>icon.space.factor</code>. 
</p>
<p>The icons or pictogram elements may be colored dependent on the levels of a
variable. The variable has to be established by argument <code>grp.color</code>. 
A set of colors can be defined by argument <code>colors</code>. 
Accordingly, the symbols or images are determined by <code>grp.icon</code> and <code>icons</code>.
</p>
<p>An icon or pictogram element can be generated by an icon generating function.
The result of an icon generating function describes a standardized icon by a
set of segments, polygons, splines and texts which are combined in a list.
<code>segments</code>: <code>segments</code> are defined by a matrix or a data frame of 5 or 6 columns:
Columns 1 to 4 keep the coordinates of the starting and ending points of the segments: 
<code>x.0, y.0, x.1, y.1</code>.<br />  
The 5th column contains the widths of the segments. 
The coordinates and the widths have to be choosen in a way 
that the icon fits pretty well into a plotting field of size 100mm x 100mm 
assuming the coordinates of the world window defined by: <code>usr = c(0, 100, 0, 100)</code>.<br />
If the 6th column is available it defines the coloring of the segments.  A value of &quot;0&quot; 
codes the color &quot;white&quot; and the other values are interpreted as usually: &quot;1&quot; means &quot;black&quot; 
and any other color is processed as <code>col</code> in <code>points</code>, for example. 
An <code>NA</code> value instead of a color instructs <code>iconplot()</code> to color the segment 
dependent on the associated level of the variable fixed by <code>grp.color</code>.
Segment objects must have the class attribute <code>"segments"</code>.
</p>
<p><code>polygon</code>: Polygons are defined by a matrix or data frame of 2 or 3 columns. 
Colums 1 and 2 store the coordinates of the vertices of the polygon. 
A third column fixes the coloring of the polygon. 
The class attribute of this kind of element has to be set to <code>"polygon"</code>.
</p>
<p><code>spline</code>: Splines are defined by a matrix or data frame of 3 or 4 columns. 
Colums 1 and 2 store the coordinates of the points which form the basis of the spline. 
The third column keeps the line width of the curve. The optional fourth column shows 
how to color the spline. Splines are identified by class attribute <code>"spline"</code>.
</p>
<p><code>text</code>: Text elements of a generated icon are defined by 
a data frame of 3, 4 or 5 columns.
The first two columns of the object store the coordinates of the positions of the text(s). 
The third element stores the text information and 
the fourth is used to set the size of the characters. 
The fifth fixes the coloring of the text. 
The class attribute of a text element is <code>"text"</code>.
There are some internal icon generating functions. Here is a list of them: <br />
<code>BI, TL, cross.simple, cross, circle.simple, circle, car.simple, car, nabla</code>, 
<code>walkman, smiley.blueeye, smiley.normal, smiley, smiley.sad, mazz.man, bike</code>,
<code>bike2, heart, bend.sign, fir.tree, comet, coor.system</code>.
</p>


<h3>Value</h3>

  
<p><code>iconplot()</code> returns a list consisting of three elements. The first element is 
the matrix <code>jobs</code> whose lines show some attributes of the panels. 
In a row of this matrix you find the number of the panel <code>.job.no</code> and 
the location of the panel (in user coordinates: <code>xmins, xmaxs, ymins, ymaxs</code>).
The second element is a copy of the modified data matrix which is used for 
the construction of the icon plot: Besides the data delivered by the user
there are columns showing the colors, icons and coordinates of the pictogram elements.
The third element contains the output of <code>par()</code> and describes the graphics device 
during the computation; this list differs from the parameter settings after leaving 
<code>iconplot()</code> because the state of graphics parameter before calling <code>iconplot()</code>
is restored.  These three lists may be helpful if you want to add further graphical elements 
to the plot.
</p>


<h3>Note</h3>

<p>Remark: the version of <code>iconplot</code> of this package is an experimental version. 
Therefore, in the future some of the features may be changed and it is not sure 
that the function works as described on all types of graphics devices. 
In case of errors feel free to write a mail.
Additional information and examples are found on the web page<br />
<a href="https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml">https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml</a>.
</p>


<h3>Author(s)</h3>

<p>Hans Peter Wolf
</p>


<h3>See Also</h3>

<p><code>mosaicplot</code>, <code>pairs</code>, <code>puticon</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HairEyeColor data, grouping by color
iconplot(HairEyeColor, 
         grp.color         = 1, 
         grp.xy            = NULL, 
         colors            = c("black", "brown", "red", "gold"),
         icon.space.factor = 0, 
         icon.aspect       = 2,
         main = "grouping by color")
# HairEyeColor data, grouping by color and symbols
iconplot(HairEyeColor, 
         grp.icon          = "Sex", 
         grp.color         = "Hair", 
         grp.xy            = NULL, 
         colors            = c("black", "brown", "red", "gold"),
         icons             = 18:17,
         icon.frame        = FALSE, 
         lab.cex           = 0.8, 
         icon.space.factor = 0, 
         lab.parallel      = !FALSE,
         main = "grouping by color and icons")
# HairEyeColor data, grouping by x and color
iconplot(HairEyeColor, 
         grp.xy            = "0 ~ 1", 
         grp.color         = 2, 
         colors            = c("black", "brown", "red", "gold"),
         icon.stack.type   = "tr", 
         icon.space.factor = c(0, 0.4), 
         lab.cex           =0.7, 
         main = "grouping by x and by colors")
# 2-dim, 1 split in y, 1 split in x, grouping by color
iconplot(HairEyeColor, 
         grp.xy          = "1 ~ 3", 
         grp.color       = 2, 
         colors          = c("brown", "blue", "brown3", "green"),
         panel.frame     = FALSE,
         icon.stack.type = "bl",
         lab.cex         = 0.7, 
         main = "grouping by x and y and by colors")
# 3-dim, 2 splits in x, 1 split in x, margin labs on the right
iconplot(HairEyeColor, 
         grp.xy             = "2 ~ 1 + 3 ", 
         grp.color          = 2, 
         panel.space.factor = c(0, .1), 
         panel.margin       = c(.05,.03,.03,.01),
         icon.stack.type    = "lb", 
         icon.stack.len     = 7, 
         icon.frame         = FALSE,
         icon.space.factor  = .0, 
         lab.parallel       = c(TRUE, FALSE), 
         lab.color          = c("lightblue","green"),
         lab.side           = "br", 
         lab.boxes          = 0.2, 
         lab.type           = "compact", 
         lab.cex            = 0.8, 
         main = "grouping: 2~1+3 and by color, margin labs variations")
# 3-dim, 3 splits in y, icon.aspect = NA
iconplot(HairEyeColor, 
         grp.xy             = "3 + 2 ~ 1", 
         grp.color          = 3, 
         panel.margin       = 0, 
         panel.space.factor = 0.1, 
         icon.stack.type    = "lb", 
         icon.horizontal    = TRUE, 
         icon.stack.len     = 5, 
         icon.space.factor  = c(.1, .3), 
         icon.aspect        = NA, 
         icon.frame         = FALSE,
         lab.boxes          = 0.3, 
         lab.color          = "grey", 
         lab.side           = "tl",
         lab.parallel       = TRUE, 
         lab.cex            = 0.7, 
         lab.type           = "compact", 
         main = "grouping: 3 + 2 ~ 1 and by color")
# 3-dim, plotting characters as icons
data &lt;- as.table(array(0:23, 2:4))
iconplot(data, 
         grp.xy          = 1 + 2 ~ 3, 
         grp.color       = 3, 
         grp.icon        = 2,
         icon.aspect     = 2, 
         icon.horizontal = TRUE, 
         icons           = 15:18,
         icon.stack.type = c("lb", "lt", "rb","rt")[3], 
         icon.frame      = FALSE,
         lab.cex         = .6, 
         lab.type        = "compact", 
         main = "1+2 ~ 3")
# 3-dim contingency table: panels of different sizes, 1 split in y, 2 in x
# packer numbers
  ## because of computation time
iconplot(Titanic, 
         grp.xy             = 1~3+2, 
         grp.color          = 1, 
         packer             = c("icons", "numbers"), 
         panel.prop.to.size = 0.5, 
         panel.frame        = !TRUE, 
         panel.margin       = .01, 
         icon.aspect        = 0.15, 
         icon.stack.type    = "lt", 
         icon.space.factor  = 0.0,
         icon.frame         = FALSE,
         lab.side           = c("bl","br","tl","tr")[1], 
         lab.type           = "compact", 
         lab.cex            = 0.8, 
         lab.boxes          = 1.1, 
         lab.color          = "lightgreen",
         lab.parallel       = TRUE, 
         main = "different sizes of panels")

# 3-dim contingency table: panels of different sizes, 3 splits in y
  ## because of computation time
iconplot(Titanic, 
         grp.xy             = "4 + 3 + 1 ~ 0" , 
         grp.color          = 4, 
         colors             = c("green", "red"), 
         packer             = c("icons", "numbers"), 
         panel.frame        = FALSE, 
         panel.margin       = .01,
         panel.prop.to.size = .3, 
         panel.space.factor = 0.05, 
         panel.reverse.y    = TRUE,
         icon.space.factor  = 0.5, 
         lab.side           = "l", 
         lab.type           = "compact",
         lab.parallel       = c(FALSE, TRUE), 
         lab.cex            = 0.7,
         main = "Titanic data, different sizes of panels")

#  3-dim contingency table: panels of different sizes 
  ## because of computation time
iconplot(Titanic, 
         grp.xy             = "0 ~ 4 + 3 + 1 " , 
         grp.color          = 4, 
         colors             = c("green", "red"), 
         panel.frame        = FALSE, 
         panel.margin       = .01,
         panel.prop.to.size = .2, 
         panel.space.factor = 0.05, 
         panel.reverse.y    = TRUE,
         icon.space.factor  = 0.5, 
         lab.side           = "b", 
         lab.type           = "compact", 
         lab.boxes          = 0.2, 
         lab.parallel       = c(FALSE, TRUE), 
         lab.cex            = 0.6,
         lab.color          = c("lightblue"),
         main = "Titanic data, different widths of panels")

# 3-dim contingency table: panels of different sizes, 3 splits in x 
  ## because of computation time
iconplot(Titanic, 
         grp.xy             = 3 + 2 ~ 1, 
         grp.color          = 2, 
         panel.prop.to.size = 0.66,
         icon.space.factor  = 0.4, 
         panel.space.factor = 0.1,
         lab.type           = "c", 
         lab.cex            = 0.7, 
         lab.boxes          = 1.2,
         lab.color          = c("lightblue"),
         main = "Titanic: panel.prop.to.size = 0.66")

# comparing iconplot and mosaic plot
# par(mfrow = 2:1)
iconplot(HairEyeColor, 
         grp.xy             = 2 ~ 1 + 3 , 
         lab.parallel       = c(TRUE, TRUE),
         colors             = "red", 
         panel.reverse.y    = TRUE, 
         panel.prop.to.size = TRUE,
         icon.space.factor  = 0.5, 
         icon.aspect        = 2,
         lab.cex            = .6, 
         lab.boxes          = 1, 
         lab.color          = "grey", 
         # lab.side           = "lt", 
         panel.margin       = c(0.00,.035,0.0,.050),
         main = 'HairEyeColor: grp.xy = 2 ~ 1 + 3')
mosaicplot(HairEyeColor)
# par(mfrow = c(1,1))
# relative frequences 
data &lt;- as.table(Titanic / max(Titanic))
iconplot(data, 
         grp.xy             = 1 ~ 2 + 3, 
         grp.color          = 4, 
         panel.frame        = FALSE, 
         panel.space.factor = 0.05, 
         icon.horizontal    = !TRUE, 
         icon.space.factor  = 0.103, 
         icon.stack.type    = "b",
         icon.aspect        = 0.5,
         main = "Titanic: relative frequencies", colors = c("black", "green"))
# negative and fractional cell entries
  ## because of computation time
data &lt;- HairEyeColor; Exp &lt;- margin.table(data, 1)
for( d in 2:length(dim(data)) ){
  Exp &lt;- outer( Exp, margin.table(data, d) ) / sum(data)
}
Diff &lt;- Exp - data
cat("observed:\n"); print(data)
cat("expected:\n"); print(round(Exp, 3))
cat("deviation: expected - observed:\n"); print(round(Diff,3))
iconplot(Diff, 
         grp.xy          = 1 + .sign ~ 2 + 3, 
         grp.color       = ".sign", 
         colors          = c( "red", "green"),
         panel.reverse.y = TRUE, 
         panel.frame     = FALSE,
         icon.stack.type = c("t","b"), 
         lab.boxes       = 1.2,  
         lab.color       = "lightgreen",
         main = "deviations from expectation: HairEyeColor")

# relative differences of expectations, split according sign
data &lt;- margin.table(Titanic, c(2,1,4)); pT &lt;- prop.table(data)
eT &lt;- outer(outer(margin.table(pT,1), margin.table(pT,2)), margin.table(pT,3))
data &lt;- as.table(pT - eT); data &lt;- data / max(data)
iconplot(data, 
         grp.xy = Survived + Sex + .sign ~ Class, 
         grp.color          = ".sign", 
         panel.frame        = FALSE, 
         panel.reverse.y    = TRUE, 
         panel.space.factor = 0.05, 
         icon.horizontal    = !TRUE, 
         icon.stack.type    = rep(c("t","b"), 2), 
         icon.aspect        = 2, 
         icon.space.factor  = 0.1, 
         lab.boxes          = 1.2, 
         lab.color          = "lightgrey",
         main = "Titanic: difference to expectation")
# using a foto as icon, rentals of flats in Goettingen 2015/12
rentels &lt;- 
 structure(list(Rooms = c(2, 3, 2, 2, 3, 2, 2, 3, 2, NA, 2, 2,            
 3, 4, 4, NA, 3, 2, 3, 2, 4, 2, 1, 2), qm = c(43.13, 86, 48, 66.62,        
 76, 49, 59, 97, 45, 87, 46.39, 71, 65, 100, 75, 178, 94.07, 56,           
 97, 70, 132, 43, 24, 48), Eur = c(365, 480, 480, 660, 500, 410,           
 440, 1200, 450, 696, 420, 710, 747.5, 1300, 450, 990, 900, 520,           
 1020, 1005, 924, 610, 375, 420)), class = "data.frame", 
 row.names = c(NA, 24L)) 
fname &lt;- system.file("src", "tm1.jpg", package="aplpack") # fname &lt;- "tm1.jpg" 
print(fname)
iconplot(rentels, 
         grp.xy              = Eur ~ qm, 
         vars.to.factors     = c(1, .5, .3),
         panel.frame         = FALSE, 
         panel.space.factor  = 0.2,
         panel.prop.to.size  = 0.7,
         icons               = fname, 
         icon.frame          = FALSE, 
         icon.space.factor   = 0.05,
         lab.parallel        = c(TRUE, TRUE), 
         lab.legend          = "cols",
         main = "rentels of flats in Goettingen 2015/12")
# size by .fractions, color by rooms
data &lt;- cbind(rentels, .fraction = (rentels[,3] / max(rentels[,3]))^.5)
iconplot(data, 
         grp.xy             = Eur ~ qm, 
         grp.color          = Rooms, 
         vars.to.factors    = c(1,.5, .3),
         panel.frame        = FALSE,
         panel.space.factor = 0.1,
         panel.prop.to.size = 0.7,
         icons              = fname,
         icon.stack.type    = "s",  
         icon.frame         = FALSE,
         icon.space.factor  = 0.05, 
         lab.cex            = 0.8,
         main               = "size fby .fractions, color by rooms")
# jpg files as icons 
  ## because of computation time
data &lt;- as.table(Titanic[2:3,,,,drop=FALSE]) / 10
fname1 &lt;- system.file("src", "walkman-r.jpg", package="aplpack") # fname1 &lt;- "walkman-r.jpg"
fname2 &lt;- system.file("src", "pw-esch.jpg", package="aplpack")   # fname2 &lt;- "pw-esch.jpg"
p.set &lt;- c(fname1, fname2)
iconplot(data, 
         grp.xy             = 2 ~ 3+1, 
         grp.color          = 1, 
         grp.icon           = 3, 
         icons              = p.set, 
         colors             = c("blue", "green"),
         panel.space.factor = 0.05, 
         panel.prop.to.size = c(.5, .5, 1),
         icon.aspect        = 1, 
         icon.space.factor  = .10, 
         icon.horizontal    = TRUE, 
         icon.draft         = FALSE,
         icon.stack.type    = c("lb", "lt", "rb","rt")[1], 
         icon.grey.levels   = list(2, 10), 
         lab.side           = "t", lab.cex = .7, 
         main = "walkman and pw icons, scaled subset of Titanic")

# files of different types as icons
  ## because of computation time
fname3 &lt;- system.file("src", "pw-esch.ppm", package="aplpack") # fname3 &lt;- "pw-esch.ppm"
fname4 &lt;- system.file("src", "pw-esch.png", package="aplpack") # fname4 &lt;- "pw-esch.png"
p.set &lt;- c(fname2, fname3, fname4)
iconplot(trees, 
         grp.xy             = Girth ~ Height, 
         grp.icon           = Height, 
         grp.color          = Volume, 
         vars.to.factors    = c(Volume = 4, Girth = 3, Height = 3), 
         panel.space.factor = 0.05, 
         panel.prop.to.size = c(.7, .45),
         panel.frame        = FALSE,
         icons              = p.set, 
         icon.cex           = 14,
         icon.grey.levels = 6, icon.space.factor   = 0.05 )

# using raster graphics objects as icons
data &lt;- as.table(Titanic[1:2,,,,drop=FALSE])/10
image1 &lt;- as.raster(  matrix( c(1,0,1,1,0,1,1,0,1), ncol = 3, nrow = 3))
image2 &lt;- as.raster(  matrix( c(1,0,1,0,0,0,1,0,1), ncol = 3, nrow = 3))
iconplot(data, 
         grp.xy            = 2 ~ 4+1, 
         grp.color         = 1, 
         grp.icon          = 4, 
         colors            = c("blue", "green"), 
         icons             = list(image1, image2),
         icon.aspect       = 1,    
         icon.space.factor = .10, 
         icon.horizontal   = TRUE, 
         icon.draft        = FALSE,
         icon.stack.type   = c("lb", "lt", "rb","rt")[1], 
         icon.grey.levels  = list(2, 10), 
         lab.side = "t", lab.cex = .7, main = "some Titanic data")
# using internal generator "fir.tree"
  ## because of computation time
data &lt;- trees
iconplot(data, 
         grp.color          = 3, 
         grp.xy             = 1 ~ 2, 
         vars.to.factor     = c(5, 5, 8), 
         icons              = "fir.tree", 
         colors             = rainbow(8, start = .1, end = .5), 
         icon.frame         = FALSE, 
         lab.legend         = 2, 
         lab.cex            = 0.7, 
         main = "grouping by vars and by colors")

# using different internal generators
data &lt;- trees
iconplot(data, 
         grp.color          = 1, 
         grp.xy             = 1 ~ 2, 
         grp.icon           = 2, 
         colors             = c("orange", "green", "orange", "red"), 
         icons = c("nabla", "BI", "walkman", "car.simple", "bike", "circle"), 
         vars.to.factor     = c(3,6), 
         lab.legend         = 2, 
         lab.cex            = 0.7, 
         main = "grouping by vars, by icons and by colors")
# Traveller plot proposed by M. Mazziotta and A. Pareto
Mazzi.Pareto &lt;- 
 structure(list(Region = c("Piemonte", "Valle d'Aosta", "Lombardia",  
 "Trentino-Alto Adige", "Veneto", "Friuli-Venezia Giulia", "Liguria", 
 "Emilia-Romagna", "Toscana", "Umbria", "Marche", "Lazio", "Abruzzo", 
 "Molise", "Campania", "Puglia", "Basilicata", "Calabria", "Sicilia", 
 "Sardegna"), Mean = c(98.74, 104.07, 101.38, 106.1, 104.38, 105.55,  
 102.76, 103.62, 101.84, 103.52, 102.05, 97.88, 102.9, 91.43,         
 94.12, 96.78, 93.55, 92.59, 96.29, 100.45), Penalty = c(0.43,        
 4.23, 0.64, 0.63, 0.77, 0.34, 0.29, 0.46, 0.27, 0.22, 0.15, 0.82,    
 1.3, 1.02, 0.37, 0.21, 2.37, 0.51, 0.31, 0.76), MPI = c(98.3,        
 99.84, 100.74, 105.47, 103.61, 105.21, 102.47, 103.16, 101.57,       
 103.3, 101.9, 97.06, 101.6, 90.42, 93.75, 96.58, 91.18, 92.08,       
 95.98, 99.69)), .Names = c("Region", "Mean", "Penalty", "MPI"        
 ), row.names = c(NA, -20L), class = "data.frame")
dm &lt;- cbind(Mazzi.Pareto, 
            col = as.factor(rep(1:4, 5)),        # as.factor!! 
            row = as.factor(rep(1:5, each = 4))) # as.factor!!
iconplot(dm, verbose = !TRUE, x.text = 60,  y.text = -10,  #t3s
         grp.xy            = row ~ col,
         grp.icon          = 0 + Mean +  Penalty + Region, 
         vars.to.factor    = FALSE,
         icons             = "mazz.man",
         panel.reverse.y   = TRUE,
         icon.space.factor = 0,
         icon.frame        = FALSE,
         lab.parallel      = TRUE,
         lab.side          = c("",""),
         main = "Traveller plot")
# definition of a check list, tally or 'Krebholz'
check.list &lt;- function(x, colors = rainbow(length(x))){
  num.split &lt;- function(x, div = 5){
    x.name &lt;- as.character(substitute(x))
    xn &lt;- lapply( x, function(x) 
       c(rep(div, x %/% div), if( 0 &lt; ( h &lt;- x %% div) ) h )
    )
    len &lt;- max(sapply(xn, length))
    xn &lt;- lapply( xn, function(x) c(x, rep(0, len - length(x) )))
    xn &lt;- matrix( unlist(xn), ncol = len, byrow = TRUE )
    xn &lt;- as.table(xn)
    dimnames(xn) &lt;- list( seq( along = x ), 1:len)
    names(dimnames(xn)) &lt;- c(x.name, "Blocks")
    xn
  }
  x.split &lt;- num.split(x)
  rownames(x.split) &lt;- paste(sep = ":", 1:length(x), x)
  iconplot(x.split, 
           grp.xy             = 1 ~ 2,  
           grp.col            = 1, 
           colors             = colors,
           panel.space.factor = c(0.4, 0.3), 
           panel.frame        = FALSE, 
           icon.stack.len     = 5, 
           icon.space.factor  = c(0.4, 0), 
           icon.asp           = NA, 
           icon.frame         = FALSE,
           lab.side           = "l", 
           lab.cex            = 0.7,
           main = paste("score of", substitute(x)))
  x.split
}
set.seed(13); data &lt;- sample(1:50, size = 15)
check.list(data)
</code></pre>

<hr>
<h2 id='plothulls'>plothulls for data peeling </h2><span id='topic+plothulls'></span>

<h3>Description</h3>

<p><code>plothulls plots convex hulls of a bivariate data set.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plothulls(x, y, fraction, n.hull = 1, main, add = FALSE, col.hull, 
    lty.hull, lwd.hull, density = 0, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plothulls_+3A_x">x</code></td>
<td>
<p> two column matrix of the coordinates of points of x-values of a data set</p>
</td></tr> 
<tr><td><code id="plothulls_+3A_y">y</code></td>
<td>
<p> if x is one dimensional then y contains the y-values of the data set</p>
</td></tr> 
<tr><td><code id="plothulls_+3A_fraction">fraction</code></td>
<td>
<p> ... of points that lies inside the hull to be plotted</p>
</td></tr> 
<tr><td><code id="plothulls_+3A_n.hull">n.hull</code></td>
<td>
<p> number of directions sequential hulls to be plotted</p>
</td></tr>
<tr><td><code id="plothulls_+3A_main">main</code></td>
<td>
<p> title for the graphics</p>
</td></tr>
<tr><td><code id="plothulls_+3A_add">add</code></td>
<td>
<p> if TRUE no new plot is initialized</p>
</td></tr>
<tr><td><code id="plothulls_+3A_col.hull">col.hull</code></td>
<td>
<p> color(s) of the hull(s)</p>
</td></tr>
<tr><td><code id="plothulls_+3A_lty.hull">lty.hull</code></td>
<td>
<p> line type(s) of the hull(s)</p>
</td></tr>
<tr><td><code id="plothulls_+3A_lwd.hull">lwd.hull</code></td>
<td>
<p> line width(s) of the hull(s)</p>
</td></tr>
<tr><td><code id="plothulls_+3A_density">density</code></td>
<td>
<p> density argument of polygon() that draws the hulls</p>
</td></tr>
<tr><td><code id="plothulls_+3A_...">...</code></td>
<td>
<p> further arguments used in the call of plot() or points()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>plothulls</code> computes hulls of a bivariate data set using the 
function <code>chull</code>. After finding a hull the hull maybe plotted. 
Then the data points of the hull will be removed and 
the hull of the remaining points is computed. 
The style of plotting a hull depends on the setting of 
<code>col.hull</code>, <code>lty.hull</code>, <code>lwd.hull</code> and <code>density</code>.
<code>density=NA</code> has the effect that the regions of the hulls are filled by a color.
Using <code>fraction</code> you can plot a single hull. 
<code>n.hull</code> defines the number of hull that should be drawn one after the other.
</p>


<h3>Value</h3>

<p>The  hull(s) are stored as a list of matrices with two columns, 
the innermost first and so on. 
</p>


<h3>Note</h3>

<p>Version of plothulls: 10/2013 </p>


<h3>Author(s)</h3>

<p> Peter Wolf </p>


<h3>References</h3>

 
<p>Green, P.J. (1981): Peeling bivariate data. 
In: Interpreting Multivariate Data, V. Barnett (ed.), pp 3-19, Wiley.
Porzio, Giovanni C., Ragozini, Giancarlo (2000): 
Peeling multvariate data sets: a new approach. Quanderni di Statistica, Vol. 2.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+bagplot">bagplot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  # 10 hulls computed from the faithful data and plotted
  plothulls(faithful, n.hull=10, lty.hull=1)
  # plotting additionally a hull with 90 percent of points within the hull
  plot(faithful)
  plothulls(faithful, fraction=.90, add=TRUE, col.hull="red", lwd.hull=3)
  # hull with 10 percent of points within the hull 
  plothulls(faithful, fraction=.10, col.hull="red", lwd.hull=3)
  # first 3 hulls of the cars data set
  n &lt;- 3
  plothulls(cars, n.hull=n, col.hull=1:n, lty.hull=1:n)
  # 5 hulls represented by colored regions
  n &lt;- 5
  cols &lt;- heat.colors(9)[3:(3+n-1)]
  plothulls(cars, n.hull=n, col.hull=cols, lty.hull=1:n, density=NA, col=0)
  points(cars, pch=17, cex=1)
  # 6 hulls: regions colored and boundaries shown
  n &lt;- 6
  cols &lt;- rainbow(n)
  plothulls(cars, n.hull=n, col.hull=cols, lty.hull=1:n, density=NA, col=0)
  plothulls(cars, n.hull=n, add=TRUE, col.hull=1, lwd.hull=2, lty=1, col=0)
</code></pre>

<hr>
<h2 id='plotsummary'>  graphical summaries of variables of a data set </h2><span id='topic+plotsummary'></span>

<h3>Description</h3>

                                                         
<p><code>plotsummary</code> shows some important characteristics of the variables of a data set.
For each variable a plot is computed consisting of a barplot, an ecdf, 
a density trace and a boxplot. </p>


<h3>Usage</h3>

<pre><code class='language-R'> 
 plotsummary(data, trim = 0, types = c("stripes", "ecdf", "density", "boxplot"),
             y.sizes = 4:1, design = "chessboard", main, mycols = "RB")
 </code></pre>


<h3>Arguments</h3>

                                                   
<table>
<tr><td><code id="plotsummary_+3A_data">data</code></td>
<td>
<p>   Data set for computing a graphical summary. </p>
</td></tr>      
<tr><td><code id="plotsummary_+3A_trim">trim</code></td>
<td>
   <p><code>trim</code> defines the fraction of observation for trimming on both  
ends of the data.  </p>
</td></tr>
<tr><td><code id="plotsummary_+3A_types">types</code></td>
<td>
<p>  vector of types of representation of the data set. 
The elements of the vector will induce small plots which are stacked 
in vertical order. The first letter of the types is sufficient for 
defining a type. </p>
</td></tr> 
<tr><td><code id="plotsummary_+3A_y.sizes">y.sizes</code></td>
<td>
<p>defines the relative sizes of the small plots. 
The values are divided by their sum to get percentages. </p>
</td></tr>                  
<tr><td><code id="plotsummary_+3A_design">design</code></td>
<td>
<p> if <code>design</code> is <code>chessboard</code> the graphics device 
is fragmented into rows and cols. Otherwise the images of a variable 
build vertical stripes.  </p>
</td></tr>                                                  
<tr><td><code id="plotsummary_+3A_main">main</code></td>
<td>
<p>   defines a title for the graphics.  </p>
</td></tr>                                           
<tr><td><code id="plotsummary_+3A_mycols">mycols</code></td>
<td>
<p> allows to define some colors for the showing the regions separated
by the quartils. </p>
</td></tr>              
</table>


<h3>Details</h3>

        <p><code>plotsummary</code> can be use for a quick and dirty inspection 
of a data matrix or a list of variables. 
Without further specification some representation of each of the 
variables is built and stacked into a plot. 
The sizes of the types of representation can be set as well as the 
layout design of the graphics device. It is helpful to trim the data 
before processing because outliers will often hide 
the interesting characteristics. </p>


<h3>Author(s)</h3>

                                                       
<p>Peter Wolf, pwolf@wiwi.uni-bielefeld.de
</p>


<h3>See Also</h3>

                                                         
<p><code><a href="graphics.html#topic+pairs">pairs</a></code>,   <code><a href="base.html#topic+summary">summary</a></code>,    <code><a href="utils.html#topic+str">str</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>                                                        
 ##---- Should be DIRECTLY executable !! ----         
 ##-- ==&gt;  Define data, use random,                      
 ##--\tor do  help(data=index)  for the standard data sets.   
 plotsummary(cars)
 plotsummary(cars, types=c("ecdf", "density", "boxplot"), 
             y.sizes = c(1,1,1), design ="stripes")
 plotsummary(c(list(rivers=rivers, co2=co2), cars), y.sizes=c(10,3,3,1), mycols=3)
 plotsummary(cars, design="chessboard")
 # find all matrices in your R
 ds.of.R &lt;- function(type="vector"){
   dat &lt;- ls(pos=grep("datasets",search()))
   dat.type &lt;- unlist(lapply(dat,function(x) {       
      num &lt;- mode(x&lt;-eval(parse(text=x)))
      num &lt;- ifelse(is.array(x),"array",num)
      num &lt;- ifelse(is.list(x),"list",num)
      num &lt;- ifelse(is.matrix(x),"matrix",num)
      num &lt;- ifelse(is.data.frame(x),"matrix",num)
      num &lt;- ifelse(num=="numeric","vector",num)
      num }))
   return(dat[dat.type==type])
 }
 namelist &lt;- ds.of.R("matrix")
 # inspect the matrices one after the other
 for(i in seq(along=namelist)){
   print(i); print(namelist[i])
   xy &lt;- get(namelist[i])
   # plotsummary(xy,y.sizes=4:1,trim=.05,main=namelist[i]) 
   # Sys.sleep(1)
 }
 </code></pre>

<hr>
<h2 id='puticon'>
Add Icon(s) to a Plot
</h2><span id='topic+puticon'></span>

<h3>Description</h3>

<p><code>puticon()</code> draws icons at the coordinates given by <code>x</code> and <code>y</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  puticon(x = 0, y = 0, icon = "", grey.levels = 0.5, icon.cex = 10, 
          color = "red", ..., adj = c(0.5, 0.5), xpd = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="puticon_+3A_x">x</code>, <code id="puticon_+3A_y">y</code></td>
<td>

<p>numeric vectors of coordinates where to plot icon(s).
If <code>x</code> is missing some information about internal icon 
generators are printed or plotted. 
</p>
</td></tr>
<tr><td><code id="puticon_+3A_icon">icon</code></td>
<td>

<p>icon to use. There are several ways to define an icon:
If <code>icon</code> is a file name with one of the extensions
<code>c(".jpg", ".JPG", ".pnm", ".PNM", ".png", ".PNG")</code>
<code>puticon()</code> tries to use the graphics file to plot the icon(s).
To read <code>jpeg</code> and <code>png</code> files the functions <code>jpeg</code> 
and <code>png</code> of the packages <code>jpeg</code> and <code>png</code> are called.
Note: If an image file is defined by an internet link it is temporarily downloaded
using <code>tempfile()</code> and <code>download.file()</code>.
</p>
<p>If <code>icon</code> is  a number a central symbol is plotted by invoking <code>points</code>.
Remark: Usually the width of central symbols are a little bit smaller than
<code>par()$cin[1]*0.75</code>. Therefore, it may be necessary to increase 
<code>icon.cex</code> to get an icon of a suitable size.
If <code>icon</code> is a raster graphics object this object is used as icon.
If <code>icon</code> is a string and if it is the name of an in internal 
icon generator (function) this generator is used to generate the icon(s). 
In the moment the following generators are implemented:<br />
<code>BI, TL, cross.simple, cross, circle.simple, circle, car.simple, car, nabla</code>, 
<code>walkman, smiley.blueeye, smiley.normal, smiley, smiley.sad, mazz.man, bike</code>,
<code>bike2, heart, bend.sign, fir.tree, comet, coor.system</code>.
If <code>icon</code> is a function it is used as an icon generating function.
</p>
</td></tr> 
<tr><td><code id="puticon_+3A_grey.levels">grey.levels</code></td>
<td>

<p>An image from a file is transformed to black-and-white and then recolored by 
<code>color</code>; if <code>is.na(color)</code> the original image is used.
<code>grey.levels</code> defines the grey levels of the black-and-white image as well as 
the recoloring.
If <code>grey.levels</code> is a single decimal value and is in (0,1) the pixels 
which levels are greater than <code>grey.levels</code> are recolored by <code>color</code>.
If <code>grey.levels</code> is a single decimal value and is in (-1,0) the pixels 
which levels are less than <code>abs(grey.levels)</code> are recolored by <code>color</code>.
If <code>grey.levels</code> consists of two decimal values in (0,1) pixels 
which level are within the intervall of the values are recolored by <code>color</code>.
If <code>grey.levels</code> is an integer <code>grey.levels &gt; 1</code> a vector of equal spaced 
fractions in (0,1) is created.
If <code>grey.levels</code> is an integer <code>grey.levels &lt; -1</code> a vector of limits in (0,1)
is created in a way that the observed frequencies of the classes defined by the 
limits are equal.
If <code>grey.levels</code> is a vector and <code>all(grey.levels &lt; 1)</code> <code>puticon</code> tries
to create different intensities of <code>color</code> for recoloring pixels.
</p>
</td></tr>
<tr><td><code id="puticon_+3A_icon.cex">icon.cex</code></td>
<td>

<p>size(s) of icon(s) in mm.  If <code>icon.cex &lt; 1</code> it is interpreted as ratio 
(width of icon) / (width of plotting area (<code>par()$pin[1]</code>)) and is transformed to mm.
</p>
</td></tr>
<tr><td><code id="puticon_+3A_color">color</code></td>
<td>

<p>color(s) to be used for the pictogram(s). <code>color</code> can be a color code or name, 
for details see section <code>Color Specification</code> of the help of <code>par</code>.
</p>
</td></tr>
<tr><td><code id="puticon_+3A_...">...</code></td>
<td>

<p>Further parameters to be passed to the icon generating function. 
</p>
</td></tr>
<tr><td><code id="puticon_+3A_adj">adj</code></td>
<td>

<p><code>adj</code> one or two values usually lying in [0, 1] and which specify the x (and y) 
adjustment of the icon(s).
</p>
</td></tr>
<tr><td><code id="puticon_+3A_xpd">xpd</code></td>
<td>

<p>controls clipping. See help of <code>par</code> for further explainations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details concerning icon generating function see the help of
<code>iconplot()</code>. 
If <code>puticon()</code> is called without argument <code>x</code> and <code>icon</code> 
is an empty string a list of internal generators will be returned.  
If <code>x</code> is missing  and <code>icon</code> is the name of an internal generator 
a standardized version of the icon is plotted and the arguments 
of the generator (function) are printed. 
</p>


<h3>Value</h3>

<p>Usually <code>Null</code> is returned. However, if no coordinates are set and the name 
of an internal generator is assigned to <code>icon</code> <code>puticon</code> returns the
definition of the generator function. 
</p>


<h3>Note</h3>

<p>Remark: the version of <code>puticon</code> of this package is an experimental version. 
Therefore, in the future some of the features may be changed and it is not sure 
that the function works as described on all types of graphics devices. 
In case of errors feel free to write a mail.
Additional information and examples are found on the web page<br />
<a href="https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml">https://www.uni-bielefeld.de/fakultaeten/wirtschaftswissenschaften/fakultaet/lehrende-ehemalige/pwolf/wolf_aplpack/index.xml</a>.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf
</p>


<h3>References</h3>

<p>under construction
</p>


<h3>See Also</h3>

<p><code>points</code>, <code>rasterImage</code>, <code>iconplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # representation of data set "trees" by plotting characters
  x &lt;- trees[,1]; y &lt;- trees[,2]; colors &lt;- rainbow(100)[floor(trees[,3])]
  plot(x, y, type = "n")
  puticon(x, y, icon = 1, color = colors, icon.cex = 15, lwd = 6)
  for(i in seq(along = x)){
    puticon(x[i], y[i], icon = i - 25 * ( i &gt; 25),
            color = "red", icon.cex = 7, lwd = 4)
  }
  # representation of data set "trees" by fir.tree icons
  x &lt;- trees[,1]; y &lt;- trees[,2]; colors &lt;- rainbow(100)[floor(trees[,3])]
  plot(x, y, type = "n")
  puticon(x, y, icon = "fir.tree", icon.cex = 10, color = colors, 
          height = y / 50, width = x / 10)
  # standardized design of icon generator "fir.tree" and its definition
  puticon( icon = "fir.tree" )
  # list of implemented icon generators / generator functions
  puticon()
  # demo of internal icon generator functions
  h &lt;- puticon(); n &lt;- length(h); y &lt;- 1 + ((1:n)-1) 
  plot(1:n, xlim = c(0, n + 4), ylim = c(0, n / 2 + 4), type = "n")
  for(i in 1:n) 
    puticon(i, y[i] + (0:1), h[i], icon.cex = 3 + (1:2) , color = 3:4)
  text(1:n - 0.3, y - 1, h, adj = c(0, 0.5))
  # some smileys and Bielefeld logos of different colors and different sizes
  plot(1:100, type = "n")
  n &lt;- 15; set.seed(26); x &lt;- seq(10, 90, length = n); y &lt;- runif(n, 10, 90)
  sizes &lt;- 5 + (1:n) / 4; my.color &lt;- rainbow(n); h &lt;- 2 + (1:n)^0.5
  puticon(x, y, icon = "BI", icon.cex = sizes, color = my.color)
  puticon(x + h, y + h, icon = "smiley", color = my.color, icon.cex = sizes)
  
  # icons with some letters
  n &lt;- 150; plot(1:n, 1:n, type = "n", xlab ="", ylab = "")
  x &lt;- runif(n, 1, n); y &lt;- runif(n, 1, n); colors &lt;- sample(rainbow(n))
  for(i in 1:n) 
    puticon(x[i], y[i], icon = "TL", icon.cex = 20, 
            shiftY = runif(1, -10, 10), color = colors[i],
            L = paste(sample(letters, sample(1:5, size = 1)), collapse = ""))  
  # a modern painting
  plot(1:20, xlim = c(-7,22), ylim = c(-7,22), type = "n", axes = FALSE, 
     xlab ="", ylab = "")
  rect(-7, -7, 22, 22, col = "gray")
  n &lt;- 100; set.seed(13); colors &lt;- sample(rainbow(n)); CEX &lt;- sort(runif(n, 2, 21))
  for(i in 1:n){
    icon &lt;- c("cross.simple", "cross", "circle.simple", "circle")[[sample(1:4, 1)]]
    puticon(runif(1, -5,20),  runif(1, -5, 20), icon, 
            icon.cex = CEX[i], z = runif(1, 0.20, 0.45), 
            whole = runif(1, 0.1, 0.6), color = colors[i])
  }
  
  # Traveller plot proposed by M. Mazziotta and A. Pareto.
  #   M. Mazziotta, A. Pareto (2016): 
  #   Non-compensatory Aggregation of Social Indicaters: An Icon Representation.
  #   url{http://link.springer.com/chapter/10.1007/978-3-319-05552-7_33}
  Mazzi.Pareto &lt;- 
   structure(list(Region = c("Piemonte", "Valle d'Aosta", "Lombardia",  
   "Trentino-Alto Adige", "Veneto", "Friuli-Venezia Giulia", "Liguria", 
   "Emilia-Romagna", "Toscana", "Umbria", "Marche", "Lazio", "Abruzzo", 
   "Molise", "Campania", "Puglia", "Basilicata", "Calabria", "Sicilia", 
   "Sardegna"), Mean = c(98.74, 104.07, 101.38, 106.1, 104.38, 105.55,  
   102.76, 103.62, 101.84, 103.52, 102.05, 97.88, 102.9, 91.43,         
   94.12, 96.78, 93.55, 92.59, 96.29, 100.45), Penalty = c(0.43,        
   4.23, 0.64, 0.63, 0.77, 0.34, 0.29, 0.46, 0.27, 0.22, 0.15, 0.82,    
   1.3, 1.02, 0.37, 0.21, 2.37, 0.51, 0.31, 0.76), MPI = c(98.3,        
   99.84, 100.74, 105.47, 103.61, 105.21, 102.47, 103.16, 101.57,       
   103.3, 101.9, 97.06, 101.6, 90.42, 93.75, 96.58, 91.18, 92.08,       
   95.98, 99.69)), .Names = c("Region", "Mean", "Penalty", "MPI"        
   ), row.names = c(NA, -20L), class = "data.frame")
  plot(0, xlim = c(0.5, 4.5), ylim = c(0.83, 4.9), 
       axes = FALSE,xlab = "", ylab = "" )
  x &lt;- rep(1:4,5) - 1; y &lt;- rep(5:1, each = 4)
  puticon( x, y, "mazz.man", icon.cex = 15, color = 1,
           Mean = Mazzi.Pareto$Mean, Penalty = Mazzi.Pareto$Penalty, 
           Region = Mazzi.Pareto$Region, x.text = 70, y.text = -10 )
  # some cars 
  plot(1:1000, type = "n", axes = FALSE, xlab = "", ylab = "")
  n &lt;- 200; set.seed(13); x &lt;- runif(n, -100, 1100); y &lt;- runif(n, -100, 1100)
  colors &lt;- sample(rainbow(n))
  for( i in 1:n ){
    puticon(x[i], y[i], icon = "car", icon.cex = runif(1, 10, 20),
             width = runif(1, 0, 1), height = runif(1, 0, 1), color = colors[i])
  }
  # fuzzy scatter plots as icons
  plot(-30:120, -30:120, type = "n", axes = FALSE, xlab = "", ylab = "")
  set.seed(13)
  puticon(50, 50, icon = "coor.system", icon.cex = .8, color = "blue", 
          xxx = list(rnorm(20, 50, 15)), yyy = list(rnorm(100, 50, 15)*1000), 
          axes = TRUE)
  puticon(x = c(20, 100, 95), y = c(100, 110, -45), icon = "coor.system", 
          icon.cex = c(20, 30), color = c("green", "red", "magenta"),
          xxx = list(c(30, 50, 70), c(10, 20), c(80, 90, 10)), 
          yyy = list(c(20, 60, 30), c(10, 20), c(10, 80, 90)), pcex = 10)
  # Marilyn Monroe or R icons via internet
  plot(1:20, type = "n",  axes = FALSE, xlab = "", ylab = "")
  f1 &lt;- "http://www.radiopaula.cl/wp-content/uploads/2014/03/marilyn-monroe-3-andrew-fare.jpg"
  ## Not run: puticon(15, 17, icon = f1, icon.cex = 40, color = NA)
  ## Not run: puticon( c(6, 9, 12, 15), c(15, 13, 11, 9), icon = f1, icon.cex = 20, 
     color = rainbow(4), grey.levels = 20)
## End(Not run)
  ## Not run: puticon( 4,  8, icon = f1, icon.cex = 40, color = "green", grey.levels = c(0.5, 0.9))
  ## Not run: puticon(10,  4, icon = f1, icon.cex = 40, color = "blue",  grey.levels = c(0.0, 0.6))
  plot(1:20, type = "n",  axes = FALSE, xlab = "", ylab = "")
  f1 &lt;- "https://developer.r-project.org/Logo/Rlogo-4.png"
  ## Not run: puticon(15, 17, icon = f1, icon.cex = 40, color = NA)
  ## Not run: puticon( c(6, 9, 12, 15), c(15, 13, 11, 9), icon = f1, icon.cex = 20, 
     color = rainbow(4), grey.levels = 20)
## End(Not run)
  ## Not run: puticon( 4,  8, icon = f1, icon.cex = 40, color = "green", grey.levels = c(0.5, 0.9))
  ## Not run: puticon(10,  4, icon = f1, icon.cex = 40, color = "blue",  grey.levels = c(0.0, 0.6))
  # simple raster graphics 
  plot(1:20, pch = 1:20) 
  puticon(1:20, sample(1:20), icon = 15, icon.cex = 20)
  image1 &lt;- as.raster(  matrix( c(1,1,1,1,0,1,1,1,1), ncol = 3, nrow = 3))
  image2 &lt;- as.raster(  matrix( c(0,1,0,1,0,1,0,1,0), ncol = 3, nrow = 3))
  image3 &lt;- as.raster(  matrix( c(0,0,0,0,1,0,0,0,0), ncol = 3, nrow = 3))
  puticon( 7, 14,            icon = image1, icon.cex = .5, col = "orange")
  puticon( c(5, 10), c(5,5), icon = image2, icon.cex = c(.1, .2), color = 3:4)
  puticon( 17, 10,           icon = image3, icon.cex = .30, col = "yellow") 
  # demo "my.house" of writing a generator function to generate icons
  my.house &lt;- function(col1 = 2, col2 = 3, col3 = 4){
    # initialize result object
    result &lt;- NULL
    # compose object of type "polygon" consisting of 
    # x-, y-values and colors 
    x &lt;- c(0, 1, 1, 0, 0, 1, 0.5,  0, 1) * 55 + 20
    y &lt;- c(0, 0, 1, 1, 0, 1, 1.65, 1, 0) * 55 + 5
    res &lt;- data.frame( x, y, color = col2)
    # add class "polygon" to the object and store it in "result"
    class(res) &lt;- c(class(res), "polygon"); result &lt;- c(result, list(res))
    # compose another object of type "polygon"
    res &lt;- data.frame( x[c(1, 3, 4, 2)], y[c(1, 3, 4, 2)], color = col3)
    # add class "polygon" to the object and store it in "result"
    class(res) &lt;- c(class(res), "polygon"); result &lt;- c(result, list(res))
    n &lt;- length(x)
    # compose object of type "segments" consisting of 
    # x1-, y1-, x2-, y2-values, line widths and colors 
    res &lt;- data.frame( x[-n], y[-n], x[-1], y[-1], lwd.mm = 5, color = col1)
    # add class "segments" to the object and store it in "result"
    class(res) &lt;- c(class(res), "segments"); result &lt;- c(result, list(res))
    # output result object
    result
  }
  plot(1:100, type = "n")
  n &lt;- 50; x &lt;- runif(n, 10, 90); y &lt;- runif(n, 10, 90)
  colors &lt;- rainbow(n); sizes &lt;- 5 + sample(1:n) / 2
  puticon(x, y, icon = my.house, icon.cex = sizes, 
          col1 = sample(colors), col2 = sample(colors), col3 = sample(colors) )
  # demo "my.star" of writing a generator function to generate icons
  my.star &lt;- function(xx = 1:5, max.xx, star.txt = "..."){
    if(missing(max.xx)) max.xx &lt;- max(xx)
    n &lt;- length(xx); xx &lt;- 50 * xx / max.xx
    colors &lt;- rainbow(n); result &lt;- NULL
    # compose object of type "segments" consisting of 
    # x1-, y1-, x2-, y2-values, line widths and colors 
    if( n &gt; 1 ){
      x &lt;- sin(2 * pi * (1:n) / n) * xx + 50
      y &lt;- cos(2 * pi * (1:n) / n) * xx + 50
      res &lt;- data.frame( 50, 50, x, y, lwd.mm = 2, color = colors)
    } else {
      res &lt;- data.frame( 50, 50, x, y, width = 30, color = colors)
    }
    # add class "segments" to the object and store it in "result"
    class(res) &lt;- c(class(res), "segments"); result &lt;- c(result, list(res))
    # compose object of type "text" consisting of 
    # x-, y-values, text, sizes of the text and colors 
    res &lt;- data.frame( 85, 20, txt = star.txt, t.cex.mm = 20, color = "blue")
    # add class "text" to the object and store it in "result"
    class(res) &lt;- c(class(res), "text"); result &lt;- c(result, list(res))
    # output result object
    result  
  }
  plot(1:100, type = "n")
  for(i in 1:10){
    puticon( runif(1, 0, 100), runif(1, 0, 100), icon = my.star, icon.cex = 20, 
             xx = list(runif(14, 2, 10)), max.xx = 10, star.txt = letters[i])
  }
</code></pre>

<hr>
<h2 id='skyline.hist'>
<code>skyline.hist</code> computes a skyline plot which is special histogram.
</h2><span id='topic+skyline.hist'></span>

<h3>Description</h3>

<p>The function <code>skyline.hist</code> draws several histograms in one plot. The 
resulting image may look like a skyline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   skyline.hist(x, n.class, n.hist = 1, main, ylab="density", 
                night = FALSE, col.bars = NA, col.border = 4, lwd.border = 2.5,
                n.shading = 6, lwd.shading = 2, col.shading = NA, lty.shading = 3,
                pcol.data = "green", cex.data = 0.3, pch.data = 16, col.data = 1,
                lwd.data = .2, permutation = FALSE, 
                xlab, xlim, ylim, new.plot=TRUE, bty="n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skyline.hist_+3A_x">x</code></td>
<td>
<p> one dimensional data set.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_n.class">n.class</code></td>
<td>

<p>number of classes that should be used to find the width of the bars 
of the histogram(s).</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_n.hist">n.hist</code></td>
<td>

<p>number of histograms that should be plotted.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_main">main</code></td>
<td>

<p>used for call of <code>title</code>.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_ylab">ylab</code></td>
<td>

<p>text for y axis.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_night">night</code></td>
<td>

<p>If <code>TRUE</code> the background will be colored blue. 
If <code>FALSE</code> there will be no colored background. Otherwise 
<code>night</code> is used as background color.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_col.bars">col.bars</code></td>
<td>

<p>defines the color of the bars. If <code>is.na(col.bars)</code> and 
<code>night==TRUE</code> the bars will be colored gray. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_col.border">col.border</code></td>
<td>
<p>  color of the borders of the bars.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_lwd.border">lwd.border</code></td>
<td>
<p>  line width of the borders of the bars.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_n.shading">n.shading</code></td>
<td>

<p>number of vertical lines for filling the bars of the histograms.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_lwd.shading">lwd.shading</code></td>
<td>

<p>line width of the vertical lines for shading the bars. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_col.shading">col.shading</code></td>
<td>

<p>color for the vertical lines for shading. If <code>NA</code> heat colors are used.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_lty.shading">lty.shading</code></td>
<td>

<p>line type for the vertical lines for shading.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_pcol.data">pcol.data</code></td>
<td>
<p> color of data points.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_cex.data">cex.data</code></td>
<td>
<p> character size of plotting character.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_pch.data">pch.data</code></td>
<td>
<p> plotting character of data points.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_lwd.data">lwd.data</code></td>
<td>
<p> line width for segments between data points.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_col.data">col.data</code></td>
<td>
<p> color for segments between data points.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_permutation">permutation</code></td>
<td>
<p> if not <code>FALSE</code> a permutation of the data set is erformed.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_xlab">xlab</code></td>
<td>
<p>     text for y axis. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_xlim">xlim</code></td>
<td>
<p>     range of x. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_ylim">ylim</code></td>
<td>
<p>     range of y. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_new.plot">new.plot</code></td>
<td>
<p>    logical. If <code>TRUE</code> a new plot is constructed.</p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_bty">bty</code></td>
<td>
<p>     box type, used by <code>plot</code>. </p>
</td></tr>
<tr><td><code id="skyline.hist_+3A_...">...</code></td>
<td>
<p>     further graphical parameters passed to plot. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>skyline.hist</code> computes several histograms and plots them one upon
the other. The histograms differ in the positions of the first cells, 
but all cells have the same width. The parameters <code>n.class</code> and
<code>n.hist</code> have the greatest effect on the design of the result. 
<code>col.border</code> allows to color the border of the rectangular boxes of the 
histogram bars. <code>col.bars</code> defines the fill color of the bars. 
<code>n.shading</code> defines the number of vertical lines of type
<code>lty.shading</code> and width <code>lwd.shading</code> that are drawn within the boxes. 
Another feature of <code>skyline.hist</code> is to represent the data points.
The data points of a cell are plotted according their x-values and
their ranks (within the points of the cell). The resulting points are connected
by line segments and you will see a time series running from bottom to top
in each cell. The points and lines can be specified by <code>pcol.data</code>,
<code>cex.data</code>, <code>pch.data</code>, <code>lwd.data</code>, <code>col.data</code>. To get rid 
of the original order of the data you can permutated them (<code>permutation=1</code>).
The &quot;skyline&quot; of the plot may be similar to the skyline of a town and the 
vertical lines may look like small windows of buildings.
In Young et. al. you find &quot;shaded histograms&quot;. These histograms have triggered
the idea of <code>skyline.hist</code> and the representation of a one dimensional 
data set by laying histograms on top of otheroverlied histograms.
</p>


<h3>Value</h3>

<p>The result of a call of hist is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Wolf, pwolf@wiwi.uni-bielefeld.de
</p>


<h3>References</h3>

<p>F.W. Young, R.M. Valero-Mora, M. Friendly (2006): Visual Statistics. 
Wiley, p207&ndash;208.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="stats.html#topic+density">density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # dev.off()
print(par())
  par(mfrow=c(1,1))
  for(n.c in c(2,4,8)){  # some values for n.class
    for(n.h in c(2,4,3)){# some values for number of n.hist
        n.s &lt;- 9         # value for number of vertical lines
        skyline.hist(co2, n.shading = n.s, n.hist = n.h ,n.class = n.c, 
                     night = n.h==3, col.border = n.h!=4)
    }
  }
  par(mfrow = c(1,1))
  skyline.hist(x=rivers, n.class=4, n.hist=2, n.shading=0, main="rivers",
             cex.data=.5, lwd.data = .2, col.data = "green", pcol.data = "red",
             col.border=NA, night=FALSE, ylab="density")
  skyline.hist(x=rivers, n.class=4, n.hist=5, n.shading=0, main="rivers",
             cex.data=.5, lwd.data = 1, col.data = "green", pcol.data = "red",
             col.border=NA, night="blue" , ylab="density", col.bars =NA)
  skyline.hist(x=rivers, n.class=10, n.hist=2, n.shading=0, main="rivers",
             cex.data=.5, lwd.data = 1, col.data = "green", pcol.data = "red",
             col.border=NA, night=FALSE , ylab="density", col.bars = "lightblue")
  skyline.hist(x=rivers, n.class=10, n.hist=1, n.shading=0, main="rivers",
             cex.data=1, lwd.data = 0, col.data = "green", pcol.data = "red",
             col.border=NA, night=FALSE , ylab="density", col.bars = "lightblue" )
  skyline.hist(x=rivers, n.class=6, n.hist=1, n.shading=0, main="rivers",
             cex.data=0.1, lwd.data = 2, col.data = "red", pcol.data = "green",
             night="orange" , ylab="density", col.bars = "white", col.border=1 )
  skyline.hist(x=rivers, n.class=6, n.hist=1, n.shading=0, main="rivers",
             cex.data=0.1, lwd.data = 2, col.data = "red", pcol.data = "green",
             col.border=NA, night=FALSE , ylab="density", col.bars = "lightblue")
  skyline.hist(x=rivers, n.class=6, n.hist=1, n.shading=5, col.shading = "blue",
             main="rivers",
             cex.data=0.1, lwd.data = 1, col.data = "black", pcol.data = "green",
             col.border=NA, night=FALSE , ylab="density", col.bars = "green")
  skyline.hist(x=rivers, n.class=6, n.hist=3, n.shading=5, col.shading = "blue",
             main="rivers", col.bars = "green",
             cex.data=0.1, lwd.data = 1, col.data = "black", pcol.data = "green",
             col.border="white", night="magenta" , ylab="density")
  skyline.hist(x=rivers, n.class=6, n.hist=4, n.shading=5, col.shading = "blue",
             main="rivers",
             cex.data=0.8, lwd.data = 1, col.data = "blue", pcol.data = "red",
             col.border=NA, night=FALSE , ylab="density", col.bars = "green")
</code></pre>

<hr>
<h2 id='slider'>slider / button control widgets</h2><span id='topic+slider'></span><span id='topic+gslider'></span>

<h3>Description</h3>

<p><code>slider</code> and <code>gslider</code> construct a Tcl/Tk-widget with sliders and buttons to
demonstrate the effects of variation of parameters on calculations and plots. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults, but.functions,
  but.names, no, set.no.value, obj.name, obj.value, reset.function, title, prompt=FALSE,
  sliders.frame.vertical=TRUE)

gslider(sl.functions, sl.names, sl.mins, sl.maxs, sl.deltas, sl.defaults, but.functions,
  but.names, no, set.no.value, obj.name, obj.value, reset.function, title, prompt=FALSE,
  sliders.frame.vertical=TRUE, hscale=1, vscale=1,
  pos.of.panel = c("bottom","top","left","right")[1])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider_+3A_sl.functions">sl.functions</code></td>
<td>
<p>set of functions or function connected to the slider(s)</p>
</td></tr>
<tr><td><code id="slider_+3A_sl.names">sl.names</code></td>
<td>
<p>labels of the sliders</p>
</td></tr>
<tr><td><code id="slider_+3A_sl.mins">sl.mins</code></td>
<td>
<p>minimum values of the sliders' ranges</p>
</td></tr>
<tr><td><code id="slider_+3A_sl.maxs">sl.maxs</code></td>
<td>
<p>maximum values of the sliders' ranges</p>
</td></tr>
<tr><td><code id="slider_+3A_sl.deltas">sl.deltas</code></td>
<td>
<p>change of step per click</p>
</td></tr>
<tr><td><code id="slider_+3A_sl.defaults">sl.defaults</code></td>
<td>
<p>default values for the sliders</p>
</td></tr>
<tr><td><code id="slider_+3A_but.functions">but.functions</code></td>
<td>
<p>function or list of functions
that are assigned to the button(s)</p>
</td></tr>
<tr><td><code id="slider_+3A_but.names">but.names</code></td>
<td>
<p>labels of the buttons</p>
</td></tr>
<tr><td><code id="slider_+3A_no">no</code></td>
<td>
<p><code>slider(no=i)</code> requests slider <code>i</code></p>
</td></tr>
<tr><td><code id="slider_+3A_set.no.value">set.no.value</code></td>
<td>
<p><code>slider(set.no.value=c(i,val))</code> sets slider <code>i</code> to value <code>val</code></p>
</td></tr>
<tr><td><code id="slider_+3A_obj.name">obj.name</code></td>
<td>
<p><code>slider(obj.name=name)</code> requests the value of 
variable <code>name</code> from environment <code>slider.env</code></p>
</td></tr>
<tr><td><code id="slider_+3A_obj.value">obj.value</code></td>
<td>
<p><code>slider(obj.name=name,obj.value=value)</code> assigns <code>value</code>
to variable <code>name</code> in environment <code>slider.env</code></p>
</td></tr>
<tr><td><code id="slider_+3A_reset.function">reset.function</code></td>
<td>
<p>function that induce a <code>reset.button</code> and 
contains the commands of it.</p>
</td></tr>
<tr><td><code id="slider_+3A_title">title</code></td>
<td>
<p>title of the control window</p>
</td></tr>
<tr><td><code id="slider_+3A_prompt">prompt</code></td>
<td>
<p> if TRUE slider functions are called by moving a slider,
if FALSE slider functions are called after releasing the mouse button</p>
</td></tr>
<tr><td><code id="slider_+3A_sliders.frame.vertical">sliders.frame.vertical</code></td>
<td>
<p> if TRUE the sliders are stacked one above the other;
otherwise they are positioned side by side </p>
</td></tr>
<tr><td><code id="slider_+3A_hscale">hscale</code></td>
<td>
<p>horizontal scale factor for image size; compare tkrplot in package tkrplot</p>
</td></tr>
<tr><td><code id="slider_+3A_vscale">vscale</code></td>
<td>
<p>vertical scale factor for image size; compare tkrplot in package tkrplot</p>
</td></tr>  
<tr><td><code id="slider_+3A_pos.of.panel">pos.of.panel</code></td>
<td>
<p>position of the panel field for sliders and buttons. 
Value of <code>pos.of.panel</code>: bottom, top, left or right.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider</code> constructs a separated panel for controlling the parameters whereas 
<code>gslider</code> integrates a graphical device and buttons and sliders within one window. 
</p>
<p>The following actions can be done:
a) definition of (multiple) sliders and buttons, 
b) request or specification of slider values, and
c) request or specification of variables in the environment <code>slider.env</code>.
The management takes place in the environment <code>slider.env</code>. If <code>slider.env</code>
is not found it is generated.
</p>
<p><b>Definition</b> ... of sliders: First of all you have to define sliders, buttons and the attributes of them.
Sliders are established by six arguments:
<code>sl.functions, sl.names, sl.minima, sl.maxima,sl.deltas</code>, and <code>sl.defaults</code>.
The first argument,
<code>sl.functions</code>, is either a list of functions or a single function that 
contains the commands for the sliders.
If there are three sliders and slider 2 is moved with the mouse the function stored in
<code>sl.functions[[2]]</code> (or in case of one function for all sliders the function <code>sl.functions</code>)
is called.
</p>
<p><b>DEFINITION</b> ... of buttons: Buttons are defined by a vector of labels <code>but.names</code> and a list of functions:
<code>but.functions</code>. If button <code>i</code> is pressed the function stored in <code>but.functions[[i]]</code> is called.
</p>
<p><b>REQUESTING</b> ... a slider: 
<code>slider(no=1)</code> returns the actual value of slider 1,
<code>slider(no=2)</code> returns the value of slider 2, etc. 
You are allowed to include expressions of the type
<code>slider(no=i)</code> in functions describing the effect of
sliders or buttons.
</p>
<p><b>SETTING</b> ... a slider: <code>slider(set.no.value=c(2,333))</code> sets slider <code>2</code> to value 333.
<code>slider(set.no.value=c(i,value))</code> can be included in the functions 
defining the effects of moving sliders or pushing buttons.
</p>
<p><b>VARIABLES</b> ... of the environment <code>slider.env</code>: Sometimes information
has to be trransferred back and forth between functions defining the effects of sliders and buttons.
Imagine for example two sliders: one to control <code>p</code> and another one to control <code>q</code>,
but they should satisfy: <code>p+q=1</code>. Consequently, you have to correct the value of the first slider
after the second one was moved. To prevent the creation of  global 
variables store them in the environment <code>slider.env</code>.
Use <code>slider(obj.name="p.save",obj.value=1-slider(no=2))</code>
to assign value  <code>1-slider(no=2)</code> to the variable <code>p.save</code> .
<code>slider(obj.name=p.save)</code> returns the value of variable <code>p.save</code>.
</p>
<p><b>Dependencies</b> The function <code>gslider</code> depends on package <code>tkrplot</code>.
</p>


<h3>Value</h3>

<p>Using <code>slider</code> in definition mode <code>slider</code> returns the value of new created the top level widget. 
<code>slider(no=i)</code> returns the actual value of slider <code>i</code>.
<code>slider(obj.name=name)</code> returns the value of variable <code>name</code> in environment <code>slider.env</code>.
<code>gslider</code> return in definition mode the result of <code>tkrplot</code> which was called to construct the widget.
</p>


<h3>Author(s)</h3>

<p>Hans Peter Wolf</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example 1, sliders only
if(interactive()){
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm&lt;-function(){
 refresh.code&lt;-function(...){
   mu&lt;-slider(no=1); sd&lt;-slider(no=2); n&lt;-slider(no=3)
   x&lt;-rnorm(n,mu,sd)
   plot(x)
 }
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(+10,50,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20))
}
plot.sample.norm()
}

# example 2, sliders and buttons
if(interactive()){
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2&lt;-function(){
 refresh.code&lt;-function(...){
   mu&lt;-slider(no=1); sd&lt;-slider(no=2); n&lt;-slider(no=3)
   type=  slider(obj.name="type")
   x&lt;-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(obj.name="type",obj.value="l")
 slider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
}
plot.sample.norm.2()
}

# example 2a, sliders and buttons and graphics in one window
if(interactive()){
## This example cannot be run by examples() but should work in an interactive R session
plot.sample.norm.2&lt;-function(){
 refresh.code&lt;-function(...){
   mu&lt;-slider(no=1); sd&lt;-slider(no=2); n&lt;-slider(no=3)
   type=  slider(obj.name="type")
   x&lt;-rnorm(n,mu,sd)
   plot(seq(x),x,ylim=c(-20,20),type=type)
 }
 slider(obj.name="type",obj.value="l")
 gslider(refresh.code,sl.names=c("value of mu","value of sd","n number of observations"),
       sl.mins=c(-10,.01,5),sl.maxs=c(10,10,100),sl.deltas=c(.01,.01,1),sl.defaults=c(0,1,20),
       but.functions=list(
              function(...){slider(obj.name="type",obj.value="l");refresh.code()},
              function(...){slider(obj.name="type",obj.value="p");refresh.code()},
              function(...){slider(obj.name="type",obj.value="b");refresh.code()}
       ),
       but.names=c("lines","points","both"))
}
plot.sample.norm.2()
}

# example 3, dependent sliders
if(interactive()){
## This example cannot be run by examples() but should work in an interactive R session
print.of.p.and.q&lt;-function(){
 refresh.code&lt;-function(...){
   p.old&lt;-slider(obj.name="p.old")
   p&lt;-slider(no=1); if(abs(p-p.old)&gt;0.001) {slider(set.no.value=c(2,1-p))}
   q&lt;-slider(no=2); if(abs(q-(1-p))&gt;0.001) {slider(set.no.value=c(1,1-q))}
   slider(obj.name="p.old",obj.value=p)
   cat("p=",p,"q=",1-p,"\n")
 }
 slider(refresh.code,sl.names=c("value of p","value of q"),
       sl.mins=c(0,0),sl.maxs=c(1,1),sl.deltas=c(.01,.01),sl.defaults=c(.2,.8))
 slider(obj.name="p.old",obj.value=slider(no=1))
}
print.of.p.and.q()
}

# example 4, rotating a surface
if(interactive()){
## This example cannot be run by examples() but should work in an interactive R session
R.veil.in.the.wind&lt;-function(){
  # Mark Hempelmann / Peter Wolf
  par(bg="blue4", col="white", col.main="white", 
      col.sub="white", font.sub=2, fg="white") # set colors and fonts
  refresh.code&lt;-function(...){
    samp        &lt;- function(N,D) N*(1/4+D)/(1/4+D*N) 
    z&lt;-outer(seq(1, 800, by=10), seq(.0025, 0.2, .0025)^2/1.96^2, samp) # create 3d matrix
    h&lt;-100 
    z[10:70,20:25]&lt;-z[10:70,20:25]+h; z[65:70,26:45]&lt;-z[65:70,26:45]+h
    z[64:45,43:48]&lt;-z[64:45,43:48]+h; z[44:39,26:45]&lt;-z[44:39,26:45]+h
    x&lt;-26:59; y&lt;-11:38; zz&lt;-outer(x,y,"+"); zz&lt;-zz*(65&lt;zz)*(zz&lt;73)
    cz&lt;-10+col(zz)[zz&gt;0];rz&lt;-25+row(zz)[zz&gt;0]; z[cbind(cz,rz)]&lt;-z[cbind(cz,rz)]+h
    theta&lt;-slider(no=1); phi&lt;-slider(no=2)
    persp(x=seq(1,800,by=10),y=seq(.0025,0.2,.0025),z=z,theta=theta,phi=phi, 
          scale=T, shade=.9, box=F, ltheta = 45,
          lphi = 45, col="aquamarine", border="NA",ticktype="detailed")   
  }
  slider(refresh.code, c("theta", "phi"), c(0, 0),c(360, 360),c(.2, .2),c(85, 270)  )
}
R.veil.in.the.wind()
}

</code></pre>

<hr>
<h2 id='slider.bootstrap.lm.plot'>interactive bootstapping for lm</h2><span id='topic+slider.bootstrap.lm.plot'></span>

<h3>Description</h3>

<p><code>slider.bootstrap.lm.plot</code> computes a scatterplot and 
adds regression curves of samples of the data points. 
The number of samples and the degree of the model are 
controlled by sliders. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.bootstrap.lm.plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.bootstrap.lm.plot_+3A_x">x</code></td>
<td>
<p> two column matrix or vector of x values if y is used </p>
</td></tr>
<tr><td><code id="slider.bootstrap.lm.plot_+3A_y">y</code></td>
<td>
<p> y values if x is not a matrix </p>
</td></tr>
<tr><td><code id="slider.bootstrap.lm.plot_+3A_...">...</code></td>
<td>
<p> additional graphics parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.bootstrap.lm.plot</code> draws a scatterplot of the data points
and fits a linear model to the data set. Regression curves  
of samples of the data are then added to the plot. Within a Tcl/Tk 
control widget the degree of the model, the repetitions and the start
of the random seed are set. After modification of a parameter
the plot is updated.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>References</h3>

<p> ~~ </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  daten&lt;-iris[,2:3]
  slider.bootstrap.lm.plot(daten)

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.brush'>interactive brushing functions</h2><span id='topic+slider.brush.pairs'></span><span id='topic+slider.brush.plot.xy'></span>

<h3>Description</h3>

<p>These functions compute a pairs plot or a simple xy-plot and
open a slider control widget for brushing. 
</p>
<p><code>slider.brush.pairs</code> computes a pairs plot; the user defines an
interval for one of the variables and in effect all data points 
in this interval will be recolored.
</p>
<p><code>slider.brush.plot.xy</code> computes an xy-plot; the user defines a
interval for a third variable <code>z</code> and all points 
<code>(x,y)</code> will be recolored red if the <code>z</code> value is in the interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.brush.pairs(x, ...)
  slider.brush.plot.xy(x, y, z, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.brush_+3A_...">...</code></td>
<td>
<p> new settings for global graphics parameters </p>
</td></tr>
<tr><td><code id="slider.brush_+3A_x">x</code></td>
<td>
<p> matrix or data frame or vector </p>
</td></tr>
<tr><td><code id="slider.brush_+3A_y">y</code></td>
<td>
<p> vector of y values if <code>x</code> is not a matrix </p>
</td></tr>
<tr><td><code id="slider.brush_+3A_z">z</code></td>
<td>
<p> vector of z values if <code>x</code> is not a matrix </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.brush.pairs</code> draws a pairs plot of the data set <code>x</code>.
The first slider defines the lower limit of the interval and the
second its width. By the third slider a variable is selected.
All data points for which the selected variable is in the interval
are recolored red.
</p>
<p><code>slider.brush.plot.xy</code> draws an xy-plot of the data set <code>x</code>.
The first slider defines the lower limit of the interval of z values 
and the second one its width. All data points for which the variable z
is in the interval are recolored red.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>References</h3>

<p> W. S. Cleveland, R. A. Becker, and G. Weil. The Use of
Brushing and Rotation for Data Analysis. InW. S. Cleveland
and M. E. McGill, editors, Dynamic Graphics for
Statistics. Wadsworth and Brooks/Cole, Pacific Grove,
CA, 1988. </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+pairs">pairs</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.brush.pairs(iris)

## End(Not run)
## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.brush.plot.xy(iris[,1:3])

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.hist'>interactive histogram and density traces</h2><span id='topic+slider.hist'></span><span id='topic+slider.density'></span>

<h3>Description</h3>

<p>The functions <code>slider.hist</code> and <code>slider.density</code>
compute histograms and density traces 
whereas some parameter are controlled by sliders. 
</p>
<p><code>slider.hist</code> computes a histogram; the number of classes is
defined by a slider.
</p>
<p><code>slider.density</code> computes a density trace; width and 
type of the kernel are defined by sliders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.hist(x, panel, ...)
  slider.density(x, panel, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.hist_+3A_x">x</code></td>
<td>
<p> data set to be used for plotting </p>
</td></tr>
<tr><td><code id="slider.hist_+3A_panel">panel</code></td>
<td>
<p> function constructing additional graphical elements to the plot</p>
</td></tr>
<tr><td><code id="slider.hist_+3A_...">...</code></td>
<td>
<p> additional (graphics) parameters which are passed to 
the invoked high level plotting function </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.hist</code> draws a histogram of the data set <code>x</code> by
calling <code>hist</code> and opens a Tcl/Tk widget with one slider. 
The slider defines the number of classes of the histogram. Changing the
slider results in redrawing of the plot. For further
details see the help page of <code>hist</code>. <code>rug</code> is used as the
default panel function.
</p>
<p><code>slider.density</code> draws a density trace of the data set <code>x</code>
by <code>plot(density(...))</code> and opens a Tcl/Tk-widget with two 
sliders. The first slider defines the width of the density trace 
and the second one the kernel function: 
<code>"1-gaussian",  "2-epanechnikov", "3-rectangular", 
         "4-triangular","5-biweight",     "6-cosine",     "7-optcosine"</code>
Changing one of the sliders results in a redrawing of the plot. 
For further details see the help page of <code>density</code>. 
<code>rug</code> is used as the default panel function.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>References</h3>

<p> ~~ </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+hist">hist</a></code>, <code>slider</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.hist(log(islands))

## End(Not run)
## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
slider.density(rivers,xlab="rivers",col="red")

## End(Not run)
## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
slider.density(log(rivers),xlab="rivers",col="red",
  panel=function(x){
    xx&lt;-seq(min(x),max(x),length=100)
    yy&lt;-dnorm(xx,mean(x),sd(x))
    lines(xx,yy)
    rug(x)
    print(summary(yy))
  }
)

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.lowess.plot'>interactive lowess smoothing</h2><span id='topic+slider.lowess.plot'></span>

<h3>Description</h3>

<p><code>slider.lowess.plot</code> computes an xy-plot of the data and 
adds LOWESS lines. The smoother
span and the number of iterations are selected by sliders.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.lowess.plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.lowess.plot_+3A_x">x</code></td>
<td>
<p> data set to be used for plotting or vector of x values </p>
</td></tr>
<tr><td><code id="slider.lowess.plot_+3A_y">y</code></td>
<td>
<p> vector of y values in case <code>x</code> is not a matrix </p>
</td></tr>
<tr><td><code id="slider.lowess.plot_+3A_...">...</code></td>
<td>
<p> additional (graphics) parameter settings </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.lowess.plot</code> computes a scatterplot of the data.
Then a LOWESS smoother line is added to the plot.   
For more details about the lowess parameters <code>f</code> and <code>iter</code>
take a look at the help page of <code>lowess</code>.
The parameters are set by moving sliders of the 
control widget. The first slider defines the smoother span <code>f</code>
and the second one the number of iterations.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>References</h3>

<p> for references see help file of <code>lowess</code> </p>


<h3>See Also</h3>

 <p><code><a href="stats.html#topic+lowess">lowess</a></code>, <code>slider</code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.lowess.plot(cars)

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.smooth.plot.ts'>interactive Tukey smoothing</h2><span id='topic+slider.smooth.plot.ts'></span>

<h3>Description</h3>

<p><code>slider.smooth.plot.ts</code> computes smooth curves
of a time series plot by Tukey's smoothers.
The kind of smoothing is controlled by a Tcl/Tk widget. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.smooth.plot.ts(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.smooth.plot.ts_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="slider.smooth.plot.ts_+3A_...">...</code></td>
<td>
<p> additional graphical parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.smooth.plot.ts</code> draws the time series <code>x</code>.
The user selects a filter of the set 
<code>c("3RS3R", "3RSS", "3RSR", "3R", "3", "S")</code>
step by step and the resulting curve is added to the plot.
The selection is performed by pressing a button of the control
widget of <code>slider.smooth.plot.ts</code>. 
The button <code>reset</code> restarts the smoothing process.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>References</h3>

<p>  Tukey, J. W. (1977). Exploratory Data Analysis, Reading
Massachusetts: Addison-Wesley.
</p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+smooth">smooth</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.smooth.plot.ts(rnorm(100))

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.split.plot.ts'>interactive splitting of time series</h2><span id='topic+slider.split.plot.ts'></span>

<h3>Description</h3>

<p><code>slider.split.plot.ts</code> plots linear fitted lines or 
summary statistics in sections of a time series. 
The sections are controlled by sliders. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.split.plot.ts(x, type="l", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.split.plot.ts_+3A_x">x</code></td>
<td>
<p> time series or vector</p>
</td></tr>
<tr><td><code id="slider.split.plot.ts_+3A_type">type</code></td>
<td>
<p> plotting type: <code>type</code> will be forwarded to function <code>plot</code></p>
</td></tr>
<tr><td><code id="slider.split.plot.ts_+3A_...">...</code></td>
<td>
<p> additional graphics parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.split.plot.ts</code> draws a time series plot and let you define 
sections of the series by fixing a limit on the time scale as well as 
a window width.
The whole range of the series is partitioned in pieces of the same 
length in a way that the fixed limit will be one of the section limits. 
Then linear models are fitted and plotted in the sections.
Alternatively &ndash; by pressing the button <code>fivenum summary</code> &ndash; 
summary statistics are drawn instead of the model lines.
</p>
<p>The first slider fixes the width of the sections and 
the second one the limit between two of them.
</p>
<p>By clicking on button <code>linear model</code> or <code>fivenum summary</code>
the user switches between drawing model curves and five number summary.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.split.plot.ts(as.vector(sunspots)[1:100])

## End(Not run)
</code></pre>

<hr>
<h2 id='slider.stem.leaf'>                                                                
construction of stem and leaf display interactively
</h2><span id='topic+slider.stem.leaf'></span>

<h3>Description</h3>

 
<p>'slider.stem.leaf' computes a stem and leaf display within a 
graphics device. The parameters are controlled by a control widget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>                                                                
 slider.stem.leaf(x, main = main)                                        
 </code></pre>


<h3>Arguments</h3>

                                                            
<table>
<tr><td><code id="slider.stem.leaf_+3A_x">x</code></td>
<td>
                                                            
<p>data set for plotting
</p>
</td></tr>                                                                       
<tr><td><code id="slider.stem.leaf_+3A_main">main</code></td>
<td>
                                                         
<p>main title of the plot
</p>
</td></tr>                                                                       
</table>


<h3>Details</h3>

                                                              
<p>The function 'slider.stem.leaf' allows the user to construct
a stem and leaf display within a graphics device. The main parameters 
will be set by a Tcl/Tk control widget. The line rule is selected
by pressing one of the buttons 'Dixon', 'Sturges', 'Velleman'.
A slider controls the separation of the stem.
Additionally the character size device could be set. 
</p>


<h3>Value</h3>

                                                                
<p>a short message is returned
</p>


<h3>Note</h3>

                                                                 
<p>The function is a function of the package aplpack
</p>


<h3>Author(s)</h3>

                                                               
<p>Peter Wolf, Nov 2009
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+stem">stem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>     
 ## Not run:     
   slider.stem.leaf(islands)
 
## End(Not run)
 </code></pre>

<hr>
<h2 id='slider.zoom.plot.ts'>interactive zooming of time series</h2><span id='topic+slider.zoom.plot.ts'></span>

<h3>Description</h3>

<p>This function shows one or two sections of a time series. The window(s) is 
(are) controlled by sliders. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  slider.zoom.plot.ts(x, n.windows, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slider.zoom.plot.ts_+3A_x">x</code></td>
<td>
<p> time series </p>
</td></tr>
<tr><td><code id="slider.zoom.plot.ts_+3A_n.windows">n.windows</code></td>
<td>
 <p><code>if(n.windows&gt;1</code> two sections are defined </p>
</td></tr>
<tr><td><code id="slider.zoom.plot.ts_+3A_...">...</code></td>
<td>
<p> additional graphical parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>slider.zoom.plot.ts</code> plots the original time series and it lets you 
select one or two sections of the series by fixing the width(s) and the 
starting point(s) of the region(s). Then the section(s) of the series is (are)
plotted separately one below the other.
</p>
<p>The first slider defines the width of the section(s). 
The second (third) one sets the start of the first (second) section.
</p>


<h3>Value</h3>

<p>a message about the usage
</p>


<h3>Author(s)</h3>

<p> Hans Peter Wolf </p>


<h3>See Also</h3>

 <p><code><a href="graphics.html#topic+plot">plot</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example cannot be run by examples() but should be work in an interactive R session
  slider.zoom.plot.ts(co2,2)

## End(Not run)
</code></pre>

<hr>
<h2 id='spin3R'> spin3R </h2><span id='topic+spin3R'></span>

<h3>Description</h3>

<p>Simple spin function to rotate and to inspect 
a 3-dimensional cloud of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  spin3R(x, alpha = 1, delay = 0.015, na.rm=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin3R_+3A_x">x</code></td>
<td>
 <p><code>(nx3)</code>-matrix of points </p>
</td></tr>
<tr><td><code id="spin3R_+3A_alpha">alpha</code></td>
<td>
<p> angle between successive projections </p>
</td></tr>
<tr><td><code id="spin3R_+3A_delay">delay</code></td>
<td>
<p> delay in seconds between two plots </p>
</td></tr>
<tr><td><code id="spin3R_+3A_na.rm">na.rm</code></td>
<td>
<p> if TRUE 'NA' values are removed otherwise exchanged by mean</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spin3R</code> computes two-dimensional projections 
of <code>(nx3)</code>-matrix <code>x</code> and plots them
on the graphics device. The cloud of points is rotated
step by step. The rotation is defined by a tcl/tk control 
widget. <code>spin3R</code> requires tcl/tk package of R.
</p>


<h3>Note</h3>

<p>  version 05/2008 </p>


<h3>Author(s)</h3>

<p> Peter Wolf </p>


<h3>References</h3>

 
<p>Cleveland, W. S. / McGill, M. E. (1988): Dynamic Graphics
for Statistics. Wadsworth &amp; Brooks/Cole, Belmont, California.
</p>


<h3>See Also</h3>

 <p><code>spin</code> of S-Plus </p>


<h3>Examples</h3>

<pre><code class='language-R'>  xyz&lt;-matrix(rnorm(300),100,3)
  # now start:     spin3R(xyz) 
</code></pre>

<hr>
<h2 id='stem.leaf'>stem and leaf display and back to back stem and leaf display</h2><span id='topic+stem.leaf'></span><span id='topic+stem.leaf.backback'></span>

<h3>Description</h3>

<p>Creates a classical (&quot;Tukey-style&quot;) stem and leaf display / back-to-back stem and leaf display.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stem.leaf(data, unit, m, Min, Max, rule.line = c("Dixon", "Velleman", "Sturges"),
    style = c("Tukey", "bare"), trim.outliers = TRUE, depths = TRUE,
    reverse.negative.leaves = TRUE, na.rm = FALSE, printresult = TRUE)
stem.leaf.backback(x,y, unit, m, Min, Max, rule.line = c("Dixon", "Velleman", 
    "Sturges"), style = c("Tukey", "bare"), trim.outliers = TRUE, 
    depths = TRUE, reverse.negative.leaves = TRUE, na.rm = FALSE,
    printresult=TRUE, show.no.depths = FALSE, add.more.blanks = 0,
    back.to.back = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stem.leaf_+3A_data">data</code></td>
<td>
<p>a numeric vector of data</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_x">x</code></td>
<td>
<p>first dataset for <code>stem.leaf.backback</code></p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_y">y</code></td>
<td>
<p>first dataset for <code>stem.leaf.backback</code></p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_unit">unit</code></td>
<td>
<p>leaf unit, as a power of 10 (e.g., <code>100</code>, <code>.01</code>);
if <code>unit</code> is missing <code>unit</code> is choosen by <code>stem.leaf</code>.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_m">m</code></td>
<td>
<p>number of parts (1, 2, or 5) into which each stem will be separated;
if <code>m</code> is missing the number of parts/stem 
(<code>m</code>) is choosen by <code>stem.leaf</code>.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_min">Min</code></td>
<td>
<p>smallest non-outlying value; omit for automatic choice.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_max">Max</code></td>
<td>
<p>largest non-outlying value; omit for automatic choice.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_rule.line">rule.line</code></td>
<td>
<p>the rule to use for choosing the desired number of lines
in the display; <code>"Dixon"</code> = 10*log10(n); <code>"Velleman"</code> = 2*sqrt(n);
<code>"Sturges"</code> = 1 + log2(n); the default is <code>"Dixon"</code>.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_style">style</code></td>
<td>
<p><code>"Tukey"</code> (the default) for &quot;Tukey-style&quot; divided stems;
<code>"bare"</code> for divided stems that simply repeat the stem digits.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_trim.outliers">trim.outliers</code></td>
<td>
<p>if <code>TRUE</code> (the default), outliers are placed on <code>LO</code> and
<code>HI</code> stems.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_depths">depths</code></td>
<td>
<p>if <code>TRUE</code> (the default), print a column of &quot;depths&quot; to the left of the
stems; the depth of the stem containing the median is the stem-count enclosed in
parentheses.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_reverse.negative.leaves">reverse.negative.leaves</code></td>
<td>
<p>if <code>TRUE</code> (the default), reverse direction the leaves on negative
stems (so, e.g., the leaf 9 comes before the leaf 8, etc.).</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_na.rm">na.rm</code></td>
<td>
<p> if TRUE &quot;NA&quot; values are removed otherwise the number of NAs are counted.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_printresult">printresult</code></td>
<td>
<p> if TRUE output of the stem and leaf display by <code>cat</code>.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_show.no.depths">show.no.depths</code></td>
<td>
<p> if TRUE no depths are printed.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_add.more.blanks">add.more.blanks</code></td>
<td>
<p> number of blanks that are added besides the leaves.</p>
</td></tr>
<tr><td><code id="stem.leaf_+3A_back.to.back">back.to.back</code></td>
<td>
<p> if FALSE two parallel stem and leaf displays are constructed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the <code>stem</code> function in the <code>base</code> package, <code>stem.leaf</code> produces
classic stem-and-leaf displays, as described in Tukey's <em>Exploratory Data Analysis</em>.
The function <code>stem.leaf.backback</code> creates back-to-back stem and leaf displays.
</p>


<h3>Value</h3>

<p>The computed stem and leaf display is printed out.
Invisibly <code>stem.leaf</code> returns the stem and leaf
display as a list containing the elements
<code>info</code> (legend), <code>display</code> (stem and leaf display as character vecter), 
<code>lower</code> (very small values), <code>upper</code> (very large values), <code>depths</code> (vector of depths), 
<code>stem</code> (stem information as a vector), and <code>leaves</code> (vector of leaves).
</p>


<h3>Author(s)</h3>

<p>Peter Wolf, the code has been slightly modified by John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
with the original author's permission, help page written by John Fox, 
the help page has been slightly modified by Peter Wolf.</p>


<h3>References</h3>

<p>Tukey, J.
<em>Exploratory Data Analysis.</em>
Addison-Wesley, 1977.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+stem">stem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>stem.leaf(co2)
stem.leaf.backback(co2[1:120],co2[121:240])
stem.leaf.backback(co2[1:120],co2[121:240], back.to.back = FALSE)
stem.leaf.backback(co2[1:120],co2[121:240], back.to.back = FALSE,
                   add.more.blanks = 3, show.no.depths = TRUE)
stem.leaf.backback(rivers[-(1:30)],rivers[1:30], back.to.back = FALSE, unit=10, m=5, 
                   Min=200, Max=900, add.more.blanks = 20, show.no.depths = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
