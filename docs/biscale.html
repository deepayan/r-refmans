<!DOCTYPE html><html><head><title>Help for package biscale</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {biscale}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bi_class'><p>Create Classes for Bivariate Maps</p></a></li>
<li><a href='#bi_class_breaks'><p>Return Breaks</p></a></li>
<li><a href='#bi_legend'><p>Create Object for Drawing Legend</p></a></li>
<li><a href='#bi_pal'><p>Preview Palettes and Hex Values</p></a></li>
<li><a href='#bi_pal_manual'><p>Create Manual Palette</p></a></li>
<li><a href='#bi_scale_color'><p>Apply Bivariate Color to ggplot Object</p></a></li>
<li><a href='#bi_scale_fill'><p>Apply Bivariate Fill to ggplot Object</p></a></li>
<li><a href='#bi_theme'><p>Basic Theme for Bivariate Mapping</p></a></li>
<li><a href='#stl_race_income'><p>Race and Median Income in St. Louis by Census Tract, 2017</p></a></li>
<li><a href='#stl_race_income_point'><p>Race and Median Income in St. Louis by Census Tract, 2017</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools and Palettes for Bivariate Thematic Mapping</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a 'ggplot2' centric approach to bivariate mapping. This is a 
    technique that maps two quantities simultaneously rather than the single value 
    that most thematic maps display. The package provides a suite of tools 
    for calculating breaks using multiple different approaches, a selection of 
    palettes appropriate for bivariate mapping and scale functions for 'ggplot2' 
    calls that adds those palettes to maps. Tools for creating bivariate legends 
    are also included.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://chris-prener.github.io/biscale/">https://chris-prener.github.io/biscale/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chris-prener/biscale/issues">https://github.com/chris-prener/biscale/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>classInt, ggplot2, stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, cowplot, knitr, rmarkdown, sf, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-26 18:11:15 UTC; chris</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Prener
    <a href="https://orcid.org/0000-0002-4310-9888"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Timo Grossenbacher [aut],
  Angelo Zehr [aut],
  Joshua Stevens [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Prener &lt;chris.prener@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-27 08:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='bi_class'>Create Classes for Bivariate Maps</h2><span id='topic+bi_class'></span>

<h3>Description</h3>

<p>Creates mapping classes for a bivariate map. These data will be stored
in a new variable named <code>bi_class</code>, which will be added to the given
data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_class(.data, x, y, style, dim = 3, keep_factors = FALSE, dig_lab = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_class_+3A_.data">.data</code></td>
<td>
<p>A data frame, tibble, or <code>sf</code> object</p>
</td></tr>
<tr><td><code id="bi_class_+3A_x">x</code></td>
<td>
<p>The <code>x</code> variable, either a numeric (including double and integer
classes) or factor</p>
</td></tr>
<tr><td><code id="bi_class_+3A_y">y</code></td>
<td>
<p>The <code>y</code> variable, either a numeric (including double and integer
classes) or factor</p>
</td></tr>
<tr><td><code id="bi_class_+3A_style">style</code></td>
<td>
<p>A string identifying the style used to calculate breaks. Currently
supported styles are <code>"quantile"</code>, <code>"equal"</code>, <code>"fisher"</code>,
and <code>"jenks"</code>. If both <code>x</code> and <code>y</code> are factors, this argument can
be omitted.
</p>
<p>Note that older versions of <code>biscale</code> used <code>"quantile"</code> as the default
for this argument. Now that <code>bi_class</code> accepts factors, this argument
no longer as a default and older code will error.</p>
</td></tr>
<tr><td><code id="bi_class_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette. To use the built-in palettes,
this value must be either <code>2</code>, <code>3</code>, or <code>4</code>. A value of
<code>3</code>, for example, would be used to create a three-by-three bivariate
map with a total of 9 classes.
</p>
<p>If you are using a custom palette, this value may be larger (though these
maps can be very hard to interpret).
</p>
<p>If you are using pre-made factors, both factors must have the same number
of levels as this value.</p>
</td></tr>
<tr><td><code id="bi_class_+3A_keep_factors">keep_factors</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code>, the intermediate factor
variables created as part of the calculation of <code>bi_class</code> will be
retained. If <code>FALSE</code> (default), they will not be returned.</p>
</td></tr>
<tr><td><code id="bi_class_+3A_dig_lab">dig_lab</code></td>
<td>
<p>An integer that is passed to <code>base::cut()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A copy of <code>.data</code> with a new variable <code>bi_class</code> that contains
combinations of values that correspond to an observations values for <code>x</code>
and <code>y</code>. This is the basis for applying a bivariate color palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># quantile breaks, 2x2
data &lt;- bi_class(stl_race_income, x = pctWhite, y = medInc, style = "quantile", dim = 2)

# summarize quantile breaks, 2x2
table(data$bi_class)

# quantile breaks, 3x3
data &lt;- bi_class(stl_race_income, x = pctWhite, y = medInc, style = "quantile", dim = 3)

# summarize quantile breaks, 3x3
table(data$bi_class)

</code></pre>

<hr>
<h2 id='bi_class_breaks'>Return Breaks</h2><span id='topic+bi_class_breaks'></span>

<h3>Description</h3>

<p>This function can be used to return a list containing vectors
of either the ranges of values included in each category of <code>x</code>
and <code>y</code> or, alternatively, the individual break values including
the minimum and maximum values. This function supports simplified
reporting as well as more descriptive legends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_class_breaks(.data, x, y, style, dim = 3, clean_levels = TRUE,
    dig_lab = 3, split = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_class_breaks_+3A_.data">.data</code></td>
<td>
<p>A data frame, tibble, or <code>sf</code> object</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_x">x</code></td>
<td>
<p>The <code>x</code> variable, either a numeric (including double and integer
classes) or factor</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_y">y</code></td>
<td>
<p>The <code>y</code> variable, either a numeric (including double and integer
classes) or factor</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_style">style</code></td>
<td>
<p>A string identifying the style used to calculate breaks. Currently
supported styles are <code>"quantile"</code> (default), <code>"equal"</code>, <code>"fisher"</code>,
and <code>"jenks"</code>. If both <code>x</code> and <code>y</code> are factors, this argument can
be omitted.</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette. To use the built-in palettes,
this value must be either <code>2</code>, <code>3</code>, or <code>4</code>. A value of
<code>3</code>, for example, would be used to create a three-by-three bivariate
map with a total of 9 classes.
</p>
<p>If you are using a custom palette, this value may be larger (though these
maps can be very hard to interpret).
</p>
<p>If you are using pre-made factors, both factors must have the same number
of levels as this value.</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_clean_levels">clean_levels</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> (default), the
brackets and parentheses will be stripped from the output. If <code>FALSE</code>
(default), the levels will be returned with brackets and parentheses. If
<code>split</code> is <code>TRUE</code> and <code>clean_levels</code> is <code>FALSE</code>,
the <code>clean_levels</code> argument will be overridden.</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_dig_lab">dig_lab</code></td>
<td>
<p>An integer that is passed to <code>base::cut()</code>; it determines
the number of digits used in formatting break numbers. It can either be
a scalar or a vector. If it is a scalar, the value will be applied to both
the <code>x</code> and <code>y</code> variables. If it is a vector, the first element
will be applied to the <code>x</code> variable and the second will be applied
to the <code>y</code> variable.</p>
</td></tr>
<tr><td><code id="bi_class_breaks_+3A_split">split</code></td>
<td>
<p>A logical scalar; if <code>FALSE</code> (default), the range of values
for each factor level (corresponds to <code>dim</code>) will be returned for
both the <code>x</code> and <code>y</code> variables. If <code>TRUE</code>, the individual
values for each break (including the minimum and maximum values) will be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list where <code>bi_x</code> is a vector containing the breaks for the
<code>x</code> variable and <code>bi_y</code> is a vector containing the breaks for
the <code>y</code> variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return ranges for each category of x and y
bi_class_breaks(stl_race_income, style = "quantile", x = pctWhite, y = medInc,
    dim = 4, dig_lab = c(4, 5), split = FALSE)

# ranges can be returned with brackets and parentheses
bi_class_breaks(stl_race_income, style = "quantile", x = pctWhite, y = medInc,
    clean_levels = FALSE, dim = 4, dig_lab = 3, split = FALSE)

# return breaks for each category of x and y
bi_class_breaks(stl_race_income, style = "quantile", x = pctWhite, y = medInc,
    dim = 4, dig_lab = c(4, 5), split = TRUE)

# optionally name vector for dig_lab for increased clarity of code
bi_class_breaks(stl_race_income, style = "quantile", x = pctWhite, y = medInc,
    dim = 4, dig_lab = c(x = 4, y = 5), split = TRUE)

# scalars can also be used for dig_lab, though results may be less optimal
bi_class_breaks(stl_race_income, style = "quantile", x = pctWhite, y = medInc,
    dim = 4, dig_lab = 3, split = TRUE)

</code></pre>

<hr>
<h2 id='bi_legend'>Create Object for Drawing Legend</h2><span id='topic+bi_legend'></span>

<h3>Description</h3>

<p>Creates a <code>ggplot</code> object containing a legend that is
specific to bivariate mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_legend(pal, dim = 3, xlab, ylab, size = 10, flip_axes = FALSE,
    rotate_pal = FALSE, pad_width = NA, pad_color = "#ffffff",
    breaks = NULL, arrows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_legend_+3A_pal">pal</code></td>
<td>
<p>A palette name or a vector containing a custom palette. See
the help file for <code><a href="#topic+bi_pal">bi_pal</a></code> for complete list of built-in palette
names. If you are providing a custom palette, it must follow the formatting
described in the 'Advanced Options' vignette.</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette. To use the built-in palettes,
this value must be either <code>2</code>, <code>3</code>, or <code>4</code>. A value of
<code>3</code>, for example, would be used to create a three-by-three bivariate
map with a total of 9 classes.
</p>
<p>If you are using a custom palette, this value may be larger (though these
maps can be very hard to interpret). See the 'Advanced Options' vignette
for details on the relationship between <code>dim</code> values and palette size.</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_xlab">xlab</code></td>
<td>
<p>Text for desired x axis label on legend</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_ylab">ylab</code></td>
<td>
<p>Text for desired y axis label on legend</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_size">size</code></td>
<td>
<p>A numeric scalar; size of axis labels</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_flip_axes">flip_axes</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code>, the axes of the palette
will be flipped. If <code>FALSE</code> (default), the palette will be displayed
on its original axes. Custom palettes with 'dim' greater
than 4 cannot take advantage of flipping axes.</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_rotate_pal">rotate_pal</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code>, the palette will be
rotated 180 degrees. If <code>FALSE</code> (default), the palette will be
displayed in its original orientation. Custom palettes with 'dim' greater
than 4 cannot take advantage of palette rotation.</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_pad_width">pad_width</code></td>
<td>
<p>An optional numeric scalar; controls the width of padding
between tiles in the legend</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_pad_color">pad_color</code></td>
<td>
<p>An optional character scalar; controls the color of padding
between tiles in the legend</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_breaks">breaks</code></td>
<td>
<p>An optional list created by <code>bi_class_breaks</code>. Depending
on the options selected when making the list, labels will placed
showing the corresponding range of values for each axis or, if
<code>split = TRUE</code>, showing the individual breaks.</p>
</td></tr>
<tr><td><code id="bi_legend_+3A_arrows">arrows</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> (default), directional arrows
will be added to both the x and y axes of the legend. If you want to
suppress these arrows, especially if you are supplying breaks to create
a more detailed legend, this parameter can be set of <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object with a bivariate legend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bi_pal">bi_pal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3x3 legend
legend &lt;- bi_legend(pal = "GrPink",
                    dim = 3,
                    xlab = "Higher % White ",
                    ylab = "Higher Income ",
                    size = 16)

# print legend
legend

# sample 3x3 legend with breaks
## create vector of breaks
break_vals &lt;- bi_class_breaks(stl_race_income, style = "quantile",
    x = pctWhite, y = medInc, dim = 3, dig_lab = c(x = 4, y = 5),
    split = TRUE)

## create legend
legend &lt;- bi_legend(pal = "GrPink",
                    dim = 3,
                    xlab = "Higher % White ",
                    ylab = "Higher Income ",
                    size = 16,
                    breaks = break_vals,
                    arrows = FALSE)

# print legend
legend

</code></pre>

<hr>
<h2 id='bi_pal'>Preview Palettes and Hex Values</h2><span id='topic+bi_pal'></span>

<h3>Description</h3>

<p>Prints either a visual preview of each palette or the associated
hex values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_pal(pal, dim = 3, preview = TRUE, flip_axes = FALSE, rotate_pal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_pal_+3A_pal">pal</code></td>
<td>
<p>A palette name or a vector containing a custom palette.
If you are providing a palette name, it must be one of:
<code>"Bluegill"</code>, <code>"BlueGold"</code>, <code>"BlueOr"</code>, <code>"BlueYl"</code>,
<code>"Brown"</code>/<code>"Brown2"</code>, <code>"DkBlue"</code>/<code>"DkBlue2"</code>,
<code>"DkCyan"</code>/<code>"DkCyan2"</code>, <code>"DkViolet"</code>/<code>"DkViolet2"</code>,
<code>"GrPink"</code>/<code>"GrPink2"</code>, <code>"PinkGrn"</code>, <code>"PurpleGrn"</code>,
or <code>"PurpleOr"</code>.
</p>
<p>Pairs of palettes, such as <code>"GrPink"</code>/<code>"GrPink2"</code>, are included
for legacy support. The numbered palettes support four-by-four bivarite
maps while the un-numbered ones, which were the five included in the
original release of the package, only support two-by-two and
three-by-three maps.
</p>
<p>If you are providing a custom palette, it must follow the formatting
described in the 'Advanced Options' vignette.</p>
</td></tr>
<tr><td><code id="bi_pal_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette. To use the built-in palettes,
this value must be either <code>2</code>, <code>3</code>, or <code>4</code>. A value of
<code>3</code>, for example, would be used to create a three-by-three bivariate
map with a total of 9 classes.
</p>
<p>If you are using a custom palette, this value may be larger (though these
maps can be very hard to interpret). See the 'Advanced Options' vignette
for details on the relationship between <code>dim</code> values and palette size.</p>
</td></tr>
<tr><td><code id="bi_pal_+3A_preview">preview</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> (default), an image preview
will be generated. If <code>FALSE</code>, a vector with hex color values will
be returned.</p>
</td></tr>
<tr><td><code id="bi_pal_+3A_flip_axes">flip_axes</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the axes of the palette
will be flipped. If <code>FALSE</code> (default), the palette will be displayed
on its original axes. Custom palettes with 'dim' greater
than 4 cannot take advantage of flipping axes.</p>
</td></tr>
<tr><td><code id="bi_pal_+3A_rotate_pal">rotate_pal</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the palette will be
rotated 180 degrees. If <code>FALSE</code> (default), the palette will be
displayed in its original orientation. Custom palettes with 'dim' greater
than 4 cannot take advantage of palette rotation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>"Brown"</code>, <code>"DkBlue"</code>, <code>"DkCyan"</code>, and <code>"GrPink"</code>
palettes were made by
<a href="https://www.joshuastevens.net/cartography/make-a-bivariate-choropleth-map/">Joshua Stevens</a>.
The <code>"DkViolet"</code> palette was made by
<a href="https://timogrossenbacher.ch/2019/04/bivariate-maps-with-ggplot2-and-sf/">Timo Grossenbacher and Angelo Zehr</a>.
Many of the new palettes were inspired by Branson Fox's earlier work to expand
<code>biscale</code>.
</p>


<h3>Value</h3>

<p>If <code>preview = TRUE</code>, an image preview of the legend will be returned.
Otherwise, if <code>preview = FALSE</code>, a named vector with class values for names
and their corresponding hex color values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># gray pink palette, 2x2
bi_pal(pal = "GrPink", dim = 2)

# gray pink palette, 2x2 hex values
bi_pal(pal = "GrPink", dim = 2, preview = FALSE)

# gray pink palette, 3x3
bi_pal(pal = "GrPink", dim = 3)

# gray pink palette, 3x3 hex values
bi_pal(pal = "GrPink", dim = 3, preview = FALSE)

# custom palette
custom_pal &lt;- c(
    "1-1" = "#cabed0", # low x, low y
    "2-1" = "#ae3a4e", # high x, low y
    "1-2" = "#4885c1", # low x, high y
    "2-2" = "#3f2949" # high x, high y
)

bi_pal(pal = custom_pal, dim = 2, preview = FALSE)

</code></pre>

<hr>
<h2 id='bi_pal_manual'>Create Manual Palette</h2><span id='topic+bi_pal_manual'></span>

<h3>Description</h3>

<p>This function has been deprecated and will be removed from the
next release of the package. See the Advanced Options vignette for a
replacement workflow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_pal_manual(val_1_1, val_1_2, val_1_3, val_2_1, val_2_2, val_2_3,
    val_3_1, val_3_2, val_3_3, preview = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_pal_manual_+3A_val_1_1">val_1_1</code></td>
<td>
<p>A hex value for cell 1-1</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_1_2">val_1_2</code></td>
<td>
<p>A hex value for cell 1-2</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_1_3">val_1_3</code></td>
<td>
<p>A hex value for cell 1-3</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_2_1">val_2_1</code></td>
<td>
<p>A hex value for cell 2-1</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_2_2">val_2_2</code></td>
<td>
<p>A hex value for cell 2-2</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_2_3">val_2_3</code></td>
<td>
<p>A hex value for cell 2-3</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_3_1">val_3_1</code></td>
<td>
<p>A hex value for cell 3-1</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_3_2">val_3_2</code></td>
<td>
<p>A hex value for cell 3-2</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_val_3_3">val_3_3</code></td>
<td>
<p>A hex value for cell 3-3</p>
</td></tr>
<tr><td><code id="bi_pal_manual_+3A_preview">preview</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> (default), an image preview will
be generated. If <code>FALSE</code>, a vector with hex color values will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A function for structuring manual bi-variate palettes. All values must be entered
as six-digit hex values (e.g. #000000) and must be preceded by the number symbol. Short
forms of hex values (e.g. #000) are not accepted as valid inputs. For two-by-two palettes,
only the 'val_1_1', 'val_1_2', 'val_2_1', and 'val_2_2' parameters are required. For
three-by-three palettes, all parameters are required.
</p>

<hr>
<h2 id='bi_scale_color'>Apply Bivariate Color to ggplot Object</h2><span id='topic+bi_scale_color'></span>

<h3>Description</h3>

<p>Applies the selected palette as the color aesthetic when <code><a href="ggplot2.html#topic+geom_sf">geom_sf</a></code>
is used and the <code>bi_class</code> variable is given as the <code>color</code> in the aesthetic
mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_scale_color(pal, dim = 3, flip_axes = FALSE, rotate_pal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_scale_color_+3A_pal">pal</code></td>
<td>
<p>A palette name or a vector containing a custom palette. See
the help file for <code>bi_pal</code> for complete list of built-in palette
names. If you are providing a custom palette, it must follow the formatting
described in the 'Advanced Options' vignette.</p>
</td></tr>
<tr><td><code id="bi_scale_color_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette. To use the built-in palettes,
this value must be either <code>2</code>, <code>3</code>, or <code>4</code>. A value of
<code>3</code>, for example, would be used to create a three-by-three bivariate
map with a total of 9 classes.
</p>
<p>If you are using a custom palette, this value may be larger (though these
maps can be very hard to interpret). See the 'Advanced Options' vignette
for details on the relationship between <code>dim</code> values and palette size.</p>
</td></tr>
<tr><td><code id="bi_scale_color_+3A_flip_axes">flip_axes</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the axes of the palette
will be flipped. If <code>FALSE</code> (default), the palette will be displayed
on its original axes. Custom palettes with 'dim' greater
than 4 cannot take advantage of flipping axes.</p>
</td></tr>
<tr><td><code id="bi_scale_color_+3A_rotate_pal">rotate_pal</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the palette will be
rotated 180 degrees. If <code>FALSE</code> (default), the palette will be
displayed in its original orientation. Custom palettes with 'dim' greater
than 4 cannot take advantage of palette rotation.</p>
</td></tr>
<tr><td><code id="bi_scale_color_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="ggplot2.html#topic+scale_color_manual">scale_color_manual</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object with the given bivariate palette applied to the data.
</p>


<h3>See Also</h3>

<p>bi_pal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dependencies
library(ggplot2)

# add breaks, 3x3
data &lt;- bi_class(stl_race_income, x = pctWhite, y = medInc, style = "quantile", dim = 3)

# create map
plot &lt;- ggplot() +
  geom_sf(data = data, aes(color = bi_class), size = 2, show.legend = FALSE) +
  bi_scale_color(pal = "GrPink", dim = 3)

</code></pre>

<hr>
<h2 id='bi_scale_fill'>Apply Bivariate Fill to ggplot Object</h2><span id='topic+bi_scale_fill'></span>

<h3>Description</h3>

<p>Applies the selected palette as the fill aesthetic when <code><a href="ggplot2.html#topic+geom_sf">geom_sf</a></code>
is used and the <code>bi_class</code> variable is given as the <code>fill</code> in the aesthetic
mapping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_scale_fill(pal, dim = 3, flip_axes = FALSE, rotate_pal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_scale_fill_+3A_pal">pal</code></td>
<td>
<p>A palette name or a vector containing a custom palette. See
the help file for <code>bi_pal</code> for complete list of built-in palette
names. If you are providing a custom palette, it must follow the formatting
described in the 'Advanced Options' vignette.</p>
</td></tr>
<tr><td><code id="bi_scale_fill_+3A_dim">dim</code></td>
<td>
<p>The dimensions of the palette, either <code>2</code> for a
two-by-two palette, <code>3</code> for a three-by-three palette, or <code>4</code>
for a four-by-four palette.</p>
</td></tr>
<tr><td><code id="bi_scale_fill_+3A_flip_axes">flip_axes</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the axes of the palette
will be flipped. If <code>FALSE</code> (default), the palette will be displayed
on its original axes.</p>
</td></tr>
<tr><td><code id="bi_scale_fill_+3A_rotate_pal">rotate_pal</code></td>
<td>
<p>A logical scalar; if <code>TRUE</code> the palette will be
rotated 180 degrees. If <code>FALSE</code> (default), the palette will be
displayed in its original orientation</p>
</td></tr>
<tr><td><code id="bi_scale_fill_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="ggplot2.html#topic+scale_fill_manual">scale_fill_manual</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object with the given bivariate palette applied to the data.
</p>


<h3>See Also</h3>

<p>bi_pal
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load dependencies
library(ggplot2)

# add breaks, 3x3
data &lt;- bi_class(stl_race_income, x = pctWhite, y = medInc, style = "quantile", dim = 3)

# create map
plot &lt;- ggplot() +
  geom_sf(data = data, aes(fill = bi_class), color = "white", size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "GrPink", dim = 3)

</code></pre>

<hr>
<h2 id='bi_theme'>Basic Theme for Bivariate Mapping</h2><span id='topic+bi_theme'></span>

<h3>Description</h3>

<p>A theme for creating a simple, clean bivariate map using
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bi_theme(
  base_family = "sans",
  base_size = 24,
  bg_color = "#ffffff",
  font_color = "#000000",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bi_theme_+3A_base_family">base_family</code></td>
<td>
<p>A character string representing the font family to be used
in the map.</p>
</td></tr>
<tr><td><code id="bi_theme_+3A_base_size">base_size</code></td>
<td>
<p>A number representing the base size used in the map.</p>
</td></tr>
<tr><td><code id="bi_theme_+3A_bg_color">bg_color</code></td>
<td>
<p>A character string containing the hex value for the desired
color of the map's background.</p>
</td></tr>
<tr><td><code id="bi_theme_+3A_font_color">font_color</code></td>
<td>
<p>A character string containing the hex value for the desired
color of the map's text.</p>
</td></tr>
<tr><td><code id="bi_theme_+3A_...">...</code></td>
<td>
<p>Arguments to pass on to <code>ggplot2</code>'s <code>theme</code> function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load suggested dependencies
library(ggplot2)
library(sf)

# add breaks, 3x3
data &lt;- bi_class(stl_race_income, x = pctWhite, y = medInc, style = "quantile", dim = 3)

# create map
ggplot() +
  geom_sf(data = data, aes(fill = bi_class), color = "white", size = 0.1, show.legend = FALSE) +
  bi_scale_fill(pal = "GrPink", dim = 3) +
  bi_theme()

</code></pre>

<hr>
<h2 id='stl_race_income'>Race and Median Income in St. Louis by Census Tract, 2017</h2><span id='topic+stl_race_income'></span>

<h3>Description</h3>

<p>A simple features data set containing the geometry and associated attributes
for the 2013-2017 American Community Survey estimates for median household income and the
percentage of white residents in St. Louis. This version of the sample data are stored
as polygon data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stl_race_income)
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 4 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>full GEOID string</p>
</dd>
<dt>pctWhite</dt><dd><p>Percent of white residents per tract</p>
</dd>
<dt>medInc</dt><dd><p>Median household income of tract</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>tidycensus</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(stl_race_income)
head(stl_race_income)
summary(stl_race_income$medInc)

</code></pre>

<hr>
<h2 id='stl_race_income_point'>Race and Median Income in St. Louis by Census Tract, 2017</h2><span id='topic+stl_race_income_point'></span>

<h3>Description</h3>

<p>A simple features data set containing the geometry and associated attributes
for the 2013-2017 American Community Survey estimates for median household income and the
percentage of white residents in St. Louis. This version of the sample data are stored
as point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stl_race_income_point)
</code></pre>


<h3>Format</h3>

<p>A data frame with 106 rows and 4 variables:
</p>

<dl>
<dt>GEOID</dt><dd><p>full GEOID string</p>
</dd>
<dt>pctWhite</dt><dd><p>Percent of white residents per tract</p>
</dd>
<dt>medInc</dt><dd><p>Median household income of tract</p>
</dd>
<dt>geometry</dt><dd><p>simple features geometry</p>
</dd>
</dl>



<h3>Source</h3>

<p><code>tidycensus</code> package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(stl_race_income_point)
head(stl_race_income_point)
summary(stl_race_income_point$medInc)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
