<!DOCTYPE html><html lang="en"><head><title>Help for package RPointCloud</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RPointCloud}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CLL-data'><p>Chronic Lymphocytic Leukemia Clinical Data</p></a></li>
<li><a href='#Cycle-class'>
<p><code>Cycle</code> Objects For Visualizing Topological Data Analysis Results</p></a></li>
<li><a href='#cytof-data'><p>CyTOF Data</p></a></li>
<li><a href='#disentangle'>
<p>Disentangling Rips Diagrams From Their Initial Data Coordinates</p></a></li>
<li><a href='#EBexpo-class'>
<p>The <code>EBexpo</code> Class</p></a></li>
<li><a href='#ExpoFit-class'>
<p>The <code>ExpoFit</code> Class</p></a></li>
<li><a href='#Feature-class'>
<p><code>Feature</code> Objects For Visualizing Topological Data Anal;ysis Results</p></a></li>
<li><a href='#LDPC'>
<p>Local Dimension of Point Clouds</p></a></li>
<li><a href='#LoopCircos-class'>
<p>The <code>LoopCircos</code> Class</p></a></li>
<li><a href='#LoopFeature-class'>
<p><code>LoopFeature</code> Objects For Visualizing Features That Define Loops</p></a></li>
<li><a href='#Projection-class'>
<p><code>Projection</code> Objects For Visualizing 3D Topological Data Analysis</p>
Results in 2D</a></li>
<li><a href='#tailHisto'>
<p>Function to extract the right tail of a histogram for display purposes.</p></a></li>
<li><a href='#treg-data'><p>Single Cell Data on T Regulatory (Treg) Cells</p></a></li>
<li><a href='#voids'>
<p>3D Scatter Plots of Cycles and Features</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.8.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Visualizing Topological Loops and Voids</td>
</tr>
<tr>
<td>Description:</td>
<td>Visualizations to explain the results of a topological
  data analysis. The goal of topological data analysis is to identify
  persistent topological structures, such as loops (topological circles)
  and voids (topological spheres), in data sets. The output of an
  analysis using the 'TDA' package is a Rips diagram (named after the
  mathematician Eliyahu Rips). The goal of 'RPointCloud' is to fill in
  these holes in the data by providing tools to visualize the features
  that help explain the structures found in the Rips diagram. See McGee
  and colleagues (2024) &lt;<a href="https://doi.org/10.1101%2F2024.05.16.593927">doi:10.1101/2024.05.16.593927</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, graphics, stats, TDA, ClassDiscovery, ClassComparison
(&ge; 3.3), Mercator, rgl, splines, circlize</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, Polychrome, igraph, ape, PCDimension</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/Artistic-2.0">Artistic-2.0</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://oompa.r-forge.r-project.org/">http://oompa.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 17:17:07 UTC; KRC</td>
</tr>
<tr>
<td>Author:</td>
<td>Kevin R. Coombes [aut, cre],
  Jake Reed [aut],
  RB McGee [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kevin R. Coombes &lt;krc@silicovore.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CLL-data'>Chronic Lymphocytic Leukemia Clinical Data</h2><span id='topic+CLL-data'></span><span id='topic+clinical'></span><span id='topic+daisydist'></span><span id='topic+ripdiag'></span>

<h3>Description</h3>

<p>Contains 29 columns of deidentified clinical data on 266 patients with
chronic lymphocytic leukemia (CLL).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CLL)
</code></pre>


<h3>Format</h3>

<p> Note that there are three distinct objects included in the data
set: <code>clinical</code>, <code>daisydist</code>, and <code>ripDiag</code>.
</p>

<dl>
<dt><code>clinical</code></dt><dd><p>A numerical data matrix with 266 rows
(patients) amd 29 columns (clinical features). Patients were newly
diagnosed with CLL and previously untreated at the time the
clinical measurements were recorded.</p>
</dd>
<dt><code>daisydist</code></dt><dd><p>A distance matrix, stored as a <code>dist</code>
object, recording pairwise distances between the 266 CLL
patients. Distances were computed using the <code><a href="cluster.html#topic+daisy">daisy</a></code>
function of Kaufmann and Rooseeuw, as implemented in the
<code>cluster</code> R package.</p>
</dd>
<dt><code>ripDiag</code></dt><dd><p>This object  is a &quot;Rips diagram&quot;. It was produced
by running the the <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code> function from the
<code><a href="TDA.html#topic+TDA">TDA</a></code> R package on the <code>daisydist</code> distance matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Caitlin E. Coombes <a href="mailto:ccoombes@stanford.edu">ccoombes@stanford.edu</a>,
Jake Reed <a href="mailto:hreed@augusta.edu">hreed@augusta.edu</a></p>


<h3>Source</h3>

<p>Data were collected in the clinic of Dr. Michael Keating at the
University of Texas M.D. Anderson Cancer Center to accompany patient
samples sent to the laboratory of Dr. Lynne Abruzzo. Various subsets
of the data have been reported previously; see the references for some
publications. Computation of the daisy distance was performed by
Caitlin E. Coombes, whose Master's Thesis also showed that this was 
the most appropriate method when dealing with heterogeneous clinical
data of mixed type. Computation of the topological data analysis (TDA) using the
Rips diagram was performed by Jake Reed.
</p>


<h3>References</h3>

<p>Schweighofer CD, Coombes KR, Barron LL, Diao L, Newman RJ, Ferrajoli
A, O'Brien S, Wierda WG, Luthra R, Medeiros LJ, Keating MJ, Abruzzo
LV.  A two-gene signature, SKI and SLAMF1, predicts time-to-treatment
in previously untreated patients with chronic lymphocytic
leukemia. PLoS One. 2011;6(12):e28277. doi:
10.1371/journal.pone.0028277.
</p>
<p>Duzkale H, Schweighofer CD, Coombes KR, Barron LL, Ferrajoli A,
O'Brien S, Wierda WG, Pfeifer J, Majewski T, Czerniak BA, Jorgensen
JL, Medeiros LJ, Freireich EJ, Keating MJ, Abruzzo LV.  LDOC1 mRNA is
differentially expressed in chronic lymphocytic leukemia and predicts
overall survival in untreated patients. Blood. 2011 Apr
14;117(15):4076-84. doi: 10.1182/blood-2010-09-304881.
</p>
<p>Schweighofer CD, Coombes KR, Majewski T, Barron LL, Lerner S, Sargent
RL, O'Brien S, Ferrajoli A, Wierda WG, Czerniak BA, Medeiros LJ,
Keating MJ, Abruzzo LV. Genomic variation by whole-genome SNP mapping
arrays predicts time-to-event outcome in patients with chronic
lymphocytic leukemia: a comparison of CLL and HapMap genotypes. J Mol
Diagn. 2013 Mar;15(2):196-209. doi: 10.1016/j.jmoldx.2012.09.006.
</p>
<p>Herling CD, Coombes KR, Benner A, Bloehdorn J, Barron LL, Abrams ZB,
Majewski T, Bondaruk JE, Bahlo J, Fischer K, Hallek M, Stilgenbauer S,
Czerniak BA, Oakes CC, Ferrajoli A, Keating MJ, Abruzzo
LV. Time-to-progression after front-line fludarabine,
cyclophosphamide, and rituximab chemoimmunotherapy for chronic
lymphocytic leukaemia: a retrospective, multicohort study. Lancet
Oncol. 2019 Nov;20(11):1576-1586. doi: 10.1016/S1470-2045(19)30503-0.
</p>
<p>Coombes CE, Abrams ZB, Li S, Abruzzo LV, Coombes KR. Unsupervised
machine learning and prognostic factors of survival in chronic
lymphocytic leukemia. J Am Med Inform Assoc. 2020 Jul
1;27(7):1019-1027. doi: 10.1093/jamia/ocaa060. 
</p>

<hr>
<h2 id='Cycle-class'>
<code>Cycle</code> Objects For Visualizing Topological Data Analysis Results
</h2><span id='topic+Cycle-class'></span><span id='topic+Cycle'></span><span id='topic+lines+2CCycle-method'></span><span id='topic+plot+2CCycle+2Cmatrix-method'></span><span id='topic+getCycle'></span><span id='topic+cycleSupport'></span>

<h3>Description</h3>

<p>The <code>Cycle</code> object represents a cycle found by performing
topological data analysis (using the <code>TDA</code> package) on a data
matrix or distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cycle(rips, dimen, J, color)
getCycle(rips, dimension = 1, target = NULL)
cycleSupport(cycle, view)
## S4 method for signature 'Cycle,matrix'
plot(x, y, lwd = 2, ...)
## S4 method for signature 'Cycle'
lines(x, view, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cycle-class_+3A_rips">rips</code></td>
<td>
<p>A Rips <code>diagram</code> from the <code>TDA</code> package.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_dimen">dimen</code></td>
<td>
<p>An integer; the dimension of the cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_j">J</code></td>
<td>
<p>An integer; the index locating the cycle in the
<code>cycleLocation</code> portion of the Rips diagram. If <code>NULL</code>,
then looks for the most persistent cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_color">color</code></td>
<td>
<p>A character vector of length one; the color in which to
display the cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_x">x</code></td>
<td>
<p>A <code>Cycle</code> object.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_y">y</code></td>
<td>
<p> A (layout) matrix with coordinates showing where to plot
each point supporting the cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_view">view</code></td>
<td>
<p> A (layout) matrix with coordinates showing where to plot
each point supporting the cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_lwd">lwd</code></td>
<td>
<p>A number; the graphical line width parameter <code>lwd</code>.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_...">...</code></td>
<td>
<p>The usual set of additional graphical parameters. </p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_dimension">dimension</code></td>
<td>
<p>An integer; the dimension of the cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_target">target</code></td>
<td>
<p>An integer indexing the desired cycle. Note that the index
should be relative to other cuycles of the same dimension. If
<code>NULL</code>, gets the longest persisting cycle.</p>
</td></tr>
<tr><td><code id="Cycle-class_+3A_cycle">cycle</code></td>
<td>
<p>A raw cycle, meaning a simple element of the
<code>cycleLocation</code> part of a Rips diagram.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Cycle</code> function constructs and returns an object of the
<code>Cycle</code> class
</p>
<p>The <code>plot</code> and <code>lines</code> methods return (invisibly) the Cycle
object that was their first argument.
</p>
<p>The <code>getCycle</code> function extracts a single raw cycle from a Rips
diagram and returns it. The <code>cycleSupport</code> function combines such
a cycle with a layout/view matrix to extract a list of the coordinates
of the points contained in the cycle.
</p>


<h3>Slots</h3>


<dl>
<dt><code>index</code>:</dt><dd><p>A matrix, containing the indices into the data
matrix or distance matrix defining the simplices that realize the
cycle.</p>
</dd>
<dt><code>dimension</code>:</dt><dd><p>A matrix; the dimension of the cycle. </p>
</dd>
<dt><code>color</code>:</dt><dd><p>A character vector; the color in which to
display the cycle.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, y, lwd = 2, ...):</dt><dd>
<p>Produce a plot of a <code>Cycle</code> object.
</p>
</dd>
<dt>lines(x, view, ...)</dt><dd>
<p>Add a depiction of a cycle to an existing plot. 
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="TDA.html#topic+TDA">TDA</a></code>, <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
cyc1 &lt;- Cycle(ripdiag, 1, 236, "forestgreen")
V &lt;- cmdscale(daisydist)
plot(cyc1, V)
plot(V, pch = 16, col = "gray")
lines(cyc1, V)
</code></pre>

<hr>
<h2 id='cytof-data'>CyTOF Data</h2><span id='topic+cytof-data'></span><span id='topic+AML10.node287'></span><span id='topic+AML10.node287.rips'></span><span id='topic+Arip'></span>

<h3>Description</h3>

<p>This data set contains 18 columns of protein expression values
measured in 214 early monocyte cells using mass cytometry (CyTOF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cytof)
</code></pre>


<h3>Format</h3>

<p> Note that there are three distinct objects included in the data
set: <code>AML10.node287</code>, <code>AML10,node287.rips</code>, and <code>Arip</code>.
</p>

<dl>
<dt><code>AML10.node287</code></dt><dd><p>A numerical data matrix with 214 rows
(single cells) amd 18 columns (antibody-protein markers). Values
were obtained using mass cytometry applied to a sample collected
from a patient with acute myeloid leukemia (AML).</p>
</dd> 
<dt><code>AML10.node287.rips</code></dt><dd><p>This object  is a
&quot;Rips diagram&quot;. It was produced by running the
<code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code> function from the <code><a href="TDA.html#topic+TDA">TDA</a></code> R
package on the <code>AML10.node287</code> data matrix.</p>
</dd>
<dt><code>Arip</code></dt><dd><p>This object  is a &quot;Rips diagram&quot;. It was produced
by running the <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code> function from the
<code><a href="TDA.html#topic+TDA">TDA</a></code> R package on the Euclidean distance matrix
between the single cells.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
RB McGee <a href="mailto:mcgee@sholycross.edu">mcgee@sholycross.edu</a>,
Jake Reed <a href="mailto:hreed@augusta.edu">hreed@augusta.edu</a></p>


<h3>Source</h3>

<p>Data were collected by Dr. Greg Behbehani while working in the
laboratory of Dr. Garry Nolan at Stanford University. This data set is
a tiny subset of the full data set, which was described previously in
the paper by Behbehani et al.
</p>


<h3>References</h3>

<p>Behbehani GK, Samusik N, Bjornson ZB, Fantl WJ, Medeiros BC, Nolan
GP. Mass Cytometric Functional Profiling of Acute Myeloid Leukemia
Defines Cell-Cycle and Immunophenotypic Properties That Correlate with
Known Responses to Therapy. Cancer Discov. 2015
Sep;5(9):988-1003. doi: 10.1158/2159-8290.CD-15-0298. 
</p>

<hr>
<h2 id='disentangle'>
Disentangling Rips Diagrams From Their Initial Data Coordinates
</h2><span id='topic+disentangle'></span>

<h3>Description</h3>

<p>The <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code> function in the <code>TDA</code> package produces
very different results depending on whether you invoke it on a data
matrix (expressed in terms of specific data coordinates) or a distance
matrix (expressed as abstract indices). This function converts the
specific coordinates into indices, allowing one to more easily plot
different views of the data structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disentangle(rips, dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="disentangle_+3A_rips">rips</code></td>
<td>
<p>A Rips <code>diagram</code> produced from a data matrix using
the <code>TDA</code> package.</p>
</td></tr>
<tr><td><code id="disentangle_+3A_dataset">dataset</code></td>
<td>
<p>The original dataset used to create the <code>rips</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The core algorithm is, quite simply, to recombine the coordinates of a
point in the Rips diagram in a manner consistent with their storage in
the original data set, and find the index (i.e., row number) of that
point.
</p>


<h3>Value</h3>

<p>Returns a Rips diagram nearly identical to the one that would be
produced if the <code>ripsDiag</code> function had been invoked instead on
the Euclidean distance matrix.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytof)
fixed &lt;- disentangle(Arip, AML10.node287)
</code></pre>

<hr>
<h2 id='EBexpo-class'>
The <code>EBexpo</code> Class
</h2><span id='topic+EBexpo-class'></span><span id='topic+EBexpo'></span><span id='topic+plot+2CEBexpo+2Cmissing-method'></span><span id='topic+hist+2CEBexpo-method'></span><span id='topic+cutoff'></span>

<h3>Description</h3>

<p>The <code>EBexpo</code> object represents the results of an Empirical Bayes
approach to estimate a distribution as a mixture of a (more or less)
known exponential distribution along with a completely unknown
&quot;interesting&quot; distribution. The basic method was described by Efron
and Tibshirani with an application to differential expression in
microarray data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EBexpo(edata, resn = 200)
cutoff(target, prior, object)
## S4 method for signature 'EBexpo,missing'
plot(x, prior = 1, significance = c(0.5, 0.8, 0.9),
                 ylim = c(-0.5, 1), xlab = "Duration",
                 ylab = "Probability(Interesting | Duration)", ...)
## S4 method for signature 'EBexpo'
hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EBexpo-class_+3A_edata">edata</code></td>
<td>
<p>A numeric vector; the observed data that we think comes
mainly from an exponential distribution.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_resn">resn</code></td>
<td>
<p>A numeric vector; the resolution used to estimate a histogream.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_x">x</code></td>
<td>
<p>An <code>EBexpo</code> object.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_prior">prior</code></td>
<td>
<p>A numeric vector of length 1; the prior probability of an
observed data point coming from the known exponential distribution.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_significance">significance</code></td>
<td>
<p>A numeric vector with values between 0 and 1; the
target posterior probabiltiites.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length two.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_xlab">xlab</code></td>
<td>
<p>A character vector; the label for the x-axis.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_ylab">ylab</code></td>
<td>
<p>A character vector; the label for the y-axis.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_...">...</code></td>
<td>
<p>The usual set of graphical parameters. </p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_target">target</code></td>
<td>
<p>The target posterior probability.</p>
</td></tr>
<tr><td><code id="EBexpo-class_+3A_object">object</code></td>
<td>
<p>An <code>EBexpo</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>EBexpo</code> function constructs and returns an object of the
<code>EBexpo</code> class
</p>
<p>The <code>plot</code> and <code>hist</code> methods return (invisibly) the EBexpo
object that was their first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xvals</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code></p>
</dd> 
<dt><code>statistics</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>, Here, these are
the same a the <code>edata</code> slot from an <code>link{ExpoFit}</code> object.</p>
</dd>
<dt><code>pdf</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code></p>
</dd> 
<dt><code>theoretical.pdf</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code></p>
</dd> 
<dt><code>unravel</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code></p>
</dd> 
<dt><code>groups</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code>, but not used</p>
</dd>
<dt><code>call</code>:</dt><dd><p>Inherited from
<code><a href="ClassComparison.html#topic+MultiWilcoxonTest">MultiWilcoxonTest</a></code></p>
</dd> 
<dt><code>h0</code>:</dt><dd><p>See <code><a href="#topic+ExpoFit">ExpoFit</a></code></p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>See <code><a href="#topic+ExpoFit">ExpoFit</a></code></p>
</dd>
<dt><code>mu</code>:</dt><dd><p>See <code><a href="#topic+ExpoFit">ExpoFit</a></code></p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, prior, post = c(0.5, 0.8, 0.9), ...):</dt><dd>
<p>Produce a plot of a <code>EBexpo</code> object.
</p>
</dd>
<dt>hist(x, ...):</dt><dd>
<p>Produce a histogram of the observed distibution, with overlays.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>References</h3>

<p>Efron B, Tibshirani R. Empirical bayes methods and false discovery
rates for microarrays. Genet Epidemiol. 2002 Jun;23(1):70-86. doi:
10.1002/gepi.1124.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytof)
diag &lt;- AML10.node287.rips[["diagram"]]
persistence &lt;- diag[, "Death"] - diag[, "Birth"]
d1 &lt;- persistence[diag[, "dimension"] == 1]
eb &lt;- EBexpo(d1, 200)
hist(eb)
plot(eb, prior = 0.56)
cutoff(0.8, 0.56, eb)
</code></pre>

<hr>
<h2 id='ExpoFit-class'>
The <code>ExpoFit</code> Class
</h2><span id='topic+ExpoFit-class'></span><span id='topic+ExpoFit'></span><span id='topic+plot+2CExpoFit+2Cmissing-method'></span>

<h3>Description</h3>

<p>An <code>ExpoFit</code> object represents a robust fit to an exponential
distribution, in a form that can conveniently be used as part of an
Empirical Bayes approach to decompose the distributions of cycle
presistence or duration for a topological data analysis performed
using the <code>TDA</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExpoFit(edata, resn = 200)
## S4 method for signature 'ExpoFit,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ExpoFit-class_+3A_edata">edata</code></td>
<td>
<p>A numeric vector; the observed data that we think comes
mainly from an exponential distribution.</p>
</td></tr>
<tr><td><code id="ExpoFit-class_+3A_resn">resn</code></td>
<td>
<p>A numeric vector of length 1; the resolution (number of
breaks) used to estimate a histogram.</p>
</td></tr>
<tr><td><code id="ExpoFit-class_+3A_x">x</code></td>
<td>
<p>An <code>ExpoFit</code> object.</p>
</td></tr>
<tr><td><code id="ExpoFit-class_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="ExpoFit-class_+3A_...">...</code></td>
<td>
<p>The usual set of graphical parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>ExpoFit</code> function constructs and returns an object of the
<code>ExpoFit</code> class.
</p>
<p>The <code>plot</code> method returns (invisibly) the ExpoFit object that was
its first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>edata</code>:</dt><dd><p>A numeric vector; the observed data that we
think comes from an exponential distribution.</p>
</dd>
<dt><code>h0</code>:</dt><dd><p>A <code>histogram</code> object produced by the
<code><a href="graphics.html#topic+hist">hist</a></code> function applied to the supplied <code>edata</code>.</p>
</dd>
<dt><code>X0</code>:</dt><dd><p>A numeric vector containing the midpoints of the
breaks in the histogram object.</p>
</dd>
<dt><code>pdf</code>:</dt><dd><p>The empirical density function extracted from the
histogram object.</p>
</dd>
<dt><code>mu</code>:</dt><dd><p>The observed mean of the putative exponential
distribution.</p>
</dd>
<dt><code>lambda</code>:</dt><dd><p>The robustly estimated parameter of the
exponential distribution. Originally crudely repesented by the
reciprocal of the mean.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, y, lwd = 2, ...):</dt><dd>
<p>Produce a plot of a <code>ExpoFit</code> object.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+EBexpo">EBexpo</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytof)
diag &lt;- AML10.node287.rips[["diagram"]]
persistence &lt;- diag[, "Death"] - diag[, "Birth"]
d1 &lt;- persistence[diag[, "dimension"] == 1]
ef &lt;- ExpoFit(d1) # should be close to log(2)/median? 
plot(ef)
</code></pre>

<hr>
<h2 id='Feature-class'>
<code>Feature</code> Objects For Visualizing Topological Data Anal;ysis Results
</h2><span id='topic+Feature-class'></span><span id='topic+Feature'></span><span id='topic+points+2CFeature-method'></span><span id='topic+plot+2CFeature+2Cmatrix-method'></span>

<h3>Description</h3>

<p>The <code>Feature</code> object represents a feature from a data matrix used
when performing topological data analysis with the <code>TDA</code>
package. Features might be genes, proteins, clinical or demographic
covariates, or any other item measured on a set of patient samples or
cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Feature(values, name, colors, meaning, ...)
## S4 method for signature 'Feature,matrix'
plot(x, y, pch = 16, ...)
## S4 method for signature 'Feature'
points(x, view, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Feature-class_+3A_values">values</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_name">name</code></td>
<td>
<p>A character vector of length one.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_colors">colors</code></td>
<td>
<p>A character vector of length at least two, containing
the names or hexadecimal representations of colors used to create a
color ramp to display the feature.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_meaning">meaning</code></td>
<td>
<p>A character vector of length two containing the
interpretations of the low and high extreme values of the
feature. Note that this works perfectly well for binary factors
represented as numeric 0-1 vectors.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_x">x</code></td>
<td>
<p>A <code>Feature</code> object.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_y">y</code></td>
<td>
<p>A (layout) matrix with coordinates showing where to plot
each point in the feature.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_view">view</code></td>
<td>
<p> A (layout) matrix with coordinates showing where to plot
each point in the feature.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_pch">pch</code></td>
<td>
<p>A number; the graphical plotting character parameter <code>pch</code>.</p>
</td></tr>
<tr><td><code id="Feature-class_+3A_...">...</code></td>
<td>
<p>The usual set of additional graphical parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Feature</code> function constructs and returns an object of the
<code>Feature</code> class
</p>
<p>The <code>plot</code> and <code>points</code> methods return (invisibly) the Feature
object that was their first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd><p>A character vector of length one; the name of
the feature..</p>
</dd>
<dt><code>values</code>:</dt><dd><p>A numeric vector of the values of this feature. </p>
</dd>
<dt><code>meaning</code>:</dt><dd><p>A character vector of length two containing the
interpretations of the low and high extreme values of the
feature. Note that this works perfectly well for binary factors
represented as numeric 0-1 vectors. </p>
</dd>
<dt><code>colRamp</code>:</dt><dd><p>A function created using the
<code><a href="circlize.html#topic+colorRamp2">colorRamp2</a></code> function from the <code><a href="circlize.html#topic+circlize">circlize</a></code>
package.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, y, lwd = 2, ...):</dt><dd>
<p>Produce a plot of a <code>Feature</code> object.
</p>
</dd>
<dt>points(x, view, ...)</dt><dd>
<p>Add a depiction of a feature to an existing plot.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
featSex &lt;- Feature(clinical[,"Sex"], "Sex",
            c("pink", "skyblue"), c("Female", "Male"))
V &lt;- cmdscale(daisydist)
plot(featSex, V)
plot(V)
points(featSex, V)
</code></pre>

<hr>
<h2 id='LDPC'>
Local Dimension of Point Clouds
</h2><span id='topic+LDPC'></span><span id='topic+takens'></span>

<h3>Description</h3>

<p>Given a data set viewed as a point cloud in N-dimesnional space,
compute the local estimate of the dimension of an underlying manifold,
as defined by Ellis and McDermott, analogous to earlier related work
by Takens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>takens(r, dists)
LDPC(CellID, dset, rg, quorum, samplesAreRows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LDPC_+3A_cellid">CellID</code></td>
<td>
<p>An integer indexing one of the cells-samples in the data set.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_dset">dset</code></td>
<td>
<p>A data set. The usual orientation is that rows are cells
and columns are features.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_rg">rg</code></td>
<td>
<p>A numerical vector of radial distances at which to compute
Takens estimates of the local dimension.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_quorum">quorum</code></td>
<td>
<p>The minimum number of neighboring cells required for
the computation to be meaningful.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_samplesarerows">samplesAreRows</code></td>
<td>
<p>A logical value: do rows or columns represent
samples at which to compute local dimensions.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_r">r</code></td>
<td>
<p>A radial distances at which to compute the Takens estimate.</p>
</td></tr>
<tr><td><code id="LDPC_+3A_dists">dists</code></td>
<td>
<p>A sorted vector of distances from one cell to all other cells.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;[T]he procedure is carried out as follows. A 'bin increment', $A$; a
number, $m$, of bin increments; and a 'quorum', $q &gt; 0$, are chosen
and raw dimensions are calculated for $r=A$, $2A$, $...$, $m$. Next,
for each observation, $x_i$, let $r_i$ be the smallest multiple of $A$
not exceeding $mA$ such that the ball with radius $r_i$ centered at
$x_i$ contains at least $q$ observations, providing that there are at
least $q$ observations within $mA$ of $x_i$. Otherwise let $r_i = mA$.&quot;
</p>
<p>The <code>takens</code> function computes the Takens estimate of the local
dimension of a point cloud at radius $r$ around a data point. For each
cell-sample, we must compute and sort the distances from that cell to
all other cells. (For the <code>takens</code> function, these distances are
passed in as the second argument to the function.) Preliminary
histograms of distance distributions may be used to inform a good set
of radial distances. Note that the local dimension estimates are
infinite if the radius is so small that there are no neighbors. The
estmiates decrease as the radius increases os as the number of local
neighbors increases. The reference paper by Ellis and McDermott says:
</p>
<p>The <code>LDPC</code> function iterates over all cells-samples int he data sets,
computes and sorts their distance to all other cells, and invokes teh
<code>takens</code> function to compute local estimates os dimension.
</p>


<h3>Value</h3>

<p>The <code>takens</code> function returns a list with two items: the number
of neighbors $k$ and the dimension estimate $d$ at each value
of the radius from the input vector.
</p>
<p>The <code>LDPC</code> function returns a list containing vectors $R$, $k$,
and $d$ values for each cell in the data set.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>References</h3>

<p>Ellis and McDermott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cytof)
localdim &lt;- LDPC(1, AML10.node287, seq(1, 6, length=20), 30, TRUE)
</code></pre>

<hr>
<h2 id='LoopCircos-class'>
The <code>LoopCircos</code> Class
</h2><span id='topic+LoopCircos-class'></span><span id='topic+LoopCircos'></span><span id='topic+image+2CLoopCircos-method'></span><span id='topic+angleMeans'></span>

<h3>Description</h3>

<p>A <code>LoopCircos</code> object represents a one-dimensional cycle (a
loop, or topogical eequivalent of a circle), along with a set of
features that vary around the loop and can be plotted in a &quot;circos&quot;
plot to help explain why the loop exists. The <code>LoopCircos</code> class
inherits from the <code><a href="#topic+Cycle">Cycle</a></code> class, so you can think of it as
a cycle object with extra information (namely, the explanatory
features).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoopCircos(cycle, angles, colors)
angleMeans(view, rips, cycle = NULL, dset, angleWidth = 20, incr = 15)
## S4 method for signature 'LoopCircos'
image(x, na.col = "grey", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LoopCircos-class_+3A_cycle">cycle</code></td>
<td>
<p>In the <code>LoopCircos</code> function, an object of the
<code><a href="#topic+Cycle">Cycle</a></code> class. In the <code>angleMeans</code> function, an 
object of the <code><a href="#topic+Cycle">Cycle</a></code> class.</p>
</td></tr> 
<tr><td><code id="LoopCircos-class_+3A_angles">angles</code></td>
<td>
<p>A matrix where columns are features, rows are angles,
and the value is the mean expression of that feature in a sector
around that central angle. These are almost always constructed using
the <code>angleMeans</code> function.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_colors">colors</code></td>
<td>
<p>A list of character vectors, each of length two, containing
the names or hexadecimal representations of colors used to create a
color ramp to display the feature. The list should be the same
length as the number of features to be displayed.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_view">view</code></td>
<td>
<p> A (layout) matrix with coordinates showing where to plot
each point in the feature while computing means in sectors.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_rips">rips</code></td>
<td>
<p>A Rips <code>diagram</code> object.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_dset">dset</code></td>
<td>
<p>The numeric matrix from which Featuers are drawn.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_anglewidth">angleWidth</code></td>
<td>
<p>A numeric vector of length one; the width (in
degrees) of each sector.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_incr">incr</code></td>
<td>
<p>A numeric vector; the increment (in degeres)  between sector centers.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_x">x</code></td>
<td>
<p>A <code>LoopCircos</code> object.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_na.col">na.col</code></td>
<td>
<p>A character string; the color in which to plot missing
(<code>NA</code>) data.</p>
</td></tr>
<tr><td><code id="LoopCircos-class_+3A_...">...</code></td>
<td>
<p>The usual set of additional graphical parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>angleMeans</code> function computes the mean expression of each
numeric feature in a two-dimensional sector swept out around the
centroid of the support of a cycle. It returns these values as a
matrix, with each row corresponding to the angle (in degrees) around
the centroid of the cycle.
</p>
<p>The <code>LoopCircos</code> function constructs and returns an object of the
<code>LoopCircos</code> class
</p>
<p>The <code>image</code> method returns (invisibly) the LoopCircos
object that was its first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>angles</code>:</dt><dd><p>A matrix of angle means.</p>
</dd>
<dt><code>colors</code>:</dt><dd><p>A list of color-pairs for displayign features.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>image(x, ...):</dt><dd>
<p>Produce a circos plot of a <code>LoopCircos</code> object.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cycle">Cycle</a></code>, <code><a href="#topic+LoopFeature">LoopFeature</a></code>, <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
cyc1 &lt;- Cycle(ripdiag, 1, 236, "forestgreen")
V &lt;- cmdscale(daisydist)
poof &lt;- angleMeans(V, ripdiag, cyc1, clinical)
poof[is.na(poof)] &lt;- 0
angle.df &lt;- poof[, c("mutation.status", "CatCD38", "CatB2M", "CatRAI",
                     "Massive.Splenomegaly", "Hypogammaglobulinemia")]
colorScheme &lt;- list(c(M = "green", U = "magenta"),
                    c(Hi = "cyan", Lo ="red"),
                    c(Hi = "blue", Lo = "yellow"),
                    c(Hi = "#dddddd", Lo = "#111111"),
                    c(No = "#dddddd", Yes = "brown"),
                    c(No = "#dddddd", Yes = "purple"))
annote &lt;- LoopCircos(cyc1, angle.df, colorScheme)
image(annote)
</code></pre>

<hr>
<h2 id='LoopFeature-class'>
<code>LoopFeature</code> Objects For Visualizing Features That Define Loops
</h2><span id='topic+LoopFeature-class'></span><span id='topic+LoopFeature'></span><span id='topic+plot+2CLoopFeature+2Cmissing-method'></span><span id='topic+plot+2CLoopFeature+2Ccharacter-method'></span><span id='topic+image+2CLoopFeature-method'></span>

<h3>Description</h3>

<p>The <code>LoopFeature</code> class is a tool for understanding and
visualizing loops (topological circles) and the features that can be
used to define and interpret them. Having found a (statistically
significant) loop, we investigate a feature by computing its mean
expression in sectors of a fixed width (usually 20 degrees) at a grid
of angles around the circle (usually multiples of 15 degrees from 0
to 360). We model these data using the function
</p>
<p style="text-align: center;"><code class="reqn">f(\theta) = A + B\sin(\theta) + C\cos(\theta).</code>
</p>

<p>We then compute the &quot;fraction of unexplained variance&quot; by dividing the
residual sum of squares from this model by the total variance of the
feature. Smaller values of this statistic are more likely to identify
features that vary sytematically around the circle with a single peak
and a single trough.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LoopFeature(circMeans)
## S4 method for signature 'LoopFeature,missing'
plot(x, y, ...)
## S4 method for signature 'LoopFeature,character'
plot(x, y, ...)
## S4 method for signature 'LoopFeature'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LoopFeature-class_+3A_circmeans">circMeans</code></td>
<td>
<p>A matrix, assumed to be the output from a call to the
<code>angleMeans</code> function. Columns are features and rows are angles.</p>
</td></tr>
<tr><td><code id="LoopFeature-class_+3A_x">x</code></td>
<td>
<p>A <code>LoopFeature</code> object.</p>
</td></tr>
<tr><td><code id="LoopFeature-class_+3A_y">y</code></td>
<td>
<p>A character vector; the set of features to plot.</p>
</td></tr>
<tr><td><code id="LoopFeature-class_+3A_...">...</code></td>
<td>
<p>The usual set of additional graphical parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>LoopFeature</code> function constructs and returns an object of the
<code>LoopFeature</code> class
</p>
<p>The <code>plot</code> and <code>image</code> methods return (invisibly) the
LoopFeature object that was their first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>The input <code>circMeans</code> data matrix.</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>A matrix that is the same size as <code>data</code>;
the results of fitting a model for each feature as a linear
combination of sine and cosine.</p>
</dd>
<dt><code>RSS</code>:</dt><dd><p>A numeric vector; the residual sum of squares for
each model.</p>
</dd>
<dt><code>V</code>:</dt><dd><p>A numeric vector; the total variance for each feature.</p>
</dd>
<dt><code>Kstat</code>:</dt><dd><p>A numeric vector, the unexplained variance
statistic, RSS/V.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, y, ...):</dt><dd>
<p>For the selected features listed in <code>y</code> (which can be missing
or &quot;all&quot; to plot all features), plots the fitted model as a curve
along with the observed data.
</p>
</dd>
<dt>image(x, ...)</dt><dd>
<p>Produce a 2D image of all the features, with each one scaled to
the range [0,1] and with the rows ordered by where around the loop
the maximum value occurs.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
view &lt;- cmdscale(daisydist)
circular &lt;- angleMeans(view, ripdiag, NULL, clinical)
lf &lt;- LoopFeature(circular)
sort(lf@Kstat)
plot(lf, "Serum.beta.2.microglobulin")
opar &lt;- par(mai = c(0.82, 0.2, 0.82, 1.82))
image(lf, main = "Clinical Factors in CLL")
par(opar)

</code></pre>

<hr>
<h2 id='Projection-class'>
<code>Projection</code> Objects For Visualizing 3D Topological Data Analysis
Results in 2D
</h2><span id='topic+Projection-class'></span><span id='topic+Projection'></span><span id='topic+plot+2CProjection+2Cmissing-method'></span><span id='topic+image+2CProjection-method'></span>

<h3>Description</h3>

<p>The <code>Projection</code> class is a tool for understanding and
visualizing voids (topological spheres) and the features that can be
used to define and interpret them. The core idea is to first project all
data points in dimension (at least) 3 radially onto the surface of the
sphere. We then use spherical coordinates on the sphere (the latitude,
<code>psi</code> from 0 to 180 degrees and the longitude, <code>phi</code>, from -180 to 180
degrees) to locate the points. The <code>plot</code> method shows these
points in two dimensions, colored based on the expression of the
chosen <code>Feature</code>. The <code>image</code> method uses a loess fit to
smooth the observed data points across the entire surface of the
sphere and displays the resulting image. Using latitude and longitude
in this way is similar to a Mercator projection of the surface of the
Earth onto a two-dimensional plot.
</p>
<p>It is worth noting that, for purposes of computing the smoothed
version, we actually take two &quot;trips&quot; around the &quot;equator&quot; to fit the
model, but only display the middle section of that fit. The point of
this approach is to avoid edge effects in smoothing the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Projection(cycle, view, feature, span = 0.3, resn = 25)
## S4 method for signature 'Projection,missing'
plot(x, y, pch = 16, ...)
## S4 method for signature 'Projection'
image(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Projection-class_+3A_cycle">cycle</code></td>
<td>
<p>A <code>Cycle</code> object representing a void, or 2-cycle.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_view">view</code></td>
<td>
<p> A (layout) matrix with coordinates showing where to plot
each point in the feature. Must be at least three-dimensional.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_feature">feature</code></td>
<td>
<p>A <code>Feature</code> object, representing the expression
levels of one of the features in the underlying data set.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_span">span</code></td>
<td>
<p>Parameter used for a <code>loess</code> fit.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_resn">resn</code></td>
<td>
<p>The number of steps used to create the vectors <code>psi</code>
and half-<code>phi</code>.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_x">x</code></td>
<td>
<p>A <code>Projection</code> object.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_pch">pch</code></td>
<td>
<p>A number; the graphical plotting character parameter <code>pch</code>.</p>
</td></tr>
<tr><td><code id="Projection-class_+3A_...">...</code></td>
<td>
<p>The usual set of additional graphical parameters. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Projection</code> function constructs and returns an object of the
<code>Projection</code> class
</p>
<p>The <code>plot</code> and <code>image</code> methods return (invisibly) the
Projection object that was their first argument.
</p>


<h3>Slots</h3>


<dl>
<dt><code>phi</code>:</dt><dd><p>A numeric vector</p>
</dd>
<dt><code>psi</code>:</dt><dd><p>A numeric vector</p>
</dd>
<dt><code>displayphi</code>:</dt><dd><p>A numeric vector</p>
</dd>
<dt><code>displaypsi</code>:</dt><dd><p>A numeric vector</p>
</dd>
<dt><code>value</code>:</dt><dd><p>A matrix.</p>
</dd>
<dt><code>feature</code>:</dt><dd><p>A <code>Feature</code> object.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>plot(x, y, lwd = 2, ...):</dt><dd>
<p>Produce a 2-dimensional scatter plot of a <code>Projection</code> object.
</p>
</dd>
<dt>image(x, ...)</dt><dd>
<p>Produce a 2D heatmap image of a <code>Projection</code> object.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
cyc &lt;- Cycle(ripdiag, 2, NULL, "black")
V &lt;- cmdscale(daisydist, 3)
feat &lt;- Feature(clinical[,"stat13"], "Deletion 13q",
               c("green", "magenta"), c("Abnormal", "Normal"))
ob &lt;- Projection(cyc, V, feat, span = 0.2)
plot(ob)
image(ob, col = colorRampPalette(c("green", "gray", "magenta"))(64))

</code></pre>

<hr>
<h2 id='tailHisto'>
Function to extract the right tail of a histogram for display purposes.
</h2><span id='topic+tailHisto'></span>

<h3>Description</h3>

<p>Sometimes, the most interesting part of a histogram lies in the tail,
where details are obscured because of the scale of earlier peaks in
the distribution. This function uses a user-defined target cutoff to
extract the right tail of a histogram, preserving its structure as a
histogram object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tailHisto(H, target)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tailHisto_+3A_h">H</code></td>
<td>
<p>A <code>histogram</code> object.</p>
</td></tr>
<tr><td><code id="tailHisto_+3A_target">target</code></td>
<td>
<p>A real number; the target cutoff defining the portion of
the tail of the histogram to be extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is nothing special going on. The only sanity check is to ensure
that the <code>target</code> is small enough that there is actually a part
of the histogram that can be extracted. After that, we simply cut out
the approprioate pieces, make sure they are structured properly, and
return them.
</p>


<h3>Value</h3>

<p>Returns another <code>histogram</code> object that only contains the portion
of the histogram beyond the target cutoff.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345)
fakeData &lt;- rexp(2000, rate = 10)
H &lt;- hist(fakeData, breaks = 123, plot = FALSE)
H2 &lt;- tailHisto(H, 0.3)
opar &lt;- par(mai=c(0.9, 0.9, 0.6, 0.2))
plot(H, freq = FALSE)
par(mai=c(3.4, 3.0, 0.6, 0.6), new=TRUE)
plot(H2, freq = FALSE, main = "", col = "skyblue")
par(opar)
</code></pre>

<hr>
<h2 id='treg-data'>Single Cell Data on T Regulatory (Treg) Cells</h2><span id='topic+treg-data'></span><span id='topic+treg'></span><span id='topic+tmat'></span><span id='topic+rip'></span>

<h3>Description</h3>

<p>This data set contains mRNA and protein-antibody data on T-regulatory
immune cells. It is a subset of a much larger data set collected from
the peripheral blood of patients with a variety of health comnditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(treg)
</code></pre>


<h3>Format</h3>

<p> Note that there are three distinct objects
included in the data set: <code>treg</code>, <code>tmat</code>, and <code>rip</code>.
</p>

<dl>
<dt><code>treg</code></dt><dd><p>A numerical data matrix with 538 rows and 255
columns. Each column represents a single cell from one of 61
samples that were assayed by (mixed-omics) single cell
sequencing. Each row represents one of the features that was
measured in the assay. Of these, 51 are antibodies that were
tagged with an RNA barcode to identify them; their names all end
with the string <code>pAbO</code>. The remaining 487 features are mRNA
measurements, named by their official gene symbol at the time the
experiment was performed. Each column represents a different
single cell. This matrix is a subset of a more complete data set
of T regulatory cells (Tregs). It was produced using the
<code>downsample</code> function from the <code><a href="Mercator.html#topic+Mercator">Mercator</a></code>
package, which was in turn inspired by a similar routine used in
the SPADE algorithm by Peng Qiu. A key point of the algorithm is
to make sampling less likely from the densest part of the
distribution in order to preserve rare cell types in the
population.</p>
</dd>
<dt><code>tmat</code></dt><dd><p>A distance matrix, stored as a
<code><a href="stats.html#topic+dist">dist</a></code> object, produced using Pearson correlation as a
measure of distance between sigle-cell vectors in the <code>treg</code>
data set.</p>
</dd>
<dt><code>rip</code></dt><dd><p>This object  is a &quot;Rips diagram&quot;. It was produced
by running the the <code><a href="TDA.html#topic+ripsDiag">ripsDiag</a></code> function from the
<code><a href="TDA.html#topic+TDA">TDA</a></code> R package on the <code>treg</code> subset of single cells.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kevin R. Coombes <a href="mailto:krc@silicovore.com">krc@silicovore.com</a>,
Jake Reed <a href="mailto:hreed@augusta.edu">hreed@augusta.edu</a></p>


<h3>Source</h3>

<p>Data were kindly provided by Dr. Klaus Ley, director of the Georgia
Immunolgy Center at Augusta University. Analysis to perform cell
typing with Seurat and isolate the subset of 769 T regulatory cells
found in <code>dset</code> was performed by Jake Reed, as was the
downsampling to select the random subset of 255 cells in the
<code>treg</code> subset and use them for topolgical data analysis to
compute the <code>rip</code> object.
</p>


<h3>References</h3>

<p>Qiu P, Simonds EF, Bendall SC, Gibbs KD Jr, Bruggner RV, Linderman MD,
Sachs K, Nolan GP, Plevritis SK. Extracting a cellular hierarchy from
high-dimensional cytometry data with SPADE. Nat Biotechnol. 2011 Oct
2;29(10):886-91. doi: 10.1038/nbt.1991.
</p>

<hr>
<h2 id='voids'>
3D Scatter Plots of Cycles and Features
</h2><span id='topic+voids'></span><span id='topic+voidPlot'></span><span id='topic+voidFeature'></span>

<h3>Description</h3>

<p>Voids are two-dimensional cycles and should be thought of as the
topological equivalents of (the surface) of a sphere. These are
typically displayed as a point cloud in space, with wire-frame edges
outlining the component (triangular) simplices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>voidPlot(cycle, view, feature = NULL, radius = 0.01, ...)
voidFeature(feature, view, radius = 0.01, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="voids_+3A_cycle">cycle</code></td>
<td>
<p>An object of the <code><a href="#topic+Cycle">Cycle</a></code> class.</p>
</td></tr>
<tr><td><code id="voids_+3A_view">view</code></td>
<td>
<p>A matrix (with three columns, x, y, and, z) specifying the
coordinates to be used to display the data.</p>
</td></tr>
<tr><td><code id="voids_+3A_feature">feature</code></td>
<td>
<p>An object of the <code><a href="#topic+Feature">Feature</a></code> class.</p>
</td></tr>
<tr><td><code id="voids_+3A_radius">radius</code></td>
<td>
<p>The radius of spheres used to display the points in
three dimensions.</p>
</td></tr>
<tr><td><code id="voids_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 3D displays are implemented using the <code><a href="rgl.html#topic+rgl">rgl</a></code>
package. The <code>voidPlot</code> function adds a wire-frame two-cycle
to the 3d scatter plot of the underlying data. If a feature is
present, then the point are colored by the expression lecvel of that
feature. If not present, they are simply colored gray. However, you can
always add the expression levels of a feature to an existing plot
using the <code>voidFeature</code> function.
</p>
<p>In an interactive session, everything is displayed in an OpenGL window,
where the graph can be manipulated with a mouse. Programmatically, you
can use the <code>rgl::rglwidget</code> function to write out the code for
an interactive HTML display, and you can save the widget to a file
using the <code>htmlwidgets::saveWidget</code> function.
</p>


<h3>Value</h3>

<p>Both <code>voidPlot</code> and <code>voidFeature</code> invisibly return their
first argument.
</p>


<h3>Author(s)</h3>

<p>Kevin R. Coombes &lt;krc@silicovore.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(CLL)
featRai &lt;- Feature(clinical[,"CatRAI"], "Rai Stage", c("green", "magenta"), c("High", "Low"))
vd &lt;- Cycle(ripdiag, 2, 95, "blue")
mds &lt;- cmdscale(daisydist, k = 3)
voidPlot(vd, mds)
voidFeature(featRai, mds, radius = 0.011)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
