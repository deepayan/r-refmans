<!DOCTYPE html><html><head><title>Help for package treenomial</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treenomial}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alignPoly'><p>Align various types of coefficient matrices</p></a></li>
<li><a href='#allTrees'><p>Calculate all full unordered m-ary trees up to n tips</p></a></li>
<li><a href='#plotExtremeTrees'><p>Plot the min/max distance trees from a target tree</p></a></li>
<li><a href='#polyDist'><p>Calculates the distance between coefficient matrices</p></a></li>
<li><a href='#polyToDistMat'><p>Calculates the distance matrix from a list coefficient matrices</p></a></li>
<li><a href='#treeDist'><p>Calculates the distance between trees</p></a></li>
<li><a href='#treeJuliaSet'><p>Plots a Julia Set for a tree</p></a></li>
<li><a href='#treeToDistMat'><p>Calculates the distance matrix from a list of phylo objects</p></a></li>
<li><a href='#treeToPoly'><p>Convert trees to coefficient matrices</p></a></li>
<li><a href='#wedge'><p>Performs the wedge operation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Comparison of Trees using a Tree Defining Polynomial</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Gould &lt;mgould@sfu.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functionality for creation and comparison of polynomials that uniquely
  describe trees as introduced in Liu (2019, &lt;<a href="https://doi.org/10.48550/arXiv.1904.03332">doi:10.48550/arXiv.1904.03332</a>&gt;). The core method
  converts rooted unlabeled phylo objects from 'ape' to the tree defining polynomials 
  described with coefficient matrices. Additionally, a conversion for rooted binary trees 
  with binary trait labels is also provided. Once the polynomials of trees are calculated 
  there are functions to calculate distances, distance matrices and plot different distance 
  trees from a target tree. Manipulation and conversion to the tree defining polynomials is 
  implemented in C++ with 'Rcpp' and 'RcppArmadillo'. Furthermore, parallel programming with 
  'RcppThread' is used to improve performance converting to polynomials and calculating distances. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gouldmatt/treenomial">https://github.com/gouldmatt/treenomial</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), ape, methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread (&ge; 2.1.3)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-05 03:50:15 UTC; mgould</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Gould [aut, cre],
  Pengyu Liu [ctb],
  Caroline Colijn [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-06 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alignPoly'>Align various types of coefficient matrices</h2><span id='topic+alignPoly'></span>

<h3>Description</h3>

<p>Align various types of coefficient matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignPoly(coefficientMatrices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignPoly_+3A_coefficientmatrices">coefficientMatrices</code></td>
<td>
<p>a list of coefficient matrices of various sizes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alignment depends on the type of coefficient matrix:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>the smaller matrices columns are prepended with zero columns to align with the max number of columns and the rows are appended with zero rows to match the max number of rows</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>the smaller vectors are appended with zeroes to match the max length vector</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>the smaller matrices are appended with zeroes to match the max number of rows and columns</p>
</dd>
</dl>



<h3>Value</h3>

<p>the aligned list of coefficient matrices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)
differentSizeTrees &lt;- c(rtree(2), rmtree(10,10))
coeffs &lt;- treeToPoly(differentSizeTrees, numThreads = 0)
alignedCoeffs &lt;- alignPoly(coeffs)


</code></pre>

<hr>
<h2 id='allTrees'>Calculate all full unordered m-ary trees up to n tips</h2><span id='topic+allTrees'></span>

<h3>Description</h3>

<p>Return normal coefficient matrices, substituted y coefficient vectors, or phylo objects for all possible unordered full m-ary trees up to n tips.
For binary trees (m = 2), the number of trees at each number of tips follows the <a href="https://oeis.org/A001190">Wedderburn-Etherington numbers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allTrees(n, m = 2, type = c("default", "yEvaluated", "phylo"), y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allTrees_+3A_n">n</code></td>
<td>
<p>max number of tips</p>
</td></tr>
<tr><td><code id="allTrees_+3A_m">m</code></td>
<td>
<p>max number of children for each node</p>
</td></tr>
<tr><td><code id="allTrees_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distiguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distiguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;phylo&rdquo;</dt><dd><p>phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="allTrees_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lists containing all the trees in <strong>type</strong> format for each number of tips
</p>


<h3>Note</h3>

<p>only m = 2 is currently supported
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(treenomial)
library(ape)

# generate coefficient matrices describing the polynomials of all possible
# unordered full binary trees up to 10 tips

allBinTenRealCoeff &lt;- allTrees(10, type = "phylo")

# number of trees at each number of tips follows Wedderburn-Etherington numbers
lengths(allBinTenRealCoeff)

# phylo type example, plot all 6 tip unordered full binary trees

# backup par options
oldpar &lt;- par(no.readonly =TRUE)

allBinSixPhylo &lt;- allTrees(6, type = "phylo")[[6]]
par(mfrow=c(1,6))
plots &lt;- lapply(allBinSixPhylo, function(t){
  plot.phylo(ladderize(t), direction = "downwards", show.tip.label = FALSE)
})

# restore par options
par(oldpar)

</code></pre>

<hr>
<h2 id='plotExtremeTrees'>Plot the min/max distance trees from a target tree</h2><span id='topic+plotExtremeTrees'></span>

<h3>Description</h3>

<p>Plot the min/max distance trees from a target tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotExtremeTrees(
  target,
  trees,
  n,
  comparison = "min",
  method = c("fraction", "logDiff", "wLogDiff", "pa", "ap"),
  type = c("default", "yEvaluated", "tipLabel"),
  y,
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotExtremeTrees_+3A_target">target</code></td>
<td>
<p>the phylo object of the tree to calculate the distances to</p>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_trees">trees</code></td>
<td>
<p>a list of phylo objects to compare with the <strong>target</strong></p>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_n">n</code></td>
<td>
<p>the number of trees to find and plot</p>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_comparison">comparison</code></td>
<td>
<p>whether to find the &ldquo;min&rdquo; or the &ldquo;max&rdquo; distance trees from the <strong>target</strong></p>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_method">method</code></td>
<td>
<p>method to use when calculating coefficient distances:
</p>

<dl>
<dt>&ldquo;fraction&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(abs(A-B)/(A+B)), excluding elements where both A and B are zero</p>
</dd>
<dt>&ldquo;logDiff&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(log(1+abs(A-B))</p>
</dd>
<dt>&ldquo;wLogDiff&rdquo;</dt><dd><p>performs the &ldquo;logDiff&rdquo; method with weights on the rows</p>
</dd>
<dt>&ldquo;pa&rdquo;</dt><dd><p>total pairs where the coefficient is present in one matrix and absent in the other (presence-absence)</p>
</dd>
<dt>&ldquo;ap&rdquo;</dt><dd><p>opposite comparison of pa (absence-presence)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distinguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distinguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>complex coefficient polynomial that utilize binary trait tip labels on the phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
<tr><td><code id="plotExtremeTrees_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of lists containing the <strong>n</strong> min/max distance trees and their distances to <strong>target</strong>
</p>


<h3>Note</h3>


<ul>
<li><p> the substituted y coefficient vector only supports the &ldquo;logDiff&rdquo; method and the &ldquo;fraction&rdquo; method
</p>
</li>
<li> <p>&ldquo;pa&rdquo; and &ldquo;ap&rdquo; force symmetry in the output distance matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)
trees &lt;- c(rmtree(1000, 50), rmtree(10, 9))
target &lt;- rtree(50)
minTrees &lt;- plotExtremeTrees(target, trees, 2, comparison = "min", numThreads = 0)
</code></pre>

<hr>
<h2 id='polyDist'>Calculates the distance between coefficient matrices</h2><span id='topic+polyDist'></span>

<h3>Description</h3>

<p>Calculates the distance between two coefficient matrices or a coefficient matrix and a list of coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyDist(
  x,
  Y,
  method = c("fraction", "logDiff", "wLogDiff", "pa", "ap"),
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyDist_+3A_x">x</code></td>
<td>
<p>single coefficient matrix to find distances to</p>
</td></tr>
<tr><td><code id="polyDist_+3A_y">Y</code></td>
<td>
<p>a list of coefficient matrices</p>
</td></tr>
<tr><td><code id="polyDist_+3A_method">method</code></td>
<td>
<p>method to use when calculating coefficient distances:
</p>

<dl>
<dt>&ldquo;fraction&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(abs(A-B)/(A+B)), excluding elements where both A and B are zero</p>
</dd>
<dt>&ldquo;logDiff&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(log(1+abs(A-B))</p>
</dd>
<dt>&ldquo;wLogDiff&rdquo;</dt><dd><p>performs the &ldquo;logDiff&rdquo; method with weights on the rows</p>
</dd>
<dt>&ldquo;pa&rdquo;</dt><dd><p>total pairs where the coefficient is present in one matrix and absent in the other (presence-absence)</p>
</dd>
<dt>&ldquo;ap&rdquo;</dt><dd><p>opposite comparison of pa (absence-presence)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="polyDist_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distances
</p>


<h3>Note</h3>


<ul>
<li><p> the substituted y coefficient vector only supports the &ldquo;logDiff&rdquo; method and the &ldquo;fraction&rdquo; method
</p>
</li>
<li> <p>&ldquo;pa&rdquo; and &ldquo;ap&rdquo; force symmetry in the output distance matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)

# distance between coefficient matrices of one 10 tip tree
# and 100 trees with 30 tips using
# create the coefficient matrices
tenTipTree &lt;- rtree(10)
tenTipTreeCoeff &lt;- treeToPoly(tenTipTree, numThreads = 0)

thirtyTipList &lt;- rmtree(100, 30)
thirtyTipCoeffs &lt;- treeToPoly(thirtyTipList, numThreads = 0)

# find the distance
polyDist(tenTipTreeCoeff, thirtyTipCoeffs, numThreads = 0)
</code></pre>

<hr>
<h2 id='polyToDistMat'>Calculates the distance matrix from a list coefficient matrices</h2><span id='topic+polyToDistMat'></span>

<h3>Description</h3>

<p>Calculates the distance matrix from a list coefficient matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyToDistMat(
  coefficientMatrices,
  method = c("fraction", "logDiff", "wLogDiff", "pa", "ap"),
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyToDistMat_+3A_coefficientmatrices">coefficientMatrices</code></td>
<td>
<p>list of coefficient matrices</p>
</td></tr>
<tr><td><code id="polyToDistMat_+3A_method">method</code></td>
<td>
<p>method to use when calculating coefficient distances:
</p>

<dl>
<dt>&ldquo;fraction&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(abs(A-B)/(A+B)), excluding elements where both A and B are zero</p>
</dd>
<dt>&ldquo;logDiff&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(log(1+abs(A-B))</p>
</dd>
<dt>&ldquo;wLogDiff&rdquo;</dt><dd><p>performs the &ldquo;logDiff&rdquo; method with weights on the rows</p>
</dd>
<dt>&ldquo;pa&rdquo;</dt><dd><p>total pairs where the coefficient is present in one matrix and absent in the other (presence-absence)</p>
</dd>
<dt>&ldquo;ap&rdquo;</dt><dd><p>opposite comparison of pa (absence-presence)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="polyToDistMat_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>distance matrix calculated from argument coefficient matrices
</p>


<h3>Note</h3>


<ul>
<li><p> the substituted y coefficient vector only supports the &ldquo;logDiff&rdquo; method and the &ldquo;fraction&rdquo; method
</p>
</li>
<li> <p>&ldquo;pa&rdquo; and &ldquo;ap&rdquo; force symmetry in the output distance matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)

# coefficient matrices for ten trees of 20 tips
coeffs &lt;- treeToPoly(rmtree(10, 20), numThreads = 0)

# distance matrix from the list of coefficient matrices
d &lt;- polyToDistMat(coeffs, method = "logDiff", numThreads = 0)

# using the absence-presence method
d &lt;- polyToDistMat(coeffs, method = "ap", numThreads = 0)
</code></pre>

<hr>
<h2 id='treeDist'>Calculates the distance between trees</h2><span id='topic+treeDist'></span>

<h3>Description</h3>

<p>Calculates the distance between two trees or a tree and a list of trees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeDist(
  x,
  Y,
  type = c("default", "yEvaluated", "tipLabel"),
  method = c("fraction", "logDiff", "wLogDiff", "pa", "ap"),
  y,
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeDist_+3A_x">x</code></td>
<td>
<p>single phylo object</p>
</td></tr>
<tr><td><code id="treeDist_+3A_y">Y</code></td>
<td>
<p>a list of phylo objects</p>
</td></tr>
<tr><td><code id="treeDist_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distinguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distinguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>complex coefficient polynomial that utilize binary trait tip labels on the phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="treeDist_+3A_method">method</code></td>
<td>
<p>method to use when calculating coefficient distances:
</p>

<dl>
<dt>&ldquo;fraction&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(abs(A-B)/(A+B)), excluding elements where both A and B are zero</p>
</dd>
<dt>&ldquo;logDiff&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(log(1+abs(A-B))</p>
</dd>
<dt>&ldquo;wLogDiff&rdquo;</dt><dd><p>performs the &ldquo;logDiff&rdquo; method with weights on the rows</p>
</dd>
<dt>&ldquo;pa&rdquo;</dt><dd><p>total pairs where the coefficient is present in one matrix and absent in the other (presence-absence)</p>
</dd>
<dt>&ldquo;ap&rdquo;</dt><dd><p>opposite comparison of pa (absence-presence)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="treeDist_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
<tr><td><code id="treeDist_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of distances
</p>


<h3>Note</h3>


<ul>
<li><p> the substituted y coefficient vector only supports the &ldquo;logDiff&rdquo; method and the &ldquo;fraction&rdquo; method
</p>
</li>
<li> <p>&ldquo;pa&rdquo; and &ldquo;ap&rdquo; force symmetry in the output distance matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)

# distance between one 10 tip tree and 100 trees with 30 tips

# generate the trees
tenTipTree &lt;- rtree(10)
thirtyTipList &lt;- rmtree(100, 30)

# find the distance
treeDist(tenTipTree, thirtyTipList, numThreads = 0)
</code></pre>

<hr>
<h2 id='treeJuliaSet'>Plots a Julia Set for a tree</h2><span id='topic+treeJuliaSet'></span>

<h3>Description</h3>

<p>Finds the Julia Set for the y evaluated polynomial of a tree and plots in a square image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeJuliaSet(
  tree,
  pixelLength = 700,
  center = 0,
  maxZ = 2,
  maxIter = 100,
  col = c("white", colorRampPalette(c("dodgerblue4", "lightblue"))(98), "black"),
  y
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeJuliaSet_+3A_tree">tree</code></td>
<td>
<p>phylo object</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_pixellength">pixelLength</code></td>
<td>
<p>number of pixels on one side of the image</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_center">center</code></td>
<td>
<p>complex number giving the center of the image on the complex plane</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_maxz">maxZ</code></td>
<td>
<p>the max value for the real and imaginary axis</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_maxiter">maxIter</code></td>
<td>
<p>maximum count for iterations</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_col">col</code></td>
<td>
<p>colours to be used for the image</p>
</td></tr>
<tr><td><code id="treeJuliaSet_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)
treeJuliaSet(stree(5,type = "right"), y = 1+1i)

</code></pre>

<hr>
<h2 id='treeToDistMat'>Calculates the distance matrix from a list of phylo objects</h2><span id='topic+treeToDistMat'></span>

<h3>Description</h3>

<p>Calculates the distance matrix from a list of phylo objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeToDistMat(
  trees,
  method = c("fraction", "logDiff", "wLogDiff", "pa", "ap"),
  type = c("default", "yEvaluated", "tipLabel"),
  y,
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeToDistMat_+3A_trees">trees</code></td>
<td>
<p>a single phylo object or a list of phylo objects</p>
</td></tr>
<tr><td><code id="treeToDistMat_+3A_method">method</code></td>
<td>
<p>method to use when calculating coefficient distances:
</p>

<dl>
<dt>&ldquo;fraction&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(abs(A-B)/(A+B)), excluding elements where both A and B are zero</p>
</dd>
<dt>&ldquo;logDiff&rdquo;</dt><dd><p>for two coefficient matrices A and B returns sum(log(1+abs(A-B))</p>
</dd>
<dt>&ldquo;wLogDiff&rdquo;</dt><dd><p>performs the &ldquo;logDiff&rdquo; method with weights on the rows</p>
</dd>
<dt>&ldquo;pa&rdquo;</dt><dd><p>total pairs where the coefficient is present in one matrix and absent in the other (presence-absence)</p>
</dd>
<dt>&ldquo;ap&rdquo;</dt><dd><p>opposite comparison of pa (absence-presence)</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="treeToDistMat_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distinguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distinguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>complex coefficient polynomial that utilize binary trait tip labels on the phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="treeToDistMat_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
<tr><td><code id="treeToDistMat_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a distance matrix
</p>


<h3>Note</h3>


<ul>
<li><p> the substituted y coefficient vector only supports the &ldquo;logDiff&rdquo; method and the &ldquo;fraction&rdquo; method
</p>
</li>
<li> <p>&ldquo;pa&rdquo; and &ldquo;ap&rdquo; force symmetry in the output distance matrix
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)
# distance matrix for 10 trees of 30 tips
treeToDistMat(rmtree(10, 30), method = "wLogDiff", numThreads = 0)
</code></pre>

<hr>
<h2 id='treeToPoly'>Convert trees to coefficient matrices</h2><span id='topic+treeToPoly'></span>

<h3>Description</h3>

<p>Converts rooted full binary trees to tree distinguishing polynomials described with coefficient matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treeToPoly(
  trees,
  type = c("default", "yEvaluated", "tipLabel"),
  y,
  varLabels = FALSE,
  numThreads = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treeToPoly_+3A_trees">trees</code></td>
<td>
<p>a single phylo object or a list of phylo objects</p>
</td></tr>
<tr><td><code id="treeToPoly_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distinguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distinguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>complex coefficient polynomial that utilize binary trait tip labels on the phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="treeToPoly_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
<tr><td><code id="treeToPoly_+3A_varlabels">varLabels</code></td>
<td>
<p>boolean for whether to add row and column names corresponding to the variables in the polynomial</p>
</td></tr>
<tr><td><code id="treeToPoly_+3A_numthreads">numThreads</code></td>
<td>
<p>number of threads to be used, the default (-1) will use the number of cores in the machine and numThreads = 0 will only use the main thread</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the resulting coefficient matrix or matrices of the form:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>a real matrix where the ith row, jth column represents the x^(j-1)*y^(i-1) coefficient</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>a vector where the kth column represents the x^(k-1) coefficient</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>given trees with two unique tip labels &ldquo;a&rdquo;, &ldquo;b&rdquo; a complex matrix where the ith row, jth column represents the a^(i-1)*b^(j-1) coefficient</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>library(treenomial)
library(ape)

# generate a tree
tree &lt;- rtree(n = 30, rooted = TRUE)

# a real coefficient matrix
treeToPoly(tree, varLabels = TRUE, numThreads = 0)

# complex coefficient vector for the tree
treeToPoly(tree, type = "yEvaluated", y = 1+1i, varLabels = TRUE, numThreads = 0)

# for a list of trees
treeToPoly(rmtree(4, 20), varLabels = TRUE, numThreads = 0)

</code></pre>

<hr>
<h2 id='wedge'>Performs the wedge operation</h2><span id='topic+wedge'></span>

<h3>Description</h3>

<p>Calculates the result from the wedge operation on two real coefficient
matrices, two y evaluated polynomial coefficient vectors or two phylo objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wedge(A, B, type = c("default", "yEvaluated", "phylo"), y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wedge_+3A_a">A</code>, <code id="wedge_+3A_b">B</code></td>
<td>
<p>two real coefficient matrices, complex coefficient vectors or phylo objects</p>
</td></tr>
<tr><td><code id="wedge_+3A_type">type</code></td>
<td>
<p>one of:
</p>

<dl>
<dt>&ldquo;real&rdquo;</dt><dd><p>tree distinguishing polynomials in two variables x (columns) and y (rows)</p>
</dd>
<dt>&ldquo;yEvaluated&rdquo;</dt><dd><p>tree distinguishing polynomials with y evaluated at a specified argument</p>
</dd>
<dt>&ldquo;tipLabel&rdquo;</dt><dd><p>complex coefficient polynomial that utilize binary trait tip labels on the phylo objects</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="wedge_+3A_y">y</code></td>
<td>
<p>the y value to evaluate the polynomial at when type is &ldquo;yEvaluated&rdquo;, ignored otherwise</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the wedge result in the same form as the arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(treenomial)
library(ape)

# wedge two real coefficient matrices

leaf &lt;- matrix(c(0,1), nrow = 1, ncol = 2)
wedge(leaf, leaf)

# wedge two complex coefficient vectors

leaf &lt;- as.complex(c(0,1))
wedge(leaf, leaf, "yEvaluated",5)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
