<!DOCTYPE html><html><head><title>Help for package admiral</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {admiral}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admiral-package'><p>admiral: ADaM in R Asset Library</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#admiral_adlb'><p>Lab Analysis Dataset</p></a></li>
<li><a href='#admiral_adsl'><p>Subject Level Analysis Dataset</p></a></li>
<li><a href='#assert_parameters_argument'><p>Asserts <code>parameters</code> Argument and Converts to List of Expressions</p></a></li>
<li><a href='#atoxgr_criteria_ctcv4'><p>Metadata Holding Grading Criteria for NCI-CTCAEv4</p></a></li>
<li><a href='#atoxgr_criteria_ctcv5'><p>Metadata Holding Grading Criteria for NCI-CTCAEv5</p></a></li>
<li><a href='#atoxgr_criteria_daids'><p>Metadata Holding Grading Criteria for DAIDs</p></a></li>
<li><a href='#basket_select'><p>Create a <code>basket_select</code> object</p></a></li>
<li><a href='#call_derivation'><p>Call a Single Derivation Multiple Times</p></a></li>
<li><a href='#call_user_fun'><p>Calls a Function Provided by the User</p></a></li>
<li><a href='#censor_source'><p>Create a <code>censor_source</code> Object</p></a></li>
<li><a href='#chr2vars'><p>Turn a Character Vector into a List of Expressions</p></a></li>
<li><a href='#compute_age_years'><p>Compute Age in Years</p></a></li>
<li><a href='#compute_bmi'><p>Compute Body Mass Index (BMI)</p></a></li>
<li><a href='#compute_bsa'><p>Compute Body Surface Area (BSA)</p></a></li>
<li><a href='#compute_dtf'><p>Derive the Date Imputation Flag</p></a></li>
<li><a href='#compute_duration'><p>Compute Duration</p></a></li>
<li><a href='#compute_egfr'><p>Compute Estimated Glomerular Filtration Rate (eGFR) for Kidney Function</p></a></li>
<li><a href='#compute_framingham'><p>Compute Framingham Heart Study Cardiovascular Disease 10-Year Risk Score</p></a></li>
<li><a href='#compute_map'><p>Compute Mean Arterial Pressure (MAP)</p></a></li>
<li><a href='#compute_qtc'><p>Compute Corrected QT</p></a></li>
<li><a href='#compute_qual_imputation'><p>Function to Impute Values When Qualifier Exists in Character Result</p></a></li>
<li><a href='#compute_qual_imputation_dec'><p>Compute Factor for Value Imputations When Character Value Contains &lt; or &gt;</p></a></li>
<li><a href='#compute_rr'><p>Compute RR Interval From Heart Rate</p></a></li>
<li><a href='#compute_scale'><p>Compute Scale Parameters</p></a></li>
<li><a href='#compute_tmf'><p>Derive the Time Imputation Flag</p></a></li>
<li><a href='#consolidate_metadata'><p>Consolidate Multiple Meta Datasets Into a Single One</p></a></li>
<li><a href='#convert_blanks_to_na'><p>Convert Blank Strings Into NAs</p></a></li>
<li><a href='#convert_date_to_dtm'><p>Convert a Date into a Datetime Object</p></a></li>
<li><a href='#convert_dtc_to_dt'><p>Convert a Date Character Vector into a Date Object</p></a></li>
<li><a href='#convert_dtc_to_dtm'><p>Convert a Date Character Vector into a Datetime Object</p></a></li>
<li><a href='#convert_na_to_blanks'><p>Convert NAs Into Blank Strings</p></a></li>
<li><a href='#count_vals'><p>Count Number of Observations Where a Variable Equals a Value</p></a></li>
<li><a href='#create_period_dataset'><p>Create a Reference Dataset for Subperiods, Periods, or Phases</p></a></li>
<li><a href='#create_query_data'><p>Creates a queries dataset as input dataset to the <code>dataset_queries</code> argument in</p>
<code>derive_vars_query()</code></a></li>
<li><a href='#create_single_dose_dataset'><p>Create dataset of single doses</p></a></li>
<li><a href='#date_source'><p>Create a <code>date_source</code> object</p></a></li>
<li><a href='#death_event'><p>Pre-Defined Time-to-Event Source Objects</p></a></li>
<li><a href='#default_qtc_paramcd'><p>Get Default Parameter Code for Corrected QT</p></a></li>
<li><a href='#derivation_slice'><p>Create a <code>derivation_slice</code> Object</p></a></li>
<li><a href='#derive_basetype_records'><p>Derive Basetype Variable</p></a></li>
<li><a href='#derive_expected_records'><p>Derive Expected Records</p></a></li>
<li><a href='#derive_extreme_event'><p>Add the Worst or Best Observation for Each By Group as New Records</p></a></li>
<li><a href='#derive_extreme_records'><p>Add the First or Last Observation for Each By Group as New Records</p></a></li>
<li><a href='#derive_locf_records'><p>Derive LOCF (Last Observation Carried Forward) Records</p></a></li>
<li><a href='#derive_param_bmi'><p>Adds a Parameter for BMI</p></a></li>
<li><a href='#derive_param_bsa'><p>Adds a Parameter for BSA (Body Surface Area) Using the Specified Method</p></a></li>
<li><a href='#derive_param_computed'><p>Adds a Parameter Computed from the Analysis Value of Other Parameters</p></a></li>
<li><a href='#derive_param_doseint'><p>Adds a Parameter for Dose Intensity</p></a></li>
<li><a href='#derive_param_exist_flag'><p>Add an Existence Flag Parameter</p></a></li>
<li><a href='#derive_param_exposure'><p>Add an Aggregated Parameter and Derive the Associated Start and End Dates</p></a></li>
<li><a href='#derive_param_extreme_record'><p>Adds a Parameter Based on First or Last Record from Multiple Sources</p></a></li>
<li><a href='#derive_param_framingham'><p>Adds a Parameter for Framingham Heart Study Cardiovascular Disease</p>
10-Year Risk Score</a></li>
<li><a href='#derive_param_map'><p>Adds a Parameter for Mean Arterial Pressure</p></a></li>
<li><a href='#derive_param_qtc'><p>Adds a Parameter for Corrected QT (an ECG measurement)</p></a></li>
<li><a href='#derive_param_rr'><p>Adds a Parameter for Derived RR (an ECG measurement)</p></a></li>
<li><a href='#derive_param_tte'><p>Derive a Time-to-Event Parameter</p></a></li>
<li><a href='#derive_param_wbc_abs'><p>Add a parameter for lab differentials converted to absolute values</p></a></li>
<li><a href='#derive_summary_records'><p>Add New Records Within By Groups Using Aggregation Functions</p></a></li>
<li><a href='#derive_var_age_years'><p>Derive Age in Years</p></a></li>
<li><a href='#derive_var_analysis_ratio'><p>Derive Ratio Variable</p></a></li>
<li><a href='#derive_var_anrind'><p>Derive Reference Range Indicator</p></a></li>
<li><a href='#derive_var_atoxgr'><p>Derive Lab High toxicity Grade 0 - 4 and Low Toxicity Grades 0 - (-4)</p></a></li>
<li><a href='#derive_var_atoxgr_dir'><p>Derive Lab Toxicity Grade 0 - 4</p></a></li>
<li><a href='#derive_var_base'><p>Derive Baseline Variables</p></a></li>
<li><a href='#derive_var_chg'><p>Derive Change from Baseline</p></a></li>
<li><a href='#derive_var_dthcaus'><p>Derive Death Cause</p></a></li>
<li><a href='#derive_var_extreme_dt'><p>Derive First or Last Date from Multiple Sources</p></a></li>
<li><a href='#derive_var_extreme_dtm'><p>Derive First or Last Datetime from Multiple Sources</p></a></li>
<li><a href='#derive_var_extreme_flag'><p>Add a Variable Flagging the First or Last Observation Within Each By Group</p></a></li>
<li><a href='#derive_var_joined_exist_flag'><p>Derives a Flag Based on an Existing Flag</p></a></li>
<li><a href='#derive_var_merged_ef_msrc'><p>Merge an Existence Flag From Multiple Sources</p></a></li>
<li><a href='#derive_var_merged_exist_flag'><p>Merge an Existence Flag</p></a></li>
<li><a href='#derive_var_merged_summary'><p>Merge Summary Variables</p></a></li>
<li><a href='#derive_var_obs_number'><p>Adds a Variable Numbering the Observations Within Each By Group</p></a></li>
<li><a href='#derive_var_ontrtfl'><p>Derive On-Treatment Flag Variable</p></a></li>
<li><a href='#derive_var_pchg'><p>Derive Percent Change from Baseline</p></a></li>
<li><a href='#derive_var_relative_flag'><p>Flag Observations Before or After a Condition is Fulfilled</p></a></li>
<li><a href='#derive_var_shift'><p>Derive Shift</p></a></li>
<li><a href='#derive_var_trtdurd'><p>Derive Total Treatment Duration (Days)</p></a></li>
<li><a href='#derive_var_trtemfl'><p>Derive Treatment-emergent Flag</p></a></li>
<li><a href='#derive_vars_aage'><p>Derive Analysis Age</p></a></li>
<li><a href='#derive_vars_atc'><p>Derive ATC Class Variables</p></a></li>
<li><a href='#derive_vars_computed'><p>Adds Variable(s) Computed from the Analysis Value of one or more Parameters</p></a></li>
<li><a href='#derive_vars_dt'><p>Derive/Impute a Date from a Date Character Vector</p></a></li>
<li><a href='#derive_vars_dtm'><p>Derive/Impute a Datetime from a Date Character Vector</p></a></li>
<li><a href='#derive_vars_dtm_to_dt'><p>Derive Date Variables from Datetime Variables</p></a></li>
<li><a href='#derive_vars_dtm_to_tm'><p>Derive Time Variables from Datetime Variables</p></a></li>
<li><a href='#derive_vars_duration'><p>Derive Duration</p></a></li>
<li><a href='#derive_vars_dy'><p>Derive Relative Day Variables</p></a></li>
<li><a href='#derive_vars_extreme_event'><p>Add the Worst or Best Observation for Each By Group as New Variables</p></a></li>
<li><a href='#derive_vars_joined'><p>Add Variables from an Additional Dataset Based on Conditions from Both</p>
Datasets</a></li>
<li><a href='#derive_vars_merged'><p>Add New Variable(s) to the Input Dataset Based on Variables from Another</p>
Dataset</a></li>
<li><a href='#derive_vars_merged_lookup'><p>Merge Lookup Table with Source Dataset</p></a></li>
<li><a href='#derive_vars_period'><p>Add Subperiod, Period, or Phase Variables to ADSL</p></a></li>
<li><a href='#derive_vars_query'><p>Derive Query Variables</p></a></li>
<li><a href='#derive_vars_transposed'><p>Derive Variables by Transposing and Merging a Second Dataset</p></a></li>
<li><a href='#desc'><p>dplyr desc</p></a></li>
<li><a href='#dose_freq_lookup'><p>Pre-Defined Dose Frequencies</p></a></li>
<li><a href='#dt_level'><p>Create a <code>dt_level</code> object</p></a></li>
<li><a href='#dthcaus_source'><p>Create a <code>dthcaus_source</code> Object</p></a></li>
<li><a href='#dtm_level'><p>Create a <code>dtm_level</code> object</p></a></li>
<li><a href='#event'><p>Create a <code>event</code> Object</p></a></li>
<li><a href='#event_joined'><p>Create a <code>event_joined</code> Object</p></a></li>
<li><a href='#event_source'><p>Create an <code>event_source</code> Object</p></a></li>
<li><a href='#ex_single'><p>Single Dose Exposure Dataset</p></a></li>
<li><a href='#example_qs'><p>Example <code>QS</code> Dataset</p></a></li>
<li><a href='#exprs'><p>rlang exprs</p></a></li>
<li><a href='#extract_duplicate_records'><p>Extract Duplicate Records</p></a></li>
<li><a href='#extract_unit'><p>Extract Unit From Parameter Description</p></a></li>
<li><a href='#filter_exist'><p>Returns records that fit into existing by groups in a filtered source dataset</p></a></li>
<li><a href='#filter_extreme'><p>Filter the First or Last Observation for Each By Group</p></a></li>
<li><a href='#filter_joined'><p>Filter Observations Taking Other Observations into Account</p></a></li>
<li><a href='#filter_not_exist'><p>Returns records that don't fit into existing by groups in a filtered source dataset</p></a></li>
<li><a href='#filter_relative'><p>Filter the Observations Before or After a Condition is Fulfilled</p></a></li>
<li><a href='#flag_event'><p>Create a <code>flag_event</code> Object</p></a></li>
<li><a href='#format.basket_select'><p>Returns a Character Representation of a <code>basket_select()</code> Object</p></a></li>
<li><a href='#get_admiral_option'><p>Get the Value of an Admiral Option</p></a></li>
<li><a href='#get_duplicates_dataset'><p>Get Duplicate Records that Led to a Prior Error</p></a></li>
<li><a href='#get_hori_data'><p>Creating Temporary Parameters and <code style="white-space: pre;">&#8288;&lt;variable&gt;.&lt;parameter&gt;&#8288;</code> Variables</p></a></li>
<li><a href='#get_imputation_target_date'><p>Get Date Imputation Targets</p></a></li>
<li><a href='#get_imputation_target_time'><p>Get Time Imputation Targets</p></a></li>
<li><a href='#get_joined_data'><p>Join Data for &quot;joined&quot; functions</p></a></li>
<li><a href='#get_many_to_one_dataset'><p>Get Many to One Values that Led to a Prior Error</p></a></li>
<li><a href='#get_not_mapped'><p>Get list of records not mapped from the lookup table.</p></a></li>
<li><a href='#get_one_to_many_dataset'><p>Get One to Many Values that Led to a Prior Error</p></a></li>
<li><a href='#get_partialdatetime'><p>Parse DTC variable and Determine Components</p></a></li>
<li><a href='#get_summary_records'><p>Create Summary Records</p></a></li>
<li><a href='#get_terms_from_db'><p>Get Terms from the Queries Database</p></a></li>
<li><a href='#impute_dtc_dt'><p>Impute Partial Date Portion of a <code>'--DTC'</code> Variable</p></a></li>
<li><a href='#impute_dtc_dtm'><p>Impute Partial Date(-time) Portion of a <code>'--DTC'</code> Variable</p></a></li>
<li><a href='#list_all_templates'><p>List All Available ADaM Templates</p></a></li>
<li><a href='#list_tte_source_objects'><p>List all <code>tte_source</code> Objects Available in a Package</p></a></li>
<li><a href='#max_cond'><p>Maximum Value on a Subset</p></a></li>
<li><a href='#min_cond'><p>Minimum Value on a Subset</p></a></li>
<li><a href='#negate_vars'><p>Negate List of Variables</p></a></li>
<li><a href='#params'><p>Create a Set of Parameters</p></a></li>
<li><a href='#print_named_list'><p>Print Named List</p></a></li>
<li><a href='#print.adam_templates'><p>Print <code>adam_templates</code> Objects</p></a></li>
<li><a href='#print.duplicates'><p>Print <code>duplicates</code> Objects</p></a></li>
<li><a href='#print.source'><p>Print <code>source</code> Objects</p></a></li>
<li><a href='#queries'><p>Queries Dataset</p></a></li>
<li><a href='#queries_mh'><p>Queries MH Dataset</p></a></li>
<li><a href='#query'><p>Create an <code>query</code> object</p></a></li>
<li><a href='#records_source'><p>Create a <code>records_source</code> Object</p></a></li>
<li><a href='#restrict_derivation'><p>Execute a Derivation on a Subset of the Input Dataset</p></a></li>
<li><a href='#restrict_imputed_dtc_dt'><p>Restrict Imputed DTC date to Minimum/Maximum Dates</p></a></li>
<li><a href='#restrict_imputed_dtc_dtm'><p>Restrict Imputed DTC date to Minimum/Maximum Dates</p></a></li>
<li><a href='#set_admiral_options'><p>Set the Value of Admiral Options</p></a></li>
<li><a href='#signal_duplicate_records'><p>Signal Duplicate Records</p></a></li>
<li><a href='#slice_derivation'><p>Execute a Derivation with Different Arguments for Subsets of the Input Dataset</p></a></li>
<li><a href='#tte_source'><p>Create a <code>tte_source</code> Object</p></a></li>
<li><a href='#use_ad_template'><p>Open an ADaM Template Script</p></a></li>
<li><a href='#yn_to_numeric'><p>Map <code>"Y"</code> and <code>"N"</code> to Numeric Values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ADaM in R Asset Library</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolbox for programming Clinical Data Interchange Standards
    Consortium (CDISC) compliant Analysis Data Model (ADaM) datasets in R.
    ADaM datasets are a mandatory part of any New Drug or Biologics
    License Application submitted to the United States Food and Drug
    Administration (FDA). Analysis derivations are implemented in
    accordance with the "Analysis Data Model Implementation Guide" (CDISC
    Analysis Data Model Team, 2021,
    <a href="https://www.cdisc.org/standards/foundational/adam">https://www.cdisc.org/standards/foundational/adam</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pharmaverse.github.io/admiral/">https://pharmaverse.github.io/admiral/</a>,
<a href="https://github.com/pharmaverse/admiral">https://github.com/pharmaverse/admiral</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pharmaverse/admiral/issues">https://github.com/pharmaverse/admiral/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>admiraldev (&ge; 1.0.0), dplyr (&ge; 1.0.5), hms (&ge; 0.5.3),
lifecycle (&ge; 0.1.0), lubridate (&ge; 1.7.4), magrittr (&ge; 1.5),
purrr (&ge; 0.3.3), rlang (&ge; 0.4.4), stringr (&ge; 1.4.0), tidyr
(&ge; 1.0.2), tidyselect (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>diffdf, DT, htmltools, knitr, methods, pharmaversesdtm (&ge;
0.2.0), reactable, readxl, rmarkdown, testthat (&ge; 3.0.0),
tibble</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>gert</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 15:53:40 UTC; r590548</td>
</tr>
<tr>
<td>Author:</td>
<td>Ben Straub [aut, cre],
  Stefan Bundfuss [aut],
  Jeffrey Dickinson [aut],
  Ross Farrugia [aut],
  Adam Forys [aut],
  G Gayatri [aut],
  Daphne Grasselly [aut],
  Dinakar Kulkarni [aut],
  Edoardo Mancini [aut],
  Sadchla Mascary [aut],
  Gordon Miller [aut],
  Sophie Shapcott [aut],
  Eric Simms [aut],
  Daniel Sjoberg [aut],
  Stefan Thoma [aut],
  Kangjie Zhang [aut],
  Zelos Zhu [aut],
  Thomas Neitmann [ctb],
  F. Hoffmann-La Roche AG [cph, fnd],
  GlaxoSmithKline LLC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Straub &lt;ben.x.straub@gsk.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 17:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='admiral-package'>admiral: ADaM in R Asset Library</h2><span id='topic+admiral'></span><span id='topic+admiral-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A toolbox for programming Clinical Data Interchange Standards Consortium (CDISC) compliant Analysis Data Model (ADaM) datasets in R. ADaM datasets are a mandatory part of any New Drug or Biologics License Application submitted to the United States Food and Drug Administration (FDA). Analysis derivations are implemented in accordance with the &quot;Analysis Data Model Implementation Guide&quot; (CDISC Analysis Data Model Team, 2021, <a href="https://www.cdisc.org/standards/foundational/adam">https://www.cdisc.org/standards/foundational/adam</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ben Straub <a href="mailto:ben.x.straub@gsk.com">ben.x.straub@gsk.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Stefan Bundfuss
</p>
</li>
<li><p> Jeffrey Dickinson
</p>
</li>
<li><p> Ross Farrugia
</p>
</li>
<li><p> Adam Forys
</p>
</li>
<li><p> G Gayatri
</p>
</li>
<li><p> Daphne Grasselly
</p>
</li>
<li><p> Dinakar Kulkarni
</p>
</li>
<li><p> Edoardo Mancini
</p>
</li>
<li><p> Sadchla Mascary
</p>
</li>
<li><p> Gordon Miller
</p>
</li>
<li><p> Sophie Shapcott
</p>
</li>
<li><p> Eric Simms
</p>
</li>
<li><p> Daniel Sjoberg
</p>
</li>
<li><p> Stefan Thoma
</p>
</li>
<li><p> Kangjie Zhang
</p>
</li>
<li><p> Zelos Zhu
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Thomas Neitmann [contributor]
</p>
</li>
<li><p> F. Hoffmann-La Roche AG [copyright holder, funder]
</p>
</li>
<li><p> GlaxoSmithKline LLC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pharmaverse.github.io/admiral/">https://pharmaverse.github.io/admiral/</a>
</p>
</li>
<li> <p><a href="https://github.com/pharmaverse/admiral">https://github.com/pharmaverse/admiral</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pharmaverse/admiral/issues">https://github.com/pharmaverse/admiral/issues</a>
</p>
</li></ul>

<p>Other internal: 
<code><a href="#topic+extract_duplicate_records">extract_duplicate_records</a>()</code>,
<code><a href="#topic+format.basket_select">format.basket_select</a>()</code>,
<code><a href="#topic+signal_duplicate_records">signal_duplicate_records</a>()</code>
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>

<hr>
<h2 id='admiral_adlb'>Lab Analysis Dataset</h2><span id='topic+admiral_adlb'></span>

<h3>Description</h3>

<p>An example of lab analysis dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admiral_adlb
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 3779 rows and 111 columns.
</p>


<h3>Source</h3>

<p>Derived from the <code>adlb</code> template, then further filtered
due to dataset size by the following USUBJIDs:
01-701-1015, 01-701-1023, 01-701-1028, 01-701-1033,
01-701-1034, 01-701-1047, 01-701-1097, 01-705-1186,
01-705-1292, 01-705-1310, 01-708-1286
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adsl">admiral_adsl</a></code>,
<code><a href="#topic+ex_single">ex_single</a></code>,
<code><a href="#topic+example_qs">example_qs</a></code>,
<code><a href="#topic+queries">queries</a></code>,
<code><a href="#topic+queries_mh">queries_mh</a></code>
</p>

<hr>
<h2 id='admiral_adsl'>Subject Level Analysis Dataset</h2><span id='topic+admiral_adsl'></span>

<h3>Description</h3>

<p>An example subject level analysis dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admiral_adsl
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 306 rows and 50 columns.
</p>


<h3>Source</h3>

<p>Derived from the <code>dm</code> and <code>ds</code> datasets using <code>{admiral}</code> (<a href="https://github.com/pharmaverse/admiral/blob/main/inst/templates/ad_adsl.R">https://github.com/pharmaverse/admiral/blob/main/inst/templates/ad_adsl.R</a>)
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adlb">admiral_adlb</a></code>,
<code><a href="#topic+ex_single">ex_single</a></code>,
<code><a href="#topic+example_qs">example_qs</a></code>,
<code><a href="#topic+queries">queries</a></code>,
<code><a href="#topic+queries_mh">queries_mh</a></code>
</p>

<hr>
<h2 id='assert_parameters_argument'>Asserts <code>parameters</code> Argument and Converts to List of Expressions</h2><span id='topic+assert_parameters_argument'></span>

<h3>Description</h3>

<p>The function asserts that the argument is a character vector or a list of
expressions. If it is a character vector, it converts it to a list of
symbols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_parameters_argument(parameters, optional = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_parameters_argument_+3A_parameters">parameters</code></td>
<td>
<p>The argument to check</p>
</td></tr>
<tr><td><code id="assert_parameters_argument_+3A_optional">optional</code></td>
<td>
<p>Is the checked argument optional? If set to <code>FALSE</code> and
<code>parameters</code> is <code>NULL</code> then an error is thrown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>parameters</code> argument (converted to a list of symbol, if it is a
character vector)
</p>

<hr>
<h2 id='atoxgr_criteria_ctcv4'>Metadata Holding Grading Criteria for NCI-CTCAEv4</h2><span id='topic+atoxgr_criteria_ctcv4'></span>

<h3>Description</h3>

<p>Metadata Holding Grading Criteria for NCI-CTCAEv4
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atoxgr_criteria_ctcv4
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 40 rows and 13 columns.
</p>


<h3>Details</h3>

<p>This metadata has its origin in the ADLB Grading Spec Excel file which ships with <code>{admiral}</code>
and can be accessed using <code>system.file("adlb_grading/adlb_grading_spec.xlsx", package = "admiral")</code>
in sheet = &quot;NCICTCAEv4&quot;.
The dataset contained in there has the following columns:
</p>

<ul>
<li> <p><code>SOC</code>: variable to hold the SOC of the lab test criteria.
</p>
</li>
<li> <p><code>TERM</code>: variable to hold the term describing the criteria applied to a particular lab test,
eg. 'Anemia' or 'INR Increased'. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 1&#8288;</code>: Criteria defining lab value as Grade 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 2&#8288;</code>: Criteria defining lab value as Grade 2.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 3&#8288;</code>: Criteria defining lab value as Grade 3.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 4&#8288;</code>: Criteria defining lab value as Grade 4.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 5&#8288;</code>: Criteria defining lab value as Grade 5.
</p>
</li>
<li> <p><code>Definition</code>: Holds the definition of the lab test abnormality.
</p>
</li>
<li> <p><code>GRADE_CRITERIA_CODE</code>: variable to hold code that creates grade based on defined criteria.
</p>
</li>
<li> <p><code>SI_UNIT_CHECK</code>: variable to hold unit of particular lab test. Used to check against input data
if criteria is based on absolute values.
</p>
</li>
<li> <p><code>VAR_CHECK</code>: List of variables required to implement lab grade criteria. Use to check against
input data.
</p>
</li>
<li> <p><code>DIRECTION</code>: variable to hold the direction of the abnormality of a particular lab test
value. 'L' is for LOW values, 'H' is for HIGH values. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>COMMENT</code>: Holds any information regarding rationale behind implementation of grading criteria.
</p>
</li></ul>

<p>Note: Variables <code>SOC</code>, <code>TERM</code>, <code style="white-space: pre;">&#8288;Grade 1&#8288;</code>, <code style="white-space: pre;">&#8288;Grade 2&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 3&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 4&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 5&#8288;</code>, <code>Definition</code>
are from the source document on NCI-CTC website defining the grading criteria.
<a href="https://ctep.cancer.gov/protocoldevelopment/electronic_applications/ctc.htm#ctc_40"><strong>Common Terminology Criteria for Adverse Events (CTCAE)v4.0</strong></a>
From these variables only 'TERM' is used in the <code>{admiral}</code> code, the rest are for information and
traceability only.
</p>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+atoxgr_criteria_ctcv5">atoxgr_criteria_ctcv5</a></code>,
<code><a href="#topic+atoxgr_criteria_daids">atoxgr_criteria_daids</a></code>,
<code><a href="#topic+dose_freq_lookup">dose_freq_lookup</a></code>
</p>

<hr>
<h2 id='atoxgr_criteria_ctcv5'>Metadata Holding Grading Criteria for NCI-CTCAEv5</h2><span id='topic+atoxgr_criteria_ctcv5'></span>

<h3>Description</h3>

<p>Metadata Holding Grading Criteria for NCI-CTCAEv5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atoxgr_criteria_ctcv5
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 37 rows and 13 columns.
</p>


<h3>Details</h3>

<p>This metadata has its origin in the ADLB Grading Spec Excel file which ships with <code>{admiral}</code>
and can be accessed using <code>system.file("adlb_grading/adlb_grading_spec.xlsx", package = "admiral")</code>
in sheet = &quot;NCICTCAEv5&quot;.
The dataset contained in there has the following columns:
</p>

<ul>
<li> <p><code>SOC</code>: variable to hold the SOC of the lab test criteria.
</p>
</li>
<li> <p><code>TERM</code>: variable to hold the term describing the criteria applied to a particular lab test,
eg. 'Anemia' or 'INR Increased'. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 1&#8288;</code>: Criteria defining lab value as Grade 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 2&#8288;</code>: Criteria defining lab value as Grade 2.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 3&#8288;</code>: Criteria defining lab value as Grade 3.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 4&#8288;</code>: Criteria defining lab value as Grade 4.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 5&#8288;</code>: Criteria defining lab value as Grade 5.
</p>
</li>
<li> <p><code>Definition</code>: Holds the definition of the lab test abnormality.
</p>
</li>
<li> <p><code>GRADE_CRITERIA_CODE</code>: variable to hold code that creates grade based on defined criteria.
</p>
</li>
<li> <p><code>SI_UNIT_CHECK</code>: variable to hold unit of particular lab test. Used to check against input data
if criteria is based on absolute values.
</p>
</li>
<li> <p><code>VAR_CHECK</code>: List of variables required to implement lab grade criteria. Use to check against
input data.
</p>
</li>
<li> <p><code>DIRECTION</code>: variable to hold the direction of the abnormality of a particular lab test
value. 'L' is for LOW values, 'H' is for HIGH values. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>COMMENT</code>: Holds any information regarding rationale behind implementation of grading criteria.
</p>
</li></ul>

<p>Note: Variables <code>SOC</code>, <code>TERM</code>, <code style="white-space: pre;">&#8288;Grade 1&#8288;</code>, <code style="white-space: pre;">&#8288;Grade 2&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 3&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 4&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 5&#8288;</code>, <code>Definition</code>
are from the source document on NCI-CTC website defining the grading criteria.
<a href="https://ctep.cancer.gov/protocoldevelopment/electronic_applications/ctc.htm#ctc_50"><strong>Common Terminology Criteria for Adverse Events (CTCAE)v5.0</strong></a>
From these variables only 'TERM' is used in the <code>{admiral}</code> code, the rest are for information and
traceability only.
</p>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+atoxgr_criteria_ctcv4">atoxgr_criteria_ctcv4</a></code>,
<code><a href="#topic+atoxgr_criteria_daids">atoxgr_criteria_daids</a></code>,
<code><a href="#topic+dose_freq_lookup">dose_freq_lookup</a></code>
</p>

<hr>
<h2 id='atoxgr_criteria_daids'>Metadata Holding Grading Criteria for DAIDs</h2><span id='topic+atoxgr_criteria_daids'></span>

<h3>Description</h3>

<p>Metadata Holding Grading Criteria for DAIDs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>atoxgr_criteria_daids
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 63 rows and 15 columns.
</p>


<h3>Details</h3>

<p>This metadata has its origin in the ADLB Grading Spec Excel file which ships with <code>{admiral}</code>
and can be accessed using <code>system.file("adlb_grading/adlb_grading_spec.xlsx", package = "admiral")</code>
in sheet = &quot;DAIDS&quot;.
The dataset contained in there has the following columns:
</p>

<ul>
<li> <p><code>SOC</code>: variable to hold the SOC of the lab test criteria.
</p>
</li>
<li> <p><code>TERM</code>: variable to hold the term describing the criteria applied to a particular lab test,
eg. 'Anemia' or 'INR Increased'. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>SUBGROUP</code> : Description of sub-group of subjects were grading will be applied (i.e. &gt;= 18 years)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 1&#8288;</code>: Criteria defining lab value as Grade 1.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 2&#8288;</code>: Criteria defining lab value as Grade 2.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 3&#8288;</code>: Criteria defining lab value as Grade 3.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 4&#8288;</code>: Criteria defining lab value as Grade 4.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;Grade 5&#8288;</code>: Criteria defining lab value as Grade 5.
</p>
</li>
<li> <p><code>Definition</code>: Holds the definition of the lab test abnormality.
</p>
</li>
<li> <p><code>FILTER</code> : <code>admiral</code> code to apply the filter based on SUBGROUP column.
</p>
</li>
<li> <p><code>GRADE_CRITERIA_CODE</code>: variable to hold code that creates grade based on defined criteria.
</p>
</li>
<li> <p><code>SI_UNIT_CHECK</code>: variable to hold unit of particular lab test. Used to check against input data
if criteria is based on absolute values.
</p>
</li>
<li> <p><code>VAR_CHECK</code>: List of variables required to implement lab grade criteria. Use to check against
input data.
</p>
</li>
<li> <p><code>DIRECTION</code>: variable to hold the direction of the abnormality of a particular lab test
value. 'L' is for LOW values, 'H' is for HIGH values. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>COMMENT</code>: Holds any information regarding rationale behind implementation of grading criteria.
</p>
</li></ul>

<p>Note: Variables <code>SOC</code>, <code>TERM</code>, <code>SUBGROUP</code>, <code style="white-space: pre;">&#8288;Grade 1&#8288;</code>, <code style="white-space: pre;">&#8288;Grade 2&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 3&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 4&#8288;</code>,<code style="white-space: pre;">&#8288;Grade 5&#8288;</code>, <code>Definition</code>
are from the source document on DAIDS website defining the grading criteria.
[Division of AIDS (DAIDS) Table for Grading the Severity of Adult and Pediatric Adverse Events
From these variables only 'TERM' is used in the <code>{admiral}</code> code, the rest are for information and
traceability only.
</p>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+atoxgr_criteria_ctcv4">atoxgr_criteria_ctcv4</a></code>,
<code><a href="#topic+atoxgr_criteria_ctcv5">atoxgr_criteria_ctcv5</a></code>,
<code><a href="#topic+dose_freq_lookup">dose_freq_lookup</a></code>
</p>

<hr>
<h2 id='basket_select'>Create a <code>basket_select</code> object</h2><span id='topic+basket_select'></span>

<h3>Description</h3>

<p>Create a <code>basket_select</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basket_select(name = NULL, id = NULL, scope = NULL, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basket_select_+3A_name">name</code></td>
<td>
<p>Name of the query used to select the definition of the query from
the company database.</p>
</td></tr>
<tr><td><code id="basket_select_+3A_id">id</code></td>
<td>
<p>Identifier of the query used to select the definition of the query
from the company database.</p>
</td></tr>
<tr><td><code id="basket_select_+3A_scope">scope</code></td>
<td>
<p>Scope of the query used to select the definition of the query
from the company database.
</p>
<p><em>Permitted Values</em>: <code>"BROAD"</code>, <code>"NARROW"</code>, <code>NA_character_</code></p>
</td></tr>
<tr><td><code id="basket_select_+3A_type">type</code></td>
<td>
<p>The type argument expects a character scalar. It is passed to the
company specific get_terms() function such that the function can determine
which sort of basket is requested</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Exactly one of <code>name</code> or <code>id</code> must be specified.
</p>


<h3>Value</h3>

<p>An object of class <code>basket_select</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_query_data">create_query_data()</a></code>, <code><a href="#topic+query">query()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>

<hr>
<h2 id='call_derivation'>Call a Single Derivation Multiple Times</h2><span id='topic+call_derivation'></span>

<h3>Description</h3>

<p>Call a single derivation multiple times with some parameters/arguments being fixed across
iterations and others varying.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_derivation(dataset = NULL, derivation, variable_params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_derivation_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="call_derivation_+3A_derivation">derivation</code></td>
<td>
<p>The derivation function to call
</p>
<p>A function that performs a specific derivation is expected. A derivation
adds variables or observations to a dataset. The first argument of a
derivation must expect a dataset and the derivation must return a dataset.
The function must provide the <code>dataset</code> argument and all arguments
specified in the <code>params()</code> objects passed to the <code>variable_params</code> and
<code>...</code> argument.
</p>
<p>Please note that it is not possible to specify <code>{dplyr}</code>
functions like <code>mutate()</code> or <code>summarize()</code>.</p>
</td></tr>
<tr><td><code id="call_derivation_+3A_variable_params">variable_params</code></td>
<td>
<p>A <code>list</code> of function arguments that are different across iterations.
Each set of function arguments must be created using <code><a href="#topic+params">params()</a></code>.</p>
</td></tr>
<tr><td><code id="call_derivation_+3A_...">...</code></td>
<td>
<p>Any number of <em>named</em> function arguments that stay the same across iterations.
If a function argument is specified both inside <code>variable_params</code> and <code>...</code> then
the value in <code>variable_params</code> overwrites the one in <code>...</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with additional records/variables added depending on
which <code>derivation</code> has been used.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params">params()</a></code>
</p>
<p>Higher Order Functions: 
<code><a href="#topic+derivation_slice">derivation_slice</a>()</code>,
<code><a href="#topic+restrict_derivation">restrict_derivation</a>()</code>,
<code><a href="#topic+slice_derivation">slice_derivation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID,      ~TRTSDT,      ~TRTEDT,
  "PILOT01", "01-1307",           NA,           NA,
  "PILOT01", "05-1377", "2014-01-04", "2014-01-25",
  "PILOT01", "06-1384", "2012-09-15", "2012-09-24",
  "PILOT01", "15-1085", "2013-02-16", "2013-08-18",
  "PILOT01", "16-1298", "2013-04-08", "2013-06-28"
) %&gt;%
  mutate(
    across(TRTSDT:TRTEDT, as.Date)
  )

ae &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,     ~AESTDTC,     ~AEENDTC,
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06"
)

adae &lt;- ae %&gt;%
  derive_vars_merged(
    dataset_add = adsl,
    new_vars = exprs(TRTSDT, TRTEDT),
    by_vars = exprs(USUBJID)
  )

## While `derive_vars_dt()` can only add one variable at a time, using `call_derivation()`
## one can add multiple variables in one go
call_derivation(
  dataset = adae,
  derivation = derive_vars_dt,
  variable_params = list(
    params(dtc = AESTDTC, date_imputation = "first", new_vars_prefix = "AST"),
    params(dtc = AEENDTC, date_imputation = "last", new_vars_prefix = "AEN")
  ),
  min_dates = exprs(TRTSDT),
  max_dates = exprs(TRTEDT)
)

## The above call using `call_derivation()` is equivalent to the following
adae %&gt;%
  derive_vars_dt(
    new_vars_prefix = "AST",
    dtc = AESTDTC,
    date_imputation = "first",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  ) %&gt;%
  derive_vars_dt(
    new_vars_prefix = "AEN",
    dtc = AEENDTC,
    date_imputation = "last",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  )
</code></pre>

<hr>
<h2 id='call_user_fun'>Calls a Function Provided by the User</h2><span id='topic+call_user_fun'></span>

<h3>Description</h3>

<p>Calls a function provided by the user and adds the function call to the error
message if the call fails.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_user_fun(call)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_user_fun_+3A_call">call</code></td>
<td>
<p>Call to be executed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of the function call
</p>


<h3>See Also</h3>

<p>Utilities used within Derivation functions: 
<code><a href="#topic+extract_unit">extract_unit</a>()</code>,
<code><a href="#topic+get_not_mapped">get_not_mapped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>call_user_fun(compute_bmi(
  height = 172,
  weight = 60
))

try(call_user_fun(compute_bmi(
  height = 172,
  weight = "hallo"
)))
</code></pre>

<hr>
<h2 id='censor_source'>Create a <code>censor_source</code> Object</h2><span id='topic+censor_source'></span>

<h3>Description</h3>

<p><code>censor_source</code> objects are used to define censorings as input for the
<code>derive_param_tte()</code> function.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>tte_source()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>censor_source(
  dataset_name,
  filter = NULL,
  date,
  censor = 1,
  set_values_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="censor_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the source dataset
</p>
<p>The name refers to the dataset provided by the <code>source_datasets</code> parameter
of <code>derive_param_tte()</code>.</p>
</td></tr>
<tr><td><code id="censor_source_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for selecting the observations from
<code>dataset</code> which are events or possible censoring time points.</p>
</td></tr>
<tr><td><code id="censor_source_+3A_date">date</code></td>
<td>
<p>A variable or expression providing the date of the event or
censoring. A date, or a datetime can be specified. An unquoted symbol or
expression is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> or <code>convert_dtc_to_dt()</code> to impute and derive a
date from a date character vector to a date object.</p>
</td></tr>
<tr><td><code id="censor_source_+3A_censor">censor</code></td>
<td>
<p>Censoring value
</p>
<p>CDISC strongly recommends using <code>0</code> for events and positive integers for
censoring.</p>
</td></tr>
<tr><td><code id="censor_source_+3A_set_values_to">set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event or censoring, e.g. <code>exprs(EVENTDESC = "DEATH", SRCDOM = "ADSL", SRCVAR = "DTHDT")</code>. The values must be a symbol, a
character string, a numeric value, an expression, or <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>censor_source</code>, inheriting from class <code>tte_source</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>, <code><a href="#topic+event_source">event_source()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Last study date known alive censor

censor_source(
  dataset_name = "adsl",
  date = LSTALVDT,
  set_values_to = exprs(
    EVNTDESC = "ALIVE",
    SRCDOM = "ADSL",
    SRCVAR = "LSTALVDT"
  )
)
</code></pre>

<hr>
<h2 id='chr2vars'>Turn a Character Vector into a List of Expressions</h2><span id='topic+chr2vars'></span>

<h3>Description</h3>

<p>Turn a character vector into a list of expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chr2vars(chr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chr2vars_+3A_chr">chr</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of expressions as returned by <code><a href="#topic+exprs">exprs()</a></code>
</p>


<h3>See Also</h3>

<p>Utilities for working with quosures/list of expressions: 
<code><a href="#topic+negate_vars">negate_vars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chr2vars(c("USUBJID", "AVAL"))
</code></pre>

<hr>
<h2 id='compute_age_years'>Compute Age in Years</h2><span id='topic+compute_age_years'></span>

<h3>Description</h3>

<p>Converts a set of age values from the specified time unit to years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_age_years(age, age_unit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_age_years_+3A_age">age</code></td>
<td>
<p>The ages to convert.
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_age_years_+3A_age_unit">age_unit</code></td>
<td>
<p>Age unit.
</p>
<p>Either a string containing the time unit of all ages in <code>age</code> or a character
vector containing the time units of each age in <code>age</code> is expected. Note that
permitted values are cases insensitive (e.g. <code>"YEARS"</code> is treated the same
as <code>"years"</code> and <code>"Years"</code>).
</p>
<p>Permitted Values: <code>"years"</code>, <code>"months"</code>, <code>"weeks"</code>, <code>"days"</code>, <code>"hours"</code>, <code>"minutes"</code>,
<code>"seconds"</code>, <code>NA_character_</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a numeric vector of ages in years as doubles. Note
that passing <code>NA_character_</code> as a unit will result in an <code>NA</code> value for the outputted
age. Also note, underlying computations assume an equal number of days in each
year (365.25).
</p>


<h3>Value</h3>

<p>The ages contained in <code>age</code> converted to years.
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_age_years(
  age = c(240, 360, 480),
  age_unit = "MONTHS"
)

compute_age_years(
  age = c(10, 520, 3650, 1000),
  age_unit = c("YEARS", "WEEKS", "DAYS", NA_character_)
)

</code></pre>

<hr>
<h2 id='compute_bmi'>Compute Body Mass Index (BMI)</h2><span id='topic+compute_bmi'></span>

<h3>Description</h3>

<p>Computes BMI from height and weight
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_bmi(height, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_bmi_+3A_height">height</code></td>
<td>
<p>HEIGHT value
</p>
<p>It is expected that HEIGHT is in cm.
</p>
<p><em>Permitted Values:</em> numeric vector</p>
</td></tr>
<tr><td><code id="compute_bmi_+3A_weight">weight</code></td>
<td>
<p>WEIGHT value
</p>
<p>It is expected that WEIGHT is in kg.
</p>
<p><em>Permitted Values:</em> numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>The BMI (Body Mass Index Area) in kg/m^2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_bmi">derive_param_bmi()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_bmi(height = 170, weight = 75)
</code></pre>

<hr>
<h2 id='compute_bsa'>Compute Body Surface Area (BSA)</h2><span id='topic+compute_bsa'></span>

<h3>Description</h3>

<p>Computes BSA from height and weight making use of the specified derivation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_bsa(height = height, weight = weight, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_bsa_+3A_height">height</code></td>
<td>
<p>HEIGHT value
</p>
<p>It is expected that HEIGHT is in cm.
</p>
<p><em>Permitted Values:</em> numeric vector</p>
</td></tr>
<tr><td><code id="compute_bsa_+3A_weight">weight</code></td>
<td>
<p>WEIGHT value
</p>
<p>It is expected that WEIGHT is in kg.
</p>
<p><em>Permitted Values:</em> numeric vector</p>
</td></tr>
<tr><td><code id="compute_bsa_+3A_method">method</code></td>
<td>
<p>Derivation method to use:
</p>
<p>Mosteller: sqrt(height * weight / 3600)
</p>
<p>DuBois-DuBois: 0.20247 * (height/100) ^ 0.725 * weight ^ 0.425
</p>
<p>Haycock: 0.024265 * height ^ 0.3964 * weight ^ 0.5378
</p>
<p>Gehan-George: 0.0235 * height ^ 0.42246 * weight ^ 0.51456
</p>
<p>Boyd: 0.0003207 * (height ^ 0.3) * (1000 * weight) ^ (0.7285 - (0.0188 * log10(1000 * weight)))
</p>
<p>Fujimoto: 0.008883 * height ^ 0.663 * weight ^ 0.444
</p>
<p>Takahira: 0.007241 * height ^ 0.725 * weight ^ 0.425
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>The BSA (Body Surface Area) in m^2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_bsa">derive_param_bsa()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Derive BSA by the Mosteller method
compute_bsa(
  height = 170,
  weight = 75,
  method = "Mosteller"
)

# Derive BSA by the DuBois &amp; DuBois method
compute_bsa(
  height = c(170, 185),
  weight = c(75, 90),
  method = "DuBois-DuBois"
)
</code></pre>

<hr>
<h2 id='compute_dtf'>Derive the Date Imputation Flag</h2><span id='topic+compute_dtf'></span>

<h3>Description</h3>

<p>Derive the date imputation flag (<code>'--DTF'</code>) comparing a date character vector
(<code>'--DTC'</code>) with a Date vector (<code>'--DT'</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_dtf(dtc, dt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_dtf_+3A_dtc">dtc</code></td>
<td>
<p>The date character vector (<code>'--DTC'</code>).
</p>
<p>A character date is expected in a format like <code>yyyy-mm-ddThh:mm:ss</code> (partial or complete).</p>
</td></tr>
<tr><td><code id="compute_dtf_+3A_dt">dt</code></td>
<td>
<p>The  Date vector to compare.
</p>
<p>A date object is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>The date imputation flag (<code>'--DTF'</code>) (character value of <code>'D'</code>, <code>'M'</code> , <code>'Y'</code> or <code>NA</code>)
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_dtf(dtc = "2019-07", dt = as.Date("2019-07-18"))
compute_dtf(dtc = "2019", dt = as.Date("2019-07-18"))
compute_dtf(dtc = "--06-01T00:00", dt = as.Date("2022-06-01"))
compute_dtf(dtc = "2022-06--T00:00", dt = as.Date("2022-06-01"))
compute_dtf(dtc = "2022---01T00:00", dt = as.Date("2022-06-01"))
compute_dtf(dtc = "2022----T00:00", dt = as.Date("2022-06-01"))
</code></pre>

<hr>
<h2 id='compute_duration'>Compute Duration</h2><span id='topic+compute_duration'></span>

<h3>Description</h3>

<p>Compute duration between two dates, e.g., duration of an adverse event,
relative day, age, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_duration(
  start_date,
  end_date,
  in_unit = "days",
  out_unit = "days",
  floor_in = TRUE,
  add_one = TRUE,
  trunc_out = FALSE,
  type = "duration"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_duration_+3A_start_date">start_date</code></td>
<td>
<p>The start date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Refer to <code>convert_dtc_to_dt()</code> to obtain a vector of imputed dates.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_end_date">end_date</code></td>
<td>
<p>The end date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Refer to <code>convert_dtc_to_dt()</code> to obtain a vector of imputed dates.</p>
</td></tr>
<tr><td><code id="compute_duration_+3A_in_unit">in_unit</code></td>
<td>
<p>Input unit
</p>
<p>See floor_in and add_one parameter for details.
</p>
<p>Permitted Values (case-insensitive):
</p>
<p>For years: <code>"year"</code>, <code>"years"</code>, <code>"yr"</code>, <code>"yrs"</code>, <code>"y"</code>
</p>
<p>For months: <code>"month"</code>, <code>"months"</code>, <code>"mo"</code>, <code>"mos"</code>
</p>
<p>For days: <code>"day"</code>, <code>"days"</code>, <code>"d"</code>
</p>
<p>For hours: <code>"hour"</code>, <code>"hours"</code>, <code>"hr"</code>, <code>"hrs"</code>, <code>"h"</code>
</p>
<p>For minutes: <code>"minute"</code>, <code>"minutes"</code>, <code>"min"</code>, <code>"mins"</code>
</p>
<p>For seconds: <code>"second"</code>, <code>"seconds"</code>, <code>"sec"</code>, <code>"secs"</code>, <code>"s"</code></p>
</td></tr>
<tr><td><code id="compute_duration_+3A_out_unit">out_unit</code></td>
<td>
<p>Output unit
</p>
<p>The duration is derived in the specified unit
</p>
<p>Permitted Values (case-insensitive):
</p>
<p>For years: <code>"year"</code>, <code>"years"</code>, <code>"yr"</code>, <code>"yrs"</code>, <code>"y"</code>
</p>
<p>For months: <code>"month"</code>, <code>"months"</code>, <code>"mo"</code>, <code>"mos"</code>
</p>
<p>For weeks: <code>"week"</code>, <code>"weeks"</code>, <code>"wk"</code>, <code>"wks"</code>, <code>"w"</code>
</p>
<p>For days: <code>"day"</code>, <code>"days"</code>, <code>"d"</code>
</p>
<p>For hours: <code>"hour"</code>, <code>"hours"</code>, <code>"hr"</code>, <code>"hrs"</code>, <code>"h"</code>
</p>
<p>For minutes: <code>"minute"</code>, <code>"minutes"</code>, <code>"min"</code>, <code>"mins"</code>
</p>
<p>For seconds: <code>"second"</code>, <code>"seconds"</code>, <code>"sec"</code>, <code>"secs"</code>, <code>"s"</code></p>
</td></tr>
<tr><td><code id="compute_duration_+3A_floor_in">floor_in</code></td>
<td>
<p>Round down input dates?
</p>
<p>The input dates are round down with respect to the input unit, e.g., if the
input unit is 'days', the time of the input dates is ignored.
</p>
<p>Default: <code>TRUE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="compute_duration_+3A_add_one">add_one</code></td>
<td>
<p>Add one input unit?
</p>
<p>If the duration is non-negative, one input unit is added. i.e., the
duration can not be zero.
</p>
<p>Default: <code>TRUE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="compute_duration_+3A_trunc_out">trunc_out</code></td>
<td>
<p>Return integer part
</p>
<p>The fractional part of the duration (in output unit) is removed, i.e., the
integer part is returned.
</p>
<p>Default: <code>FALSE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="compute_duration_+3A_type">type</code></td>
<td>
<p>lubridate duration type.
</p>
<p>See below for details.
</p>
<p>Default: <code>"duration"</code>
</p>
<p>Permitted Values: <code>"duration"</code>, <code>"interval"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output is a numeric vector providing the duration as time from
start to end date in the specified unit. If the end date is before the start
date, the duration is negative.
</p>


<h3>Value</h3>

<p>The duration between the two date in the specified unit
</p>


<h3>Duration Type</h3>

<p>The <a href="https://lubridate.tidyverse.org/">lubridate</a> package calculates two
types of spans between two dates: duration and interval.
While these calculations are largely the same, when the unit of the time period
is month or year the result can be slightly different.
</p>
<p>The difference arises from the ambiguity in the length of <code>"1 month"</code> or
<code>"1 year"</code>.
Months may have 31, 30, 28, or 29 days, and years are 365 days and 366 during leap years.
Durations and intervals help solve the ambiguity in these measures.
</p>
<p>The <strong>interval</strong> between <code>2000-02-01</code> and <code>2000-03-01</code> is <code>1</code> (i.e. one month).
The <strong>duration</strong> between these two dates is <code>0.95</code>, which accounts for the fact
that the year 2000 is a leap year, February has 29 days, and the average month
length is <code>30.4375</code>, i.e. <code>29 / 30.4375 = 0.95</code>.
</p>
<p>For additional details, review the
<a href="https://lubridate.tidyverse.org/reference/timespan.html">lubridate time span reference page</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_duration">derive_vars_duration()</a></code>
</p>
<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

# Derive duration in days (integer), i.e., relative day
compute_duration(
  start_date = ymd_hms("2020-12-06T15:00:00"),
  end_date = ymd_hms("2020-12-24T08:15:00")
)

# Derive duration in days (float)
compute_duration(
  start_date = ymd_hms("2020-12-06T15:00:00"),
  end_date = ymd_hms("2020-12-24T08:15:00"),
  floor_in = FALSE,
  add_one = FALSE
)

# Derive age in years
compute_duration(
  start_date = ymd("1984-09-06"),
  end_date = ymd("2020-02-24"),
  trunc_out = TRUE,
  out_unit = "years",
  add_one = FALSE
)

# Derive duration in hours
compute_duration(
  start_date = ymd_hms("2020-12-06T9:00:00"),
  end_date = ymd_hms("2020-12-06T13:30:00"),
  out_unit = "hours",
  floor_in = FALSE,
  add_one = FALSE,
)
</code></pre>

<hr>
<h2 id='compute_egfr'>Compute Estimated Glomerular Filtration Rate (eGFR) for Kidney Function</h2><span id='topic+compute_egfr'></span>

<h3>Description</h3>

<p>Compute Kidney Function Tests:
</p>

<ul>
<li><p> Estimated Creatinine Clearance (CRCL) by Cockcroft-Gault equation
</p>
</li>
<li><p> Estimated Glomerular Filtration Rate (eGFR) by CKD-EPI or MDRD equations
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>compute_egfr(creat, creatu = "SI", age, weight, sex, race = NULL, method, wt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_egfr_+3A_creat">creat</code></td>
<td>
<p>Creatinine
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_creatu">creatu</code></td>
<td>
<p>Creatinine Units
</p>
<p>A character vector is expected.
</p>
<p>Default: <code>"SI"</code>
</p>
<p>Expected Values: <code>"SI"</code>, <code>"CV"</code>, <code>"umol/L"</code>, <code>"mg/dL"</code></p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_age">age</code></td>
<td>
<p>Age (years)
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_weight">weight</code></td>
<td>
<p>Weight (kg)
</p>
<p>A numeric vector is expected if <code>method = "CRCL"</code></p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_sex">sex</code></td>
<td>
<p>Gender
</p>
<p>A character vector is expected.
</p>
<p>Expected Values: <code>"M"</code>, <code>"F"</code></p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_race">race</code></td>
<td>
<p>Race
</p>
<p>A character vector is expected if <code>method = "MDRD"</code>
</p>
<p>Expected Values: <code>"BLACK OR AFRICAN AMERICAN"</code> and others</p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_method">method</code></td>
<td>
<p>Method
</p>
<p>A character vector is expected.
</p>
<p>Expected Values: <code>"CRCL"</code>, <code>"CKD-EPI"</code>, <code>"MDRD"</code></p>
</td></tr>
<tr><td><code id="compute_egfr_+3A_wt">wt</code></td>
<td>
<p><em>Deprecated</em>, please use <code>weight</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates an estimate of Glomerular Filtration Rate (eGFR)
</p>
<p><strong>CRCL Creatinine Clearance (Cockcroft-Gault)</strong>
</p>
<p>For Creatinine in umol/L:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(140 - age) \times weight(kg) \times constant}{Serum\:Creatinine(\mu mol/L)}</code>
</p>

<p style="text-align: center;"><code class="reqn">Constant = 1.04\:for\:females, 1.23\:for\:males</code>
</p>

<p>For Creatinine in mg/dL:
</p>
<p style="text-align: center;"><code class="reqn">\frac{(140 - age) \times weight(kg) \times (0.85\:if\:female)}{72 \times
Serum\:Creatinine(mg/dL)}</code>
</p>

<p>units = mL/min
</p>
<p><strong>CKD-EPI Chronic Kidney Disease Epidemiology Collaboration formula</strong>
</p>
<p style="text-align: center;"><code class="reqn">eGFR = 142 \times min(SCr/{\kappa}, 1)^{\alpha} \times max(SCr/{\kappa}, 1)^{-1.200}
\times 0.9938^{Age} \times 1.012 [if\:female]</code>
</p>

<p>SCr = standardized serum creatinine in mg/dL
(Note SCr(mg/dL) = Creat(umol/L) / 88.42)
</p>
<p style="text-align: center;"><code class="reqn">\kappa</code>
</p>
<p> = 0.7 (females) or 0.9 (males)
</p>
<p style="text-align: center;"><code class="reqn">\alpha</code>
</p>
<p> = -0.241 (female) or -0.302 (male)
units = mL/min/1.73 m2
</p>
<p><strong>MDRD Modification of Diet in Renal Disease formula</strong>
</p>
<p style="text-align: center;"><code class="reqn">eGFR = 175 \times (SCr)^{-1.154} \times (age)^{-0.203}
\times 0.742 [if\:female] \times 1.212 [if\:Black]</code>
</p>

<p>SCr = standardized serum creatinine in mg/dL
(Note SCr(mg/dL) = Creat(umol/L) / 88.42)
</p>
<p>units = mL/min/1.73 m2
</p>


<h3>Value</h3>

<p>A numeric vector of egfr values
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_egfr(
  creat = 90, creatu = "umol/L", age = 53, weight = 85, sex = "M", method = "CRCL"
)

compute_egfr(
  creat = 90, creatu = "umol/L", age = 53, sex = "M", race = "ASIAN", method = "MDRD"
)

compute_egfr(
  creat = 70, creatu = "umol/L", age = 52, sex = "F", race = "BLACK OR AFRICAN AMERICAN",
  method = "MDRD"
)

compute_egfr(
  creat = 90, creatu = "umol/L", age = 53, sex = "M", method = "CKD-EPI"
)


base &lt;- tibble::tribble(
  ~STUDYID, ~USUBJID, ~AGE, ~SEX, ~RACE, ~WTBL, ~CREATBL, ~CREATBLU,
  "P01", "P01-1001", 55, "M", "WHITE", 90.7, 96.3, "umol/L",
  "P01", "P01-1002", 52, "F", "BLACK OR AFRICAN AMERICAN", 68.5, 70, "umol/L",
  "P01", "P01-1003", 67, "M", "BLACK OR AFRICAN AMERICAN", 85.0, 77, "umol/L",
  "P01", "P01-1004", 76, "F", "ASIAN", 60.7, 65, "umol/L",
)

base %&gt;%
  dplyr::mutate(
    CRCL_CG = compute_egfr(
      creat = CREATBL, creatu = CREATBLU, age = AGE, weight = WTBL, sex = SEX,
      method = "CRCL"
    ),
    EGFR_EPI = compute_egfr(
      creat = CREATBL, creatu = CREATBLU, age = AGE, weight = WTBL, sex = SEX,
      method = "CKD-EPI"
    ),
    EGFR_MDRD = compute_egfr(
      creat = CREATBL, creatu = CREATBLU, age = AGE, weight = WTBL, sex = SEX,
      race = RACE, method = "MDRD"
    ),
  )
</code></pre>

<hr>
<h2 id='compute_framingham'>Compute Framingham Heart Study Cardiovascular Disease 10-Year Risk Score</h2><span id='topic+compute_framingham'></span>

<h3>Description</h3>

<p>Computes Framingham Heart Study Cardiovascular Disease 10-Year Risk Score
(FCVD101) based on systolic blood pressure, total serum cholesterol (mg/dL),
HDL serum cholesterol (mg/dL), sex, smoking status, diabetic status,
and treated for hypertension flag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_framingham(sysbp, chol, cholhdl, age, sex, smokefl, diabetfl, trthypfl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_framingham_+3A_sysbp">sysbp</code></td>
<td>
<p>Systolic blood pressure
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_chol">chol</code></td>
<td>
<p>Total serum cholesterol (mg/dL)
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_cholhdl">cholhdl</code></td>
<td>
<p>HDL serum cholesterol (mg/dL)
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_age">age</code></td>
<td>
<p>Age (years)
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_sex">sex</code></td>
<td>
<p>Gender
</p>
<p>A character vector is expected.
Expected Values: 'M' 'F'</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_smokefl">smokefl</code></td>
<td>
<p>Smoking Status
</p>
<p>A character vector  is expected.
Expected Values: 'Y' 'N'</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_diabetfl">diabetfl</code></td>
<td>
<p>Diabetic Status
</p>
<p>A character vector is expected.
Expected Values: 'Y' 'N'</p>
</td></tr>
<tr><td><code id="compute_framingham_+3A_trthypfl">trthypfl</code></td>
<td>
<p>Treated for hypertension status
</p>
<p>A character vector is expected.
Expected Values: 'Y' 'N'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The predicted probability of having cardiovascular disease (CVD)
within 10-years according to Framingham formula.  See AHA Journal article
General Cardiovascular Risk Profile for Use in Primary Care for reference.
</p>
<p><strong>For Women:</strong>
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>Factor</strong> </td><td style="text-align: right;"> <strong>Amount</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
Age </td><td style="text-align: right;"> 2.32888 </td>
</tr>
<tr>
 <td style="text-align: right;">
Total Chol </td><td style="text-align: right;"> 1.20904 </td>
</tr>
<tr>
 <td style="text-align: right;">
HDL Chol </td><td style="text-align: right;"> -0.70833 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP </td><td style="text-align: right;"> 2.76157 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP + Hypertension Meds </td><td style="text-align: right;"> 2.82263 </td>
</tr>
<tr>
 <td style="text-align: right;">
Smoker </td><td style="text-align: right;"> 0.52873 </td>
</tr>
<tr>
 <td style="text-align: right;">
Non-Smoker </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Diabetic </td><td style="text-align: right;"> 0.69154 </td>
</tr>
<tr>
 <td style="text-align: right;">
Not Diabetic </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Average Risk </td><td style="text-align: right;"> 26.1931 </td>
</tr>
<tr>
 <td style="text-align: right;">
Risk Period </td><td style="text-align: right;"> 0.95012 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>For Men:</strong>
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>Factor</strong> </td><td style="text-align: right;"> <strong>Amount</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
Age </td><td style="text-align: right;"> 3.06117 </td>
</tr>
<tr>
 <td style="text-align: right;">
Total Chol </td><td style="text-align: right;"> 1.12370 </td>
</tr>
<tr>
 <td style="text-align: right;">
HDL Chol </td><td style="text-align: right;"> -0.93263 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP </td><td style="text-align: right;"> 1.93303 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP + Hypertension Meds </td><td style="text-align: right;"> 2.99881 </td>
</tr>
<tr>
 <td style="text-align: right;">
Smoker </td><td style="text-align: right;"> .65451  </td>
</tr>
<tr>
 <td style="text-align: right;">
Non-Smoker </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Diabetic </td><td style="text-align: right;"> 0.57367  </td>
</tr>
<tr>
 <td style="text-align: right;">
Not Diabetic </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Average Risk </td><td style="text-align: right;"> 23.9802 </td>
</tr>
<tr>
 <td style="text-align: right;">
Risk Period </td><td style="text-align: right;"> 0.88936 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>The equation for calculating risk:</strong>
</p>
<p style="text-align: center;"><code class="reqn">RiskFactors = (log(Age) * AgeFactor)
+ (log(TotalChol) * TotalCholFactor)
+ (log(CholHDL) * CholHDLFactor) \\
+ (log(SysBP) * SysBPFactor) + Smoker
+ Diabetes Present - AvgRisk</code>
</p>

<p style="text-align: center;"><code class="reqn">Risk = 100 * (1 - RiskPeriodFactor ^ exp(RiskFactors))</code>
</p>



<h3>Value</h3>

<p>A numeric vector of Framingham values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_framingham">derive_param_framingham()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_framingham(
  sysbp = 133, chol = 216.16, cholhdl = 54.91, age = 53,
  sex = "M", smokefl = "N", diabetfl = "N", trthypfl = "N"
)

compute_framingham(
  sysbp = 161, chol = 186.39, cholhdl = 64.19, age = 52,
  sex = "F", smokefl = "Y", diabetfl = "N", trthypfl = "Y"
)
</code></pre>

<hr>
<h2 id='compute_map'>Compute Mean Arterial Pressure (MAP)</h2><span id='topic+compute_map'></span>

<h3>Description</h3>

<p>Computes mean arterial pressure (MAP) based on diastolic and systolic blood
pressure. Optionally heart rate can be used as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_map(diabp, sysbp, hr = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_map_+3A_diabp">diabp</code></td>
<td>
<p>Diastolic blood pressure
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_map_+3A_sysbp">sysbp</code></td>
<td>
<p>Systolic blood pressure
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_map_+3A_hr">hr</code></td>
<td>
<p>Heart rate
</p>
<p>A numeric vector or <code>NULL</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">\frac{2DIABP + SYSBP}{3}</code>
</p>

<p>if it is based on diastolic and systolic blood pressure and
</p>
<p style="text-align: center;"><code class="reqn">DIABP + 0.01 e^{4.14 - \frac{40.74}{HR}} (SYSBP - DIABP)</code>
</p>

<p>if it is based on diastolic, systolic blood pressure, and heart rate.
</p>
<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of MAP values
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_map">derive_param_map()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute MAP based on diastolic and systolic blood pressure
compute_map(diabp = 51, sysbp = 121)

# Compute MAP based on diastolic and systolic blood pressure and heart rate
compute_map(diabp = 51, sysbp = 121, hr = 59)
</code></pre>

<hr>
<h2 id='compute_qtc'>Compute Corrected QT</h2><span id='topic+compute_qtc'></span>

<h3>Description</h3>

<p>Computes corrected QT using Bazett's, Fridericia's or Sagie's formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_qtc(qt, rr, method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_qtc_+3A_qt">qt</code></td>
<td>
<p>QT interval
</p>
<p>A numeric vector is expected. It is expected that QT is measured in msec.</p>
</td></tr>
<tr><td><code id="compute_qtc_+3A_rr">rr</code></td>
<td>
<p>RR interval
</p>
<p>A numeric vector is expected. It is expected that RR is measured in msec.</p>
</td></tr>
<tr><td><code id="compute_qtc_+3A_method">method</code></td>
<td>
<p>Method used to QT correction
</p>
<p>Permitted Values: <code>"Bazett"</code>, <code>"Fridericia"</code>, <code>"Sagie"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the chosen <code>method</code> one of the following formulae is used.
</p>
<p><em>Bazett</em>: </p>
<p style="text-align: center;"><code class="reqn">\frac{QT}{\sqrt{\frac{RR}{1000}}}</code>
</p>

<p><em>Fridericia</em>: </p>
<p style="text-align: center;"><code class="reqn">\frac{QT}{\sqrt[3]{\frac{RR}{1000}}}</code>
</p>

<p><em>Sagie</em>: </p>
<p style="text-align: center;"><code class="reqn">1000\left(\frac{QT}{1000} + 0.154\left(1 - \frac{RR}{1000}\right)\right)</code>
</p>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>QT interval in msec
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_qtc">derive_param_qtc()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_qtc(qt = 350, rr = 56.54, method = "Bazett")

compute_qtc(qt = 350, rr = 56.54, method = "Fridericia")

compute_qtc(qt = 350, rr = 56.54, method = "Sagie")
</code></pre>

<hr>
<h2 id='compute_qual_imputation'>Function to Impute Values When Qualifier Exists in Character Result</h2><span id='topic+compute_qual_imputation'></span>

<h3>Description</h3>

<p>Derive an imputed value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_qual_imputation(character_value, imputation_type = 1, factor = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_qual_imputation_+3A_character_value">character_value</code></td>
<td>
<p>Character version of value to be imputed</p>
</td></tr>
<tr><td><code id="compute_qual_imputation_+3A_imputation_type">imputation_type</code></td>
<td>
<p>(default value=1)
Valid Values:
1: Strip &lt;, &gt;, = and convert to numeric.
2: imputation_type=1 and if the character value contains a &lt; or &gt;, the number of
of decimals associated with the character value is found and then a factor of
1/10^(number of decimals + 1) will be added/subtracted from the numeric value.
If no decimals exists, a factor of 1/10 will be added/subtracted from the value.</p>
</td></tr>
<tr><td><code id="compute_qual_imputation_+3A_factor">factor</code></td>
<td>
<p>Numeric value (default=0), when using <code>imputation_type</code> = 1, this
value can be added or subtracted when the qualifier is removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The imputed value
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_qual_imputation("&lt;40")
</code></pre>

<hr>
<h2 id='compute_qual_imputation_dec'>Compute Factor for Value Imputations When Character Value Contains &lt; or &gt;</h2><span id='topic+compute_qual_imputation_dec'></span>

<h3>Description</h3>

<p>Function to compute factor for value imputation when character
value contains &lt; or &gt;.  The factor is calculated using the number of decimals.
If there are no decimals, the factor is 1, otherwise the factor = 1/10^decimal
place.  For example, the factor for 100 = 1, the factor for 5.4 = 1/10^1,
the factor for 5.44 = 1/10^2.  This results in no additional false precision
added to the value.  This is an intermediate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_qual_imputation_dec(character_value_decimal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_qual_imputation_dec_+3A_character_value_decimal">character_value_decimal</code></td>
<td>
<p>Character value to determine decimal precision</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Derive an imputed value
</p>


<h3>Value</h3>

<p>Decimal precision value to add or subtract
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_qual_imputation_dec("&lt;40.1")
</code></pre>

<hr>
<h2 id='compute_rr'>Compute RR Interval From Heart Rate</h2><span id='topic+compute_rr'></span>

<h3>Description</h3>

<p>Computes RR interval from heart rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_rr(hr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_rr_+3A_hr">hr</code></td>
<td>
<p>Heart rate
</p>
<p>A numeric vector is expected. It is expected that heart rate is measured in
beats/min.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>RR interval in msec:
</p>
<p style="text-align: center;"><code class="reqn">\frac{60000}{HR}</code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+derive_param_rr">derive_param_rr()</a></code>
</p>
<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_scale">compute_scale</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_rr(hr = 70.14)
</code></pre>

<hr>
<h2 id='compute_scale'>Compute Scale Parameters</h2><span id='topic+compute_scale'></span>

<h3>Description</h3>

<p>Computes the average of a set of source values and transforms the result
from the source range to the target range. For example, for calculating the
average of a set of questionnaire response scores and re-coding the average
response to obtain a subscale score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_scale(
  source,
  source_range = NULL,
  target_range = NULL,
  flip_direction = FALSE,
  min_n = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_scale_+3A_source">source</code></td>
<td>
<p>A vector of values to be scaled
</p>
<p>A numeric vector is expected.</p>
</td></tr>
<tr><td><code id="compute_scale_+3A_source_range">source_range</code></td>
<td>
<p>The permitted source range
</p>
<p>A numeric vector containing two elements is expected, representing the
lower and upper bounds of the permitted source range. Alternatively, if no
argument is specified for <code>source_range</code> and <code>target_range</code>, no
transformation will be performed.</p>
</td></tr>
<tr><td><code id="compute_scale_+3A_target_range">target_range</code></td>
<td>
<p>The target range
</p>
<p>A numeric vector containing two elements is expected, representing the
lower and upper bounds of the target range. Alternatively, if no
argument is specified for <code>source_range</code> and <code>target_range</code>, no
transformation will be performed.</p>
</td></tr>
<tr><td><code id="compute_scale_+3A_flip_direction">flip_direction</code></td>
<td>
<p>Flip direction of the scale?
</p>
<p>The transformed values will be reversed within the target range, e.g.
within the range 0 to 100, 25 would be reversed to 75.
</p>
<p>This argument will be ignored if <code>source_range</code> and <code>target_range</code> aren't
specified.
</p>
<p>Default: <code>FALSE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="compute_scale_+3A_min_n">min_n</code></td>
<td>
<p>Minimum number of values for computation
</p>
<p>The minimum number of non-missing values in source for the computation to
be carried out. If the number of non-missing values is below <code>min_n</code>,
the result will be set to missing, i.e. <code>NA</code>.
</p>
<p>A positive integer is expected.
</p>
<p>Default: 1</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a numeric value. If source contains less than <code>min_n</code> values,
the result is set to <code>NA</code>. If <code>source_range</code> and <code>target_range</code> aren't
specified, the mean will be computed without any transformation being
performed.
</p>


<h3>Value</h3>

<p>The average of source transformed to the target range or <code>NA</code> if
source doesn't contain <code>min_n</code> values.
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns a vector: 
<code><a href="#topic+compute_bmi">compute_bmi</a>()</code>,
<code><a href="#topic+compute_bsa">compute_bsa</a>()</code>,
<code><a href="#topic+compute_egfr">compute_egfr</a>()</code>,
<code><a href="#topic+compute_framingham">compute_framingham</a>()</code>,
<code><a href="#topic+compute_map">compute_map</a>()</code>,
<code><a href="#topic+compute_qtc">compute_qtc</a>()</code>,
<code><a href="#topic+compute_qual_imputation">compute_qual_imputation</a>()</code>,
<code><a href="#topic+compute_qual_imputation_dec">compute_qual_imputation_dec</a>()</code>,
<code><a href="#topic+compute_rr">compute_rr</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>compute_scale(
  source = c(1, 4, 3, 5),
  source_range = c(1, 5),
  target_range = c(0, 100),
  flip_direction = TRUE,
  min_n = 3
)

</code></pre>

<hr>
<h2 id='compute_tmf'>Derive the Time Imputation Flag</h2><span id='topic+compute_tmf'></span>

<h3>Description</h3>

<p>Derive the time imputation flag (<code>'--TMF'</code>) comparing a date character vector
(<code>'--DTC'</code>) with a Datetime vector (<code>'--DTM'</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_tmf(dtc, dtm, ignore_seconds_flag = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_tmf_+3A_dtc">dtc</code></td>
<td>
<p>The date character vector (<code>'--DTC'</code>).
</p>
<p>A character date is expected in a format like <code>yyyy-mm-ddThh:mm:ss</code> (partial or complete).</p>
</td></tr>
<tr><td><code id="compute_tmf_+3A_dtm">dtm</code></td>
<td>
<p>The Date vector to compare (<code>'--DTM'</code>).
</p>
<p>A datetime object is expected.</p>
</td></tr>
<tr><td><code id="compute_tmf_+3A_ignore_seconds_flag">ignore_seconds_flag</code></td>
<td>
<p>ADaM IG states that given SDTM (<code>'--DTC'</code>) variable,
if only hours and minutes are ever collected, and seconds are imputed in
(<code>'--DTM'</code>) as 00, then it is not necessary to set (<code>'--TMF'</code>) to <code>'S'</code>. A user can set this
to <code>TRUE</code> so the <code>'S'</code> Flag is dropped from (<code>'--TMF'</code>).
</p>
<p><em>Permitted Values</em>: A logical value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>The time imputation flag (<code>'--TMF'</code>) (character value of <code>'H'</code>, <code>'M'</code> , <code>'S'</code> or <code>NA</code>)
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

compute_tmf(dtc = "2019-07-18T15:25", dtm = ymd_hms("2019-07-18T15:25:00"))
compute_tmf(dtc = "2019-07-18T15", dtm = ymd_hms("2019-07-18T15:25:00"))
compute_tmf(dtc = "2019-07-18", dtm = ymd("2019-07-18"))
compute_tmf(dtc = "2022-05--T00:00", dtm = ymd_hms("2022-05-15T23:59:59"))
compute_tmf(dtc = "2022-05--T23:00", dtm = ymd_hms("2022-05-15T23:59:59"))
compute_tmf(dtc = "2022-05--T23:59:00", dtm = ymd_hms("2022-05-15T23:59:59"))

</code></pre>

<hr>
<h2 id='consolidate_metadata'>Consolidate Multiple Meta Datasets Into a Single One</h2><span id='topic+consolidate_metadata'></span>

<h3>Description</h3>

<p>The purpose of the function is to consolidate multiple meta datasets into a
single one. For example, from global and project specific parameter mappings
a single lookup table can be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consolidate_metadata(
  datasets,
  key_vars,
  source_var = SOURCE,
  check_vars = "warning",
  check_keys,
  check_type = "error"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="consolidate_metadata_+3A_datasets">datasets</code></td>
<td>
<p>List of datasets to consolidate
</p>
<p><em>Permitted Values</em>: A named list of datasets</p>
</td></tr>
<tr><td><code id="consolidate_metadata_+3A_key_vars">key_vars</code></td>
<td>
<p>Key variables
</p>
<p>The specified variables must be a unique of all input datasets.
</p>
<p><em>Permitted Values</em>: A list of variables created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="consolidate_metadata_+3A_source_var">source_var</code></td>
<td>
<p>Source variable
</p>
<p>The specified variable is added to the output dataset. It is set the name
of the dataset the observation is originating from.
</p>
<p><em>Permitted Values</em>: A symbol</p>
</td></tr>
<tr><td><code id="consolidate_metadata_+3A_check_vars">check_vars</code></td>
<td>
<p>Check variables?
</p>
<p>If <code>"message"</code>, <code>"warning"</code>, or <code>"error"</code> is specified, a message is issued
if the variable names differ across the input datasets (<code>datasets</code>).
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"message"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="consolidate_metadata_+3A_check_keys">check_keys</code></td>
<td>
<p>Check keys?
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>check_type</code> instead.
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, a message is issued if the key
variables (<code>key_vars</code>) are not a unique key in all of the input datasets
(<code>datasets</code>).
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="consolidate_metadata_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, a message is issued if the key
variables (<code>key_vars</code>) are not a unique key in all of the input datasets
(<code>datasets</code>).
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All observations of the input datasets are put together into a
single dataset. If a by group (defined by <code>key_vars</code>) exists in more than
one of the input datasets, the observation from the last dataset is
selected.
</p>


<h3>Value</h3>

<p>A dataset which contains one row for each by group occurring in any
of the input datasets.
</p>


<h3>See Also</h3>

<p>Creating auxiliary datasets: 
<code><a href="#topic+create_period_dataset">create_period_dataset</a>()</code>,
<code><a href="#topic+create_query_data">create_query_data</a>()</code>,
<code><a href="#topic+create_single_dose_dataset">create_single_dose_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
glob_ranges &lt;- tribble(
  ~PARAMCD, ~ANRLO, ~ANRHI,
  "PULSE",      60,    100,
  "SYSBP",      90,    130,
  "DIABP",      60,     80
)
proj_ranges &lt;- tribble(
  ~PARAMCD, ~ANRLO, ~ANRHI,
  "SYSBP",     100,    140,
  "DIABP",      70,     90
)
stud_ranges &lt;- tribble(
  ~PARAMCD, ~ANRLO, ~ANRHI,
  "BMI",        18,     25
)

consolidate_metadata(
  datasets = list(
    global = glob_ranges,
    project = proj_ranges,
    study = stud_ranges
  ),
  key_vars = exprs(PARAMCD)
)
</code></pre>

<hr>
<h2 id='convert_blanks_to_na'>Convert Blank Strings Into NAs</h2><span id='topic+convert_blanks_to_na'></span><span id='topic+convert_blanks_to_na.default'></span><span id='topic+convert_blanks_to_na.character'></span><span id='topic+convert_blanks_to_na.list'></span><span id='topic+convert_blanks_to_na.data.frame'></span>

<h3>Description</h3>

<p>Turn SAS blank strings into proper R <code>NA</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_blanks_to_na(x)

## Default S3 method:
convert_blanks_to_na(x)

## S3 method for class 'character'
convert_blanks_to_na(x)

## S3 method for class 'list'
convert_blanks_to_na(x)

## S3 method for class 'data.frame'
convert_blanks_to_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_blanks_to_na_+3A_x">x</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default methods simply returns its input unchanged. The <code>character</code> method
turns every instance of <code>""</code> into <code>NA_character_</code> while preserving <em>all</em> attributes.
When given a data frame as input the function keeps all non-character columns
as is and applies the just described logic to <code>character</code> columns. Once again
all attributes such as labels are preserved.
</p>


<h3>Value</h3>

<p>An object of the same class as the input
</p>


<h3>See Also</h3>

<p>Utilities for Formatting Observations: 
<code><a href="#topic+convert_na_to_blanks">convert_na_to_blanks</a>()</code>,
<code><a href="#topic+yn_to_numeric">yn_to_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

convert_blanks_to_na(c("a", "b", "", "d", ""))

df &lt;- tribble(
  ~USUBJID,   ~RFICDTC,
  "1001", "2000-01-01",
  "1002", "2001-01-01",
  "1003",           ""
)
print(df)
convert_blanks_to_na(df)
</code></pre>

<hr>
<h2 id='convert_date_to_dtm'>Convert a Date into a Datetime Object</h2><span id='topic+convert_date_to_dtm'></span>

<h3>Description</h3>

<p>Convert a date (datetime, date, or date character) into a Date
vector (usually <code>'--DTM'</code>).
</p>
<p><strong>Note:</strong> This is a wrapper function for the function <code>convert_dtc_to_dtm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_date_to_dtm(
  dt,
  highest_imputation = "h",
  date_imputation = "first",
  time_imputation = "first",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_date_to_dtm_+3A_dt">dt</code></td>
<td>
<p>The date to convert.
</p>
<p>A date or character date is expected in a format like <code>yyyy-mm-ddThh:mm:ss</code>.</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified, no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"h"</code> (hour), <code>"m"</code> (minute), <code>"s"</code> (second), <code>"n"</code> (none, lowest
level)</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_time_imputation">time_imputation</code></td>
<td>
<p>The value to impute the time when a timepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with hour, min and sec specified as <code>"hh:mm:ss"</code>: e.g. <code>"00:00:00"</code>
for the start of the day,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>,<code>"last"</code> to impute to the start/end of a day.
</p>
</li></ul>

<p>The argument is ignored if <code>highest_imputation = "n"</code>.</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"00:00:00"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"23:59:59"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="convert_date_to_dtm_+3A_preserve">preserve</code></td>
<td>
<p>Preserve lower level date/time part when higher order part
is missing, e.g. preserve day if month is missing or
preserve minute when hour is missing.
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "mid"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>A datetime object
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert_date_to_dtm("2019-07-18T15:25:00")
convert_date_to_dtm(Sys.time())
convert_date_to_dtm(as.Date("2019-07-18"), time_imputation = "23:59:59")
convert_date_to_dtm("2019-07-18", time_imputation = "23:59:59")
convert_date_to_dtm("2019-07-18")
</code></pre>

<hr>
<h2 id='convert_dtc_to_dt'>Convert a Date Character Vector into a Date Object</h2><span id='topic+convert_dtc_to_dt'></span>

<h3>Description</h3>

<p>Convert a date character vector (usually '&ndash;DTC') into a Date vector (usually '&ndash;DT').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_dtc_to_dt(
  dtc,
  highest_imputation = "n",
  date_imputation = "first",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_dtc_to_dt_+3A_dtc">dtc</code></td>
<td>
<p>The &ndash;DTC date to convert.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dt_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"n"</code> (none, lowest level)</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dt_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dt_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dt_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dt_+3A_preserve">preserve</code></td>
<td>
<p>Preserve day if month is missing and day is present
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "MID"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>a date object
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert_dtc_to_dt("2019-07-18")
convert_dtc_to_dt("2019-07")
</code></pre>

<hr>
<h2 id='convert_dtc_to_dtm'>Convert a Date Character Vector into a Datetime Object</h2><span id='topic+convert_dtc_to_dtm'></span>

<h3>Description</h3>

<p>Convert a date character vector (usually <code>'--DTC'</code>) into a Date vector (usually <code>'--DTM'</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_dtc_to_dtm(
  dtc,
  highest_imputation = "h",
  date_imputation = "first",
  time_imputation = "first",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_dtc_to_dtm_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to convert.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified, no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"h"</code> (hour), <code>"m"</code> (minute), <code>"s"</code> (second), <code>"n"</code> (none, lowest
level)</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_time_imputation">time_imputation</code></td>
<td>
<p>The value to impute the time when a timepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with hour, min and sec specified as <code>"hh:mm:ss"</code>: e.g. <code>"00:00:00"</code>
for the start of the day,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>,<code>"last"</code> to impute to the start/end of a day.
</p>
</li></ul>

<p>The argument is ignored if <code>highest_imputation = "n"</code>.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"00:00:00"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"23:59:59"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="convert_dtc_to_dtm_+3A_preserve">preserve</code></td>
<td>
<p>Preserve lower level date/time part when higher order part
is missing, e.g. preserve day if month is missing or
preserve minute when hour is missing.
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "mid"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>A datetime object
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convert_dtc_to_dtm("2019-07-18T15:25:00")
convert_dtc_to_dtm("2019-07-18T00:00:00") # note Time = 00:00:00 is not printed
convert_dtc_to_dtm("2019-07-18")
</code></pre>

<hr>
<h2 id='convert_na_to_blanks'>Convert NAs Into Blank Strings</h2><span id='topic+convert_na_to_blanks'></span><span id='topic+convert_na_to_blanks.default'></span><span id='topic+convert_na_to_blanks.character'></span><span id='topic+convert_na_to_blanks.list'></span><span id='topic+convert_na_to_blanks.data.frame'></span>

<h3>Description</h3>

<p>Turn <code>NA</code>s to blank strings .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_na_to_blanks(x)

## Default S3 method:
convert_na_to_blanks(x)

## S3 method for class 'character'
convert_na_to_blanks(x)

## S3 method for class 'list'
convert_na_to_blanks(x)

## S3 method for class 'data.frame'
convert_na_to_blanks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_na_to_blanks_+3A_x">x</code></td>
<td>
<p>Any R object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default methods simply returns its input unchanged. The <code>character</code> method
turns every instance of <code>NA_character_</code> or <code>NA</code> into <code>""</code> while preserving <em>all</em> attributes.
When given a data frame as input the function keeps all non-character columns
as is and applies the just described logic to <code>character</code>
all attributes such as labels are preserved.
</p>


<h3>Value</h3>

<p>An object of the same class as the input
</p>


<h3>See Also</h3>

<p>Utilities for Formatting Observations: 
<code><a href="#topic+convert_blanks_to_na">convert_blanks_to_na</a>()</code>,
<code><a href="#topic+yn_to_numeric">yn_to_numeric</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

convert_na_to_blanks(c("a", "b", NA, "d", NA))

df &lt;- tribble(
  ~USUBJID,   ~RFICDTC,
  "1001", "2000-01-01",
  "1002", "2001-01-01",
  "1003",           NA
)
print(df)
convert_na_to_blanks(df)
</code></pre>

<hr>
<h2 id='count_vals'>Count Number of Observations Where a Variable Equals a Value</h2><span id='topic+count_vals'></span>

<h3>Description</h3>

<p>Count number of observations where a variable equals a value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_vals(var, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_vals_+3A_var">var</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="count_vals_+3A_val">val</code></td>
<td>
<p>A value</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(admiral)
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "NE",
  "1",      4,        "CR",
  "1",      5,        "NE",
  "2",      1,        "CR",
  "2",      2,        "PR",
  "2",      3,        "CR",
  "3",      1,        "CR",
  "4",      1,        "CR",
  "4",      2,        "NE",
  "4",      3,        "NE",
  "4",      4,        "CR",
  "4",      5,        "PR"
)

# add variable providing the number of NEs for each subject
group_by(data, USUBJID) %&gt;%
  mutate(nr_nes = count_vals(var = AVALC, val = "NE"))
</code></pre>

<hr>
<h2 id='create_period_dataset'>Create a Reference Dataset for Subperiods, Periods, or Phases</h2><span id='topic+create_period_dataset'></span>

<h3>Description</h3>

<p>The function creates a reference dataset for subperiods, periods, or phases
from the <code>ADSL</code> dataset. The reference dataset can be used to derive
subperiod, period, or phase variables like <code>ASPER</code>, <code>ASPRSDT</code>, <code>ASPREDT</code>,
<code>APERIOD</code>, <code>APERSDT</code>, <code>APEREDT</code>, <code>TRTA</code>, <code>APHASEN</code>, <code>PHSDTM</code>, <code>PHEDTM</code>, ...
in OCCDS and BDS datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_period_dataset(
  dataset,
  new_vars,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_period_dataset_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>new_vars</code> and <code>subject_keys</code> arguments are expected to be in the dataset.
For each element of <code>new_vars</code> at least one variable of the form of the right
hand side value must be available in the dataset.</p>
</td></tr>
<tr><td><code id="create_period_dataset_+3A_new_vars">new_vars</code></td>
<td>
<p>New variables
</p>
<p>A named list of variables like <code>exprs(PHSDT = PHwSDT, PHEDT = PHwEDT, APHASE = APHASEw)</code> is expected. The left hand side of the elements defines a
variable of the output dataset, the right hand side defines the source
variables from the ADSL dataset in CDISC notation.
</p>
<p>If the lower case letter &quot;w&quot;  is used it refers to a phase variable, if the
lower case letters &quot;xx&quot; are used it refers to a period variable, and if
both &quot;xx&quot; and &quot;w&quot; are used it refers to a subperiod variable.
</p>
<p>Only one type must be used, e.g., all right hand side values must refer to
period variables. It is not allowed to mix for example period and subperiod
variables. If period <em>and</em> subperiod variables are required, separate
reference datasets must be created.</p>
</td></tr>
<tr><td><code id="create_period_dataset_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of expressions where the expressions are symbols as returned by
<code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each subject and each subperiod/period/phase where at least one
of the source variable is not <code>NA</code> an observation is added to the output
dataset.
</p>
<p>Depending on the type of the source variable (subperiod, period, or phase)
the variable <code>ASPER</code>, <code>APERIOD</code>, or <code>APHASEN</code> is added and set to the
number of the subperiod, period, or phase.
</p>
<p>The variables specified for <code>new_vars</code> (left hand side) are added to the
output dataset and set to the value of the source variable (right hand
side).
</p>


<h3>Value</h3>

<p>A period reference dataset (see &quot;Details&quot; section)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_period">derive_vars_period()</a></code>
</p>
<p>Creating auxiliary datasets: 
<code><a href="#topic+consolidate_metadata">consolidate_metadata</a>()</code>,
<code><a href="#topic+create_query_data">create_query_data</a>()</code>,
<code><a href="#topic+create_single_dose_dataset">create_single_dose_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

# Create reference dataset for periods
adsl &lt;- tribble(
  ~USUBJID, ~AP01SDT,     ~AP01EDT,     ~AP02SDT,     ~AP02EDT,     ~TRT01A, ~TRT02A,
  "1",      "2021-01-04", "2021-02-06", "2021-02-07", "2021-03-07", "A",     "B",
  "2",      "2021-02-02", "2021-03-02", "2021-03-03", "2021-04-01", "B",     "A",
) %&gt;%
  mutate(
    across(matches("AP\\d\\d[ES]DT"), ymd)
  ) %&gt;%
  mutate(
    STUDYID = "xyz"
  )

create_period_dataset(
  adsl,
  new_vars = exprs(APERSDT = APxxSDT, APEREDT = APxxEDT, TRTA = TRTxxA)
)

# Create reference dataset for phases
adsl &lt;- tribble(
  ~USUBJID, ~PH1SDT,      ~PH1EDT,      ~PH2SDT,      ~PH2EDT,      ~APHASE1,    ~APHASE2,
  "1",      "2021-01-04", "2021-02-06", "2021-02-07", "2021-03-07", "TREATMENT", "FUP",
  "2",      "2021-02-02", "2021-03-02", NA,           NA,           "TREATMENT", NA
) %&gt;%
  mutate(
    across(matches("PH\\d[ES]DT"), ymd)
  ) %&gt;%
  mutate(
    STUDYID = "xyz"
  )

create_period_dataset(
  adsl,
  new_vars = exprs(PHSDT = PHwSDT, PHEDT = PHwEDT, APHASE = APHASEw)
)

# Create reference datasets for subperiods
adsl &lt;- tribble(
  ~USUBJID, ~P01S1SDT,    ~P01S1EDT,    ~P01S2SDT,    ~P01S2EDT,    ~P02S1SDT,    ~P02S1EDT,
  "1",      "2021-01-04", "2021-01-19", "2021-01-20", "2021-02-06", "2021-02-07", "2021-03-07",
  "2",      "2021-02-02", "2021-03-02", NA,           NA,           "2021-03-03", "2021-04-01"
) %&gt;%
  mutate(
    across(matches("P\\d\\dS\\d[ES]DT"), ymd)
  ) %&gt;%
  mutate(
    STUDYID = "xyz"
  )

create_period_dataset(
  adsl,
  new_vars = exprs(ASPRSDT = PxxSwSDT, ASPREDT = PxxSwEDT)
)
</code></pre>

<hr>
<h2 id='create_query_data'>Creates a queries dataset as input dataset to the <code>dataset_queries</code> argument in
<code>derive_vars_query()</code></h2><span id='topic+create_query_data'></span>

<h3>Description</h3>

<p>Creates a queries dataset as input dataset to the <code>dataset_queries</code> argument
in the <code>derive_vars_query()</code> function as defined in the <a href="../articles/queries_dataset.html">Queries Dataset Documentation</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_query_data(queries, version = NULL, get_terms_fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_query_data_+3A_queries">queries</code></td>
<td>
<p>List of queries
</p>
<p>A list of <code>query()</code> objects is expected.</p>
</td></tr>
<tr><td><code id="create_query_data_+3A_version">version</code></td>
<td>
<p>Dictionary version
</p>
<p>The dictionary version used for coding the terms should be specified.
If any of the queries is a basket (SMQ, SDG, ....) or a customized query
including a basket, the parameter needs to be specified.
</p>
<p><em>Permitted Values</em>: A character string (the expected format is
company-specific)</p>
</td></tr>
<tr><td><code id="create_query_data_+3A_get_terms_fun">get_terms_fun</code></td>
<td>
<p>Function which returns the terms
</p>
<p>For each query specified for the <code>queries</code> parameter referring to a basket
(i.e., those where the <code>definition</code> field is set to a <code>basket_select()</code>
object or a list which contains at least one <code>basket_select()</code> object) the
specified function is called to retrieve the terms defining the query.
This function is not provided by admiral as it is company specific, i.e.,
it has to be implemented at company level.
</p>
<p>The function must return a dataset with all the terms defining the basket.
The output dataset must contain the following variables.
</p>

<ul>
<li> <p><code>SRCVAR</code>: the variable to be used for defining a term of the basket,
e.g., <code>AEDECOD</code>
</p>
</li>
<li> <p><code>TERMCHAR</code>: the name of the term if the variable <code>SRCVAR</code> is
referring to is character
</p>
</li>
<li> <p><code>TERMNUM</code> the numeric id of the term if the variable <code>SRCVAR</code> is
referring to is numeric
</p>
</li>
<li> <p><code>GRPNAME</code>: the name of the basket. The values must be the same for
all observations.
</p>
</li></ul>

<p>The function must provide the following parameters
</p>

<ul>
<li> <p><code>basket_select</code>: A <code>basket_select()</code> object.
</p>
</li>
<li> <p><code>version</code>: The dictionary version. The value specified for the
<code>version</code> in the <code>create_query_data()</code> call is passed to this
parameter.
</p>
</li>
<li> <p><code>keep_id</code>: If set to <code>TRUE</code>, the output dataset must contain the
<code>GRPID</code> variable. The variable must be set to the numeric id of the basket.
</p>
</li>
<li> <p><code>temp_env</code>: A temporary environment is passed to this parameter. It can
be used to store data which is used for all baskets in the
<code>create_query_data()</code> call. For example if SMQs need to be read from a
database all SMQs can be read and stored in the environment when the first
SMQ is handled. For the other SMQs the terms can be retrieved from the
environment instead of accessing the database again.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>query()</code> object listed in the <code>queries</code> argument, the terms belonging
to the query (<code>SRCVAR</code>, <code>TERMCHAR</code>, <code>TERMNUM</code>) are determined with respect
to the <code>definition</code> field of the query: if the definition field of the
<code>query()</code> object is
</p>

<ul>
<li><p> a <code>basket_select()</code> object, the terms are read from the basket
database by calling the function specified for the <code>get_terms_fun</code> parameter.
</p>
</li>
<li><p> a data frame, the terms stored in the data frame are used.
</p>
</li>
<li><p> a list of data frames and <code>basket_select()</code> objects, all terms from
the data frames and all terms read from the basket database referenced by the
<code>basket_select()</code> objects are collated.
</p>
</li></ul>

<p>The following variables (as described in <a href="../articles/queries_dataset.html">Queries Dataset Documentation</a>) are created:
</p>

<ul>
<li> <p><code>PREFIX</code>: Prefix of the variables to be created by
<code>derive_vars_query()</code> as specified by the <code>prefix</code> element.
</p>
</li>
<li> <p><code>GRPNAME</code>: Name of the query as specified by the <code>name</code> element.
</p>
</li>
<li> <p><code>GRPID</code>: Id of the query as specified by the <code>id</code> element. If the <code>id</code>
element is not specified for a query, the variable is set to <code>NA</code>. If the
<code>id</code> element is not specified for any query, the variable is not created.
</p>
</li>
<li> <p><code>SCOPE</code>: scope of the query as specified by the <code>scope</code> element of
the <code>basket_select()</code> object. For queries not defined by a <code>basket_select()</code>
object, the variable is set to <code>NA</code>. If none of the queries is defined by a
<code>basket_select()</code> object, the variable is not created.
</p>
</li>
<li> <p><code>SCOPEN</code>: numeric scope of the query. It is set to <code>1</code> if the
scope is broad. Otherwise it is set to <code>2</code>. If the <code>add_scope_num</code> element
equals <code>FALSE</code>, the variable is set to <code>NA</code>. If the <code>add_scope_num</code> element
equals <code>FALSE</code> for all baskets or none of the queries is an basket , the variable
is not created.
</p>
</li>
<li> <p><code>SRCVAR</code>: Name of the variable used to identify the terms.
</p>
</li>
<li> <p><code>TERMCHAR</code>: Value of the term variable if it is a character variable.
</p>
</li>
<li> <p><code>TERMNUM</code>: Value of the term variable if it is a numeric variable.
</p>
</li>
<li> <p><code>VERSION</code>: Set to the value of the <code>version</code> argument. If it is not
specified, the variable is not created.
</p>
</li></ul>



<h3>Value</h3>

<p>A dataset to be used as input dataset to the <code>dataset_queries</code>
argument in <code>derive_vars_query()</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_query">derive_vars_query()</a></code>, <code><a href="#topic+query">query()</a></code>, <code><a href="#topic+basket_select">basket_select()</a></code>, <a href="../articles/queries_dataset.html">Queries Dataset Documentation</a>
</p>
<p>Creating auxiliary datasets: 
<code><a href="#topic+consolidate_metadata">consolidate_metadata</a>()</code>,
<code><a href="#topic+create_period_dataset">create_period_dataset</a>()</code>,
<code><a href="#topic+create_single_dose_dataset">create_single_dose_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(pharmaversesdtm)
library(admiral)

# creating a query dataset for a customized query
cqterms &lt;- tribble(
  ~TERMCHAR, ~TERMNUM,
  "APPLICATION SITE ERYTHEMA", 10003041L,
  "APPLICATION SITE PRURITUS", 10003053L
) %&gt;%
  mutate(SRCVAR = "AEDECOD")

cq &lt;- query(
  prefix = "CQ01",
  name = "Application Site Issues",
  definition = cqterms
)

create_query_data(queries = list(cq))

# create a query dataset for SMQs
pregsmq &lt;- query(
  prefix = "SMQ02",
  id = auto,
  definition = basket_select(
    name = "Pregnancy and neonatal topics (SMQ)",
    scope = "NARROW",
    type = "smq"
  )
)

bilismq &lt;- query(
  prefix = "SMQ04",
  definition = basket_select(
    id = 20000121L,
    scope = "BROAD",
    type = "smq"
  )
)

# The get_terms function from pharmaversesdtm is used for this example.
# In a real application a company-specific function must be used.
create_query_data(
  queries = list(pregsmq, bilismq),
  get_terms_fun = pharmaversesdtm:::get_terms,
  version = "20.1"
)

# create a query dataset for SDGs
sdg &lt;- query(
  prefix = "SDG01",
  id = auto,
  definition = basket_select(
    name = "5-aminosalicylates for ulcerative colitis",
    scope = NA_character_,
    type = "sdg"
  )
)

# The get_terms function from pharmaversesdtm is used for this example.
# In a real application a company-specific function must be used.
create_query_data(
  queries = list(sdg),
  get_terms_fun = pharmaversesdtm:::get_terms,
  version = "2019-09"
)

# creating a query dataset for a customized query including SMQs
# The get_terms function from pharmaversesdtm is used for this example.
# In a real application a company-specific function must be used.
create_query_data(
  queries = list(
    query(
      prefix = "CQ03",
      name = "Special issues of interest",
      definition = list(
        basket_select(
          name = "Pregnancy and neonatal topics (SMQ)",
          scope = "NARROW",
          type = "smq"
        ),
        cqterms
      )
    )
  ),
  get_terms_fun = pharmaversesdtm:::get_terms,
  version = "20.1"
)
</code></pre>

<hr>
<h2 id='create_single_dose_dataset'>Create dataset of single doses</h2><span id='topic+create_single_dose_dataset'></span>

<h3>Description</h3>

<p>Derives dataset of single dose from aggregate dose information. This may be
necessary when e.g. calculating last dose before an adverse event in <code>ADAE</code>
or deriving a total dose parameter in <code>ADEX</code> when <code>EXDOSFRQ != ONCE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_single_dose_dataset(
  dataset,
  dose_freq = EXDOSFRQ,
  start_date = ASTDT,
  start_datetime = NULL,
  end_date = AENDT,
  end_datetime = NULL,
  lookup_table = dose_freq_lookup,
  lookup_column = CDISC_VALUE,
  nominal_time = NULL,
  keep_source_vars = expr_c(exprs(USUBJID), dose_freq, start_date, start_datetime,
    end_date, end_datetime)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_single_dose_dataset_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>dose_freq</code>, <code>start_date</code> and <code>end_date</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_dose_freq">dose_freq</code></td>
<td>
<p>The dose frequency
</p>
<p>The aggregate dosing frequency used for multiple doses in a row.
</p>
<p>Permitted Values: defined by lookup table.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_start_date">start_date</code></td>
<td>
<p>The start date
</p>
<p>A date object is expected. This object cannot contain <code>NA</code> values.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_start_datetime">start_datetime</code></td>
<td>
<p>The start date-time
</p>
<p>A date-time object is expected. This object cannot contain <code>NA</code> values.
</p>
<p>Refer to <code>derive_vars_dtm()</code> to impute and derive a date-time from a date
character vector to a date object.
</p>
<p>If the input dataset contains frequencies which refer to <code>DOSE_WINDOW</code>
equals <code>"HOUR"</code> or <code>"MINUTE"</code>, the parameter must be specified.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_end_date">end_date</code></td>
<td>
<p>The end date
</p>
<p>A date or date-time object is expected. This object cannot contain <code>NA</code> values.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_end_datetime">end_datetime</code></td>
<td>
<p>The end date-time
</p>
<p>A date-time object is expected. This object cannot contain <code>NA</code> values.
</p>
<p>Refer to <code>derive_vars_dtm()</code> to impute and derive a date-time from a date
character vector to a date object.
</p>
<p>If the input dataset contains frequencies which refer to <code>DOSE_WINDOW</code>
equals <code>"HOUR"</code> or <code>"MINUTE"</code>, the parameter must be specified.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_lookup_table">lookup_table</code></td>
<td>
<p>The dose frequency value lookup table
</p>
<p>The table used to look up <code>dose_freq</code> values and determine the appropriate
multiplier to be used for row generation. If a lookup table other than the
default is used, it must have columns <code>DOSE_WINDOW</code>, <code>DOSE_COUNT</code>, and
<code>CONVERSION_FACTOR</code>. The default table <code>dose_freq_lookup</code> is described in
detail <a href="#topic+dose_freq_lookup">here</a>.
</p>
<p>Permitted Values for <code>DOSE_WINDOW</code>: <code>"MINUTE"</code>, <code>"HOUR"</code>, <code>"DAY"</code>,
<code>"WEEK"</code>, <code>"MONTH"</code>, <code>"YEAR"</code></p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_lookup_column">lookup_column</code></td>
<td>
<p>The dose frequency value column in the lookup table
</p>
<p>The column of <code>lookup_table</code>.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_nominal_time">nominal_time</code></td>
<td>
<p>The nominal relative time from first dose (<code>NFRLT</code>)
</p>
<p>Used for PK analysis, this will be in hours and should be 0 for
the first dose.  It can be derived as <code>(VISITDY - 1) * 24</code> for example.
This will be expanded as the single dose dataset is created.  For example
an <code>EXDOFRQ</code> of <code>"QD"</code> will result in the nominal_time being incremented by
24 hours for each expanded record.
</p>
<p>The value can be NULL if not needed.</p>
</td></tr>
<tr><td><code id="create_single_dose_dataset_+3A_keep_source_vars">keep_source_vars</code></td>
<td>
<p>List of variables to be retained from source dataset
</p>
<p>This parameter can be specified if additional information is required in
the output dataset. For example <code>EXTRT</code> for studies with more than one
drug.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each aggregate dose row is split into multiple rows which each
represent a single dose.The number of completed dose periods between
<code>start_date</code> or <code>start_datetime</code> and <code>end_date</code> or <code>end_datetime</code> is
calculated with <code>compute_duration</code> and multiplied by <code>DOSE_COUNT</code>.
For <code>DOSE_WINDOW</code> values of <code>"WEEK"</code>, <code>"MONTH"</code>, and <code>"YEAR"</code>,
<code>CONVERSION_FACTOR</code> is used to convert into days the time object
to be added to <code>start_date</code>.
</p>
<p>Observations with dose frequency <code>"ONCE"</code> are copied to the output dataset
unchanged.
</p>


<h3>Value</h3>

<p>The input dataset with a single dose per row.
</p>


<h3>See Also</h3>

<p>Creating auxiliary datasets: 
<code><a href="#topic+consolidate_metadata">consolidate_metadata</a>()</code>,
<code><a href="#topic+create_period_dataset">create_period_dataset</a>()</code>,
<code><a href="#topic+create_query_data">create_query_data</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with default lookup

library(lubridate)
library(stringr)
library(tibble)
library(dplyr)

data &lt;- tribble(
  ~USUBJID, ~EXDOSFRQ, ~ASTDT, ~ASTDTM, ~AENDT, ~AENDTM,
  "P01", "Q2D", ymd("2021-01-01"), ymd_hms("2021-01-01 10:30:00"),
  ymd("2021-01-07"), ymd_hms("2021-01-07 11:30:00"),
  "P01", "Q3D", ymd("2021-01-08"), ymd_hms("2021-01-08 12:00:00"),
  ymd("2021-01-14"), ymd_hms("2021-01-14 14:00:00"),
  "P01", "EVERY 2 WEEKS", ymd("2021-01-15"), ymd_hms("2021-01-15 09:57:00"),
  ymd("2021-01-29"), ymd_hms("2021-01-29 10:57:00")
)

create_single_dose_dataset(data)

# Example with custom lookup

custom_lookup &lt;- tribble(
  ~Value,   ~DOSE_COUNT, ~DOSE_WINDOW, ~CONVERSION_FACTOR,
  "Q30MIN", (1 / 30),    "MINUTE",                      1,
  "Q90MIN", (1 / 90),    "MINUTE",                      1
)

data &lt;- tribble(
  ~USUBJID, ~EXDOSFRQ, ~ASTDT, ~ASTDTM, ~AENDT, ~AENDTM,
  "P01", "Q30MIN", ymd("2021-01-01"), ymd_hms("2021-01-01T06:00:00"),
  ymd("2021-01-01"), ymd_hms("2021-01-01T07:00:00"),
  "P02", "Q90MIN", ymd("2021-01-01"), ymd_hms("2021-01-01T06:00:00"),
  ymd("2021-01-01"), ymd_hms("2021-01-01T09:00:00")
)

create_single_dose_dataset(data,
  lookup_table = custom_lookup,
  lookup_column = Value,
  start_datetime = ASTDTM,
  end_datetime = AENDTM
)
# Example with nominal time

data &lt;- tribble(
  ~USUBJID, ~EXDOSFRQ, ~NFRLT, ~ASTDT, ~ASTDTM, ~AENDT, ~AENDTM,
  "P01", "BID", 0, ymd("2021-01-01"), ymd_hms("2021-01-01 08:00:00"),
  ymd("2021-01-07"), ymd_hms("2021-01-07 20:00:00"),
  "P01", "BID", 168, ymd("2021-01-08"), ymd_hms("2021-01-08 08:00:00"),
  ymd("2021-01-14"), ymd_hms("2021-01-14 20:00:00"),
  "P01", "BID", 336, ymd("2021-01-15"), ymd_hms("2021-01-15 08:00:00"),
  ymd("2021-01-29"), ymd_hms("2021-01-29 20:00:00")
)

create_single_dose_dataset(data,
  dose_freq = EXDOSFRQ,
  start_date = ASTDT,
  start_datetime = ASTDTM,
  end_date = AENDT,
  end_datetime = AENDTM,
  lookup_table = dose_freq_lookup,
  lookup_column = CDISC_VALUE,
  nominal_time = NFRLT,
  keep_source_vars = exprs(
    USUBJID, EXDOSFRQ, ASTDT, ASTDTM, AENDT, AENDTM, NFRLT
  )
)

# Example - derive a single dose dataset with imputations

# For either single drug administration records, or multiple drug administration
# records covering a range of dates, fill-in of missing treatment end datetime
# `EXENDTC` by substitution with an acceptable alternate, for example date of
# death, date of datacut may be required. This example shows the
# maximum possible number of single dose records to be derived. The example
# requires the date of datacut `DCUTDT` to be specified correctly, or
# if not appropriate to use `DCUTDT` as missing treatment end data and missing
# treatment end datetime could set equal to treatment start date and treatment
# start datetime. ADSL variables `DTHDT` and `DCUTDT` are preferred for
# imputation use.
#
# All available trial treatments are included, allowing multiple different
# last dose variables to be created in for example `use_ad_template("ADAE")`
# if required.

adsl &lt;- tribble(
  ~STUDYID, ~USUBJID, ~DTHDT,
  "01", "1211", ymd("2013-01-14"),
  "01", "1083", ymd("2013-08-02"),
  "01", "1445", ymd("2014-11-01"),
  "01", "1015", NA,
  "01", "1023", NA
)

ex &lt;- tribble(
  ~STUDYID, ~USUBJID, ~EXSEQ, ~EXTRT, ~EXDOSE, ~EXDOSU, ~EXDOSFRQ, ~EXSTDTC, ~EXENDTC,
  "01", "1015", 1, "PLAC", 0, "mg", "QD", "2014-01-02", "2014-01-16",
  "01", "1015", 2, "PLAC", 0, "mg", "QD", "2014-06-17", "2014-06-18",
  "01", "1015", 3, "PLAC", 0, "mg", "QD", "2014-06-19", NA_character_,
  "01", "1023", 1, "PLAC", 0, "mg", "QD", "2012-08-05", "2012-08-27",
  "01", "1023", 2, "PLAC", 0, "mg", "QD", "2012-08-28", "2012-09-01",
  "01", "1211", 1, "XANO", 54, "mg", "QD", "2012-11-15", "2012-11-28",
  "01", "1211", 2, "XANO", 54, "mg", "QD", "2012-11-29", NA_character_,
  "01", "1445", 1, "PLAC", 0, "mg", "QD", "2014-05-11", "2014-05-25",
  "01", "1445", 2, "PLAC", 0, "mg", "QD", "2014-05-26", "2014-11-01",
  "01", "1083", 1, "PLAC", 0, "mg", "QD", "2013-07-22", "2013-08-01"
)

adsl_death &lt;- adsl %&gt;%
  mutate(
    DTHDTM = convert_date_to_dtm(DTHDT),
    # Remove `DCUT` setup line below if ADSL `DCUTDT` is populated.
    DCUTDT = convert_dtc_to_dt("2015-03-06"), # Example only, enter date.
    DCUTDTM = convert_date_to_dtm(DCUTDT)
  )

# Select valid dose records, non-missing `EXSTDTC` and `EXDOSE`.
ex_mod &lt;- ex %&gt;%
  filter(!is.na(EXSTDTC) &amp; !is.na(EXDOSE)) %&gt;%
  derive_vars_merged(adsl_death, by_vars = exprs(STUDYID, USUBJID)) %&gt;%
  # Example, set up missing `EXDOSFRQ` as QD daily dosing regime.
  # Replace with study dosing regime per trial treatment.
  mutate(EXDOSFRQ = if_else(is.na(EXDOSFRQ), "QD", EXDOSFRQ)) %&gt;%
  # Create EXxxDTM variables and replace missing `EXENDTM`.
  derive_vars_dtm(
    dtc = EXSTDTC,
    new_vars_prefix = "EXST",
    date_imputation = "first",
    time_imputation = "first",
    flag_imputation = "none",
  ) %&gt;%
  derive_vars_dtm_to_dt(exprs(EXSTDTM)) %&gt;%
  derive_vars_dtm(
    dtc = EXENDTC,
    new_vars_prefix = "EXEN",
    # Maximum imputed treatment end date must not be not greater than
    # date of death or after the datacut date.
    max_dates = exprs(DTHDTM, DCUTDTM),
    date_imputation = "last",
    time_imputation = "last",
    flag_imputation = "none",
    highest_imputation = "Y",
  ) %&gt;%
  derive_vars_dtm_to_dt(exprs(EXENDTM)) %&gt;%
  # Select only unique values.
  # Removes duplicated records before final step.
  distinct(
    STUDYID, USUBJID, EXTRT, EXDOSE, EXDOSFRQ, DCUTDT, DTHDT, EXSTDT,
    EXSTDTM, EXENDT, EXENDTM, EXSTDTC, EXENDTC
  )

create_single_dose_dataset(
  ex_mod,
  start_date = EXSTDT,
  start_datetime = EXSTDTM,
  end_date = EXENDT,
  end_datetime = EXENDTM,
  keep_source_vars = exprs(
    STUDYID, USUBJID, EXTRT, EXDOSE, EXDOSFRQ,
    DCUTDT, EXSTDT, EXSTDTM, EXENDT, EXENDTM, EXSTDTC, EXENDTC
  )
)
</code></pre>

<hr>
<h2 id='date_source'>Create a <code>date_source</code> object</h2><span id='topic+date_source'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>date_source()</code>
function has been superseded in favor of <code>derive_vars_extreme_event()</code>.
</p>
<p>Create a <code>date_source</code> object as input for <code>derive_var_extreme_dt()</code> and
<code>derive_var_extreme_dtm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_source(
  dataset_name,
  filter = NULL,
  date,
  traceability_vars = NULL,
  set_values_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the dataset, i.e. a string, used to search for
the date.</p>
</td></tr>
<tr><td><code id="date_source_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for filtering <code>dataset</code>.</p>
</td></tr>
<tr><td><code id="date_source_+3A_date">date</code></td>
<td>
<p>A variable or an expression providing a date. A date or a
datetime can be specified. An unquoted symbol or expression is expected.</p>
</td></tr>
<tr><td><code id="date_source_+3A_traceability_vars">traceability_vars</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the
traceability variables, e.g. <code>exprs(LALVDOM = "AE", LALVSEQ = AESEQ, LALVVAR = "AESTDTC")</code>. The values must be a symbol, a character string, a numeric,
an expression, or <code>NA</code>.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.</p>
</td></tr>
<tr><td><code id="date_source_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>date_source</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm()</a></code>, <code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# treatment end date from ADSL
trt_end_date &lt;- date_source(
  dataset_name = "adsl",
  date = TRTEDT
)

# lab date from LB where assessment was taken, i.e. not "NOT DONE"
lb_date &lt;- date_source(
  dataset_name = "lb",
  filter = LBSTAT != "NOT DONE" | is.na(LBSTAT),
  date = convert_dtc_to_dt(LBDTC)
)

# death date from ADSL including traceability variables
death_date &lt;- date_source(
  dataset_name = "adsl",
  date = DTHDT,
  set_values_to = exprs(
    LALVDOM = "ADSL",
    LALVVAR = "DTHDT"
  )
)
</code></pre>

<hr>
<h2 id='death_event'>Pre-Defined Time-to-Event Source Objects</h2><span id='topic+death_event'></span><span id='topic+lastalive_censor'></span><span id='topic+ae_event'></span><span id='topic+ae_ser_event'></span><span id='topic+ae_gr1_event'></span><span id='topic+ae_gr2_event'></span><span id='topic+ae_gr3_event'></span><span id='topic+ae_gr4_event'></span><span id='topic+ae_gr5_event'></span><span id='topic+ae_gr35_event'></span><span id='topic+ae_sev_event'></span><span id='topic+ae_wd_event'></span>

<h3>Description</h3>

<p>These pre-defined <code>tte_source</code> objects can be used as input to <code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>death_event

lastalive_censor

ae_event

ae_ser_event

ae_gr1_event

ae_gr2_event

ae_gr3_event

ae_gr4_event

ae_gr5_event

ae_gr35_event

ae_sev_event

ae_wd_event
</code></pre>


<h3>Details</h3>

<p>To see the definition of the various objects simply print the object in the
R console, e.g. <code>print(death_event)</code>. For details of how to use these objects
please refer to <code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>, <code><a href="#topic+tte_source">tte_source()</a></code>, <code><a href="#topic+event_source">event_source()</a></code>, <code><a href="#topic+censor_source">censor_source()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This shows the definition of all pre-defined `tte_source` objects that ship
# with {admiral}
for (obj in list_tte_source_objects()$object) {
  cat(obj, "\n")
  print(get(obj))
  cat("\n")
}
</code></pre>

<hr>
<h2 id='default_qtc_paramcd'>Get Default Parameter Code for Corrected QT</h2><span id='topic+default_qtc_paramcd'></span>

<h3>Description</h3>

<p>Get Default Parameter Code for Corrected QT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_qtc_paramcd(method)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_qtc_paramcd_+3A_method">method</code></td>
<td>
<p>Method used to QT correction
</p>
<p>Permitted Values: <code>"Bazett"</code>, <code>"Fridericia"</code>, <code>"Sagie"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>"QTCBR"</code> if <code>method</code> is <code>"Bazett"</code>, <code>"QTCFR"</code> if it's <code>"Fridericia"</code> or
<code>"QTLCR"</code> if it's <code>"Sagie"</code>. An error otherwise.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_qtc">derive_param_qtc()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>default_qtc_paramcd("Sagie")
</code></pre>

<hr>
<h2 id='derivation_slice'>Create a <code>derivation_slice</code> Object</h2><span id='topic+derivation_slice'></span>

<h3>Description</h3>

<p>Create a <code>derivation_slice</code> object as input for <code>slice_derivation()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivation_slice(filter, args = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivation_slice_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for defining the observations of the
slice</p>
</td></tr>
<tr><td><code id="derivation_slice_+3A_args">args</code></td>
<td>
<p>Arguments of the derivation to be used for the slice
</p>
<p>A <code>params()</code> object is expected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>derivation_slice</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+slice_derivation">slice_derivation()</a></code>, <code><a href="#topic+params">params()</a></code>
</p>
<p>Higher Order Functions: 
<code><a href="#topic+call_derivation">call_derivation</a>()</code>,
<code><a href="#topic+restrict_derivation">restrict_derivation</a>()</code>,
<code><a href="#topic+slice_derivation">slice_derivation</a>()</code>
</p>

<hr>
<h2 id='derive_basetype_records'>Derive Basetype Variable</h2><span id='topic+derive_basetype_records'></span>

<h3>Description</h3>

<p>Baseline Type <code>BASETYPE</code> is needed when there is more than one definition of
baseline for a given Analysis Parameter <code>PARAM</code> in the same dataset.  For a
given parameter, if Baseline Value <code>BASE</code> is populated, and there is more than
one definition of baseline, then <code>BASETYPE</code> must be non-null on all records of
any type for that parameter. Each value of <code>BASETYPE</code> refers to a definition of
baseline that characterizes the value of <code>BASE</code> on that row.  Please see
section 4.2.1.6 of the ADaM Implementation Guide, version 1.3 for further
background.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_basetype_records(dataset, basetypes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_basetype_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>basetypes</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_basetype_records_+3A_basetypes">basetypes</code></td>
<td>
<p>A <em>named</em> list of expressions created using the
<code>rlang::exprs()</code> function
</p>
<p>The names corresponds to the values of the newly created <code>BASETYPE</code> variables
and the expressions are used to subset the input dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds the <code>BASETYPE</code> variable to a dataset and duplicates records based upon
the provided conditions.
</p>
<p>For each element of <code>basetypes</code> the input dataset is subset based upon
the provided expression and the <code>BASETYPE</code> variable is set to the name of the
expression. Then, all subsets are stacked. Records which do not match any
condition are kept and <code>BASETYPE</code> is set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>The input dataset with variable <code>BASETYPE</code> added
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(rlang)

bds &lt;- tribble(
  ~USUBJID, ~EPOCH,         ~PARAMCD,  ~ASEQ, ~AVAL,
  "P01",    "RUN-IN",       "PARAM01",     1,  10.0,
  "P01",    "RUN-IN",       "PARAM01",     2,   9.8,
  "P01",    "DOUBLE-BLIND", "PARAM01",     3,   9.2,
  "P01",    "DOUBLE-BLIND", "PARAM01",     4,  10.1,
  "P01",    "OPEN-LABEL",   "PARAM01",     5,  10.4,
  "P01",    "OPEN-LABEL",   "PARAM01",     6,   9.9,
  "P02",    "RUN-IN",       "PARAM01",     1,  12.1,
  "P02",    "DOUBLE-BLIND", "PARAM01",     2,  10.2,
  "P02",    "DOUBLE-BLIND", "PARAM01",     3,  10.8,
  "P02",    "OPEN-LABEL",   "PARAM01",     4,  11.4,
  "P02",    "OPEN-LABEL",   "PARAM01",     5,  10.8
)

bds_with_basetype &lt;- derive_basetype_records(
  dataset = bds,
  basetypes = exprs(
    "RUN-IN" = EPOCH %in% c("RUN-IN", "STABILIZATION", "DOUBLE-BLIND", "OPEN-LABEL"),
    "DOUBLE-BLIND" = EPOCH %in% c("DOUBLE-BLIND", "OPEN-LABEL"),
    "OPEN-LABEL" = EPOCH == "OPEN-LABEL"
  )
)


# Below print statement will print all 23 records in the data frame
# bds_with_basetype
print(bds_with_basetype, n = Inf)

count(bds_with_basetype, BASETYPE, name = "Number of Records")

# An example where all parameter records need to be included for 2 different
# baseline type derivations (such as LAST and WORST)
bds &lt;- tribble(
  ~USUBJID, ~EPOCH,         ~PARAMCD,  ~ASEQ, ~AVAL,
  "P01",    "RUN-IN",       "PARAM01",     1,  10.0,
  "P01",    "RUN-IN",       "PARAM01",     2,   9.8,
  "P01",    "DOUBLE-BLIND", "PARAM01",     3,   9.2,
  "P01",    "DOUBLE-BLIND", "PARAM01",     4,  10.1
)

bds_with_basetype &lt;- derive_basetype_records(
  dataset = bds,
  basetypes = exprs(
    "LAST" = TRUE,
    "WORST" = TRUE
  )
)

print(bds_with_basetype, n = Inf)

count(bds_with_basetype, BASETYPE, name = "Number of Records")
</code></pre>

<hr>
<h2 id='derive_expected_records'>Derive Expected Records</h2><span id='topic+derive_expected_records'></span>

<h3>Description</h3>

<p>Add expected records as new observations for each 'by group' when the dataset
contains missing observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_expected_records(
  dataset,
  dataset_expected_obs,
  dataset_ref,
  by_vars = NULL,
  set_values_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_expected_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>dataset_ref</code> and <code>by_vars</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_expected_records_+3A_dataset_expected_obs">dataset_expected_obs</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>dataset_ref</code> instead.</p>
</td></tr>
<tr><td><code id="derive_expected_records_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Expected observations dataset
</p>
<p>Data frame with the expected observations, e.g., all the expected
combinations of <code>PARAMCD</code>, <code>PARAM</code>, <code>AVISIT</code>, <code>AVISITN</code>, ...</p>
</td></tr>
<tr><td><code id="derive_expected_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> those observations from <code>dataset_ref</code>
are added to the output dataset which do not have a corresponding observation
in the input dataset.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_expected_records_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>A list of variable name-value pairs is expected.
</p>

<ul>
<li><p> LHS refers to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, <code>NA</code>, or expressions, e.g., <code>exprs(PARAMCD =   "TDOSE", PARCAT1 = "OVERALL")</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (the variables specified in the <code>by_vars</code> parameter),
those records from <code>dataset_ref</code> that are missing in the input
dataset are added to the output dataset.
</p>


<h3>Value</h3>

<p>The input dataset with the missed expected observations added for each
<code>by_vars</code>. Note, a variable will only be populated in the new parameter rows
if it is specified in <code>by_vars</code> or <code>set_values_to</code>.
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adqs &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVISITN, ~AVISIT, ~AVAL,
  "1",      "a",             1, "WEEK 1",   10,
  "1",      "b",             1, "WEEK 1",   11,
  "2",      "a",             2, "WEEK 2",   12,
  "2",      "b",             2, "WEEK 2",   14
)

# Example 1. visit variables are parameter independent
parm_visit_ref &lt;- tribble(
  ~AVISITN, ~AVISIT,
  1,        "WEEK 1",
  2,        "WEEK 2"
)

derive_expected_records(
  dataset = adqs,
  dataset_ref = parm_visit_ref,
  by_vars = exprs(USUBJID, PARAMCD),
  set_values_to = exprs(DTYPE = "DERIVED")
)

# Example 2. visit variables are parameter dependent
parm_visit_ref &lt;- tribble(
  ~PARAMCD, ~AVISITN, ~AVISIT,
  "a",             1, "WEEK 1",
  "a",             2, "WEEK 2",
  "b",             1, "WEEK 1"
)

derive_expected_records(
  dataset = adqs,
  dataset_ref = parm_visit_ref,
  by_vars = exprs(USUBJID, PARAMCD),
  set_values_to = exprs(DTYPE = "DERIVED")
)

</code></pre>

<hr>
<h2 id='derive_extreme_event'>Add the Worst or Best Observation for Each By Group as New Records</h2><span id='topic+derive_extreme_event'></span>

<h3>Description</h3>

<p>Add the first available record from <code>events</code> for each by group as new
records, all variables of the selected observation are kept. It can be used
for selecting the extreme observation from a series of user-defined events.
This distinguishes <code>derive_extreme_event()</code> from <code>derive_extreme_records()</code>,
where extreme records are derived based on certain order of existing
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_extreme_event(
  dataset = NULL,
  by_vars,
  events,
  tmp_event_nr_var = NULL,
  order,
  mode,
  source_datasets = NULL,
  ignore_event_order = NULL,
  check_type = "warning",
  set_values_to = NULL,
  keep_source_vars = exprs(everything())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_extreme_event_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Default</em>: <code>NULL</code>
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_events">events</code></td>
<td>
<p>Conditions and new values defining events
</p>
<p>A list of <code>event()</code> or <code>event_joined()</code> objects is expected. Only
observations listed in the <code>events</code> are considered for deriving extreme
event. If multiple records meet the filter <code>condition</code>, take the first
record sorted by <code>order</code>. The data is grouped by <code>by_vars</code>, i.e., summary
functions like <code>all()</code> or <code>any()</code> can be used in <code>condition</code>.
</p>
<p>For <code>event_joined()</code> events the observations are selected by calling
<code>filter_joined()</code>. The <code>condition</code> field is passed to the <code>filter_join</code> argument.</p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_tmp_event_nr_var">tmp_event_nr_var</code></td>
<td>
<p>Temporary event number variable
</p>
<p>The specified variable is added to all source datasets and is set to the
number of the event before selecting the records of the event.
</p>
<p>It can be used in <code>order</code> to determine which record should be used if
records from more than one event are selected.
</p>
<p>The variable is not included in the output dataset.</p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If a particular event from <code>events</code> has more than one observation, within
the event and by group, the records are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If a particular event from <code>events</code> has more than one observation,
<code>"first"</code>/<code>"last"</code> is used to select the first/last record of this type of
event sorting by <code>order</code>.
</p>
<p><em>Permitted Values:</em> <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_source_datasets">source_datasets</code></td>
<td>
<p>Source datasets
</p>
<p>A named list of datasets is expected. The <code>dataset_name</code> field of <code>event()</code>
and <code>event_joined()</code> refers to the dataset provided in the list.</p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_ignore_event_order">ignore_event_order</code></td>
<td>
<p>Ignore event order
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>. If event order should be ignored, please
specify neither <code>ignore_event_order</code> nor <code>tmp_event_nr_var</code>. If the event
order should be considered, don't specify <code>ignore_event_order</code> but specify
<code>tmp_event_nr_var</code> and and the specified variable to <code>order</code>.
</p>
<p>If the argument is set to <code>TRUE</code>, all events defined by <code>events</code> are
considered equivalent. If there is more than one observation per by group
the first or last (with respect to <code>mode</code> and <code>order</code>) is select without
taking the order of the events into account.
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Default:</em> <code>"warning"</code>
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="derive_extreme_event_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>Set a list of variables to some specified value for the new records
</p>

<ul>
<li><p> LHS refer to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, an expression or NA. If summary functions are
used, the values are summarized by the variables specified for <code>by_vars</code>.
</p>
</li></ul>

<p>For example:
</p>
<div class="sourceCode"><pre>  set_values_to = exprs(
    AVAL = sum(AVAL),
    DTYPE = "AVERAGE",
  )
</pre></div></td></tr>
<tr><td><code id="derive_extreme_event_+3A_keep_source_vars">keep_source_vars</code></td>
<td>
<p>Variables to keep from the source dataset
</p>
<p>For each event the specified variables are kept from the selected
observations. The variables specified for <code>by_vars</code> and created by
<code>set_values_to</code> are always kept.
</p>
<p><em>Permitted Values</em>: A list of expressions where each element is
a symbol or a tidyselect expression, e.g., <code>exprs(VISIT, VISITNUM, starts_with("RS"))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> For each event select the observations to consider:
</p>

<ol>
<li><p> If the event is of class <code>event</code>, the observations of the source dataset
are restricted by <code>condition</code> and then the first or last (<code>mode</code>)
observation per by group (<code>by_vars</code>) is selected.
</p>
<p>If the event is of class <code>event_joined</code>, <code>filter_joined()</code> is called to
select the observations.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> field of the event
are added to the selected observations.
</p>
</li>
<li><p> The variable specified for <code>tmp_event_nr_var</code> is added and set to
the number of the event.
</p>
</li>
<li><p> Only the variables specified for the <code>keep_source_vars</code> field of the
event, and the by variables (<code>by_vars</code>) and the variables created by
<code>set_values_to</code> are kept.
</p>
</li></ol>

</li>
<li><p> All selected observations are bound together.
</p>
</li>
<li><p> For each group (with respect to the variables specified for the
<code>by_vars</code> parameter) the first or last observation (with respect to the
order specified for the <code>order</code> parameter and the mode specified for the
<code>mode</code> parameter) is selected.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> parameter are added to
the selected observations.
</p>
</li>
<li><p> The observations are added to input dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the best or worst observation of each by group
added as new observations.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event()</a></code>, <code><a href="#topic+event_joined">event_joined()</a></code>, <code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
library(lubridate)

adqs &lt;- tribble(
  ~USUBJID, ~PARAMCD,       ~AVALC,        ~ADY,
  "1",      "NO SLEEP",     "N",              1,
  "1",      "WAKE UP",      "N",              2,
  "1",      "FALL ASLEEP",  "N",              3,
  "2",      "NO SLEEP",     "N",              1,
  "2",      "WAKE UP",      "Y",              2,
  "2",      "WAKE UP",      "Y",              3,
  "2",      "FALL ASLEEP",  "N",              4,
  "3",      "NO SLEEP",     NA_character_,    1
)

# Add a new record for each USUBJID storing the the worst sleeping problem.
derive_extreme_event(
  adqs,
  by_vars = exprs(USUBJID),
  events = list(
    event(
      condition = PARAMCD == "NO SLEEP" &amp; AVALC == "Y",
      set_values_to = exprs(AVALC = "No sleep", AVAL = 1)
    ),
    event(
      condition = PARAMCD == "WAKE UP" &amp; AVALC == "Y",
      set_values_to = exprs(AVALC = "Waking up more than three times", AVAL = 2)
    ),
    event(
      condition = PARAMCD == "FALL ASLEEP" &amp; AVALC == "Y",
      set_values_to = exprs(AVALC = "More than 30 mins to fall asleep", AVAL = 3)
    ),
    event(
      condition = all(AVALC == "N"),
      set_values_to = exprs(
        AVALC = "No sleeping problems", AVAL = 4
      )
    ),
    event(
      condition = TRUE,
      set_values_to = exprs(AVALC = "Missing", AVAL = 99)
    )
  ),
  tmp_event_nr_var = event_nr,
  order = exprs(event_nr, desc(ADY)),
  mode = "first",
  set_values_to = exprs(
    PARAMCD = "WSP",
    PARAM = "Worst Sleeping Problems"
  )
)

# Use different mode by event
adhy &lt;- tribble(
  ~USUBJID, ~AVISITN, ~CRIT1FL,
  "1",             1, "Y",
  "1",             2, "Y",
  "2",             1, "Y",
  "2",             2, NA_character_,
  "2",             3, "Y",
  "2",             4, NA_character_
) %&gt;%
  mutate(
    PARAMCD = "ALKPH",
    PARAM = "Alkaline Phosphatase (U/L)"
  )

derive_extreme_event(
  adhy,
  by_vars = exprs(USUBJID),
  events = list(
    event(
      condition = is.na(CRIT1FL),
      set_values_to = exprs(AVALC = "N")
    ),
    event(
      condition = CRIT1FL == "Y",
      mode = "last",
      set_values_to = exprs(AVALC = "Y")
    )
  ),
  tmp_event_nr_var = event_nr,
  order = exprs(event_nr, AVISITN),
  mode = "first",
  keep_source_vars = exprs(AVISITN),
  set_values_to = exprs(
    PARAMCD = "ALK2",
    PARAM = "ALKPH &lt;= 2 times ULN"
  )
)

# Derive confirmed best overall response (using event_joined())
# CR - complete response, PR - partial response, SD - stable disease
# NE - not evaluable, PD - progressive disease
adsl &lt;- tribble(
  ~USUBJID, ~TRTSDTC,
  "1",      "2020-01-01",
  "2",      "2019-12-12",
  "3",      "2019-11-11",
  "4",      "2019-12-30",
  "5",      "2020-01-01",
  "6",      "2020-02-02",
  "7",      "2020-02-02",
  "8",      "2020-02-01"
) %&gt;%
  mutate(TRTSDT = ymd(TRTSDTC))

adrs &lt;- tribble(
  ~USUBJID, ~ADTC,        ~AVALC,
  "1",      "2020-01-01", "PR",
  "1",      "2020-02-01", "CR",
  "1",      "2020-02-16", "NE",
  "1",      "2020-03-01", "CR",
  "1",      "2020-04-01", "SD",
  "2",      "2020-01-01", "SD",
  "2",      "2020-02-01", "PR",
  "2",      "2020-03-01", "SD",
  "2",      "2020-03-13", "CR",
  "4",      "2020-01-01", "PR",
  "4",      "2020-03-01", "NE",
  "4",      "2020-04-01", "NE",
  "4",      "2020-05-01", "PR",
  "5",      "2020-01-01", "PR",
  "5",      "2020-01-10", "PR",
  "5",      "2020-01-20", "PR",
  "6",      "2020-02-06", "PR",
  "6",      "2020-02-16", "CR",
  "6",      "2020-03-30", "PR",
  "7",      "2020-02-06", "PR",
  "7",      "2020-02-16", "CR",
  "7",      "2020-04-01", "NE",
  "8",      "2020-02-16", "PD"
) %&gt;%
  mutate(
    ADT = ymd(ADTC),
    PARAMCD = "OVR",
    PARAM = "Overall Response by Investigator"
  ) %&gt;%
  derive_vars_merged(
    dataset_add = adsl,
    by_vars = exprs(USUBJID),
    new_vars = exprs(TRTSDT)
  )

derive_extreme_event(
  adrs,
  by_vars = exprs(USUBJID),
  tmp_event_nr_var = event_nr,
  order = exprs(event_nr, ADT),
  mode = "first",
  source_datasets = list(adsl = adsl),
  events = list(
    event_joined(
      description = paste(
        "CR needs to be confirmed by a second CR at least 28 days later",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join == "CR" &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "CR" &amp;
        all(AVALC.join %in% c("CR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "CR"
      )
    ),
    event_joined(
      description = paste(
        "PR needs to be confirmed by a second CR or PR at least 28 days later,",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join %in% c("CR", "PR") &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "PR" &amp;
        all(AVALC.join %in% c("CR", "PR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "PR"
      )
    ),
    event(
      description = paste(
        "CR, PR, or SD are considered as SD if occurring at least 28",
        "after treatment start"
      ),
      condition = AVALC %in% c("CR", "PR", "SD") &amp; ADT &gt;= TRTSDT + 28,
      set_values_to = exprs(
        AVALC = "SD"
      )
    ),
    event(
      condition = AVALC == "PD",
      set_values_to = exprs(
        AVALC = "PD"
      )
    ),
    event(
      condition = AVALC %in% c("CR", "PR", "SD", "NE"),
      set_values_to = exprs(
        AVALC = "NE"
      )
    ),
    event(
      description = "set response to MISSING for patients without records in ADRS",
      dataset_name = "adsl",
      condition = TRUE,
      set_values_to = exprs(
        AVALC = "MISSING"
      ),
      keep_source_vars = exprs(TRTSDT)
    )
  ),
  set_values_to = exprs(
    PARAMCD = "CBOR",
    PARAM = "Best Confirmed Overall Response by Investigator"
  )
) %&gt;%
  filter(PARAMCD == "CBOR")

</code></pre>

<hr>
<h2 id='derive_extreme_records'>Add the First or Last Observation for Each By Group as New Records</h2><span id='topic+derive_extreme_records'></span>

<h3>Description</h3>

<p>Add the first or last observation for each by group as new observations. The
new observations can be selected from the additional dataset. This function can
be used for adding the maximum or minimum value as a separate visit.
All variables of the selected observation are kept. This distinguishes
<code>derive_extreme_records()</code> from <code>derive_summary_records()</code>,
where only the by variables are populated for the new records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_extreme_records(
  dataset = NULL,
  dataset_add,
  dataset_ref = NULL,
  by_vars = NULL,
  order = NULL,
  mode = NULL,
  filter_add = NULL,
  check_type = "warning",
  exist_flag = NULL,
  true_value = "Y",
  false_value = NA_character_,
  keep_source_vars = exprs(everything()),
  set_values_to
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_extreme_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The additional dataset, which determines the by groups returned in the input dataset,
based on the groups that exist in this dataset after being subset by <code>filter_add</code>.
</p>
<p>The variables specified in the <code>by_vars</code> and <code>filter_add</code> parameters are expected
in this dataset. If <code>mode</code> and <code>order</code> are specified, the first or last observation
within each by group, defined by <code>by_vars</code>, is selected.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Reference dataset
</p>
<p>The variables specified for <code>by_vars</code> are expected. For each
observation of the specified dataset a new observation is added to the
input dataset.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>If <code>dataset_ref</code> is specified, this argument must be specified.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Within each by group the observations are ordered by the specified order.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, the first observation of each by group is added
to the input dataset. If <code>"last"</code> is specified, the last observation of
each by group is added to the input dataset.
</p>
<p><em>Permitted Values:</em> <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations in <code>dataset_add</code> fulfilling the specified condition are
considered.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the (restricted) additional dataset are not unique
with respect to the by variables and the order.
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_exist_flag">exist_flag</code></td>
<td>
<p>Existence flag
</p>
<p>The specified variable is added to the output dataset.
</p>
<p>For by groups with at least one observation in the additional dataset
(<code>dataset_add</code>) <code>exist_flag</code> is set to the value specified by the
<code>true_value</code> argument.
</p>
<p>For all other by groups <code>exist_flag</code> is set to the value specified by the
<code>false_value</code> argument.
</p>
<p><em>Permitted Values:</em> Variable name</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>For new observations selected from the additional dataset (<code>dataset_add</code>),
<code>exist_flag</code> is set to the specified value.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>For new observations not selected from the additional dataset
(<code>dataset_add</code>), <code>exist_flag</code> is set to the specified value.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_keep_source_vars">keep_source_vars</code></td>
<td>
<p>Variables to be kept in the new records
</p>
<p>A named list or tidyselect expressions created by <code>exprs()</code> defining the
variables to be kept for the new records. The variables specified for
<code>by_vars</code> and <code>set_values_to</code> need not be specified here as they are kept
automatically.</p>
</td></tr>
<tr><td><code id="derive_extreme_records_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>Set a list of variables to some specified value for the new records
</p>

<ul>
<li><p> LHS refer to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, an expression or NA. If summary functions are
used, the values are summarized by the variables specified for <code>by_vars</code>.
</p>
</li></ul>

<p>For example:
</p>
<div class="sourceCode"><pre>  set_values_to = exprs(
    AVAL = sum(AVAL),
    DTYPE = "AVERAGE",
  )
</pre></div></td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The additional dataset (<code>dataset_add</code>) is restricted as specified by the
<code>filter_add</code> argument.
</p>
</li>
<li><p> For each group (with respect to the variables specified for the
<code>by_vars</code> argument) the first or last observation (with respect to the
order specified for the <code>order</code> argument and the mode specified for the
<code>mode</code> argument) is selected.
</p>
</li>
<li><p> If <code>dataset_ref</code> is specified, observations which are in <code>dataset_ref</code>
but not in the selected records are added.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> argument are added to
the selected observations.
</p>
</li>
<li><p> The variables specified by the <code>keep_source_vars</code> argument are selected
along with the variables specified in <code>by_vars</code> and <code>set_values_to</code>
arguments.
</p>
</li>
<li><p> The observations are added to input dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the first or last observation of each by group
added as new observations.
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

adlb &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVAL, ~LBSEQ,
  "1",      1,          113,      1,
  "1",      2,          113,      2,
  "1",      3,          117,      3,
  "2",      1,          101,      1,
  "2",      2,          101,      2,
  "2",      3,           95,      3
)

# Add a new record for each USUBJID storing the minimum value (first AVAL).
# If multiple records meet the minimum criterion, take the first value by
# AVISITN. Set AVISITN = 97 and DTYPE = MINIMUM for these new records.
# Specify the variables that need to be kept in the new records.
derive_extreme_records(
  adlb,
  dataset_add = adlb,
  by_vars = exprs(USUBJID),
  order = exprs(AVAL, AVISITN),
  mode = "first",
  filter_add = !is.na(AVAL),
  keep_source_vars = exprs(AVAL),
  set_values_to = exprs(
    AVISITN = 97,
    DTYPE = "MINIMUM"
  )
)

# Add a new record for each USUBJID storing the maximum value (last AVAL).
# If multiple records meet the maximum criterion, take the first value by
# AVISITN. Set AVISITN = 98 and DTYPE = MAXIMUM for these new records.
derive_extreme_records(
  adlb,
  dataset_add = adlb,
  by_vars = exprs(USUBJID),
  order = exprs(desc(AVAL), AVISITN),
  mode = "first",
  filter_add = !is.na(AVAL),
  set_values_to = exprs(
    AVISITN = 98,
    DTYPE = "MAXIMUM"
  )
)

# Add a new record for each USUBJID storing for the last value.
# Set AVISITN = 99 and DTYPE = LOV for these new records.
derive_extreme_records(
  adlb,
  dataset_add = adlb,
  by_vars = exprs(USUBJID),
  order = exprs(AVISITN),
  mode = "last",
  set_values_to = exprs(
    AVISITN = 99,
    DTYPE = "LOV"
  )
)

# Derive a new parameter for the first disease progression (PD)
adsl &lt;- tribble(
  ~USUBJID, ~DTHDT,
  "1",      ymd("2022-05-13"),
  "2",      ymd(""),
  "3",      ymd("")
) %&gt;%
  mutate(STUDYID = "XX1234")

adrs &lt;- tribble(
  ~USUBJID, ~ADTC,        ~AVALC,
  "1",      "2020-01-02", "PR",
  "1",      "2020-02-01", "CR",
  "1",      "2020-03-01", "CR",
  "1",      "2020-04-01", "SD",
  "2",      "2021-06-15", "SD",
  "2",      "2021-07-16", "PD",
  "2",      "2021-09-14", "PD"
) %&gt;%
  mutate(
    STUDYID = "XX1234",
    ADT = ymd(ADTC),
    PARAMCD = "OVR",
    PARAM = "Overall Response",
    ANL01FL = "Y"
  ) %&gt;%
  select(-ADTC)

derive_extreme_records(
  adrs,
  dataset_ref = adsl,
  dataset_add = adrs,
  by_vars = exprs(STUDYID, USUBJID),
  filter_add = PARAMCD == "OVR" &amp; AVALC == "PD",
  order = exprs(ADT),
  exist_flag = AVALC,
  true_value = "Y",
  false_value = "N",
  mode = "first",
  set_values_to = exprs(
    PARAMCD = "PD",
    PARAM = "Disease Progression",
    AVAL = yn_to_numeric(AVALC),
    ANL01FL = "Y",
    ADT = ADT
  )
)

# derive parameter indicating death
derive_extreme_records(
  dataset_ref = adsl,
  dataset_add = adsl,
  by_vars = exprs(STUDYID, USUBJID),
  filter_add = !is.na(DTHDT),
  exist_flag = AVALC,
  true_value = "Y",
  false_value = "N",
  mode = "first",
  set_values_to = exprs(
    PARAMCD = "DEATH",
    PARAM = "Death",
    ANL01FL = "Y",
    ADT = DTHDT
  )
)
</code></pre>

<hr>
<h2 id='derive_locf_records'>Derive LOCF (Last Observation Carried Forward) Records</h2><span id='topic+derive_locf_records'></span>

<h3>Description</h3>

<p>Adds LOCF records as new observations for each 'by group' when the dataset
does not contain observations for missed visits/time points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_locf_records(
  dataset,
  dataset_expected_obs,
  dataset_ref,
  by_vars,
  analysis_var = AVAL,
  order,
  keep_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_locf_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code>, <code>analysis_var</code>, <code>order</code> and <code>keep_vars</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_dataset_expected_obs">dataset_expected_obs</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>dataset_ref</code> instead.</p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Expected observations dataset
</p>
<p>Data frame with all the combinations of <code>PARAMCD</code>, <code>PARAM</code>, <code>AVISIT</code>,
<code>AVISITN</code>, ... which are expected in the dataset is expected.</p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> those observations from <code>dataset_ref</code>
are added to the output dataset which do not have a corresponding observation
in the input dataset or for which <code>analysis_var</code> is <code>NA</code> for the corresponding observation
in the input dataset.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable.
</p>
<p><em>Default</em>: <code>AVAL</code>
</p>
<p><em>Permitted Values</em>: a variable</p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>The dataset is sorted by <code>order</code> before carrying the last observation
forward (e.g. <code>AVAL</code>) within each <code>by_vars</code>.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.</p>
</td></tr>
<tr><td><code id="derive_locf_records_+3A_keep_vars">keep_vars</code></td>
<td>
<p>Variables that need carrying the last observation forward
</p>
<p>Keep variables that need carrying the last observation forward other than <code>analysis_var</code>
(e.g., <code>PARAMN</code>, <code>VISITNUM</code>). If by default <code>NULL</code>, only variables specified in
<code>by_vars</code> and <code>analysis_var</code> will be populated in the newly created records.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
by_vars parameter) those observations from <code>dataset_ref</code> are added to
the output dataset
</p>

<ul>
<li><p> which do not have a corresponding observation in the input dataset or
</p>
</li>
<li><p> for which <code>analysis_var</code> is NA for the corresponding observation in the input dataset.
</p>
<p>For the new observations, <code>analysis_var</code> is set to the non-missing <code>analysis_var</code> of the
previous observation in the input dataset (when sorted by <code>order</code>) and
<code>DTYPE</code> is set to &quot;LOCF&quot;.
</p>
</li></ul>



<h3>Value</h3>

<p>The input dataset with the new &quot;LOCF&quot; observations added for each
<code>by_vars</code>. Note, a variable will only be populated in the new parameter rows
if it is specified in <code>by_vars</code>.
</p>


<h3>Author(s)</h3>

<p>G Gayatri
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tibble)

advs &lt;- tribble(
  ~STUDYID,  ~USUBJID,      ~PARAMCD, ~PARAMN, ~AVAL, ~AVISITN, ~AVISIT,
  "CDISC01", "01-701-1015", "PULSE",        1,    61,        0, "BASELINE",
  "CDISC01", "01-701-1015", "PULSE",        1,    60,        2, "WEEK 6",
  "CDISC01", "01-701-1015", "DIABP",        2,    51,        0, "BASELINE",
  "CDISC01", "01-701-1015", "DIABP",        2,    50,        2, "WEEK 2",
  "CDISC01", "01-701-1015", "DIABP",        2,    51,        4, "WEEK 4",
  "CDISC01", "01-701-1015", "DIABP",        2,    50,        6, "WEEK 6",
  "CDISC01", "01-701-1015", "SYSBP",        3,   121,        0, "BASELINE",
  "CDISC01", "01-701-1015", "SYSBP",        3,   121,        2, "WEEK 2",
  "CDISC01", "01-701-1015", "SYSBP",        3,   121,        4, "WEEK 4",
  "CDISC01", "01-701-1015", "SYSBP",        3,   121,        6, "WEEK 6",
  "CDISC01", "01-701-1028", "PULSE",        1,    65,        0, "BASELINE",
  "CDISC01", "01-701-1028", "DIABP",        2,    79,        0, "BASELINE",
  "CDISC01", "01-701-1028", "DIABP",        2,    80,        2, "WEEK 2",
  "CDISC01", "01-701-1028", "DIABP",        2,    NA,        4, "WEEK 4",
  "CDISC01", "01-701-1028", "DIABP",        2,    NA,        6, "WEEK 6",
  "CDISC01", "01-701-1028", "SYSBP",        3,   130,        0, "BASELINE",
  "CDISC01", "01-701-1028", "SYSBP",        3,   132,        2, "WEEK 2"
)


# A dataset with all the combinations of PARAMCD, PARAM, AVISIT, AVISITN, ... which are expected.
advs_expected_obsv &lt;- tribble(
  ~PARAMCD, ~AVISITN, ~AVISIT,
  "PULSE",         0, "BASELINE",
  "PULSE",         6, "WEEK 6",
  "DIABP",         0, "BASELINE",
  "DIABP",         2, "WEEK 2",
  "DIABP",         4, "WEEK 4",
  "DIABP",         6, "WEEK 6",
  "SYSBP",         0, "BASELINE",
  "SYSBP",         2, "WEEK 2",
  "SYSBP",         4, "WEEK 4",
  "SYSBP",         6, "WEEK 6"
)

derive_locf_records(
  dataset = advs,
  dataset_ref = advs_expected_obsv,
  by_vars = exprs(STUDYID, USUBJID, PARAMCD),
  order = exprs(AVISITN, AVISIT),
  keep_vars = exprs(PARAMN)
)

</code></pre>

<hr>
<h2 id='derive_param_bmi'>Adds a Parameter for BMI</h2><span id='topic+derive_param_bmi'></span>

<h3>Description</h3>

<p>Adds a record for BMI/Body Mass Index using Weight and Height each by group
(e.g., subject and visit) where the source parameters are available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_bmi(
  dataset,
  by_vars,
  set_values_to = exprs(PARAMCD = "BMI"),
  weight_code = "WEIGHT",
  height_code = "HEIGHT",
  get_unit_expr,
  filter = NULL,
  constant_by_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_bmi_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>weight_code</code> and <code>height_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_weight_code">weight_code</code></td>
<td>
<p>WEIGHT parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the WEIGHT. It is expected that WEIGHT is measured in kg
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_height_code">height_code</code></td>
<td>
<p>HEIGHT parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the HEIGHT. It is expected that HEIGHT is measured in cm
</p>
<p><em>Permitted Values:</em> character value
</p>
<p><em>Permitted Values:</em> logical scalar</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
<tr><td><code id="derive_param_bmi_+3A_constant_by_vars">constant_by_vars</code></td>
<td>
<p>By variables for when HEIGHT is constant
</p>
<p>When HEIGHT is constant, the HEIGHT parameters (measured only once) are merged
to the other parameters using the specified variables.
</p>
<p>If height is constant (e.g. only measured once at screening or baseline) then
use <code>constant_by_vars</code> to select the subject-level variable to merge on (e.g. <code>USUBJID</code>).
This will produce BMI at all visits where weight is measured.  Otherwise
it will only be calculated at visits with both height and weight collected.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis value of the new parameter is derived as
</p>
<p style="text-align: center;"><code class="reqn">BMI = \frac{WEIGHT}{HEIGHT^2}</code>
</p>



<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_bmi">compute_bmi()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example 1: Derive BMI where height is measured only once using constant_by_vars
advs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~AVISIT,
  "01-701-1015", "HEIGHT", "Height (cm)", 147, "SCREENING",
  "01-701-1015", "WEIGHT", "Weight (kg)", 54.0, "SCREENING",
  "01-701-1015", "WEIGHT", "Weight (kg)", 54.4, "BASELINE",
  "01-701-1015", "WEIGHT", "Weight (kg)", 53.1, "WEEK 2",
  "01-701-1028", "HEIGHT", "Height (cm)", 163, "SCREENING",
  "01-701-1028", "WEIGHT", "Weight (kg)", 78.5, "SCREENING",
  "01-701-1028", "WEIGHT", "Weight (kg)", 80.3, "BASELINE",
  "01-701-1028", "WEIGHT", "Weight (kg)", 80.7, "WEEK 2"
)

derive_param_bmi(
  advs,
  by_vars = exprs(USUBJID, AVISIT),
  weight_code = "WEIGHT",
  height_code = "HEIGHT",
  set_values_to = exprs(
    PARAMCD = "BMI",
    PARAM = "Body Mass Index (kg/m^2)"
  ),
  get_unit_expr = extract_unit(PARAM),
  constant_by_vars = exprs(USUBJID)
)

# Example 2: Derive BMI where height is measured only once and keep only one record
# where both height and weight are measured.
derive_param_bmi(
  advs,
  by_vars = exprs(USUBJID, AVISIT),
  weight_code = "WEIGHT",
  height_code = "HEIGHT",
  set_values_to = exprs(
    PARAMCD = "BMI",
    PARAM = "Body Mass Index (kg/m^2)"
  ),
  get_unit_expr = extract_unit(PARAM)
)

# Example 3: Pediatric study where height and weight are measured multiple times
advs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~VISIT,
  "01-101-1001", "HEIGHT", "Height (cm)", 47.1, "BASELINE",
  "01-101-1001", "HEIGHT", "Height (cm)", 59.1, "WEEK 12",
  "01-101-1001", "HEIGHT", "Height (cm)", 64.7, "WEEK 24",
  "01-101-1001", "HEIGHT", "Height (cm)", 68.2, "WEEK 48",
  "01-101-1001", "WEIGHT", "Weight (kg)", 2.6, "BASELINE",
  "01-101-1001", "WEIGHT", "Weight (kg)", 5.3, "WEEK 12",
  "01-101-1001", "WEIGHT", "Weight (kg)", 6.7, "WEEK 24",
  "01-101-1001", "WEIGHT", "Weight (kg)", 7.4, "WEEK 48",
)

derive_param_bmi(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  weight_code = "WEIGHT",
  height_code = "HEIGHT",
  set_values_to = exprs(
    PARAMCD = "BMI",
    PARAM = "Body Mass Index (kg/m^2)"
  ),
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_param_bsa'>Adds a Parameter for BSA (Body Surface Area) Using the Specified Method</h2><span id='topic+derive_param_bsa'></span>

<h3>Description</h3>

<p>Adds a record for BSA (Body Surface Area) using the specified derivation
method for each by group (e.g., subject and visit) where the source parameters are
available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_bsa(
  dataset,
  by_vars,
  method,
  set_values_to = exprs(PARAMCD = "BSA"),
  height_code = "HEIGHT",
  weight_code = "WEIGHT",
  get_unit_expr,
  filter = NULL,
  constant_by_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_bsa_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>HEIGHT</code> and <code>WEIGHT</code>.</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_method">method</code></td>
<td>
<p>Derivation method to use. Note that <code>HEIGHT</code> is expected
in cm and <code>WEIGHT</code> is expected in kg:
</p>
<p>Mosteller: <code>sqrt(height * weight / 3600)</code>
</p>
<p>DuBois-DuBois: <code>0.20247 * (height/100) ^ 0.725 * weight ^ 0.425</code>
</p>
<p>Haycock: <code>0.024265 * height ^ 0.3964 * weight ^ 0.5378</code>
</p>
<p>Gehan-George: <code>0.0235 * height ^ 0.42246 * weight ^ 0.51456</code>
</p>
<p>Boyd: <code>0.0003207 * (height ^ 0.3) * (1000 * weight) ^ (0.7285 - (0.0188 * log10(1000 * weight)))</code>
</p>
<p>Fujimoto: <code>0.008883 * height ^ 0.663 * weight ^ 0.444</code>
</p>
<p>Takahira: <code>0.007241 * height ^ 0.725 * weight ^ 0.425</code>
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_height_code">height_code</code></td>
<td>
<p>HEIGHT parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the HEIGHT assessments. It is expected that HEIGHT is measured in cm.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_weight_code">weight_code</code></td>
<td>
<p>WEIGHT parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the WEIGHT assessments. It is expected that WEIGHT is measured in kg.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
<tr><td><code id="derive_param_bsa_+3A_constant_by_vars">constant_by_vars</code></td>
<td>
<p>By variables for when HEIGHT is constant
</p>
<p>When HEIGHT is constant, the HEIGHT parameters (measured only once) are merged
to the other parameters using the specified variables.
</p>
<p>If height is constant (e.g. only measured once at screening or baseline) then
use <code>constant_by_vars</code> to select the subject-level variable to merge on (e.g. <code>USUBJID</code>).
This will produce BSA at all visits where weight is measured.  Otherwise
it will only be calculated at visits with both height and weight collected.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_bsa">compute_bsa()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# Example 1: Derive BSA where height is measured only once using constant_by_vars
advs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~VISIT,
  "01-701-1015", "HEIGHT", "Height (cm)", 170, "BASELINE",
  "01-701-1015", "WEIGHT", "Weight (kg)", 75, "BASELINE",
  "01-701-1015", "WEIGHT", "Weight (kg)", 78, "MONTH 1",
  "01-701-1015", "WEIGHT", "Weight (kg)", 80, "MONTH 2",
  "01-701-1028", "HEIGHT", "Height (cm)", 185, "BASELINE",
  "01-701-1028", "WEIGHT", "Weight (kg)", 90, "BASELINE",
  "01-701-1028", "WEIGHT", "Weight (kg)", 88, "MONTH 1",
  "01-701-1028", "WEIGHT", "Weight (kg)", 85, "MONTH 2",
)

derive_param_bsa(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  method = "Mosteller",
  set_values_to = exprs(
    PARAMCD = "BSA",
    PARAM = "Body Surface Area (m^2)"
  ),
  get_unit_expr = extract_unit(PARAM),
  constant_by_vars = exprs(USUBJID)
)

derive_param_bsa(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  method = "Fujimoto",
  set_values_to = exprs(
    PARAMCD = "BSA",
    PARAM = "Body Surface Area (m^2)"
  ),
  get_unit_expr = extract_unit(PARAM),
  constant_by_vars = exprs(USUBJID)
)

# Example 2: Derive BSA where height is measured only once and keep only one record
# where both height and weight are measured.

derive_param_bsa(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  method = "Mosteller",
  set_values_to = exprs(
    PARAMCD = "BSA",
    PARAM = "Body Surface Area (m^2)"
  ),
  get_unit_expr = extract_unit(PARAM)
)

# Example 3: Pediatric study where height and weight are measured multiple times
advs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~VISIT,
  "01-101-1001", "HEIGHT", "Height (cm)", 47.1, "BASELINE",
  "01-101-1001", "HEIGHT", "Height (cm)", 59.1, "WEEK 12",
  "01-101-1001", "HEIGHT", "Height (cm)", 64.7, "WEEK 24",
  "01-101-1001", "HEIGHT", "Height (cm)", 68.2, "WEEK 48",
  "01-101-1001", "WEIGHT", "Weight (kg)", 2.6, "BASELINE",
  "01-101-1001", "WEIGHT", "Weight (kg)", 5.3, "WEEK 12",
  "01-101-1001", "WEIGHT", "Weight (kg)", 6.7, "WEEK 24",
  "01-101-1001", "WEIGHT", "Weight (kg)", 7.4, "WEEK 48",
)
derive_param_bsa(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  method = "Mosteller",
  set_values_to = exprs(
    PARAMCD = "BSA",
    PARAM = "Body Surface Area (m^2)"
  ),
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_param_computed'>Adds a Parameter Computed from the Analysis Value of Other Parameters</h2><span id='topic+derive_param_computed'></span>

<h3>Description</h3>

<p>Adds a parameter computed from the analysis value of other parameters. It is
expected that the analysis value of the new parameter is defined by an
expression using the analysis values of other parameters. For example mean
arterial pressure (MAP) can be derived from systolic (SYSBP) and diastolic
blood pressure (DIABP) with the formula
</p>
<p style="text-align: center;"><code class="reqn">MAP = \frac{SYSBP + 2 DIABP}{3}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>derive_param_computed(
  dataset = NULL,
  dataset_add = NULL,
  by_vars,
  parameters,
  analysis_var = AVAL,
  analysis_value,
  set_values_to,
  filter = NULL,
  constant_by_vars = NULL,
  constant_parameters = NULL,
  keep_nas = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_computed_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code> is expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>parameters</code>.</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code> parameter are expected.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the additional dataset after restricting it to the parameters specified by
<code>parameters</code>.
</p>
<p>If the argument is specified, the observations of the additional dataset
are considered in addition to the observations from the input dataset
(<code>dataset</code> restricted by <code>filter</code>).</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_parameters">parameters</code></td>
<td>
<p>Required parameter codes
</p>
<p>It is expected that all parameter codes (<code>PARAMCD</code>) which are required to
derive the new parameter are specified for this parameter or the
<code>constant_parameters</code> parameter.
</p>
<p>If observations should be considered which do not have a parameter code,
e.g., if an SDTM dataset is used, temporary parameter codes can be derived
by specifying a list of expressions. The name of the element defines the
temporary parameter code and the expression the condition for selecting the
records. For example <code>parameters = exprs(HGHT = VSTESTCD == "HEIGHT")</code>
selects the observations with <code>VSTESTCD == "HEIGHT"</code> from the input data
(<code>dataset</code> and <code>dataset_add</code>), sets <code>PARAMCD = "HGHT"</code> for these
observations, and adds them to the observations to consider.
</p>
<p>Unnamed elements in the list of expressions are considered as parameter
codes. For example, <code>parameters = exprs(WEIGHT, HGHT = VSTESTCD == "HEIGHT")</code> uses the parameter code <code>"WEIGHT"</code> and creates a temporary
parameter code <code>"HGHT"</code>.
</p>
<p><em>Permitted Values:</em> A character vector of <code>PARAMCD</code> values or a list of expressions</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.
</p>
<p>The specified variable is set to the value of <code>analysis_value</code> for the new
observations.
</p>
<p><em>Permitted Values</em>: An unquoted symbol</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_analysis_value">analysis_value</code></td>
<td>
<p>Definition of the analysis value
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.
</p>
<p>An expression defining the analysis value (<code>AVAL</code>) of the new parameter is
expected. The values of variables of the parameters specified by
<code>parameters</code> can be accessed using <code style="white-space: pre;">&#8288;&lt;variable name&gt;.&lt;parameter code&gt;&#8288;</code>,
e.g., <code>AVAL.SYSBP</code>.
</p>
<p>Variable names in the expression must not contain more than one dot.
</p>
<p><em>Permitted Values:</em> An unquoted expression</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. The values of variables of the parameters specified by
<code>parameters</code> can be accessed using <code style="white-space: pre;">&#8288;&lt;variable name&gt;.&lt;parameter code&gt;&#8288;</code>. For
example
</p>
<div class="sourceCode"><pre>exprs(
  AVAL = (AVAL.SYSBP + 2 * AVAL.DIABP) / 3,
  PARAMCD = "MAP"
)
</pre></div>
<p>defines the analysis value and parameter code for the new parameter.
</p>
<p>Variable names in the expression must not contain more than one dot.
</p>
<p><em>Permitted Values:</em> List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_constant_by_vars">constant_by_vars</code></td>
<td>
<p>By variables for constant parameters
</p>
<p>The constant parameters (parameters that are measured only once) are merged
to the other parameters using the specified variables. (Refer to Example 2)
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_constant_parameters">constant_parameters</code></td>
<td>
<p>Required constant parameter codes
</p>
<p>It is expected that all the parameter codes (<code>PARAMCD</code>) which are required
to derive the new parameter and are measured only once are specified here.
For example if BMI should be derived and height is measured only once while
weight is measured at each visit. Height could be specified in the
<code>constant_parameters</code> parameter. (Refer to Example 2)
</p>
<p>If observations should be considered which do not have a parameter code,
e.g., if an SDTM dataset is used, temporary parameter codes can be derived
by specifying a list of expressions. The name of the element defines the
temporary parameter code and the expression the condition for selecting the
records. For example <code>constant_parameters = exprs(HGHT = VSTESTCD == "HEIGHT")</code> selects the observations with <code>VSTESTCD == "HEIGHT"</code> from the
input data (<code>dataset</code> and <code>dataset_add</code>), sets <code>PARAMCD = "HGHT"</code> for these
observations, and adds them to the observations to consider.
</p>
<p>Unnamed elements in the list of expressions are considered as parameter
codes. For example, <code>constant_parameters = exprs(WEIGHT, HGHT = VSTESTCD == "HEIGHT")</code> uses the parameter code <code>"WEIGHT"</code> and creates a temporary
parameter code <code>"HGHT"</code>.
</p>
<p><em>Permitted Values:</em> A character vector of <code>PARAMCD</code> values or a list of expressions</p>
</td></tr>
<tr><td><code id="derive_param_computed_+3A_keep_nas">keep_nas</code></td>
<td>
<p>Keep observations with <code>NA</code>s
</p>
<p>If the argument is set to <code>TRUE</code>, observations are added even if some of
the values contributing to the computed value are <code>NA</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
<code>by_vars</code> parameter) an observation is added to the output dataset if the
filtered input dataset (<code>dataset</code>) or the additional dataset
(<code>dataset_add</code>) contains exactly one observation for each parameter code
specified for <code>parameters</code>.
</p>
<p>For the new observations the variables specified for <code>set_values_to</code> are
set to the provided values. The values of the other variables of the input
dataset are set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
library(lubridate)

# Example 1: Derive MAP
advs &lt;- tribble(
  ~USUBJID,      ~PARAMCD, ~PARAM,                            ~AVAL, ~AVALU, ~VISIT,
  "01-701-1015", "DIABP",  "Diastolic Blood Pressure (mmHg)",    51, "mmHg", "BASELINE",
  "01-701-1015", "DIABP",  "Diastolic Blood Pressure (mmHg)",    50, "mmHg", "WEEK 2",
  "01-701-1015", "SYSBP",  "Systolic Blood Pressure (mmHg)",    121, "mmHg", "BASELINE",
  "01-701-1015", "SYSBP",  "Systolic Blood Pressure (mmHg)",    121, "mmHg", "WEEK 2",
  "01-701-1028", "DIABP",  "Diastolic Blood Pressure (mmHg)",    79, "mmHg", "BASELINE",
  "01-701-1028", "DIABP",  "Diastolic Blood Pressure (mmHg)",    80, "mmHg", "WEEK 2",
  "01-701-1028", "SYSBP",  "Systolic Blood Pressure (mmHg)",    130, "mmHg", "BASELINE",
  "01-701-1028", "SYSBP",  "Systolic Blood Pressure (mmHg)",    132, "mmHg", "WEEK 2"
)

derive_param_computed(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  parameters = c("SYSBP", "DIABP"),
  set_values_to = exprs(
    AVAL = (AVAL.SYSBP + 2 * AVAL.DIABP) / 3,
    PARAMCD = "MAP",
    PARAM = "Mean Arterial Pressure (mmHg)",
    AVALU = "mmHg"
  )
)

# Example 2: Derive BMI where height is measured only once
advs &lt;- tribble(
  ~USUBJID,      ~PARAMCD, ~PARAM,        ~AVAL, ~AVALU, ~VISIT,
  "01-701-1015", "HEIGHT", "Height (cm)", 147.0, "cm",   "SCREENING",
  "01-701-1015", "WEIGHT", "Weight (kg)",  54.0, "kg",   "SCREENING",
  "01-701-1015", "WEIGHT", "Weight (kg)",  54.4, "kg",   "BASELINE",
  "01-701-1015", "WEIGHT", "Weight (kg)",  53.1, "kg",   "WEEK 2",
  "01-701-1028", "HEIGHT", "Height (cm)", 163.0, "cm",   "SCREENING",
  "01-701-1028", "WEIGHT", "Weight (kg)",  78.5, "kg",   "SCREENING",
  "01-701-1028", "WEIGHT", "Weight (kg)",  80.3, "kg",   "BASELINE",
  "01-701-1028", "WEIGHT", "Weight (kg)",  80.7, "kg",   "WEEK 2"
)

derive_param_computed(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  parameters = "WEIGHT",
  set_values_to = exprs(
    AVAL = AVAL.WEIGHT / (AVAL.HEIGHT / 100)^2,
    PARAMCD = "BMI",
    PARAM = "Body Mass Index (kg/m^2)",
    AVALU = "kg/m^2"
  ),
  constant_parameters = c("HEIGHT"),
  constant_by_vars = exprs(USUBJID)
)

# Example 3: Using data from an additional dataset and other variables than AVAL
qs &lt;- tribble(
  ~USUBJID, ~AVISIT,   ~QSTESTCD, ~QSORRES, ~QSSTRESN,
  "1",      "WEEK 2",  "CHSF112", NA,               1,
  "1",      "WEEK 2",  "CHSF113", "Yes",           NA,
  "1",      "WEEK 2",  "CHSF114", NA,               1,
  "1",      "WEEK 4",  "CHSF112", NA,               2,
  "1",      "WEEK 4",  "CHSF113", "No",            NA,
  "1",      "WEEK 4",  "CHSF114", NA,               1
)

adchsf &lt;- tribble(
  ~USUBJID, ~AVISIT,  ~PARAMCD, ~QSSTRESN, ~AVAL,
  "1",      "WEEK 2", "CHSF12", 1,             6,
  "1",      "WEEK 2", "CHSF14", 1,             6,
  "1",      "WEEK 4", "CHSF12", 2,            12,
  "1",      "WEEK 4", "CHSF14", 1,             6
) %&gt;%
  mutate(QSORRES = NA_character_)

derive_param_computed(
  adchsf,
  dataset_add = qs,
  by_vars = exprs(USUBJID, AVISIT),
  parameters = exprs(CHSF12, CHSF13 = QSTESTCD %in% c("CHSF113", "CHSF213"), CHSF14),
  set_values_to = exprs(
    AVAL = case_when(
      QSORRES.CHSF13 == "Not applicable" ~ 0,
      QSORRES.CHSF13 == "Yes" ~ 38,
      QSORRES.CHSF13 == "No" ~ if_else(
        QSSTRESN.CHSF12 &gt; QSSTRESN.CHSF14,
        25,
        0
      )
    ),
    PARAMCD = "CHSF13"
  )
)

# Example 4: Computing more than one variable
adlb_tbilialk &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVALC, ~ADTM,        ~ADTF,
  "1",      "ALK2",   "Y",    "2021-05-13", NA_character_,
  "1",      "TBILI2", "Y",    "2021-06-30", "D",
  "2",      "ALK2",   "Y",    "2021-12-31", "M",
  "2",      "TBILI2", "N",    "2021-11-11", NA_character_,
  "3",      "ALK2",   "N",    "2021-04-03", NA_character_,
  "3",      "TBILI2", "N",    "2021-04-04", NA_character_
) %&gt;%
  mutate(ADTM = ymd(ADTM))

derive_param_computed(
  dataset_add = adlb_tbilialk,
  by_vars = exprs(USUBJID),
  parameters = c("ALK2", "TBILI2"),
  set_values_to = exprs(
    AVALC = if_else(AVALC.TBILI2 == "Y" &amp; AVALC.ALK2 == "Y", "Y", "N"),
    ADTM = pmax(ADTM.TBILI2, ADTM.ALK2),
    ADTF = if_else(ADTM == ADTM.TBILI2, ADTF.TBILI2, ADTF.ALK2),
    PARAMCD = "TB2AK2",
    PARAM = "TBILI &gt; 2 times ULN and ALKPH &lt;= 2 times ULN"
  ),
  keep_nas = TRUE
)
</code></pre>

<hr>
<h2 id='derive_param_doseint'>Adds a Parameter for Dose Intensity</h2><span id='topic+derive_param_doseint'></span>

<h3>Description</h3>

<p>Adds a record for the dose intensity for each by group
(e.g., subject and visit) where the source parameters are available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>
<p>The analysis value of the new parameter is derived as
Total Dose / Planned Dose * 100
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_doseint(
  dataset,
  by_vars,
  set_values_to = exprs(PARAMCD = "TNDOSINT"),
  tadm_code = "TNDOSE",
  tpadm_code = "TSNDOSE",
  zero_doses = "Inf",
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_doseint_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>tadm_code</code> and <code>padm_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_tadm_code">tadm_code</code></td>
<td>
<p>Total Doses Administered parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the total dose administered.  The <code>AVAL</code> associated with this <code>PARAMCD</code>
will be the numerator of the dose intensity calculation.
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_tpadm_code">tpadm_code</code></td>
<td>
<p>Total Doses Planned parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the total planned dose.  The <code>AVAL</code> associated with this <code>PARAMCD</code>
will be the denominator of the dose intensity calculation.
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_zero_doses">zero_doses</code></td>
<td>
<p>Flag indicating logic for handling 0 planned or
administered doses for a <code>by_vars</code> group
</p>
<p>Default: <code>Inf</code>
</p>
<p>Permitted Values: <code>Inf</code>, <code>100</code>
</p>
<p>No record is returned if either the planned (<code>tpadm_code</code>) or administered
(<code>tadm_code</code>) <code>AVAL</code> are <code>NA</code>.  No record is returned is a record does not
exist for both <code>tadm_code</code> and <code>tpadm_code</code> for the specified <code>by_var</code>.
</p>
<p>If <code>zero_doses</code> = <code>Inf</code>:
</p>

<ol>
<li><p> If the planned dose (<code>tpadm_code</code>) is 0 and administered dose
(<code>tadm_code</code>) is 0, <code>NaN</code> is returned.
</p>
</li>
<li><p> If the planned dose (<code>tpadm_code</code>) is 0 and the administered dose
(<code>tadm_code</code>) is &gt; 0, <code>Inf</code> is returned.
</p>
</li></ol>

<p>If <code>zero_doses</code> = <code>100</code> :
</p>

<ol>
<li><p> If the planned dose (<code>tpadm_code</code>) is 0 and administered dose
(<code>tadm_code</code>) is 0, 0 is returned.
</p>
</li>
<li><p> If the planned dose (<code>tpadm_code</code>) is 0 and the administered dose
(<code>tadm_code</code>) is &gt; 0, 100 is returned.
</p>
</li></ol>
</td></tr>
<tr><td><code id="derive_param_doseint_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with the new parameter rows added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate, warn.conflicts = FALSE)

adex &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~VISIT, ~ANL01FL, ~ASTDT, ~AENDT, ~AVAL,
  "P001", "TNDOSE", "V1", "Y", ymd("2020-01-01"), ymd("2020-01-30"), 59,
  "P001", "TSNDOSE", "V1", "Y", ymd("2020-01-01"), ymd("2020-02-01"), 96,
  "P001", "TNDOSE", "V2", "Y", ymd("2020-02-01"), ymd("2020-03-15"), 88,
  "P001", "TSNDOSE", "V2", "Y", ymd("2020-02-05"), ymd("2020-03-01"), 88,
  "P002", "TNDOSE", "V1", "Y", ymd("2021-01-01"), ymd("2021-01-30"), 0,
  "P002", "TSNDOSE", "V1", "Y", ymd("2021-01-01"), ymd("2021-02-01"), 0,
  "P002", "TNDOSE", "V2", "Y", ymd("2021-02-01"), ymd("2021-03-15"), 52,
  "P002", "TSNDOSE", "V2", "Y", ymd("2021-02-05"), ymd("2021-03-01"), 0
)

derive_param_doseint(
  adex,
  by_vars = exprs(USUBJID, VISIT),
  set_values_to = exprs(PARAMCD = "TNDOSINT"),
  tadm_code = "TNDOSE",
  tpadm_code = "TSNDOSE"
)

derive_param_doseint(
  adex,
  by_vars = exprs(USUBJID, VISIT),
  set_values_to = exprs(PARAMCD = "TDOSINT2"),
  tadm_code = "TNDOSE",
  tpadm_code = "TSNDOSE",
  zero_doses = "100"
)
</code></pre>

<hr>
<h2 id='derive_param_exist_flag'>Add an Existence Flag Parameter</h2><span id='topic+derive_param_exist_flag'></span>

<h3>Description</h3>

<p>Add a new parameter indicating that a certain event exists in a dataset.
<code>AVALC</code> and <code>AVAL</code> indicate if an event occurred or not. For example, the
function can derive a parameter indicating if there is measurable disease at
baseline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_exist_flag(
  dataset = NULL,
  dataset_ref,
  dataset_add,
  condition,
  true_value = "Y",
  false_value = NA_character_,
  missing_value = NA_character_,
  filter_add = NULL,
  by_vars = get_admiral_option("subject_keys"),
  set_values_to
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_exist_flag_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code> is expected as well.</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Reference dataset, e.g., ADSL
</p>
<p>The variables specified in <code>by_vars</code> are expected. For each group
(as defined by <code>by_vars</code>) from the specified dataset (<code>dataset_ref</code>),
the existence flag is calculated and added as a new observation to the
input datasets (<code>dataset</code>).</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code> parameter are expected.
</p>
<p>This dataset is used to check if an event occurred or not. Any observation
in the dataset fulfilling the event condition (<code>condition</code>) is considered
as an event.</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_condition">condition</code></td>
<td>
<p>Event condition
</p>
<p>The condition is evaluated at the additional dataset (<code>dataset_add</code>).
</p>
<p>For all groups where it evaluates as <code>TRUE</code> at least once <code>AVALC</code> is set
to the true value (<code>true_value</code>) for the new observations.
</p>
<p>For all groups where it evaluates as <code>FALSE</code> or <code>NA</code> for all observations
<code>AVALC</code> is set to the false value (<code>false_value</code>).
</p>
<p>For all groups not present in the additional dataset <code>AVALC</code> is set to
the missing value (<code>missing_value</code>).</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>For all groups with at least one observations in the additional dataset
(<code>dataset_add</code>) fulfilling the event condition (<code>condition</code>), <code>AVALC</code> is
set to the specified value (<code>true_value</code>).
</p>
<p><em>Default</em>: <code>"Y"</code>
</p>
<p><em>Permitted Value</em>: A character scalar</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>For all groups with at least one observations in the additional dataset
(<code>dataset_add</code>) but none of them is fulfilling the event condition
(<code>condition</code>), <code>AVALC</code> is set to the specified value (<code>false_value</code>).
</p>
<p><em>Default</em>: <code>NA_character_</code>
</p>
<p><em>Permitted Value</em>: A character scalar</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_missing_value">missing_value</code></td>
<td>
<p>Values used for missing information
</p>
<p>For all groups without an observation in the additional dataset
(<code>dataset_add</code>), <code>AVALC</code> is set to the specified value (<code>missing_value</code>).
</p>
<p><em>Default</em>: <code>NA_character_</code>
</p>
<p><em>Permitted Value</em>: A character scalar</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional data
</p>
<p>Only observations fulfilling the specified condition are taken into account
for flagging. If the parameter is not specified, all observations are
considered.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_exist_flag_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to set
</p>
<p>A named list returned by <code>exprs()</code> defining the variables to be set for the
new parameter, e.g. <code>exprs(PARAMCD = "MDIS", PARAM = "Measurable Disease at Baseline")</code> is expected. The values must be symbols, character strings,
numeric values, <code>NA</code>, or expressions.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The additional dataset (<code>dataset_add</code>) is restricted to the observations
matching the <code>filter_add</code> condition.
</p>
</li>
<li><p> For each group in <code>dataset_ref</code> a new observation is created.
</p>

<ul>
<li><p> The <code>AVALC</code> variable is added and set to the true value (<code>true_value</code>)
if for the group at least one observation exists in the (restricted)
additional dataset where the condition evaluates to <code>TRUE</code>.
</p>
</li>
<li><p> It is set to the false value (<code>false_value</code>) if for the group at least
one observation exists and for all observations the condition evaluates
to <code>FALSE</code> or <code>NA</code>.
</p>
</li>
<li><p> Otherwise, it is set to the missing value (<code>missing_value</code>), i.e., for
those groups not in <code>dataset_add</code>.
</p>
</li></ul>

</li>
<li><p> The variables specified by the <code>set_values_to</code> parameter are added to
the new observations.
</p>
</li>
<li><p> The new observations are added to input dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with a new parameter indicating if an event
occurred (<code>AVALC</code> and the variables specified by <code>by_vars</code>
and <code>set_value_to</code> are populated for the new parameter).
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

# Derive a new parameter for measurable disease at baseline
adsl &lt;- tribble(
  ~USUBJID,
  "1",
  "2",
  "3"
) %&gt;%
  mutate(STUDYID = "XX1234")

tu &lt;- tribble(
  ~USUBJID, ~VISIT,      ~TUSTRESC,
  "1",      "SCREENING", "TARGET",
  "1",      "WEEK 1",    "TARGET",
  "1",      "WEEK 5",    "TARGET",
  "1",      "WEEK 9",    "NON-TARGET",
  "2",      "SCREENING", "NON-TARGET",
  "2",      "SCREENING", "NON-TARGET"
) %&gt;%
  mutate(
    STUDYID = "XX1234",
    TUTESTCD = "TUMIDENT"
  )

derive_param_exist_flag(
  dataset_ref = adsl,
  dataset_add = tu,
  filter_add = TUTESTCD == "TUMIDENT" &amp; VISIT == "SCREENING",
  condition = TUSTRESC == "TARGET",
  false_value = "N",
  missing_value = "N",
  set_values_to = exprs(
    AVAL = yn_to_numeric(AVALC),
    PARAMCD = "MDIS",
    PARAM = "Measurable Disease at Baseline"
  )
)
</code></pre>

<hr>
<h2 id='derive_param_exposure'>Add an Aggregated Parameter and Derive the Associated Start and End Dates</h2><span id='topic+derive_param_exposure'></span>

<h3>Description</h3>

<p>Add a record computed from the aggregated analysis value of another parameter and compute the
start (<code>ASTDT(M)</code>)and end date (<code>AENDT(M)</code>) as the minimum and maximum date by <code>by_vars</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_exposure(
  dataset = NULL,
  dataset_add,
  by_vars,
  input_code,
  analysis_var,
  summary_fun,
  filter = NULL,
  filter_add = NULL,
  set_values_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_exposure_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified for <code>by_vars</code>, <code>analysis_var</code>, <code>PARAMCD</code>,
alongside either <code>ASTDTM</code> and <code>AENDTM</code> or <code>ASTDT</code> and <code>AENDT</code> are also expected.
Observations from the specified dataset are going to be used to calculate and added
as new records to the input dataset (<code>dataset</code>).</p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_input_code">input_code</code></td>
<td>
<p>Required parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered to compute the
summary record.
</p>
<p><em>Permitted Values:</em> A character of <code>PARAMCD</code> value</p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable.</p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_summary_fun">summary_fun</code></td>
<td>
<p>Function that takes as an input the <code>analysis_var</code> and
performs the calculation.
This can include built-in functions as well as user defined functions,
for example <code>mean</code> or <code>function(x) mean(x, na.rm = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_filter">filter</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>filter_add</code> instead.
</p>
<p>Filter condition as logical expression to apply during
summary calculation. By default, filtering expressions are computed within
<code>by_vars</code> as this will help when an aggregating, lagging, or ranking
function is involved.
</p>
<p>For example,
</p>

<ul>
<li> <p><code>filter = (AVAL &gt; mean(AVAL, na.rm = TRUE))</code> will filter all <code>AVAL</code>
values greater than mean of <code>AVAL</code> with in <code>by_vars</code>.
</p>
</li>
<li> <p><code>filter = (dplyr::n() &gt; 2)</code> will filter n count of <code>by_vars</code> greater
than 2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter condition as logical expression to apply during
summary calculation. By default, filtering expressions are computed within
<code>by_vars</code> as this will help when an aggregating, lagging, or ranking
function is involved.
</p>
<p>For example,
</p>

<ul>
<li> <p><code>filter_add = (AVAL &gt; mean(AVAL, na.rm = TRUE))</code> will filter all <code>AVAL</code>
values greater than mean of <code>AVAL</code> with in <code>by_vars</code>.
</p>
</li>
<li> <p><code>filter_add = (dplyr::n() &gt; 2)</code> will filter n count of <code>by_vars</code> greater
than 2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="derive_param_exposure_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variable-value pairs
</p>
<p>Set a list of variables to some specified value for the new observation(s)
</p>

<ul>
<li><p> LHS refer to a variable. It is expected that at least <code>PARAMCD</code> is defined.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a symbol, a numeric
value, <code>NA</code>, or an expression.
(e.g.  <code>exprs(PARAMCD = "TDOSE",PARCAT1 = "OVERALL")</code>).
</p>
</li></ul>

<p><em>Permitted Values:</em> List of variable-value pairs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the <code>by_vars</code> parameter),
an observation is added to the output dataset and the defined values are set to the defined
variables
</p>


<h3>Value</h3>

<p>The input dataset with a new record added for each group (with respect to the variables
specified for the <code>by_vars</code> parameter). That is, a variable will only
be populated in this new record if it is specified in <code>by_vars</code>.
For each new record,
</p>

<ul>
<li><p> the variable specified <code>analysis_var</code> is computed as defined by <code>summary_fun</code>,
</p>
</li>
<li><p> the variable(s) specified on the LHS of <code>set_values_to</code> are set to their paired value (RHS).
In addition, the start and end date are computed as the minimum/maximum dates by <code>by_vars</code>.
</p>
</li></ul>

<p>If the input datasets contains
</p>

<ul>
<li><p> both <code>AxxDTM</code> and <code>AxxDT</code> then all <code>ASTDTM</code>,<code>AENDTM</code>, <code>ASTDT</code>, <code>AENDT</code> are computed
</p>
</li>
<li><p> only <code>AxxDTM</code> then <code>ASTDTM</code>,<code>AENDTM</code> are computed
</p>
</li>
<li><p> only <code>AxxDT</code> then <code>ASTDT</code>,<code>AENDT</code> are computed.
</p>
</li></ul>



<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)
library(stringr, warn.conflicts = FALSE)
adex &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~AVALC, ~VISIT, ~ASTDT, ~AENDT,
  "1015", "DOSE", 80, NA_character_, "BASELINE", ymd("2014-01-02"), ymd("2014-01-16"),
  "1015", "DOSE", 85, NA_character_, "WEEK 2", ymd("2014-01-17"), ymd("2014-06-18"),
  "1015", "DOSE", 82, NA_character_, "WEEK 24", ymd("2014-06-19"), ymd("2014-07-02"),
  "1015", "ADJ", NA, NA_character_, "BASELINE", ymd("2014-01-02"), ymd("2014-01-16"),
  "1015", "ADJ", NA, NA_character_, "WEEK 2", ymd("2014-01-17"), ymd("2014-06-18"),
  "1015", "ADJ", NA, NA_character_, "WEEK 24", ymd("2014-06-19"), ymd("2014-07-02"),
  "1017", "DOSE", 80, NA_character_, "BASELINE", ymd("2014-01-05"), ymd("2014-01-19"),
  "1017", "DOSE", 50, NA_character_, "WEEK 2", ymd("2014-01-20"), ymd("2014-05-10"),
  "1017", "DOSE", 65, NA_character_, "WEEK 24", ymd("2014-05-10"), ymd("2014-07-02"),
  "1017", "ADJ", NA, NA_character_, "BASELINE", ymd("2014-01-05"), ymd("2014-01-19"),
  "1017", "ADJ", NA, "ADVERSE EVENT", "WEEK 2", ymd("2014-01-20"), ymd("2014-05-10"),
  "1017", "ADJ", NA, NA_character_, "WEEK 24", ymd("2014-05-10"), ymd("2014-07-02")
) %&gt;%
  mutate(ASTDTM = ymd_hms(paste(ASTDT, "00:00:00")), AENDTM = ymd_hms(paste(AENDT, "00:00:00")))

# Cumulative dose
adex %&gt;%
  derive_param_exposure(
    dataset_add = adex,
    by_vars = exprs(USUBJID),
    set_values_to = exprs(PARAMCD = "TDOSE", PARCAT1 = "OVERALL"),
    input_code = "DOSE",
    analysis_var = AVAL,
    summary_fun = function(x) sum(x, na.rm = TRUE)
  ) %&gt;%
  select(-ASTDTM, -AENDTM)

# average dose in w2-24
adex %&gt;%
  derive_param_exposure(
    dataset_add = adex,
    by_vars = exprs(USUBJID),
    filter = VISIT %in% c("WEEK 2", "WEEK 24"),
    set_values_to = exprs(PARAMCD = "AVDW224", PARCAT1 = "WEEK2-24"),
    input_code = "DOSE",
    analysis_var = AVAL,
    summary_fun = function(x) mean(x, na.rm = TRUE)
  ) %&gt;%
  select(-ASTDTM, -AENDTM)

# Any dose adjustment?
adex %&gt;%
  derive_param_exposure(
    dataset_add = adex,
    by_vars = exprs(USUBJID),
    set_values_to = exprs(PARAMCD = "TADJ", PARCAT1 = "OVERALL"),
    input_code = "ADJ",
    analysis_var = AVALC,
    summary_fun = function(x) if_else(sum(!is.na(x)) &gt; 0, "Y", NA_character_)
  ) %&gt;%
  select(-ASTDTM, -AENDTM)
</code></pre>

<hr>
<h2 id='derive_param_extreme_record'>Adds a Parameter Based on First or Last Record from Multiple Sources</h2><span id='topic+derive_param_extreme_record'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>derive_param_extreme_record()</code>
function has been superseded in favor of <code>derive_extreme_event()</code>.
</p>
<p>Generates parameter based on the first or last observation from multiple
source datasets, based on user-defined filter, order and by group criteria.
All variables of the selected observation are kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_extreme_record(
  dataset = NULL,
  sources,
  source_datasets,
  by_vars = NULL,
  order,
  mode,
  set_values_to
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_extreme_record_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_sources">sources</code></td>
<td>
<p>Sources
</p>
<p>A list of <code>records_source()</code> objects is expected.</p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_source_datasets">source_datasets</code></td>
<td>
<p>Source datasets
</p>
<p>A named list of datasets is expected. The <code>dataset_name</code> field of
<code>records_source()</code> refers to the dataset provided in the list. The variables
specified by the <code>order</code> and the <code>by_vars</code> arguments are expected after applying <code>new_vars</code>.</p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>If the argument is specified, for each by group the observations are
selected separately.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If the argument is set to a non-null value, for each by group the first or
last observation from the source datasets is selected with respect to
the specified order. Variables created via <code>new_vars</code> e.g., imputed date variables,
can be specified as well (see examples below).
</p>
<p>Please note that <code>NA</code> is considered as the last value. I.e., if a order
variable is <code>NA</code> and <code>mode = "last"</code>, this observation is chosen while for
<code>mode = "first"</code> the observation is chosen only if there are no
observations where the variable is not <code>NA</code>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, for each by group the first observation with
respect to <code>order</code> is included in the output dataset. If <code>"last"</code> is
specified, the last observation is included in the output dataset.
</p>
<p>Permitted Values:  <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_param_extreme_record_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>A list of variable name-value pairs is expected.
</p>

<ul>
<li><p> LHS refers to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value or <code>NA</code>, e.g., <code>exprs(PARAMCD = "PD", PARAM =   "First Progressive Disease")</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps are performed to create the output dataset:
</p>

<ol>
<li><p> For each source dataset the observations as specified by
the <code>filter</code> element are selected.
</p>
</li>
<li><p> Variables specified by <code>new_vars</code> are created for each source dataset.
</p>
</li>
<li><p> The first or last observation (with respect to the
<code>order</code> variable) for each by group (specified by <code>by_vars</code>) from multiple sources
is selected and added to the input dataset. </p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the first or last observation of each by group
added as new observations.
</p>


<h3>See Also</h3>

<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aevent_samp &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD,                       ~PARAM,     ~RSSTDTC,
  "1",          "PD",  "First Progressive Disease", "2022-04-01",
  "2",          "PD",  "First Progressive Disease", "2021-04-01",
  "3",          "PD",  "First Progressive Disease", "2023-04-01"
)

cm &lt;- tibble::tribble(
  ~STUDYID, ~USUBJID, ~CMDECOD,     ~CMSTDTC,
  "1001",        "1",    "ACT", "2021-12-25"
)

pr &lt;- tibble::tribble(
  ~STUDYID, ~USUBJID, ~PRDECOD,     ~PRSTDTC,
  "1001",        "1",    "ACS", "2021-12-27",
  "1001",        "2",    "ACS", "2020-12-25",
  "1001",        "3",    "ACS", "2022-12-25",
)
derive_param_extreme_record(
  dataset = aevent_samp,
  sources = list(
    records_source(
      dataset_name = "cm",
      filter = CMDECOD == "ACT",
      new_vars = exprs(
        ADT = convert_dtc_to_dt(CMSTDTC),
        AVALC = CMDECOD
      )
    ),
    records_source(
      dataset_name = "pr",
      filter = PRDECOD == "ACS",
      new_vars = exprs(
        ADT = convert_dtc_to_dt(PRSTDTC),
        AVALC = PRDECOD
      )
    )
  ),
  source_datasets = list(cm = cm, pr = pr),
  by_vars = exprs(USUBJID),
  order = exprs(ADT),
  mode = "first",
  set_values_to = exprs(
    PARAMCD = "FIRSTACT",
    PARAM = "First Anti-Cancer Therapy"
  )
)
</code></pre>

<hr>
<h2 id='derive_param_framingham'>Adds a Parameter for Framingham Heart Study Cardiovascular Disease
10-Year Risk Score</h2><span id='topic+derive_param_framingham'></span>

<h3>Description</h3>

<p>Adds a record for framingham score (FCVD101) for each by group
(e.g., subject and visit) where the source parameters are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_framingham(
  dataset,
  by_vars,
  set_values_to = exprs(PARAMCD = "FCVD101"),
  sysbp_code = "SYSBP",
  chol_code = "CHOL",
  cholhdl_code = "CHOLHDL",
  age = AGE,
  sex = SEX,
  smokefl = SMOKEFL,
  diabetfl = DIABETFL,
  trthypfl = TRTHYPFL,
  get_unit_expr,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_framingham_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>sysbp_code</code>, <code>chol_code</code>
and <code>hdl_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_sysbp_code">sysbp_code</code></td>
<td>
<p>Systolic blood pressure parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the systolic blood pressure assessments.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_chol_code">chol_code</code></td>
<td>
<p>Total serum cholesterol code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the total cholesterol assessments. This must be measured in mg/dL.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_cholhdl_code">cholhdl_code</code></td>
<td>
<p>HDL serum cholesterol code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the HDL cholesterol assessments. This must be measured in mg/dL.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_age">age</code></td>
<td>
<p>Subject age
</p>
<p>A variable containing the subject's age.
</p>
<p><em>Permitted Values:</em> A numeric variable name that refers to a subject age
column of the input dataset</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_sex">sex</code></td>
<td>
<p>Subject sex
</p>
<p>A variable containing the subject's sex.
</p>
<p><em>Permitted Values:</em> A character variable name that refers to a subject sex
column of the input dataset</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_smokefl">smokefl</code></td>
<td>
<p>Smoking status flag
</p>
<p>A flag indicating smoking status.
</p>
<p><em>Permitted Values:</em> A character variable name that refers to a smoking status
column of the input dataset.</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_diabetfl">diabetfl</code></td>
<td>
<p>Diabetic flag
</p>
<p>A flag indicating diabetic status.
</p>
<p><em>Permitted Values:</em> A character variable name that refers to a diabetic
status column of the input dataset</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_trthypfl">trthypfl</code></td>
<td>
<p>Treated with hypertension medication flag
</p>
<p>A flag indicating if a subject was treated with hypertension medication.
</p>
<p><em>Permitted Values:</em> A character variable name that refers to a column that
indicates whether a subject is treated for high blood
pressure</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_framingham_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values of <code>age</code>, <code>sex</code>, <code>smokefl</code>, <code>diabetfl</code> and <code>trthypfl</code> will be
added to the <code>by_vars</code> list.
The predicted probability of having cardiovascular disease (CVD)
within 10-years according to Framingham formula. See AHA Journal article
General Cardiovascular Risk Profile for Use in Primary Care for reference.
</p>
<p><strong>For Women:</strong>
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>Factor</strong> </td><td style="text-align: right;"> <strong>Amount</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
Age </td><td style="text-align: right;"> 2.32888 </td>
</tr>
<tr>
 <td style="text-align: right;">
Total Chol </td><td style="text-align: right;"> 1.20904 </td>
</tr>
<tr>
 <td style="text-align: right;">
HDL Chol </td><td style="text-align: right;"> -0.70833 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP </td><td style="text-align: right;"> 2.76157 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP + Hypertension Meds </td><td style="text-align: right;"> 2.82263 </td>
</tr>
<tr>
 <td style="text-align: right;">
Smoker </td><td style="text-align: right;"> 0.52873 </td>
</tr>
<tr>
 <td style="text-align: right;">
Non-Smoker </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Diabetic </td><td style="text-align: right;"> 0.69154 </td>
</tr>
<tr>
 <td style="text-align: right;">
Not Diabetic </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Average Risk </td><td style="text-align: right;"> 26.1931 </td>
</tr>
<tr>
 <td style="text-align: right;">
Risk Period </td><td style="text-align: right;"> 0.95012 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>For Men:</strong>
</p>

<table>
<tr>
 <td style="text-align: right;">
<strong>Factor</strong> </td><td style="text-align: right;"> <strong>Amount</strong> </td>
</tr>
<tr>
 <td style="text-align: right;">
Age </td><td style="text-align: right;"> 3.06117 </td>
</tr>
<tr>
 <td style="text-align: right;">
Total Chol </td><td style="text-align: right;"> 1.12370 </td>
</tr>
<tr>
 <td style="text-align: right;">
HDL Chol </td><td style="text-align: right;"> -0.93263 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP </td><td style="text-align: right;"> 1.93303 </td>
</tr>
<tr>
 <td style="text-align: right;">
Sys BP + Hypertension Meds </td><td style="text-align: right;"> 2.99881 </td>
</tr>
<tr>
 <td style="text-align: right;">
Smoker </td><td style="text-align: right;"> .65451  </td>
</tr>
<tr>
 <td style="text-align: right;">
Non-Smoker </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Diabetic </td><td style="text-align: right;"> 0.57367  </td>
</tr>
<tr>
 <td style="text-align: right;">
Not Diabetic </td><td style="text-align: right;"> 0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Average Risk </td><td style="text-align: right;"> 23.9802 </td>
</tr>
<tr>
 <td style="text-align: right;">
Risk Period </td><td style="text-align: right;"> 0.88936 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>

<p><strong>The equation for calculating risk:</strong>
</p>
<p style="text-align: center;"><code class="reqn">RiskFactors = (log(Age) * AgeFactor)
+ (log(TotalChol) * TotalCholFactor)
+ (log(CholHDL) * CholHDLFactor) \\
+ (log(SysBP) * SysBPFactor) + Smoker
+ Diabetes Present - AvgRisk</code>
</p>

<p style="text-align: center;"><code class="reqn">Risk = 100 * (1 - RiskPeriodFactor^{RiskFactors})</code>
</p>



<h3>Value</h3>

<p>The input dataset with the new parameter added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_framingham">compute_framingham()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adcvrisk &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~AVALU,
  ~VISIT, ~AGE, ~SEX, ~SMOKEFL, ~DIABETFL, ~TRTHYPFL,
  "01-701-1015", "SYSBP", "Systolic Blood Pressure (mmHg)", 121,
  "mmHg", "BASELINE", 44, "F", "N", "N", "N",
  "01-701-1015", "SYSBP", "Systolic Blood Pressure (mmHg)", 115,
  "mmHg", "WEEK 2", 44, "F", "N", "N", "Y",
  "01-701-1015", "CHOL", "Total Cholesterol (mg/dL)", 216.16,
  "mg/dL", "BASELINE", 44, "F", "N", "N", "N",
  "01-701-1015", "CHOL", "Total Cholesterol (mg/dL)", 210.78,
  "mg/dL", "WEEK 2", 44, "F", "N", "N", "Y",
  "01-701-1015", "CHOLHDL", "Cholesterol/HDL-Cholesterol (mg/dL)", 54.91,
  "mg/dL", "BASELINE", 44, "F", "N", "N", "N",
  "01-701-1015", "CHOLHDL", "Cholesterol/HDL-Cholesterol (mg/dL)", 26.72,
  "mg/dL", "WEEK 2", 44, "F", "N", "N", "Y",
  "01-701-1028", "SYSBP", "Systolic Blood Pressure (mmHg)", 119,
  "mmHg", "BASELINE", 55, "M", "Y", "Y", "Y",
  "01-701-1028", "SYSBP", "Systolic Blood Pressure (mmHg)", 101,
  "mmHg", "WEEK 2", 55, "M", "Y", "Y", "Y",
  "01-701-1028", "CHOL", "Total Cholesterol (mg/dL)", 292.01,
  "mg/dL", "BASELINE", 55, "M", "Y", "Y", "Y",
  "01-701-1028", "CHOL", "Total Cholesterol (mg/dL)", 246.73,
  "mg/dL", "WEEK 2", 55, "M", "Y", "Y", "Y",
  "01-701-1028", "CHOLHDL", "Cholesterol/HDL-Cholesterol (mg/dL)", 65.55,
  "mg/dL", "BASELINE", 55, "M", "Y", "Y", "Y",
  "01-701-1028", "CHOLHDL", "Cholesterol/HDL-Cholesterol (mg/dL)", 44.62,
  "mg/dL", "WEEK 2", 55, "M", "Y", "Y", "Y"
)


adcvrisk %&gt;%
  derive_param_framingham(
    by_vars = exprs(USUBJID, VISIT),
    set_values_to = exprs(
      PARAMCD = "FCVD101",
      PARAM = "FCVD1-Framingham CVD 10-Year Risk Score (%)"
    ),
    get_unit_expr = AVALU
  )

derive_param_framingham(
  adcvrisk,
  by_vars = exprs(USUBJID, VISIT),
  set_values_to = exprs(
    PARAMCD = "FCVD101",
    PARAM = "FCVD1-Framingham CVD 10-Year Risk Score (%)"
  ),
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_param_map'>Adds a Parameter for Mean Arterial Pressure</h2><span id='topic+derive_param_map'></span>

<h3>Description</h3>

<p>Adds a record for mean arterial pressure (MAP) for each by group
(e.g., subject and visit) where the source parameters are available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_map(
  dataset,
  by_vars,
  set_values_to = exprs(PARAMCD = "MAP"),
  sysbp_code = "SYSBP",
  diabp_code = "DIABP",
  hr_code = NULL,
  get_unit_expr,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_map_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>sysbp_code</code>, <code>diabp_code</code>
and <code>hr_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_sysbp_code">sysbp_code</code></td>
<td>
<p>Systolic blood pressure parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the systolic blood pressure assessments.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_diabp_code">diabp_code</code></td>
<td>
<p>Diastolic blood pressure parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the diastolic blood pressure assessments.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_hr_code">hr_code</code></td>
<td>
<p>Heart rate parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the heart rate assessments.
</p>
<p><em>Permitted Values:</em> character value</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_map_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The analysis value of the new parameter is derived as
</p>
<p style="text-align: center;"><code class="reqn">\frac{2DIABP + SYSBP}{3}</code>
</p>

<p>if it is based on diastolic and systolic blood pressure and
</p>
<p style="text-align: center;"><code class="reqn">DIABP + 0.01 e^{4.14 - \frac{40.74}{HR}} (SYSBP - DIABP)</code>
</p>

<p>if it is based on diastolic, systolic blood pressure, and heart rate.
</p>


<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_map">compute_map()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)

advs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~VISIT,
  "01-701-1015", "PULSE", "Pulse (beats/min)", 59, "BASELINE",
  "01-701-1015", "PULSE", "Pulse (beats/min)", 61, "WEEK 2",
  "01-701-1015", "DIABP", "Diastolic Blood Pressure (mmHg)", 51, "BASELINE",
  "01-701-1015", "DIABP", "Diastolic Blood Pressure (mmHg)", 50, "WEEK 2",
  "01-701-1015", "SYSBP", "Systolic Blood Pressure (mmHg)", 121, "BASELINE",
  "01-701-1015", "SYSBP", "Systolic Blood Pressure (mmHg)", 121, "WEEK 2",
  "01-701-1028", "PULSE", "Pulse (beats/min)", 62, "BASELINE",
  "01-701-1028", "PULSE", "Pulse (beats/min)", 77, "WEEK 2",
  "01-701-1028", "DIABP", "Diastolic Blood Pressure (mmHg)", 79, "BASELINE",
  "01-701-1028", "DIABP", "Diastolic Blood Pressure (mmHg)", 80, "WEEK 2",
  "01-701-1028", "SYSBP", "Systolic Blood Pressure (mmHg)", 130, "BASELINE",
  "01-701-1028", "SYSBP", "Systolic Blood Pressure (mmHg)", 132, "WEEK 2"
)

# Derive MAP based on diastolic and systolic blood pressure
advs %&gt;%
  derive_param_map(
    by_vars = exprs(USUBJID, VISIT),
    set_values_to = exprs(
      PARAMCD = "MAP",
      PARAM = "Mean Arterial Pressure (mmHg)"
    ),
    get_unit_expr = extract_unit(PARAM)
  ) %&gt;%
  filter(PARAMCD != "PULSE")

# Derive MAP based on diastolic and systolic blood pressure and heart rate
derive_param_map(
  advs,
  by_vars = exprs(USUBJID, VISIT),
  hr_code = "PULSE",
  set_values_to = exprs(
    PARAMCD = "MAP",
    PARAM = "Mean Arterial Pressure (mmHg)"
  ),
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_param_qtc'>Adds a Parameter for Corrected QT (an ECG measurement)</h2><span id='topic+derive_param_qtc'></span>

<h3>Description</h3>

<p>Adds a record for corrected QT using either Bazett's, Fridericia's or Sagie's
formula for each by group (e.g., subject and visit) where the source parameters
are available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_qtc(
  dataset,
  by_vars,
  method,
  set_values_to = default_qtc_paramcd(method),
  qt_code = "QT",
  rr_code = "RR",
  get_unit_expr,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_qtc_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>get_unit_expr</code> arguments are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>qt_code</code> and <code>rr_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_method">method</code></td>
<td>
<p>Method used to QT correction
</p>
<p>Permitted Values: <code>"Bazett"</code>, <code>"Fridericia"</code>, <code>"Sagie"</code></p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_qt_code">qt_code</code></td>
<td>
<p>QT parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the QT interval assessments. It is expected that QT is measured in msec.
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_rr_code">rr_code</code></td>
<td>
<p>RR parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the RR interval assessments. It is expected that RR is measured in msec.
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_qtc_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_qtc">compute_qtc()</a></code>
</p>
<p><code><a href="#topic+compute_qtc">compute_qtc()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adeg &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~AVALU, ~VISIT,
  "01-701-1015", "HR", "Heart Rate (beats/min)", 70.14, "beats/min", "BASELINE",
  "01-701-1015", "QT", "QT Duration (msec)", 370, "msec", "WEEK 2",
  "01-701-1015", "HR", "Heart Rate (beats/min)", 62.66, "beats/min", "WEEK 1",
  "01-701-1015", "RR", "RR Duration (msec)", 710, "msec", "WEEK 2",
  "01-701-1028", "HR", "Heart Rate (beats/min)", 85.45, "beats/min", "BASELINE",
  "01-701-1028", "QT", "QT Duration (msec)", 480, "msec", "WEEK 2",
  "01-701-1028", "QT", "QT Duration (msec)", 350, "msec", "WEEK 3",
  "01-701-1028", "HR", "Heart Rate (beats/min)", 56.54, "beats/min", "WEEK 3",
  "01-701-1028", "RR", "RR Duration (msec)", 842, "msec", "WEEK 2",
)

derive_param_qtc(
  adeg,
  by_vars = exprs(USUBJID, VISIT),
  method = "Bazett",
  set_values_to = exprs(
    PARAMCD = "QTCBR",
    PARAM = "QTcB - Bazett's Correction Formula Rederived (msec)",
    AVALU = "msec"
  ),
  get_unit_expr = AVALU
)

derive_param_qtc(
  adeg,
  by_vars = exprs(USUBJID, VISIT),
  method = "Fridericia",
  set_values_to = exprs(
    PARAMCD = "QTCFR",
    PARAM = "QTcF - Fridericia's Correction Formula Rederived (msec)",
    AVALU = "msec"
  ),
  get_unit_expr = extract_unit(PARAM)
)

derive_param_qtc(
  adeg,
  by_vars = exprs(USUBJID, VISIT),
  method = "Sagie",
  set_values_to = exprs(
    PARAMCD = "QTLCR",
    PARAM = "QTlc - Sagie's Correction Formula Rederived (msec)",
    AVALU = "msec"
  ),
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_param_rr'>Adds a Parameter for Derived RR (an ECG measurement)</h2><span id='topic+derive_param_rr'></span>

<h3>Description</h3>

<p>Adds a record for derived RR based on heart rate for each by group (e.g.,
subject and visit) where the source parameters are available.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_param_computed()</code>.
</p>
<p>The analysis value of the new parameter is derived as
</p>
<p style="text-align: center;"><code class="reqn">\frac{60000}{HR}</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>derive_param_rr(
  dataset,
  by_vars,
  set_values_to = exprs(PARAMCD = "RRR"),
  hr_code = "HR",
  get_unit_expr,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_rr_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset after restricting it by the filter condition (<code>filter</code>
parameter) and to the parameters specified by <code>hr_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_rr_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>For each group defined by <code>by_vars</code> an observation is added to the output
dataset. Only variables specified in <code>by_vars</code> will be populated
in the newly created records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_rr_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations. For example <code>exprs(PARAMCD = "MAP")</code> defines the parameter code
for the new parameter.
</p>
<p><em>Permitted Values</em>: List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_param_rr_+3A_hr_code">hr_code</code></td>
<td>
<p>HR parameter code
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the heart rate assessments.
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_rr_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: A variable of the input dataset or a function call</p>
</td></tr>
<tr><td><code id="derive_param_rr_+3A_filter">filter</code></td>
<td>
<p>Filter condition
</p>
<p>The specified condition is applied to the input dataset before deriving the
new parameter, i.e., only observations fulfilling the condition are taken
into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with the new parameter added. Note, a variable will only
be populated in the new parameter rows if it is specified in <code>by_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_rr">compute_rr()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adeg &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~PARAM, ~AVAL, ~AVALU, ~VISIT,
  "01-701-1015", "HR", "Heart Rate", 70.14, "beats/min", "BASELINE",
  "01-701-1015", "QT", "QT Duration", 370, "msec", "WEEK 2",
  "01-701-1015", "HR", "Heart Rate", 62.66, "beats/min", "WEEK 1",
  "01-701-1015", "RR", "RR Duration", 710, "msec", "WEEK 2",
  "01-701-1028", "HR", "Heart Rate", 85.45, "beats/min", "BASELINE",
  "01-701-1028", "QT", "QT Duration", 480, "msec", "WEEK 2",
  "01-701-1028", "QT", "QT Duration", 350, "msec", "WEEK 3",
  "01-701-1028", "HR", "Heart Rate", 56.54, "beats/min", "WEEK 3",
  "01-701-1028", "RR", "RR Duration", 842, "msec", "WEEK 2"
)

derive_param_rr(
  adeg,
  by_vars = exprs(USUBJID, VISIT),
  set_values_to = exprs(
    PARAMCD = "RRR",
    PARAM = "RR Duration Rederived (msec)",
    AVALU = "msec"
  ),
  get_unit_expr = AVALU
)
</code></pre>

<hr>
<h2 id='derive_param_tte'>Derive a Time-to-Event Parameter</h2><span id='topic+derive_param_tte'></span>

<h3>Description</h3>

<p>Add a time-to-event parameter to the input dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_tte(
  dataset = NULL,
  dataset_adsl,
  source_datasets,
  by_vars = NULL,
  start_date = TRTSDT,
  event_conditions,
  censor_conditions,
  create_datetime = FALSE,
  set_values_to,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_tte_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
<code>PARAMCD</code> is expected.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_dataset_adsl">dataset_adsl</code></td>
<td>
<p>ADSL input dataset
</p>
<p>The variables specified for <code>start_date</code>, and
<code>subject_keys</code> are expected.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_source_datasets">source_datasets</code></td>
<td>
<p>Source datasets
</p>
<p>A named list of datasets is expected. The <code>dataset_name</code> field of
<code>tte_source()</code> refers to the dataset provided in the list.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_by_vars">by_vars</code></td>
<td>
<p>By variables
</p>
<p>If the parameter is specified, separate time to event parameters are
derived for each by group.
</p>
<p>The by variables must be in at least one of the source datasets. Each
source dataset must contain either all by variables or none of the by
variables.
</p>
<p>The by variables are not included in the output dataset.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_start_date">start_date</code></td>
<td>
<p>Time to event origin date
</p>
<p>The variable <code>STARTDT</code> is set to the specified date. The value is taken
from the ADSL dataset.
</p>
<p>If the event or censoring date is before the origin date, <code>ADT</code> is set to
the origin date.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_event_conditions">event_conditions</code></td>
<td>
<p>Sources and conditions defining events
</p>
<p>A list of <code>event_source()</code> objects is expected.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_censor_conditions">censor_conditions</code></td>
<td>
<p>Sources and conditions defining censorings
</p>
<p>A list of <code>censor_source()</code> objects is expected.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_create_datetime">create_datetime</code></td>
<td>
<p>Create datetime variables?
</p>
<p>If set to <code>TRUE</code>, variables <code>ADTM</code> and <code>STARTDTM</code> are created. Otherwise,
variables <code>ADT</code> and <code>STARTDT</code> are created.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to set
</p>
<p>A named list returned by <code>exprs()</code> defining the variables to be set for the
new parameter, e.g. <code>exprs(PARAMCD = "OS", PARAM = "Overall Survival")</code> is
expected. The values must be symbols, character strings, numeric values,
expressions, or <code>NA</code>.</p>
</td></tr>
<tr><td><code id="derive_param_tte_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of symbols created using <code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps are performed to create the observations of the
new parameter:
</p>
<p><strong>Deriving the events:</strong>
</p>
 <ol>
<li><p> For each event source dataset the observations as
specified by the <code>filter</code> element are selected. Then for each patient the
first observation (with respect to <code>date</code>) is selected.
</p>
</li>
<li><p> The <code>ADT</code> variable is set to the variable specified by the
<code>date</code> element. If the date variable is a datetime variable, only
the datepart is copied.
</p>
</li>
<li><p> The <code>CNSR</code> variable is added and set to the <code>censor</code> element.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> element are
added.
</p>
</li>
<li><p> The selected observations of all event source datasets are combined into a
single dataset.
</p>
</li>
<li><p> For each patient the first observation (with respect to the <code>ADT</code>
variable) from the single dataset is selected. </p>
</li></ol>

<p><strong>Deriving the censoring observations:</strong>
</p>
 <ol>
<li><p> For each censoring source dataset the observations as
specified by the <code>filter</code> element are selected. Then for each patient the
last observation (with respect to <code>date</code>) is selected.
</p>
</li>
<li><p> The <code>ADT</code> variable is set to the variable specified by the
<code>date</code> element. If the date variable is a datetime variable, only
the datepart is copied.
</p>
</li>
<li><p> The <code>CNSR</code> variable is added and set to the <code>censor</code> element.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> element are
added.
</p>
</li>
<li><p> The selected observations of all censoring source datasets are
combined into a single dataset.
</p>
</li>
<li><p> For each patient the last observation (with respect to the <code>ADT</code>
variable) from the single dataset is selected. </p>
</li></ol>

<p>For each subject (as defined by the <code>subject_keys</code> parameter) an
observation is selected. If an event is available, the event observation is
selected. Otherwise the censoring observation is selected.
</p>
<p>Finally:
</p>

<ol>
<li><p> The variable specified for <code>start_date</code> is joined from the
ADSL dataset. Only subjects in both datasets are kept,
i.e., subjects with both an event or censoring and an observation in
<code>dataset_adsl</code>.
</p>
</li>
<li><p> The variables as defined by the <code>set_values_to</code> parameter are added.
</p>
</li>
<li><p> The <code>ADT</code>/<code>ADTM</code> variable is set to the maximum of <code>ADT</code>/<code>ADTM</code> and
<code>STARTDT</code>/<code>STARTDTM</code> (depending on the <code>create_datetime</code> parameter).
</p>
</li>
<li><p> The new observations are added to the output dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the new parameter added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event_source">event_source()</a></code>, <code><a href="#topic+censor_source">censor_source()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)
data("admiral_adsl")

adsl &lt;- admiral_adsl

# derive overall survival parameter
death &lt;- event_source(
  dataset_name = "adsl",
  filter = DTHFL == "Y",
  date = DTHDT,
  set_values_to = exprs(
    EVNTDESC = "DEATH",
    SRCDOM = "ADSL",
    SRCVAR = "DTHDT"
  )
)

last_alive_dt &lt;- censor_source(
  dataset_name = "adsl",
  date = LSTALVDT,
  set_values_to = exprs(
    EVNTDESC = "LAST DATE KNOWN ALIVE",
    SRCDOM = "ADSL",
    SRCVAR = "LSTALVDT"
  )
)

derive_param_tte(
  dataset_adsl = adsl,
  event_conditions = list(death),
  censor_conditions = list(last_alive_dt),
  source_datasets = list(adsl = adsl),
  set_values_to = exprs(
    PARAMCD = "OS",
    PARAM = "Overall Survival"
  )
) %&gt;%
  select(-STUDYID) %&gt;%
  filter(row_number() %in% 20:30)

# derive duration of response
# only observations for subjects in dataset_adsl are created
adsl &lt;- tribble(
  ~USUBJID, ~DTHFL, ~DTHDT,            ~RSPDT,
  "01",     "Y",    ymd("2021-06-12"), ymd("2021-03-04"),
  "02",     "N",    NA,                NA,
  "03",     "Y",    ymd("2021-08-21"), NA,
  "04",     "N",    NA,                ymd("2021-04-14")
) %&gt;%
  mutate(STUDYID = "AB42")

adrs &lt;- tribble(
  ~USUBJID, ~AVALC, ~ADT,              ~ASEQ,
  "01",     "SD",   ymd("2021-01-03"), 1,
  "01",     "PR",   ymd("2021-03-04"), 2,
  "01",     "PD",   ymd("2021-05-05"), 3,
  "02",     "PD",   ymd("2021-02-03"), 1,
  "04",     "SD",   ymd("2021-02-13"), 1,
  "04",     "PR",   ymd("2021-04-14"), 2,
  "04",     "CR",   ymd("2021-05-15"), 3
) %&gt;%
  mutate(STUDYID = "AB42", PARAMCD = "OVR")

pd &lt;- event_source(
  dataset_name = "adrs",
  filter = AVALC == "PD",
  date = ADT,
  set_values_to = exprs(
    EVENTDESC = "PD",
    SRCDOM = "ADRS",
    SRCVAR = "ADTM",
    SRCSEQ = ASEQ
  )
)

death &lt;- event_source(
  dataset_name = "adsl",
  filter = DTHFL == "Y",
  date = DTHDT,
  set_values_to = exprs(
    EVENTDESC = "DEATH",
    SRCDOM = "ADSL",
    SRCVAR = "DTHDT"
  )
)

lastvisit &lt;- censor_source(
  dataset_name = "adrs",
  date = ADT,
  censor = 1,
  set_values_to = exprs(
    EVENTDESC = "LAST TUMOR ASSESSMENT",
    SRCDOM = "ADRS",
    SRCVAR = "ADTM",
    SRCSEQ = ASEQ
  )
)

first_response &lt;- censor_source(
  dataset_name = "adsl",
  date = RSPDT,
  censor = 1,
  set_values_to = exprs(
    EVENTDESC = "FIRST RESPONSE",
    SRCDOM = "ADSL",
    SRCVAR = "RSPDT"
  )
)

derive_param_tte(
  dataset_adsl = filter(adsl, !is.na(RSPDT)),
  start_date = RSPDT,
  event_conditions = list(pd, death),
  censor_conditions = list(lastvisit, first_response),
  source_datasets = list(adsl = adsl, adrs = adrs),
  set_values_to = exprs(
    PARAMCD = "DURRSP",
    PARAM = "Duration of Response"
  )
)

# derive time to adverse event for each preferred term
adsl &lt;- tribble(
  ~USUBJID, ~TRTSDT,           ~EOSDT,
  "01",     ymd("2020-12-06"), ymd("2021-03-06"),
  "02",     ymd("2021-01-16"), ymd("2021-02-03")
) %&gt;%
  mutate(STUDYID = "AB42")

ae &lt;- tribble(
  ~USUBJID, ~AESTDTC,           ~AESEQ, ~AEDECOD,
  "01",     "2021-01-03T10:56", 1,      "Flu",
  "01",     "2021-03-04",       2,      "Cough",
  "01",     "2021",             3,      "Flu"
) %&gt;%
  mutate(STUDYID = "AB42")

ae_ext &lt;- derive_vars_dt(
  ae,
  dtc = AESTDTC,
  new_vars_prefix = "AEST",
  highest_imputation = "M",
  flag_imputation = "none"
)

ttae &lt;- event_source(
  dataset_name = "ae",
  date = AESTDT,
  set_values_to = exprs(
    EVNTDESC = "AE",
    SRCDOM = "AE",
    SRCVAR = "AESTDTC",
    SRCSEQ = AESEQ
  )
)

eos &lt;- censor_source(
  dataset_name = "adsl",
  date = EOSDT,
  set_values_to = exprs(
    EVNTDESC = "END OF STUDY",
    SRCDOM = "ADSL",
    SRCVAR = "EOSDT"
  )
)

derive_param_tte(
  dataset_adsl = adsl,
  by_vars = exprs(AEDECOD),
  start_date = TRTSDT,
  event_conditions = list(ttae),
  censor_conditions = list(eos),
  source_datasets = list(adsl = adsl, ae = ae_ext),
  set_values_to = exprs(
    PARAMCD = paste0("TTAE", as.numeric(as.factor(AEDECOD))),
    PARAM = paste("Time to First", AEDECOD, "Adverse Event"),
    PARCAT1 = "TTAE",
    PARCAT2 = AEDECOD
  )
) %&gt;%
  select(USUBJID, STARTDT, PARAMCD, PARAM, ADT, CNSR, SRCSEQ)
</code></pre>

<hr>
<h2 id='derive_param_wbc_abs'>Add a parameter for lab differentials converted to absolute values</h2><span id='topic+derive_param_wbc_abs'></span>

<h3>Description</h3>

<p>Add a parameter by converting lab differentials from fraction or percentage to absolute values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_param_wbc_abs(
  dataset,
  by_vars,
  set_values_to,
  get_unit_expr,
  wbc_unit = "10^9/L",
  wbc_code = "WBC",
  diff_code,
  diff_type = "fraction"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_param_wbc_abs_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.
<code>PARAMCD</code>, and <code>AVAL</code> are expected as well.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the input dataset, and to the parameters specified by <code>wbc_code</code> and <code>diff_code</code>.</p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to set
</p>
<p>A named list returned by <code>exprs()</code> defining the variables to be set for the
new parameter, e.g. <code>exprs(PARAMCD = "LYMPH", PARAM = "Lymphocytes Abs (10^9/L)")</code> is
expected.</p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters.
</p>
<p>Permitted Values: a variable containing unit from the input dataset, or a function call,
for example, <code>get_unit_expr = extract_unit(PARAM)</code>.</p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_wbc_unit">wbc_unit</code></td>
<td>
<p>A string containing the required unit of the WBC parameter
</p>
<p>Default: <code>"10^9/L"</code></p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_wbc_code">wbc_code</code></td>
<td>
<p>White Blood Cell (WBC) parameter
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the WBC absolute results to use for converting the differentials.
</p>
<p>Default: <code>"WBC"</code>
</p>
<p>Permitted Values: character value</p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_diff_code">diff_code</code></td>
<td>
<p>white blood differential parameter
</p>
<p>The observations where <code>PARAMCD</code> equals the specified value are considered
as the white blood differential lab results in fraction or percentage value to be converted
into absolute value.</p>
</td></tr>
<tr><td><code id="derive_param_wbc_abs_+3A_diff_type">diff_type</code></td>
<td>
<p>A string specifying the type of differential
</p>
<p>Permitted Values: <code>"percent"</code>, <code>"fraction"</code>
Default: <code>fraction</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>diff_type</code> is <code>"percent"</code>, the analysis value of the new parameter is derived as
</p>
<p style="text-align: center;"><code class="reqn">\frac{White Blood Cell Count  * Percentage Value}{100}</code>
</p>

<p>If <code>diff_type</code> is <code>"fraction"</code>, the analysis value of the new parameter is derived as
</p>
<p style="text-align: center;"><code class="reqn">White Blood Cell Count  * Fraction Value</code>
</p>

<p>New records are created for each group of records (grouped by <code>by_vars</code>) if 1) the white blood
cell component in absolute value is not already available from the input dataset, and 2) the
white blood cell absolute value (identified by <code>wbc_code</code>) and the white blood cell differential
(identified by <code>diff_code</code>) are both present.
</p>


<h3>Value</h3>

<p>The input dataset with the new parameter added
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_summary_records">derive_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

test_lb &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~PARAM, ~VISIT,
  "P01", "WBC", 33, "Leukocyte Count (10^9/L)", "CYCLE 1 DAY 1",
  "P01", "WBC", 38, "Leukocyte Count (10^9/L)", "CYCLE 2 DAY 1",
  "P01", "LYMLE", 0.90, "Lymphocytes (fraction of 1)", "CYCLE 1 DAY 1",
  "P01", "LYMLE", 0.70, "Lymphocytes (fraction of 1)", "CYCLE 2 DAY 1",
  "P01", "ALB", 36, "Albumin (g/dL)", "CYCLE 2 DAY 1",
  "P02", "WBC", 33, "Leukocyte Count (10^9/L)", "CYCLE 1 DAY 1",
  "P02", "LYMPH", 29, "Lymphocytes Abs (10^9/L)", "CYCLE 1 DAY 1",
  "P02", "LYMLE", 0.87, "Lymphocytes (fraction of 1)", "CYCLE 1 DAY 1",
  "P03", "LYMLE", 0.89, "Lymphocytes (fraction of 1)", "CYCLE 1 DAY 1"
)

derive_param_wbc_abs(
  dataset = test_lb,
  by_vars = exprs(USUBJID, VISIT),
  set_values_to = exprs(
    PARAMCD = "LYMPH",
    PARAM = "Lymphocytes Abs (10^9/L)",
    DTYPE = "CALCULATION"
  ),
  get_unit_expr = extract_unit(PARAM),
  wbc_code = "WBC",
  diff_code = "LYMLE",
  diff_type = "fraction"
)
</code></pre>

<hr>
<h2 id='derive_summary_records'>Add New Records Within By Groups Using Aggregation Functions</h2><span id='topic+derive_summary_records'></span>

<h3>Description</h3>

<p>It is not uncommon to have an analysis need whereby one needs to derive an
analysis value (<code>AVAL</code>) from multiple records. The ADaM basic dataset
structure variable <code>DTYPE</code> is available to indicate when a new derived
records has been added to a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_summary_records(
  dataset = NULL,
  dataset_add,
  dataset_ref = NULL,
  by_vars,
  filter = NULL,
  filter_add = NULL,
  analysis_var,
  summary_fun,
  set_values_to,
  missing_values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_summary_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified for <code>by_vars</code> are expected.
Observations from the specified dataset are going to be used to calculate and added
as new records to the input dataset (<code>dataset</code>).</p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Reference dataset
</p>
<p>The variables specified for <code>by_vars</code> are expected. For each
observation of the specified dataset a new observation is added to the
input dataset.</p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Variables to consider for generation of groupwise summary
records. Providing the names of variables in <code><a href="#topic+exprs">exprs()</a></code> will create a
groupwise summary and generate summary records for the specified groups.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_filter">filter</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>filter_add</code> instead.
</p>
<p>Filter condition as logical expression to apply during
summary calculation. By default, filtering expressions are computed within
<code>by_vars</code> as this will help when an aggregating, lagging, or ranking
function is involved.
</p>
<p>For example,
</p>

<ul>
<li> <p><code>filter = (AVAL &gt; mean(AVAL, na.rm = TRUE))</code> will filter all <code>AVAL</code>
values greater than mean of <code>AVAL</code> with in <code>by_vars</code>.
</p>
</li>
<li> <p><code>filter = (dplyr::n() &gt; 2)</code> will filter n count of <code>by_vars</code> greater
than 2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter condition as logical expression to apply during
summary calculation. By default, filtering expressions are computed within
<code>by_vars</code> as this will help when an aggregating, lagging, or ranking
function is involved.
</p>
<p>For example,
</p>

<ul>
<li> <p><code>filter_add = (AVAL &gt; mean(AVAL, na.rm = TRUE))</code> will filter all <code>AVAL</code>
values greater than mean of <code>AVAL</code> with in <code>by_vars</code>.
</p>
</li>
<li> <p><code>filter_add = (dplyr::n() &gt; 2)</code> will filter n count of <code>by_vars</code> greater
than 2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.</p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_summary_fun">summary_fun</code></td>
<td>
<p>Function that takes as an input the <code>analysis_var</code> and
performs the calculation.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.
</p>
<p>This can include built-in functions as well as user defined functions,
for example <code>mean</code> or <code>function(x) mean(x, na.rm = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="derive_summary_records_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>Set a list of variables to some specified value for the new records
</p>

<ul>
<li><p> LHS refer to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, an expression or NA. If summary functions are
used, the values are summarized by the variables specified for <code>by_vars</code>.
</p>
</li></ul>

<p>For example:
</p>
<div class="sourceCode"><pre>  set_values_to = exprs(
    AVAL = sum(AVAL),
    DTYPE = "AVERAGE",
  )
</pre></div></td></tr>
<tr><td><code id="derive_summary_records_+3A_missing_values">missing_values</code></td>
<td>
<p>Values for missing summary values
</p>
<p>For observations of the reference dataset (<code>dataset_ref</code>) which do not have a
complete mapping defined by the summarization defined in <code>set_values_to</code>.  Only variables
specified for <code>set_values_to</code> can be specified for <code>missing_values</code>.
</p>
<p><em>Permitted Values</em>: named list of expressions, e.g.,
<code>exprs(AVAL = -9999)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When all records have same values within <code>by_vars</code> then this function will
retain those common values in the newly derived records. Otherwise new value
will be set to <code>NA</code>.
</p>


<h3>Value</h3>

<p>A data frame with derived records appended to original dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_summary_records">get_summary_records()</a></code>, <code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary()</a></code>
</p>
<p>BDS-Findings Functions for adding Parameters/Records: 
<code><a href="#topic+default_qtc_paramcd">default_qtc_paramcd</a>()</code>,
<code><a href="#topic+derive_expected_records">derive_expected_records</a>()</code>,
<code><a href="#topic+derive_extreme_event">derive_extreme_event</a>()</code>,
<code><a href="#topic+derive_extreme_records">derive_extreme_records</a>()</code>,
<code><a href="#topic+derive_locf_records">derive_locf_records</a>()</code>,
<code><a href="#topic+derive_param_bmi">derive_param_bmi</a>()</code>,
<code><a href="#topic+derive_param_bsa">derive_param_bsa</a>()</code>,
<code><a href="#topic+derive_param_computed">derive_param_computed</a>()</code>,
<code><a href="#topic+derive_param_doseint">derive_param_doseint</a>()</code>,
<code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag</a>()</code>,
<code><a href="#topic+derive_param_exposure">derive_param_exposure</a>()</code>,
<code><a href="#topic+derive_param_framingham">derive_param_framingham</a>()</code>,
<code><a href="#topic+derive_param_map">derive_param_map</a>()</code>,
<code><a href="#topic+derive_param_qtc">derive_param_qtc</a>()</code>,
<code><a href="#topic+derive_param_rr">derive_param_rr</a>()</code>,
<code><a href="#topic+derive_param_wbc_abs">derive_param_wbc_abs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)

adeg &lt;- tribble(
  ~USUBJID,   ~EGSEQ, ~PARAM,             ~AVISIT,    ~EGDTC,             ~AVAL, ~TRTA,
  "XYZ-1001", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:50", 385,   NA_character_,
  "XYZ-1001", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:52", 399,   NA_character_,
  "XYZ-1001", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:56", 396,   NA_character_,
  "XYZ-1001", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:45", 384,   "Placebo",
  "XYZ-1001", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:48", 393,   "Placebo",
  "XYZ-1001", 6,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:51", 388,   "Placebo",
  "XYZ-1001", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:45", 385,   "Placebo",
  "XYZ-1001", 8,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:48", 394,   "Placebo",
  "XYZ-1001", 9,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:51", 402,   "Placebo",
  "XYZ-1002", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 399,   NA_character_,
  "XYZ-1002", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 410,   NA_character_,
  "XYZ-1002", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-22T08:01", 392,   NA_character_,
  "XYZ-1002", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:50", 401,   "Active 20mg",
  "XYZ-1002", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:53", 407,   "Active 20mg",
  "XYZ-1002", 6,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:56", 400,   "Active 20mg",
  "XYZ-1002", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:50", 412,   "Active 20mg",
  "XYZ-1002", 8,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:53", 414,   "Active 20mg",
  "XYZ-1002", 9,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:56", 402,   "Active 20mg"
) %&gt;%
  mutate(
    ADTM = convert_dtc_to_dtm(EGDTC)
  )

# Summarize the average of the triplicate ECG interval values (AVAL)
derive_summary_records(
  adeg,
  dataset_add = adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  set_values_to = exprs(
    AVAL = mean(AVAL, na.rm = TRUE),
    DTYPE = "AVERAGE"
  )
) %&gt;%
  arrange(USUBJID, AVISIT)

# Derive more than one summary variable
derive_summary_records(
  adeg,
  dataset_add = adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  set_values_to = exprs(
    AVAL = mean(AVAL),
    ADTM = max(ADTM),
    DTYPE = "AVERAGE"
  )
) %&gt;%
  arrange(USUBJID, AVISIT) %&gt;%
  select(-EGSEQ, -TRTA)

# Sample ADEG dataset with triplicate record for only AVISIT = 'Baseline'
adeg &lt;- tribble(
  ~USUBJID,   ~EGSEQ, ~PARAM,             ~AVISIT,    ~EGDTC,             ~AVAL, ~TRTA,
  "XYZ-1001", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:50", 385,   NA_character_,
  "XYZ-1001", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:52", 399,   NA_character_,
  "XYZ-1001", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:56", 396,   NA_character_,
  "XYZ-1001", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:48", 393,   "Placebo",
  "XYZ-1001", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:51", 388,   "Placebo",
  "XYZ-1001", 6,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:48", 394,   "Placebo",
  "XYZ-1001", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:51", 402,   "Placebo",
  "XYZ-1002", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 399,   NA_character_,
  "XYZ-1002", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 410,   NA_character_,
  "XYZ-1002", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-22T08:01", 392,   NA_character_,
  "XYZ-1002", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:53", 407,   "Active 20mg",
  "XYZ-1002", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:56", 400,   "Active 20mg",
  "XYZ-1002", 6,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:53", 414,   "Active 20mg",
  "XYZ-1002", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:56", 402,   "Active 20mg"
)

# Compute the average of AVAL only if there are more than 2 records within the
# by group
derive_summary_records(
  adeg,
  dataset_add = adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  filter_add = n() &gt; 2,
  set_values_to = exprs(
    AVAL = mean(AVAL, na.rm = TRUE),
    DTYPE = "AVERAGE"
  )
) %&gt;%
  arrange(USUBJID, AVISIT)
</code></pre>

<hr>
<h2 id='derive_var_age_years'>Derive Age in Years</h2><span id='topic+derive_var_age_years'></span>

<h3>Description</h3>

<p>Converts the given age variable (<code>age_var</code>) to the unit 'years' from the current
units given in the <code>age_var+U</code> variable or <code>age_unit</code> argument and stores
in a new variable (<code>new_var</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_age_years(dataset, age_var, age_unit = NULL, new_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_age_years_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>age_var</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_age_years_+3A_age_var">age_var</code></td>
<td>
<p>Age variable.
</p>
<p>A numeric object is expected.</p>
</td></tr>
<tr><td><code id="derive_var_age_years_+3A_age_unit">age_unit</code></td>
<td>
<p>Age unit.
</p>
<p>The <code>age_unit</code> argument is only expected when there is NOT a variable <code>age_var+U</code>
in <code>dataset</code>. This gives the unit of the <code>age_var</code> variable and is used to convert
AGE to 'years' so that grouping can occur.
</p>
<p>Default: NULL
</p>
<p>Permitted Values: 'years', 'months', 'weeks', 'days', 'hours', 'minutes', 'seconds'</p>
</td></tr>
<tr><td><code id="derive_var_age_years_+3A_new_var">new_var</code></td>
<td>
<p>New age variable to be created in years. The returned values are
doubles and NOT integers.
'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to convert an age variable into the unit 'years'
which can then be used to create age groups. The resulting column contains the
equivalent years as a double. Note, underlying computations assume an equal number
of days in each year (365.25).
</p>


<h3>Value</h3>

<p>The input dataset (<code>dataset</code>) with <code>new_var</code> variable added in years.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_duration">derive_vars_duration()</a></code>
</p>
<p>ADSL Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_vars_aage">derive_vars_aage</a>()</code>,
<code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event</a>()</code>,
<code><a href="#topic+derive_vars_period">derive_vars_period</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# Derive age with age units specified
data &lt;- tribble(
  ~AGE, ~AGEU,
  27, "days",
  24, "months",
  3, "years",
  4, "weeks",
  1, "years"
)

derive_var_age_years(data, AGE, new_var = AAGE)

# Derive age without age units variable specified
data &lt;- tribble(
  ~AGE,
  12,
  24,
  36,
  48
)
derive_var_age_years(data, AGE, age_unit = "months", new_var = AAGE)
</code></pre>

<hr>
<h2 id='derive_var_analysis_ratio'>Derive Ratio Variable</h2><span id='topic+derive_var_analysis_ratio'></span>

<h3>Description</h3>

<p>Derives a ratio variable for a BDS dataset based on user specified variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_analysis_ratio(dataset, numer_var, denom_var, new_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_analysis_ratio_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>numer_var</code> and <code>denom_var</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_analysis_ratio_+3A_numer_var">numer_var</code></td>
<td>
<p>Variable containing numeric values to be used in the numerator of
the ratio calculation.</p>
</td></tr>
<tr><td><code id="derive_var_analysis_ratio_+3A_denom_var">denom_var</code></td>
<td>
<p>Variable containing numeric values to be used in the denominator of
the ratio calculation.</p>
</td></tr>
<tr><td><code id="derive_var_analysis_ratio_+3A_new_var">new_var</code></td>
<td>
<p>A user-defined variable that will be appended to the dataset.
The default behavior will take the denominator variable and prefix it with <code>R2</code>
and append to the dataset. Using this argument will override this default behavior.
</p>
<p>Default is <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A user wishing to calculate a Ratio to Baseline, <code>AVAL / BASE</code> will
have returned a new variable <code>R2BASE</code> that will be appended to the input dataset.
Ratio to Analysis Range Lower Limit <code>AVAL / ANRLO</code> will return a new variable
<code>R2ANRLO</code>, and Ratio to Analysis Range  Upper Limit <code>AVAL / ANRHI</code> will return
a new variable <code>R2ANRLO</code>. Please note how the denominator variable has the prefix
<code style="white-space: pre;">&#8288;R2----&#8288;</code>. A user can override the default returned variables by using the
<code>new_var</code> argument. Also, values of 0 in the denominator will return <code>NA</code> in
the derivation.
</p>
<p>Reference CDISC ADaM Implementation Guide
Version 1.1 Section 3.3.4 Analysis Parameter Variables for BDS Datasets
</p>


<h3>Value</h3>

<p>The input dataset with a ratio variable appended
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

data &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~SEQ, ~AVAL, ~BASE, ~ANRLO, ~ANRHI,
  "P01", "ALT", 1, 27, 27, 6, 34,
  "P01", "ALT", 2, 41, 27, 6, 34,
  "P01", "ALT", 3, 17, 27, 6, 34,
  "P02", "ALB", 1, 38, 38, 33, 49,
  "P02", "ALB", 2, 39, 38, 33, 49,
  "P02", "ALB", 3, 37, 38, 33, 49
)

# Returns "R2" prefixed variables
data %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = BASE) %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = ANRLO) %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = ANRHI)

# Returns user-defined variables
data %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = BASE, new_var = R01BASE) %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = ANRLO, new_var = R01ANRLO) %&gt;%
  derive_var_analysis_ratio(numer_var = AVAL, denom_var = ANRHI, new_var = R01ANRHI)
</code></pre>

<hr>
<h2 id='derive_var_anrind'>Derive Reference Range Indicator</h2><span id='topic+derive_var_anrind'></span>

<h3>Description</h3>

<p>Derive Reference Range Indicator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_anrind(
  dataset,
  signif_dig = get_admiral_option("signif_digits"),
  use_a1hia1lo = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_anrind_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
<code>ANRLO</code>, <code>ANRHI</code>, and <code>AVAL</code> are expected and if <code>use_a1hia1lo</code> is set to <code>TRUE</code>,
<code>A1LO</code> and <code>A1H1</code> are expected as well.</p>
</td></tr>
<tr><td><code id="derive_var_anrind_+3A_signif_dig">signif_dig</code></td>
<td>
<p>Number of significant digits to use when comparing values.
</p>
<p>Significant digits used to avoid floating point discrepancies when comparing numeric values.
See blog: <a href="https://pharmaverse.github.io/blog/posts/2023-10-30_floating_point/floating_point.html">How admiral handles floating points</a></p>
</td></tr>
<tr><td><code id="derive_var_anrind_+3A_use_a1hia1lo">use_a1hia1lo</code></td>
<td>
<p>A logical value indicating whether to use <code>A1H1</code> and <code>A1LO</code> in
the derivation of <code>ANRIND</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the case that <code>A1H1</code> and <code>A1LO</code> are to be used, <code>ANRIND</code> is set to:
</p>

<ul>
<li> <p><code>"NORMAL"</code> if <code>AVAL</code> is greater or equal <code>ANRLO</code> and less than
or equal <code>ANRHI</code>; or if <code>AVAL</code> is greater than or equal <code>ANRLO</code> and <code>ANRHI</code>
is missing; or if <code>AVAL</code> is less than or equal <code>ANRHI</code> and <code>ANRLO</code> is
missing
</p>
</li>
<li> <p><code>"LOW"</code> if <code>AVAL</code> is less than <code>ANRLO</code> and either <code>A1LO</code> is missing or <code>AVAL</code>
is greater than or equal <code>A1LO</code>
</p>
</li>
<li> <p><code>"HIGH"</code> if <code>AVAL</code> is greater than <code>ANRHI</code> and either <code>A1HI</code> is missing or <code>AVAL</code>
is less than or equal <code>A1HI</code>
</p>
</li>
<li> <p><code>"LOW LOW"</code> if <code>AVAL</code> is less than <code>A1LO</code>
</p>
</li>
<li> <p><code>"HIGH HIGH"</code> if <code>AVAL</code> is greater than <code>A1HI</code>
</p>
</li></ul>

<p>In the case that <code>A1H1</code> and <code>A1LO</code> are not to be used, <code>ANRIND</code> is set to:
</p>

<ul>
<li> <p><code>"NORMAL"</code> if <code>AVAL</code> is greater or equal <code>ANRLO</code> and less than
or equal <code>ANRHI</code>; or if <code>AVAL</code> is greater than or equal <code>ANRLO</code> and <code>ANRHI</code>
is missing; or if <code>AVAL</code> is less than or equal <code>ANRHI</code> and <code>ANRLO</code> is
missing
</p>
</li>
<li> <p><code>"LOW"</code> if <code>AVAL</code> is less than <code>ANRLO</code>
</p>
</li>
<li> <p><code>"HIGH"</code> if <code>AVAL</code> is greater than <code>ANRHI</code>
</p>
</li></ul>



<h3>Value</h3>

<p>The input dataset with additional column <code>ANRIND</code>
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)

vs &lt;- tibble::tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~ANRLO, ~ANRHI, ~A1LO, ~A1HI,
  "P01",       "PUL",    70,     60,    100,    40,   110,
  "P01",       "PUL",    57,     60,    100,    40,   110,
  "P01",       "PUL",    60,     60,    100,    40,   110,
  "P01",     "DIABP",   102,     60,     80,    40,    90,
  "P02",       "PUL",   109,     60,    100,    40,   110,
  "P02",       "PUL",   100,     60,    100,    40,   110,
  "P02",     "DIABP",    80,     60,     80,    40,    90,
  "P03",       "PUL",    39,     60,    100,    40,   110,
  "P03",       "PUL",    40,     60,    100,    40,   110
)

vs %&gt;% derive_var_anrind(use_a1hia1lo = TRUE)
vs %&gt;% derive_var_anrind(use_a1hia1lo = FALSE)

</code></pre>

<hr>
<h2 id='derive_var_atoxgr'>Derive Lab High toxicity Grade 0 - 4 and Low Toxicity Grades 0 - (-4)</h2><span id='topic+derive_var_atoxgr'></span>

<h3>Description</h3>

<p>Derives character lab grade based on high and low severity/toxicity grade(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_atoxgr(
  dataset,
  lotox_description_var = ATOXDSCL,
  hitox_description_var = ATOXDSCH
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_atoxgr_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>lotox_description_var</code> and <code>hitox_description_var</code> arguments are expected to be in the dataset.
<code>ATOXGRL</code>, and <code>ATOXGRH</code> are expected as well.</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_+3A_lotox_description_var">lotox_description_var</code></td>
<td>
<p>Variable containing the toxicity grade description
for low values, eg. &quot;Anemia&quot;</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_+3A_hitox_description_var">hitox_description_var</code></td>
<td>
<p>Variable containing the toxicity grade description
for high values, eg. &quot;Hemoglobin Increased&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Created variable <code>ATOXGR</code> will contain values &quot;-4&quot;, &quot;-3&quot;, &quot;-2&quot;, &quot;-1&quot; for low values
and &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; for high values, and will contain &quot;0&quot; if value is gradable
and does not satisfy any of the criteria for high or low values. ATOXGR is set to
missing if information not available to give a grade.
</p>
<p>Function applies the following rules:
</p>

<ul>
<li><p> High and low missing - overall missing
</p>
</li>
<li><p> Low grade not missing and &gt; 0 - overall holds low grade
</p>
</li>
<li><p> High grade not missing and &gt; 0 - overall holds high grade
</p>
</li>
<li><p> (Only high direction OR low direction is NORMAL) and high grade normal - overall NORMAL
</p>
</li>
<li><p> (Only low direction OR high direction is NORMAL) and low grade normal - overall NORMAL
</p>
</li>
<li><p> otherwise set to missing
</p>
</li></ul>



<h3>Value</h3>

<p>The input data set with the character variable added
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adlb &lt;- tribble(
  ~ATOXDSCL,          ~ATOXDSCH,        ~ATOXGRL,      ~ATOXGRH,
  "Hypoglycemia",     "Hyperglycemia",  NA_character_, "0",
  "Hypoglycemia",     "Hyperglycemia",  "0",           "1",
  "Hypoglycemia",     "Hyperglycemia",  "0",           "0",
  NA_character_,      "INR Increased",  NA_character_, "0",
  "Hypophosphatemia", NA_character_,    "1",           NA_character_
)

derive_var_atoxgr(adlb)
</code></pre>

<hr>
<h2 id='derive_var_atoxgr_dir'>Derive Lab Toxicity Grade 0 - 4</h2><span id='topic+derive_var_atoxgr_dir'></span>

<h3>Description</h3>

<p>Derives a character lab grade based on severity/toxicity criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_atoxgr_dir(
  dataset,
  new_var,
  tox_description_var,
  meta_criteria,
  criteria_direction,
  get_unit_expr,
  signif_dig = get_admiral_option("signif_digits")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_atoxgr_dir_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>tox_description_var</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_new_var">new_var</code></td>
<td>
<p>Name of the character grade variable to create, for example, <code>ATOXGRH</code>
or <code>ATOXGRL</code>.</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_tox_description_var">tox_description_var</code></td>
<td>
<p>Variable containing the description of the grading
criteria. For example: &quot;Anemia&quot; or &quot;INR Increased&quot;.</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_meta_criteria">meta_criteria</code></td>
<td>
<p>Metadata data set holding the criteria (normally a case statement)
</p>
<p>Permitted Values: <code>atoxgr_criteria_ctcv4</code>, <code>atoxgr_criteria_ctcv5</code>, <code>atoxgr_criteria_daids</code>
</p>

<ul>
<li> <p><code>atoxgr_criteria_ctcv4</code> implements <a href="https://ctep.cancer.gov/protocoldevelopment/electronic_applications/ctc.htm">Common Terminology Criteria for Adverse Events (CTCAE) v4.0</a>
</p>
</li>
<li> <p><code>atoxgr_criteria_ctcv5</code> implements <a href="https://ctep.cancer.gov/protocoldevelopment/electronic_applications/ctc.htm">Common Terminology Criteria for Adverse Events (CTCAE) v5.0</a>
</p>
</li>
<li> <p><code>atoxgr_criteria_daids</code> implements
<a href="https://rsc.niaid.nih.gov/sites/default/files/daidsgradingcorrectedv21.pdf">Division of AIDS (DAIDS) Table for Grading the Severity of Adult and Pediatric Adverse Events</a>
</p>
<p>The metadata should have the following variables:
</p>
</li>
<li> <p><code>TERM</code>: variable to hold the term describing the criteria applied to a particular lab test,
eg. &quot;Anemia&quot; or &quot;INR Increased&quot;. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>DIRECTION</code>: variable to hold the direction of the abnormality of a particular lab test
value. &quot;L&quot; is for LOW values, &quot;H&quot; is for HIGH values. Note: the variable is case insensitive.
</p>
</li>
<li> <p><code>SI_UNIT_CHECK</code>: variable to hold unit of particular lab test. Used to check against input data
if criteria is based on absolute values.
</p>
</li>
<li> <p><code>VAR_CHECK</code>: variable to hold comma separated list of variables used in criteria. Used to check
against input data that variables exist.
</p>
</li>
<li> <p><code>GRADE_CRITERIA_CODE</code>: variable to hold code that creates grade based on defined criteria.
</p>
</li>
<li> <p><code>FILTER</code>: Required only for DAIDS grading, specifies <code>admiral</code> code to filter the lab data
based on a subset of subjects (e.g. AGE &gt; 18 YEARS)
</p>
</li></ul>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_criteria_direction">criteria_direction</code></td>
<td>
<p>Direction (L= Low, H = High) of toxicity grade.
</p>
<p>Permitted Values: &quot;L&quot;, &quot;H&quot;</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_get_unit_expr">get_unit_expr</code></td>
<td>
<p>An expression providing the unit of the parameter
</p>
<p>The result is used to check the units of the input parameters. Compared with
<code>SI_UNIT_CHECK</code> in metadata (see <code>meta_criteria</code> parameter).
</p>
<p>Permitted Values: A variable containing unit from the input dataset, or a function call,
for example, <code>get_unit_expr = extract_unit(PARAM)</code>.</p>
</td></tr>
<tr><td><code id="derive_var_atoxgr_dir_+3A_signif_dig">signif_dig</code></td>
<td>
<p>Number of significant digits to use when comparing a lab value against another
value.
</p>
<p>Significant digits used to avoid floating point discrepancies when comparing numeric values.
See blog: <a href="https://pharmaverse.github.io/blog/posts/2023-10-30_floating_point/floating_point.html">How admiral handles floating points</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>new_var</code> is derived with values NA, &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, where &quot;4&quot; is the most
severe grade
</p>

<ul>
<li><p> &quot;4&quot; is where the lab value satisfies the criteria for grade 4.
</p>
</li>
<li><p> &quot;3&quot; is where the lab value satisfies the criteria for grade 3.
</p>
</li>
<li><p> &quot;2&quot; is where the lab value satisfies the criteria for grade 2.
</p>
</li>
<li><p> &quot;1&quot; is where the lab value satisfies the criteria for grade 1.
</p>
</li>
<li><p> &quot;0&quot; is where a grade can be derived and is not grade &quot;1&quot;, &quot;2&quot;, &quot;3&quot; or &quot;4&quot;.
</p>
</li>
<li><p> NA is where a grade cannot be derived.
</p>
</li></ul>



<h3>Value</h3>

<p>The input dataset with the character variable added
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

data &lt;- tribble(
  ~ATOXDSCL,                    ~AVAL, ~ANRLO, ~ANRHI, ~PARAM,
  "Hypoglycemia",               119,   4,      7,      "Glucose (mmol/L)",
  "Lymphocyte count decreased", 0.7,   1,      4,      "Lymphocytes Abs (10^9/L)",
  "Anemia",                     129,   120,    180,    "Hemoglobin (g/L)",
  "White blood cell decreased", 10,    5,      20,     "White blood cell (10^9/L)",
  "White blood cell decreased", 15,    5,      20,     "White blood cell (10^9/L)",
  "Anemia",                     140,   120,    180,    "Hemoglobin (g/L)"
)

derive_var_atoxgr_dir(data,
  new_var = ATOXGRL,
  tox_description_var = ATOXDSCL,
  meta_criteria = atoxgr_criteria_ctcv5,
  criteria_direction = "L",
  get_unit_expr = extract_unit(PARAM)
)

data &lt;- tribble(
  ~ATOXDSCH,                     ~AVAL,  ~ANRLO,   ~ANRHI, ~PARAM,
  "CPK increased",               129,    0,        30,     "Creatine Kinase (U/L)",
  "Lymphocyte count increased",  4,      1,        4,      "Lymphocytes Abs (10^9/L)",
  "Lymphocyte count increased",  2,      1,        4,      "Lymphocytes Abs (10^9/L)",
  "CPK increased",               140,    120,      180,    "Creatine Kinase (U/L)"
)

derive_var_atoxgr_dir(data,
  new_var = ATOXGRH,
  tox_description_var = ATOXDSCH,
  meta_criteria = atoxgr_criteria_ctcv5,
  criteria_direction = "H",
  get_unit_expr = extract_unit(PARAM)
)
</code></pre>

<hr>
<h2 id='derive_var_base'>Derive Baseline Variables</h2><span id='topic+derive_var_base'></span>

<h3>Description</h3>

<p>Derive baseline variables, e.g. <code>BASE</code> or <code>BNRIND</code>, in a BDS dataset.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_vars_merged()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_base(
  dataset,
  by_vars,
  source_var = AVAL,
  new_var = BASE,
  filter = ABLFL == "Y"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_base_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>source_var</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_base_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Grouping variables uniquely identifying a set
of records for which to calculate <code>new_var</code>.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_base_+3A_source_var">source_var</code></td>
<td>
<p>The column from which to extract the baseline value, e.g. <code>AVAL</code></p>
</td></tr>
<tr><td><code id="derive_var_base_+3A_new_var">new_var</code></td>
<td>
<p>The name of the newly created baseline column, e.g. <code>BASE</code></p>
</td></tr>
<tr><td><code id="derive_var_base_+3A_filter">filter</code></td>
<td>
<p>The condition used to filter <code>dataset</code> for baseline records.
</p>
<p>By default <code>ABLFL == "Y"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>by_vars</code> group, the baseline record is identified by the
condition specified in <code>filter</code> which defaults to <code>ABLFL == "Y"</code>. Subsequently,
every value of the <code>new_var</code> variable for the <code>by_vars</code> group is set to the
value of the <code>source_var</code> variable of the baseline record. In case there are
multiple baseline records within <code>by_vars</code> an error is issued.
</p>


<h3>Value</h3>

<p>A new <code>data.frame</code> containing all records and variables of the input
dataset plus the <code>new_var</code> variable
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

dataset &lt;- tribble(
  ~STUDYID, ~USUBJID,   ~PARAMCD, ~AVAL,   ~AVALC,      ~AVISIT, ~ABLFL,  ~ANRIND,
  "TEST01",  "PAT01",  "PARAM01", 10.12,       NA,   "Baseline",    "Y", "NORMAL",
  "TEST01",  "PAT01",  "PARAM01", 9.700,       NA,      "Day 7",    "N",    "LOW",
  "TEST01",  "PAT01",  "PARAM01", 15.01,       NA,     "Day 14",    "N",   "HIGH",
  "TEST01",  "PAT01",  "PARAM02", 8.350,       NA,   "Baseline",    "Y",    "LOW",
  "TEST01",  "PAT01",  "PARAM02",    NA,       NA,      "Day 7",    "N",       NA,
  "TEST01",  "PAT01",  "PARAM02", 8.350,       NA,     "Day 14",    "N",    "LOW",
  "TEST01",  "PAT01",  "PARAM03",    NA,    "LOW",   "Baseline",    "Y",       NA,
  "TEST01",  "PAT01",  "PARAM03",    NA,    "LOW",      "Day 7",    "N",       NA,
  "TEST01",  "PAT01",  "PARAM03",    NA, "MEDIUM",     "Day 14",    "N",       NA,
  "TEST01",  "PAT01",  "PARAM04",    NA,   "HIGH",   "Baseline",    "Y",       NA,
  "TEST01",  "PAT01",  "PARAM04",    NA,   "HIGH",      "Day 7",    "N",       NA,
  "TEST01",  "PAT01",  "PARAM04",    NA, "MEDIUM",     "Day 14",    "N",       NA
)

## Derive `BASE` variable from `AVAL`
derive_var_base(
  dataset,
  by_vars = exprs(USUBJID, PARAMCD),
  source_var = AVAL,
  new_var = BASE
)

## Derive `BASEC` variable from `AVALC`
derive_var_base(
  dataset,
  by_vars = exprs(USUBJID, PARAMCD),
  source_var = AVALC,
  new_var = BASEC
)

## Derive `BNRIND` variable from `ANRIND`
derive_var_base(
  dataset,
  by_vars = exprs(USUBJID, PARAMCD),
  source_var = ANRIND,
  new_var = BNRIND
)
</code></pre>

<hr>
<h2 id='derive_var_chg'>Derive Change from Baseline</h2><span id='topic+derive_var_chg'></span>

<h3>Description</h3>

<p>Derive change from baseline (<code>CHG</code>) in a BDS dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_chg(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_chg_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset <code>AVAL</code> and <code>BASE</code> are expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Change from baseline is calculated by subtracting the baseline value
from the analysis value.
</p>


<h3>Value</h3>

<p>The input dataset with an additional column named <code>CHG</code>
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

advs &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~ABLFL, ~BASE,
  "P01",    "WEIGHT", 80,    "Y",    80,
  "P01",    "WEIGHT", 80.8,  "",     80,
  "P01",    "WEIGHT", 81.4,  "",     80,
  "P02",    "WEIGHT", 75.3,  "Y",    75.3,
  "P02",    "WEIGHT", 76,    "",     75.3
)
derive_var_chg(advs)
</code></pre>

<hr>
<h2 id='derive_var_dthcaus'>Derive Death Cause</h2><span id='topic+derive_var_dthcaus'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>derive_var_dthcaus()</code>
function has been superseded in favor of <code>derive_vars_extreme_event()</code>.
</p>
<p>Derive death cause (<code>DTHCAUS</code>) and add traceability variables if required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_dthcaus(
  dataset,
  ...,
  source_datasets,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_dthcaus_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>subject_keys</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_dthcaus_+3A_...">...</code></td>
<td>
<p>Objects of class &quot;dthcaus_source&quot; created by <code><a href="#topic+dthcaus_source">dthcaus_source()</a></code>.</p>
</td></tr>
<tr><td><code id="derive_var_dthcaus_+3A_source_datasets">source_datasets</code></td>
<td>
<p>A named <code>list</code> containing datasets in which to search for the
death cause</p>
</td></tr>
<tr><td><code id="derive_var_dthcaus_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of expressions where the expressions are symbols as returned by
<code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function derives <code>DTHCAUS</code> along with the user-defined traceability
variables, if required. If a subject has death info from multiple sources,
the one from the source with the earliest death date will be used. If dates are
equivalent, the first source will be kept, so the user should provide the inputs in
the preferred order.
</p>


<h3>Value</h3>

<p>The input dataset with <code>DTHCAUS</code> variable added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dthcaus_source">dthcaus_source()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)

adsl &lt;- tribble(
  ~STUDYID,  ~USUBJID,
  "STUDY01", "PAT01",
  "STUDY01", "PAT02",
  "STUDY01", "PAT03"
)
ae &lt;- tribble(
  ~STUDYID,  ~USUBJID, ~AESEQ, ~AEDECOD,       ~AEOUT,  ~AEDTHDTC,
  "STUDY01", "PAT01",  12,     "SUDDEN DEATH", "FATAL", "2021-04-04"
)

ds &lt;- tribble(
  ~STUDYID, ~USUBJID, ~DSSEQ, ~DSDECOD, ~DSTERM, ~DSSTDTC,
  "STUDY01", "PAT02", 1, "INFORMED CONSENT OBTAINED", "INFORMED CONSENT OBTAINED", "2021-04-03",
  "STUDY01", "PAT02", 2, "RANDOMIZATION", "RANDOMIZATION", "2021-04-11",
  "STUDY01", "PAT02", 3, "DEATH", "DEATH DUE TO PROGRESSION OF DISEASE", "2022-02-01",
  "STUDY01", "PAT03", 1, "DEATH", "POST STUDY REPORTING OF DEATH", "2022-03-03"
)

# Derive `DTHCAUS` only - for on-study deaths only
src_ae &lt;- dthcaus_source(
  dataset_name = "ae",
  filter = AEOUT == "FATAL",
  date = convert_dtc_to_dt(AEDTHDTC),
  mode = "first",
  dthcaus = AEDECOD
)

src_ds &lt;- dthcaus_source(
  dataset_name = "ds",
  filter = DSDECOD == "DEATH" &amp; grepl("DEATH DUE TO", DSTERM),
  date = convert_dtc_to_dt(DSSTDTC),
  mode = "first",
  dthcaus = DSTERM
)

derive_var_dthcaus(adsl, src_ae, src_ds, source_datasets = list(ae = ae, ds = ds))

# Derive `DTHCAUS` and add traceability variables - for on-study deaths only
src_ae &lt;- dthcaus_source(
  dataset_name = "ae",
  filter = AEOUT == "FATAL",
  date = convert_dtc_to_dt(AEDTHDTC),
  mode = "first",
  dthcaus = AEDECOD,
  set_values_to = exprs(DTHDOM = "AE", DTHSEQ = AESEQ)
)

src_ds &lt;- dthcaus_source(
  dataset_name = "ds",
  filter = DSDECOD == "DEATH" &amp; grepl("DEATH DUE TO", DSTERM),
  date = convert_dtc_to_dt(DSSTDTC),
  mode = "first",
  dthcaus = DSTERM,
  set_values_to = exprs(DTHDOM = "DS", DTHSEQ = DSSEQ)
)

derive_var_dthcaus(adsl, src_ae, src_ds, source_datasets = list(ae = ae, ds = ds))

# Derive `DTHCAUS` as above - now including post-study deaths with different `DTHCAUS` value
src_ae &lt;- dthcaus_source(
  dataset_name = "ae",
  filter = AEOUT == "FATAL",
  date = convert_dtc_to_dt(AEDTHDTC),
  mode = "first",
  dthcaus = AEDECOD,
  set_values_to = exprs(DTHDOM = "AE", DTHSEQ = AESEQ)
)

ds &lt;- mutate(
  ds,
  DSSTDT = convert_dtc_to_dt(DSSTDTC)
)

src_ds &lt;- dthcaus_source(
  dataset_name = "ds",
  filter = DSDECOD == "DEATH" &amp; grepl("DEATH DUE TO", DSTERM),
  date = DSSTDT,
  mode = "first",
  dthcaus = DSTERM,
  set_values_to = exprs(DTHDOM = "DS", DTHSEQ = DSSEQ)
)

src_ds_post &lt;- dthcaus_source(
  dataset_name = "ds",
  filter = DSDECOD == "DEATH" &amp; DSTERM == "POST STUDY REPORTING OF DEATH",
  date = DSSTDT,
  mode = "first",
  dthcaus = "POST STUDY: UNKNOWN CAUSE",
  set_values_to = exprs(DTHDOM = "DS", DTHSEQ = DSSEQ)
)

derive_var_dthcaus(
  adsl,
  src_ae, src_ds, src_ds_post,
  source_datasets = list(ae = ae, ds = ds)
)
</code></pre>

<hr>
<h2 id='derive_var_extreme_dt'>Derive First or Last Date from Multiple Sources</h2><span id='topic+derive_var_extreme_dt'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>derive_var_extreme_dt()</code>
function has been superseded in favor of <code>derive_vars_extreme_event()</code>.
</p>
<p>Add the first or last date from multiple sources to the
dataset, e.g., the last known alive date (<code>LSTALVDT</code>).
</p>
<p><strong>Note:</strong> This is a wrapper function for the function <code>derive_var_extreme_dtm()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_extreme_dt(
  dataset,
  new_var,
  ...,
  source_datasets,
  mode,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_extreme_dt_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>subject_keys</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dt_+3A_new_var">new_var</code></td>
<td>
<p>Name of variable to create</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dt_+3A_...">...</code></td>
<td>
<p>Source(s) of dates. One or more <code>date_source()</code> objects are
expected.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dt_+3A_source_datasets">source_datasets</code></td>
<td>
<p>A named <code>list</code> containing datasets in which to search
for the first or last date</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dt_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, the first date for each subject is selected. If
<code>"last"</code> is specified, the last date for each subject is selected.
</p>
<p>Permitted Values:  <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_var_extreme_dt_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of expressions where the expressions are symbols as returned by
<code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps are performed to create the output dataset:
</p>

<ol>
<li><p> For each source dataset the observations as specified by the <code>filter</code>
element are selected and observations where <code>date</code> is <code>NA</code> are removed.
Then for each patient the first or last observation (with respect to <code>date</code>
and <code>mode</code>) is selected.
</p>
</li>
<li><p> The new variable is set to the variable or expression specified by the
<code>date</code> element.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> element are added.
</p>
</li>
<li><p> The selected observations of all source datasets are combined into a
single dataset.
</p>
</li>
<li><p> For each patient the first or last observation (with respect to the new
variable and <code>mode</code>) from the single dataset is selected and the new
variable is merged to the input dataset.
</p>
</li>
<li><p> The time part is removed from the new variable.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the new variable added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+date_source">date_source()</a></code>, <code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm()</a></code>, <code><a href="#topic+derive_vars_merged">derive_vars_merged()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
ae &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AESEQ,     ~AESTDTC,     ~AEENDTC,
  "PILOT01",    "AE", "01-1130",      5, "2014-05-09", "2014-05-09",
  "PILOT01",    "AE", "01-1130",      6, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      4, "2014-05-09", "2014-05-09",
  "PILOT01",    "AE", "01-1130",      8, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      7, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      2, "2014-03-09", "2014-03-09",
  "PILOT01",    "AE", "01-1130",      1, "2014-03-09", "2014-03-16",
  "PILOT01",    "AE", "01-1130",      3, "2014-03-09", "2014-03-16",
  "PILOT01",    "AE", "01-1133",      1, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      3, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      2, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      4, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1211",      5, "2012-11-29",           NA,
  "PILOT01",    "AE", "01-1211",      1, "2012-11-16",           NA,
  "PILOT01",    "AE", "01-1211",      7, "2013-01-11",           NA,
  "PILOT01",    "AE", "01-1211",      8, "2013-01-11",           NA,
  "PILOT01",    "AE", "01-1211",      4, "2012-11-22",           NA,
  "PILOT01",    "AE", "01-1211",      2, "2012-11-21", "2012-11-21",
  "PILOT01",    "AE", "01-1211",      3, "2012-11-21",           NA,
  "PILOT01",    "AE", "01-1211",      6, "2012-12-09",           NA,
  "PILOT01",    "AE", "01-1211",      9, "2013-01-14", "2013-01-14",
  "PILOT01",    "AE", "09-1081",      2, "2014-05-01",           NA,
  "PILOT01",    "AE", "09-1081",      1, "2014-04-07",           NA,
  "PILOT01",    "AE", "09-1088",      1, "2014-05-08",           NA,
  "PILOT01",    "AE", "09-1088",      2, "2014-08-02",           NA
)

adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID,              ~TRTEDTM,      ~TRTEDT,
  "PILOT01", "01-1130", "2014-08-16 23:59:59", "2014-08-16",
  "PILOT01", "01-1133", "2013-04-28 23:59:59", "2013-04-28",
  "PILOT01", "01-1211", "2013-01-12 23:59:59", "2013-01-12",
  "PILOT01", "09-1081", "2014-04-27 23:59:59", "2014-04-27",
  "PILOT01", "09-1088", "2014-10-09 23:59:59", "2014-10-09"
) %&gt;%
  mutate(
    across(TRTEDTM:TRTEDT, as.Date)
  )


lb &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~LBSEQ,             ~LBDTC,
  "PILOT01",    "LB", "01-1130",    219, "2014-06-07T13:20",
  "PILOT01",    "LB", "01-1130",    322, "2014-08-16T13:10",
  "PILOT01",    "LB", "01-1133",    268, "2013-04-18T15:30",
  "PILOT01",    "LB", "01-1133",    304, "2013-04-29T10:13",
  "PILOT01",    "LB", "01-1211",      8, "2012-10-30T14:26",
  "PILOT01",    "LB", "01-1211",    162, "2013-01-08T12:13",
  "PILOT01",    "LB", "09-1081",     47, "2014-02-01T10:55",
  "PILOT01",    "LB", "09-1081",    219, "2014-05-10T11:15",
  "PILOT01",    "LB", "09-1088",    283, "2014-09-27T12:13",
  "PILOT01",    "LB", "09-1088",    322, "2014-10-09T13:25"
)

dm &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01",    "DM", "01-1130",   84, "YEARS",
  "PILOT01",    "DM", "01-1133",   81, "YEARS",
  "PILOT01",    "DM", "01-1211",   76, "YEARS",
  "PILOT01",    "DM", "09-1081",   86, "YEARS",
  "PILOT01",    "DM", "09-1088",   69, "YEARS"
)

ae_start &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dt(AESTDTC, highest_imputation = "M")
)
ae_end &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dt(AEENDTC, highest_imputation = "M")
)

ae_ext &lt;- ae %&gt;%
  derive_vars_dt(
    dtc = AESTDTC,
    new_vars_prefix = "AEST",
    highest_imputation = "M"
  ) %&gt;%
  derive_vars_dt(
    dtc = AEENDTC,
    new_vars_prefix = "AEEN",
    highest_imputation = "M"
  )

lb_date &lt;- date_source(
  dataset_name = "lb",
  date = convert_dtc_to_dt(LBDTC)
)

lb_ext &lt;- derive_vars_dt(
  lb,
  dtc = LBDTC,
  new_vars_prefix = "LB"
)

adsl_date &lt;- date_source(dataset_name = "adsl", date = TRTEDT)

dm %&gt;%
  derive_var_extreme_dt(
    new_var = LSTALVDT,
    ae_start, ae_end, lb_date, adsl_date,
    source_datasets = list(
      adsl = adsl,
      ae = ae_ext,
      lb = lb_ext
    ),
    mode = "last"
  ) %&gt;%
  select(USUBJID, LSTALVDT)

# derive last alive date and traceability variables
ae_start &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dt(AESTDTC, highest_imputation = "M"),
  set_values_to = exprs(
    LALVDOM = "AE",
    LALVSEQ = AESEQ,
    LALVVAR = "AESTDTC"
  )
)

ae_end &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dt(AEENDTC, highest_imputation = "M"),
  set_values_to = exprs(
    LALVDOM = "AE",
    LALVSEQ = AESEQ,
    LALVVAR = "AEENDTC"
  )
)

lb_date &lt;- date_source(
  dataset_name = "lb",
  date = convert_dtc_to_dt(LBDTC),
  set_values_to = exprs(
    LALVDOM = "LB",
    LALVSEQ = LBSEQ,
    LALVVAR = "LBDTC"
  )
)

adsl_date &lt;- date_source(
  dataset_name = "adsl",
  date = TRTEDT,
  set_values_to = exprs(
    LALVDOM = "ADSL",
    LALVSEQ = NA_integer_,
    LALVVAR = "TRTEDT"
  )
)

dm %&gt;%
  derive_var_extreme_dt(
    new_var = LSTALVDT,
    ae_start, ae_end, lb_date, adsl_date,
    source_datasets = list(
      adsl = adsl,
      ae = ae_ext,
      lb = lb_ext
    ),
    mode = "last"
  ) %&gt;%
  select(USUBJID, LSTALVDT, LALVDOM, LALVSEQ, LALVVAR)
</code></pre>

<hr>
<h2 id='derive_var_extreme_dtm'>Derive First or Last Datetime from Multiple Sources</h2><span id='topic+derive_var_extreme_dtm'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>derive_var_extreme_dtm()</code>
function has been superseded in favor of <code>derive_vars_extreme_event()</code>.
</p>
<p>Add the first or last datetime from multiple sources to the dataset, e.g.,
the last known alive datetime (<code>LSTALVDTM</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_extreme_dtm(
  dataset,
  new_var,
  ...,
  source_datasets,
  mode,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_extreme_dtm_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>subject_keys</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dtm_+3A_new_var">new_var</code></td>
<td>
<p>Name of variable to create</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dtm_+3A_...">...</code></td>
<td>
<p>Source(s) of dates. One or more <code>date_source()</code> objects are
expected.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dtm_+3A_source_datasets">source_datasets</code></td>
<td>
<p>A named <code>list</code> containing datasets in which to search
for the first or last date</p>
</td></tr>
<tr><td><code id="derive_var_extreme_dtm_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, the first date for each subject is selected. If
<code>"last"</code> is specified, the last date for each subject is selected.
</p>
<p>Permitted Values:  <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_var_extreme_dtm_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of expressions where the expressions are symbols as returned by
<code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps are performed to create the output dataset:
</p>

<ol>
<li><p> For each source dataset the observations as specified by the <code>filter</code>
element are selected and observations where <code>date</code> is <code>NA</code> are removed.
Then for each patient the first or last observation (with respect to <code>date</code>
and <code>mode</code>) is selected.
</p>
</li>
<li><p> The new variable is set to the variable or expression specified by the
<code>date</code> element. If this is a date variable (rather than datetime), then the
time is imputed as <code>"00:00:00"</code>.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> element are added.
</p>
</li>
<li><p> The selected observations of all source datasets are combined into a
single dataset.
</p>
</li>
<li><p> For each patient the first or last observation (with respect to the new
variable and <code>mode</code>) from the single dataset is selected and the new
variable is merged to the input dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the new variable added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+date_source">date_source()</a></code>, <code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt()</a></code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
library(lubridate)
dm &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01",    "DM", "01-1130",   84, "YEARS",
  "PILOT01",    "DM", "01-1133",   81, "YEARS",
  "PILOT01",    "DM", "01-1211",   76, "YEARS",
  "PILOT01",    "DM", "09-1081",   86, "YEARS",
  "PILOT01",    "DM", "09-1088",   69, "YEARS"
)
ae &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AESEQ,     ~AESTDTC,     ~AEENDTC,
  "PILOT01",    "AE", "01-1130",      5, "2014-05-09", "2014-05-09",
  "PILOT01",    "AE", "01-1130",      6, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      4, "2014-05-09", "2014-05-09",
  "PILOT01",    "AE", "01-1130",      8, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      7, "2014-05-22",           NA,
  "PILOT01",    "AE", "01-1130",      2, "2014-03-09", "2014-03-09",
  "PILOT01",    "AE", "01-1130",      1, "2014-03-09", "2014-03-16",
  "PILOT01",    "AE", "01-1130",      3, "2014-03-09", "2014-03-16",
  "PILOT01",    "AE", "01-1133",      1, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      3, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      2, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1133",      4, "2012-12-27",           NA,
  "PILOT01",    "AE", "01-1211",      5, "2012-11-29",           NA,
  "PILOT01",    "AE", "01-1211",      1, "2012-11-16",           NA,
  "PILOT01",    "AE", "01-1211",      7, "2013-01-11",           NA,
  "PILOT01",    "AE", "01-1211",      8, "2013-01-11",           NA,
  "PILOT01",    "AE", "01-1211",      4, "2012-11-22",           NA,
  "PILOT01",    "AE", "01-1211",      2, "2012-11-21", "2012-11-21",
  "PILOT01",    "AE", "01-1211",      3, "2012-11-21",           NA,
  "PILOT01",    "AE", "01-1211",      6, "2012-12-09",           NA,
  "PILOT01",    "AE", "01-1211",      9, "2013-01-14", "2013-01-14",
  "PILOT01",    "AE", "09-1081",      2, "2014-05-01",           NA,
  "PILOT01",    "AE", "09-1081",      1, "2014-04-07",           NA,
  "PILOT01",    "AE", "09-1088",      1, "2014-05-08",           NA,
  "PILOT01",    "AE", "09-1088",      2, "2014-08-02",           NA
)
lb &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~LBSEQ,             ~LBDTC,
  "PILOT01",    "LB", "01-1130",    219, "2014-06-07T13:20",
  "PILOT01",    "LB", "01-1130",    322, "2014-08-16T13:10",
  "PILOT01",    "LB", "01-1133",    268, "2013-04-18T15:30",
  "PILOT01",    "LB", "01-1133",    304, "2013-04-29T10:13",
  "PILOT01",    "LB", "01-1211",      8, "2012-10-30T14:26",
  "PILOT01",    "LB", "01-1211",    162, "2013-01-08T12:13",
  "PILOT01",    "LB", "09-1081",     47, "2014-02-01T10:55",
  "PILOT01",    "LB", "09-1081",    219, "2014-05-10T11:15",
  "PILOT01",    "LB", "09-1088",    283, "2014-09-27T12:13",
  "PILOT01",    "LB", "09-1088",    322, "2014-10-09T13:25"
)
adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID,              ~TRTEDTM,
  "PILOT01", "01-1130", "2014-08-16 23:59:59",
  "PILOT01", "01-1133", "2013-04-28 23:59:59",
  "PILOT01", "01-1211", "2013-01-12 23:59:59",
  "PILOT01", "09-1081", "2014-04-27 23:59:59",
  "PILOT01", "09-1088", "2014-10-09 23:59:59"
) %&gt;%
  mutate(
    TRTEDTM = as_datetime(TRTEDTM)
  )

# derive last known alive datetime (LSTALVDTM)
ae_start &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dtm(AESTDTC, highest_imputation = "M"),
)
ae_end &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dtm(AEENDTC, highest_imputation = "M"),
)

ae_ext &lt;- ae %&gt;%
  derive_vars_dtm(
    dtc = AESTDTC,
    new_vars_prefix = "AEST",
    highest_imputation = "M"
  ) %&gt;%
  derive_vars_dtm(
    dtc = AEENDTC,
    new_vars_prefix = "AEEN",
    highest_imputation = "M"
  )

lb_date &lt;- date_source(
  dataset_name = "lb",
  date = convert_dtc_to_dtm(LBDTC),
)

lb_ext &lt;- derive_vars_dtm(
  lb,
  dtc = LBDTC,
  new_vars_prefix = "LB"
)

adsl_date &lt;- date_source(
  dataset_name = "adsl",
  date = TRTEDTM
)

dm %&gt;%
  derive_var_extreme_dtm(
    new_var = LSTALVDTM,
    ae_start, ae_end, lb_date, adsl_date,
    source_datasets = list(
      adsl = adsl,
      ae = ae_ext,
      lb = lb_ext
    ),
    mode = "last"
  ) %&gt;%
  select(USUBJID, LSTALVDTM)

# derive last alive datetime and traceability variables
ae_start &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dtm(AESTDTC, highest_imputation = "M"),
  set_values_to = exprs(
    LALVDOM = "AE",
    LALVSEQ = AESEQ,
    LALVVAR = "AESTDTC"
  )
)

ae_end &lt;- date_source(
  dataset_name = "ae",
  date = convert_dtc_to_dtm(AEENDTC, highest_imputation = "M"),
  set_values_to = exprs(
    LALVDOM = "AE",
    LALVSEQ = AESEQ,
    LALVVAR = "AEENDTC"
  )
)
lb_date &lt;- date_source(
  dataset_name = "lb",
  date = convert_dtc_to_dtm(LBDTC),
  set_values_to = exprs(
    LALVDOM = "LB",
    LALVSEQ = LBSEQ,
    LALVVAR = "LBDTC"
  )
)

adsl_date &lt;- date_source(
  dataset_name = "adsl",
  date = TRTEDTM,
  set_values_to = exprs(
    LALVDOM = "ADSL",
    LALVSEQ = NA_integer_,
    LALVVAR = "TRTEDTM"
  )
)

dm %&gt;%
  derive_var_extreme_dtm(
    new_var = LSTALVDTM,
    ae_start, ae_end, lb_date, adsl_date,
    source_datasets = list(
      adsl = adsl,
      ae = ae_ext,
      lb = lb_ext
    ),
    mode = "last"
  ) %&gt;%
  select(USUBJID, LSTALVDTM, LALVDOM, LALVSEQ, LALVVAR)
</code></pre>

<hr>
<h2 id='derive_var_extreme_flag'>Add a Variable Flagging the First or Last Observation Within Each By Group</h2><span id='topic+derive_var_extreme_flag'></span>

<h3>Description</h3>

<p>Add a variable flagging the first or last observation within each by group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_extreme_flag(
  dataset,
  by_vars,
  order,
  new_var,
  mode,
  true_value = "Y",
  false_value = NA_character_,
  flag_all = FALSE,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_extreme_flag_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>The first or last observation is determined with respect to the specified
order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p>Permitted Values: list of variables or functions of variables</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_new_var">new_var</code></td>
<td>
<p>Variable to add
</p>
<p>The specified variable is added to the output dataset. It is set to the value
set in <code>true_value</code> for the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: list of name-value pairs</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_mode">mode</code></td>
<td>
<p>Flag mode
</p>
<p>Determines of the first or last observation is flagged.
</p>
<p>Permitted Values: <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>The value for the specified variable <code>new_var</code>, applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>The value for the specified variable <code>new_var</code>, NOT applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_flag_all">flag_all</code></td>
<td>
<p>Flag setting
</p>
<p>A logical value where if set to <code>TRUE</code>, all records are flagged
and no error or warning is issued if the first or last record is not unique.</p>
</td></tr>
<tr><td><code id="derive_var_extreme_flag_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p>Default: <code>"warning"</code>
</p>
<p>Permitted Values: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
<code>by_vars</code> parameter), <code>new_var</code> is set to <code>"Y"</code> for the first or last observation
(with respect to the order specified for the <code>order</code> parameter and the flag mode
specified for the <code>mode</code> parameter). In the case where the user wants to flag multiple records
of a grouping, for example records that all happen on the same visit and time, the argument
<code>flag_all</code> can be set to <code>TRUE</code>.
Otherwise, <code>new_var</code> is set to <code>NA</code>. Thus, the direction of &quot;worst&quot; is considered fixed for
all parameters in the dataset depending on the <code>order</code> and the <code>mode</code>, i.e. for every
parameter the first or last record will be flagged across the whole dataset.
</p>


<h3>Value</h3>

<p>The input dataset with the new flag variable added
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
example_vs &lt;- tribble(
  ~USUBJID, ~VSTESTCD,      ~VISIT, ~VISITNUM, ~VSTPTNUM, ~VSSTRESN,
  "1001",     "DIABP", "SCREENING",         1,        10,        64,
  "1001",     "DIABP", "SCREENING",         1,        11,        66,
  "1001",     "DIABP",  "BASELINE",         2,       100,        68,
  "1001",     "DIABP",  "BASELINE",         2,       101,        68,
  "1001",     "DIABP",    "WEEK 2",         3,       200,        72,
  "1001",     "DIABP",    "WEEK 2",         3,       201,        71,
  "1001",     "DIABP",    "WEEK 4",         4,       300,        70,
  "1001",     "DIABP",    "WEEK 4",         4,       301,        70
)

# Flag last value for each patient, test, and visit, baseline observations are ignored
example_vs %&gt;%
  restrict_derivation(
    derivation = derive_var_extreme_flag,
    args = params(
      by_vars = exprs(USUBJID, VSTESTCD, VISIT),
      order = exprs(VSTPTNUM),
      new_var = LASTFL,
      mode = "last"
    ),
    filter = VISIT != "BASELINE"
  ) %&gt;%
  arrange(USUBJID, VSTESTCD, VISITNUM, VSTPTNUM) %&gt;%
  select(USUBJID, VSTESTCD, VISIT, VSTPTNUM, VSSTRESN, LASTFL)

# Baseline (ABLFL) examples:

input &lt;- tribble(
  ~STUDYID, ~USUBJID,  ~PARAMCD,     ~AVISIT,                  ~ADT, ~AVAL,    ~DTYPE,
  "TEST01",  "PAT01", "PARAM01",  "BASELINE", as.Date("2021-04-27"),  15.0,        NA,
  "TEST01",  "PAT01", "PARAM01",  "BASELINE", as.Date("2021-04-25"),  14.0,        NA,
  "TEST01",  "PAT01", "PARAM01",  "BASELINE", as.Date("2021-04-23"),  15.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM01",    "WEEK 1", as.Date("2021-04-27"),  10.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM01",    "WEEK 2", as.Date("2021-04-30"),  12.0,        NA,
  "TEST01",  "PAT02", "PARAM01", "SCREENING", as.Date("2021-04-27"),  15.0, "AVERAGE",
  "TEST01",  "PAT02", "PARAM01",  "BASELINE", as.Date("2021-04-25"),  14.0, "AVERAGE",
  "TEST01",  "PAT02", "PARAM01",  "BASELINE", as.Date("2021-04-23"),  15.0, "AVERAGE",
  "TEST01",  "PAT02", "PARAM01",    "WEEK 1", as.Date("2021-04-27"),  10.0, "AVERAGE",
  "TEST01",  "PAT02", "PARAM01",    "WEEK 2", as.Date("2021-04-30"),  12.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM02", "SCREENING", as.Date("2021-04-27"),  15.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM02", "SCREENING", as.Date("2021-04-25"),  14.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM02", "SCREENING", as.Date("2021-04-23"),  15.0,        NA,
  "TEST01",  "PAT01", "PARAM02",  "BASELINE", as.Date("2021-04-27"),  10.0, "AVERAGE",
  "TEST01",  "PAT01", "PARAM02",    "WEEK 2", as.Date("2021-04-30"),  12.0,        NA,
  "TEST01",  "PAT02", "PARAM02", "SCREENING", as.Date("2021-04-27"),  15.0,        NA,
  "TEST01",  "PAT02", "PARAM02",  "BASELINE", as.Date("2021-04-25"),  14.0,        NA,
  "TEST01",  "PAT02", "PARAM02",    "WEEK 1", as.Date("2021-04-23"),  15.0,        NA,
  "TEST01",  "PAT02", "PARAM02",    "WEEK 1", as.Date("2021-04-27"),  10.0,        NA,
  "TEST01",  "PAT02", "PARAM02",  "BASELINE", as.Date("2021-04-30"),  12.0,        NA
)

# Last observation
restrict_derivation(
  input,
  derivation = derive_var_extreme_flag,
  args = params(
    by_vars = exprs(USUBJID, PARAMCD),
    order = exprs(ADT),
    new_var = ABLFL,
    mode = "last"
  ),
  filter = AVISIT == "BASELINE"
)

# Worst observation - Direction = High
restrict_derivation(
  input,
  derivation = derive_var_extreme_flag,
  args = params(
    by_vars = exprs(USUBJID, PARAMCD),
    order = exprs(AVAL, ADT),
    new_var = ABLFL,
    mode = "last"
  ),
  filter = AVISIT == "BASELINE"
)

# Worst observation - Direction = Lo
restrict_derivation(
  input,
  derivation = derive_var_extreme_flag,
  args = params(
    by_vars = exprs(USUBJID, PARAMCD),
    order = exprs(desc(AVAL), ADT),
    new_var = ABLFL,
    mode = "last"
  ),
  filter = AVISIT == "BASELINE"
)

# Average observation
restrict_derivation(
  input,
  derivation = derive_var_extreme_flag,
  args = params(
    by_vars = exprs(USUBJID, PARAMCD),
    order = exprs(ADT, desc(AVAL)),
    new_var = ABLFL,
    mode = "last"
  ),
  filter = AVISIT == "BASELINE" &amp; DTYPE == "AVERAGE"
)

# OCCURDS Examples
example_ae &lt;- tribble(
  ~USUBJID,         ~AEBODSYS,    ~AEDECOD,   ~AESEV, ~AESTDY, ~AESEQ,
  "1015", "GENERAL DISORDERS",  "ERYTHEMA",   "MILD",       2,      1,
  "1015", "GENERAL DISORDERS",  "PRURITUS",   "MILD",       2,      2,
  "1015",      "GI DISORDERS", "DIARRHOEA",   "MILD",       8,      3,
  "1023", "CARDIAC DISORDERS",  "AV BLOCK",   "MILD",      22,      4,
  "1023",    "SKIN DISORDERS",  "ERYTHEMA",   "MILD",       3,      1,
  "1023",    "SKIN DISORDERS",  "ERYTHEMA", "SEVERE",       5,      2,
  "1023",    "SKIN DISORDERS",  "ERYTHEMA",   "MILD",       8,      3
)

# Most severe AE first occurrence per patient
example_ae %&gt;%
  mutate(
    TEMP_AESEVN =
      as.integer(factor(AESEV, levels = c("SEVERE", "MODERATE", "MILD")))
  ) %&gt;%
  derive_var_extreme_flag(
    new_var = AOCCIFL,
    by_vars = exprs(USUBJID),
    order = exprs(TEMP_AESEVN, AESTDY, AESEQ),
    mode = "first"
  ) %&gt;%
  arrange(USUBJID, AESTDY, AESEQ) %&gt;%
  select(USUBJID, AEDECOD, AESEV, AESTDY, AESEQ, AOCCIFL)

# Most severe AE first occurrence per patient (flag all cases)
example_ae %&gt;%
  mutate(
    TEMP_AESEVN =
      as.integer(factor(AESEV, levels = c("SEVERE", "MODERATE", "MILD")))
  ) %&gt;%
  derive_var_extreme_flag(
    new_var = AOCCIFL,
    by_vars = exprs(USUBJID),
    order = exprs(TEMP_AESEVN, AESTDY),
    mode = "first",
    flag_all = TRUE
  ) %&gt;%
  arrange(USUBJID, AESTDY) %&gt;%
  select(USUBJID, AEDECOD, AESEV, AESTDY, AOCCIFL)

# Most severe AE first occurrence per patient per body system
example_ae %&gt;%
  mutate(
    TEMP_AESEVN =
      as.integer(factor(AESEV, levels = c("SEVERE", "MODERATE", "MILD")))
  ) %&gt;%
  derive_var_extreme_flag(
    new_var = AOCCSIFL,
    by_vars = exprs(USUBJID, AEBODSYS),
    order = exprs(TEMP_AESEVN, AESTDY, AESEQ),
    mode = "first"
  ) %&gt;%
  arrange(USUBJID, AESTDY, AESEQ) %&gt;%
  select(USUBJID, AEBODSYS, AESEV, AESTDY, AOCCSIFL)
</code></pre>

<hr>
<h2 id='derive_var_joined_exist_flag'>Derives a Flag Based on an Existing Flag</h2><span id='topic+derive_var_joined_exist_flag'></span>

<h3>Description</h3>

<p>Derive a flag which depends on other observations of the dataset. For
example, flagging events which need to be confirmed by a second event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_joined_exist_flag(
  dataset,
  dataset_add,
  by_vars,
  order,
  new_var,
  tmp_obs_nr_var = NULL,
  join_vars,
  join_type,
  first_cond = NULL,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  filter = NULL,
  filter_add = NULL,
  filter_join,
  true_value = "Y",
  false_value = NA_character_,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_joined_exist_flag_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>join_vars</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified for <code>by_vars</code>, <code>join_vars</code>, and <code>order</code> are
expected.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The specified variables are used for joining the input
dataset (<code>dataset</code>) with the additional dataset (<code>dataset_add</code>).
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_order">order</code></td>
<td>
<p>Order
</p>
<p>The observations are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_new_var">new_var</code></td>
<td>
<p>New variable
</p>
<p>The specified variable is added to the input dataset.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_tmp_obs_nr_var">tmp_obs_nr_var</code></td>
<td>
<p>Temporary observation number
</p>
<p>The specified variable is added to the input dataset (<code>dataset</code>) and the
additional dataset (<code>dataset_add</code>). It is set to the observation number
with respect to <code>order</code>. For each by group (<code>by_vars</code>) the observation
number starts with <code>1</code>. The variable can be used in the conditions
(<code>filter_join</code>, <code>first_cond_upper</code>, <code>first_cond_lower</code>). It is not included
in the output dataset. It can also be used to flag consecutive observations
or the last observation (see last example below).</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_join_vars">join_vars</code></td>
<td>
<p>Variables to keep from joined dataset
</p>
<p>The variables needed from the other observations should be specified
for this parameter. The specified variables are added to the joined dataset
with suffix &quot;.join&quot;. For example to flag all observations with <code>AVALC == "Y"</code> and <code>AVALC == "Y"</code> for at least one subsequent visit <code>join_vars = exprs(AVALC, AVISITN)</code> and <code>filter_join = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join</code> could be specified.
</p>
<p>The <code style="white-space: pre;">&#8288;*.join&#8288;</code> variables are not included in the output dataset.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_join_type">join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code>
is specified all observations after the original observations are kept.
</p>
<p>For example for confirmed response or BOR in the oncology setting or
confirmed deterioration in questionnaires the confirmatory assessment must
be after the assessment. Thus <code>join_type = "after"</code> could be used.
</p>
<p>Whereas, sometimes you might allow for confirmatory observations to occur
prior to the observation. For example, to identify AEs occurring on or
after seven days before a COVID AE. Thus <code>join_type = "all"</code> could be used.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_first_cond">first_cond</code></td>
<td>
<p>Condition for selecting range of data
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>first_cond_upper</code> instead.
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment. For an example see the third example below.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_first_cond_lower">first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation. For an example see the last example below.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_first_cond_upper">first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment. For an example see the third example below.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_filter">filter</code></td>
<td>
<p>Condition for selecting observations
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>filter_join</code> instead.
</p>
<p>The filter is applied to the joined dataset for flagging the confirmed
observations. The condition can include summary functions. The joined
dataset is grouped by the original observations. I.e., the summary function
are applied to all observations up to the confirmation observation. For
example, <code>filter = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code> selects observations with
response &quot;CR&quot; and for all observations up to the confirmation observation
the response is &quot;CR&quot; or &quot;NE&quot; and there is at most one &quot;NE&quot;.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations from <code>dataset_add</code> fulfilling the specified condition are
joined to the input dataset. If the argument is not specified, all
observations are joined.
</p>
<p>Variables created by <code>order</code> or <code>new_vars</code> arguments can be used in the
condition.
</p>
<p>The condition can include summary functions like <code>all()</code> or <code>any()</code>. The
additional dataset is grouped by the by variables (<code>by_vars</code>).
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_filter_join">filter_join</code></td>
<td>
<p>Condition for selecting observations
</p>
<p>The filter is applied to the joined dataset for flagging the confirmed
observations. The condition can include summary functions like <code>all()</code> or
<code>any()</code>. The joined dataset is grouped by the original observations. I.e.,
the summary function are applied to all observations up to the confirmation
observation. For example, <code>filter_join = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code>
selects observations with response &quot;CR&quot; and for all observations up to the
confirmation observation the response is &quot;CR&quot; or &quot;NE&quot; and there is at most
one &quot;NE&quot;.</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_true_value">true_value</code></td>
<td>
<p>Value of <code>new_var</code> for flagged observations</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_false_value">false_value</code></td>
<td>
<p>Value of <code>new_var</code> for observations not flagged</p>
</td></tr>
<tr><td><code id="derive_var_joined_exist_flag_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An example usage might be flagging if a patient received two required
medications within a certain timeframe of each other.
</p>
<p>In the oncology setting, for example, the function could be used to flag if a
response value can be confirmed by an other assessment. This is commonly
used in endpoints such as best overall response.
</p>
<p>The following steps are performed to produce the output dataset.
</p>


<h4>Step 1</h4>


<ul>
<li><p> The variables specified by <code>order</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The variables specified by <code>join_vars</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted to
those matching the <code>filter_add</code> condition.
</p>
</li></ul>

<p>The input dataset (<code>dataset</code>) is joined with the restricted additional
dataset by the variables specified for <code>by_vars</code>. From the additional
dataset only the variables specified for <code>join_vars</code> are kept. The suffix
&quot;.join&quot; is added to those variables which also exist in the input dataset.
</p>
<p>For example, for <code>by_vars = USUBJID</code>, <code>join_vars = exprs(AVISITN, AVALC)</code>
and input dataset and additional dataset
</p>
<div class="sourceCode r"><pre># A tibble: 2 x 4
USUBJID AVISITN AVALC  AVAL
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
1             1 Y         1
1             2 N         0
</pre></div>
<p>the joined dataset is
</p>
<div class="sourceCode r"><pre>A tibble: 4 x 6
USUBJID AVISITN AVALC  AVAL AVISITN.join AVALC.join
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;
1             1 Y         1            1 Y
1             1 Y         1            2 N
1             2 N         0            1 Y
1             2 N         0            2 N
</pre></div>



<h4>Step 2</h4>

<p>The joined dataset is restricted to observations with respect to
<code>join_type</code> and <code>order</code>.
</p>
<p>The dataset from the example in the previous step with <code>join_type = "after"</code> and <code>order = exprs(AVISITN)</code> is restricted to
</p>
<div class="sourceCode r"><pre>A tibble: 4 x 6
USUBJID AVISITN AVALC  AVAL AVISITN.join AVALC.join
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;
1             1 Y         1            2 N
</pre></div>



<h4>Step 3</h4>

<p>If <code>first_cond_lower</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations from the first
observation where <code>first_cond_lower</code> is fulfilled (the observation
fulfilling the condition is included) up to the observation of the input
dataset. If for an observation of the input dataset the condition is not
fulfilled, the observation is removed.
</p>
<p>If <code>first_cond_upper</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations up to the first
observation where <code>first_cond_upper</code> is fulfilled (the observation
fulfilling the condition is included). If for an observation of the input
dataset the condition is not fulfilled, the observation is removed.
</p>
<p>For an example see the last example in the &quot;Examples&quot; section.
</p>



<h4>Step 4</h4>

<p>The joined dataset is grouped by the observations from the input dataset
and restricted to the observations fulfilling the condition specified by
<code>filter_join</code>.
</p>



<h4>Step 5</h4>

<p>The first observation of each group is selected
</p>



<h4>Step 6</h4>

<p>The variable specified by <code>new_var</code> is added to the input dataset. It is
set to <code>true_value</code> for all observations which were selected in the
previous step. For the other observations it is set to <code>false_value</code>.
</p>



<h3>Value</h3>

<p>The input dataset with the variable specified by <code>new_var</code> added.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filter_joined">filter_joined()</a></code>, <code><a href="#topic+derive_vars_joined">derive_vars_joined()</a></code>
</p>
<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# flag observations with a duration longer than 30 and
# at, after, or up to 7 days before a COVID AE (ACOVFL == "Y")
adae &lt;- tribble(
  ~USUBJID, ~ADY, ~ACOVFL, ~ADURN,
  "1",        10, "N",          1,
  "1",        21, "N",         50,
  "1",        23, "Y",         14,
  "1",        32, "N",         31,
  "1",        42, "N",         20,
  "2",        11, "Y",         13,
  "2",        23, "N",          2,
  "3",        13, "Y",         12,
  "4",        14, "N",         32,
  "4",        21, "N",         41
)

derive_var_joined_exist_flag(
  adae,
  dataset_add = adae,
  new_var = ALCOVFL,
  by_vars = exprs(USUBJID),
  join_vars = exprs(ACOVFL, ADY),
  join_type = "all",
  order = exprs(ADY),
  filter_join = ADURN &gt; 30 &amp; ACOVFL.join == "Y" &amp; ADY &gt;= ADY.join - 7
)

# flag observations with AVALC == "Y" and AVALC == "Y" at one subsequent visit
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "Y",
  "1",      2,        "N",
  "1",      3,        "Y",
  "1",      4,        "N",
  "2",      1,        "Y",
  "2",      2,        "N",
  "3",      1,        "Y",
  "4",      1,        "N",
  "4",      2,        "N",
)

derive_var_joined_exist_flag(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  new_var = CONFFL,
  join_vars = exprs(AVALC, AVISITN),
  join_type = "after",
  order = exprs(AVISITN),
  filter_join = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join
)

# select observations with AVALC == "CR", AVALC == "CR" at a subsequent visit,
# only "CR" or "NE" in between, and at most one "NE" in between
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "NE",
  "1",      4,        "CR",
  "1",      5,        "NE",
  "2",      1,        "CR",
  "2",      2,        "PR",
  "2",      3,        "CR",
  "3",      1,        "CR",
  "4",      1,        "CR",
  "4",      2,        "NE",
  "4",      3,        "NE",
  "4",      4,        "CR",
  "4",      5,        "PR"
)

derive_var_joined_exist_flag(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  join_vars = exprs(AVALC),
  join_type = "after",
  order = exprs(AVISITN),
  new_var = CONFFL,
  first_cond_upper = AVALC.join == "CR",
  filter_join = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp;
    count_vals(var = AVALC.join, val = "NE") &lt;= 1
)

# flag observations with AVALC == "PR", AVALC == "CR" or AVALC == "PR"
# at a subsequent visit at least 20 days later, only "CR", "PR", or "NE"
# in between, at most one "NE" in between, and "CR" is not followed by "PR"
data &lt;- tribble(
  ~USUBJID, ~ADY, ~AVALC,
  "1",         6, "PR",
  "1",        12, "CR",
  "1",        24, "NE",
  "1",        32, "CR",
  "1",        48, "PR",
  "2",         3, "PR",
  "2",        21, "CR",
  "2",        33, "PR",
  "3",        11, "PR",
  "4",         7, "PR",
  "4",        12, "NE",
  "4",        24, "NE",
  "4",        32, "PR",
  "4",        55, "PR"
)

derive_var_joined_exist_flag(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  join_vars = exprs(AVALC, ADY),
  join_type = "after",
  order = exprs(ADY),
  new_var = CONFFL,
  first_cond_upper = AVALC.join %in% c("CR", "PR") &amp; ADY.join - ADY &gt;= 20,
  filter_join = AVALC == "PR" &amp;
    all(AVALC.join %in% c("CR", "PR", "NE")) &amp;
    count_vals(var = AVALC.join, val = "NE") &lt;= 1 &amp;
    (
      min_cond(var = ADY.join, cond = AVALC.join == "CR") &gt;
        max_cond(var = ADY.join, cond = AVALC.join == "PR") |
        count_vals(var = AVALC.join, val = "CR") == 0
    )
)

# flag observations with CRIT1FL == "Y" at two consecutive visits or at the last visit
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~CRIT1FL,
  "1",      1,        "Y",
  "1",      2,        "N",
  "1",      3,        "Y",
  "1",      5,        "N",
  "2",      1,        "Y",
  "2",      3,        "Y",
  "2",      5,        "N",
  "3",      1,        "Y",
  "4",      1,        "Y",
  "4",      2,        "N",
)

derive_var_joined_exist_flag(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  new_var = CONFFL,
  tmp_obs_nr_var = tmp_obs_nr,
  join_vars = exprs(CRIT1FL),
  join_type = "all",
  order = exprs(AVISITN),
  filter_join = CRIT1FL == "Y" &amp; CRIT1FL.join == "Y" &amp;
    (tmp_obs_nr + 1 == tmp_obs_nr.join | tmp_obs_nr == max(tmp_obs_nr.join))
)

# first_cond_lower and first_cond_upper argument
myd &lt;- tribble(
  ~subj, ~day, ~val,
  "1",      1, "++",
  "1",      2, "-",
  "1",      3, "0",
  "1",      4, "+",
  "1",      5, "++",
  "1",      6, "-",
  "2",      1, "-",
  "2",      2, "++",
  "2",      3, "+",
  "2",      4, "0",
  "2",      5, "-",
  "2",      6, "++"
)

# flag "0" where all results from the first "++" before the "0" up to the "0"
# (excluding the "0") are "+" or "++"
derive_var_joined_exist_flag(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  new_var = flag,
  join_vars = exprs(val),
  join_type = "before",
  first_cond_lower = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)

# flag "0" where all results from the "0" (excluding the "0") up to the first
# "++" after the "0" are "+" or "++"
derive_var_joined_exist_flag(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  new_var = flag,
  join_vars = exprs(val),
  join_type = "after",
  first_cond_upper = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)
</code></pre>

<hr>
<h2 id='derive_var_merged_ef_msrc'>Merge an Existence Flag From Multiple Sources</h2><span id='topic+derive_var_merged_ef_msrc'></span>

<h3>Description</h3>

<p>Adds a flag variable to the input dataset which indicates if
there exists at least one observation in one of the source datasets
fulfilling a certain condition. For example, if a dose adjustment flag
should be added to <code>ADEX</code> but the dose adjustment information is collected
in different datasets, e.g., <code>EX</code>, <code>EC</code>, and <code>FA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_merged_ef_msrc(
  dataset,
  by_vars,
  flag_events,
  source_datasets,
  new_var,
  true_value = "Y",
  false_value = NA_character_,
  missing_value = NA_character_
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_flag_events">flag_events</code></td>
<td>
<p>Flag events
</p>
<p>A list of <code>flag_event()</code> objects is expected. For each event the condition
(<code>condition</code> field) is evaluated in the source dataset referenced by the
<code>dataset_name</code> field. If it evaluates to <code>TRUE</code> at least once, the new
variable is set to <code>true_value</code>.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_source_datasets">source_datasets</code></td>
<td>
<p>Source datasets
</p>
<p>A named list of datasets is expected. The <code>dataset_name</code> field of
<code>flag_event()</code> refers to the dataset provided in the list.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_new_var">new_var</code></td>
<td>
<p>New variable
</p>
<p>The specified variable is added to the input dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>The new variable (<code>new_var</code>) is set to the specified value for all by
groups for which at least one of the source object (<code>sources</code>) has the
condition evaluate to <code>TRUE</code>.
</p>
<p>The values of <code>true_value</code>, <code>false_value</code>, and <code>missing_value</code> must be of
the same type.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>The new variable (<code>new_var</code>) is set to the specified value for all by
groups which occur in at least one source (<code>sources</code>) but the condition
never evaluates to <code>TRUE</code>.
</p>
<p>The values of <code>true_value</code>, <code>false_value</code>, and <code>missing_value</code> must be of
the same type.</p>
</td></tr>
<tr><td><code id="derive_var_merged_ef_msrc_+3A_missing_value">missing_value</code></td>
<td>
<p>Values used for missing information
</p>
<p>The new variable is set to the specified value for all by groups without
observations in any of the sources (<code>sources</code>).
</p>
<p>The values of <code>true_value</code>, <code>false_value</code>, and <code>missing_value</code> must be of
the same type.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> For each <code>flag_event()</code> object specified for <code>flag_events</code>: The
condition (<code>condition</code>) is evaluated in the dataset referenced by
<code>dataset_name</code>. If the <code>by_vars</code> field is specified the dataset is grouped
by the specified variables for evaluating the condition. If named elements
are used in <code>by_vars</code> like <code>by_vars = exprs(USUBJID, EXLNKID = ECLNKID)</code>,
the variables are renamed after the evaluation. If the <code>by_vars</code> element is
not specified, the observations are grouped by the variables specified for
the <code>by_vars</code> argument.
</p>
</li>
<li><p> The new variable (<code>new_var</code>) is added to the input dataset and set to
the true value (<code>true_value</code>) if for the by group at least one condition
evaluates to <code>TRUE</code> in one of the sources. It is set to the false value
(<code>false_value</code>) if for the by group at least one observation exists and for
all observations the condition evaluates to <code>FALSE</code> or <code>NA</code>. Otherwise, it
is set to the missing value (<code>missing_value</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset and additionally the variable specified for <code>new_var</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+flag_event">flag_event()</a></code>
</p>
<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Derive a flag indicating anti-cancer treatment based on CM and PR
adsl &lt;- tribble(
  ~USUBJID,
  "1",
  "2",
  "3",
  "4"
)

cm &lt;- tribble(
  ~USUBJID, ~CMCAT,        ~CMSEQ,
  "1",      "ANTI-CANCER",      1,
  "1",      "GENERAL",          2,
  "2",      "GENERAL",          1,
  "3",      "ANTI-CANCER",      1
)

# Assuming all records in PR indicate cancer treatment
pr &lt;- tibble::tribble(
  ~USUBJID, ~PRSEQ,
  "2",      1,
  "3",      1
)

derive_var_merged_ef_msrc(
  adsl,
  by_vars = exprs(USUBJID),
  flag_events = list(
    flag_event(
      dataset_name = "cm",
      condition = CMCAT == "ANTI-CANCER"
    ),
    flag_event(
      dataset_name = "pr"
    )
  ),
  source_datasets = list(cm = cm, pr = pr),
  new_var = CANCTRFL
)

# Using different by variables depending on the source
# Add a dose adjustment flag to ADEX based on ADEX, EC, and FA
adex &lt;- tribble(
  ~USUBJID, ~EXLNKID, ~EXADJ,
  "1",      "1",      "AE",
  "1",      "2",      NA_character_,
  "1",      "3",      NA_character_,
  "2",      "1",      NA_character_,
  "3",      "1",      NA_character_
)

ec &lt;- tribble(
  ~USUBJID, ~ECLNKID, ~ECADJ,
  "1",      "3",      "AE",
  "3",      "1",      NA_character_
)

fa &lt;- tribble(
  ~USUBJID, ~FALNKID, ~FATESTCD, ~FAOBJ,            ~FASTRESC,
  "3",      "1",      "OCCUR",   "DOSE ADJUSTMENT", "Y"
)

derive_var_merged_ef_msrc(
  adex,
  by_vars = exprs(USUBJID, EXLNKID),
  flag_events = list(
    flag_event(
      dataset_name = "ex",
      condition = !is.na(EXADJ)
    ),
    flag_event(
      dataset_name = "ec",
      condition = !is.na(ECADJ),
      by_vars = exprs(USUBJID, EXLNKID = ECLNKID)
    ),
    flag_event(
      dataset_name = "fa",
      condition = FATESTCD == "OCCUR" &amp; FAOBJ == "DOSE ADJUSTMENT" &amp; FASTRESC == "Y",
      by_vars = exprs(USUBJID, EXLNKID = FALNKID)
    )
  ),
  source_datasets = list(ex = adex, ec = ec, fa = fa),
  new_var = DOSADJFL
)
</code></pre>

<hr>
<h2 id='derive_var_merged_exist_flag'>Merge an Existence Flag</h2><span id='topic+derive_var_merged_exist_flag'></span>

<h3>Description</h3>

<p>Adds a flag variable to the input dataset which indicates if
there exists at least one observation in another dataset fulfilling a certain
condition.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_vars_merged()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_merged_exist_flag(
  dataset,
  dataset_add,
  by_vars,
  new_var,
  condition,
  true_value = "Y",
  false_value = NA_character_,
  missing_value = NA_character_,
  filter_add = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_merged_exist_flag_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected.</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_new_var">new_var</code></td>
<td>
<p>New variable
</p>
<p>The specified variable is added to the input dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_condition">condition</code></td>
<td>
<p>Condition
</p>
<p>The condition is evaluated at the additional dataset (<code>dataset_add</code>). For
all by groups where it evaluates as <code>TRUE</code> at least once the new variable
is set to the true value (<code>true_value</code>). For all by groups where it
evaluates as <code>FALSE</code> or <code>NA</code> for all observations the new variable is set
to the false value (<code>false_value</code>). The new variable is set to the missing
value (<code>missing_value</code>) for by groups not present in the additional
dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_true_value">true_value</code></td>
<td>
<p>True value</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_false_value">false_value</code></td>
<td>
<p>False value</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_missing_value">missing_value</code></td>
<td>
<p>Values used for missing information
</p>
<p>The new variable is set to the specified value for all by groups without
observations in the additional dataset.
</p>
<p><em>Permitted Value</em>: A character scalar</p>
</td></tr>
<tr><td><code id="derive_var_merged_exist_flag_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional data
</p>
<p>Only observations fulfilling the specified condition are taken into account
for flagging. If the argument is not specified, all observations are
considered.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The additional dataset is restricted to the observations matching the
<code>filter_add</code> condition.
</p>
</li>
<li><p> The new variable is added to the input dataset and set to the true value
(<code>true_value</code>) if for the by group at least one observation exists in the
(restricted) additional dataset where the condition evaluates to <code>TRUE</code>. It
is set to the false value (<code>false_value</code>) if for the by group at least one
observation exists and for all observations the condition evaluates to
<code>FALSE</code> or <code>NA</code>. Otherwise, it is set to the missing value
(<code>missing_value</code>).
</p>
</li></ol>



<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset and additionally the variable specified for <code>new_var</code> derived
from the additional dataset (<code>dataset_add</code>).
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr, warn.conflicts = FALSE)

dm &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01",    "DM", "01-1028",   71, "YEARS",
  "PILOT01",    "DM", "04-1127",   84, "YEARS",
  "PILOT01",    "DM", "06-1049",   60, "YEARS"
)

ae &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,    ~AETERM,     ~AEREL,
  "PILOT01",    "AE", "01-1028", "ERYTHEMA", "POSSIBLE",
  "PILOT01",    "AE", "01-1028", "PRURITUS", "PROBABLE",
  "PILOT01",    "AE", "06-1049",  "SYNCOPE", "POSSIBLE",
  "PILOT01",    "AE", "06-1049",  "SYNCOPE", "PROBABLE"
)


derive_var_merged_exist_flag(
  dm,
  dataset_add = ae,
  by_vars = exprs(STUDYID, USUBJID),
  new_var = AERELFL,
  condition = AEREL == "PROBABLE"
) %&gt;%
  select(STUDYID, USUBJID, AGE, AGEU, AERELFL)

vs &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,      ~VISIT, ~VSTESTCD, ~VSSTRESN, ~VSBLFL,
  "PILOT01",    "VS", "01-1028", "SCREENING",  "HEIGHT",     177.8,      NA,
  "PILOT01",    "VS", "01-1028", "SCREENING",  "WEIGHT",     98.88,      NA,
  "PILOT01",    "VS", "01-1028",  "BASELINE",  "WEIGHT",     99.34,     "Y",
  "PILOT01",    "VS", "01-1028",    "WEEK 4",  "WEIGHT",     98.88,      NA,
  "PILOT01",    "VS", "04-1127", "SCREENING",  "HEIGHT",     165.1,      NA,
  "PILOT01",    "VS", "04-1127", "SCREENING",  "WEIGHT",     42.87,      NA,
  "PILOT01",    "VS", "04-1127",  "BASELINE",  "WEIGHT",     41.05,     "Y",
  "PILOT01",    "VS", "04-1127",    "WEEK 4",  "WEIGHT",     41.73,      NA,
  "PILOT01",    "VS", "06-1049", "SCREENING",  "HEIGHT",    167.64,      NA,
  "PILOT01",    "VS", "06-1049", "SCREENING",  "WEIGHT",     57.61,      NA,
  "PILOT01",    "VS", "06-1049",  "BASELINE",  "WEIGHT",     57.83,     "Y",
  "PILOT01",    "VS", "06-1049",    "WEEK 4",  "WEIGHT",     58.97,      NA
)
derive_var_merged_exist_flag(
  dm,
  dataset_add = vs,
  by_vars = exprs(STUDYID, USUBJID),
  filter_add = VSTESTCD == "WEIGHT" &amp; VSBLFL == "Y",
  new_var = WTBLHIFL,
  condition = VSSTRESN &gt; 90,
  false_value = "N",
  missing_value = "M"
) %&gt;%
  select(STUDYID, USUBJID, AGE, AGEU, WTBLHIFL)
</code></pre>

<hr>
<h2 id='derive_var_merged_summary'>Merge Summary Variables</h2><span id='topic+derive_var_merged_summary'></span>

<h3>Description</h3>

<p>Merge a summary variable from a dataset to the input dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_merged_summary(
  dataset,
  dataset_add,
  by_vars,
  new_vars = NULL,
  new_var,
  filter_add = NULL,
  missing_values = NULL,
  analysis_var,
  summary_fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_merged_summary_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code> and the variables used on the left
hand sides of the <code>new_vars</code> arguments are expected.</p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The expressions on the left hand sides of <code>new_vars</code> are evaluated by the
specified <em>variables</em>. Then the resulting values are merged to the input
dataset (<code>dataset</code>) by the specified <em>variables</em>.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_new_vars">new_vars</code></td>
<td>
<p>New variables to add
</p>
<p>The specified variables are added to the input dataset.
</p>
<p>A named list of expressions is expected:
</p>

<ul>
<li><p> LHS refer to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, an expression or NA. If summary functions are
used, the values are summarized by the variables specified for <code>by_vars</code>.
</p>
</li></ul>

<p>For example:
</p>
<div class="sourceCode"><pre>  new_vars = exprs(
    DOSESUM = sum(AVAL),
    DOSEMEAN = mean(AVAL)
  )
</pre></div></td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_new_var">new_var</code></td>
<td>
<p>Variable to add
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>new_vars</code> instead.
</p>
<p>The specified variable is added to the input dataset (<code>dataset</code>) and set to
the summarized values.</p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations fulfilling the specified condition are taken into account
for summarizing. If the argument is not specified, all observations are
considered.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_missing_values">missing_values</code></td>
<td>
<p>Values for non-matching observations
</p>
<p>For observations of the input dataset (<code>dataset</code>) which do not have a
matching observation in the additional dataset (<code>dataset_add</code>) the values
of the specified variables are set to the specified value. Only variables
specified for <code>new_vars</code> can be specified for <code>missing_values</code>.
</p>
<p><em>Permitted Values</em>: named list of expressions, e.g.,
<code>exprs(BASEC = "MISSING", BASE = -1)</code></p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>new_vars</code> instead.
</p>
<p>The values of the specified variable are summarized by the function
specified for <code>summary_fun</code>.</p>
</td></tr>
<tr><td><code id="derive_var_merged_summary_+3A_summary_fun">summary_fun</code></td>
<td>
<p>Summary function
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>new_vars</code> instead.
</p>
<p>The specified function that takes as input <code>analysis_var</code> and performs the
calculation. This can include built-in functions as well as user defined
functions, for example <code>mean</code> or <code>function(x) mean(x, na.rm = TRUE)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted
to those matching the <code>filter_add</code> condition.
</p>
</li>
<li><p> The new variables (<code>new_vars</code>) are created for each by group (<code>by_vars</code>)
in the additional dataset (<code>dataset_add</code>) by calling <code>summarize()</code>. I.e.,
all observations of a by group are summarized to a single observation.
</p>
</li>
<li><p> The new variables are merged to the input dataset. For observations
without a matching observation in the additional dataset the new variables
are set to <code>NA</code>. Observations in the additional dataset which have no
matching observation in the input dataset are ignored.
</p>
</li></ol>



<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset and additionally the variables specified for <code>new_vars</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_summary_records">derive_summary_records()</a></code>, <code><a href="#topic+get_summary_records">get_summary_records()</a></code>
</p>
<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

# Add a variable for the mean of AVAL within each visit
adbds &lt;- tribble(
  ~USUBJID,  ~AVISIT,  ~ASEQ, ~AVAL,
  "1",      "WEEK 1",      1,    10,
  "1",      "WEEK 1",      2,    NA,
  "1",      "WEEK 2",      3,    NA,
  "1",      "WEEK 3",      4,    42,
  "1",      "WEEK 4",      5,    12,
  "1",      "WEEK 4",      6,    12,
  "1",      "WEEK 4",      7,    15,
  "2",      "WEEK 1",      1,    21,
  "2",      "WEEK 4",      2,    22
)

derive_var_merged_summary(
  adbds,
  dataset_add = adbds,
  by_vars = exprs(USUBJID, AVISIT),
  new_vars = exprs(
    MEANVIS = mean(AVAL, na.rm = TRUE),
    MAXVIS = max(AVAL, na.rm = TRUE)
  )
)

# Add a variable listing the lesion ids at baseline
adsl &lt;- tribble(
  ~USUBJID,
  "1",
  "2",
  "3"
)

adtr &lt;- tribble(
  ~USUBJID,     ~AVISIT, ~LESIONID,
  "1",       "BASELINE",  "INV-T1",
  "1",       "BASELINE",  "INV-T2",
  "1",       "BASELINE",  "INV-T3",
  "1",       "BASELINE",  "INV-T4",
  "1",         "WEEK 1",  "INV-T1",
  "1",         "WEEK 1",  "INV-T2",
  "1",         "WEEK 1",  "INV-T4",
  "2",       "BASELINE",  "INV-T1",
  "2",       "BASELINE",  "INV-T2",
  "2",       "BASELINE",  "INV-T3",
  "2",         "WEEK 1",  "INV-T1",
  "2",         "WEEK 1",  "INV-N1"
)

derive_var_merged_summary(
  adsl,
  dataset_add = adtr,
  by_vars = exprs(USUBJID),
  filter_add = AVISIT == "BASELINE",
  new_vars = exprs(LESIONSBL = paste(LESIONID, collapse = ", "))
)

</code></pre>

<hr>
<h2 id='derive_var_obs_number'>Adds a Variable Numbering the Observations Within Each By Group</h2><span id='topic+derive_var_obs_number'></span>

<h3>Description</h3>

<p>Adds a variable numbering the observations within each by group
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_obs_number(
  dataset,
  by_vars = NULL,
  order = NULL,
  new_var = ASEQ,
  check_type = "none"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_obs_number_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_obs_number_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_obs_number_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Within each by group the observations are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p>Permitted Values: list of variables or functions of variables</p>
</td></tr>
<tr><td><code id="derive_var_obs_number_+3A_new_var">new_var</code></td>
<td>
<p>Name of variable to create
</p>
<p>The new variable is set to the observation number for each by group. The
numbering starts with 1.
</p>
<p>Default: <code>ASEQ</code></p>
</td></tr>
<tr><td><code id="derive_var_obs_number_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p>Default: <code>"none"</code>
</p>
<p>Permitted Values: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
<code>by_vars</code> parameter) the first or last observation (with respect to the
order specified for the <code>order</code> parameter and the mode specified for the
<code>mode</code> parameter) is included in the output dataset.
</p>


<h3>Value</h3>

<p>A dataset containing all observations and variables of the input
dataset and additionally the variable specified by the <code>new_var</code> parameter.
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
vs &lt;- tribble(
  ~STUDYID,  ~DOMAIN,      ~USUBJID, ~VSTESTCD, ~VISITNUM, ~VSTPTNUM,
  "PILOT01",    "VS", "01-703-1182",   "DIABP",         3,       815,
  "PILOT01",    "VS", "01-703-1182",   "DIABP",         3,       816,
  "PILOT01",    "VS", "01-703-1182",   "DIABP",         4,       815,
  "PILOT01",    "VS", "01-703-1182",   "DIABP",         4,       816,
  "PILOT01",    "VS", "01-703-1182",   "PULSE",         3,       815,
  "PILOT01",    "VS", "01-703-1182",   "PULSE",         3,       816,
  "PILOT01",    "VS", "01-703-1182",   "PULSE",         4,       815,
  "PILOT01",    "VS", "01-703-1182",   "PULSE",         4,       816,
  "PILOT01",    "VS", "01-703-1182",   "SYSBP",         3,       815,
  "PILOT01",    "VS", "01-703-1182",   "SYSBP",         3,       816,
  "PILOT01",    "VS", "01-703-1182",   "SYSBP",         4,       815,
  "PILOT01",    "VS", "01-703-1182",   "SYSBP",         4,       816,
  "PILOT01",    "VS", "01-716-1229",   "DIABP",         3,       815,
  "PILOT01",    "VS", "01-716-1229",   "DIABP",         3,       816,
  "PILOT01",    "VS", "01-716-1229",   "DIABP",         4,       815,
  "PILOT01",    "VS", "01-716-1229",   "DIABP",         4,       816,
  "PILOT01",    "VS", "01-716-1229",   "PULSE",         3,       815,
  "PILOT01",    "VS", "01-716-1229",   "PULSE",         3,       816,
  "PILOT01",    "VS", "01-716-1229",   "PULSE",         4,       815,
  "PILOT01",    "VS", "01-716-1229",   "PULSE",         4,       816,
  "PILOT01",    "VS", "01-716-1229",   "SYSBP",         3,       815,
  "PILOT01",    "VS", "01-716-1229",   "SYSBP",         3,       816,
  "PILOT01",    "VS", "01-716-1229",   "SYSBP",         4,       815,
  "PILOT01",    "VS", "01-716-1229",   "SYSBP",         4,       816
)
vs %&gt;%
  derive_var_obs_number(
    by_vars = exprs(USUBJID, VSTESTCD),
    order = exprs(VISITNUM, desc(VSTPTNUM))
  )
</code></pre>

<hr>
<h2 id='derive_var_ontrtfl'>Derive On-Treatment Flag Variable</h2><span id='topic+derive_var_ontrtfl'></span>

<h3>Description</h3>

<p>Derive on-treatment flag (<code>ONTRTFL</code>) in an ADaM dataset with a single
assessment date (e.g <code>ADT</code>) or event start and end dates (e.g.
<code>ASTDT</code>/<code>AENDT</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_ontrtfl(
  dataset,
  new_var = ONTRTFL,
  start_date,
  end_date = NULL,
  ref_start_date,
  ref_end_date = NULL,
  ref_end_window = 0,
  ignore_time_for_ref_end_date = TRUE,
  filter_pre_timepoint = NULL,
  span_period = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_ontrtfl_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>Required columns are <code>start_date</code>, <code>end_date</code>, <code>ref_start_date</code> and
<code>ref_end_date</code>.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_new_var">new_var</code></td>
<td>
<p>On-treatment flag variable name to be created.
</p>
<p>Default is <code>ONTRTFL</code>.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_start_date">start_date</code></td>
<td>
<p>The start date (e.g. <code>AESDT</code>) or assessment date (e.g.
<code>ADT</code>) Required; A date or date-time object column is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_end_date">end_date</code></td>
<td>
<p>The end date of assessment/event (e.g. <code>AENDT</code>) A date or
date-time object column is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Optional; Default is null. If the used and date value is missing on an
observation, it is assumed the medication is ongoing and <code>ONTRTFL</code> is set
to <code>"Y"</code>.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_ref_start_date">ref_start_date</code></td>
<td>
<p>The lower bound of the on-treatment period Required; A
date or date-time object column is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_ref_end_date">ref_end_date</code></td>
<td>
<p>The upper bound of the on-treatment period A date or
date-time object column is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Optional; This can be null and everything after <code>ref_start_date</code> will be
considered on-treatment. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_ref_end_window">ref_end_window</code></td>
<td>
<p>A window to add to the upper bound <code>ref_end_date</code>
measured in days (e.g. 7 if 7 days should be added to the upper bound)
Optional; default is 0.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_ignore_time_for_ref_end_date">ignore_time_for_ref_end_date</code></td>
<td>
<p>If the argument is set to <code>TRUE</code>, the time part is ignored for checking if
the event occurred more than <code>ref_end_window</code> days after reference end
date.
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_filter_pre_timepoint">filter_pre_timepoint</code></td>
<td>
<p>An expression to filter observations as not
on-treatment when <code>date</code> = <code>ref_start_date</code>. For example, if observations
where <code>VSTPT = PRE</code> should not be considered on-treatment when <code>date = ref_start_date</code>, <code>filter_pre_timepoint</code> should be used to denote when the
on-treatment flag should be set to null. Optional; default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="derive_var_ontrtfl_+3A_span_period">span_period</code></td>
<td>
<p>A logical scalar. If <code>TRUE</code>, events that started
prior to the <code>ref_start_date</code>and are ongoing or end after the
<code>ref_start_date</code> are flagged as <code>"Y"</code>. Optional; default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On-Treatment is calculated by determining whether the assessment
date or start/stop dates fall between 2 dates. The following logic is used
to assign on-treatment = <code>"Y"</code>:
</p>

<ol>
<li> <p><code>start_date</code> is missing and <code>ref_start_date</code>is non-missing
</p>
</li>
<li><p> No timepoint filter is provided (<code>filter_pre_timepoint</code>) and both
<code>start_date</code> and <code>ref_start_date</code> are non-missing and <code>start_date</code> =
<code>ref_start_date</code>
</p>
</li>
<li><p> A timepoint is provided (<code>filter_pre_timepoint</code>) and both <code>start_date</code>
and <code>ref_start_date</code> are non-missing and <code>start_date = ref_start_date</code> and
the filter provided in <code>filter_pre_timepoint</code> is not true.
</p>
</li>
<li> <p><code>ref_end_date</code> is not provided and <code>ref_start_date &lt; start_date</code>
</p>
</li>
<li> <p><code>ref_end_date</code> is provided and <code>ref_start_date &lt; start_date</code> &lt;=
<code>ref_end_date + ref_end_window</code>.
</p>
</li></ol>

<p>If the <code>end_date</code> is provided and the <code>end_date</code> &lt; ref_start_date then the
<code>ONTRTFL</code> is set to <code>NULL</code>.This would be applicable to cases where the
<code>start_date</code> is missing and <code>ONTRTFL</code> has been assigned as <code>"Y"</code> above.
</p>
<p>If the <code>span_period</code> is <code>TRUE</code>, this allows the user to assign
<code>ONTRTFL</code> as <code>"Y"</code> to cases where the record started prior to the
<code>ref_start_date</code> and was ongoing or ended after the <code>ref_start_date</code>.
</p>
<p>Any date imputations needed should be done prior to calling this function.
</p>


<h3>Value</h3>

<p>The input dataset with an additional column named <code>ONTRTFL</code> with a
value of <code>"Y"</code> or <code>NA</code>
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate, warn.conflicts = FALSE)

advs &lt;- tribble(
  ~USUBJID, ~ADT,              ~TRTSDT,           ~TRTEDT,
  "P01",    ymd("2020-02-24"), ymd("2020-01-01"), ymd("2020-03-01"),
  "P02",    ymd("2020-01-01"), ymd("2020-01-01"), ymd("2020-03-01"),
  "P03",    ymd("2019-12-31"), ymd("2020-01-01"), ymd("2020-03-01")
)
derive_var_ontrtfl(
  advs,
  start_date = ADT,
  ref_start_date = TRTSDT,
  ref_end_date = TRTEDT
)

advs &lt;- tribble(
  ~USUBJID, ~ADT,              ~TRTSDT,           ~TRTEDT,
  "P01",    ymd("2020-07-01"), ymd("2020-01-01"), ymd("2020-03-01"),
  "P02",    ymd("2020-04-30"), ymd("2020-01-01"), ymd("2020-03-01"),
  "P03",    ymd("2020-03-15"), ymd("2020-01-01"), ymd("2020-03-01")
)
derive_var_ontrtfl(
  advs,
  start_date = ADT,
  ref_start_date = TRTSDT,
  ref_end_date = TRTEDT,
  ref_end_window = 60
)

advs &lt;- tribble(
  ~USUBJID, ~ADTM,                      ~TRTSDTM,                   ~TRTEDTM,
  "P01",    ymd_hm("2020-01-02T12:00"), ymd_hm("2020-01-01T12:00"), ymd_hm("2020-03-01T12:00"),
  "P02",    ymd("2020-01-01"),          ymd_hm("2020-01-01T12:00"), ymd_hm("2020-03-01T12:00"),
  "P03",    ymd("2019-12-31"),          ymd_hm("2020-01-01T12:00"), ymd_hm("2020-03-01T12:00"),
) %&gt;%
  mutate(TPT = c(NA, "PRE", NA))
derive_var_ontrtfl(
  advs,
  start_date = ADTM,
  ref_start_date = TRTSDTM,
  ref_end_date = TRTEDTM,
  filter_pre_timepoint = TPT == "PRE"
)

advs &lt;- tribble(
  ~USUBJID, ~ASTDT,            ~TRTSDT,           ~TRTEDT,           ~AENDT,
  "P01",    ymd("2020-03-15"), ymd("2020-01-01"), ymd("2020-03-01"), ymd("2020-12-01"),
  "P02",    ymd("2019-04-30"), ymd("2020-01-01"), ymd("2020-03-01"), ymd("2020-03-15"),
  "P03",    ymd("2019-04-30"), ymd("2020-01-01"), ymd("2020-03-01"), NA,
)
derive_var_ontrtfl(
  advs,
  start_date = ASTDT,
  end_date = AENDT,
  ref_start_date = TRTSDT,
  ref_end_date = TRTEDT,
  ref_end_window = 60,
  span_period = TRUE
)

advs &lt;- tribble(
  ~USUBJID, ~ASTDT,            ~AP01SDT,          ~AP01EDT,          ~AENDT,
  "P01",    ymd("2020-03-15"), ymd("2020-01-01"), ymd("2020-03-01"), ymd("2020-12-01"),
  "P02",    ymd("2019-04-30"), ymd("2020-01-01"), ymd("2020-03-01"), ymd("2020-03-15"),
  "P03",    ymd("2019-04-30"), ymd("2020-01-01"), ymd("2020-03-01"), NA,
)
derive_var_ontrtfl(
  advs,
  new_var = ONTR01FL,
  start_date = ASTDT,
  end_date = AENDT,
  ref_start_date = AP01SDT,
  ref_end_date = AP01EDT,
  span_period = TRUE
)
</code></pre>

<hr>
<h2 id='derive_var_pchg'>Derive Percent Change from Baseline</h2><span id='topic+derive_var_pchg'></span>

<h3>Description</h3>

<p>Derive percent change from baseline (<code>PCHG</code>) in a BDS dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_pchg(dataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_pchg_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
<code>AVAL</code> and <code>BASE</code> are expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Percent change from baseline is calculated by dividing change from
baseline by the absolute value of the baseline value and
multiplying the result by <code>100</code>.
</p>


<h3>Value</h3>

<p>The input dataset with an additional column named <code>PCHG</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_var_chg">derive_var_chg()</a></code>
</p>
<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_shift">derive_var_shift</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

advs &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~ABLFL, ~BASE,
  "P01",    "WEIGHT", 80,    "Y",    80,
  "P01",    "WEIGHT", 80.8,  "",     80,
  "P01",    "WEIGHT", 81.4,  "",     80,
  "P02",    "WEIGHT", 75.3,  "Y",    75.3,
  "P02",    "WEIGHT", 76,    "",     75.3
)
derive_var_pchg(advs)
</code></pre>

<hr>
<h2 id='derive_var_relative_flag'>Flag Observations Before or After a Condition is Fulfilled</h2><span id='topic+derive_var_relative_flag'></span>

<h3>Description</h3>

<p>Flag all observations before or after the observation where a specified
condition is fulfilled for each by group. For example, the function could be
called to flag for each subject all observations before the first disease
progression or to flag all AEs after a specific AE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_relative_flag(
  dataset,
  by_vars,
  order,
  new_var,
  condition,
  mode,
  selection,
  inclusive,
  flag_no_ref_groups = TRUE,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_relative_flag_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Within each by group the observations are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_new_var">new_var</code></td>
<td>
<p>New variable
</p>
<p>The variable is added to the input dataset and set to <code>"Y"</code> for all
observations before or after the condition is fulfilled. For all other
observations it is set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_condition">condition</code></td>
<td>
<p>Condition for Reference Observation
</p>
<p>The specified condition determines the reference observation. In the output
dataset all observations before or after (<code>selection</code> argument)
the reference observation are flagged.</p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, for each by group the observations before or
after (<code>selection</code> argument) the observation where the condition
(<code>condition</code> argument) is fulfilled the <em>first</em> time is flagged in the
output dataset. If <code>"last"</code> is specified, for each by group the
observations before or after (<code>selection</code> argument) the observation where
the condition (<code>condition</code> argument) is fulfilled the <em>last</em> time is
flagged in the output dataset.
</p>
<p><em>Permitted Values:</em> <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_selection">selection</code></td>
<td>
<p>Flag observations before or after the reference observation?
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_inclusive">inclusive</code></td>
<td>
<p>Flag the reference observation?
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_flag_no_ref_groups">flag_no_ref_groups</code></td>
<td>
<p>Should by groups without reference observation be flagged?
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_var_relative_flag_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each by group (<code>by_vars</code> argument) the observations before or
after (<code>selection</code> argument) the observations where the condition
(<code>condition</code> argument) is fulfilled the first or last time (<code>order</code>
argument and <code>mode</code> argument) is flagged in the output dataset.
</p>


<h3>Value</h3>

<p>The input dataset with the new variable (<code>new_var</code>) added
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)

# Flag all AEs after the first COVID AE
adae &lt;- tribble(
  ~USUBJID, ~ASTDY, ~ACOVFL, ~AESEQ,
  "1",           2, NA,           1,
  "1",           5, "Y",          2,
  "1",           5, NA,           3,
  "1",          17, NA,           4,
  "1",          27, "Y",          5,
  "1",          32, NA,           6,
  "2",           8, NA,           1,
  "2",          11, NA,           2,
)

derive_var_relative_flag(
  adae,
  by_vars = exprs(USUBJID),
  order = exprs(ASTDY, AESEQ),
  new_var = PSTCOVFL,
  condition = ACOVFL == "Y",
  mode = "first",
  selection = "after",
  inclusive = FALSE,
  flag_no_ref_groups = FALSE
)

response &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      0,        "PR",
  "1",      1,        "CR",
  "1",      2,        "CR",
  "1",      3,        "SD",
  "1",      4,        "NE",
  "2",      0,        "SD",
  "2",      1,        "PD",
  "2",      2,        "PD",
  "3",      0,        "SD",
  "4",      0,        "SD",
  "4",      1,        "PR",
  "4",      2,        "PD",
  "4",      3,        "SD",
  "4",      4,        "PR"
)

# Flag observations up to first PD for each patient
response %&gt;%
  derive_var_relative_flag(
    by_vars = exprs(USUBJID),
    order = exprs(AVISITN),
    new_var = ANL02FL,
    condition = AVALC == "PD",
    mode = "first",
    selection = "before",
    inclusive = TRUE
  )

# Flag observations up to first PD excluding baseline (AVISITN = 0) for each patient
response %&gt;%
  restrict_derivation(
    derivation = derive_var_relative_flag,
    args = params(
      by_vars = exprs(USUBJID),
      order = exprs(AVISITN),
      new_var = ANL02FL,
      condition = AVALC == "PD",
      mode = "first",
      selection = "before",
      inclusive = TRUE
    ),
    filter = AVISITN &gt; 0
  ) %&gt;%
  arrange(USUBJID, AVISITN)
</code></pre>

<hr>
<h2 id='derive_var_shift'>Derive Shift</h2><span id='topic+derive_var_shift'></span>

<h3>Description</h3>

<p>Derives a character shift variable containing concatenated shift in
values based on user-defined pairing, e.g., shift from baseline to
analysis value, shift from baseline grade to analysis grade, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_shift(
  dataset,
  new_var,
  from_var,
  to_var,
  na_val,
  missing_value = "NULL",
  sep_val = " to "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_shift_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>from_var</code> and <code>to_var</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_new_var">new_var</code></td>
<td>
<p>Name of the character shift variable to create.</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_from_var">from_var</code></td>
<td>
<p>Variable containing value to shift from.</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_to_var">to_var</code></td>
<td>
<p>Variable containing value to shift to.</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_na_val">na_val</code></td>
<td>
<p><em>Deprecated</em>, please use <code>missing_value</code> instead.</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_missing_value">missing_value</code></td>
<td>
<p>Character string to replace missing values in <code>from_var</code> or <code>to_var</code>.
</p>
<p>Default: &quot;NULL&quot;</p>
</td></tr>
<tr><td><code id="derive_var_shift_+3A_sep_val">sep_val</code></td>
<td>
<p>Character string to concatenate values of <code>from_var</code> and <code>to_var</code>.
</p>
<p>Default: &quot; to &quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>new_var</code> is derived by concatenating the values of <code>from_var</code> to values of <code>to_var</code>
(e.g. &quot;NORMAL to HIGH&quot;). When <code>from_var</code> or <code>to_var</code> has missing value, the
missing value is replaced by <code>missing_value</code> (e.g. &quot;NORMAL to NULL&quot;).
</p>


<h3>Value</h3>

<p>The input dataset with the character shift variable added
</p>


<h3>See Also</h3>

<p>BDS-Findings Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_basetype_records">derive_basetype_records</a>()</code>,
<code><a href="#topic+derive_var_analysis_ratio">derive_var_analysis_ratio</a>()</code>,
<code><a href="#topic+derive_var_anrind">derive_var_anrind</a>()</code>,
<code><a href="#topic+derive_var_atoxgr">derive_var_atoxgr</a>()</code>,
<code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir</a>()</code>,
<code><a href="#topic+derive_var_base">derive_var_base</a>()</code>,
<code><a href="#topic+derive_var_chg">derive_var_chg</a>()</code>,
<code><a href="#topic+derive_var_ontrtfl">derive_var_ontrtfl</a>()</code>,
<code><a href="#topic+derive_var_pchg">derive_var_pchg</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

data &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVAL, ~ABLFL, ~BNRIND, ~ANRIND,
  "P01", "ALB", 33, "Y", "LOW", "LOW",
  "P01", "ALB", 38, NA, "LOW", "NORMAL",
  "P01", "ALB", NA, NA, "LOW", NA,
  "P02", "ALB", 37, "Y", "NORMAL", "NORMAL",
  "P02", "ALB", 49, NA, "NORMAL", "HIGH",
  "P02", "SODIUM", 147, "Y", "HIGH", "HIGH"
)

data %&gt;%
  convert_blanks_to_na() %&gt;%
  derive_var_shift(
    new_var = SHIFT1,
    from_var = BNRIND,
    to_var = ANRIND
  )

# or only populate post-baseline records
data %&gt;%
  convert_blanks_to_na() %&gt;%
  restrict_derivation(
    derivation = derive_var_shift,
    args = params(
      new_var = SHIFT1,
      from_var = BNRIND,
      to_var = ANRIND
    ),
    filter = is.na(ABLFL)
  )
</code></pre>

<hr>
<h2 id='derive_var_trtdurd'>Derive Total Treatment Duration (Days)</h2><span id='topic+derive_var_trtdurd'></span>

<h3>Description</h3>

<p>Derives total treatment duration (days) (<code>TRTDURD</code>).
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_vars_duration()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_trtdurd(dataset, start_date = TRTSDT, end_date = TRTEDT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_trtdurd_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>start_date</code> and <code>end_date</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_var_trtdurd_+3A_start_date">start_date</code></td>
<td>
<p>The start date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Default: <code>TRTSDT</code></p>
</td></tr>
<tr><td><code id="derive_var_trtdurd_+3A_end_date">end_date</code></td>
<td>
<p>The end date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Default: <code>TRTEDT</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total treatment duration is derived as the number of days from
start to end date plus one.
</p>


<h3>Value</h3>

<p>The input dataset with <code>TRTDURD</code> added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_duration">derive_vars_duration()</a></code>
</p>
<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)

data &lt;- tribble(
  ~TRTSDT, ~TRTEDT,
  ymd("2020-01-01"), ymd("2020-02-24")
)

derive_var_trtdurd(data)
</code></pre>

<hr>
<h2 id='derive_var_trtemfl'>Derive Treatment-emergent Flag</h2><span id='topic+derive_var_trtemfl'></span>

<h3>Description</h3>

<p>Derive treatment emergent analysis flag (e.g., <code>TRTEMFL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_var_trtemfl(
  dataset,
  new_var = TRTEMFL,
  start_date = ASTDTM,
  end_date = AENDTM,
  trt_start_date = TRTSDTM,
  trt_end_date = NULL,
  end_window = NULL,
  ignore_time_for_trt_end = TRUE,
  initial_intensity = NULL,
  intensity = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_var_trtemfl_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by <code>start_date</code>, <code>end_date</code>, <code>trt_start_date</code>,
<code>trt_end_date</code>, <code>initial_intensity</code>, and <code>intensity</code> are expected.</p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_new_var">new_var</code></td>
<td>
<p>New variable</p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_start_date">start_date</code></td>
<td>
<p>Event start date
</p>
<p><em>Permitted Values:</em> A symbol referring to a date or datetime variable of
the input dataset</p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_end_date">end_date</code></td>
<td>
<p>Event end date
</p>
<p><em>Permitted Values:</em> A symbol referring to a date or datetime variable of
the input dataset</p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_trt_start_date">trt_start_date</code></td>
<td>
<p>Treatment start date
</p>
<p><em>Permitted Values:</em> A symbol referring to a date or datetime variable of
the input dataset</p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_trt_end_date">trt_end_date</code></td>
<td>
<p>Treatment end date
</p>
<p><em>Permitted Values:</em> A symbol referring to a date or datetime variable of
the input dataset or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_end_window">end_window</code></td>
<td>
<p>If the argument is specified (in 'days'), events starting more than the specified
number of days after end of treatment, are not flagged.
</p>
<p><em>Permitted Values:</em> A non-negative integer or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_ignore_time_for_trt_end">ignore_time_for_trt_end</code></td>
<td>
<p>If the argument is set to <code>TRUE</code>, the time part is ignored for checking if
the event occurred more than <code>end_window</code> days after end of treatment.
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_initial_intensity">initial_intensity</code></td>
<td>
<p>Initial severity/intensity or toxicity
</p>
<p>This derivation assumes AE data collection method as single record per AE
with &quot;initial&quot; and &quot;most extreme&quot; severity/intensity recorded separately.
</p>
<p>If the argument is specified, events which start before treatment start and
end after treatment start (or are ongoing) and worsened (i.e., the
intensity is greater than the initial intensity), are flagged.
</p>
<p>The values of the specified variable must be comparable with the usual
comparison operators. I.e., if the intensity is greater than the initial
intensity <code>initial_intensity &lt; intensity</code> must evaluate to <code>TRUE</code>.
</p>
<p><em>Permitted Values:</em> A symbol referring to a variable of the input dataset
or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_var_trtemfl_+3A_intensity">intensity</code></td>
<td>
<p>Severity/intensity or toxicity
</p>
<p>If the argument is specified, events which start before treatment start and
end after treatment start (or are ongoing) and worsened (i.e., the
intensity is greater than the initial intensity), are flagged.
</p>
<p>The values of the specified variable must be comparable with the usual
comparison operators. I.e., if the intensity is greater than the initial
intensity <code>initial_intensity &lt; intensity</code> must evaluate to <code>TRUE</code>.
</p>
<p><em>Permitted Values:</em> A symbol referring to a variable of the input dataset
or <code>NULL</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the derivation of the new variable the following cases are
considered in this order. The first case which applies, defines the value
of the variable.
</p>

<ul>
<li> <p><em>not treated</em>: If <code>trt_start_date</code> is <code>NA</code>, it is set to <code>NA_character_</code>.
</p>
</li>
<li> <p><em>event before treatment</em>: If <code>end_date</code> is before <code>trt_start_date</code> (and
<code>end_date</code> is not <code>NA</code>), it is set to <code>NA_character_</code>.
</p>
</li>
<li> <p><em>no event date</em>: If <code>start_date</code> is <code>NA</code>, it is set to <code>"Y"</code> as in such
cases it is usually considered more conservative to assume the event was
treatment-emergent.
</p>
</li>
<li> <p><em>event started during treatment</em>:
</p>

<ul>
<li><p> if <code>end_window</code> is not specified:
if <code>start_date</code> is on or after <code>trt_start_date</code>, it is set to <code>"Y"</code>,
</p>
</li>
<li><p> if <code>end_window</code> is specified:
if <code>start_date</code> is on or after <code>trt_start_date</code> and <code>start_date</code> is on
or before <code>trt_end_date</code> + <code>end_window</code> days, it is set to <code>"Y"</code>,
</p>
</li></ul>

</li>
<li> <p><em>event started before treatment and (possibly) worsened on treatment</em>:
</p>

<ul>
<li><p> if <code>initial_intensity</code> and <code>intensity</code> is specified: if
<code>initial_intensity &lt; intensity</code> and <code>start_date</code> is before
<code>trt_start_date</code> and <code>end_date</code> is on or after <code>trt_start_date</code> or
<code>end_date</code> is <code>NA</code>, it is set to <code>"Y"</code>.
</p>
</li></ul>

</li>
<li><p> Otherwise it is set to <code>NA_character_</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>The input dataset with the variable specified by <code>new_var</code> added
</p>


<h3>See Also</h3>

<p>OCCDS Functions: 
<code><a href="#topic+derive_vars_atc">derive_vars_atc</a>()</code>,
<code><a href="#topic+derive_vars_query">derive_vars_query</a>()</code>,
<code><a href="#topic+get_terms_from_db">get_terms_from_db</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

adae &lt;- expected &lt;- tribble(
  ~USUBJID, ~ASTDTM,            ~AENDTM,            ~AEITOXGR, ~AETOXGR,
  # before treatment
  "1",      "2021-12-13T20:15", "2021-12-15T12:45", "1",       "1",
  "1",      "2021-12-14T20:15", "2021-12-14T22:00", "1",       "3",
  # starting before treatment and ending during treatment
  "1",      "2021-12-30T20:00", "2022-01-14T11:00", "1",       "3",
  "1",      "2021-12-31T20:15", "2022-01-01T01:23", "1",       "1",
  # starting during treatment
  "1",      "2022-01-01T12:00", "2022-01-02T23:25", "3",       "4",
  # after treatment
  "1",      "2022-05-10T11:00", "2022-05-10T13:05", "2",       "2",
  "1",      "2022-05-11T11:00", "2022-05-11T13:05", "2",       "2",
  # missing dates
  "1",      "",                 "",                 "3",       "4",
  "1",      "2021-12-30T09:00", "",                 "3",       "4",
  "1",      "2021-12-30T11:00", "",                 "3",       "3",
  "1",      "",                 "2022-01-04T09:00", "3",       "4",
  "1",      "",                 "2021-12-24T19:00", "3",       "4",
  "1",      "",                 "2022-06-04T09:00", "3",       "4",
  # without treatment
  "2",      "",                 "2021-12-03T12:00", "1",       "2",
  "2",      "2021-12-01T12:00", "2021-12-03T12:00", "1",       "2",
  "2",      "2021-12-06T18:00", "",                 "1",       "2"
) %&gt;%
  mutate(
    ASTDTM = ymd_hm(ASTDTM),
    AENDTM = ymd_hm(AENDTM),
    TRTSDTM = if_else(USUBJID == "1", ymd_hm("2022-01-01T01:01"), ymd_hms("")),
    TRTEDTM = if_else(USUBJID == "1", ymd_hm("2022-04-30T23:59"), ymd_hms(""))
  )

# derive TRTEMFL without considering treatment end and worsening
derive_var_trtemfl(adae) %&gt;% select(ASTDTM, AENDTM, TRTSDTM, TRTEMFL)

# derive TRTEM2FL taking treatment end and worsening into account
derive_var_trtemfl(
  adae,
  new_var = TRTEM2FL,
  trt_end_date = TRTEDTM,
  end_window = 10,
  initial_intensity = AEITOXGR,
  intensity = AETOXGR
) %&gt;% select(ASTDTM, AENDTM, AEITOXGR, AETOXGR, TRTEM2FL)
</code></pre>

<hr>
<h2 id='derive_vars_aage'>Derive Analysis Age</h2><span id='topic+derive_vars_aage'></span>

<h3>Description</h3>

<p>Derives analysis age (<code>AAGE</code>) and analysis age unit (<code>AAGEU</code>).
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_vars_duration()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_aage(
  dataset,
  start_date = BRTHDT,
  end_date = RANDDT,
  unit = "years",
  age_unit = "YEARS",
  type = "interval"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_aage_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>start_date</code> and <code>end_date</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_aage_+3A_start_date">start_date</code></td>
<td>
<p>The start date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date character
vector to a date object.
</p>
<p>Default: <code>BRTHDT</code></p>
</td></tr>
<tr><td><code id="derive_vars_aage_+3A_end_date">end_date</code></td>
<td>
<p>The end date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date character
vector to a date object.
</p>
<p>Default: <code>RANDDT</code></p>
</td></tr>
<tr><td><code id="derive_vars_aage_+3A_unit">unit</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>age_unit</code> instead.</p>
</td></tr>
<tr><td><code id="derive_vars_aage_+3A_age_unit">age_unit</code></td>
<td>
<p>Age unit
</p>
<p>The age is derived in the specified unit
</p>
<p>Permitted Values (case-insensitive):
</p>
<p>For years: <code>"year"</code>, <code>"years"</code>, <code>"yr"</code>, <code>"yrs"</code>, <code>"y"</code>
</p>
<p>For months: <code>"month"</code>, <code>"months"</code>, <code>"mo"</code>, <code>"mos"</code>
</p>
<p>For weeks: <code>"week"</code>, <code>"weeks"</code>, <code>"wk"</code>, <code>"wks"</code>, <code>"w"</code>
</p>
<p>For days: <code>"day"</code>, <code>"days"</code>, <code>"d"</code>
</p>
<p>For hours: <code>"hour"</code>, <code>"hours"</code>, <code>"hr"</code>, <code>"hrs"</code>, <code>"h"</code>
</p>
<p>For minutes: <code>"minute"</code>, <code>"minutes"</code>, <code>"min"</code>, <code>"mins"</code>
</p>
<p>For seconds: <code>"second"</code>, <code>"seconds"</code>, <code>"sec"</code>, <code>"secs"</code>, <code>"s"</code></p>
</td></tr>
<tr><td><code id="derive_vars_aage_+3A_type">type</code></td>
<td>
<p>lubridate duration type.
</p>
<p>See below for details.
</p>
<p>Default: <code>"duration"</code>
</p>
<p>Permitted Values: <code>"duration"</code>, <code>"interval"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The duration is derived as time from start to end date in the
specified output unit. If the end date is before the start date, the duration
is negative. The start and end date variable must be present in the specified
input dataset.
</p>
<p>The <a href="https://lubridate.tidyverse.org/">lubridate</a> package calculates two
types of spans between two dates: duration and interval.
While these calculations are largely the same, when the unit of the time period
is month or year the result can be slightly different.
</p>
<p>The difference arises from the ambiguity in the length of <code>"1 month"</code> or
<code>"1 year"</code>.
Months may have 31, 30, 28, or 29 days, and years are 365 days and 366 during leap years.
Durations and intervals help solve the ambiguity in these measures.
</p>
<p>The <strong>interval</strong> between <code>2000-02-01</code> and <code>2000-03-01</code> is <code>1</code> (i.e. one month).
The <strong>duration</strong> between these two dates is <code>0.95</code>, which accounts for the fact
that the year 2000 is a leap year, February has 29 days, and the average month
length is <code>30.4375</code>, i.e. <code>29 / 30.4375 = 0.95</code>.
</p>
<p>For additional details, review the
<a href="https://lubridate.tidyverse.org/reference/timespan.html">lubridate time span reference page</a>.
</p>


<h3>Value</h3>

<p>The input dataset with <code>AAGE</code> and <code>AAGEU</code> added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_vars_duration">derive_vars_duration()</a></code>
</p>
<p>ADSL Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_age_years">derive_var_age_years</a>()</code>,
<code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event</a>()</code>,
<code><a href="#topic+derive_vars_period">derive_vars_period</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)

data &lt;- tribble(
  ~BRTHDT, ~RANDDT,
  ymd("1984-09-06"), ymd("2020-02-24")
)

derive_vars_aage(data)
</code></pre>

<hr>
<h2 id='derive_vars_atc'>Derive ATC Class Variables</h2><span id='topic+derive_vars_atc'></span>

<h3>Description</h3>

<p>Add Anatomical Therapeutic Chemical class variables from <code>FACM</code> to <code>ADCM</code>.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>derive_vars_transposed()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_atc(
  dataset,
  dataset_facm,
  by_vars = exprs(USUBJID, CMREFID = FAREFID),
  value_var = FASTRESC
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_atc_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_atc_+3A_dataset_facm">dataset_facm</code></td>
<td>
<p>FACM dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>value_var</code> parameters,
<code>FAGRPID</code> and <code>FATESTCD</code> are required</p>
</td></tr>
<tr><td><code id="derive_vars_atc_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Keys used to merge <code>dataset_facm</code> with <code>dataset</code>.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_atc_+3A_value_var">value_var</code></td>
<td>
<p>The variable of <code>dataset_facm</code> containing the values of the
transposed variables
</p>
<p>Default: <code>FASTRESC</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input dataset with ATC variables added
</p>


<h3>See Also</h3>

<p>OCCDS Functions: 
<code><a href="#topic+derive_var_trtemfl">derive_var_trtemfl</a>()</code>,
<code><a href="#topic+derive_vars_query">derive_vars_query</a>()</code>,
<code><a href="#topic+get_terms_from_db">get_terms_from_db</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

cm &lt;- tribble(
  ~USUBJID, ~CMGRPID, ~CMREFID, ~CMDECOD,
  "BP40257-1001", "14", "1192056", "PARACETAMOL",
  "BP40257-1001", "18", "2007001", "SOLUMEDROL",
  "BP40257-1002", "19", "2791596", "SPIRONOLACTONE"
)
facm &lt;- tribble(
  ~USUBJID, ~FAGRPID, ~FAREFID, ~FATESTCD, ~FASTRESC,
  "BP40257-1001", "1", "1192056", "CMATC1CD", "N",
  "BP40257-1001", "1", "1192056", "CMATC2CD", "N02",
  "BP40257-1001", "1", "1192056", "CMATC3CD", "N02B",
  "BP40257-1001", "1", "1192056", "CMATC4CD", "N02BE",
  "BP40257-1001", "1", "2007001", "CMATC1CD", "D",
  "BP40257-1001", "1", "2007001", "CMATC2CD", "D10",
  "BP40257-1001", "1", "2007001", "CMATC3CD", "D10A",
  "BP40257-1001", "1", "2007001", "CMATC4CD", "D10AA",
  "BP40257-1001", "2", "2007001", "CMATC1CD", "D",
  "BP40257-1001", "2", "2007001", "CMATC2CD", "D07",
  "BP40257-1001", "2", "2007001", "CMATC3CD", "D07A",
  "BP40257-1001", "2", "2007001", "CMATC4CD", "D07AA",
  "BP40257-1001", "3", "2007001", "CMATC1CD", "H",
  "BP40257-1001", "3", "2007001", "CMATC2CD", "H02",
  "BP40257-1001", "3", "2007001", "CMATC3CD", "H02A",
  "BP40257-1001", "3", "2007001", "CMATC4CD", "H02AB",
  "BP40257-1002", "1", "2791596", "CMATC1CD", "C",
  "BP40257-1002", "1", "2791596", "CMATC2CD", "C03",
  "BP40257-1002", "1", "2791596", "CMATC3CD", "C03D",
  "BP40257-1002", "1", "2791596", "CMATC4CD", "C03DA"
)

derive_vars_atc(cm, facm)
</code></pre>

<hr>
<h2 id='derive_vars_computed'>Adds Variable(s) Computed from the Analysis Value of one or more Parameters</h2><span id='topic+derive_vars_computed'></span>

<h3>Description</h3>

<p>Adds Variable(s) computed from the analysis value of one or more parameters.
It is expected that the value of the new variable is defined by an expression
using the analysis values of other parameters. For example Body Mass Index at
Baseline (<code>BMIBL</code>) in <code>ADSL</code> can be derived from of HEIGHT and WEIGHT
parameters in <code>ADVS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_computed(
  dataset,
  dataset_add,
  by_vars,
  parameters,
  new_vars,
  filter_add = NULL,
  constant_by_vars = NULL,
  constant_parameters = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_computed_+3A_dataset">dataset</code></td>
<td>
<p>The variables specified by the <code>by_vars</code> parameter are expected.</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code> parameter are expected.
</p>
<p>The variable specified by <code>by_vars</code> and <code>PARAMCD</code> must be a unique key of
the additional dataset after restricting it by the filter condition
(<code>filter_add</code> parameter) and to the parameters specified by <code>parameters</code>.</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Grouping variables uniquely identifying a set of records for which
<code>new_vars</code> are to be calculated.
</p>
<p><em>Permitted Values:</em> list of variables created by exprs()</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_parameters">parameters</code></td>
<td>
<p>Required parameter codes
</p>
<p>It is expected that all parameter codes (<code>PARAMCD</code>) which are required to
derive the new variable are specified for this parameter or the
<code>constant_parameters</code> parameter.
</p>
<p>If observations should be considered which do not have a parameter code,
e.g., if an SDTM dataset is used, temporary parameter codes can be derived
by specifying a list of expressions. The name of the element defines the
temporary parameter code and the expression defines the condition for
selecting the records. For example,
<code>parameters = exprs(HGHT = VSTESTCD == "HEIGHT")</code> selects the observations
with <code>VSTESTCD == "HEIGHT"</code> from the input data (<code>dataset</code> and
<code>dataset_add</code>), sets <code>PARAMCD = "HGHT"</code> for these observations, and adds
them to the observations to consider.
</p>
<p>Unnamed elements in the list of expressions are considered as parameter
codes. For example, <code>parameters = exprs(WEIGHT, HGHT = VSTESTCD == "HEIGHT")</code> uses the parameter code <code>"WEIGHT"</code> and creates a temporary
parameter code <code>"HGHT"</code>.
</p>
<p><em>Permitted Values:</em> A character vector of <code>PARAMCD</code> values or a list of expressions</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_new_vars">new_vars</code></td>
<td>
<p>Name of the newly created variables
</p>
<p>The specified variables are set to the specified values. The values of
variables of the parameters specified by <code>parameters</code> can be accessed using
<code style="white-space: pre;">&#8288;&lt;variable name&gt;.&lt;parameter code&gt;&#8288;</code>. For example
</p>
<div class="sourceCode"><pre>exprs(
  BMIBL = (AVAL.WEIGHT / (AVAL.HEIGHT/100)^2)
)
</pre></div>
<p>defines the value for the new variable.
</p>
<p>Variable names in the expression must not contain more than one dot.
</p>
<p><em>Permitted Values:</em> List of variable-value pairs</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter condition of additional dataset
</p>
<p>The specified condition is applied to the additional dataset before
deriving the new variable, i.e., only observations fulfilling the
condition are taken into account.
</p>
<p><em>Permitted Values:</em> a condition</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_constant_by_vars">constant_by_vars</code></td>
<td>
<p>By variables for constant parameters
</p>
<p>The constant parameters (parameters that are measured only once) are merged
to the other parameters using the specified variables.
(Refer to the Example)
</p>
<p><em>Permitted Values:</em> list of variables</p>
</td></tr>
<tr><td><code id="derive_vars_computed_+3A_constant_parameters">constant_parameters</code></td>
<td>
<p>Required constant parameter codes
</p>
<p>It is expected that all the parameter codes (<code>PARAMCD</code>) which are required
to derive the new variable and are measured only once are specified here.
For example if BMI should be derived and height is measured only once while
weight is measured at each visit. Height could be specified in the
<code>constant_parameters</code> parameter. (Refer to the Example)
</p>
<p>If observations should be considered which do not have a parameter code,
e.g., if an SDTM dataset is used, temporary parameter codes can be derived
by specifying a list of expressions. The name of the element defines the
temporary parameter code and the expression defines the condition for
selecting the records. For example <code>constant_parameters = exprs(HGHT = VSTESTCD == "HEIGHT")</code> selects the observations with
<code>VSTESTCD == "HEIGHT"</code> from the input data (<code>dataset</code> and <code>dataset_add</code>),
sets <code>PARAMCD = "HGHT"</code> for these observations, and adds them to the
observations to consider.
</p>
<p>Unnamed elements in the list of expressions are considered as parameter
codes. For example, <code>constant_parameters = exprs(WEIGHT, HGHT = VSTESTCD == "HEIGHT")</code> uses the parameter code <code>"WEIGHT"</code> and creates a temporary
parameter code <code>"HGHT"</code>.
</p>
<p><em>Permitted Values:</em> A character vector of <code>PARAMCD</code> values or a list of expressions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
<code>by_vars</code> argument), the values of the new variables (<code>new_vars</code>) are
computed based on the parameters in the additional dataset
(<code>dataset_add</code>) and then the new variables are merged to the input
dataset (<code>dataset</code>).
</p>


<h3>Value</h3>

<p>The input dataset with the new variables added.
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)

# Example 1: Derive BMIBL
adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01", "01-1302",   61, "YEARS",
  "PILOT01", "17-1344",   64, "YEARS"
)

advs &lt;- tribble(
  ~STUDYID, ~USUBJID, ~PARAMCD, ~PARAM, ~VISIT, ~AVAL, ~AVALU, ~ABLFL,
  "PILOT01", "01-1302", "HEIGHT", "Height (cm)", "SCREENING", 177.8, "cm", "Y",
  "PILOT01", "01-1302", "WEIGHT", "Weight (kg)", "SCREENING", 81.19, "kg", "N",
  "PILOT01", "01-1302", "WEIGHT", "Weight (kg)", "BASELINE", 82.1, "kg", "Y",
  "PILOT01", "01-1302", "WEIGHT", "Weight (kg)", "WEEK 2", 81.19, "kg", "N",
  "PILOT01", "01-1302", "WEIGHT", "Weight (kg)", "WEEK 4", 82.56, "kg", "N",
  "PILOT01", "01-1302", "WEIGHT", "Weight (kg)", "WEEK 6", 80.74, "kg", "N",
  "PILOT01", "17-1344", "HEIGHT", "Height (cm)", "SCREENING", 163.5, "cm", "Y",
  "PILOT01", "17-1344", "WEIGHT", "Weight (kg)", "SCREENING", 58.06, "kg", "N",
  "PILOT01", "17-1344", "WEIGHT", "Weight (kg)", "BASELINE", 58.06, "kg", "Y",
  "PILOT01", "17-1344", "WEIGHT", "Weight (kg)", "WEEK 2", 58.97, "kg", "N",
  "PILOT01", "17-1344", "WEIGHT", "Weight (kg)", "WEEK 4", 57.97, "kg", "N",
  "PILOT01", "17-1344", "WEIGHT", "Weight (kg)", "WEEK 6", 58.97, "kg", "N"
)

derive_vars_computed(
  dataset = adsl,
  dataset_add = advs,
  by_vars = exprs(STUDYID, USUBJID),
  parameters = c("WEIGHT", "HEIGHT"),
  new_vars = exprs(BMIBL = compute_bmi(height = AVAL.HEIGHT, weight = AVAL.WEIGHT)),
  filter_add = ABLFL == "Y"
)
</code></pre>

<hr>
<h2 id='derive_vars_dt'>Derive/Impute a Date from a Date Character Vector</h2><span id='topic+derive_vars_dt'></span>

<h3>Description</h3>

<p>Derive a date (<code>'--DT'</code>) from a date character vector (<code style="white-space: pre;">&#8288;'--DTC&#8288;</code>').
The date can be imputed (see <code>date_imputation</code> argument)
and the date imputation flag ('<code style="white-space: pre;">&#8288;--DTF'&#8288;</code>) can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_dt(
  dataset,
  new_vars_prefix,
  dtc,
  highest_imputation = "n",
  date_imputation = "first",
  flag_imputation = "auto",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_dt_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>dtc</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_new_vars_prefix">new_vars_prefix</code></td>
<td>
<p>Prefix used for the output variable(s).
</p>
<p>A character scalar is expected. For the date variable &quot;DT&quot; is appended to
the specified prefix and for the date imputation flag &quot;DTF&quot;. I.e., for
<code>new_vars_prefix = "AST"</code> the variables <code>ASTDT</code> and <code>ASTDTF</code> are created.</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"n"</code> (none, lowest level)</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_flag_imputation">flag_imputation</code></td>
<td>
<p>Whether the date imputation flag must also be derived.
</p>
<p>If <code>"auto"</code> is specified and <code>highest_imputation</code> argument is not <code>"n"</code>,
then date imputation flag is derived.
</p>
<p>If <code>"date"</code> is specified, then date imputation flag is derived.
</p>
<p>If <code>"none"</code> is specified, then no date imputation flag is derived.
</p>
<p><em>Permitted Values</em>: <code>"auto"</code>, <code>"date"</code> or <code>"none"</code></p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.</p>
</td></tr>
<tr><td><code id="derive_vars_dt_+3A_preserve">preserve</code></td>
<td>
<p>Preserve day if month is missing and day is present
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "MID"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>{admiral}</code> we don't allow users to pick any single part of the date/time to
impute, we only enable to impute up to a highest level, i.e. you couldn't
choose to say impute months, but not days.
</p>
<p>The presence of a <code>'--DTF'</code> variable is checked and if it already exists in the input dataset,
a warning is issued and <code>'--DTF'</code> will be overwritten.
</p>


<h3>Value</h3>

<p>The input dataset with the date <code>'--DT'</code> (and the date imputation flag <code>'--DTF'</code>
if requested) added.
</p>


<h3>See Also</h3>

<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)

mhdt &lt;- tribble(
  ~MHSTDTC,
  "2019-07-18T15:25:40",
  "2019-07-18T15:25",
  "2019-07-18",
  "2019-02",
  "2019",
  "2019---07",
  ""
)

# Create ASTDT and ASTDTF
# No imputation for partial date
derive_vars_dt(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC
)

# Create ASTDT and ASTDTF
# Impute partial dates to first day/month
derive_vars_dt(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M"
)

# Impute partial dates to 6th of April
derive_vars_dt(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M",
  date_imputation = "04-06"
)

# Create AENDT and AENDTF
# Impute partial dates to last day/month
derive_vars_dt(
  mhdt,
  new_vars_prefix = "AEN",
  dtc = MHSTDTC,
  highest_imputation = "M",
  date_imputation = "last"
)

# Create BIRTHDT
# Impute partial dates to 15th of June. No Date Imputation Flag
derive_vars_dt(
  mhdt,
  new_vars_prefix = "BIRTH",
  dtc = MHSTDTC,
  highest_imputation = "M",
  date_imputation = "mid",
  flag_imputation = "none"
)

# Impute AE start date to the first date and ensure that the imputed date
# is not before the treatment start date
adae &lt;- tribble(
  ~AESTDTC, ~TRTSDTM,
  "2020-12", ymd_hms("2020-12-06T12:12:12"),
  "2020-11", ymd_hms("2020-12-06T12:12:12")
)

derive_vars_dt(
  adae,
  dtc = AESTDTC,
  new_vars_prefix = "AST",
  highest_imputation = "M",
  min_dates = exprs(TRTSDTM)
)

# A user imputing dates as middle month/day, i.e. date_imputation = "mid" can
# use preserve argument to "preserve" partial dates.  For example, "2019---07",
# will be displayed as "2019-06-07" rather than 2019-06-15 with preserve = TRUE

derive_vars_dt(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M",
  date_imputation = "mid",
  preserve = TRUE
)
</code></pre>

<hr>
<h2 id='derive_vars_dtm'>Derive/Impute a Datetime from a Date Character Vector</h2><span id='topic+derive_vars_dtm'></span>

<h3>Description</h3>

<p>Derive a datetime object (<code>'--DTM'</code>) from a date character vector (<code>'--DTC'</code>).
The date and time can be imputed (see <code>date_imputation</code>/<code>time_imputation</code> arguments)
and the date/time imputation flag (<code>'--DTF'</code>, <code>'--TMF'</code>) can be added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_dtm(
  dataset,
  new_vars_prefix,
  dtc,
  highest_imputation = "h",
  date_imputation = "first",
  time_imputation = "first",
  flag_imputation = "auto",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE,
  ignore_seconds_flag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_dtm_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>dtc</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_new_vars_prefix">new_vars_prefix</code></td>
<td>
<p>Prefix used for the output variable(s).
</p>
<p>A character scalar is expected. For the date variable &quot;DT&quot; is appended to
the specified prefix, for the date imputation flag &quot;DTF&quot;, and for the time
imputation flag &quot;TMF&quot;. I.e., for <code>new_vars_prefix = "AST"</code> the variables
<code>ASTDT</code>, <code>ASTDTF</code>, and <code>ASTTMF</code> are created.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified, no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"h"</code> (hour), <code>"m"</code> (minute), <code>"s"</code> (second), <code>"n"</code> (none, lowest
level)</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_time_imputation">time_imputation</code></td>
<td>
<p>The value to impute the time when a timepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with hour, min and sec specified as <code>"hh:mm:ss"</code>: e.g. <code>"00:00:00"</code>
for the start of the day,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>,<code>"last"</code> to impute to the start/end of a day.
</p>
</li></ul>

<p>The argument is ignored if <code>highest_imputation = "n"</code>.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_flag_imputation">flag_imputation</code></td>
<td>
<p>Whether the date/time imputation flag(s) must also be derived.
</p>
<p>If <code>"both"</code> or <code>"date"</code> is specified, then date imputation flag is derived.
If <code>"auto"</code> is specified and <code>highest_imputation</code> argument is greater than
<code>"h"</code>, then date imputation flag is derived.
</p>
<p>If <code>"both"</code> or <code>"time"</code> is specified, then time imputation flag is derived.
If <code>"auto"</code> is specified and <code>highest_imputation</code> argument is not <code>"n"</code>,
then time imputation flag is derived.
</p>
<p>If <code>"none"</code> is specified, then no date or time imputation flag is derived.
</p>
<p><em>Permitted Values</em>: <code>"auto"</code>, <code>"date"</code>, <code>"time"</code>, <code>"both"</code>, or <code>"none"</code></p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"00:00:00"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"23:59:59"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_preserve">preserve</code></td>
<td>
<p>Preserve lower level date/time part when higher order part
is missing, e.g. preserve day if month is missing or
preserve minute when hour is missing.
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "mid"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_vars_dtm_+3A_ignore_seconds_flag">ignore_seconds_flag</code></td>
<td>
<p>ADaM IG states that given SDTM (<code>'--DTC'</code>) variable,
if only hours and minutes are ever collected, and seconds are imputed in
(<code>'--DTM'</code>) as 00, then it is not necessary to set (<code>'--TMF'</code>) to <code>'S'</code>. A user can set this
to <code>TRUE</code> so the <code>'S'</code> Flag is dropped from (<code>'--TMF'</code>).
</p>
<p><em>Permitted Values</em>: A logical value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code>{admiral}</code> we don't allow users to pick any single part of the date/time to
impute, we only enable to impute up to a highest level, i.e. you couldn't
choose to say impute months, but not days.
</p>
<p>The presence of a <code>'--DTF'</code> variable is checked and the variable is not derived
if it already exists in the input dataset. However, if <code>'--TMF'</code> already exists
in the input dataset, a warning is issued and <code>'--TMF'</code> will be overwritten.
</p>


<h3>Value</h3>

<p>The input dataset with the datetime <code>'--DTM'</code> (and the date/time imputation
flag <code>'--DTF'</code>, <code>'--TMF'</code>) added.
</p>


<h3>See Also</h3>

<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)

mhdt &lt;- tribble(
  ~MHSTDTC,
  "2019-07-18T15:25:40",
  "2019-07-18T15:25",
  "2019-07-18",
  "2019-02",
  "2019",
  "2019---07",
  ""
)

derive_vars_dtm(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M"
)

# Impute AE end date to the last date and ensure that the imputed date is not
# after the death or data cut off date
adae &lt;- tribble(
  ~AEENDTC, ~DTHDT, ~DCUTDT,
  "2020-12", ymd("2020-12-06"), ymd("2020-12-24"),
  "2020-11", ymd("2020-12-06"), ymd("2020-12-24")
)

derive_vars_dtm(
  adae,
  dtc = AEENDTC,
  new_vars_prefix = "AEN",
  highest_imputation = "M",
  date_imputation = "last",
  time_imputation = "last",
  max_dates = exprs(DTHDT, DCUTDT)
)

# Seconds has been removed from the input dataset.  Function now uses
# ignore_seconds_flag to remove the 'S' from the --TMF variable.
mhdt &lt;- tribble(
  ~MHSTDTC,
  "2019-07-18T15:25",
  "2019-07-18T15:25",
  "2019-07-18",
  "2019-02",
  "2019",
  "2019---07",
  ""
)

derive_vars_dtm(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M",
  ignore_seconds_flag = TRUE
)

# A user imputing dates as middle month/day, i.e. date_imputation = "MID" can
# use preserve argument to "preserve" partial dates.  For example, "2019---07",
# will be displayed as "2019-06-07" rather than 2019-06-15 with preserve = TRUE

derive_vars_dtm(
  mhdt,
  new_vars_prefix = "AST",
  dtc = MHSTDTC,
  highest_imputation = "M",
  date_imputation = "mid",
  preserve = TRUE
)
</code></pre>

<hr>
<h2 id='derive_vars_dtm_to_dt'>Derive Date Variables from Datetime Variables</h2><span id='topic+derive_vars_dtm_to_dt'></span>

<h3>Description</h3>

<p>This function creates date(s) as output from datetime variable(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_dtm_to_dt(dataset, source_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_dtm_to_dt_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>source_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_to_dt_+3A_source_vars">source_vars</code></td>
<td>
<p>A list of datetime variables created using <code>exprs()</code> from
which dates are to be extracted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the input dataset with the corresponding date (<code>--DT</code>)
variable(s) of all datetime variables (<code>--DTM</code>) specified in <code>source_vars.</code>
</p>


<h3>See Also</h3>

<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

adcm &lt;- tribble(
  ~USUBJID, ~TRTSDTM,              ~ASTDTM,               ~AENDTM,
  "PAT01",  "2012-02-25 23:00:00", "2012-02-28 19:00:00", "2012-02-25 23:00:00",
  "PAT01",  NA,                    "2012-02-28 19:00:00", NA,
  "PAT01",  "2017-02-25 23:00:00", "2013-02-25 19:00:00", "2014-02-25 19:00:00",
  "PAT01",  "2017-02-25 16:00:00", "2017-02-25 14:00:00", "2017-03-25 23:00:00",
  "PAT01",  "2017-02-25 16:00:00", "2017-02-25 14:00:00", "2017-04-29 14:00:00",
) %&gt;%
  mutate(
    TRTSDTM = as_datetime(TRTSDTM),
    ASTDTM = as_datetime(ASTDTM),
    AENDTM = as_datetime(AENDTM)
  )

adcm %&gt;%
  derive_vars_dtm_to_dt(exprs(TRTSDTM, ASTDTM, AENDTM)) %&gt;%
  select(USUBJID, starts_with("TRT"), starts_with("AST"), starts_with("AEN"))
</code></pre>

<hr>
<h2 id='derive_vars_dtm_to_tm'>Derive Time Variables from Datetime Variables</h2><span id='topic+derive_vars_dtm_to_tm'></span>

<h3>Description</h3>

<p>This function creates time variable(s) as output from datetime variable(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_dtm_to_tm(dataset, source_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_dtm_to_tm_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>source_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_dtm_to_tm_+3A_source_vars">source_vars</code></td>
<td>
<p>A list of datetime variables created using <code>exprs()</code> from
which time is to be extracted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the newly added variables are automatically set by replacing the
<code>--DTM</code> suffix of the <code>source_vars</code> with <code>--TM</code>. The <code>--TM</code> variables are created
using the <code>{hms}</code> package.
</p>


<h3>Value</h3>

<p>A data frame containing the input dataset with the corresponding time
(<code>--TM</code>) variable(s) of all datetime variables (<code>--DTM</code>) specified in
<code>source_vars</code> with the correct name.
</p>


<h3>See Also</h3>

<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

adcm &lt;- tribble(
  ~USUBJID, ~TRTSDTM, ~ASTDTM, ~AENDTM,
  "PAT01", "2012-02-25 23:41:10", "2012-02-28 19:03:00", "2013-02-25 23:32:16",
  "PAT01", "", "2012-02-28 19:00:00", "",
  "PAT01", "2017-02-25 23:00:02", "2013-02-25 19:00:15", "2014-02-25 19:00:56",
  "PAT01", "2017-02-25 16:00:00", "2017-02-25 14:25:00", "2017-03-25 23:00:00",
  "PAT01", "2017-02-25 16:05:17", "2017-02-25 14:20:00", "2018-04-29 14:06:45",
) %&gt;%
  mutate(
    TRTSDTM = as_datetime(TRTSDTM),
    ASTDTM = as_datetime(ASTDTM),
    AENDTM = as_datetime(AENDTM)
  )

adcm %&gt;%
  derive_vars_dtm_to_tm(exprs(TRTSDTM)) %&gt;%
  select(USUBJID, starts_with("TRT"), everything())

adcm %&gt;%
  derive_vars_dtm_to_tm(exprs(TRTSDTM, ASTDTM, AENDTM)) %&gt;%
  select(USUBJID, starts_with("TRT"), starts_with("AS"), starts_with("AE"))
</code></pre>

<hr>
<h2 id='derive_vars_duration'>Derive Duration</h2><span id='topic+derive_vars_duration'></span>

<h3>Description</h3>

<p>Derives duration between two dates, specified by the variables present in
input dataset e.g., duration of adverse events, relative day, age, ...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_duration(
  dataset,
  new_var,
  new_var_unit = NULL,
  start_date,
  end_date,
  in_unit = "days",
  out_unit = "DAYS",
  floor_in = TRUE,
  add_one = TRUE,
  trunc_out = FALSE,
  type = "duration"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_duration_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>start_date</code> and <code>end_date</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_new_var">new_var</code></td>
<td>
<p>Name of variable to create</p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_new_var_unit">new_var_unit</code></td>
<td>
<p>Name of the unit variable If the parameter is not
specified, no variable for the unit is created.</p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_start_date">start_date</code></td>
<td>
<p>The start date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Refer to <code>convert_dtc_to_dt()</code> to obtain a vector of imputed dates.</p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_end_date">end_date</code></td>
<td>
<p>The end date
</p>
<p>A date or date-time object is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.
</p>
<p>Refer to <code>convert_dtc_to_dt()</code> to obtain a vector of imputed dates.</p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_in_unit">in_unit</code></td>
<td>
<p>Input unit
</p>
<p>See floor_in and add_one parameter for details.
</p>
<p>Permitted Values (case-insensitive):
</p>
<p>For years: <code>"year"</code>, <code>"years"</code>, <code>"yr"</code>, <code>"yrs"</code>, <code>"y"</code>
</p>
<p>For months: <code>"month"</code>, <code>"months"</code>, <code>"mo"</code>, <code>"mos"</code>
</p>
<p>For days: <code>"day"</code>, <code>"days"</code>, <code>"d"</code>
</p>
<p>For hours: <code>"hour"</code>, <code>"hours"</code>, <code>"hr"</code>, <code>"hrs"</code>, <code>"h"</code>
</p>
<p>For minutes: <code>"minute"</code>, <code>"minutes"</code>, <code>"min"</code>, <code>"mins"</code>
</p>
<p>For seconds: <code>"second"</code>, <code>"seconds"</code>, <code>"sec"</code>, <code>"secs"</code>, <code>"s"</code></p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_out_unit">out_unit</code></td>
<td>
<p>Output unit
</p>
<p>The duration is derived in the specified unit
</p>
<p>Permitted Values (case-insensitive):
</p>
<p>For years: <code>"year"</code>, <code>"years"</code>, <code>"yr"</code>, <code>"yrs"</code>, <code>"y"</code>
</p>
<p>For months: <code>"month"</code>, <code>"months"</code>, <code>"mo"</code>, <code>"mos"</code>
</p>
<p>For weeks: <code>"week"</code>, <code>"weeks"</code>, <code>"wk"</code>, <code>"wks"</code>, <code>"w"</code>
</p>
<p>For days: <code>"day"</code>, <code>"days"</code>, <code>"d"</code>
</p>
<p>For hours: <code>"hour"</code>, <code>"hours"</code>, <code>"hr"</code>, <code>"hrs"</code>, <code>"h"</code>
</p>
<p>For minutes: <code>"minute"</code>, <code>"minutes"</code>, <code>"min"</code>, <code>"mins"</code>
</p>
<p>For seconds: <code>"second"</code>, <code>"seconds"</code>, <code>"sec"</code>, <code>"secs"</code>, <code>"s"</code></p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_floor_in">floor_in</code></td>
<td>
<p>Round down input dates?
</p>
<p>The input dates are round down with respect to the input unit, e.g., if the
input unit is 'days', the time of the input dates is ignored.
</p>
<p>Default: <code>TRUE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_add_one">add_one</code></td>
<td>
<p>Add one input unit?
</p>
<p>If the duration is non-negative, one input unit is added. i.e., the
duration can not be zero.
</p>
<p>Default: <code>TRUE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_trunc_out">trunc_out</code></td>
<td>
<p>Return integer part
</p>
<p>The fractional part of the duration (in output unit) is removed, i.e., the
integer part is returned.
</p>
<p>Default: <code>FALSE</code>
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="derive_vars_duration_+3A_type">type</code></td>
<td>
<p>lubridate duration type.
</p>
<p>See below for details.
</p>
<p>Default: <code>"duration"</code>
</p>
<p>Permitted Values: <code>"duration"</code>, <code>"interval"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The duration is derived as time from start to end date in the
specified output unit. If the end date is before the start date, the duration
is negative. The start and end date variable must be present in the specified
input dataset.
</p>
<p>The <a href="https://lubridate.tidyverse.org/">lubridate</a> package calculates two
types of spans between two dates: duration and interval.
While these calculations are largely the same, when the unit of the time period
is month or year the result can be slightly different.
</p>
<p>The difference arises from the ambiguity in the length of <code>"1 month"</code> or
<code>"1 year"</code>.
Months may have 31, 30, 28, or 29 days, and years are 365 days and 366 during leap years.
Durations and intervals help solve the ambiguity in these measures.
</p>
<p>The <strong>interval</strong> between <code>2000-02-01</code> and <code>2000-03-01</code> is <code>1</code> (i.e. one month).
The <strong>duration</strong> between these two dates is <code>0.95</code>, which accounts for the fact
that the year 2000 is a leap year, February has 29 days, and the average month
length is <code>30.4375</code>, i.e. <code>29 / 30.4375 = 0.95</code>.
</p>
<p>For additional details, review the
<a href="https://lubridate.tidyverse.org/reference/timespan.html">lubridate time span reference page</a>.
</p>


<h3>Value</h3>

<p>The input dataset with the duration and unit variable added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_duration">compute_duration()</a></code>
</p>
<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_dy">derive_vars_dy</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
library(tibble)

# Derive age in years
data &lt;- tribble(
  ~USUBJID, ~BRTHDT, ~RANDDT,
  "P01", ymd("1984-09-06"), ymd("2020-02-24"),
  "P02", ymd("1985-01-01"), NA,
  "P03", NA, ymd("2021-03-10"),
  "P04", NA, NA
)

derive_vars_duration(data,
  new_var = AAGE,
  new_var_unit = AAGEU,
  start_date = BRTHDT,
  end_date = RANDDT,
  out_unit = "years",
  add_one = FALSE,
  trunc_out = TRUE
)

# Derive adverse event duration in days
data &lt;- tribble(
  ~USUBJID, ~ASTDT, ~AENDT,
  "P01", ymd("2021-03-05"), ymd("2021-03-02"),
  "P02", ymd("2019-09-18"), ymd("2019-09-18"),
  "P03", ymd("1985-01-01"), NA,
  "P04", NA, NA
)

derive_vars_duration(data,
  new_var = ADURN,
  new_var_unit = ADURU,
  start_date = ASTDT,
  end_date = AENDT,
  out_unit = "days"
)

# Derive adverse event duration in minutes
data &lt;- tribble(
  ~USUBJID, ~ADTM, ~TRTSDTM,
  "P01", ymd_hms("2019-08-09T04:30:56"), ymd_hms("2019-08-09T05:00:00"),
  "P02", ymd_hms("2019-11-11T10:30:00"), ymd_hms("2019-11-11T11:30:00"),
  "P03", ymd_hms("2019-11-11T00:00:00"), ymd_hms("2019-11-11T04:00:00"),
  "P04", NA, ymd_hms("2019-11-11T12:34:56"),
)

derive_vars_duration(data,
  new_var = ADURN,
  new_var_unit = ADURU,
  start_date = ADTM,
  end_date = TRTSDTM,
  in_unit = "minutes",
  out_unit = "minutes",
  add_one = FALSE
)

# Derive adverse event start time since last dose in hours
data &lt;- tribble(
  ~USUBJID, ~ASTDTM, ~LDOSEDTM,
  "P01", ymd_hms("2019-08-09T04:30:56"), ymd_hms("2019-08-08T10:05:00"),
  "P02", ymd_hms("2019-11-11T23:59:59"), ymd_hms("2019-10-11T11:37:00"),
  "P03", ymd_hms("2019-11-11T00:00:00"), ymd_hms("2019-11-10T23:59:59"),
  "P04", ymd_hms("2019-11-11T12:34:56"), NA,
  "P05", NA, ymd_hms("2019-09-28T12:34:56")
)
derive_vars_duration(
  data,
  new_var = LDRELTM,
  new_var_unit = LDRELTMU,
  start_date = LDOSEDTM,
  end_date = ASTDTM,
  in_unit = "hours",
  out_unit = "hours",
  add_one = FALSE
)
</code></pre>

<hr>
<h2 id='derive_vars_dy'>Derive Relative Day Variables</h2><span id='topic+derive_vars_dy'></span>

<h3>Description</h3>

<p>Adds relative day variables (<code>--DY</code>) to the dataset, e.g., <code>ASTDY</code> and
<code>AENDY</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_dy(dataset, reference_date, source_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_dy_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>reference_date</code> and <code>source_vars</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_dy_+3A_reference_date">reference_date</code></td>
<td>
<p>A date or date-time column, e.g., date of first treatment
or date-time of last exposure to treatment.
</p>
<p>Refer to <code>derive_vars_dt()</code> to impute and derive a date from a date
character vector to a date object.</p>
</td></tr>
<tr><td><code id="derive_vars_dy_+3A_source_vars">source_vars</code></td>
<td>
<p>A list of datetime or date variables created using
<code>exprs()</code> from which dates are to be extracted. This can either be a list of
date(time) variables or named <code>--DY</code> variables and corresponding &ndash;DT(M)
variables e.g. <code>exprs(TRTSDTM, ASTDTM, AENDT)</code> or <code>exprs(TRTSDT, ASTDTM, AENDT, DEATHDY = DTHDT)</code>. If the source variable does not end in &ndash;DT(M), a
name for the resulting <code>--DY</code> variable must be provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The relative day is derived as number of days from the reference
date to the end date. If it is nonnegative, one is added. I.e., the
relative day of the reference date is 1. Unless a name is explicitly
specified, the name of the resulting relative day variable is generated
from the source variable name by replacing DT (or DTM as appropriate) with
DY.
</p>


<h3>Value</h3>

<p>The input dataset with <code>--DY</code> corresponding to the <code>--DTM</code> or <code>--DT</code>
source variable(s) added
</p>


<h3>See Also</h3>

<p>Date/Time Derivation Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_trtdurd">derive_var_trtdurd</a>()</code>,
<code><a href="#topic+derive_vars_dt">derive_vars_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm">derive_vars_dtm</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_dt">derive_vars_dtm_to_dt</a>()</code>,
<code><a href="#topic+derive_vars_dtm_to_tm">derive_vars_dtm_to_tm</a>()</code>,
<code><a href="#topic+derive_vars_duration">derive_vars_duration</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)
library(dplyr, warn.conflicts = FALSE)

datain &lt;- tribble(
  ~TRTSDTM, ~ASTDTM, ~AENDT,
  "2014-01-17T23:59:59", "2014-01-18T13:09:O9", "2014-01-20"
) %&gt;%
  mutate(
    TRTSDTM = as_datetime(TRTSDTM),
    ASTDTM = as_datetime(ASTDTM),
    AENDT = ymd(AENDT)
  )

derive_vars_dy(
  datain,
  reference_date = TRTSDTM,
  source_vars = exprs(TRTSDTM, ASTDTM, AENDT)
)

# specifying name of new variables
datain &lt;- tribble(
  ~TRTSDT, ~DTHDT,
  "2014-01-17", "2014-02-01"
) %&gt;%
  mutate(
    TRTSDT = ymd(TRTSDT),
    DTHDT = ymd(DTHDT)
  )

derive_vars_dy(
  datain,
  reference_date = TRTSDT,
  source_vars = exprs(TRTSDT, DEATHDY = DTHDT)
)
</code></pre>

<hr>
<h2 id='derive_vars_extreme_event'>Add the Worst or Best Observation for Each By Group as New Variables</h2><span id='topic+derive_vars_extreme_event'></span>

<h3>Description</h3>

<p>Add the first available record from <code>events</code> for each by group as new
variables, all variables of the selected observation are kept. It can be used
for selecting the extreme observation from a series of user-defined events.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_extreme_event(
  dataset,
  by_vars,
  events,
  tmp_event_nr_var = NULL,
  order,
  mode,
  source_datasets = NULL,
  check_type = "warning",
  new_vars
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_extreme_event_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Default</em>: <code>NULL</code>
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_events">events</code></td>
<td>
<p>Conditions and new values defining events
</p>
<p>A list of <code>event()</code> or <code>event_joined()</code> objects is expected. Only
observations listed in the <code>events</code> are considered for deriving extreme
event. If multiple records meet the filter <code>condition</code>, take the first
record sorted by <code>order</code>. The data is grouped by <code>by_vars</code>, i.e., summary
functions like <code>all()</code> or <code>any()</code> can be used in <code>condition</code>.
</p>
<p>For <code>event_joined()</code> events the observations are selected by calling
<code>filter_joined()</code>. The <code>condition</code> field is passed to the <code>filter_join</code> argument.</p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_tmp_event_nr_var">tmp_event_nr_var</code></td>
<td>
<p>Temporary event number variable
</p>
<p>The specified variable is added to all source datasets and is set to the
number of the event before selecting the records of the event.
</p>
<p>It can be used in <code>order</code> to determine which record should be used if
records from more than one event are selected.
</p>
<p>The variable is not included in the output dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If a particular event from <code>events</code> has more than one observation, within
the event and by group, the records are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If a particular event from <code>events</code> has more than one observation,
<code>"first"</code>/<code>"last"</code> is used to select the first/last record of this type of
event sorting by <code>order</code>.
</p>
<p><em>Permitted Values:</em> <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_source_datasets">source_datasets</code></td>
<td>
<p>Source datasets
</p>
<p>A named list of datasets is expected. The <code>dataset_name</code> field of <code>event()</code>
and <code>event_joined()</code> refers to the dataset provided in the list.</p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Default:</em> <code>"warning"</code>
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="derive_vars_extreme_event_+3A_new_vars">new_vars</code></td>
<td>
<p>Variables to add
</p>
<p>The specified variables from the events are added to the output
dataset. Variables can be renamed by naming the element, i.e., <code style="white-space: pre;">&#8288;new_vars = exprs(&lt;new name&gt; = &lt;old name&gt;)&#8288;</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> For each event select the observations to consider:
</p>

<ol>
<li><p> If the event is of class <code>event</code>, the observations of the source dataset
are restricted by <code>condition</code> and then the first or last (<code>mode</code>)
observation per by group (<code>by_vars</code>) is selected.
</p>
<p>If the event is of class <code>event_joined</code>, <code>filter_joined()</code> is called to
select the observations.
</p>
</li>
<li><p> The variables specified by the <code>set_values_to</code> field of the event
are added to the selected observations.
</p>
</li>
<li><p> The variable specified for <code>tmp_event_nr_var</code> is added and set to
the number of the event.
</p>
</li></ol>

</li>
<li><p> All selected observations are bound together.
</p>
</li>
<li><p> For each group (with respect to the variables specified for the
<code>by_vars</code> parameter) the first or last observation (with respect to the
order specified for the <code>order</code> parameter and the mode specified for the
<code>mode</code> parameter) is selected.
</p>
</li>
<li><p> The variables specified by the <code>new_vars</code> parameter are added to
the selected observations.
</p>
</li>
<li><p> The variables are added to input dataset.
</p>
</li></ol>



<h3>Value</h3>

<p>The input dataset with the best or worst observation of each by group
added as new variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+event">event()</a></code>, <code><a href="#topic+event_joined">event_joined()</a></code>, <code><a href="#topic+derive_extreme_event">derive_extreme_event()</a></code>
</p>
<p>ADSL Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_age_years">derive_var_age_years</a>()</code>,
<code><a href="#topic+derive_vars_aage">derive_vars_aage</a>()</code>,
<code><a href="#topic+derive_vars_period">derive_vars_period</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
library(lubridate)

adsl &lt;- tribble(
  ~STUDYID, ~USUBJID, ~TRTEDT, ~DTHDT,
  "PILOT01", "01-1130", ymd("2014-08-16"), ymd("2014-09-13"),
  "PILOT01", "01-1133", ymd("2013-04-28"), ymd(""),
  "PILOT01", "01-1211", ymd("2013-01-12"), ymd(""),
  "PILOT01", "09-1081", ymd("2014-04-27"), ymd(""),
  "PILOT01", "09-1088", ymd("2014-10-09"), ymd("2014-11-01"),
)

lb &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~LBSEQ,             ~LBDTC,
  "PILOT01",    "LB", "01-1130",    219, "2014-06-07T13:20",
  "PILOT01",    "LB", "01-1130",    322, "2014-08-16T13:10",
  "PILOT01",    "LB", "01-1133",    268, "2013-04-18T15:30",
  "PILOT01",    "LB", "01-1133",    304, "2013-05-01T10:13",
  "PILOT01",    "LB", "01-1211",      8, "2012-10-30T14:26",
  "PILOT01",    "LB", "01-1211",    162, "2013-01-08T12:13",
  "PILOT01",    "LB", "09-1081",     47, "2014-02-01T10:55",
  "PILOT01",    "LB", "09-1081",    219, "2014-05-10T11:15",
  "PILOT01",    "LB", "09-1088",    283, "2014-09-27T12:13",
  "PILOT01",    "LB", "09-1088",    322, "2014-10-09T13:25"
) %&gt;%
  mutate(
    ADT = convert_dtc_to_dt(LBDTC)
  )

derive_vars_extreme_event(
  adsl,
  by_vars = exprs(STUDYID, USUBJID),
  events = list(
    event(
      dataset_name = "adsl",
      condition = !is.na(DTHDT),
      set_values_to = exprs(LSTALVDT = DTHDT, DTHFL = "Y")
    ),
    event(
      dataset_name = "lb",
      condition = !is.na(ADT),
      order = exprs(ADT),
      mode = "last",
      set_values_to = exprs(LSTALVDT = ADT, DTHFL = "N")
    ),
    event(
      dataset_name = "adsl",
      condition = !is.na(TRTEDT),
      order = exprs(TRTEDT),
      mode = "last",
      set_values_to = exprs(LSTALVDT = TRTEDT, DTHFL = "N")
    )
  ),
  source_datasets = list(adsl = adsl, lb = lb),
  tmp_event_nr_var = event_nr,
  order = exprs(LSTALVDT, event_nr),
  mode = "last",
  new_vars = exprs(LSTALVDT, DTHFL)
)

# Derive DTHCAUS from AE and DS domain data
adsl &lt;- tribble(
  ~STUDYID,  ~USUBJID,
  "STUDY01", "PAT01",
  "STUDY01", "PAT02",
  "STUDY01", "PAT03"
)
ae &lt;- tribble(
  ~STUDYID, ~USUBJID, ~AESEQ, ~AEDECOD, ~AEOUT, ~AEDTHDTC,
  "STUDY01", "PAT01", 12, "SUDDEN DEATH", "FATAL", "2021-04-04",
  "STUDY01", "PAT01", 13, "CARDIAC ARREST", "FATAL", "2021-04-03",
)

ds &lt;- tribble(
  ~STUDYID, ~USUBJID, ~DSSEQ, ~DSDECOD, ~DSTERM, ~DSSTDTC,
  "STUDY01", "PAT02", 1, "INFORMED CONSENT OBTAINED", "INFORMED CONSENT OBTAINED", "2021-04-03",
  "STUDY01", "PAT02", 2, "RANDOMIZATION", "RANDOMIZATION", "2021-04-11",
  "STUDY01", "PAT02", 3, "DEATH", "DEATH DUE TO PROGRESSION OF DISEASE", "2022-02-01",
  "STUDY01", "PAT03", 1, "DEATH", "POST STUDY REPORTING OF DEATH", "2022-03-03"
)

derive_vars_extreme_event(
  adsl,
  by_vars = exprs(STUDYID, USUBJID),
  events = list(
    event(
      dataset_name = "ae",
      condition = AEOUT == "FATAL",
      set_values_to = exprs(DTHCAUS = AEDECOD, DTHDT = convert_dtc_to_dt(AEDTHDTC)),
      order = exprs(DTHDT)
    ),
    event(
      dataset_name = "ds",
      condition = DSDECOD == "DEATH" &amp; grepl("DEATH DUE TO", DSTERM),
      set_values_to = exprs(DTHCAUS = DSTERM, DTHDT = convert_dtc_to_dt(DSSTDTC)),
      order = exprs(DTHDT)
    )
  ),
  source_datasets = list(ae = ae, ds = ds),
  tmp_event_nr_var = event_nr,
  order = exprs(DTHDT, event_nr),
  mode = "first",
  new_vars = exprs(DTHCAUS, DTHDT)
)
</code></pre>

<hr>
<h2 id='derive_vars_joined'>Add Variables from an Additional Dataset Based on Conditions from Both
Datasets</h2><span id='topic+derive_vars_joined'></span>

<h3>Description</h3>

<p>The function adds variables from an additional dataset to the input dataset.
The selection of the observations from the additional dataset can depend on
variables from both datasets. For example, add the lowest value (nadir)
before the current observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_joined(
  dataset,
  dataset_add,
  by_vars = NULL,
  order = NULL,
  new_vars = NULL,
  tmp_obs_nr_var = NULL,
  join_vars = NULL,
  join_type,
  filter_add = NULL,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  filter_join = NULL,
  mode = NULL,
  exist_flag = NULL,
  true_value = "Y",
  false_value = NA_character_,
  missing_values = NULL,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_joined_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code>, the <code>new_vars</code>, the <code>join_vars</code>,
and the <code>order</code> argument are expected.</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The two datasets are joined by the specified variables.
</p>
<p>Variables can be renamed by naming the element, i.e.
<code style="white-space: pre;">&#8288;by_vars = exprs(&lt;name in input dataset&gt; = &lt;name in additional dataset&gt;)&#8288;</code>, similar to the <code>dplyr</code> joins.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If the argument is set to a non-null value, for each observation of the
input dataset the first or last observation from the joined dataset is
selected with respect to the specified order. The specified variables are
expected in the additional dataset (<code>dataset_add</code>). If a variable is
available in both <code>dataset</code> and <code>dataset_add</code>, the one from <code>dataset_add</code>
is used for the sorting.
</p>
<p>If an expression is named, e.g., <code>exprs(EXSTDT = convert_dtc_to_dt(EXSTDTC), EXSEQ)</code>, a corresponding variable (<code>EXSTDT</code>) is
added to the additional dataset and can be used in the filter conditions
(<code>filter_add</code>, <code>filter_join</code>) and for <code>join_vars</code> and <code>new_vars</code>. The
variable is not included in the output dataset.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_new_vars">new_vars</code></td>
<td>
<p>Variables to add
</p>
<p>The specified variables from the additional dataset are added to the output
dataset. Variables can be renamed by naming the element, i.e., <code style="white-space: pre;">&#8288;new_vars = exprs(&lt;new name&gt; = &lt;old name&gt;)&#8288;</code>.
</p>
<p>For example <code>new_vars = exprs(var1, var2)</code> adds variables <code>var1</code> and <code>var2</code>
from <code>dataset_add</code> to the input dataset.
</p>
<p>And <code>new_vars = exprs(var1, new_var2 = old_var2)</code> takes <code>var1</code> and
<code>old_var2</code> from <code>dataset_add</code> and adds them to the input dataset renaming
<code>old_var2</code> to <code>new_var2</code>.
</p>
<p>Values of the added variables can be modified by specifying an expression.
For example, <code>new_vars = LASTRSP = exprs(str_to_upper(AVALC))</code> adds the
variable <code>LASTRSP</code> to the dataset and sets it to the upper case value of
<code>AVALC</code>.
</p>
<p>If the argument is not specified or set to <code>NULL</code>, all variables from the
additional dataset (<code>dataset_add</code>) are added.
</p>
<p><em>Permitted Values</em>: list of variables or named expressions created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_tmp_obs_nr_var">tmp_obs_nr_var</code></td>
<td>
<p>Temporary observation number
</p>
<p>The specified variable is added to the input dataset (<code>dataset</code>) and the
additional dataset (<code>dataset_add</code>). It is set to the observation number
with respect to <code>order</code>. For each by group (<code>by_vars</code>) the observation
number starts with <code>1</code>. The variable can be used in the conditions
(<code>filter_join</code>, <code>first_cond_upper</code>, <code>first_cond_lower</code>). It can also be
used to select consecutive observations or the last observation.
</p>
<p>The variable is not included in the output dataset. To include it specify
it for <code>new_vars</code>.</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_join_vars">join_vars</code></td>
<td>
<p>Variables to use from additional dataset
</p>
<p>Any extra variables required from the additional dataset for <code>filter_join</code>
should be specified for this argument. Variables specified for <code>new_vars</code>
do not need to be repeated for <code>join_vars</code>. If a specified variable exists
in both the input dataset and the additional dataset, the suffix &quot;.join&quot; is
added to the variable from the additional dataset.
</p>
<p>If an expression is named, e.g., <code>exprs(EXTDT = convert_dtc_to_dt(EXSTDTC))</code>, a corresponding variable is added to the
additional dataset and can be used in the filter conditions (<code>filter_add</code>,
<code>filter_join</code>) and for <code>new_vars</code>. The variable is not included in the
output dataset.
</p>
<p>The variables are not included in the output dataset.
</p>
<p><em>Permitted Values</em>: list of variables or named expressions created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_join_type">join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code>
is specified all observations after the original observations are kept.
</p>
<p>For example for confirmed response or BOR in the oncology setting or
confirmed deterioration in questionnaires the confirmatory assessment must
be after the assessment. Thus <code>join_type = "after"</code> could be used.
</p>
<p>Whereas, sometimes you might allow for confirmatory observations to occur
prior to the observation. For example, to identify AEs occurring on or
after seven days before a COVID AE. Thus <code>join_type = "all"</code> could be used.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations from <code>dataset_add</code> fulfilling the specified condition are
joined to the input dataset. If the argument is not specified, all
observations are joined.
</p>
<p>Variables created by <code>order</code> or <code>new_vars</code> arguments can be used in the
condition.
</p>
<p>The condition can include summary functions like <code>all()</code> or <code>any()</code>. The
additional dataset is grouped by the by variables (<code>by_vars</code>).
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_first_cond_lower">first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered.
</p>
<p>This argument should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation. For an example see the last example below.</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_first_cond_upper">first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered.
</p>
<p>This argument should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment. For an example see the last example below.</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_filter_join">filter_join</code></td>
<td>
<p>Filter for the joined dataset
</p>
<p>The specified condition is applied to the joined dataset. Therefore
variables from both datasets <code>dataset</code> and <code>dataset_add</code> can be used.
</p>
<p>Variables created by <code>order</code> or <code>new_vars</code> arguments can be used in the
condition.
</p>
<p>The condition can include summary functions like <code>all()</code> or <code>any()</code>. The
joined dataset is grouped by the original observations.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_mode">mode</code></td>
<td>
<p>Selection mode
</p>
<p>Determines if the first or last observation is selected. If the <code>order</code>
argument is specified, <code>mode</code> must be non-null.
</p>
<p>If the <code>order</code> argument is not specified, the <code>mode</code> argument is ignored.
</p>
<p><em>Permitted Values</em>: <code>"first"</code>, <code>"last"</code>, <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_exist_flag">exist_flag</code></td>
<td>
<p>Exist flag
</p>
<p>If the argument is specified (e.g., <code>exist_flag = FLAG</code>), the specified
variable (e.g., <code>FLAG</code>) is added to the input dataset. This variable will
be the value provided in <code>true_value</code> for all selected records from <code>dataset_add</code>
which are merged into the input dataset, and the value provided in <code>false_value</code> otherwise.
</p>
<p><em>Permitted Values</em>: Variable name</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>The value for the specified variable <code>exist_flag</code>, applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>The value for the specified variable <code>exist_flag</code>, NOT applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_missing_values">missing_values</code></td>
<td>
<p>Values for non-matching observations
</p>
<p>For observations of the input dataset (<code>dataset</code>) which do not have a
matching observation in the additional dataset (<code>dataset_add</code>) the values
of the specified variables are set to the specified value. Only variables
specified for <code>new_vars</code> can be specified for <code>missing_values</code>.
</p>
<p><em>Permitted Values</em>: named list of expressions, e.g.,
<code>exprs(BASEC = "MISSING", BASE = -1)</code></p>
</td></tr>
<tr><td><code id="derive_vars_joined_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the (restricted) joined dataset are not unique with
respect to the by variables and the order.
</p>
<p>This argument is ignored if <code>order</code> is not specified. In this case an error
is issued independent of <code>check_type</code> if the restricted joined dataset
contains more than one observation for any of the observations of the input
dataset.
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The variables specified by <code>order</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The variables specified by <code>join_vars</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted to
those matching the <code>filter_add</code> condition.
</p>
</li>
<li><p> The input dataset and the (restricted) additional dataset are left joined
by the grouping variables (<code>by_vars</code>). If no grouping variables are
specified, a full join is performed.
</p>
</li>
<li><p> If <code>first_cond_lower</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations from the first
observation where <code>first_cond_lower</code> is fulfilled (the observation fulfilling
the condition is included) up to the observation of the input dataset. If for
an observation of the input dataset the condition is not fulfilled, the
observation is removed.
</p>
<p>If <code>first_cond_upper</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations up to the first
observation where <code>first_cond_upper</code> is fulfilled (the observation
fulfilling the condition is included). If for an observation of the input
dataset the condition is not fulfilled, the observation is removed.
</p>
<p>For an example see the last example in the &quot;Examples&quot; section.
</p>
</li>
<li><p> The joined dataset is restricted by the <code>filter_join</code> condition.
</p>
</li>
<li><p> If <code>order</code> is specified, for each observation of the input dataset the
first or last observation (depending on <code>mode</code>) is selected.
</p>
</li>
<li><p> The variables specified for <code>new_vars</code> are created (if requested) and
merged to the input dataset. I.e., the output dataset contains all
observations from the input dataset. For observations without a matching
observation in the joined dataset the new variables are set as specified by
<code>missing_values</code> (or to <code>NA</code> for variables not in <code>missing_values</code>).
Observations in the additional dataset which have no matching observation in
the input dataset are ignored.
</p>
</li></ol>



<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset and additionally the variables specified for <code>new_vars</code> from
the additional dataset (<code>dataset_add</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag()</a></code>, <code><a href="#topic+filter_joined">filter_joined()</a></code>
</p>
<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(lubridate)
library(dplyr, warn.conflicts = FALSE)
library(tidyr)

# Add AVISIT (based on time windows), AWLO, and AWHI
adbds &lt;- tribble(
  ~USUBJID, ~ADY,
  "1",       -33,
  "1",        -2,
  "1",         3,
  "1",        24,
  "2",        NA,
)

windows &lt;- tribble(
  ~AVISIT,    ~AWLO, ~AWHI,
  "BASELINE",   -30,     1,
  "WEEK 1",       2,     7,
  "WEEK 2",       8,    15,
  "WEEK 3",      16,    22,
  "WEEK 4",      23,    30
)

derive_vars_joined(
  adbds,
  dataset_add = windows,
  join_type = "all",
  filter_join = AWLO &lt;= ADY &amp; ADY &lt;= AWHI
)

# derive the nadir after baseline and before the current observation
adbds &lt;- tribble(
  ~USUBJID, ~ADY, ~AVAL,
  "1",        -7,    10,
  "1",         1,    12,
  "1",         8,    11,
  "1",        15,     9,
  "1",        20,    14,
  "1",        24,    12,
  "2",        13,     8
)

derive_vars_joined(
  adbds,
  dataset_add = adbds,
  by_vars = exprs(USUBJID),
  order = exprs(AVAL),
  new_vars = exprs(NADIR = AVAL),
  join_vars = exprs(ADY),
  join_type = "all",
  filter_add = ADY &gt; 0,
  filter_join = ADY.join &lt; ADY,
  mode = "first",
  check_type = "none"
)

# add highest hemoglobin value within two weeks before AE,
# take earliest if more than one
adae &lt;- tribble(
  ~USUBJID, ~ASTDY,
  "1",           3,
  "1",          22,
  "2",           2
)

adlb &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~ADY, ~AVAL,
  "1",      "HGB",       1,   8.5,
  "1",      "HGB",       3,   7.9,
  "1",      "HGB",       5,   8.9,
  "1",      "HGB",       8,   8.0,
  "1",      "HGB",       9,   8.0,
  "1",      "HGB",      16,   7.4,
  "1",      "HGB",      24,   8.1,
  "1",      "ALB",       1,    42,
)

derive_vars_joined(
  adae,
  dataset_add = adlb,
  by_vars = exprs(USUBJID),
  order = exprs(AVAL, desc(ADY)),
  new_vars = exprs(HGB_MAX = AVAL, HGB_DY = ADY),
  join_type = "all",
  filter_add = PARAMCD == "HGB",
  filter_join = ASTDY - 14 &lt;= ADY &amp; ADY &lt;= ASTDY,
  mode = "last"
)

# Add APERIOD, APERIODC based on ADSL
adsl &lt;- tribble(
  ~USUBJID, ~AP01SDT,     ~AP01EDT,     ~AP02SDT,     ~AP02EDT,
  "1",      "2021-01-04", "2021-02-06", "2021-02-07", "2021-03-07",
  "2",      "2021-02-02", "2021-03-02", "2021-03-03", "2021-04-01"
) %&gt;%
  mutate(across(ends_with("DT"), ymd)) %&gt;%
  mutate(STUDYID = "xyz")

period_ref &lt;- create_period_dataset(
  adsl,
  new_vars = exprs(APERSDT = APxxSDT, APEREDT = APxxEDT)
)

period_ref

adae &lt;- tribble(
  ~USUBJID, ~ASTDT,
  "1",      "2021-01-01",
  "1",      "2021-01-05",
  "1",      "2021-02-05",
  "1",      "2021-03-05",
  "1",      "2021-04-05",
  "2",      "2021-02-15",
) %&gt;%
  mutate(
    ASTDT = ymd(ASTDT),
    STUDYID = "xyz"
  )

derive_vars_joined(
  adae,
  dataset_add = period_ref,
  by_vars = exprs(STUDYID, USUBJID),
  join_vars = exprs(APERSDT, APEREDT),
  join_type = "all",
  filter_join = APERSDT &lt;= ASTDT &amp; ASTDT &lt;= APEREDT
)

# Add day since last dose (LDRELD)
adae &lt;- tribble(
  ~USUBJID, ~ASTDT,       ~AESEQ,
  "1",      "2020-02-02",      1,
  "1",      "2020-02-04",      2
) %&gt;%
  mutate(ASTDT = ymd(ASTDT))

ex &lt;- tribble(
  ~USUBJID, ~EXSDTC,
  "1",      "2020-01-10",
  "1",      "2020-01",
  "1",      "2020-01-20",
  "1",      "2020-02-03"
)

## Please note that EXSDT is created via the order argument and then used
## for new_vars, filter_add, and filter_join
derive_vars_joined(
  adae,
  dataset_add = ex,
  by_vars = exprs(USUBJID),
  order = exprs(EXSDT = convert_dtc_to_dt(EXSDTC)),
  join_type = "all",
  new_vars = exprs(LDRELD = compute_duration(
    start_date = EXSDT, end_date = ASTDT
  )),
  filter_add = !is.na(EXSDT),
  filter_join = EXSDT &lt;= ASTDT,
  mode = "last"
)

# first_cond_lower and first_cond_upper argument
myd &lt;- tribble(
  ~subj, ~day, ~val,
  "1",      1, "++",
  "1",      2, "-",
  "1",      3, "0",
  "1",      4, "+",
  "1",      5, "++",
  "1",      6, "-",
  "2",      1, "-",
  "2",      2, "++",
  "2",      3, "+",
  "2",      4, "0",
  "2",      5, "-",
  "2",      6, "++"
)

# derive last "++" day before "0" where all results in between are "+" or "++"
derive_vars_joined(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  mode = "first",
  new_vars = exprs(prev_plus_day = day),
  join_vars = exprs(val),
  join_type = "before",
  first_cond_lower = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)

# derive first "++" day after "0" where all results in between are "+" or "++"
derive_vars_joined(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  mode = "last",
  new_vars = exprs(next_plus_day = day),
  join_vars = exprs(val),
  join_type = "after",
  first_cond_upper = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)
</code></pre>

<hr>
<h2 id='derive_vars_merged'>Add New Variable(s) to the Input Dataset Based on Variables from Another
Dataset</h2><span id='topic+derive_vars_merged'></span>

<h3>Description</h3>

<p>Add new variable(s) to the input dataset based on variables from another
dataset. The observations to merge can be selected by a condition
(<code>filter_add</code> argument) and/or selecting the first or last observation for
each by group (<code>order</code> and <code>mode</code> argument).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_merged(
  dataset,
  dataset_add,
  by_vars,
  order = NULL,
  new_vars = NULL,
  filter_add = NULL,
  mode = NULL,
  match_flag,
  exist_flag = NULL,
  true_value = "Y",
  false_value = NA_character_,
  missing_values = NULL,
  check_type = "warning",
  duplicate_msg = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_merged_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code>, the <code>new_vars</code>, and the <code>order</code>
argument are expected.</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The input dataset and the selected observations from the additional dataset
are merged by the specified variables.
</p>
<p>Variables can be renamed by naming the element, i.e.
<code style="white-space: pre;">&#8288;by_vars = exprs(&lt;name in input dataset&gt; = &lt;name in additional dataset&gt;)&#8288;</code>, similar to the <code>dplyr</code> joins.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If the argument is set to a non-null value, for each by group the first or
last observation from the additional dataset is selected with respect to the
specified order.
</p>
<p>Variables defined by the <code>new_vars</code> argument can be used in the sort order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_new_vars">new_vars</code></td>
<td>
<p>Variables to add
</p>
<p>The specified variables from the additional dataset are added to the output
dataset. Variables can be renamed by naming the element, i.e., <code style="white-space: pre;">&#8288;new_vars = exprs(&lt;new name&gt; = &lt;old name&gt;)&#8288;</code>.
</p>
<p>For example <code>new_vars = exprs(var1, var2)</code> adds variables <code>var1</code> and <code>var2</code>
from <code>dataset_add</code> to the input dataset.
</p>
<p>And <code>new_vars = exprs(var1, new_var2 = old_var2)</code> takes <code>var1</code> and
<code>old_var2</code> from <code>dataset_add</code> and adds them to the input dataset renaming
<code>old_var2</code> to <code>new_var2</code>.
</p>
<p>Values of the added variables can be modified by specifying an expression.
For example, <code>new_vars = LASTRSP = exprs(str_to_upper(AVALC))</code> adds the
variable <code>LASTRSP</code> to the dataset and sets it to the upper case value of
<code>AVALC</code>.
</p>
<p>If the argument is not specified or set to <code>NULL</code>, all variables from the
additional dataset (<code>dataset_add</code>) are added.
</p>
<p><em>Permitted Values</em>: list of variables or named expressions created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations fulfilling the specified condition are taken into account
for merging. If the argument is not specified, all observations are
considered.
</p>
<p>Variables defined by the <code>new_vars</code> argument can be used in the filter
condition.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_mode">mode</code></td>
<td>
<p>Selection mode
</p>
<p>Determines if the first or last observation is selected. If the <code>order</code>
argument is specified, <code>mode</code> must be non-null.
</p>
<p>If the <code>order</code> argument is not specified, the <code>mode</code> argument is ignored.
</p>
<p><em>Permitted Values</em>: <code>"first"</code>, <code>"last"</code>, <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_match_flag">match_flag</code></td>
<td>
<p>Match flag
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>exist_flag</code> instead.
</p>
<p>If the argument is specified (e.g., <code>match_flag = FLAG</code>), the specified
variable (e.g., <code>FLAG</code>) is added to the input dataset. This variable will
be <code>TRUE</code> for all selected records from <code>dataset_add</code> which are merged into
the input dataset, and <code>NA</code> otherwise.
</p>
<p><em>Permitted Values</em>: Variable name</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_exist_flag">exist_flag</code></td>
<td>
<p>Exist flag
</p>
<p>If the argument is specified (e.g., <code>exist_flag = FLAG</code>), the specified
variable (e.g., <code>FLAG</code>) is added to the input dataset. This variable will
be the value provided in <code>true_value</code> for all selected records from <code>dataset_add</code>
which are merged into the input dataset, and the value provided in <code>false_value</code> otherwise.
</p>
<p><em>Permitted Values</em>: Variable name</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_true_value">true_value</code></td>
<td>
<p>True value
</p>
<p>The value for the specified variable <code>exist_flag</code>, applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_false_value">false_value</code></td>
<td>
<p>False value
</p>
<p>The value for the specified variable <code>exist_flag</code>, NOT applicable to
the first or last observation (depending on the mode) of each by group.
</p>
<p>Permitted Values: An atomic scalar</p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_missing_values">missing_values</code></td>
<td>
<p>Values for non-matching observations
</p>
<p>For observations of the input dataset (<code>dataset</code>) which do not have a
matching observation in the additional dataset (<code>dataset_add</code>) the values
of the specified variables are set to the specified value. Only variables
specified for <code>new_vars</code> can be specified for <code>missing_values</code>.
</p>
<p><em>Permitted Values</em>: named list of expressions, e.g.,
<code>exprs(BASEC = "MISSING", BASE = -1)</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the (restricted) additional dataset are not unique
with respect to the by variables and the order.
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_+3A_duplicate_msg">duplicate_msg</code></td>
<td>
<p>Message of unique check
</p>
<p>If the uniqueness check fails, the specified message is displayed.
</p>
<p><em>Default</em>:
</p>
<div class="sourceCode r"><pre>paste("Dataset `dataset_add` contains duplicate records with respect to",
      enumerate(vars2chr(by_vars)))
</pre></div></td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The new variables (<code>new_vars</code>) are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted
to those matching the <code>filter_add</code> condition.
</p>
</li>
<li><p> If <code>order</code> is specified, for each by group the first or last observation
(depending on <code>mode</code>) is selected.
</p>
</li>
<li><p> The variables specified for <code>new_vars</code> are merged to the input dataset
using <code>left_join()</code>. I.e., the output dataset contains all observations
from the input dataset. For observations without a matching observation in
the additional dataset the new variables are set as specified by
<code>missing_values</code> (or to <code>NA</code> for variables not in <code>missing_values</code>).
Observations in the additional dataset which have no matching observation
in the input dataset are ignored.
</p>
</li></ol>



<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset and additionally the variables specified for <code>new_vars</code> from
the additional dataset (<code>dataset_add</code>).
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
vs &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~VSTESTCD,      ~VISIT, ~VSSTRESN, ~VSSTRESU,       ~VSDTC,
  "PILOT01",    "VS", "01-1302",  "HEIGHT", "SCREENING",     177.8,      "cm", "2013-08-20",
  "PILOT01",    "VS", "01-1302",  "WEIGHT", "SCREENING",     81.19,      "kg", "2013-08-20",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",  "BASELINE",      82.1,      "kg", "2013-08-29",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",    "WEEK 2",     81.19,      "kg", "2013-09-15",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",    "WEEK 4",     82.56,      "kg", "2013-09-24",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",    "WEEK 6",     80.74,      "kg", "2013-10-08",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",    "WEEK 8",      82.1,      "kg", "2013-10-22",
  "PILOT01",    "VS", "01-1302",  "WEIGHT",   "WEEK 12",      82.1,      "kg", "2013-11-05",
  "PILOT01",    "VS", "17-1344",  "HEIGHT", "SCREENING",     163.5,      "cm", "2014-01-01",
  "PILOT01",    "VS", "17-1344",  "WEIGHT", "SCREENING",     58.06,      "kg", "2014-01-01",
  "PILOT01",    "VS", "17-1344",  "WEIGHT",  "BASELINE",     58.06,      "kg", "2014-01-11",
  "PILOT01",    "VS", "17-1344",  "WEIGHT",    "WEEK 2",     58.97,      "kg", "2014-01-24",
  "PILOT01",    "VS", "17-1344",  "WEIGHT",    "WEEK 4",     57.97,      "kg", "2014-02-07",
  "PILOT01",    "VS", "17-1344",  "WEIGHT",    "WEEK 6",     58.97,      "kg", "2014-02-19",
  "PILOT01",    "VS", "17-1344",  "WEIGHT",    "WEEK 8",     57.79,      "kg", "2014-03-14"
)

dm &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01",    "DM", "01-1302",   61, "YEARS",
  "PILOT01",    "DM", "17-1344",   64, "YEARS"
)


# Merging all dm variables to vs
derive_vars_merged(
  vs,
  dataset_add = select(dm, -DOMAIN),
  by_vars = exprs(STUDYID, USUBJID)
) %&gt;%
  select(STUDYID, USUBJID, VSTESTCD, VISIT, VSSTRESN, AGE, AGEU)


# Merge last weight to adsl
adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01", "01-1302",   61, "YEARS",
  "PILOT01", "17-1344",   64, "YEARS"
)


derive_vars_merged(
  adsl,
  dataset_add = vs,
  by_vars = exprs(STUDYID, USUBJID),
  order = exprs(convert_dtc_to_dtm(VSDTC)),
  mode = "last",
  new_vars = exprs(LASTWGT = VSSTRESN, LASTWGTU = VSSTRESU),
  filter_add = VSTESTCD == "WEIGHT",
  exist_flag = vsdatafl
) %&gt;%
  select(STUDYID, USUBJID, AGE, AGEU, LASTWGT, LASTWGTU, vsdatafl)


# Derive treatment start datetime (TRTSDTM)
ex &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~EXSTDY, ~EXENDY,     ~EXSTDTC,     ~EXENDTC,
  "PILOT01",    "EX", "01-1302",       1,      18, "2013-08-29", "2013-09-15",
  "PILOT01",    "EX", "01-1302",      19,      69, "2013-09-16", "2013-11-05",
  "PILOT01",    "EX", "17-1344",       1,      14, "2014-01-11", "2014-01-24",
  "PILOT01",    "EX", "17-1344",      15,      63, "2014-01-25", "2014-03-14"
)
## Impute exposure start date to first date/time
ex_ext &lt;- derive_vars_dtm(
  ex,
  dtc = EXSTDTC,
  new_vars_prefix = "EXST",
  highest_imputation = "M",
)
## Add first exposure datetime and imputation flags to adsl
derive_vars_merged(
  select(dm, STUDYID, USUBJID),
  dataset_add = ex_ext,
  by_vars = exprs(STUDYID, USUBJID),
  new_vars = exprs(TRTSDTM = EXSTDTM, TRTSDTF = EXSTDTF, TRTSTMF = EXSTTMF),
  order = exprs(EXSTDTM),
  mode = "first"
)

# Derive treatment end datetime (TRTEDTM)
## Impute exposure end datetime to last time, no date imputation
ex_ext &lt;- derive_vars_dtm(
  ex,
  dtc = EXENDTC,
  new_vars_prefix = "EXEN",
  time_imputation = "last",
)
## Add last exposure datetime and imputation flag to adsl
derive_vars_merged(
  select(adsl, STUDYID, USUBJID),
  dataset_add = ex_ext,
  filter_add = !is.na(EXENDTM),
  by_vars = exprs(STUDYID, USUBJID),
  new_vars = exprs(TRTEDTM = EXENDTM, TRTETMF = EXENTMF),
  order = exprs(EXENDTM),
  mode = "last"
)
# Modify merged values and set value for non matching observations
adsl &lt;- tribble(
  ~USUBJID, ~SEX, ~COUNTRY,
  "ST42-1", "F",  "AUT",
  "ST42-2", "M",  "MWI",
  "ST42-3", "M",  "NOR",
  "ST42-4", "F",  "UGA"
)

advs &lt;- tribble(
  ~USUBJID, ~PARAMCD, ~AVISIT,    ~AVISITN, ~AVAL,
  "ST42-1", "WEIGHT", "BASELINE",        0,    66,
  "ST42-1", "WEIGHT", "WEEK 2",          1,    68,
  "ST42-2", "WEIGHT", "BASELINE",        0,    88,
  "ST42-3", "WEIGHT", "WEEK 2",          1,    55,
  "ST42-3", "WEIGHT", "WEEK 4",          2,    50
)

derive_vars_merged(
  adsl,
  dataset_add = advs,
  by_vars = exprs(USUBJID),
  new_vars = exprs(
    LSTVSCAT = if_else(AVISIT == "BASELINE", "BASELINE", "POST-BASELINE")
  ),
  order = exprs(AVISITN),
  mode = "last",
  missing_values = exprs(LSTVSCAT = "MISSING")
)
</code></pre>

<hr>
<h2 id='derive_vars_merged_lookup'>Merge Lookup Table with Source Dataset</h2><span id='topic+derive_vars_merged_lookup'></span>

<h3>Description</h3>

<p>Merge user-defined lookup table with the input dataset. Optionally print a
list of records from the input dataset that do not have corresponding
mapping from the lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_merged_lookup(
  dataset,
  dataset_add,
  by_vars,
  order = NULL,
  new_vars = NULL,
  mode = NULL,
  filter_add = NULL,
  check_type = "warning",
  duplicate_msg = NULL,
  print_not_mapped = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_merged_lookup_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Lookup table
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected.</p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The input dataset and the selected observations from the additional dataset
are merged by the specified variables.
</p>
<p>Variables can be renamed by naming the element, i.e.
<code style="white-space: pre;">&#8288;by_vars = exprs(&lt;name in input dataset&gt; = &lt;name in additional dataset&gt;)&#8288;</code>, similar to the <code>dplyr</code> joins.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If the argument is set to a non-null value, for each by group the first or
last observation from the additional dataset is selected with respect to the
specified order.
</p>
<p>Variables defined by the <code>new_vars</code> argument can be used in the sort order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_new_vars">new_vars</code></td>
<td>
<p>Variables to add
</p>
<p>The specified variables from the additional dataset are added to the output
dataset. Variables can be renamed by naming the element, i.e., <code style="white-space: pre;">&#8288;new_vars = exprs(&lt;new name&gt; = &lt;old name&gt;)&#8288;</code>.
</p>
<p>For example <code>new_vars = exprs(var1, var2)</code> adds variables <code>var1</code> and <code>var2</code>
from <code>dataset_add</code> to the input dataset.
</p>
<p>And <code>new_vars = exprs(var1, new_var2 = old_var2)</code> takes <code>var1</code> and
<code>old_var2</code> from <code>dataset_add</code> and adds them to the input dataset renaming
<code>old_var2</code> to <code>new_var2</code>.
</p>
<p>Values of the added variables can be modified by specifying an expression.
For example, <code>new_vars = LASTRSP = exprs(str_to_upper(AVALC))</code> adds the
variable <code>LASTRSP</code> to the dataset and sets it to the upper case value of
<code>AVALC</code>.
</p>
<p>If the argument is not specified or set to <code>NULL</code>, all variables from the
additional dataset (<code>dataset_add</code>) are added.
</p>
<p><em>Permitted Values</em>: list of variables or named expressions created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_mode">mode</code></td>
<td>
<p>Selection mode
</p>
<p>Determines if the first or last observation is selected. If the <code>order</code>
argument is specified, <code>mode</code> must be non-null.
</p>
<p>If the <code>order</code> argument is not specified, the <code>mode</code> argument is ignored.
</p>
<p><em>Permitted Values</em>: <code>"first"</code>, <code>"last"</code>, <code>NULL</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations fulfilling the specified condition are taken into account
for merging. If the argument is not specified, all observations are
considered.
</p>
<p>Variables defined by the <code>new_vars</code> argument can be used in the filter
condition.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the (restricted) additional dataset are not unique
with respect to the by variables and the order.
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_duplicate_msg">duplicate_msg</code></td>
<td>
<p>Message of unique check
</p>
<p>If the uniqueness check fails, the specified message is displayed.
</p>
<p><em>Default</em>:
</p>
<div class="sourceCode r"><pre>paste("Dataset `dataset_add` contains duplicate records with respect to",
      enumerate(vars2chr(by_vars)))
</pre></div></td></tr>
<tr><td><code id="derive_vars_merged_lookup_+3A_print_not_mapped">print_not_mapped</code></td>
<td>
<p>Print a list of unique <code>by_vars</code> values that do not
have corresponding records from the lookup table?
</p>
<p><em>Default</em>: <code>TRUE</code>
</p>
<p><em>Permitted Values</em>: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output dataset contains all observations and variables of the
input dataset, and add the variables specified in <code>new_vars</code> from the lookup
table specified in <code>dataset_add</code>. Optionally prints a list of unique
<code>by_vars</code> values that do not have corresponding records
from the lookup table (by specifying <code>print_not_mapped = TRUE</code>).
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_transposed">derive_vars_transposed</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
vs &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,        ~VISIT, ~VSTESTCD,       ~VSTEST,
  "PILOT01",    "VS", "01-1028",   "SCREENING",  "HEIGHT",      "Height",
  "PILOT01",    "VS", "01-1028",   "SCREENING",    "TEMP", "Temperature",
  "PILOT01",    "VS", "01-1028",    "BASELINE",    "TEMP", "Temperature",
  "PILOT01",    "VS", "01-1028",      "WEEK 4",    "TEMP", "Temperature",
  "PILOT01",    "VS", "01-1028", "SCREENING 1",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "01-1028",    "BASELINE",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "01-1028",      "WEEK 4",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "04-1325",   "SCREENING",  "HEIGHT",      "Height",
  "PILOT01",    "VS", "04-1325",   "SCREENING",    "TEMP", "Temperature",
  "PILOT01",    "VS", "04-1325",    "BASELINE",    "TEMP", "Temperature",
  "PILOT01",    "VS", "04-1325",      "WEEK 4",    "TEMP", "Temperature",
  "PILOT01",    "VS", "04-1325", "SCREENING 1",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "04-1325",    "BASELINE",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "04-1325",      "WEEK 4",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "10-1027",   "SCREENING",  "HEIGHT",      "Height",
  "PILOT01",    "VS", "10-1027",   "SCREENING",    "TEMP", "Temperature",
  "PILOT01",    "VS", "10-1027",    "BASELINE",    "TEMP", "Temperature",
  "PILOT01",    "VS", "10-1027",      "WEEK 4",    "TEMP", "Temperature",
  "PILOT01",    "VS", "10-1027", "SCREENING 1",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "10-1027",    "BASELINE",  "WEIGHT",      "Weight",
  "PILOT01",    "VS", "10-1027",      "WEEK 4",  "WEIGHT",      "Weight"
)

param_lookup &lt;- tribble(
  ~VSTESTCD,                 ~VSTEST, ~PARAMCD,                       ~PARAM,
  "SYSBP", "Systolic Blood Pressure",  "SYSBP", "Syst Blood Pressure (mmHg)",
  "WEIGHT",                 "Weight", "WEIGHT",                "Weight (kg)",
  "HEIGHT",                 "Height", "HEIGHT",                "Height (cm)",
  "TEMP",              "Temperature",   "TEMP",            "Temperature (C)",
  "MAP",    "Mean Arterial Pressure",    "MAP",   "Mean Art Pressure (mmHg)",
  "BMI",           "Body Mass Index",    "BMI",    "Body Mass Index(kg/m^2)",
  "BSA",         "Body Surface Area",    "BSA",     "Body Surface Area(m^2)"
)

derive_vars_merged_lookup(
  dataset = vs,
  dataset_add = param_lookup,
  by_vars = exprs(VSTESTCD),
  new_vars = exprs(PARAMCD, PARAM),
  print_not_mapped = TRUE
)
</code></pre>

<hr>
<h2 id='derive_vars_period'>Add Subperiod, Period, or Phase Variables to ADSL</h2><span id='topic+derive_vars_period'></span>

<h3>Description</h3>

<p>The function adds subperiod, period, or phase variables like <code>P01S1SDT</code>,
<code>P01S2SDT</code>, <code>AP01SDTM</code>, <code>AP02SDTM</code>, <code>TRT01A</code>, <code>TRT02A</code>, <code>PH1SDT</code>, <code>PH2SDT</code>,
... to the input dataset. The values of the variables are defined by a period
reference dataset which has one observations per patient and subperiod,
period, or phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_period(
  dataset,
  dataset_ref,
  new_vars,
  subject_keys = get_admiral_option("subject_keys")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_period_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>subject_keys</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_period_+3A_dataset_ref">dataset_ref</code></td>
<td>
<p>Period reference dataset
</p>
<p>The variables specified by <code>new_vars</code> and <code>subject_keys</code> are expected.
</p>
<p>If subperiod variables are requested, <code>APERIOD</code> and <code>ASPER</code> are expected.
If period variables are requested. <code>APERIOD</code> is expected. If phase
variables are requested, <code>APHASEN</code> is expected.</p>
</td></tr>
<tr><td><code id="derive_vars_period_+3A_new_vars">new_vars</code></td>
<td>
<p>New variables
</p>
<p>A named list of variables like <code>exprs(PHwSDT = PHSDT, PHwEDT = PHEDT, APHASEw = APHASE)</code> is expected. The left hand side of the elements defines
a set of variables (in CDISC notation) to be added to the output dataset.
The right hand side defines the source variable from the period reference
dataset.
</p>
<p>If the lower case letter &quot;w&quot;  is used it refers to a phase variable, if the
lower case letters &quot;xx&quot; are used it refers to a period variable, and if
both &quot;xx&quot; and &quot;w&quot; are used it refers to a subperiod variable.
</p>
<p>Only one type must be used, e.g., all left hand side values must refer to
period variables. It is not allowed to mix for example period and subperiod
variables. If period <em>and</em> subperiod variables are required, separate calls
must be used.</p>
</td></tr>
<tr><td><code id="derive_vars_period_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject
</p>
<p>A list of expressions where the expressions are symbols as returned by
<code>exprs()</code> is expected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each subperiod/period/phase in the period reference dataset and
each element in <code>new_vars</code> a variable (LHS value of <code>new_vars</code>) is added to
the output dataset and set to the value of the source variable (RHS value
of <code>new_vars</code>.
</p>


<h3>Value</h3>

<p>The input dataset with subperiod/period/phase variables added (see
&quot;Details&quot; section)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_period_dataset">create_period_dataset()</a></code>
</p>
<p>ADSL Functions that returns variable appended to dataset: 
<code><a href="#topic+derive_var_age_years">derive_var_age_years</a>()</code>,
<code><a href="#topic+derive_vars_aage">derive_vars_aage</a>()</code>,
<code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(lubridate)

adsl &lt;- tibble(STUDYID = "xyz", USUBJID = c("1", "2"))

# Add period variables to ADSL
period_ref &lt;- tribble(
  ~USUBJID, ~APERIOD, ~APERSDT,     ~APEREDT,
  "1",             1, "2021-01-04", "2021-02-06",
  "1",             2, "2021-02-07", "2021-03-07",
  "2",             1, "2021-02-02", "2021-03-02",
  "2",             2, "2021-03-03", "2021-04-01"
) %&gt;%
  mutate(
    STUDYID = "xyz",
    APERIOD = as.integer(APERIOD),
    across(matches("APER[ES]DT"), ymd)
  )

derive_vars_period(
  adsl,
  dataset_ref = period_ref,
  new_vars = exprs(APxxSDT = APERSDT, APxxEDT = APEREDT)
) %&gt;%
  select(STUDYID, USUBJID, AP01SDT, AP01EDT, AP02SDT, AP02EDT)

# Add phase variables to ADSL
phase_ref &lt;- tribble(
  ~USUBJID, ~APHASEN, ~PHSDT,       ~PHEDT,       ~APHASE,
  "1",             1, "2021-01-04", "2021-02-06", "TREATMENT",
  "1",             2, "2021-02-07", "2021-03-07", "FUP",
  "2",             1, "2021-02-02", "2021-03-02", "TREATMENT"
) %&gt;%
  mutate(
    STUDYID = "xyz",
    APHASEN = as.integer(APHASEN),
    across(matches("PH[ES]DT"), ymd)
  )

derive_vars_period(
  adsl,
  dataset_ref = phase_ref,
  new_vars = exprs(PHwSDT = PHSDT, PHwEDT = PHEDT, APHASEw = APHASE)
) %&gt;%
  select(STUDYID, USUBJID, PH1SDT, PH1EDT, PH2SDT, PH2EDT, APHASE1, APHASE2)

# Add subperiod variables to ADSL
subperiod_ref &lt;- tribble(
  ~USUBJID, ~APERIOD, ~ASPER, ~ASPRSDT,     ~ASPREDT,
  "1",             1,      1, "2021-01-04", "2021-01-19",
  "1",             1,      2, "2021-01-20", "2021-02-06",
  "1",             2,      1, "2021-02-07", "2021-03-07",
  "2",             1,      1, "2021-02-02", "2021-03-02",
  "2",             2,      1, "2021-03-03", "2021-04-01"
) %&gt;%
  mutate(
    STUDYID = "xyz",
    APERIOD = as.integer(APERIOD),
    ASPER = as.integer(ASPER),
    across(matches("ASPR[ES]DT"), ymd)
  )

derive_vars_period(
  adsl,
  dataset_ref = subperiod_ref,
  new_vars = exprs(PxxSwSDT = ASPRSDT, PxxSwEDT = ASPREDT)
) %&gt;%
  select(STUDYID, USUBJID, P01S1SDT, P01S1EDT, P01S2SDT, P01S2EDT, P02S1SDT, P02S1EDT)
</code></pre>

<hr>
<h2 id='derive_vars_query'>Derive Query Variables</h2><span id='topic+derive_vars_query'></span>

<h3>Description</h3>

<p>Derive Query Variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_query(dataset, dataset_queries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_query_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="derive_vars_query_+3A_dataset_queries">dataset_queries</code></td>
<td>
<p>A dataset containing required columns <code>PREFIX</code>,
<code>GRPNAME</code>, <code>SRCVAR</code>, <code>TERMCHAR</code> and/or <code>TERMNUM</code>, and optional columns
<code>GRPID</code>, <code>SCOPE</code>, <code>SCOPEN</code>.
</p>
<p><code>create_query_data()</code> can be used to create the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to derive CDISC variables such as
<code>SMQzzNAM</code>, <code>SMQzzCD</code>, <code>SMQzzSC</code>, <code>SMQzzSCN</code>, and <code>CQzzNAM</code> in ADAE and
ADMH, and variables such as <code>SDGzzNAM</code>, <code>SDGzzCD</code>, and <code>SDGzzSC</code> in ADCM.
An example usage of this function can be found in the
<a href="../articles/occds.html">OCCDS vignette</a>.
</p>
<p>A query dataset is expected as an input to this function. See the
<a href="../articles/queries_dataset.html">Queries Dataset Documentation vignette</a>
for descriptions, or call <code>data("queries")</code> for an example of a query dataset.
</p>
<p>For each unique element in <code>PREFIX</code>, the corresponding &quot;NAM&quot;
variable will be created. For each unique <code>PREFIX</code>, if <code>GRPID</code> is
not &quot;&quot; or NA, then the corresponding &quot;CD&quot; variable is created; similarly,
if <code>SCOPE</code> is not &quot;&quot; or NA, then the corresponding &quot;SC&quot; variable will
be created; if <code>SCOPEN</code> is not &quot;&quot; or NA, then the corresponding
&quot;SCN&quot; variable will be created.
</p>
<p>For each record in <code>dataset</code>, the &quot;NAM&quot; variable takes the value of
<code>GRPNAME</code> if the value of <code>TERMCHAR</code> or <code>TERMNUM</code> in <code>dataset_queries</code> matches
the value of the respective SRCVAR in <code>dataset</code>.
Note that <code>TERMCHAR</code> in <code>dataset_queries</code> dataset may be NA only when <code>TERMNUM</code>
is non-NA and vice versa. The matching is case insensitive.
The &quot;CD&quot;, &quot;SC&quot;, and &quot;SCN&quot; variables are derived accordingly based on
<code>GRPID</code>, <code>SCOPE</code>, and <code>SCOPEN</code> respectively,
whenever not missing.
</p>


<h3>Value</h3>

<p>The input dataset with query variables derived.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_query_data">create_query_data()</a></code>]
</p>
<p>OCCDS Functions: 
<code><a href="#topic+derive_var_trtemfl">derive_var_trtemfl</a>()</code>,
<code><a href="#topic+derive_vars_atc">derive_vars_atc</a>()</code>,
<code><a href="#topic+get_terms_from_db">get_terms_from_db</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
data("queries")
adae &lt;- tribble(
  ~USUBJID, ~ASTDTM, ~AETERM, ~AESEQ, ~AEDECOD, ~AELLT, ~AELLTCD,
  "01", "2020-06-02 23:59:59", "ALANINE AMINOTRANSFERASE ABNORMAL",
  3, "Alanine aminotransferase abnormal", NA_character_, NA_integer_,
  "02", "2020-06-05 23:59:59", "BASEDOW'S DISEASE",
  5, "Basedow's disease", NA_character_, 1L,
  "03", "2020-06-07 23:59:59", "SOME TERM",
  2, "Some query", "Some term", NA_integer_,
  "05", "2020-06-09 23:59:59", "ALVEOLAR PROTEINOSIS",
  7, "Alveolar proteinosis", NA_character_, NA_integer_
)
derive_vars_query(adae, queries)
</code></pre>

<hr>
<h2 id='derive_vars_transposed'>Derive Variables by Transposing and Merging a Second Dataset</h2><span id='topic+derive_vars_transposed'></span>

<h3>Description</h3>

<p>Adds variables from a vertical dataset after transposing it into a wide one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vars_transposed(
  dataset,
  dataset_merge,
  by_vars,
  key_var,
  value_var,
  filter = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vars_transposed_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="derive_vars_transposed_+3A_dataset_merge">dataset_merge</code></td>
<td>
<p>Dataset to transpose and merge
</p>
<p>The variables specified by the <code>by_vars</code>, <code>key_var</code> and <code>value_var</code> parameters
are expected</p>
</td></tr>
<tr><td><code id="derive_vars_transposed_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Keys used to merge <code>dataset_merge</code> with <code>dataset</code>.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="derive_vars_transposed_+3A_key_var">key_var</code></td>
<td>
<p>The variable of <code>dataset_merge</code> containing the names of the
transposed variables</p>
</td></tr>
<tr><td><code id="derive_vars_transposed_+3A_value_var">value_var</code></td>
<td>
<p>The variable of <code>dataset_merge</code> containing the values of the
transposed variables</p>
</td></tr>
<tr><td><code id="derive_vars_transposed_+3A_filter">filter</code></td>
<td>
<p>Expression used to restrict the records of <code>dataset_merge</code> prior to transposing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After filtering <code>dataset_merge</code> based upon the condition provided in <code>filter</code>, this
dataset is transposed and subsequently merged onto <code>dataset</code> using <code>by_vars</code> as
keys.
</p>


<h3>Value</h3>

<p>The input dataset with transposed variables from <code>dataset_merge</code> added
</p>


<h3>See Also</h3>

<p>General Derivation Functions for all ADaMs that returns variable appended to dataset:
<code><a href="#topic+derive_var_extreme_flag">derive_var_extreme_flag</a>()</code>,
<code><a href="#topic+derive_var_joined_exist_flag">derive_var_joined_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc</a>()</code>,
<code><a href="#topic+derive_var_merged_exist_flag">derive_var_merged_exist_flag</a>()</code>,
<code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary</a>()</code>,
<code><a href="#topic+derive_var_obs_number">derive_var_obs_number</a>()</code>,
<code><a href="#topic+derive_var_relative_flag">derive_var_relative_flag</a>()</code>,
<code><a href="#topic+derive_vars_computed">derive_vars_computed</a>()</code>,
<code><a href="#topic+derive_vars_joined">derive_vars_joined</a>()</code>,
<code><a href="#topic+derive_vars_merged">derive_vars_merged</a>()</code>,
<code><a href="#topic+derive_vars_merged_lookup">derive_vars_merged_lookup</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr, warn.conflicts = FALSE)

cm &lt;- tribble(
  ~USUBJID, ~CMGRPID, ~CMREFID, ~CMDECOD,
  "BP40257-1001", "14", "1192056", "PARACETAMOL",
  "BP40257-1001", "18", "2007001", "SOLUMEDROL",
  "BP40257-1002", "19", "2791596", "SPIRONOLACTONE"
)
facm &lt;- tribble(
  ~USUBJID, ~FAGRPID, ~FAREFID, ~FATESTCD, ~FASTRESC,
  "BP40257-1001", "1", "1192056", "CMATC1CD", "N",
  "BP40257-1001", "1", "1192056", "CMATC2CD", "N02",
  "BP40257-1001", "1", "1192056", "CMATC3CD", "N02B",
  "BP40257-1001", "1", "1192056", "CMATC4CD", "N02BE",
  "BP40257-1001", "1", "2007001", "CMATC1CD", "D",
  "BP40257-1001", "1", "2007001", "CMATC2CD", "D10",
  "BP40257-1001", "1", "2007001", "CMATC3CD", "D10A",
  "BP40257-1001", "1", "2007001", "CMATC4CD", "D10AA",
  "BP40257-1001", "2", "2007001", "CMATC1CD", "D",
  "BP40257-1001", "2", "2007001", "CMATC2CD", "D07",
  "BP40257-1001", "2", "2007001", "CMATC3CD", "D07A",
  "BP40257-1001", "2", "2007001", "CMATC4CD", "D07AA",
  "BP40257-1001", "3", "2007001", "CMATC1CD", "H",
  "BP40257-1001", "3", "2007001", "CMATC2CD", "H02",
  "BP40257-1001", "3", "2007001", "CMATC3CD", "H02A",
  "BP40257-1001", "3", "2007001", "CMATC4CD", "H02AB",
  "BP40257-1002", "1", "2791596", "CMATC1CD", "C",
  "BP40257-1002", "1", "2791596", "CMATC2CD", "C03",
  "BP40257-1002", "1", "2791596", "CMATC3CD", "C03D",
  "BP40257-1002", "1", "2791596", "CMATC4CD", "C03DA"
)

cm %&gt;%
  derive_vars_transposed(
    facm,
    by_vars = exprs(USUBJID, CMREFID = FAREFID),
    key_var = FATESTCD,
    value_var = FASTRESC
  ) %&gt;%
  select(USUBJID, CMDECOD, starts_with("CMATC"))
</code></pre>

<hr>
<h2 id='desc'>dplyr desc</h2><span id='topic+desc'></span>

<h3>Description</h3>

<p>See <code>dplyr::<a href="dplyr.html#topic+desc">desc</a></code> for details.
</p>

<hr>
<h2 id='dose_freq_lookup'>Pre-Defined Dose Frequencies</h2><span id='topic+dose_freq_lookup'></span>

<h3>Description</h3>

<p>These pre-defined dose frequencies are sourced from
<a href="https://evs.nci.nih.gov/ftp1/CDISC/SDTM/SDTM%20Terminology.pdf">CDISC</a>. The
number of rows to generate using <code>create_single_dose_dataset()</code> arguments
<code>start_date</code> and <code>end_date</code> is derived from <code>DOSE_COUNT</code>, <code>DOSE_WINDOW</code>, and
<code>CONVERSION_FACTOR</code> with appropriate functions from <code>lubridate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dose_freq_lookup
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 86 rows and 5 columns.
</p>


<h3>Details</h3>

<p><code>NCI_CODE</code> and <code>CDISC_VALUE</code> are included from the CDISC source for
traceability.
</p>
<p><code>DOSE_COUNT</code> represents the number of doses received in one single unit of
<code>DOSE_WINDOW</code>. For example, for <code>CDISC_VALUE=="10 DAYS PER MONTH"</code>,
<code>DOSE_WINDOW=="MONTH"</code> and <code>DOSE_COUNT==10</code>. Similarly, for
<code>CDISC_VALUE=="EVERY 2 WEEKS"</code>, <code>DOSE_WINDOW=="WEEK"</code> and
<code>DOSE_COUNT==0.5</code> (to yield one dose every two weeks).
</p>
<p><code>CONVERSION_FACTOR</code> is used to convert <code>DOSE_WINDOW</code> units <code>"WEEK"</code>,
<code>"MONTH"</code>, and <code>"YEAR"</code> to the unit <code>"DAY"</code>.
</p>
<p>For example, for <code>CDISC_VALUE=="10 DAYS PER MONTH"</code>, <code>CONVERSION_FACTOR</code>
is <code>0.0329</code>. One day of a month is assumed to be <code>1 / 30.4375</code> of a month (one
day is assumed to be <code>1/365.25</code> of a year).
Given only <code>start_date</code> and <code>end_date</code> in the aggregate dataset, <code>CONVERSION_FACTOR</code>
is used to calculate specific dates for<code>start_date</code> and <code>end_date</code> in the
resulting single dose dataset for the doses that occur. In such cases, doses
are assumed to occur at evenly spaced increments over the interval.
</p>
<p>To see the entire table in the console, run <code>print(dose_freq_lookup)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_single_dose_dataset">create_single_dose_dataset()</a></code>
</p>
<p>Other metadata: 
<code><a href="#topic+atoxgr_criteria_ctcv4">atoxgr_criteria_ctcv4</a></code>,
<code><a href="#topic+atoxgr_criteria_ctcv5">atoxgr_criteria_ctcv5</a></code>,
<code><a href="#topic+atoxgr_criteria_daids">atoxgr_criteria_daids</a></code>
</p>

<hr>
<h2 id='dt_level'>Create a <code>dt_level</code> object</h2><span id='topic+dt_level'></span>

<h3>Description</h3>

<p>Create a <code>dt_level</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dt_level(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dt_level_+3A_level">level</code></td>
<td>
<p>Date level
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"n"</code> (none, lowest level)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>dt_level</code> object is an ordered factor, i.e., two objects can be
compared.
</p>


<h3>Value</h3>

<p>A <code>dt_level</code> object
</p>


<h3>See Also</h3>

<p>Utilities used for date imputation: 
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='dthcaus_source'>Create a <code>dthcaus_source</code> Object</h2><span id='topic+dthcaus_source'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a> The <code>derive_var_dthcaus()</code>
function and <code>dthcaus_source()</code> have been superseded in favor of
<code>derive_vars_extreme_event()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dthcaus_source(
  dataset_name,
  filter,
  date,
  order = NULL,
  mode = "first",
  dthcaus,
  set_values_to = NULL,
  traceability_vars = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dthcaus_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the dataset, i.e. a string, used to search for
the death cause.</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_filter">filter</code></td>
<td>
<p>An expression used for filtering <code>dataset</code>.</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_date">date</code></td>
<td>
<p>A date or datetime variable or an expression to be used for
sorting <code>dataset</code>.</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Additional variables/expressions to be used for sorting the <code>dataset</code>. The
dataset is ordered by <code>date</code> and <code>order</code>. Can be used to avoid duplicate
record warning.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_mode">mode</code></td>
<td>
<p>One of <code>"first"</code> or <code>"last"</code>.
Either the <code>"first"</code> or <code>"last"</code> observation is preserved from the <code>dataset</code>
which is ordered by <code>date</code>.</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_dthcaus">dthcaus</code></td>
<td>
<p>A variable name, an expression, or a string literal
</p>
<p>If a variable name is specified, e.g., <code>AEDECOD</code>, it is the variable in the
source dataset to be used to assign values to <code>DTHCAUS</code>; if an expression,
e.g., <code>str_to_upper(AEDECOD)</code>, it is evaluated in the source dataset and
the results is assigned to <code>DTHCAUS</code>; if a string literal, e.g. <code>"Adverse Event"</code>, it is the fixed value to be assigned to <code>DTHCAUS</code>.</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set to trace the source dataset</p>
</td></tr>
<tr><td><code id="dthcaus_source_+3A_traceability_vars">traceability_vars</code></td>
<td>
<p>A named list returned by <code><a href="#topic+exprs">exprs()</a></code> listing the
traceability variables, e.g. <code>exprs(DTHDOM = "DS", DTHSEQ = DSSEQ)</code>. The
left-hand side (names of the list elements) gives the names of the
traceability variables in the returned dataset. The right-hand side (values
of the list elements) gives the values of the traceability variables in the
returned dataset. These can be either strings, numbers, symbols, or
expressions referring to existing variables.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;dthcaus_source&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+get_summary_records">get_summary_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Deaths sourced from AE
src_ae &lt;- dthcaus_source(
  dataset_name = "ae",
  filter = AEOUT == "FATAL",
  date = AEDTHDT,
  mode = "first",
  dthcaus = AEDECOD
)

# Deaths sourced from DS
src_ds &lt;- dthcaus_source(
  dataset_name = "ds",
  filter = DSDECOD == "DEATH",
  date = convert_dtc_to_dt(DSSTDTC),
  mode = "first",
  dthcaus = DSTERM
)
</code></pre>

<hr>
<h2 id='dtm_level'>Create a <code>dtm_level</code> object</h2><span id='topic+dtm_level'></span>

<h3>Description</h3>

<p>Create a <code>dtm_level</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dtm_level(level)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dtm_level_+3A_level">level</code></td>
<td>
<p>Datetime level
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"h"</code> (hour), <code>"m"</code> (minute), <code>"s"</code> (second, lowest level), <code>"n"</code>
(none)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>dtm_level</code> object is an ordered factor, i.e., two objects can be
compared.
</p>


<h3>Value</h3>

<p>A <code>dtm_level</code> object
</p>


<h3>See Also</h3>

<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='event'>Create a <code>event</code> Object</h2><span id='topic+event'></span>

<h3>Description</h3>

<p>The <code>event</code> object is used to define events as input for the
<code>derive_extreme_event()</code> and <code>derive_vars_extreme_event()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event(
  dataset_name = NULL,
  condition = NULL,
  mode = NULL,
  order = NULL,
  set_values_to = NULL,
  keep_source_vars = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Dataset name of the dataset to be used as input for the
event. The name refers to the dataset specified for <code>source_datasets</code> in
<code>derive_extreme_event()</code>. If the argument is not specified, the input
dataset (<code>dataset</code>) of <code>derive_extreme_event()</code> is used.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td></tr>
<tr><td><code id="event_+3A_condition">condition</code></td>
<td>
<p>An unquoted condition for selecting the observations, which
will contribute to the extreme event. If the condition contains summary
functions like <code>all()</code>, they are evaluated for each by group separately.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td></tr>
<tr><td><code id="event_+3A_mode">mode</code></td>
<td>
<p>If specified, the first or last observation with respect to <code>order</code> is
selected for each by group.
</p>
<p><em>Permitted Values</em>: <code>"first"</code>, <code>"last"</code>, <code>NULL</code></p>
</td></tr>
<tr><td><code id="event_+3A_order">order</code></td>
<td>
<p>The specified variables or expressions are used to select the
first or last observation if <code>mode</code> is specified.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="event_+3A_set_values_to">set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event, e.g. <code>exprs(PARAMCD = "WSP", PARAM  = "Worst Sleeping Problems")</code>. The values can be a symbol, a
character string, a numeric value, <code>NA</code> or an expression.
</p>
<p><em>Permitted Values</em>: a named list of expressions, e.g., created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="event_+3A_keep_source_vars">keep_source_vars</code></td>
<td>
<p>Variables to keep from the source dataset
</p>
<p>The specified variables are kept for the selected observations. The
variables specified for <code>by_vars</code> (of <code>derive_extreme_event()</code>) and created
by <code>set_values_to</code> are always kept.
</p>
<p><em>Permitted Values</em>: A list of expressions where each element is
a symbol or a tidyselect expression, e.g., <code>exprs(VISIT, VISITNUM, starts_with("RS"))</code>.</p>
</td></tr>
<tr><td><code id="event_+3A_description">description</code></td>
<td>
<p>Description of the event
</p>
<p>The description does not affect the derivations where the event is used. It
is intended for documentation only.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>event</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_extreme_event">derive_extreme_event()</a></code>, <code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event()</a></code>, <code><a href="#topic+event_joined">event_joined()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>

<hr>
<h2 id='event_joined'>Create a <code>event_joined</code> Object</h2><span id='topic+event_joined'></span>

<h3>Description</h3>

<p>The <code>event_joined</code> object is used to define events as input for the
<code>derive_extreme_event()</code> and <code>derive_vars_extreme_event()</code> functions.
This object should be used if the event does not depend on a single
observation of the source dataset but on multiple observations. For example,
if the event needs to be confirmed by a second observation of the source
dataset.
</p>
<p>The events are selected by calling <code>filter_joined()</code>. See its documentation
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_joined(
  dataset_name = NULL,
  condition,
  order = NULL,
  join_vars,
  join_type,
  first_cond = NULL,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  set_values_to = NULL,
  keep_source_vars = NULL,
  description = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_joined_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Dataset name of the dataset to be used as input for the
event. The name refers to the dataset specified for <code>source_datasets</code> in
<code>derive_extreme_event()</code>. If the argument is not specified, the input
dataset (<code>dataset</code>) of <code>derive_extreme_event()</code> is used.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td></tr>
<tr><td><code id="event_joined_+3A_condition">condition</code></td>
<td>
<p>An unquoted condition for selecting the observations, which
will contribute to the extreme event.
</p>
<p>The condition is applied to the joined dataset for selecting the confirmed
observations. The condition can include summary functions like <code>all()</code> or
<code>any()</code>. The joined dataset is grouped by the original observations. I.e.,
the summary function are applied to all observations up to the confirmation
observation. For example in the oncology setting when using this function
for confirmed best overall response,  <code>condition = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code> selects observations with response &quot;CR&quot; and for all
observations up to the confirmation observation the response is &quot;CR&quot; or
&quot;NE&quot; and there is at most one &quot;NE&quot;.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td></tr>
<tr><td><code id="event_joined_+3A_order">order</code></td>
<td>
<p>If specified, the specified variables or expressions are used to
select the first observation.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="event_joined_+3A_join_vars">join_vars</code></td>
<td>
<p>Variables to keep from joined dataset
</p>
<p>The variables needed from the other observations should be specified for
this parameter. The specified variables are added to the joined dataset
with suffix &quot;.join&quot;. For example to select all observations with <code>AVALC == "Y"</code> and <code>AVALC == "Y"</code> for at least one subsequent visit <code>join_vars = exprs(AVALC, AVISITN)</code> and <code>condition = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join</code> could be specified.
</p>
<p>The <code style="white-space: pre;">&#8288;*.join&#8288;</code> variables are not included in the output dataset.
</p>
<p><em>Permitted Values</em>: a named list of expressions, e.g., created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="event_joined_+3A_join_type">join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code> is specified all observations after the original observations are
kept.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td></tr>
<tr><td><code id="event_joined_+3A_first_cond">first_cond</code></td>
<td>
<p>Condition for selecting range of data
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>first_cond_upper</code> instead.
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the subsequent observations, all
observations are removed.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td></tr>
<tr><td><code id="event_joined_+3A_first_cond_lower">first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>condition</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td></tr>
<tr><td><code id="event_joined_+3A_first_cond_upper">first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>condition</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment.
</p>
<p><em>Permitted Values</em>: an unquoted condition</p>
</td></tr>
<tr><td><code id="event_joined_+3A_set_values_to">set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event, e.g. <code>exprs(PARAMCD = "WSP", PARAM  = "Worst Sleeping Problems")</code>. The values can be a symbol, a
character string, a numeric value, <code>NA</code> or an expression.
</p>
<p><em>Permitted Values</em>: a named list of expressions, e.g., created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="event_joined_+3A_keep_source_vars">keep_source_vars</code></td>
<td>
<p>Variables to keep from the source dataset
</p>
<p>The specified variables are kept for the selected observations. The
variables specified for <code>by_vars</code> (of <code>derive_extreme_event()</code>) and created
by <code>set_values_to</code> are always kept.
</p>
<p><em>Permitted Values</em>: A list of expressions where each element is
a symbol or a tidyselect expression, e.g., <code>exprs(VISIT, VISITNUM, starts_with("RS"))</code>.</p>
</td></tr>
<tr><td><code id="event_joined_+3A_description">description</code></td>
<td>
<p>Description of the event
</p>
<p>The description does not affect the derivations where the event is used. It
is intended for documentation only.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>event_joined</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_extreme_event">derive_extreme_event()</a></code>, <code><a href="#topic+derive_vars_extreme_event">derive_vars_extreme_event()</a></code>, <code><a href="#topic+event">event()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(dplyr)
library(lubridate)
# Derive confirmed best overall response (using event_joined())
# CR - complete response, PR - partial response, SD - stable disease
# NE - not evaluable, PD - progressive disease
adsl &lt;- tribble(
  ~USUBJID, ~TRTSDTC,
  "1",      "2020-01-01",
  "2",      "2019-12-12",
  "3",      "2019-11-11",
  "4",      "2019-12-30",
  "5",      "2020-01-01",
  "6",      "2020-02-02",
  "7",      "2020-02-02",
  "8",      "2020-02-01"
) %&gt;%
  mutate(TRTSDT = ymd(TRTSDTC))

adrs &lt;- tribble(
  ~USUBJID, ~ADTC,        ~AVALC,
  "1",      "2020-01-01", "PR",
  "1",      "2020-02-01", "CR",
  "1",      "2020-02-16", "NE",
  "1",      "2020-03-01", "CR",
  "1",      "2020-04-01", "SD",
  "2",      "2020-01-01", "SD",
  "2",      "2020-02-01", "PR",
  "2",      "2020-03-01", "SD",
  "2",      "2020-03-13", "CR",
  "4",      "2020-01-01", "PR",
  "4",      "2020-03-01", "NE",
  "4",      "2020-04-01", "NE",
  "4",      "2020-05-01", "PR",
  "5",      "2020-01-01", "PR",
  "5",      "2020-01-10", "PR",
  "5",      "2020-01-20", "PR",
  "6",      "2020-02-06", "PR",
  "6",      "2020-02-16", "CR",
  "6",      "2020-03-30", "PR",
  "7",      "2020-02-06", "PR",
  "7",      "2020-02-16", "CR",
  "7",      "2020-04-01", "NE",
  "8",      "2020-02-16", "PD"
) %&gt;%
  mutate(
    ADT = ymd(ADTC),
    PARAMCD = "OVR",
    PARAM = "Overall Response by Investigator"
  ) %&gt;%
  derive_vars_merged(
    dataset_add = adsl,
    by_vars = exprs(USUBJID),
    new_vars = exprs(TRTSDT)
  )

derive_extreme_event(
  adrs,
  by_vars = exprs(USUBJID),
  order = exprs(ADT),
  mode = "first",
  source_datasets = list(adsl = adsl),
  events = list(
    event_joined(
      description = paste(
        "CR needs to be confirmed by a second CR at least 28 days later",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join == "CR" &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "CR" &amp;
        all(AVALC.join %in% c("CR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "CR"
      )
    ),
    event_joined(
      description = paste(
        "PR needs to be confirmed by a second CR or PR at least 28 days later,",
        "at most one NE is acceptable between the two assessments"
      ),
      join_vars = exprs(AVALC, ADT),
      join_type = "after",
      first_cond_upper = AVALC.join %in% c("CR", "PR") &amp;
        ADT.join &gt;= ADT + 28,
      condition = AVALC == "PR" &amp;
        all(AVALC.join %in% c("CR", "PR", "NE")) &amp;
        count_vals(var = AVALC.join, val = "NE") &lt;= 1,
      set_values_to = exprs(
        AVALC = "PR"
      )
    ),
    event(
      description = paste(
        "CR, PR, or SD are considered as SD if occurring at least 28",
        "after treatment start"
      ),
      condition = AVALC %in% c("CR", "PR", "SD") &amp; ADT &gt;= TRTSDT + 28,
      set_values_to = exprs(
        AVALC = "SD"
      )
    ),
    event(
      condition = AVALC == "PD",
      set_values_to = exprs(
        AVALC = "PD"
      )
    ),
    event(
      condition = AVALC %in% c("CR", "PR", "SD", "NE"),
      set_values_to = exprs(
        AVALC = "NE"
      )
    ),
    event(
      description = "set response to MISSING for patients without records in ADRS",
      dataset_name = "adsl",
      condition = TRUE,
      set_values_to = exprs(
        AVALC = "MISSING"
      ),
      keep_source_vars = exprs(TRTSDT)
    )
  ),
  set_values_to = exprs(
    PARAMCD = "CBOR",
    PARAM = "Best Confirmed Overall Response by Investigator"
  )
) %&gt;%
  filter(PARAMCD == "CBOR")
</code></pre>

<hr>
<h2 id='event_source'>Create an <code>event_source</code> Object</h2><span id='topic+event_source'></span>

<h3>Description</h3>

<p><code>event_source</code> objects are used to define events as input for the
<code>derive_param_tte()</code> function.
</p>
<p><strong>Note:</strong> This is a wrapper function for the more generic <code>tte_source()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>event_source(dataset_name, filter = NULL, date, set_values_to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="event_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the source dataset
</p>
<p>The name refers to the dataset provided by the <code>source_datasets</code> parameter
of <code>derive_param_tte()</code>.</p>
</td></tr>
<tr><td><code id="event_source_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for selecting the observations from
<code>dataset</code> which are events or possible censoring time points.</p>
</td></tr>
<tr><td><code id="event_source_+3A_date">date</code></td>
<td>
<p>A variable or expression providing the date of the event or
censoring. A date, or a datetime can be specified. An unquoted symbol or
expression is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> or <code>convert_dtc_to_dt()</code> to impute and derive a
date from a date character vector to a date object.</p>
</td></tr>
<tr><td><code id="event_source_+3A_set_values_to">set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event or censoring, e.g. <code>exprs(EVENTDESC = "DEATH", SRCDOM = "ADSL", SRCVAR = "DTHDT")</code>. The values must be a symbol, a
character string, a numeric value, an expression, or <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>event_source</code>, inheriting from class <code>tte_source</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>, <code><a href="#topic+censor_source">censor_source()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Death event

event_source(
  dataset_name = "adsl",
  filter = DTHFL == "Y",
  date = DTHDT,
  set_values_to = exprs(
    EVNTDESC = "DEATH",
    SRCDOM = "ADSL",
    SRCVAR = "DTHDT"
  )
)
</code></pre>

<hr>
<h2 id='ex_single'>Single Dose Exposure Dataset</h2><span id='topic+ex_single'></span>

<h3>Description</h3>

<p>A derived dataset with single dose per date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ex_single
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 22439 rows and 17 columns.
</p>


<h3>Source</h3>

<p>Derived from the <code>ex</code> dataset using <code>{admiral}</code> and <code>{dplyr}</code> (<a href="https://github.com/pharmaverse/admiral/blob/main/inst/example_scripts/derive_single_dose.R">https://github.com/pharmaverse/admiral/blob/main/inst/example_scripts/derive_single_dose.R</a>)
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adlb">admiral_adlb</a></code>,
<code><a href="#topic+admiral_adsl">admiral_adsl</a></code>,
<code><a href="#topic+example_qs">example_qs</a></code>,
<code><a href="#topic+queries">queries</a></code>,
<code><a href="#topic+queries_mh">queries_mh</a></code>
</p>

<hr>
<h2 id='example_qs'>Example <code>QS</code> Dataset</h2><span id='topic+example_qs'></span>

<h3>Description</h3>

<p>An example <code>QS</code> dataset based on the examples from the CDISC ADaM Supplements
<a href="https://www.cdisc.org/standards/foundational/qrs/generalized-anxiety-disorder-7-item-version-2-0">Generalized Anxiety Disorder 7-Item Version 2 (GAD-7)</a>
and <a href="https://www.cdisc.org/standards/foundational/qrs/geriatric-depression-scale-short-form-0">Geriatric Depression Scale Short Form (GDS-SF)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_qs
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 161 rows and 11 columns.
</p>


<h3>Source</h3>

<p>Created by (<a href="https://github.com/pharmaverse/admiral/blob/main/inst/example_scripts/example_qs.R">https://github.com/pharmaverse/admiral/blob/main/inst/example_scripts/example_qs.R</a>)
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adlb">admiral_adlb</a></code>,
<code><a href="#topic+admiral_adsl">admiral_adsl</a></code>,
<code><a href="#topic+ex_single">ex_single</a></code>,
<code><a href="#topic+queries">queries</a></code>,
<code><a href="#topic+queries_mh">queries_mh</a></code>
</p>

<hr>
<h2 id='exprs'>rlang exprs</h2><span id='topic+exprs'></span>

<h3>Description</h3>

<p>See <code>rlang::<a href="rlang.html#topic+exprs">exprs</a></code> for details.
</p>

<hr>
<h2 id='extract_duplicate_records'>Extract Duplicate Records</h2><span id='topic+extract_duplicate_records'></span>

<h3>Description</h3>

<p>Extract Duplicate Records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_duplicate_records(dataset, by_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_duplicate_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="extract_duplicate_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Defines groups of records in which to look for duplicates.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of duplicate records within <code>dataset</code>
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+admiral-package">admiral-package</a></code>,
<code><a href="#topic+format.basket_select">format.basket_select</a>()</code>,
<code><a href="#topic+signal_duplicate_records">signal_duplicate_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admiral_adsl)

# Duplicate the first record
adsl &lt;- rbind(admiral_adsl[1L, ], admiral_adsl)

extract_duplicate_records(adsl, exprs(USUBJID))
</code></pre>

<hr>
<h2 id='extract_unit'>Extract Unit From Parameter Description</h2><span id='topic+extract_unit'></span>

<h3>Description</h3>

<p>Extract the unit of a parameter from a description like &quot;Param (unit)&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_unit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_unit_+3A_x">x</code></td>
<td>
<p>A parameter description</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string
</p>


<h3>See Also</h3>

<p>Utilities used within Derivation functions: 
<code><a href="#topic+call_user_fun">call_user_fun</a>()</code>,
<code><a href="#topic+get_not_mapped">get_not_mapped</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_unit("Height (cm)")

extract_unit("Diastolic Blood Pressure (mmHg)")
</code></pre>

<hr>
<h2 id='filter_exist'>Returns records that fit into existing by groups in a filtered source dataset</h2><span id='topic+filter_exist'></span>

<h3>Description</h3>

<p>Returns all records in the input dataset that belong to by groups that are present
in a source dataset, after the source dataset is optionally filtered. For example,
this could be used to return ADSL records for subjects that experienced a certain
adverse event during the course of the study (as per records in ADAE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_exist(dataset, dataset_add, by_vars, filter_add = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_exist_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="filter_exist_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Source dataset
</p>
<p>The source dataset, which determines the by groups returned in the input dataset,
based on the groups that exist in this dataset after being subset by <code>filter_add</code>.
</p>
<p>The variables specified in the <code>by_vars</code> and <code>filter_add</code> parameters are expected
in this dataset.</p>
</td></tr>
<tr><td><code id="filter_exist_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="filter_exist_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for the source dataset
</p>
<p>The filter condition which will be used to subset the source dataset.
Alternatively, if no filter condition is supplied, no subsetting of the source
dataset will be performed.
</p>
<p>Default: <code>NULL</code> (i.e. no filtering will be performed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the records in <code>dataset</code> which match an existing by group in <code>dataset_add</code>,
after being filtered according to <code>filter_add</code>. If there are no by groups that exist
in both datasets, an empty dataset will be returned.
</p>


<h3>Value</h3>

<p>The records in the input dataset which are contained within an existing by group in
the filtered source dataset.
</p>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get demographic information about subjects who have suffered from moderate or
# severe fatigue

library(tibble)

adsl &lt;- tribble(
  ~USUBJID,      ~AGE, ~SEX,
  "01-701-1015", 63,   "F",
  "01-701-1034", 77,   "F",
  "01-701-1115", 84,   "M",
  "01-701-1146", 75,   "F",
  "01-701-1444", 63,   "M"
)

adae &lt;- tribble(
  ~USUBJID,      ~AEDECOD,                    ~AESEV,     ~AESTDTC,
  "01-701-1015", "DIARRHOEA",                 "MODERATE", "2014-01-09",
  "01-701-1034", "FATIGUE",                   "SEVERE",   "2014-11-02",
  "01-701-1034", "APPLICATION SITE PRURITUS", "MODERATE", "2014-08-27",
  "01-701-1115", "FATIGUE",                   "MILD",     "2013-01-14",
  "01-701-1146", "FATIGUE",                   "MODERATE", "2013-06-03"
)

filter_exist(
  dataset = adsl,
  dataset_add = adae,
  by_vars = exprs(USUBJID),
  filter_add = AEDECOD == "FATIGUE" &amp; AESEV %in% c("MODERATE", "SEVERE")
)

</code></pre>

<hr>
<h2 id='filter_extreme'>Filter the First or Last Observation for Each By Group</h2><span id='topic+filter_extreme'></span>

<h3>Description</h3>

<p>Filters the first or last observation for each by group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_extreme(dataset, by_vars = NULL, order, mode, check_type = "warning")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_extreme_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="filter_extreme_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Default</em>: <code>NULL</code>
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="filter_extreme_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Within each by group the observations are ordered by the specified order.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="filter_extreme_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, the first observation of each by group is
included in the output dataset. If <code>"last"</code> is specified, the last
observation of each by group is included in the output dataset.
</p>
<p><em>Permitted Values:</em>  <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="filter_extreme_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Default:</em> <code>"warning"</code>
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each group (with respect to the variables specified for the
<code>by_vars</code> parameter) the first or last observation (with respect to the
order specified for the <code>order</code> parameter and the mode specified for the
<code>mode</code> parameter) is included in the output dataset.
</p>


<h3>Value</h3>

<p>A dataset containing the first or last observation of each by group
</p>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

ex &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~EXSEQ, ~EXDOSE,    ~EXTRT,
  "PILOT01",    "EX", "01-1442",      1,      54,    "XANO",
  "PILOT01",    "EX", "01-1442",      2,      54,    "XANO",
  "PILOT01",    "EX", "01-1442",      3,      54,    "XANO",
  "PILOT01",    "EX", "01-1444",      1,      54,    "XANO",
  "PILOT01",    "EX", "01-1444",      2,      81,    "XANO",
  "PILOT01",    "EX", "05-1382",      1,      54,    "XANO",
  "PILOT01",    "EX", "08-1213",      1,      54,    "XANO",
  "PILOT01",    "EX", "10-1053",      1,      54,    "XANO",
  "PILOT01",    "EX", "10-1053",      2,      54,    "XANO",
  "PILOT01",    "EX", "10-1183",      1,       0, "PLACEBO",
  "PILOT01",    "EX", "10-1183",      2,       0, "PLACEBO",
  "PILOT01",    "EX", "10-1183",      3,       0, "PLACEBO",
  "PILOT01",    "EX", "11-1036",      1,       0, "PLACEBO",
  "PILOT01",    "EX", "11-1036",      2,       0, "PLACEBO",
  "PILOT01",    "EX", "11-1036",      3,       0, "PLACEBO",
  "PILOT01",    "EX", "14-1425",      1,      54,    "XANO",
  "PILOT01",    "EX", "15-1319",      1,      54,    "XANO",
  "PILOT01",    "EX", "15-1319",      2,      81,    "XANO",
  "PILOT01",    "EX", "16-1151",      1,      54,    "XANO",
  "PILOT01",    "EX", "16-1151",      2,      54,    "XANO"
)


# Select first dose for each patient
ex %&gt;%
  filter_extreme(
    by_vars = exprs(USUBJID),
    order = exprs(EXSEQ),
    mode = "first"
  ) %&gt;%
  select(USUBJID, EXSEQ)

# Select highest dose for each patient on the active drug
ex %&gt;%
  filter(EXTRT != "PLACEBO") %&gt;%
  filter_extreme(
    by_vars = exprs(USUBJID),
    order = exprs(EXDOSE),
    mode = "last",
    check_type = "none"
  ) %&gt;%
  select(USUBJID, EXTRT, EXDOSE)
</code></pre>

<hr>
<h2 id='filter_joined'>Filter Observations Taking Other Observations into Account</h2><span id='topic+filter_joined'></span>

<h3>Description</h3>

<p>The function filters observation using a condition taking other observations
into account. For example, it could select all observations with <code>AVALC == "Y"</code> and <code>AVALC == "Y"</code> for at least one subsequent observation. The input
dataset is joined with itself to enable conditions taking variables from both
the current observation and the other observations into account. The suffix
&quot;.join&quot; is added to the variables from the subsequent observations.
</p>
<p>An example usage might be checking if a patient received two required
medications within a certain timeframe of each other.
</p>
<p>In the oncology setting, for example, we use such processing to check if a
response value can be confirmed by a subsequent assessment. This is commonly
used in endpoints such as best overall response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_joined(
  dataset,
  dataset_add,
  by_vars,
  join_vars,
  join_type,
  first_cond = NULL,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  order,
  tmp_obs_nr_var = NULL,
  filter_add = NULL,
  filter_join,
  filter = NULL,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_joined_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified for <code>by_vars</code>, <code>join_vars</code>, and <code>order</code> are
expected.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_by_vars">by_vars</code></td>
<td>
<p>By variables
</p>
<p>The specified variables are used as by variables for joining the input
dataset with itself.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="filter_joined_+3A_join_vars">join_vars</code></td>
<td>
<p>Variables to keep from joined dataset
</p>
<p>The variables needed from the other observations should be specified for
this parameter. The specified variables are added to the joined dataset
with suffix &quot;.join&quot;. For example to select all observations with <code>AVALC == "Y"</code> and <code>AVALC == "Y"</code> for at least one subsequent visit <code>join_vars = exprs(AVALC, AVISITN)</code> and <code>filter_join = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join</code> could be specified.
</p>
<p>The <code style="white-space: pre;">&#8288;*.join&#8288;</code> variables are not included in the output dataset.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_join_type">join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code>
is specified all observations after the original observations are kept.
</p>
<p>For example for confirmed response or BOR in the oncology setting or
confirmed deterioration in questionnaires the confirmatory assessment must
be after the assessment. Thus <code>join_type = "after"</code> could be used.
</p>
<p>Whereas, sometimes you might allow for confirmatory observations to occur
prior to the observation. For example, to identify AEs occurring on or
after seven days before a COVID AE. Thus <code>join_type = "all"</code> could be used.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td></tr>
<tr><td><code id="filter_joined_+3A_first_cond">first_cond</code></td>
<td>
<p>Condition for selecting range of data
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>first_cond_upper</code> instead.
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the subsequent observations, all
observations are removed.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_first_cond_lower">first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation. For an example see the last example below.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_first_cond_upper">first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This parameter should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment. For an example see the last example below.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_order">order</code></td>
<td>
<p>Order
</p>
<p>The observations are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="filter_joined_+3A_tmp_obs_nr_var">tmp_obs_nr_var</code></td>
<td>
<p>Temporary observation number
</p>
<p>The specified variable is added to the input dataset (<code>dataset</code>) and the
additional dataset (<code>dataset_add</code>). It is set to the observation number
with respect to <code>order</code>. For each by group (<code>by_vars</code>) the observation
number starts with <code>1</code>. The variable can be used in the conditions
(<code>filter_join</code>, <code>first_cond_upper</code>, <code>first_cond_lower</code>). It is not included
in the output dataset. It can also be used to select consecutive
observations or the last observation (see example below).</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations from <code>dataset_add</code> fulfilling the specified condition are
joined to the input dataset. If the argument is not specified, all
observations are joined.
</p>
<p>Variables created by the <code>order</code> argument can be used in the condition.
</p>
<p>The condition can include summary functions. The additional dataset is
grouped by the by variables (<code>by_vars</code>).</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_filter_join">filter_join</code></td>
<td>
<p>Condition for selecting observations
</p>
<p>The filter is applied to the joined dataset for selecting the confirmed
observations. The condition can include summary functions like <code>all()</code> or
<code>any()</code>. The joined dataset is grouped by the original observations. I.e.,
the summary function are applied to all observations up to the confirmation
observation. For example in the oncology setting when using this function
for confirmed best overall response,  <code>filter_join = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code> selects observations with response &quot;CR&quot; and for all
observations up to the confirmation observation the response is &quot;CR&quot; or
&quot;NE&quot; and there is at most one &quot;NE&quot;.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_filter">filter</code></td>
<td>
<p>Condition for selecting observations
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>This argument is <em>deprecated</em>, please use <code>filter_join</code> instead.
</p>
<p>The filter is applied to the joined dataset for selecting the confirmed
observations. The condition can include summary functions. The joined
dataset is grouped by the original observations. I.e., the summary function
are applied to all observations up to the confirmation observation. For
example in the oncology setting when using this function for confirmed best
overall response,  <code>filter = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp; count_vals(var = AVALC.join, val = "NE") &lt;= 1</code> selects
observations with response &quot;CR&quot; and for all observations up to the
confirmation observation the response is &quot;CR&quot; or &quot;NE&quot; and there is at most
one &quot;NE&quot;.</p>
</td></tr>
<tr><td><code id="filter_joined_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following steps are performed to produce the output dataset.
</p>


<h4>Step 1</h4>


<ul>
<li><p> The variables specified by <code>order</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The variables specified by <code>join_vars</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted to
those matching the <code>filter_add</code> condition.
</p>
</li></ul>

<p>Then the  input dataset (<code>dataset</code>) is joined with the restricted
additional dataset by the variables specified for <code>by_vars</code>. From the
additional dataset only the variables specified for <code>join_vars</code> are kept.
The suffix &quot;.join&quot; is added to those variables which are also present in
the input dataset.
</p>
<p>For example, for <code>by_vars = USUBJID</code>, <code>join_vars = exprs(AVISITN, AVALC)</code>
and input dataset and additional dataset
</p>
<div class="sourceCode r"><pre># A tibble: 2 x 4
USUBJID AVISITN AVALC  AVAL
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;
1             1 Y         1
1             2 N         0
</pre></div>
<p>the joined dataset is
</p>
<div class="sourceCode r"><pre>A tibble: 4 x 6
USUBJID AVISITN AVALC  AVAL AVISITN.join AVALC.join
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;
1             1 Y         1            1 Y
1             1 Y         1            2 N
1             2 N         0            1 Y
1             2 N         0            2 N
</pre></div>



<h4>Step 2</h4>

<p>The joined dataset is restricted to observations with respect to
<code>join_type</code> and <code>order</code>.
</p>
<p>The dataset from the example in the previous step with <code>join_type = "after"</code> and <code>order = exprs(AVISITN)</code> is restricted to
</p>
<div class="sourceCode r"><pre>A tibble: 4 x 6
USUBJID AVISITN AVALC  AVAL AVISITN.join AVALC.join
&lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;        &lt;dbl&gt; &lt;chr&gt;
1             1 Y         1            2 N
</pre></div>



<h4>Step 3</h4>

<p>If <code>first_cond_lower</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations from the first
observation where <code>first_cond_lower</code> is fulfilled (the observation
fulfilling the condition is included) up to the observation of the input
dataset. If for an observation of the input dataset the condition is not
fulfilled, the observation is removed.
</p>
<p>If <code>first_cond_upper</code> is specified, for each observation of the input
dataset the joined dataset is restricted to observations up to the first
observation where <code>first_cond_upper</code> is fulfilled (the observation
fulfilling the condition is included). If for an observation of the input
dataset the condition is not fulfilled, the observation is removed.
</p>
<p>For an example see the last example in the &quot;Examples&quot; section.
</p>



<h4>Step 4</h4>

<p>The joined dataset is grouped by the observations from the input dataset
and restricted to the observations fulfilling the condition specified by
<code>filter_join</code>.
</p>



<h4>Step 5</h4>

<p>The first observation of each group is selected and the <code style="white-space: pre;">&#8288;*.join&#8288;</code> variables
are dropped.
</p>



<h3>Value</h3>

<p>A subset of the observations of the input dataset. All variables of
the input dataset are included in the output dataset.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+count_vals">count_vals()</a></code>, <code><a href="#topic+min_cond">min_cond()</a></code>, <code><a href="#topic+max_cond">max_cond()</a></code>
</p>
<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)
library(admiral)

# filter observations with a duration longer than 30 and
# on or after 7 days before a COVID AE (ACOVFL == "Y")
adae &lt;- tribble(
  ~USUBJID, ~ADY, ~ACOVFL, ~ADURN,
  "1",        10, "N",          1,
  "1",        21, "N",         50,
  "1",        23, "Y",         14,
  "1",        32, "N",         31,
  "1",        42, "N",         20,
  "2",        11, "Y",         13,
  "2",        23, "N",          2,
  "3",        13, "Y",         12,
  "4",        14, "N",         32,
  "4",        21, "N",         41
)

filter_joined(
  adae,
  dataset_add = adae,
  by_vars = exprs(USUBJID),
  join_vars = exprs(ACOVFL, ADY),
  join_type = "all",
  order = exprs(ADY),
  filter_join = ADURN &gt; 30 &amp; ACOVFL.join == "Y" &amp; ADY &gt;= ADY.join - 7
)

# filter observations with AVALC == "Y" and AVALC == "Y" at a subsequent visit
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "Y",
  "1",      2,        "N",
  "1",      3,        "Y",
  "1",      4,        "N",
  "2",      1,        "Y",
  "2",      2,        "N",
  "3",      1,        "Y",
  "4",      1,        "N",
  "4",      2,        "N",
)

filter_joined(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  join_vars = exprs(AVALC, AVISITN),
  join_type = "after",
  order = exprs(AVISITN),
  filter_join = AVALC == "Y" &amp; AVALC.join == "Y" &amp; AVISITN &lt; AVISITN.join
)

# select observations with AVALC == "CR", AVALC == "CR" at a subsequent visit,
# only "CR" or "NE" in between, and at most one "NE" in between
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "NE",
  "1",      4,        "CR",
  "1",      5,        "NE",
  "2",      1,        "CR",
  "2",      2,        "PR",
  "2",      3,        "CR",
  "3",      1,        "CR",
  "4",      1,        "CR",
  "4",      2,        "NE",
  "4",      3,        "NE",
  "4",      4,        "CR",
  "4",      5,        "PR"
)

filter_joined(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  join_vars = exprs(AVALC),
  join_type = "after",
  order = exprs(AVISITN),
  first_cond_upper = AVALC.join == "CR",
  filter_join = AVALC == "CR" &amp; all(AVALC.join %in% c("CR", "NE")) &amp;
    count_vals(var = AVALC.join, val = "NE") &lt;= 1
)

# select observations with AVALC == "PR", AVALC == "CR" or AVALC == "PR"
# at a subsequent visit at least 20 days later, only "CR", "PR", or "NE"
# in between, at most one "NE" in between, and "CR" is not followed by "PR"
data &lt;- tribble(
  ~USUBJID, ~ADY, ~AVALC,
  "1",         6, "PR",
  "1",        12, "CR",
  "1",        24, "NE",
  "1",        32, "CR",
  "1",        48, "PR",
  "2",         3, "PR",
  "2",        21, "CR",
  "2",        33, "PR",
  "3",        11, "PR",
  "4",         7, "PR",
  "4",        12, "NE",
  "4",        24, "NE",
  "4",        32, "PR",
  "4",        55, "PR"
)

filter_joined(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  join_vars = exprs(AVALC, ADY),
  join_type = "after",
  order = exprs(ADY),
  first_cond_upper = AVALC.join %in% c("CR", "PR") &amp; ADY.join - ADY &gt;= 20,
  filter_join = AVALC == "PR" &amp;
    all(AVALC.join %in% c("CR", "PR", "NE")) &amp;
    count_vals(var = AVALC.join, val = "NE") &lt;= 1 &amp;
    (
      min_cond(var = ADY.join, cond = AVALC.join == "CR") &gt;
        max_cond(var = ADY.join, cond = AVALC.join == "PR") |
        count_vals(var = AVALC.join, val = "CR") == 0
    )
)

# select observations with CRIT1FL == "Y" at two consecutive visits or at the last visit
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~CRIT1FL,
  "1",      1,        "Y",
  "1",      2,        "N",
  "1",      3,        "Y",
  "1",      5,        "N",
  "2",      1,        "Y",
  "2",      3,        "Y",
  "2",      5,        "N",
  "3",      1,        "Y",
  "4",      1,        "Y",
  "4",      2,        "N",
)

filter_joined(
  data,
  dataset_add = data,
  by_vars = exprs(USUBJID),
  tmp_obs_nr_var = tmp_obs_nr,
  join_vars = exprs(CRIT1FL),
  join_type = "all",
  order = exprs(AVISITN),
  filter_join = CRIT1FL == "Y" &amp; CRIT1FL.join == "Y" &amp;
    (tmp_obs_nr + 1 == tmp_obs_nr.join | tmp_obs_nr == max(tmp_obs_nr.join))
)

# first_cond_lower and first_cond_upper argument
myd &lt;- tribble(
  ~subj, ~day, ~val,
  "1",      1, "++",
  "1",      2, "-",
  "1",      3, "0",
  "1",      4, "+",
  "1",      5, "++",
  "1",      6, "-",
  "2",      1, "-",
  "2",      2, "++",
  "2",      3, "+",
  "2",      4, "0",
  "2",      5, "-",
  "2",      6, "++"
)

# select "0" where all results from the first "++" before the "0" up to the "0"
# (excluding the "0") are "+" or "++"
filter_joined(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  join_vars = exprs(val),
  join_type = "before",
  first_cond_lower = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)

# select "0" where all results from the "0" (excluding the "0") up to the first
# "++" after the "0" are "+" or "++"
filter_joined(
  myd,
  dataset_add = myd,
  by_vars = exprs(subj),
  order = exprs(day),
  join_vars = exprs(val),
  join_type = "after",
  first_cond_upper = val.join == "++",
  filter_join = val == "0" &amp; all(val.join %in% c("+", "++"))
)
</code></pre>

<hr>
<h2 id='filter_not_exist'>Returns records that don't fit into existing by groups in a filtered source dataset</h2><span id='topic+filter_not_exist'></span>

<h3>Description</h3>

<p>Returns all records in the input dataset that belong to by groups that are not
present in a source dataset, after the source dataset is optionally filtered. For
example, this could be used to return ADSL records for subjects that didn't take certain
concomitant medications during the course of the study (as per records in ADCM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_not_exist(dataset, dataset_add, by_vars, filter_add = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_not_exist_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="filter_not_exist_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Source dataset
</p>
<p>The source dataset, which determines the by groups returned in the input dataset,
based on the groups that don't exist in this dataset after being subset by <code>filter_add</code>.
</p>
<p>The variables specified in the <code>by_vars</code> and <code>filter_add</code> parameters are expected
in this dataset.</p>
</td></tr>
<tr><td><code id="filter_not_exist_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="filter_not_exist_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for the source dataset
</p>
<p>The filter condition which will be used to subset the source dataset.
Alternatively, if no filter condition is supplied, no subsetting of the source
dataset will be performed.
</p>
<p>Default: <code>NULL</code> (i.e. no filtering will be performed)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the records in <code>dataset</code> which don't match any existing by groups in
<code>dataset_add</code>, after being filtered according to <code>filter_add</code>. If all by
groups that exist in <code>dataset</code> don't exist in <code>dataset_add</code>, an empty dataset will
be returned.
</p>


<h3>Value</h3>

<p>The records in the input dataset which are not contained within any existing by
group in the filtered source dataset.
</p>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get demographic information about subjects who didn't take vitamin supplements
# during the study

library(tibble)

adsl &lt;- tribble(
  ~USUBJID,      ~AGE, ~SEX,
  "01-701-1015", 63,   "F",
  "01-701-1023", 64,   "M",
  "01-701-1034", 77,   "F",
  "01-701-1118", 52,   "M"
)

adcm &lt;- tribble(
  ~USUBJID,      ~CMTRT,         ~CMSTDTC,
  "01-701-1015", "ASPIRIN",      "2013-05-14",
  "01-701-1023", "MYLANTA",      "2014-01-04",
  "01-701-1023", "CALCIUM",      "2014-02-25",
  "01-701-1034", "VITAMIN C",    "2013-12-12",
  "01-701-1034", "CALCIUM",      "2013-03-27",
  "01-701-1118", "MULTIVITAMIN", "2013-02-21"
)

filter_not_exist(
  dataset = adsl,
  dataset_add = adcm,
  by_vars = exprs(USUBJID),
  filter_add = str_detect(CMTRT, "VITAMIN")
)

</code></pre>

<hr>
<h2 id='filter_relative'>Filter the Observations Before or After a Condition is Fulfilled</h2><span id='topic+filter_relative'></span>

<h3>Description</h3>

<p>Filters the observations before or after the observation where a specified
condition is fulfilled for each by group. For example, the function could be
called to select for each subject all observations before the first disease
progression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_relative(
  dataset,
  by_vars,
  order,
  condition,
  mode,
  selection,
  inclusive,
  keep_no_ref_groups = TRUE,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_relative_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>order</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="filter_relative_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>Within each by group the observations are ordered by the specified order.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_condition">condition</code></td>
<td>
<p>Condition for Reference Observation
</p>
<p>The specified condition determines the reference observation. The output
dataset contains all observations before or after (<code>selection</code> parameter)
the reference observation.</p>
</td></tr>
<tr><td><code id="filter_relative_+3A_mode">mode</code></td>
<td>
<p>Selection mode (first or last)
</p>
<p>If <code>"first"</code> is specified, for each by group the observations before or
after (<code>selection</code> parameter) the observation where the condition
(<code>condition</code> parameter) is fulfilled the <em>first</em> time is included in the
output dataset. If <code>"last"</code> is specified, for each by group the
observations before or after (<code>selection</code> parameter) the observation where
the condition (<code>condition</code> parameter) is fulfilled the <em>last</em> time is
included in the output dataset.
</p>
<p><em>Permitted Values:</em> <code>"first"</code>, <code>"last"</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_selection">selection</code></td>
<td>
<p>Select observations before or after the reference observation?
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_inclusive">inclusive</code></td>
<td>
<p>Include the reference observation?
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_keep_no_ref_groups">keep_no_ref_groups</code></td>
<td>
<p>Should by groups without reference observation be kept?
</p>
<p><em>Permitted Values:</em> <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="filter_relative_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the input dataset are not unique with respect to the
by variables and the order.
</p>
<p><em>Permitted Values:</em> <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each by group ( <code>by_vars</code> parameter) the observations before or
after (<code>selection</code> parameter) the observations where the condition
(<code>condition</code> parameter) is fulfilled the first or last time (<code>order</code>
parameter and <code>mode</code> parameter) is included in the output dataset.
</p>


<h3>Value</h3>

<p>A dataset containing for each by group the observations before or
after the observation where the condition was fulfilled the first or last
time
</p>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

response &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "CR",
  "1",      4,        "SD",
  "1",      5,        "NE",
  "2",      1,        "SD",
  "2",      2,        "PD",
  "2",      3,        "PD",
  "3",      1,        "SD",
  "4",      1,        "SD",
  "4",      2,        "PR",
  "4",      3,        "PD",
  "4",      4,        "SD",
  "4",      5,        "PR"
)

# Select observations up to first PD for each patient
response %&gt;%
  filter_relative(
    by_vars = exprs(USUBJID),
    order = exprs(AVISITN),
    condition = AVALC == "PD",
    mode = "first",
    selection = "before",
    inclusive = TRUE
  )

# Select observations after last CR, PR, or SD for each patient
response %&gt;%
  filter_relative(
    by_vars = exprs(USUBJID),
    order = exprs(AVISITN),
    condition = AVALC %in% c("CR", "PR", "SD"),
    mode = "last",
    selection = "after",
    inclusive = FALSE
  )

# Select observations from first response to first PD
response %&gt;%
  filter_relative(
    by_vars = exprs(USUBJID),
    order = exprs(AVISITN),
    condition = AVALC %in% c("CR", "PR"),
    mode = "first",
    selection = "after",
    inclusive = TRUE,
    keep_no_ref_groups = FALSE
  ) %&gt;%
  filter_relative(
    by_vars = exprs(USUBJID),
    order = exprs(AVISITN),
    condition = AVALC == "PD",
    mode = "first",
    selection = "before",
    inclusive = TRUE
  )
</code></pre>

<hr>
<h2 id='flag_event'>Create a <code>flag_event</code> Object</h2><span id='topic+flag_event'></span>

<h3>Description</h3>

<p>The <code>flag_event</code> object is used to define events as input for the
<code>derive_var_merged_ef_msrc()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flag_event(dataset_name, condition = NULL, by_vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flag_event_+3A_dataset_name">dataset_name</code></td>
<td>
<p>Dataset name of the dataset to be used as input for the
event. The name refers to the dataset specified for <code>source_datasets</code> in
<code>derive_var_merged_ef_msrc()</code>.
</p>
<p><em>Permitted Values</em>: a character scalar</p>
</td></tr>
<tr><td><code id="flag_event_+3A_condition">condition</code></td>
<td>
<p>Condition
</p>
<p>The condition is evaluated at the dataset referenced by <code>dataset_name</code>. For
all by groups where it evaluates as <code>TRUE</code> at least once the new variable
is set to the true value (<code>true_value</code>).</p>
</td></tr>
<tr><td><code id="flag_event_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>If specified, the dataset is grouped by the specified variables before the
condition is evaluated. If named elements are used in <code>by_vars</code> like
<code>by_vars = exprs(USUBJID, EXLNKID = ECLNKID)</code>, the variables are renamed
after the evaluation. If the <code>by_vars</code> element is not specified, the
observations are grouped by the variables specified for the <code>by_vars</code>
argument of <code>derive_var_merged_ef_msrc()</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+derive_var_merged_ef_msrc">derive_var_merged_ef_msrc()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>

<hr>
<h2 id='format.basket_select'>Returns a Character Representation of a <code>basket_select()</code> Object</h2><span id='topic+format.basket_select'></span>

<h3>Description</h3>

<p>The function returns a character representation of a <code>basket_select()</code> object.
It can be used for error messages for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'basket_select'
format(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format.basket_select_+3A_x">x</code></td>
<td>
<p>A <code>basket_select()</code> object</p>
</td></tr>
<tr><td><code id="format.basket_select_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character representation of the <code>basket_select()</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+basket_select">basket_select()</a></code>
</p>
<p>Other internal: 
<code><a href="#topic+admiral-package">admiral-package</a></code>,
<code><a href="#topic+extract_duplicate_records">extract_duplicate_records</a>()</code>,
<code><a href="#topic+signal_duplicate_records">signal_duplicate_records</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
format(basket_select(id = 42, scope = "NARROW", type = "smq"))
</code></pre>

<hr>
<h2 id='get_admiral_option'>Get the Value of an Admiral Option</h2><span id='topic+get_admiral_option'></span>

<h3>Description</h3>

<p>Get the Value of an Admiral Option Which Can Be Modified for Advanced Users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_admiral_option(option)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_admiral_option_+3A_option">option</code></td>
<td>
<p>A character scalar of commonly used admiral function inputs.
</p>
<p>As of now, support only available for
&quot;subject_keys&quot; or &quot;signif_digits&quot;.
See <code>set_admiral_options()</code> for a description of the options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function allows flexibility for function inputs that may need to be repeated
multiple times in a script, such as <code>subject_keys</code>.
</p>


<h3>Value</h3>

<p>The value of the specified option.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+set_admiral_options">set_admiral_options()</a></code>, <code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag()</a></code>, <code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus()</a></code>, <code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm()</a></code>, <code><a href="#topic+derive_vars_period">derive_vars_period()</a></code>,
<code><a href="#topic+create_period_dataset">create_period_dataset()</a></code>
</p>
<p>Other admiral_options: 
<code><a href="#topic+set_admiral_options">set_admiral_options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)
dm &lt;- tribble(
  ~STUDYID, ~DOMAIN,  ~USUBJID, ~AGE,   ~AGEU,
  "PILOT01",   "DM", "01-1302",   61, "YEARS",
  "PILOT01",   "DM", "17-1344",   64, "YEARS"
)

vs &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID, ~VSTESTCD,     ~VISIT,     ~VSTPT, ~VSSTRESN,
  "PILOT01",    "VS", "01-1302",   "DIABP", "BASELINE",    "LYING",        76,
  "PILOT01",    "VS", "01-1302",   "DIABP", "BASELINE", "STANDING",        87,
  "PILOT01",    "VS", "01-1302",   "DIABP",   "WEEK 2",    "LYING",        71,
  "PILOT01",    "VS", "01-1302",   "DIABP",   "WEEK 2", "STANDING",        79,
  "PILOT01",    "VS", "17-1344",   "DIABP", "BASELINE",    "LYING",        88,
  "PILOT01",    "VS", "17-1344",   "DIABP", "BASELINE", "STANDING",        86,
  "PILOT01",    "VS", "17-1344",   "DIABP",   "WEEK 2",    "LYING",        84,
  "PILOT01",    "VS", "17-1344",   "DIABP",   "WEEK 2", "STANDING",        82
)

# Merging all dm variables to vs
derive_vars_merged(
  vs,
  dataset_add = select(dm, -DOMAIN),
  by_vars = get_admiral_option("subject_keys")
)
</code></pre>

<hr>
<h2 id='get_duplicates_dataset'>Get Duplicate Records that Led to a Prior Error</h2><span id='topic+get_duplicates_dataset'></span>

<h3>Description</h3>

<p>Get Duplicate Records that Led to a Prior Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_duplicates_dataset()
</code></pre>


<h3>Details</h3>

<p>Many <code>{admiral}</code> function check that the input dataset contains only one record
per <code>by_vars</code> group and throw an error otherwise. The <code>get_duplicates_dataset()</code>
function allows one to retrieve the duplicate records that lead to an error.
</p>
<p>Note that the function always returns the dataset of duplicates from the last
error that has been thrown in the current R session. Thus, after restarting the
R sessions <code>get_duplicates_dataset()</code> will return <code>NULL</code> and after a second error
has been thrown, the dataset of the first error can no longer be accessed (unless
it has been saved in a variable).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>NULL</code>
</p>


<h3>See Also</h3>

<p>Utilities for Dataset Checking: 
<code><a href="#topic+get_many_to_one_dataset">get_many_to_one_dataset</a>()</code>,
<code><a href="#topic+get_one_to_many_dataset">get_one_to_many_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admiral_adsl)

# Duplicate the first record
adsl &lt;- rbind(admiral_adsl[1L, ], admiral_adsl)

signal_duplicate_records(adsl, exprs(USUBJID), cnd_type = "warning")

get_duplicates_dataset()
</code></pre>

<hr>
<h2 id='get_hori_data'>Creating Temporary Parameters and <code style="white-space: pre;">&#8288;&lt;variable&gt;.&lt;parameter&gt;&#8288;</code> Variables</h2><span id='topic+get_hori_data'></span>

<h3>Description</h3>

<p>The function creates temporary parameters and variables of the form
<code style="white-space: pre;">&#8288;&lt;variable&gt;.&lt;parameter&gt;&#8288;</code>, e.g., <code>AVAL.WEIGHT</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_hori_data(dataset, by_vars, parameters, set_values_to, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_hori_data_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="get_hori_data_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="get_hori_data_+3A_parameters">parameters</code></td>
<td>
<p>List of parameter codes
</p>
<p>The input dataset is restricted to the specified parameter codes. If an
expression is specified, a new parameter code is added to the input
dataset. The name of the element defines the parameter code and the
expression the observations to select.
</p>
<p><em>Permitted Values:</em> A character vector of <code>PARAMCD</code> values or a list of expressions</p>
</td></tr>
<tr><td><code id="get_hori_data_+3A_set_values_to">set_values_to</code></td>
<td>
<p>All variables of the form <code style="white-space: pre;">&#8288;&lt;variable&gt;.&lt;parameter&gt;&#8288;</code> like <code>AVAL.WEIGHT</code> are
added to the input dataset. They are set to the value of the variable for
the parameter. E.g., <code>AVAL.WEIGHT</code> is set to the value of <code>AVAL</code> where
<code>PARAMCD == "WEIGHT"</code>.
</p>
<p><em>Permitted Values:</em> A list of expressions</p>
</td></tr>
<tr><td><code id="get_hori_data_+3A_filter">filter</code></td>
<td>
<p>Filter condition used for restricting the input dataset
</p>
<p>The specified filter condition is used in the warnings only. It is not
applied to the input dataset.
</p>
<p><em>Permitted Values:</em> An unquoted expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataset with one observation per by group. It contains the
variables specified for <code>by_vars</code> and all variables of the form
<code style="white-space: pre;">&#8288;&lt;variable&gt;.&lt;parameter&gt;&#8288;</code> occurring in <code>analysis_value</code>.
</p>

<hr>
<h2 id='get_imputation_target_date'>Get Date Imputation Targets</h2><span id='topic+get_imputation_target_date'></span>

<h3>Description</h3>

<p>Get Date Imputation Targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_imputation_target_date(date_imputation, month)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_imputation_target_date_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the 15th
of June,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_imputation_target_date_+3A_month">month</code></td>
<td>
<p>Month component of the partial date</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For <code>date_imputation = "first"</code> <code>"0000"</code>, <code>"01"</code>, <code>"01"</code> are returned.
</p>
</li>
<li><p> For <code>date_imputation = "mid"</code> <code>"xxxx"</code>, <code>"06"</code>, <code>"30"</code> if <code>month</code> is <code>NA</code>
and <code>"15"</code> otherwise are returned.
</p>
</li>
<li><p> For <code>date_imputation = "last"</code> <code>"9999"</code>, <code>"12"</code>, <code>"31"</code> are returned.
</p>
</li>
<li><p> For <code>date_imputation = "&lt;mm&gt;-&lt;dd&gt;"</code> <code>"xxxx"</code>, <code>"&lt;mm&gt;"</code>, <code>"&lt;dd&gt;"</code> are returned.
</p>
</li></ul>

<p><code>"xxxx"</code> indicates that the component is undefined. If an undefined
component occurs in the imputed DTC value, the imputed DTC value is set to
<code>NA_character_</code> in the imputation functions.
</p>


<h3>Value</h3>

<p>A list of character vectors. The elements of the list are named
&quot;year&quot;, &quot;month&quot;, &quot;day&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm()</a></code>, <code><a href="#topic+impute_dtc_dt">impute_dtc_dt()</a></code>
</p>
<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='get_imputation_target_time'>Get Time Imputation Targets</h2><span id='topic+get_imputation_target_time'></span>

<h3>Description</h3>

<p>Get Time Imputation Targets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_imputation_target_time(time_imputation)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_imputation_target_time_+3A_time_imputation">time_imputation</code></td>
<td>
<p>The value to impute the time when a timepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with hour, min and sec specified as <code>"hh:mm:ss"</code>: e.g. <code>"00:00:00"</code>
for the start of the day,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>,<code>"last"</code> to impute to the start/end of a day.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> For <code>time_imputation = "first"</code> <code>"00"</code>, <code>"00"</code>, <code>"00"</code> are returned.
</p>
</li>
<li><p> For <code>time_imputation = "last"</code> <code>"23"</code>, <code>"59"</code>, <code>"59"</code> are returned.
</p>
</li>
<li><p> For <code>time_imputation = "&lt;hh&gt;:&lt;mm&gt;:&lt;ss&gt;"</code> <code>"&lt;hh&gt;"</code>, <code>"&lt;mm&gt;"</code>, <code>"&lt;ss&gt;"</code> are returned.
</p>
</li></ul>



<h3>Value</h3>

<p>A list of character vectors. The elements of the list are named
&quot;hour&quot;, &quot;minute&quot;, &quot;second&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm()</a></code>
</p>
<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='get_joined_data'>Join Data for &quot;joined&quot; functions</h2><span id='topic+get_joined_data'></span>

<h3>Description</h3>

<p>The helper function joins the data for the &quot;joined&quot; functions. All <code>.join</code>
variables are included in the output dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_joined_data(
  dataset,
  dataset_add,
  by_vars = NULL,
  join_vars = NULL,
  join_type,
  first_cond_lower = NULL,
  first_cond_upper = NULL,
  order = NULL,
  tmp_obs_nr_var = NULL,
  filter_add = NULL,
  filter_join = NULL,
  check_type = "warning"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_joined_data_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_dataset_add">dataset_add</code></td>
<td>
<p>Additional dataset
</p>
<p>The variables specified by the <code>by_vars</code>, the <code>new_vars</code>, the <code>join_vars</code>,
and the <code>order</code> argument are expected.</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>The two datasets are joined by the specified variables.
</p>
<p>Variables can be renamed by naming the element, i.e.
<code style="white-space: pre;">&#8288;by_vars = exprs(&lt;name in input dataset&gt; = &lt;name in additional dataset&gt;)&#8288;</code>, similar to the <code>dplyr</code> joins.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_join_vars">join_vars</code></td>
<td>
<p>Variables to use from additional dataset
</p>
<p>Any extra variables required from the additional dataset for <code>filter_join</code>
should be specified for this argument. Variables specified for <code>new_vars</code>
do not need to be repeated for <code>join_vars</code>. If a specified variable exists
in both the input dataset and the additional dataset, the suffix &quot;.join&quot; is
added to the variable from the additional dataset.
</p>
<p>If an expression is named, e.g., <code>exprs(EXTDT = convert_dtc_to_dt(EXSTDTC))</code>, a corresponding variable is added to the
additional dataset and can be used in the filter conditions (<code>filter_add</code>,
<code>filter_join</code>) and for <code>new_vars</code>. The variable is not included in the
output dataset.
</p>
<p>The variables are not included in the output dataset.
</p>
<p><em>Permitted Values</em>: list of variables or named expressions created by <code>exprs()</code></p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_join_type">join_type</code></td>
<td>
<p>Observations to keep after joining
</p>
<p>The argument determines which of the joined observations are kept with
respect to the original observation. For example, if <code>join_type = "after"</code>
is specified all observations after the original observations are kept.
</p>
<p>For example for confirmed response or BOR in the oncology setting or
confirmed deterioration in questionnaires the confirmatory assessment must
be after the assessment. Thus <code>join_type = "after"</code> could be used.
</p>
<p>Whereas, sometimes you might allow for confirmatory observations to occur
prior to the observation. For example, to identify AEs occurring on or
after seven days before a COVID AE. Thus <code>join_type = "all"</code> could be used.
</p>
<p><em>Permitted Values:</em> <code>"before"</code>, <code>"after"</code>, <code>"all"</code></p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_first_cond_lower">first_cond_lower</code></td>
<td>
<p>Condition for selecting range of data (before)
</p>
<p>If this argument is specified, the other observations are restricted from
the first observation before the current observation where the specified
condition is fulfilled up to the current observation. If the condition is
not fulfilled for any of the other observations, no observations are
considered, i.e., the observation is not flagged.
</p>
<p>This argument should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only from a
certain observation before the current observation up to the current
observation.</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_first_cond_upper">first_cond_upper</code></td>
<td>
<p>Condition for selecting range of data (after)
</p>
<p>If this argument is specified, the other observations are restricted up to
the first observation where the specified condition is fulfilled. If the
condition is not fulfilled for any of the other observations, no
observations are considered, i.e., the observation is not flagged.
</p>
<p>This argument should be specified if <code>filter_join</code> contains summary
functions which should not apply to all observations but only up to the
confirmation assessment.</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_order">order</code></td>
<td>
<p>Sort order
</p>
<p>If the argument is set to a non-null value, for each observation of the
input dataset the first or last observation from the joined dataset is
selected with respect to the specified order. The specified variables are
expected in the additional dataset (<code>dataset_add</code>). If a variable is
available in both <code>dataset</code> and <code>dataset_add</code>, the one from <code>dataset_add</code>
is used for the sorting.
</p>
<p>If an expression is named, e.g., <code>exprs(EXSTDT = convert_dtc_to_dt(EXSTDTC), EXSEQ)</code>, a corresponding variable (<code>EXSTDT</code>) is
added to the additional dataset and can be used in the filter conditions
(<code>filter_add</code>, <code>filter_join</code>) and for <code>join_vars</code> and <code>new_vars</code>. The
variable is not included in the output dataset.
</p>
<p>For handling of <code>NA</code>s in sorting variables see <a href="../articles/generic.html#sort_order">Sort Order</a>.
</p>
<p><em>Permitted Values</em>: list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code> or <code>NULL</code></p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_tmp_obs_nr_var">tmp_obs_nr_var</code></td>
<td>
<p>Temporary observation number
</p>
<p>The specified variable is added to the input dataset (<code>dataset</code>) and the
additional dataset (<code>dataset_add</code>). It is set to the observation number
with respect to <code>order</code>. For each by group (<code>by_vars</code>) the observation
number starts with <code>1</code>. The variable can be used in the conditions
(<code>filter_join</code>, <code>first_cond_upper</code>, <code>first_cond_lower</code>). It can also be
used to select consecutive observations or the last observation.</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_filter_add">filter_add</code></td>
<td>
<p>Filter for additional dataset (<code>dataset_add</code>)
</p>
<p>Only observations from <code>dataset_add</code> fulfilling the specified condition are
joined to the input dataset. If the argument is not specified, all
observations are joined.
</p>
<p>Variables created by <code>order</code> or <code>new_vars</code> arguments can be used in the
condition.
</p>
<p>The condition can include summary functions like <code>all()</code> or <code>any()</code>. The
additional dataset is grouped by the by variables (<code>by_vars</code>).
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_filter_join">filter_join</code></td>
<td>
<p>Filter for the joined dataset
</p>
<p>The specified condition is applied to the joined dataset. Therefore
variables from both datasets <code>dataset</code> and <code>dataset_add</code> can be used.
</p>
<p>Variables created by <code>order</code> or <code>new_vars</code> arguments can be used in the
condition.
</p>
<p>The condition can include summary functions like <code>all()</code> or <code>any()</code>. The
joined dataset is grouped by the original observations.
</p>
<p><em>Permitted Values</em>: a condition</p>
</td></tr>
<tr><td><code id="get_joined_data_+3A_check_type">check_type</code></td>
<td>
<p>Check uniqueness?
</p>
<p>If <code>"warning"</code> or <code>"error"</code> is specified, the specified message is issued
if the observations of the (restricted) joined dataset are not unique with
respect to the by variables and the order.
</p>
<p>This argument is ignored if <code>order</code> is not specified. In this case an error
is issued independent of <code>check_type</code> if the restricted joined dataset
contains more than one observation for any of the observations of the input
dataset.
</p>
<p><em>Permitted Values</em>: <code>"none"</code>, <code>"warning"</code>, <code>"error"</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ol>
<li><p> The variables specified by <code>order</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The variables specified by <code>join_vars</code> are added to the additional dataset
(<code>dataset_add</code>).
</p>
</li>
<li><p> The records from the additional dataset (<code>dataset_add</code>) are restricted to
those matching the <code>filter_add</code> condition.
</p>
</li>
<li><p> The input dataset and the (restricted) additional dataset are left joined
by the grouping variables (<code>by_vars</code>). If no grouping variables are
specified, a full join is performed.
</p>
</li>
<li><p> The joined dataset is restricted by the <code>filter_join</code> condition.
</p>
</li></ol>


<hr>
<h2 id='get_many_to_one_dataset'>Get Many to One Values that Led to a Prior Error</h2><span id='topic+get_many_to_one_dataset'></span>

<h3>Description</h3>

<p>Get Many to One Values that Led to a Prior Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_many_to_one_dataset()
</code></pre>


<h3>Details</h3>

<p>If <code>assert_one_to_one()</code> detects an issue, the many to one values are stored
in a dataset. This dataset can be retrieved by <code>get_many_to_one_dataset()</code>.
</p>
<p>Note that the function always returns the many to one values from the last
error that has been thrown in the current R session. Thus, after restarting
the R sessions <code>get_many_to_one_dataset()</code> will return <code>NULL</code> and after a
second error has been thrown, the dataset of the first error can no longer be
accessed (unless it has been saved in a variable).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>NULL</code>
</p>


<h3>See Also</h3>

<p>Utilities for Dataset Checking: 
<code><a href="#topic+get_duplicates_dataset">get_duplicates_dataset</a>()</code>,
<code><a href="#topic+get_one_to_many_dataset">get_one_to_many_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(admiraldev, warn.conflicts = FALSE)
data(admiral_adsl)

try(
  assert_one_to_one(admiral_adsl, exprs(SITEID), exprs(STUDYID))
)

get_many_to_one_dataset()
</code></pre>

<hr>
<h2 id='get_not_mapped'>Get list of records not mapped from the lookup table.</h2><span id='topic+get_not_mapped'></span>

<h3>Description</h3>

<p>Get list of records not mapped from the lookup table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_not_mapped()
</code></pre>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>NULL</code>
</p>


<h3>See Also</h3>

<p>Utilities used within Derivation functions: 
<code><a href="#topic+call_user_fun">call_user_fun</a>()</code>,
<code><a href="#topic+extract_unit">extract_unit</a>()</code>
</p>

<hr>
<h2 id='get_one_to_many_dataset'>Get One to Many Values that Led to a Prior Error</h2><span id='topic+get_one_to_many_dataset'></span>

<h3>Description</h3>

<p>Get One to Many Values that Led to a Prior Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_one_to_many_dataset()
</code></pre>


<h3>Details</h3>

<p>If <code>assert_one_to_one()</code> detects an issue, the one to many values are stored
in a dataset. This dataset can be retrieved by <code>get_one_to_many_dataset()</code>.
</p>
<p>Note that the function always returns the one to many values from the last
error that has been thrown in the current R session. Thus, after restarting
the R sessions <code>get_one_to_many_dataset()</code> will return <code>NULL</code> and after a
second error has been thrown, the dataset of the first error can no longer be
accessed (unless it has been saved in a variable).
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> or <code>NULL</code>
</p>


<h3>See Also</h3>

<p>Utilities for Dataset Checking: 
<code><a href="#topic+get_duplicates_dataset">get_duplicates_dataset</a>()</code>,
<code><a href="#topic+get_many_to_one_dataset">get_many_to_one_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(admiraldev, warn.conflicts = FALSE)
data(admiral_adsl)

try(
  assert_one_to_one(admiral_adsl, exprs(STUDYID), exprs(SITEID))
)

get_one_to_many_dataset()
</code></pre>

<hr>
<h2 id='get_partialdatetime'>Parse DTC variable and Determine Components</h2><span id='topic+get_partialdatetime'></span>

<h3>Description</h3>

<p>Parse DTC variable and Determine Components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_partialdatetime(dtc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_partialdatetime_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to parse
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid value for any component.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function can be replaced by the parttime parser once it is
available.
</p>


<h3>Value</h3>

<p>A list of character vectors. The elements of the list are named
&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, &quot;minute&quot;, and &quot;second&quot;. Missing components
are set to <code>NA_character_</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm()</a></code>, <code><a href="#topic+impute_dtc_dt">impute_dtc_dt()</a></code>
</p>
<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='get_summary_records'>Create Summary Records</h2><span id='topic+get_summary_records'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#superseded"><img src="../help/figures/lifecycle-superseded.svg" alt='[Superseded]' /></a>
</p>
<p>Development on <code>get_summary_records()</code> is complete, and for new code we recommend
switching to using the <code>dataset_add</code> argument in <code>derive_summary_records()</code>.
</p>
<p>It is not uncommon to have an analysis need whereby one needs to derive an
analysis value (<code>AVAL</code>) from multiple records. The ADaM basic dataset
structure variable <code>DTYPE</code> is available to indicate when a new derived
records has been added to a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary_records(
  dataset,
  by_vars,
  filter = NULL,
  analysis_var,
  summary_fun,
  set_values_to = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> and <code>analysis_var</code> arguments are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="get_summary_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Variables to consider for generation of groupwise summary records.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="get_summary_records_+3A_filter">filter</code></td>
<td>
<p>Filter condition as logical expression to apply during
summary calculation. By default, filtering expressions are computed within
<code>by_vars</code> as this will help when an aggregating, lagging, or ranking
function is involved.
</p>
<p>For example,
</p>

<ul>
<li> <p><code>filter_rows = (AVAL &gt; mean(AVAL, na.rm = TRUE))</code> will filter all AVAL
values greater than mean of AVAL with in <code>by_vars</code>.
</p>
</li>
<li> <p><code>filter_rows = (dplyr::n() &gt; 2)</code> will filter n count of <code>by_vars</code> greater
than 2.
</p>
</li></ul>
</td></tr>
<tr><td><code id="get_summary_records_+3A_analysis_var">analysis_var</code></td>
<td>
<p>Analysis variable.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.</p>
</td></tr>
<tr><td><code id="get_summary_records_+3A_summary_fun">summary_fun</code></td>
<td>
<p>Function that takes as an input the <code>analysis_var</code> and
performs the calculation.
</p>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> Please use <code>set_values_to</code> instead.
</p>
<p>This can include built-in functions as well as user defined functions,
for example <code>mean</code> or <code>function(x) mean(x, na.rm = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="get_summary_records_+3A_set_values_to">set_values_to</code></td>
<td>
<p>Variables to be set
</p>
<p>The specified variables are set to the specified values for the new
observations.
</p>
<p>Set a list of variables to some specified value for the new records
</p>

<ul>
<li><p> LHS refer to a variable.
</p>
</li>
<li><p> RHS refers to the values to set to the variable. This can be a string, a
symbol, a numeric value, an expression or NA. If summary functions are
used, the values are summarized by the variables specified for <code>by_vars</code>.
</p>
</li></ul>

<p>For example:
</p>
<div class="sourceCode"><pre>  set_values_to = exprs(
    AVAL = sum(AVAL),
    PARAMCD = "TDOSE",
    PARCAT1 = "OVERALL"
  )
</pre></div></td></tr>
</table>


<h3>Details</h3>

<p>This function only creates derived observations and does not append them
to the original dataset observations. If you would like to this instead,
see the <code>derive_summary_records()</code> function.
</p>


<h3>Value</h3>

<p>A data frame of derived records.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_summary_records">derive_summary_records()</a></code>, <code><a href="#topic+derive_var_merged_summary">derive_var_merged_summary()</a></code>
</p>
<p>Other superseded: 
<code><a href="#topic+date_source">date_source</a>()</code>,
<code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record</a>()</code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus</a>()</code>,
<code><a href="#topic+derive_var_extreme_dt">derive_var_extreme_dt</a>()</code>,
<code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm</a>()</code>,
<code><a href="#topic+dthcaus_source">dthcaus_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)

adeg &lt;- tribble(
  ~USUBJID,   ~EGSEQ, ~PARAM,             ~AVISIT,    ~EGDTC,             ~AVAL, ~TRTA,
  "XYZ-1001", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:50", 385,   NA_character_,
  "XYZ-1001", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:52", 399,   NA_character_,
  "XYZ-1001", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:56", 396,   NA_character_,
  "XYZ-1001", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:45", 384,   "Placebo",
  "XYZ-1001", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:48", 393,   "Placebo",
  "XYZ-1001", 6,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:51", 388,   "Placebo",
  "XYZ-1001", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:45", 385,   "Placebo",
  "XYZ-1001", 8,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:48", 394,   "Placebo",
  "XYZ-1001", 9,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:51", 402,   "Placebo",
  "XYZ-1002", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 399,   NA_character_,
  "XYZ-1002", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 410,   NA_character_,
  "XYZ-1002", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-22T08:01", 392,   NA_character_,
  "XYZ-1002", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:50", 401,   "Active 20mg",
  "XYZ-1002", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:53", 407,   "Active 20mg",
  "XYZ-1002", 6,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:56", 400,   "Active 20mg",
  "XYZ-1002", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:50", 412,   "Active 20mg",
  "XYZ-1002", 8,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:53", 414,   "Active 20mg",
  "XYZ-1002", 9,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:56", 402,   "Active 20mg"
)

# Summarize the average of the triplicate ECG interval values (AVAL)
get_summary_records(
  adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  set_values_to = exprs(
    AVAL = mean(AVAL, na.rm = TRUE),
    DTYPE = "AVERAGE"
  )
)

# Derive more than one summary variable
get_summary_records(
  adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  set_values_to = exprs(
    AVAL = mean(AVAL),
    ASTDTM = min(convert_dtc_to_dtm(EGDTC)),
    AENDTM = max(convert_dtc_to_dtm(EGDTC)),
    DTYPE = "AVERAGE"
  )
)

# Sample ADEG dataset with triplicate record for only AVISIT = 'Baseline'
adeg &lt;- tribble(
  ~USUBJID,   ~EGSEQ, ~PARAM,             ~AVISIT,    ~EGDTC,             ~AVAL, ~TRTA,
  "XYZ-1001", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:50", 385,   NA_character_,
  "XYZ-1001", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:52", 399,   NA_character_,
  "XYZ-1001", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-24T07:56", 396,   NA_character_,
  "XYZ-1001", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:48", 393,   "Placebo",
  "XYZ-1001", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-08T09:51", 388,   "Placebo",
  "XYZ-1001", 6,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:48", 394,   "Placebo",
  "XYZ-1001", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-22T10:51", 402,   "Placebo",
  "XYZ-1002", 1,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 399,   NA_character_,
  "XYZ-1002", 2,      "QTcF Int. (msec)", "Baseline", "2016-02-22T07:58", 410,   NA_character_,
  "XYZ-1002", 3,      "QTcF Int. (msec)", "Baseline", "2016-02-22T08:01", 392,   NA_character_,
  "XYZ-1002", 4,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:53", 407,   "Active 20mg",
  "XYZ-1002", 5,      "QTcF Int. (msec)", "Visit 2",  "2016-03-06T09:56", 400,   "Active 20mg",
  "XYZ-1002", 6,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:53", 414,   "Active 20mg",
  "XYZ-1002", 7,      "QTcF Int. (msec)", "Visit 3",  "2016-03-24T10:56", 402,   "Active 20mg"
)

# Compute the average of AVAL only if there are more than 2 records within the
# by group
get_summary_records(
  adeg,
  by_vars = exprs(USUBJID, PARAM, AVISIT),
  filter = n() &gt; 2,
  set_values_to = exprs(
    AVAL = mean(AVAL, na.rm = TRUE),
    DTYPE = "AVERAGE"
  )
)
</code></pre>

<hr>
<h2 id='get_terms_from_db'>Get Terms from the Queries Database</h2><span id='topic+get_terms_from_db'></span>

<h3>Description</h3>

<p>The function checks if all requirements to access the database are fulfilled
(version and access function are available, see <code>assert_db_requirements()</code>),
reads the terms from the database, and checks if the dataset with the terms
is in the expected format (see <code>assert_terms()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_terms_from_db(
  version,
  fun,
  queries,
  definition,
  expect_grpname = FALSE,
  expect_grpid = FALSE,
  i,
  temp_env
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_terms_from_db_+3A_version">version</code></td>
<td>
<p>Version
</p>
<p>The version must be non null. Otherwise, an error is issued. The value is
passed to the access function (<code>fun</code>).</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_fun">fun</code></td>
<td>
<p>Access function
</p>
<p>The access function must be non null. Otherwise, an error is issued. The
function is called to retrieve the terms.</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_queries">queries</code></td>
<td>
<p>Queries
</p>
<p>List of all queries passed to <code>create_query_data()</code>. It is used for error
messages.</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_definition">definition</code></td>
<td>
<p>Definition of the query
</p>
<p>The definition is passed to the access function. It defines which terms are
returned.</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_expect_grpname">expect_grpname</code></td>
<td>
<p>Is <code>GRPNAME</code> expected in the output dataset?</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_expect_grpid">expect_grpid</code></td>
<td>
<p>Is <code>GRPID</code> expected in the output dataset?</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_i">i</code></td>
<td>
<p>Index of <code>definition</code> in <code>queries</code>
</p>
<p>The value is used for error messages.</p>
</td></tr>
<tr><td><code id="get_terms_from_db_+3A_temp_env">temp_env</code></td>
<td>
<p>Temporary environment
</p>
<p>The value is passed to the access function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output dataset of the access function
</p>


<h3>See Also</h3>

<p>OCCDS Functions: 
<code><a href="#topic+derive_var_trtemfl">derive_var_trtemfl</a>()</code>,
<code><a href="#topic+derive_vars_atc">derive_vars_atc</a>()</code>,
<code><a href="#topic+derive_vars_query">derive_vars_query</a>()</code>
</p>

<hr>
<h2 id='impute_dtc_dt'>Impute Partial Date Portion of a <code>'--DTC'</code> Variable</h2><span id='topic+impute_dtc_dt'></span>

<h3>Description</h3>

<p>Imputation partial date portion of a <code>'--DTC'</code> variable based on user input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_dtc_dt(
  dtc,
  highest_imputation = "n",
  date_imputation = "first",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_dtc_dt_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="impute_dtc_dt_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"n"</code> (none, lowest level)</p>
</td></tr>
<tr><td><code id="impute_dtc_dt_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="impute_dtc_dt_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).</p>
</td></tr>
<tr><td><code id="impute_dtc_dt_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.</p>
</td></tr>
<tr><td><code id="impute_dtc_dt_+3A_preserve">preserve</code></td>
<td>
<p>Preserve day if month is missing and day is present
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "MID"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

dates &lt;- c(
  "2019-07-18T15:25:40",
  "2019-07-18T15:25",
  "2019-07-18T15",
  "2019-07-18",
  "2019-02",
  "2019",
  "2019",
  "2019---07",
  ""
)

# No date imputation (highest_imputation defaulted to "n")
impute_dtc_dt(dtc = dates)

# Impute to first day/month if date is partial
impute_dtc_dt(
  dtc = dates,
  highest_imputation = "M"
)
# Same as above
impute_dtc_dt(
  dtc = dates,
  highest_imputation = "M",
  date_imputation = "01-01"
)

# Impute to last day/month if date is partial
impute_dtc_dt(
  dtc = dates,
  highest_imputation = "M",
  date_imputation = "last",
)

# Impute to mid day/month if date is partial
impute_dtc_dt(
  dtc = dates,
  highest_imputation = "M",
  date_imputation = "mid"
)

# Impute a date and ensure that the imputed date is not before a list of
# minimum dates
impute_dtc_dt(
  "2020-12",
  min_dates = list(
    ymd("2020-12-06"),
    ymd("2020-11-11")
  ),
  highest_imputation = "M"
)

# Impute completely missing dates (only possible if min_dates or max_dates is specified)
impute_dtc_dt(
  c("2020-12", NA_character_),
  min_dates = list(
    ymd("2020-12-06", "2020-01-01"),
    ymd("2020-11-11", NA)
  ),
  highest_imputation = "Y"
)
</code></pre>

<hr>
<h2 id='impute_dtc_dtm'>Impute Partial Date(-time) Portion of a <code>'--DTC'</code> Variable</h2><span id='topic+impute_dtc_dtm'></span>

<h3>Description</h3>

<p>Imputation partial date/time portion of a <code>'--DTC'</code> variable. based on user
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_dtc_dtm(
  dtc,
  highest_imputation = "h",
  date_imputation = "first",
  time_imputation = "first",
  min_dates = NULL,
  max_dates = NULL,
  preserve = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_dtc_dtm_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_highest_imputation">highest_imputation</code></td>
<td>
<p>Highest imputation level
</p>
<p>The <code>highest_imputation</code> argument controls which components of the DTC
value are imputed if they are missing. All components up to the specified
level are imputed.
</p>
<p>If a component at a higher level than the highest imputation level is
missing, <code>NA_character_</code> is returned. For example, for <code>highest_imputation = "D"</code> <code>"2020"</code> results in <code>NA_character_</code> because the month is missing.
</p>
<p>If <code>"n"</code> is specified, no imputation is performed, i.e., if any component is
missing, <code>NA_character_</code> is returned.
</p>
<p>If <code>"Y"</code> is specified, <code>date_imputation</code> should be <code>"first"</code> or <code>"last"</code>
and <code>min_dates</code> or <code>max_dates</code> should be specified respectively. Otherwise,
<code>NA_character_</code> is returned if the year component is missing.
</p>
<p><em>Permitted Values</em>: <code>"Y"</code> (year, highest level), <code>"M"</code> (month), <code>"D"</code>
(day), <code>"h"</code> (hour), <code>"m"</code> (minute), <code>"s"</code> (second), <code>"n"</code> (none, lowest
level)</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_date_imputation">date_imputation</code></td>
<td>
<p>The value to impute the day/month when a datepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with month and day specified as <code>"mm-dd"</code>: e.g. <code>"06-15"</code> for the
15th of June (The year can not be specified; for imputing the year
<code>"first"</code> or <code>"last"</code> together with <code>min_dates</code> or <code>max_dates</code> argument can
be used (see examples).),
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>, <code>"mid"</code>, <code>"last"</code> to impute to the first/mid/last
day/month. If <code>"mid"</code> is specified, missing components are imputed as the
middle of the possible range:
</p>

<ul>
<li><p> If both month and day are missing, they are imputed as <code>"06-30"</code>
(middle of the year).
</p>
</li>
<li><p> If only day is missing, it is imputed as <code>"15"</code> (middle of the month).
</p>
</li></ul>

</li></ul>

<p>The argument is ignored if <code>highest_imputation</code> is less then <code>"D"</code>.</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_time_imputation">time_imputation</code></td>
<td>
<p>The value to impute the time when a timepart is
missing.
</p>
<p>A character value is expected, either as a
</p>

<ul>
<li><p> format with hour, min and sec specified as <code>"hh:mm:ss"</code>: e.g. <code>"00:00:00"</code>
for the start of the day,
</p>
</li>
<li><p> or as a keyword: <code>"first"</code>,<code>"last"</code> to impute to the start/end of a day.
</p>
</li></ul>

<p>The argument is ignored if <code>highest_imputation = "n"</code>.</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"00:00:00"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"23:59:59"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="impute_dtc_dtm_+3A_preserve">preserve</code></td>
<td>
<p>Preserve lower level date/time part when higher order part
is missing, e.g. preserve day if month is missing or
preserve minute when hour is missing.
</p>
<p>For example <code>"2019---07"</code> would return <code style="white-space: pre;">&#8288;"2019-06-07&#8288;</code> if <code>preserve = TRUE</code>
(and <code>date_imputation = "mid"</code>).
</p>
<p>Permitted Values: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usually this computation function can not be used with <code style="white-space: pre;">&#8288;%&gt;%&#8288;</code>.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>See Also</h3>

<p>Date/Time Computation Functions that returns a vector: 
<code><a href="#topic+compute_age_years">compute_age_years</a>()</code>,
<code><a href="#topic+compute_dtf">compute_dtf</a>()</code>,
<code><a href="#topic+compute_duration">compute_duration</a>()</code>,
<code><a href="#topic+compute_tmf">compute_tmf</a>()</code>,
<code><a href="#topic+convert_date_to_dtm">convert_date_to_dtm</a>()</code>,
<code><a href="#topic+convert_dtc_to_dt">convert_dtc_to_dt</a>()</code>,
<code><a href="#topic+convert_dtc_to_dtm">convert_dtc_to_dtm</a>()</code>,
<code><a href="#topic+impute_dtc_dt">impute_dtc_dt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)

dates &lt;- c(
  "2019-07-18T15:25:40",
  "2019-07-18T15:25",
  "2019-07-18T15",
  "2019-07-18",
  "2019-02",
  "2019",
  "2019",
  "2019---07",
  ""
)

# No date imputation (highest_imputation defaulted to "h")
# Missing time part imputed with 00:00:00 portion by default
impute_dtc_dtm(dtc = dates)

# No date imputation (highest_imputation defaulted to "h")
# Missing time part imputed with 23:59:59 portion
impute_dtc_dtm(
  dtc = dates,
  time_imputation = "23:59:59"
)

# Same as above
impute_dtc_dtm(
  dtc = dates,
  time_imputation = "last"
)

# Impute to first day/month if date is partial
# Missing time part imputed with 00:00:00 portion by default
impute_dtc_dtm(
  dtc = dates,
  highest_imputation = "M"
)
# same as above
impute_dtc_dtm(
  dtc = dates,
  highest_imputation = "M",
  date_imputation = "01-01"
)

# Impute to last day/month if date is partial
# Missing time part imputed with 23:59:59 portion
impute_dtc_dtm(
  dtc = dates,
  date_imputation = "last",
  time_imputation = "last"
)

# Impute to mid day/month if date is partial
# Missing time part imputed with 00:00:00 portion by default
impute_dtc_dtm(
  dtc = dates,
  highest_imputation = "M",
  date_imputation = "mid"
)

# Impute a date and ensure that the imputed date is not before a list of
# minimum dates
impute_dtc_dtm(
  "2020-12",
  min_dates = list(
    ymd_hms("2020-12-06T12:12:12"),
    ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)

# Impute completely missing dates (only possible if min_dates or max_dates is specified)
impute_dtc_dtm(
  c("2020-12", NA_character_),
  min_dates = list(
    ymd_hms("2020-12-06T12:12:12", "2020-01-01T01:01:01"),
    ymd_hms("2020-11-11T11:11:11", NA)
  ),
  highest_imputation = "Y"
)
</code></pre>

<hr>
<h2 id='list_all_templates'>List All Available ADaM Templates</h2><span id='topic+list_all_templates'></span>

<h3>Description</h3>

<p>List All Available ADaM Templates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_all_templates(package = "admiral")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_all_templates_+3A_package">package</code></td>
<td>
<p>The R package in which to look for templates. By default <code>"admiral"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>character</code> vector of all available templates
</p>


<h3>See Also</h3>

<p>Utilities used for examples and template scripts: 
<code><a href="#topic+use_ad_template">use_ad_template</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_all_templates()
</code></pre>

<hr>
<h2 id='list_tte_source_objects'>List all <code>tte_source</code> Objects Available in a Package</h2><span id='topic+list_tte_source_objects'></span>

<h3>Description</h3>

<p>List all <code>tte_source</code> Objects Available in a Package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_tte_source_objects(package = "admiral")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_tte_source_objects_+3A_package">package</code></td>
<td>
<p>The name of the package in which to search for <code>tte_source</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> where each row corresponds to one <code>tte_source</code> object or <code>NULL</code>
if <code>package</code> does not contain any <code>tte_source</code> objects
</p>


<h3>See Also</h3>

<p>Other Advanced Functions: 
<code><a href="#topic+params">params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list_tte_source_objects()
</code></pre>

<hr>
<h2 id='max_cond'>Maximum Value on a Subset</h2><span id='topic+max_cond'></span>

<h3>Description</h3>

<p>The function derives the maximum value of a vector/column on a subset of
entries/observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_cond(var, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_cond_+3A_var">var</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="max_cond_+3A_cond">cond</code></td>
<td>
<p>A condition</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+min_cond">min_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(admiral)
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "NE",
  "1",      4,        "CR",
  "1",      5,        "NE",
  "2",      1,        "CR",
  "2",      2,        "PR",
  "2",      3,        "CR",
)

# In oncology setting, when needing to check the first time a patient had
# a Complete Response (CR) to compare to see if any Partial Response (PR)
# occurred after this add variable indicating if PR occurred after CR
group_by(data, USUBJID) %&gt;% mutate(
  first_cr_vis = min_cond(var = AVISITN, cond = AVALC == "CR"),
  last_pr_vis = max_cond(var = AVISITN, cond = AVALC == "PR"),
  pr_after_cr = last_pr_vis &gt; first_cr_vis
)
</code></pre>

<hr>
<h2 id='min_cond'>Minimum Value on a Subset</h2><span id='topic+min_cond'></span>

<h3>Description</h3>

<p>The function derives the minimum value of a vector/column on a subset of
entries/observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_cond(var, cond)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_cond_+3A_var">var</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="min_cond_+3A_cond">cond</code></td>
<td>
<p>A condition</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Utilities for Filtering Observations: 
<code><a href="#topic+count_vals">count_vals</a>()</code>,
<code><a href="#topic+filter_exist">filter_exist</a>()</code>,
<code><a href="#topic+filter_extreme">filter_extreme</a>()</code>,
<code><a href="#topic+filter_joined">filter_joined</a>()</code>,
<code><a href="#topic+filter_not_exist">filter_not_exist</a>()</code>,
<code><a href="#topic+filter_relative">filter_relative</a>()</code>,
<code><a href="#topic+max_cond">max_cond</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)
library(dplyr, warn.conflicts = FALSE)
library(admiral)
data &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVALC,
  "1",      1,        "PR",
  "1",      2,        "CR",
  "1",      3,        "NE",
  "1",      4,        "CR",
  "1",      5,        "NE",
  "2",      1,        "CR",
  "2",      2,        "PR",
  "2",      3,        "CR",
)

# In oncology setting, when needing to check the first time a patient had
# a Complete Response (CR) to compare to see if any Partial Response (PR)
# occurred after this add variable indicating if PR occurred after CR
group_by(data, USUBJID) %&gt;% mutate(
  first_cr_vis = min_cond(var = AVISITN, cond = AVALC == "CR"),
  last_pr_vis = max_cond(var = AVISITN, cond = AVALC == "PR"),
  pr_after_cr = last_pr_vis &gt; first_cr_vis
)
</code></pre>

<hr>
<h2 id='negate_vars'>Negate List of Variables</h2><span id='topic+negate_vars'></span>

<h3>Description</h3>

<p>The function adds a minus sign as prefix to each variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negate_vars(vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negate_vars_+3A_vars">vars</code></td>
<td>
<p>List of variables created by <code>exprs()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is useful if a list of variables should be removed from a dataset,
e.g., <code>select(!!!negate_vars(by_vars))</code> removes all by variables.
</p>


<h3>Value</h3>

<p>A list of expressions
</p>


<h3>See Also</h3>

<p>Utilities for working with quosures/list of expressions: 
<code><a href="#topic+chr2vars">chr2vars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>negate_vars(exprs(USUBJID, STUDYID))
</code></pre>

<hr>
<h2 id='params'>Create a Set of Parameters</h2><span id='topic+params'></span>

<h3>Description</h3>

<p>Create a set of variable parameters/function arguments to be used in <code><a href="#topic+call_derivation">call_derivation()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>params(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="params_+3A_...">...</code></td>
<td>
<p>One or more named arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>params</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+call_derivation">call_derivation()</a></code>
</p>
<p>Other Advanced Functions: 
<code><a href="#topic+list_tte_source_objects">list_tte_source_objects</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr, warn.conflicts = FALSE)

adsl &lt;- tribble(
  ~STUDYID,   ~USUBJID,      ~TRTSDT,      ~TRTEDT,
  "PILOT01", "01-1307",           NA,           NA,
  "PILOT01", "05-1377", "2014-01-04", "2014-01-25",
  "PILOT01", "06-1384", "2012-09-15", "2012-09-24",
  "PILOT01", "15-1085", "2013-02-16", "2013-08-18",
  "PILOT01", "16-1298", "2013-04-08", "2013-06-28"
) %&gt;%
  mutate(
    across(TRTSDT:TRTEDT, as.Date)
  )

ae &lt;- tribble(
  ~STUDYID,  ~DOMAIN,  ~USUBJID,     ~AESTDTC,     ~AEENDTC,
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-15", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "06-1384", "2012-09-23", "2012-09-29",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-06-08", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06",
  "PILOT01",    "AE", "16-1298", "2013-04-22", "2013-07-06"
)

adae &lt;- ae %&gt;%
  select(USUBJID, AESTDTC, AEENDTC) %&gt;%
  derive_vars_merged(
    dataset_add = adsl,
    new_vars = exprs(TRTSDT, TRTEDT),
    by_vars = exprs(USUBJID)
  )

## In order to derive both `ASTDT` and `AENDT` in `ADAE`, one can use `derive_vars_dt()`
adae %&gt;%
  derive_vars_dt(
    new_vars_prefix = "AST",
    dtc = AESTDTC,
    date_imputation = "first",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  ) %&gt;%
  derive_vars_dt(
    new_vars_prefix = "AEN",
    dtc = AEENDTC,
    date_imputation = "last",
    min_dates = exprs(TRTSDT),
    max_dates = exprs(TRTEDT)
  )


## While `derive_vars_dt()` can only add one variable at a time, using `call_derivation()`
## one can add multiple variables in one go.
## The function arguments which are different from a variable to another (e.g. `new_vars_prefix`,
## `dtc`, and `date_imputation`) are specified as a list of `params()` in the `variable_params`
## argument of `call_derivation()`. All other arguments which are common to all variables
## (e.g. `min_dates` and `max_dates`) are specified outside of `variable_params` (i.e. in `...`).
call_derivation(
  dataset = adae,
  derivation = derive_vars_dt,
  variable_params = list(
    params(dtc = AESTDTC, date_imputation = "first", new_vars_prefix = "AST"),
    params(dtc = AEENDTC, date_imputation = "last", new_vars_prefix = "AEN")
  ),
  min_dates = exprs(TRTSDT),
  max_dates = exprs(TRTEDT)
)

## The above call using `call_derivation()` is equivalent to the call using `derive_vars_dt()`
## to derive variables `ASTDT` and `AENDT` separately at the beginning.
</code></pre>

<hr>
<h2 id='print_named_list'>Print Named List</h2><span id='topic+print_named_list'></span>

<h3>Description</h3>

<p>Print Named List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_named_list(list, indent = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_named_list_+3A_list">list</code></td>
<td>
<p>A named list</p>
</td></tr>
<tr><td><code id="print_named_list_+3A_indent">indent</code></td>
<td>
<p>Indent
</p>
<p>The output is indented by the specified number of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Utilities for printing: 
<code><a href="#topic+print.adam_templates">print.adam_templates</a>()</code>,
<code><a href="#topic+print.duplicates">print.duplicates</a>()</code>,
<code><a href="#topic+print.source">print.source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print_named_list(death_event)
</code></pre>

<hr>
<h2 id='print.adam_templates'>Print <code>adam_templates</code> Objects</h2><span id='topic+print.adam_templates'></span>

<h3>Description</h3>

<p>Print <code>adam_templates</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adam_templates'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adam_templates_+3A_x">x</code></td>
<td>
<p>A <code>adam_templates</code> object</p>
</td></tr>
<tr><td><code id="print.adam_templates_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_all_templates">list_all_templates()</a></code>
</p>
<p>Utilities for printing: 
<code><a href="#topic+print.duplicates">print.duplicates</a>()</code>,
<code><a href="#topic+print.source">print.source</a>()</code>,
<code><a href="#topic+print_named_list">print_named_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>templates &lt;- list_all_templates()
print(templates)
</code></pre>

<hr>
<h2 id='print.duplicates'>Print <code>duplicates</code> Objects</h2><span id='topic+print.duplicates'></span>

<h3>Description</h3>

<p>Print <code>duplicates</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'duplicates'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.duplicates_+3A_x">x</code></td>
<td>
<p>A <code>duplicates</code> object</p>
</td></tr>
<tr><td><code id="print.duplicates_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Utilities for printing: 
<code><a href="#topic+print.adam_templates">print.adam_templates</a>()</code>,
<code><a href="#topic+print.source">print.source</a>()</code>,
<code><a href="#topic+print_named_list">print_named_list</a>()</code>
</p>

<hr>
<h2 id='print.source'>Print <code>source</code> Objects</h2><span id='topic+print.source'></span>

<h3>Description</h3>

<p>Print <code>source</code> Objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'source'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.source_+3A_x">x</code></td>
<td>
<p>An <code>source</code> object</p>
</td></tr>
<tr><td><code id="print.source_+3A_...">...</code></td>
<td>
<p>If <code style="white-space: pre;">&#8288;indent = &lt;numeric value&gt;&#8288;</code> is specified the output is indented
by the specified number of characters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Utilities for printing: 
<code><a href="#topic+print.adam_templates">print.adam_templates</a>()</code>,
<code><a href="#topic+print.duplicates">print.duplicates</a>()</code>,
<code><a href="#topic+print_named_list">print_named_list</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(death_event)
</code></pre>

<hr>
<h2 id='queries'>Queries Dataset</h2><span id='topic+queries'></span>

<h3>Description</h3>

<p>Queries Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queries
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 15 rows and 8 columns.
</p>


<h3>Source</h3>

<p>An example of standard query dataset to be used in deriving variables in ADAE and ADCM
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adlb">admiral_adlb</a></code>,
<code><a href="#topic+admiral_adsl">admiral_adsl</a></code>,
<code><a href="#topic+ex_single">ex_single</a></code>,
<code><a href="#topic+example_qs">example_qs</a></code>,
<code><a href="#topic+queries_mh">queries_mh</a></code>
</p>

<hr>
<h2 id='queries_mh'>Queries MH Dataset</h2><span id='topic+queries_mh'></span>

<h3>Description</h3>

<p>Queries MH Dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queries_mh
</code></pre>


<h3>Format</h3>

<p>An object of class <code>tbl_df</code> (inherits from <code>tbl</code>, <code>data.frame</code>) with 14 rows and 8 columns.
</p>


<h3>Source</h3>

<p>An example of standard query MH dataset to be used in deriving variables in ADMH
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+admiral_adlb">admiral_adlb</a></code>,
<code><a href="#topic+admiral_adsl">admiral_adsl</a></code>,
<code><a href="#topic+ex_single">ex_single</a></code>,
<code><a href="#topic+example_qs">example_qs</a></code>,
<code><a href="#topic+queries">queries</a></code>
</p>

<hr>
<h2 id='query'>Create an <code>query</code> object</h2><span id='topic+query'></span>

<h3>Description</h3>

<p>A <code>query</code> object defines a query, e.g., a Standard MedDRA Query (SMQ), a
Standardized Drug Grouping (SDG), or a customized query (CQ). It is used
as input to <code>create_query_data()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>query(prefix, name = auto, id = NULL, add_scope_num = FALSE, definition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="query_+3A_prefix">prefix</code></td>
<td>
<p>The value is used to populate <code>PREFIX</code> in the output
dataset of <code>create_query_data()</code>, e.g., <code>"SMQ03"</code></p>
</td></tr>
<tr><td><code id="query_+3A_name">name</code></td>
<td>
<p>The value is used to populate <code>GRPNAME</code> in the output dataset
of <code>create_query_data()</code>. If the <code>auto</code> keyword is specified, the variable
is set to the name of the query in the SMQ/SDG database.
</p>
<p><em>Permitted Values</em>: A character scalar or the <code>auto</code> keyword. The <code>auto</code>
keyword is permitted only for queries which are defined by an
<code>basket_select()</code> object.</p>
</td></tr>
<tr><td><code id="query_+3A_id">id</code></td>
<td>
<p>The value is used to populate <code>GRPID</code> in the output dataset of
<code>create_query_data()</code>. If the <code>auto</code> keyword is specified, the variable is
set to the id of the query in the SMQ/SDG database.
</p>
<p><em>Permitted Values</em>: A integer scalar or the <code>auto</code> keyword. The <code>auto</code>
keyword is permitted only for queries which are defined by an
<code>basket_select()</code> object.</p>
</td></tr>
<tr><td><code id="query_+3A_add_scope_num">add_scope_num</code></td>
<td>
<p>Determines if  <code>SCOPEN</code> in the output dataset
of <code>create_query_data()</code> is populated
</p>
<p>If the parameter is set to <code>TRUE</code>, the definition must be an <code>basket_select()</code>
object.
</p>
<p><em>Default</em>: <code>FALSE</code>
</p>
<p><em>Permitted Values</em>: <code>TRUE</code>, <code>FALSE</code></p>
</td></tr>
<tr><td><code id="query_+3A_definition">definition</code></td>
<td>
<p>Definition of terms belonging to the query
</p>
<p>There are three different ways to define the terms:
</p>

<ul>
<li><p> An <code>basket_select()</code> object is specified to select a query from the SMQ
database.
</p>
</li>
<li><p> A data frame with columns <code>SRCVAR</code> and <code>TERMCHAR</code> or <code>TERMNUM</code> can
be specified to define the terms of a customized query. The <code>SRCVAR</code>
should be set to the name of the variable which should be used to select
the terms, e.g., <code>"AEDECOD"</code> or <code>"AELLTCD"</code>. <code>SRCVAR</code> does not need
to be constant within a query. For example a query can be based on
<code>AEDECOD</code> and <code>AELLT</code>.
</p>
<p>If <code>SRCVAR</code> refers to a character variable, <code>TERMCHAR</code> should be set
to the value the variable. If it refers to a numeric variable, <code>TERMNUM</code>
should be set to the value of the variable. If only character variables
or only numeric variables are used, <code>TERMNUM</code> or <code>TERMCHAR</code> respectively
can be omitted.
</p>
</li>
<li><p> A list of data frames and <code>basket_select()</code> objects can be specified to
define a customized query based on custom terms and SMQs. The data frames
must have the same structure as described for the previous item.
</p>
</li></ul>

<p><em>Permitted Values</em>: an <code>basket_select()</code> object, a
data frame, or a list of data frames and <code>basket_select()</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>query</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_query_data">create_query_data()</a></code>, <code><a href="#topic+basket_select">basket_select()</a></code>, <a href="../articles/queries_dataset.html">Queries Dataset Documentation</a>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a query for an SMQ
library(tibble)
library(dplyr, warn.conflicts = FALSE)

# create a query for a SMQ
query(
  prefix = "SMQ02",
  id = auto,
  definition = basket_select(
    name = "Pregnancy and neonatal topics (SMQ)",
    scope = "NARROW",
    type = "smq"
  )
)

# create a query for an SDG
query(
  prefix = "SDG01",
  id = auto,
  definition = basket_select(
    name = "5-aminosalicylates for ulcerative colitis",
    scope = NA_character_,
    type = "sdg"
  )
)

# creating a query for a customized query
cqterms &lt;- tribble(
  ~TERMCHAR, ~TERMNUM,
  "APPLICATION SITE ERYTHEMA", 10003041L,
  "APPLICATION SITE PRURITUS", 10003053L
) %&gt;%
  mutate(SRCVAR = "AEDECOD")

query(
  prefix = "CQ01",
  name = "Application Site Issues",
  definition = cqterms
)

# creating a customized query based on SMQs and additional terms
query(
  prefix = "CQ03",
  name = "Special issues of interest",
  definition = list(
    cqterms,
    basket_select(
      name = "Pregnancy and neonatal topics (SMQ)",
      scope = "NARROW",
      type = "smq"
    ),
    basket_select(
      id = 8050L,
      scope = "BROAD",
      type = "smq"
    )
  )
)
</code></pre>

<hr>
<h2 id='records_source'>Create a <code>records_source</code> Object</h2><span id='topic+records_source'></span>

<h3>Description</h3>

<p>The <code>records_source</code> object is used to find extreme records of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>records_source(dataset_name, filter = NULL, new_vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="records_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the source dataset
</p>
<p>The name refers to the dataset provided by the <code>source_datasets</code> argument
of <code>derive_param_extreme_record()</code>.</p>
</td></tr>
<tr><td><code id="records_source_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for selecting the observations from
<code>dataset</code>.</p>
</td></tr>
<tr><td><code id="records_source_+3A_new_vars">new_vars</code></td>
<td>
<p>Variables to add
</p>
<p>The specified variables from the source datasets are added to the output
dataset. Variables can be renamed by naming the element, i.e., <code style="white-space: pre;">&#8288;new_vars = exprs(&lt;new name&gt; = &lt;old name&gt;)&#8288;</code>.
</p>
<p>For example <code>new_vars = exprs(var1, var2)</code> adds variables <code>var1</code> and <code>var2</code>
from to the input dataset.
</p>
<p>And <code>new_vars = exprs(var1, new_var2 = old_var2)</code> takes <code>var1</code> and
<code>old_var2</code> from the source dataset and adds them to the input dataset renaming
<code>old_var2</code> to <code>new_var2</code>. Expressions can be used to create new variables
(see for example <code>new_vars</code> argument in <code>derive_vars_merged()</code>).
</p>
<p><em>Permitted Values:</em> list of expressions created by <code>exprs()</code>, e.g.,
<code>exprs(ADT, desc(AVAL))</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>records_source</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_extreme_record">derive_param_extreme_record()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+tte_source">tte_source</a>()</code>
</p>

<hr>
<h2 id='restrict_derivation'>Execute a Derivation on a Subset of the Input Dataset</h2><span id='topic+restrict_derivation'></span>

<h3>Description</h3>

<p>Execute a derivation on a subset of the input dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_derivation(dataset, derivation, args = NULL, filter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_derivation_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="restrict_derivation_+3A_derivation">derivation</code></td>
<td>
<p>Derivation
</p>
<p>A function that performs a specific derivation is expected. A derivation
adds variables or observations to a dataset. The first argument of a
derivation must expect a dataset and the derivation must return a dataset.
The function must provide the <code>dataset</code> argument and all arguments
specified in the <code>params()</code> objects passed to the <code>arg</code> argument.</p>
</td></tr>
<tr><td><code id="restrict_derivation_+3A_args">args</code></td>
<td>
<p>Arguments of the derivation
</p>
<p>A <code>params()</code> object is expected.</p>
</td></tr>
<tr><td><code id="restrict_derivation_+3A_filter">filter</code></td>
<td>
<p>Filter condition</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+params">params()</a></code> <code><a href="#topic+slice_derivation">slice_derivation()</a></code>
</p>
<p>Higher Order Functions: 
<code><a href="#topic+call_derivation">call_derivation</a>()</code>,
<code><a href="#topic+derivation_slice">derivation_slice</a>()</code>,
<code><a href="#topic+slice_derivation">slice_derivation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(tibble)

adlb &lt;- tribble(
  ~USUBJID, ~AVISITN, ~AVAL, ~ABLFL,
  "1",            -1,   113, NA_character_,
  "1",             0,   113, "Y",
  "1",             3,   117, NA_character_,
  "2",             0,    95, "Y",
  "3",             0,   111, "Y",
  "3",             1,   101, NA_character_,
  "3",             2,   123, NA_character_
)

# Derive BASE for post-baseline records only (derive_var_base() can not be used in this case
# as it requires the baseline observation to be in the input dataset)
restrict_derivation(
  adlb,
  derivation = derive_vars_merged,
  args = params(
    by_vars = exprs(USUBJID),
    dataset_add = adlb,
    filter_add = ABLFL == "Y",
    new_vars = exprs(BASE = AVAL)
  ),
  filter = AVISITN &gt; 0
)

# Derive BASE for baseline and post-baseline records only
restrict_derivation(
  adlb,
  derivation = derive_var_base,
  args = params(
    by_vars = exprs(USUBJID)
  ),
  filter = AVISITN &gt;= 0
) %&gt;%
  # Derive CHG for post-baseline records only
  restrict_derivation(
    derivation = derive_var_chg,
    filter = AVISITN &gt; 0
  )
</code></pre>

<hr>
<h2 id='restrict_imputed_dtc_dt'>Restrict Imputed DTC date to Minimum/Maximum Dates</h2><span id='topic+restrict_imputed_dtc_dt'></span>

<h3>Description</h3>

<p>Restrict Imputed DTC date to Minimum/Maximum Dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_imputed_dtc_dt(dtc, imputed_dtc, min_dates, max_dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_imputed_dtc_dt_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dt_+3A_imputed_dtc">imputed_dtc</code></td>
<td>
<p>The imputed DTC date</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dt_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dt_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> The last of the minimum dates (<code>min_dates</code>) which are in the range of the
partial DTC date (<code>dtc</code>)
</p>
</li>
<li><p> The first of the maximum dates (<code>max_dates</code>) which are in the range of the
partial DTC date (<code>dtc</code>)
</p>
</li>
<li> <p><code>imputed_dtc</code> if the partial DTC date (<code>dtc</code>) is not in range of any of
the minimum or maximum dates.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm()</a></code>, <code><a href="#topic+impute_dtc_dt">impute_dtc_dt()</a></code>
</p>
<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dtm">restrict_imputed_dtc_dtm</a>()</code>
</p>

<hr>
<h2 id='restrict_imputed_dtc_dtm'>Restrict Imputed DTC date to Minimum/Maximum Dates</h2><span id='topic+restrict_imputed_dtc_dtm'></span>

<h3>Description</h3>

<p>Restrict Imputed DTC date to Minimum/Maximum Dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restrict_imputed_dtc_dtm(dtc, imputed_dtc, min_dates, max_dates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restrict_imputed_dtc_dtm_+3A_dtc">dtc</code></td>
<td>
<p>The <code>'--DTC'</code> date to impute
</p>
<p>A character date is expected in a format like <code>yyyy-mm-dd</code> or
<code>yyyy-mm-ddThh:mm:ss</code>. Trailing components can be omitted and <code>-</code> is a
valid &quot;missing&quot; value for any component.</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dtm_+3A_imputed_dtc">imputed_dtc</code></td>
<td>
<p>The imputed DTC date</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dtm_+3A_min_dates">min_dates</code></td>
<td>
<p>Minimum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not
before any of the specified dates, e.g., that the imputed adverse event start
date is not before the first treatment date. Only dates which are in the
range of possible dates of the <code>dtc</code> value are considered. The possible dates
are defined by the missing parts of the <code>dtc</code> date (see example below). This
ensures that the non-missing parts of the <code>dtc</code> date are not changed.
A date or date-time object is expected.
For example
</p>
<div class="sourceCode r"><pre>impute_dtc_dtm(
  "2020-11",
  min_dates = list(
   ymd_hms("2020-12-06T12:12:12"),
   ymd_hms("2020-11-11T11:11:11")
  ),
  highest_imputation = "M"
)
</pre></div>
<p>returns <code>"2020-11-11T11:11:11"</code> because the possible dates for <code>"2020-11"</code>
range from <code>"2020-11-01T00:00:00"</code> to <code>"2020-11-30T23:59:59"</code>. Therefore
<code>"2020-12-06T12:12:12"</code> is ignored. Returning <code>"2020-12-06T12:12:12"</code> would
have changed the month although it is not missing (in the <code>dtc</code> date).
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"00:00:00"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
<tr><td><code id="restrict_imputed_dtc_dtm_+3A_max_dates">max_dates</code></td>
<td>
<p>Maximum dates
</p>
<p>A list of dates is expected. It is ensured that the imputed date is not after
any of the specified dates, e.g., that the imputed date is not after the data
cut off date. Only dates which are in the range of possible dates are
considered. A date or date-time object is expected.
</p>
<p>For date variables (not datetime) in the list the time is imputed to
<code>"23:59:59"</code>. Specifying date variables makes sense only if the date is
imputed. If only time is imputed, date variables do not affect the result.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> The last of the minimum dates (<code>min_dates</code>) which are in the range of the
partial DTC date (<code>dtc</code>)
</p>
</li>
<li><p> The first of the maximum dates (<code>max_dates</code>) which are in the range of the
partial DTC date (<code>dtc</code>)
</p>
</li>
<li> <p><code>imputed_dtc</code> if the partial DTC date (<code>dtc</code>) is not in range of any of
the minimum or maximum dates.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+impute_dtc_dtm">impute_dtc_dtm()</a></code>, <code><a href="#topic+impute_dtc_dt">impute_dtc_dt()</a></code>
</p>
<p>Utilities used for date imputation: 
<code><a href="#topic+dt_level">dt_level</a>()</code>,
<code><a href="#topic+dtm_level">dtm_level</a>()</code>,
<code><a href="#topic+get_imputation_target_date">get_imputation_target_date</a>()</code>,
<code><a href="#topic+get_imputation_target_time">get_imputation_target_time</a>()</code>,
<code><a href="#topic+get_partialdatetime">get_partialdatetime</a>()</code>,
<code><a href="#topic+restrict_imputed_dtc_dt">restrict_imputed_dtc_dt</a>()</code>
</p>

<hr>
<h2 id='set_admiral_options'>Set the Value of Admiral Options</h2><span id='topic+set_admiral_options'></span>

<h3>Description</h3>

<p>Set the Values of Admiral Options That Can Be Modified for Advanced Users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_admiral_options(subject_keys, signif_digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_admiral_options_+3A_subject_keys">subject_keys</code></td>
<td>
<p>Variables to uniquely identify a subject, defaults to
<code>exprs(STUDYID, USUBJID)</code>. This option is used as default value for the
<code>subject_keys</code> argument in all admiral functions.</p>
</td></tr>
<tr><td><code id="set_admiral_options_+3A_signif_digits">signif_digits</code></td>
<td>
<p>Holds number of significant digits when comparing to numeric variables,
defaults to <code>15</code>. This option is used as default value for the  <code>signif_dig</code> argument in
admiral functions <code>derive_var_atoxgr_dir()</code> and <code>derive_var_anrind()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Modify an admiral option, e.g <code>subject_keys</code>, such that it automatically affects downstream
function inputs where <code>get_admiral_option()</code> is called such as <code>derive_param_exist_flag()</code>.
</p>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_admiral_option">get_admiral_option()</a></code>, <code><a href="#topic+derive_param_exist_flag">derive_param_exist_flag()</a></code>,<code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>,
<code><a href="#topic+derive_var_dthcaus">derive_var_dthcaus()</a></code>, <code><a href="#topic+derive_var_extreme_dtm">derive_var_extreme_dtm()</a></code>, <code><a href="#topic+derive_vars_period">derive_vars_period()</a></code>,
<code><a href="#topic+create_period_dataset">create_period_dataset()</a></code>, <code><a href="#topic+derive_var_atoxgr_dir">derive_var_atoxgr_dir()</a></code>, <code><a href="#topic+derive_var_anrind">derive_var_anrind()</a></code>
</p>
<p>Other admiral_options: 
<code><a href="#topic+get_admiral_option">get_admiral_option</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lubridate)
library(dplyr, warn.conflicts = FALSE)
library(tibble)
set_admiral_options(subject_keys = exprs(STUDYID, USUBJID2))

# Derive a new parameter for measurable disease at baseline
adsl &lt;- tribble(
  ~USUBJID2,
  "1",
  "2",
  "3"
) %&gt;%
  mutate(STUDYID = "XX1234")

tu &lt;- tribble(
  ~USUBJID2,      ~VISIT,    ~TUSTRESC,
  "1",       "SCREENING",     "TARGET",
  "1",          "WEEK 1",     "TARGET",
  "1",          "WEEK 5",     "TARGET",
  "1",          "WEEK 9", "NON-TARGET",
  "2",       "SCREENING", "NON-TARGET",
  "2",       "SCREENING", "NON-TARGET"
) %&gt;%
  mutate(
    STUDYID = "XX1234",
    TUTESTCD = "TUMIDENT"
  )

derive_param_exist_flag(
  dataset_ref = adsl,
  dataset_add = tu,
  filter_add = TUTESTCD == "TUMIDENT" &amp; VISIT == "SCREENING",
  condition = TUSTRESC == "TARGET",
  false_value = "N",
  missing_value = "N",
  set_values_to = exprs(
    PARAMCD = "MDIS",
    PARAM = "Measurable Disease at Baseline"
  )
)

set_admiral_options(signif_digits = 14)

# Derive ANRIND for ADVS
advs &lt;- tribble(
  ~PARAMCD, ~AVAL, ~ANRLO, ~ANRHI,
  "DIABP",     59,     60,     80,
  "SYSBP",    120,     90,    130,
  "RESP",      21,      8,     20,
)

derive_var_anrind(advs)

</code></pre>

<hr>
<h2 id='signal_duplicate_records'>Signal Duplicate Records</h2><span id='topic+signal_duplicate_records'></span>

<h3>Description</h3>

<p>Signal Duplicate Records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signal_duplicate_records(
  dataset,
  by_vars,
  msg = paste("Dataset contains duplicate records with respect to",
    enumerate(replace_values_by_names(by_vars))),
  cnd_type = "error"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signal_duplicate_records_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset
</p>
<p>The variables specified by the <code>by_vars</code> argument are expected to be in the dataset.</p>
</td></tr>
<tr><td><code id="signal_duplicate_records_+3A_by_vars">by_vars</code></td>
<td>
<p>Grouping variables
</p>
<p>Defines groups of records in which to look for duplicates.
</p>
<p><em>Permitted Values</em>: list of variables created by <code>exprs()</code>
e.g. <code>exprs(USUBJID, VISIT)</code></p>
</td></tr>
<tr><td><code id="signal_duplicate_records_+3A_msg">msg</code></td>
<td>
<p>The condition message</p>
</td></tr>
<tr><td><code id="signal_duplicate_records_+3A_cnd_type">cnd_type</code></td>
<td>
<p>Type of condition to signal when detecting duplicate records.
One of <code>"message"</code>, <code>"warning"</code> or <code>"error"</code>. Default is <code>"error"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>Other internal: 
<code><a href="#topic+admiral-package">admiral-package</a></code>,
<code><a href="#topic+extract_duplicate_records">extract_duplicate_records</a>()</code>,
<code><a href="#topic+format.basket_select">format.basket_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(admiral_adsl)

# Duplicate the first record
adsl &lt;- rbind(admiral_adsl[1L, ], admiral_adsl)

signal_duplicate_records(adsl, exprs(USUBJID), cnd_type = "message")
</code></pre>

<hr>
<h2 id='slice_derivation'>Execute a Derivation with Different Arguments for Subsets of the Input Dataset</h2><span id='topic+slice_derivation'></span>

<h3>Description</h3>

<p>The input dataset is split into slices (subsets) and for each slice the
derivation is called separately. Some or all arguments of the derivation
may vary depending on the slice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_derivation(dataset, derivation, args = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_derivation_+3A_dataset">dataset</code></td>
<td>
<p>Input dataset</p>
</td></tr>
<tr><td><code id="slice_derivation_+3A_derivation">derivation</code></td>
<td>
<p>Derivation
</p>
<p>A function that performs a specific derivation is expected. A derivation
adds variables or observations to a dataset. The first argument of a
derivation must expect a dataset and the derivation must return a dataset.
The function must provide the <code>dataset</code> argument and all arguments
specified in the <code>params()</code> objects passed to the <code>arg</code> argument.
</p>
<p>Please note that it is not possible to specify <code>{dplyr}</code>
functions like <code>mutate()</code> or <code>summarize()</code>.</p>
</td></tr>
<tr><td><code id="slice_derivation_+3A_args">args</code></td>
<td>
<p>Arguments of the derivation
</p>
<p>A <code>params()</code> object is expected.</p>
</td></tr>
<tr><td><code id="slice_derivation_+3A_...">...</code></td>
<td>
<p>A <code>derivation_slice()</code> object is expected
</p>
<p>Each slice defines a subset of the input dataset and some of the parameters
for the derivation. The derivation is called on the subset with the
parameters specified by the <code>args</code> parameter and the <code>args</code> field of the
<code>derivation_slice()</code> object. If a parameter is specified for both, the
value in <code>derivation_slice()</code> overwrites the one in <code>args</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each slice the derivation is called on the subset defined by the
<code>filter</code> field of the <code>derivation_slice()</code> object and with the parameters
specified by the <code>args</code> parameter and the <code>args</code> field of the
<code>derivation_slice()</code> object. If a parameter is specified for both, the
value in <code>derivation_slice()</code> overwrites the one in <code>args</code>.
</p>

<ul>
<li><p> Observations that match with more than one slice are only considered for
the first matching slice.
</p>
</li>
<li><p> Observations with no match to any of the slices are included in the
output dataset but the derivation is not called for them.
</p>
</li></ul>



<h3>Value</h3>

<p>The input dataset with the variables derived by the derivation added
</p>


<h3>See Also</h3>

<p><code><a href="#topic+params">params()</a></code> <code><a href="#topic+restrict_derivation">restrict_derivation()</a></code>
</p>
<p>Higher Order Functions: 
<code><a href="#topic+call_derivation">call_derivation</a>()</code>,
<code><a href="#topic+derivation_slice">derivation_slice</a>()</code>,
<code><a href="#topic+restrict_derivation">restrict_derivation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(tibble)
library(stringr)
advs &lt;- tribble(
  ~USUBJID, ~VSDTC,       ~VSTPT,
  "1",      "2020-04-16", NA_character_,
  "1",      "2020-04-16", "BEFORE TREATMENT"
)

# For the second slice filter is set to TRUE. Thus derive_vars_dtm is called
# with time_imputation = "last" for all observations which do not match for the
# first slice.
slice_derivation(
  advs,
  derivation = derive_vars_dtm,
  args = params(
    dtc = VSDTC,
    new_vars_prefix = "A"
  ),
  derivation_slice(
    filter = str_detect(VSTPT, "PRE|BEFORE"),
    args = params(time_imputation = "first")
  ),
  derivation_slice(
    filter = TRUE,
    args = params(time_imputation = "last")
  )
)
</code></pre>

<hr>
<h2 id='tte_source'>Create a <code>tte_source</code> Object</h2><span id='topic+tte_source'></span>

<h3>Description</h3>

<p>The <code>tte_source</code> object is used to define events and possible censorings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tte_source(dataset_name, filter = NULL, date, censor = 0, set_values_to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tte_source_+3A_dataset_name">dataset_name</code></td>
<td>
<p>The name of the source dataset
</p>
<p>The name refers to the dataset provided by the <code>source_datasets</code> parameter
of <code>derive_param_tte()</code>.</p>
</td></tr>
<tr><td><code id="tte_source_+3A_filter">filter</code></td>
<td>
<p>An unquoted condition for selecting the observations from
<code>dataset</code> which are events or possible censoring time points.</p>
</td></tr>
<tr><td><code id="tte_source_+3A_date">date</code></td>
<td>
<p>A variable or expression providing the date of the event or
censoring. A date, or a datetime can be specified. An unquoted symbol or
expression is expected.
</p>
<p>Refer to <code>derive_vars_dt()</code> or <code>convert_dtc_to_dt()</code> to impute and derive a
date from a date character vector to a date object.</p>
</td></tr>
<tr><td><code id="tte_source_+3A_censor">censor</code></td>
<td>
<p>Censoring value
</p>
<p>CDISC strongly recommends using <code>0</code> for events and positive integers for
censoring.</p>
</td></tr>
<tr><td><code id="tte_source_+3A_set_values_to">set_values_to</code></td>
<td>
<p>A named list returned by <code>exprs()</code> defining the variables
to be set for the event or censoring, e.g. <code>exprs(EVENTDESC = "DEATH", SRCDOM = "ADSL", SRCVAR = "DTHDT")</code>. The values must be a symbol, a
character string, a numeric value, an expression, or <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tte_source</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+derive_param_tte">derive_param_tte()</a></code>, <code><a href="#topic+censor_source">censor_source()</a></code>, <code><a href="#topic+event_source">event_source()</a></code>
</p>
<p>Source Objects: 
<code><a href="#topic+basket_select">basket_select</a>()</code>,
<code><a href="#topic+censor_source">censor_source</a>()</code>,
<code><a href="#topic+death_event">death_event</a></code>,
<code><a href="#topic+event">event</a>()</code>,
<code><a href="#topic+event_joined">event_joined</a>()</code>,
<code><a href="#topic+event_source">event_source</a>()</code>,
<code><a href="#topic+flag_event">flag_event</a>()</code>,
<code><a href="#topic+query">query</a>()</code>,
<code><a href="#topic+records_source">records_source</a>()</code>
</p>

<hr>
<h2 id='use_ad_template'>Open an ADaM Template Script</h2><span id='topic+use_ad_template'></span>

<h3>Description</h3>

<p>Open an ADaM Template Script
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_ad_template(
  adam_name = "adsl",
  save_path = paste0("./", adam_name, ".R"),
  package = "admiral",
  overwrite = FALSE,
  open = interactive()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_ad_template_+3A_adam_name">adam_name</code></td>
<td>
<p>An ADaM dataset name. You can use any of the available dataset name
ADAE, ADCM, ADEG, ADEX, ADLB, ADLBHY, ADMH, ADPC, ADPP, ADPPK, ADSL, ADVS, and the dataset name is case-insensitive. The default dataset
name is ADSL.</p>
</td></tr>
<tr><td><code id="use_ad_template_+3A_save_path">save_path</code></td>
<td>
<p>Path to save the script.</p>
</td></tr>
<tr><td><code id="use_ad_template_+3A_package">package</code></td>
<td>
<p>The R package in which to look for templates. By default <code>"admiral"</code>.</p>
</td></tr>
<tr><td><code id="use_ad_template_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite an existing file named <code>save_path</code>.</p>
</td></tr>
<tr><td><code id="use_ad_template_+3A_open">open</code></td>
<td>
<p>Whether to open the script right away.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Running without any arguments such as <code>use_ad_template()</code> auto-generates adsl.R in
the current path. Use <code>list_all_templates()</code> to discover which templates are available.
</p>


<h3>Value</h3>

<p>No return values, called for side effects
</p>


<h3>See Also</h3>

<p>Utilities used for examples and template scripts: 
<code><a href="#topic+list_all_templates">list_all_templates</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  use_ad_template("adsl")
}
</code></pre>

<hr>
<h2 id='yn_to_numeric'>Map <code>"Y"</code> and <code>"N"</code> to Numeric Values</h2><span id='topic+yn_to_numeric'></span>

<h3>Description</h3>

<p>Map <code>"Y"</code> and <code>"N"</code> to numeric values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yn_to_numeric(arg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yn_to_numeric_+3A_arg">arg</code></td>
<td>
<p>Character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>1</code> if <code>arg</code> equals <code>"Y"</code>, <code>0</code> if <code>arg</code> equals <code>"N"</code>, <code>NA_real_</code> otherwise
</p>


<h3>See Also</h3>

<p>Utilities for Formatting Observations: 
<code><a href="#topic+convert_blanks_to_na">convert_blanks_to_na</a>()</code>,
<code><a href="#topic+convert_na_to_blanks">convert_na_to_blanks</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
yn_to_numeric(c("Y", "N", NA_character_))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
