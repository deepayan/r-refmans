<!DOCTYPE html><html lang="en"><head><title>Help for package rqcanon</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rqcanon}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rqcanon-package'><p>rqcanon: Canonical Quantile Regression</p></a></li>
<li><a href='#boot.can'><p>Bootstrap</p></a></li>
<li><a href='#example_data'><p>Psychological data</p></a></li>
<li><a href='#rqcan'><p>Canonical Quantile Regression.</p></a></li>
<li><a href='#rqcan1'><p>First Component</p></a></li>
<li><a href='#summary.rqcan'><p>Summary of rqcan function results.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Canonical Quantile Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>A quantile regression method for multivariate data to find linear combinations of explanatory and response variables generalizing canonical correlation. The package consists of functions, rqcan() for fitting the coefficients, and summary.rqcan(), which calls a bootstrap function. For details, see the help files for rqcan() and summary.rqcan(), and the reference: Portnoy (2022) &lt;<a href="https://doi.org/10.1016%2Fj.jmva.2022.105071">doi:10.1016/j.jmva.2022.105071</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>quantreg</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-22 17:45:14 UTC; sportnoy</td>
</tr>
<tr>
<td>Author:</td>
<td>Stephen Portnoy [aut, cre],
  Isa Mostachetti [com],
  Daniel Taylor-Rodriguez [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Stephen Portnoy &lt;sportnoy@illinois.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-27 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rqcanon-package'>rqcanon: Canonical Quantile Regression</h2><span id='topic+rqcanon'></span><span id='topic+rqcanon-package'></span>

<h3>Description</h3>

<p>A quantile regression method for multivariate data to find linear combinations of explanatory and response variables generalizing canonical correlations. The package consists of functions, rqcan() for fitting the coefficients, and summary.rqcan(), which calls a bootstrap R-function. For details, see the help files for rqcan() and summary.rqcan(), and the reference: Portnoy (2022) &lt;doi:10.1016/j.jmva.2022.105071&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Stephen Portnoy <a href="mailto:sportnoy@illinois.edu">sportnoy@illinois.edu</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Isa Mostachetti [compiler]
</p>
</li>
<li><p> Daniel Taylor-Rodriguez [reviewer]
</p>
</li></ul>


<hr>
<h2 id='boot.can'>Bootstrap</h2><span id='topic+boot.can'></span>

<h3>Description</h3>

<p>Internal function to carry out the bootstrap ; It is a sub-module of summary.rqcan; not intended for general use. <br />
The parameters may be passed by summary.rqcan (see below)
<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.can(
  a,
  Rep = 200,
  method = "Andrews",
  msub = 0.9,
  seed,
  nsing = 5,
  prb = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.can_+3A_a">a</code></td>
<td>
<p>output from rqcan <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_rep">Rep</code></td>
<td>
<p>number of bootstrap replications (default=200) <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_method">method</code></td>
<td>
<p>&quot;Andrews&quot; (default) or &quot;&quot;xy&quot; <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_msub">msub</code></td>
<td>
<p>parameter defining the size of the bootstrap subsample for developmental work only: see the boot.can function <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_seed">seed</code></td>
<td>
<p>a starting seed (default: missing: no new seed set) <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_nsing">nsing</code></td>
<td>
<p>number of consecutive singular replicatios to ignore (default = 5) <br /></p>
</td></tr>
<tr><td><code id="boot.can_+3A_prb">prb</code></td>
<td>
<p>if TRUE (default = FALSE), print every time 10 percent of the bootstrap samples are done <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>See help(summary.rqcan) ; If errors occur or modification is wanted, see the routine boot.can <br />
</p>


<h3>Value</h3>

<p>Returns list(As, Bs, sdc): As (Bs) are N by dim(alpha) (dim(beta)) arrays of all bootstrap alphs and beta values; sdc = sqrt(m/n): SD adjustment for m-choose-n bootstrap, or 1 for &quot;xy&quot; bootstrap
<br />
</p>

<hr>
<h2 id='example_data'>Psychological data</h2><span id='topic+example_data'></span>

<h3>Description</h3>

<p>A dataset from UCLA Statistical Methods and Data Analytics about
investigating the associations between psychological measures and academic achievement measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_data
</code></pre>


<h3>Format</h3>

<p>## 'example_data'
A data frame with 600 rows and 8 columns:
</p>

<dl>
<dt>locus_of_control</dt><dd><p>Psychological Locus of Control</p>
</dd>
<dt>self_concept</dt><dd><p>Psychological Self Concept</p>
</dd>
<dt>motivation</dt><dd><p>Psychological Motivation</p>
</dd>
<dt>read</dt><dd><p>Academic Reading</p>
</dd>
<dt>write</dt><dd><p>Academic Writing</p>
</dd>
<dt>math</dt><dd><p>Academic Math</p>
</dd>
<dt>science</dt><dd><p>Academic Science</p>
</dd>
<dt>female</dt><dd><p>Binary flag for 1 being female.</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://stats.idre.ucla.edu/stat/data/mmreg.csv&gt;
</p>

<hr>
<h2 id='rqcan'>Canonical Quantile Regression.</h2><span id='topic+rqcan'></span>

<h3>Description</h3>

<p>Given multivariate data matrices X (explanatory variables) and Y (response variables), the function fits coefficients of the Y-variables that are best fit by a quantile regression on X. These are analogous to the coefficients given by a classical canonical correlations analysis, but replace the implicit L2 norm by an L1 norm. See: &quot;Method&quot; and &quot;Reference&quot; below.
</p>
<p>This is a simple S3 class for display formatting purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqcan(
  X,
  Y,
  tau = 0.5,
  a.pos = 1,
  ap = rep(1, na),
  na = ncol(Y),
  wts = rep(1, nrow(X))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqcan_+3A_x">X</code></td>
<td>
<p>input design matrix of explanatory variables (without intercept)</p>
</td></tr>
<tr><td><code id="rqcan_+3A_y">Y</code></td>
<td>
<p>input matrix of response variables (nrow(Y) = nrow(X))</p>
</td></tr>
<tr><td><code id="rqcan_+3A_tau">tau</code></td>
<td>
<p>desired quantile, default = .5</p>
</td></tr>
<tr><td><code id="rqcan_+3A_a.pos">a.pos</code></td>
<td>
<p>for first component: non-empty vector of indices of Y-variables (Y-columns) whose alpha coefficients are constrained to be positive (to provide the direction of increasing responses); default = 1</p>
</td></tr>
<tr><td><code id="rqcan_+3A_ap">ap</code></td>
<td>
<p>for subsequent components j = 2, 3, . . . , na: vector whose (j-1)-th element is the Y-variable (column) index whose alpha coefficients are constrained to be positive; default = rep(1,na-1)</p>
</td></tr>
<tr><td><code id="rqcan_+3A_na">na</code></td>
<td>
<p>number of components desired (1 &lt;= na &lt;= ncol(Y))</p>
</td></tr>
<tr><td><code id="rqcan_+3A_wts">wts</code></td>
<td>
<p>used only for use with the bootstrap methods. If weighting is desired for the sample observations, rqcan will multiply the columns of X and Y by the vector wts; but the bootstrap methods will apply to the unweighted data, and so will be incorrect; default = rep(1,nrow(X)) (unweighted analysis)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Finds orthogonal alpha coefficients and corresponding best-fitting beta coefficients to minimize sum|x_i' beta - y_i' alpha| subject to sum|alpha| = 1 (where x_i and y_i are the i-th rows of X and Y). The intercept is included (X should not include intercept). Need ncol(Y) &gt; 1. For first component: if length(a.pos) &lt; ncol(Y), sum(|alpha|) = 1  is constrained by going through all sign choices (s_j = sign(alpha_j)) and setting Y1_j =  s_j Y_j  (j not in a.pos). A constrained regression quantile fit is applied from quantreg: rq.fit.fnc(cbind(1,X,Y1),y0=0,R,r,tau). where (R,r) constrains all alpha_j &gt;= 0 and sum(alpha_j) &gt;= 1 (sum = 1 at min). Note: rq.fit.fnc solves by generating a sequence of quadratic approximations. The matrix defining one quadratic problem may be singular (and stop the computation) even if he input design matrices are of full rank. If a singularity stop occurs, jittering the data (see jitter()) sometimes helps.For the subsequent j-th component, only the index given by ap(j-1) is constrained to be positive. Alpha coefficients for subsequent components are constrained to be orthogonal to previous alpha coefficients.
</p>


<h3>Value</h3>

<p>object of class &quot;rqcan&quot;; a list of matrices of the alpha and beta coefficients: the j-th row of each matrix is the coefficients for the j-th component; input data and the constraint matrices R an r are also returned in the list
</p>


<h3>Fields</h3>


<dl>
<dt><code>list</code></dt><dd><p>A list.</p>
</dd>
</dl>


<h3>References</h3>

<p>S. Portnoy, 2022. Canonical quantile regression, J. Multivar. Anal., 192, 105071.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+summary.rqcan">summary.rqcan</a> for a description of the summary function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- as.matrix(example_data[,1:3])
Y &lt;- as.matrix(example_data[,4:7])

a &lt;- rqcan(X,Y,tau=.75,a.pos=2)
summary(a)
</code></pre>

<hr>
<h2 id='rqcan1'>First Component</h2><span id='topic+rqcan1'></span>

<h3>Description</h3>

<p>Internal function to find the first component <br />
It is not intended for general use, but the documentation may be helpful if errors occur or if one whishes to modify the algorithms 
<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqcan1(X, Y, tau = 0.5, a.pos = 1, wts = rep(1, nrow(X)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqcan1_+3A_x">X</code></td>
<td>
<p>input X-matrix</p>
</td></tr>
<tr><td><code id="rqcan1_+3A_y">Y</code></td>
<td>
<p>input Y-matrix</p>
</td></tr>
<tr><td><code id="rqcan1_+3A_tau">tau</code></td>
<td>
<p>probability for qualtile (default = .5)</p>
</td></tr>
<tr><td><code id="rqcan1_+3A_a.pos">a.pos</code></td>
<td>
<p>indices of Y-variable whose coefficient is constrained to be positive (default = 1)</p>
</td></tr>
<tr><td><code id="rqcan1_+3A_wts">wts</code></td>
<td>
<p>case weights (default = rep(1,nrow(X)) ) <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function finds the leading pair of indices. Notes: an intercept is added  (X should not include 1st col = 1) ;  ncol(Y) should be &gt; 1 ; length(a.pos) should be at least 1 to specify coef signs (if tau = .5 and a.pos = NULL,  coef and -coef give the same solution) ; for length(a.pos) &lt; ncol(Y), the constraint  sum(|alpha|) = 1  is set by setting Y1_j =  s_j Y_j  (j !in a.pos) where s_j = sgn(alpha_j) ;  all sign choices are used and then constrained rq.fit.fnc( cbind(1,X,Y1),y0=0,R,r,tau) is applied <br /> (R,r) contrains all alpha_j &gt;= 0 and sum(alpha_j) &gt;= 1 (makes sum = 1)
</p>


<h3>Value</h3>

<p>Returns list(a,X,Y,a.pos,R,r,rho1): a = output from rq.fit.fnc(XY,y0,R,r,tau) ; X,Y,a.pos = input data ; R,r = constraint matrices for rq.fit.fnc ; rho1 = rq objective fct. ; if rq.fit.fnc generates a singular matrix, returns &quot;sing&quot; <br />
<br />
</p>

<hr>
<h2 id='summary.rqcan'>Summary of rqcan function results.</h2><span id='topic+summary.rqcan'></span>

<h3>Description</h3>

<p>Uses one of two bootstrap methods to provide Standard Error and confidence intervals for the alpha and beta coefficients for all components. <br />
<br />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rqcan'
summary(object, pr = TRUE, ci = 1, fact = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rqcan_+3A_object">object</code></td>
<td>
<p>rqcan object returned by rqcan</p>
</td></tr>
<tr><td><code id="summary.rqcan_+3A_pr">pr</code></td>
<td>
<p>print tables if TRUE (default)</p>
</td></tr>
<tr><td><code id="summary.rqcan_+3A_ci">ci</code></td>
<td>
<p>type of 95
ci=1: use (adjusted) .025 and .975 percentiles of bootstrap distribution <br />
ci=2: use normal approx with adjusted SE based on interquartile range <br />
ci may be a vector to provide more than one type of interval; default=1 <br /></p>
</td></tr>
<tr><td><code id="summary.rqcan_+3A_fact">fact</code></td>
<td>
<p>a factor to adjust conf ints for components 2:na; used only for development <br /></p>
</td></tr>
<tr><td><code id="summary.rqcan_+3A_...">...</code></td>
<td>
<p>parameters that are sent to the bootstrap function: <br />
Rep: number of bootstrap replications (default=200) <br />
method: &quot;Andrews&quot; (default) or &quot;&quot;xy&quot; <br />
msub: parameter defining the size of the bootstrap subsample for developmental work only: see the boot.can function <br />
seed: a starting seed (default: missing: no new seed set) <br />
nsing: number of consecutive singular replicatios to ignore (default = 5) <br />
prb: if TRUE (default = FALSE), print every time 10 percent of the bootstrap samples are done <br /></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Portnoy reference showed that a subsample bootstrap (as described by Andrews) gives consistent estimates of SE's and confidence intervals. The subsample size is m = ceiling( min(n, max(log(n)*(px+py+1), n^msub)) ) (where n = nrow(X), px = ncol(X), py = ncol(Y)), msub is as above). Some simulations and examples suggest that this is OK. The usual &quot;xy&quot; bootstrap (sampling rows independently with replacement) can be specified. It seems to give similar confidence intervals to &quot;Andrews&quot;, but the SE estimates may be wrong; and no form of consistency has been proven. Note: as noted in help(rqcan), the quantreg function rq.fit.fnc may generate singular matrices even if the input design matrix is of full rank. In simulation examples, this can happen for some bootstrap replications (perhaps less than 1/1000 times). When this occurs, a new bootstrap replication is drawn. If more than nsing consecutive singularities are produced, the bootstrap function returns with those replications that it has already found (a number less than Rep), with a warning. If a singularity warning occurs, using &quot;xy&quot;, or changing the seed or &quot;jittering&quot; the data (see jitter()) sometimes helps. <br />
</p>


<h3>Value</h3>

<p>Returns list(As,Bs,sdc): As and Bs are matrices with Rep rows giving alpha beta coefficients for each bootstrap replication; and sdc is a standard error adjustment based on the subsample bootstrap:   sdc = sqrt(1 - m/n). <br />
<br />
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
