<!DOCTYPE html><html><head><title>Help for package JMbayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {JMbayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#JMbayes'>
<p>Joint Modeling of Longitudinal and Time-to-Event Data in R under a Bayesian Approach</p></a></li>
<li><a href='#aids'><p>Didanosine versus Zalcitabine in HIV Patients</p></a></li>
<li><a href='#anova'><p>Anova Method for Fitted Joint Models</p></a></li>
<li><a href='#aucJM'><p>Time-Dependent ROCs and AUCs for Joint Models</p></a></li>
<li><a href='#bma.combine'><p> Combines Predictions for Bayesian Model Averaging</p></a></li>
<li><a href='#coef'><p>Estimated Coefficients and Confidence Intervals for Joint Models</p></a></li>
<li><a href='#cvDCL'><p>Dynamic Information</p></a></li>
<li><a href='#DerivSplines'><p> Derivatives and Integrals of B-splines and Natural Cubic splines</p></a></li>
<li><a href='#dynCJM'><p>A Dynamic Discrimination Index for Joint Models</p></a></li>
<li><a href='#dynInfo'><p>Dynamic Information of an Extra Longitudinal Measurement</p></a></li>
<li><a href='#fitted &amp; residuals'><p>Fitted Values and Residuals for Joint Models</p></a></li>
<li><a href='#gt'><p> The Generalized Student's t Distribution</p></a></li>
<li><a href='#IndvPred_lme'><p>Individualized Predictions from Linear Mixed Models</p></a></li>
<li><a href='#JMbayesObject'><p>Fitted JMbayes Object</p></a></li>
<li><a href='#jointModelBayes'>
<p>Joint Models for Longitudinal and Time-to-Event Data</p></a></li>
<li><a href='#logLik.JMbayes'><p>Log-Likelihood for Joint Models</p></a></li>
<li><a href='#marglogLik'><p> Calculates Marginal Subject-specific Log-Likelihood Contributions</p></a></li>
<li><a href='#mvglmer'>
<p>Multivariate Mixed Models</p></a></li>
<li><a href='#mvJointModelBayes'>
<p>Multivariate Joint Models for Longitudinal and Time-to-Event Data</p></a></li>
<li><a href='#pbc2'><p>Mayo Clinic Primary Biliary Cirrhosis Data</p></a></li>
<li><a href='#plot'><p>MCMC Diagnostics for Joint Models</p></a></li>
<li><a href='#plot.survfitJM'><p>Plot Method for survfit.JMbayes and survfit.mvJMbayes Objects</p></a></li>
<li><a href='#prederrJM'><p>Prediction Errors for Joint Models</p></a></li>
<li><a href='#predict'><p>Predictions for Joint Models</p></a></li>
<li><a href='#prothro'><p>Prednisone versus Placebo in Liver Cirrhosis Patients</p></a></li>
<li><a href='#ranef'><p>Random Effects Estimates for Joint Models</p></a></li>
<li><a href='#runDynPred'><p> Shiny Application for Dynamic Predictions</p></a></li>
<li><a href='#survfitJM'><p>Prediction in Joint Models</p></a></li>
<li><a href='#tve'><p> Time-Varying Effects using P-splines</p></a></li>
<li><a href='#xtable'><p>xtable Method from Joint Models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Joint Modeling of Longitudinal and Time-to-Event Data under a
Bayesian Approach</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-85</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-01-08</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Shared parameter models for the joint modeling of longitudinal and time-to-event data using MCMC; Dimitris Rizopoulos (2016) &lt;<a href="https://doi.org/10.18637%2Fjss.v072.i07">doi:10.18637/jss.v072.i07</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>nlme, survival, doParallel, rstan</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, foreach, Rcpp, jagsUI, xtable, shiny, splines, Hmisc</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>JAGS (http://mcmc-jags.sourceforge.net)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/drizopoulos/JMbayes">https://github.com/drizopoulos/JMbayes</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-08 11:01:58 UTC; drizo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-09 01:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='JMbayes'>
Joint Modeling of Longitudinal and Time-to-Event Data in R under a Bayesian Approach
</h2><span id='topic+JMbayes-package'></span><span id='topic+JMbayes'></span>

<h3>Description</h3>

<p>This package fits shared parameter models for the joint modeling of normal longitudinal responses and event times 
under a Bayesian approach. Various options for the survival model and the association structure are
provided.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> JMbayes</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8-85</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2020-01-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The package has a single model-fitting function called <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>, which accepts as main arguments a linear
mixed effects object fit returned by function <code>lme()</code> of package <span class="pkg">nlme</span>, and a Cox model object fit returned 
by function <code>coxph()</code> of package <span class="pkg">survival</span>. The <code>survMod</code> argument of specifies the type of survival submodel 
to be fitted; available options are a relative risk model with a Weibull baseline hazard (default) and a relative risk model
with a B-spline approximation of the log baseline risk function. In addition, the <code>param</code> specifies the association structure
between the longitudinal and survival processes; available options are: <code>"td-value"</code> which is the classic formulation used in 
Wulfsohn and Tsiatis (1997); <code>"td-extra"</code> which is a user-defined, possibly time-dependent, term based on the specification of 
the <code>extraForm</code> argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. This could be used to include terms, such as the time-dependent 
slope (i.e., the derivative of the subject-specific linear predictor of the linear mixed model) and the time-dependent cumulative 
effect (i.e., the integral of the subject-specific linear predictor of the linear mixed model); <code>"td-both"</code> which is the 
combination of the previous two parameterizations, i.e., the current value and the user-specified terms are included in the linear 
predictor of the relative risk model; and <code>"shared-RE"</code> where only the random effects of the linear mixed model are included 
in the linear predictor of the survival submodel.
</p>
<p>The package also offers several utility functions that can extract useful information from fitted joint models. The most
important of those are included in the <b>See also</b> Section below.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos
</p>
<p>Maintainer: Dimitris Rizopoulos &lt;d.rizopoulos@erasmusmc.nl&gt;
</p>


<h3>References</h3>

<p>Guo, X. and Carlin, B. (2004) Separate and joint modeling of longitudinal and event time data 
using standard computer packages. <em>The American Statistician</em> <b>54</b>, 16&ndash;24.
</p>
<p>Henderson, R., Diggle, P. and Dobson, A. (2000) Joint modelling of longitudinal measurements 
and event time data. <em>Biostatistics</em> <b>1</b>, 465&ndash;480.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011) Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Rizopoulos, D. and Ghosh, P. (2011) A Bayesian semiparametric multivariate joint model for multiple 
longitudinal outcomes and a time-to-event. <em>Statistics in Medicine</em> <b>30</b>, 1366&ndash;1380.
</p>
<p>Rizopoulos, D., Verbeke, G. and Molenberghs, G. (2010) Multiple-imputation-based residuals and diagnostic 
plots for joint models of longitudinal and survival outcomes. <em>Biometrics</em> <b>66</b>, 20&ndash;29.
</p>
<p>Tsiatis, A. and Davidian, M. (2004) Joint modeling of longitudinal and time-to-event data: an overview. 
<em>Statistica Sinica</em> <b>14</b>, 809&ndash;834.
</p>
<p>Wulfsohn, M. and Tsiatis, A. (1997) A joint model for survival and longitudinal data measured with error. 
<em>Biometrics</em> <b>53</b>, 330&ndash;339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code>,
<code><a href="#topic+survfitJM">survfitJM</a></code>,
<code><a href="#topic+aucJM">aucJM</a></code>,
<code><a href="#topic+dynCJM">dynCJM</a></code>,
<code><a href="#topic+prederrJM">prederrJM</a></code>,
<code><a href="#topic+predict.JMbayes">predict.JMbayes</a></code>,
<code><a href="#topic+logLik.JMbayes">logLik.JMbayes</a></code>
</p>

<hr>
<h2 id='aids'>Didanosine versus Zalcitabine in HIV Patients</h2><span id='topic+aids'></span><span id='topic+aids.id'></span>

<h3>Description</h3>

<p>A randomized clinical trial in which both longitudinal and survival data were collected to compare the efficacy and 
safety of two antiretroviral drugs in treating patients who had failed or were intolerant of zidovudine (AZT) therapy.
</p>


<h3>Format</h3>

<p>A data frame with 1408 observations on the following 9 variables.
</p>

<dl>
<dt><code>patient</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>Time</code></dt><dd><p>the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>CD4</code></dt><dd><p>the CD4 cells count.</p>
</dd>
<dt><code>obstime</code></dt><dd><p>the time points at which the CD4 cells count was recorded.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>ddC</code> denoting zalcitabine and <code>ddI</code> denoting didanosine.</p>
</dd>
<dt><code>gender</code></dt><dd><p>a factor with levels <code>female</code> and <code>male</code>.</p>
</dd>
<dt><code>prevOI</code></dt><dd><p>a factor with levels <code>AIDS</code> denoting previous opportunistic infection (AIDS 
diagnosis) at study entry, and <code>noAIDS</code> denoting no previous infection.</p>
</dd>
<dt><code>AZT</code></dt><dd><p>a factor with levels <code>intolerance</code> and <code>failure</code> denoting AZT intolerance and 
AZT failure, respectively.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>aids.id</code> contains the first CD4 cell count measurement for each patient. This data frame is used to 
fit the survival model.
</p>


<h3>References</h3>

<p>Goldman, A., Carlin, B., Crane, L., Launer, C., Korvick, J., Deyton, L. and Abrams, D. (1996) Response of CD4+ and
clinical consequences to treatment using ddI or ddC in patients with advanced HIV infection. <em>Journal of Acquired
Immune Deficiency Syndromes and Human Retrovirology</em> <b>11</b>, 161&ndash;169.
</p>
<p>Guo, X. and Carlin, B. (2004) Separate and joint modeling of longitudinal and event time data using standard
computer packages. <em>The American Statistician</em> <b>58</b>, 16&ndash;24.
</p>

<hr>
<h2 id='anova'>Anova Method for Fitted Joint Models</h2><span id='topic+anova.JMbayes'></span>

<h3>Description</h3>

<p>Comparison of (non)nested joint models using information criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
anova(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_+3A_object">object</code>, <code id="anova_+3A_...">...</code></td>
<td>
<p>objects inheriting from class <code>JMbayes</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with rows the different models, and columns the number or parameters in each model, the
the log pseudo marginal likelihood value, the deviance information criterion value, and the pD value.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# composite event indicator
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# linear mixed model with natural cubic splines for the time
# effect
lmeFit.pbc1 &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
                   random = ~ ns(year, 2) | id, method = "ML")

# Cox regression model with baseline covariates
coxFit.pbc1 &lt;- coxph(Surv(years, status2) ~ drug * age, data = pbc2.id, x = TRUE)

# the standard joint model fit with only the m_i(t) term in 
# the linear predictor of the survival submodel
jointFit.pbc1 &lt;- jointModelBayes(lmeFit.pbc1, coxFit.pbc1, timeVar = "year")

# we include the time-dependent slopes term
dForm &lt;- list(fixed = ~ 0 + dns(year, 2), random = ~ 0 + dns(year, 2), 
              indFixed = 2:3, indRandom = 2:3)

jointFit.pbc2 &lt;- update(jointFit.pbc1, param = "td-both", extraForm = dForm)

# we include the cumulative effect of the marker
iForm &lt;- list(fixed = ~ 0 + year + ins(year, 2), random = ~ 0 + year + ins(year, 2), 
              indFixed = 1:3, indRandom = 1:3)

jointFit.pbc3 &lt;- update(jointFit.pbc1, param = "td-extra", extraForm = iForm)


# we compare the three models
anova(jointFit.pbc1, jointFit.pbc2, jointFit.pbc3)

## End(Not run)
</code></pre>

<hr>
<h2 id='aucJM'>Time-Dependent ROCs and AUCs for Joint Models</h2><span id='topic+aucJM'></span><span id='topic+rocJM'></span><span id='topic+aucJM.JMbayes'></span><span id='topic+aucJM.mvJMbayes'></span><span id='topic+rocJM.JMbayes'></span><span id='topic+rocJM.mvJMbayes'></span><span id='topic+find_thresholds'></span><span id='topic+find_thresholds.mvJMbayes'></span><span id='topic+predict_eventTime'></span><span id='topic+predict_eventTime.mvJMbayes'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a starting time point, this function computes an estimate 
of the ROC and the AUC at a horizon time point based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aucJM(object, newdata, Tstart, ...)

## S3 method for class 'JMbayes'
aucJM(object, newdata, Tstart, Thoriz = NULL, 
    Dt = NULL, idVar = "id", simulate = FALSE, M = 100, ...)

## S3 method for class 'mvJMbayes'
aucJM(object, newdata, Tstart, Thoriz = NULL, 
    Dt = NULL, idVar = "id", M = 100, ...)

rocJM(object, newdata, Tstart, ...)

## S3 method for class 'JMbayes'
rocJM(object, newdata, Tstart, Thoriz = NULL, 
    Dt = NULL, idVar = "id", simulate = FALSE, M = 100, ...)

## S3 method for class 'mvJMbayes'
rocJM(object, newdata, Tstart, Thoriz = NULL, 
    Dt = NULL, idVar = "id", M = 100, ...)
    
predict_eventTime(object, newdata, cut_points, ...)

## S3 method for class 'mvJMbayes'
predict_eventTime(object, newdata, cut_points, 
    idVar = "id", M = 500L, low_percentile = 0.025, ...)

find_thresholds(object, newdata, Dt, ...)

## S3 method for class 'mvJMbayes'
find_thresholds(object, newdata, Dt, idVar = "id", 
    M = 200L, variability_threshold = NULL,
    n_cores =  max(1, parallel::detectCores() - 2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aucJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code> or <code>mvJMbayes</code>.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="aucJM_+3A_tstart">Tstart</code></td>
<td>
<p>numeric scalar denoting the time point up to which longitudinal information is to be used to derive predictions.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_thoriz">Thoriz</code></td>
<td>
<p>numeric scalar denoting the time point for which a prediction of the survival status is of interest; 
<code>Thoriz</code> must be later than <code>Tstart</code> and either <code>Dt</code> or <code>Thoriz</code> must be specified. If <code>Thoriz</code> is <code>NULL</code>
is set equal to <code>Tstart + Dt</code>.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_dt">Dt</code></td>
<td>
<p>numeric scalar denoting the length of the time interval of prediction; either <code>Dt</code> or <code>Thoriz</code> must be specified.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_cut_points">cut_points</code></td>
<td>
<p>a numeric matrix with first column time-points followed by other columns of 
optimal cut-points from an ROC curve.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_variability_threshold">variability_threshold</code></td>
<td>
<p>numeric value denoting the treshold in the spread of the 
posterior distribution calculated from the 2.5% percentile to the median. Default is
the 25% percentile of the event times distribution.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_low_percentile">low_percentile</code></td>
<td>
<p>a numeric value indicating the percentile based on which it will
be judged whether the spread of the posterior predictive distribution is too large.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_n_cores">n_cores</code></td>
<td>
<p>an integer indicating the number of cores to use for parallel computing.</p>
</td></tr>
<tr><td><code id="aucJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>) and using the data supplied in argument <code>newdata</code>, this function
computes the following estimate of the AUC: </p>
<p style="text-align: center;"><code class="reqn">\mbox{AUC}(t, \Delta t) = \mbox{Pr} \bigl [ \pi_i(t + \Delta t \mid t) &lt; 
\pi_j(t + \Delta t \mid t) \mid \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + \Delta t \} \bigr ],</code>
</p>

<p>with <code class="reqn">i</code> and <code class="reqn">j</code> denote a randomly selected pair of subjects, and
<code class="reqn">\pi_i(t + \Delta t \mid t)</code> and <code class="reqn">\pi_j(t + \Delta t \mid t)</code> denote the conditional survival probabilities calculated by
<code><a href="#topic+survfitJM">survfitJM</a></code> for these two subjects, for different time windows <code class="reqn">\Delta t</code> specified by argument <code>Dt</code> using
the longitudinal information recorded up to time <code>t =</code> <code>Tstart</code>.
</p>
<p>The estimate of <code class="reqn">\mbox{AUC}(t, \Delta t)</code> provided by <code>aucJM()</code> is in the spirit of Harrell's 
<code class="reqn">c</code>-index, that is for the comparable subjects (i.e., the ones whose observed event times can be ordered), we 
compare their dynamic survival probabilities calculated by <code><a href="#topic+survfitJM">survfitJM</a></code>. For the subjects who due to 
censoring we do not know if they are comparable, they contribute in the AUC with the probability that they would
have been comparable.
</p>


<h3>Value</h3>

<p>A list of class <code>aucJM</code> with components:
</p>
<table>
<tr><td><code>auc</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Antolini, L., Boracchi, P., and Biganzoli, E. (2005). A time-dependent discrimination index
for survival data. <em>Statistics in Medicine</em> <b>24</b>, 3927&ndash;3944.
</p>
<p>Harrell, F., Kerry, L. and Mark, D. (1996). Multivariable prognostic models: issues in 
developing models, evaluating assumptions and adequacy, and measuring and reducing errors.
<em>Statistics in Medicine</em> <b>15</b>, 361&ndash;387.
</p>
<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves. 
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# AUC using data up to year 5 with horizon at year 8 
aucJM(jointFit, pbc2, Tstart = 5, Thoriz = 8)

plot(rocJM(jointFit, pbc2, Tstart = 5, Thoriz = 8))

## End(Not run)
</code></pre>

<hr>
<h2 id='bma.combine'> Combines Predictions for Bayesian Model Averaging </h2><span id='topic+bma.combine'></span>

<h3>Description</h3>

<p>Combines estimated survival probabilities or predictions for longitudinal responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bma.combine(..., JMlis = NULL, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bma.combine_+3A_...">...</code></td>
<td>
<p>objects inheriting from class <code>survfit.JMbayes</code> or <code>predict.JMbayes</code>.</p>
</td></tr>
<tr><td><code id="bma.combine_+3A_jmlis">JMlis</code></td>
<td>
<p>a list of <code>survfit.JMbayes</code> or <code>predict.JMbayes</code> objects.</p>
</td></tr>
<tr><td><code id="bma.combine_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of weights to be applied in each object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>survfit.JMbayes</code> or <code>predict.JMbayes</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D., Hatfield, L., Carlin, B. and Takkenberg, J. (2014). Combining dynamic predictions from joint models for longitudinal and time-to-event data using Bayesian model averaging. <em>Journal of the American Statistical Association</em> 
<b>109</b>, 1385&ndash;1397.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit two joint models using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function; the first one with the current value parameterization
# and the other with the shared random effects parameterization
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
              random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)

jointFit1 &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")
jointFit2 &lt;- update(jointFit1, param = "shared-RE")

# we compute survival probabilities for Subject 2 with 
# different weights
ND &lt;- pbc2[pbc2$id == 2, ] # the data of Subject 2
survPreds1 &lt;- survfitJM(jointFit1, newdata = ND, weight = 0.4)
survPreds2 &lt;- survfitJM(jointFit2, newdata = ND, weight = 0.6)

survPreds.bma &lt;- bma.combine(survPreds1, survPreds2)
survPreds.bma
plot(survPreds.bma)

## End(Not run)
</code></pre>

<hr>
<h2 id='coef'>Estimated Coefficients and Confidence Intervals for Joint Models</h2><span id='topic+coef.JMbayes'></span><span id='topic+fixef.JMbayes'></span><span id='topic+confint.JMbayes'></span>

<h3>Description</h3>

<p>Extracts estimated coefficients and confidence intervals from fitted joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
coef(object, process = c("Longitudinal", "Event"), ...)

## S3 method for class 'JMbayes'
fixef(object, process = c("Longitudinal", "Event"), ...)

## S3 method for class 'JMbayes'
confint(object, parm = c("all", "Longitudinal", "Event"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code>.</p>
</td></tr>
<tr><td><code id="coef_+3A_process">process</code></td>
<td>
<p>for which submodel (i.e., linear mixed model or survival model) to extract the estimated 
coefficients.</p>
</td></tr>
<tr><td><code id="coef_+3A_parm">parm</code></td>
<td>
<p>for which submodel (i.e., linear mixed model or survival model) to extract credible intervals.</p>
</td></tr>
<tr><td><code id="coef_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>process = "Event"</code> both methods return the same output. However, for <code>process = "Longitudinal"</code>,
the <code>coef()</code> method returns the subject-specific coefficients, whereas <code>fixef()</code> only the fixed effects.
</p>


<h3>Value</h3>

<p>A numeric vector or a matrix of the estimated parameters or confidence intervals for the fitted model.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+ranef.JMbayes">ranef.JMbayes</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(sqrt(CD4) ~ obstime * drug - drug, 
    random = ~ 1 | patient, data = aids)
# cox model fit
fitCOX &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# joint model fit
fitJOINT &lt;- jointModelBayes(fitLME, fitCOX, 
    timeVar = "obstime")

# fixed effects for the longitudinal process
fixef(fitJOINT)

# fixed effects + random effects estimates for the longitudinal 
# process
coef(fitJOINT)

# fixed effects for the event process
fixef(fitJOINT, process = "Event")
coef(fitJOINT, process = "Event")

## End(Not run)
</code></pre>

<hr>
<h2 id='cvDCL'>Dynamic Information</h2><span id='topic+cvDCL'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a starting time point, this function computes an estimate 
of the cross-entropy function based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvDCL(object, newdata, Tstart, idVar = "id", M = 300L, seed = 123L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvDCL_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="cvDCL_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="cvDCL_+3A_tstart">Tstart</code></td>
<td>
<p>a numeric scalar indicating at which time to compute the cross-entropy.</p>
</td></tr>
<tr><td><code id="cvDCL_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="cvDCL_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="cvDCL_+3A_seed">seed</code></td>
<td>
<p>a numeric scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates an estimate of the cross-entropy at any time point <code class="reqn">t</code> (given in <code>Tstart</code>) that can be
used to identify the joint model that best predicts future event giver survival up to <code class="reqn">t</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>aucJM</code> with components:
</p>
<table>
<tr><td><code>auc</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

cvDCL(jointFit, Tstart = 5)

## End(Not run)
</code></pre>

<hr>
<h2 id='DerivSplines'> Derivatives and Integrals of B-splines and Natural Cubic splines </h2><span id='topic+dns'></span><span id='topic+dbs'></span><span id='topic+ins'></span><span id='topic+ibs'></span>

<h3>Description</h3>

<p>Numerical derivatives and integrals of functions <code>bs()</code> and <code>ns()</code> at their first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dns(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), eps = 1e-03)

dbs(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), eps = 1e-03)

ins(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), from = 0, weight.fun = NULL, 
    integrand.fun = NULL, ...)

ibs(x, df = NULL, knots = NULL, intercept = FALSE, 
    Boundary.knots = range(x), from = 0, weight.fun = NULL, 
    integrand.fun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DerivSplines_+3A_x">x</code>, <code id="DerivSplines_+3A_df">df</code>, <code id="DerivSplines_+3A_knots">knots</code>, <code id="DerivSplines_+3A_intercept">intercept</code>, <code id="DerivSplines_+3A_boundary.knots">Boundary.knots</code></td>
<td>
<p>see the help pages of functions <code>ns()</code> and <code>bs()</code>.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_eps">eps</code></td>
<td>
<p>a numeric scalar denoting the step length for the central difference approximation, which
calculates the derivative.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_from">from</code></td>
<td>
<p>a numeric scalar denoting the lower limit of the integral.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_weight.fun">weight.fun</code></td>
<td>
<p>a function to be applied as weights.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_integrand.fun">integrand.fun</code></td>
<td>
<p>a function to be applied in the integrand.</p>
</td></tr>
<tr><td><code id="DerivSplines_+3A_...">...</code></td>
<td>
<p>extra arguments passed to <code>weight.fun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>dns</code>, <code>dbs</code>, <code>ins</code> or <code>ibs</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>

<hr>
<h2 id='dynCJM'>A Dynamic Discrimination Index for Joint Models</h2><span id='topic+dynCJM'></span><span id='topic+dynCJM.JMbayes'></span>

<h3>Description</h3>

 
<p>This function computes a dynamic discrimination index for joint models based on a weighted average of time-dependent AUCs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynCJM(object, newdata, Dt, ...)

## S3 method for class 'JMbayes'
dynCJM(object, newdata, Dt, idVar = "id", t.max = NULL, 
    simulate = FALSE, M = 100, weightFun = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynCJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_dt">Dt</code></td>
<td>
<p>a numeric scalar denoting the time frame within which the occurrence of events is of interest.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_t.max">t.max</code></td>
<td>
<p>a numeric scalar denoting the time maximum follow-up time up to which the dynamic discrimination index is to be calculated.
If <code>NULL</code>, it is set equal to <code>max(Time) + 1e-05</code> where <code>Time</code> denotes the observed event times.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_weightfun">weightFun</code></td>
<td>
<p>a function of two arguments the first denoting time and the second the length of the time frame of interest, i.e., <code>Dt</code>.</p>
</td></tr>
<tr><td><code id="dynCJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(<b>Note:</b> The following contain some math formulas, which are better viewed in the pdf version 
of the manual accessible at <a href="https://cran.r-project.org/package=JMbayes">https://cran.r-project.org/package=JMbayes</a>.)
</p>
<p>Function <code>dynC</code> computes the following discrimination index
</p>
<p style="text-align: center;"><code class="reqn">\mbox{C}_{dyn}^{\Delta t} = \int_0^{t_{max}} \mbox{AUC}(t, \Delta t) \, 
\mbox{Pr} \{ {\cal E}(t, \Delta t) \} \; dt \Big / \int_0^{t_{max}} \mbox{Pr} \{ {\cal E}(t, \Delta t) \} \; dt,</code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\mbox{AUC}(t, \Delta t) = \mbox{Pr} \bigl [ \pi_i(t + \Delta t \mid t) &lt; 
\pi_j(t + \Delta t \mid t) \mid \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + \Delta t \} \bigr ],</code>
</p>

<p>and </p>
<p style="text-align: center;"><code class="reqn">{\cal E}(t, \Delta t) = \bigl [ \{ T_i^* \in (t, t + \Delta t] \} \cap \{ T_j^* &gt; t + 
\Delta t \} \bigr ],</code>
</p>
<p> with <code class="reqn">i</code> and <code class="reqn">j</code> denote a randomly selected pair subjects, and
<code class="reqn">\pi_i(t + \Delta t \mid t)</code> and <code class="reqn">\pi_j(t + \Delta t \mid t)</code> denote the conditional survival probabilities calculated by
<code><a href="#topic+survfitJM">survfitJM</a></code> for these two subjects, for different time windows <code class="reqn">\Delta t</code> specified by argument <code>Dt</code>. 
The upper limit of integral in specified by argument <code>t.max</code>. The integrals in the numerator and denominator 
are approximated using a 15-point Gauss-Kronrod quadrature rule.
</p>


<h3>Value</h3>

<p>A list of class <code>dynCJM</code> with components:
</p>
<table>
<tr><td><code>dynC</code></td>
<td>
<p>a numeric scalar denoting the dynamic discrimination index.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>a numeric vector of time points at which the AUC was calculated.</p>
</td></tr>
<tr><td><code>AUCs</code></td>
<td>
<p>a numeric vector of the estimated AUCs at the aforementioned time points.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>a numeric vector of the estimated weights at the aforementioned time points.</p>
</td></tr>
<tr><td><code>t.max</code></td>
<td>
<p>a copy of the <code>t.max</code> argument.</p>
</td></tr>
<tr><td><code>Dt</code></td>
<td>
<p>a copy of the <code>Dt</code> argument.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Antolini, L., Boracchi, P., and Biganzoli, E. (2005). A time-dependent discrimination index
for survival data. <em>Statistics in Medicine</em> <b>24</b>, 3927&ndash;3944.
</p>
<p>Harrell, F., Kerry, L. and Mark, D. (1996). Multivariable prognostic models: issues in 
developing models, evaluating assumptions and adequacy, and measuring and reducing errors.
<em>Statistics in Medicine</em> <b>15</b>, 361&ndash;387.
</p>
<p>Heagerty, P. and Zheng, Y. (2005). Survival model predictive accuracy and ROC curves. 
<em>Biometrics</em> <b>61</b>, 92&ndash;105.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+aucJM">aucJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
              random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# dynamic discrimination index up to year 10 using a two-year interval 
dynCJM(jointFit, pbc2, Dt = 2, t.max = 10)

## End(Not run)
</code></pre>

<hr>
<h2 id='dynInfo'>Dynamic Information of an Extra Longitudinal Measurement</h2><span id='topic+dynInfo'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a particular time point, this 
function computes an estimate of the information we again by obtaining an extra
longitudinal measurement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynInfo(object, newdata, Dt, K = 5, M = 500, idVar = "id", 
    simulateFun = function (eta, scale) rnorm(length(eta), eta, scale), 
    seed = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dynInfo_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for
the subject for whom we wish to plan the next measurement. The names of the variables in
this data frame must be the same as in the data frames that were used to fit the linear 
mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In 
addition, this data frame should contain a variable that identifies the subject 
(see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_dt">Dt</code></td>
<td>
<p>numeric scalar denoting the length of the time interval to search for the 
optimal time point of the next measurement, i.e., the interval is <code class="reqn">(t, t + Delta t]</code>
with <code class="reqn">Delta t</code> given by <code>Dt</code>.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_k">K</code></td>
<td>
<p>numeric scalar denoting the number of time points to cosider in the interval 
<code class="reqn">(t, t + Delta t]</code>.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the subject.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_simulatefun">simulateFun</code></td>
<td>
<p>a function based on which longitudinal measurement can be simulated. 
This should have as a main argument the variable <code>eta</code> that denotes the 
subject-specific linear predictor from the mixed model, and possibly a <code>scale</code> 
parameter.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples.</p>
</td></tr>
<tr><td><code id="dynInfo_+3A_seed">seed</code></td>
<td>
<p>a numeric scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions computes the following posterior predictive distribution
</p>
<p style="text-align: center;"><code class="reqn">E_{Y} [ E_{T^* | Y} (\log p (T_j^* \mid T_j^* &gt; u, \{ Y_j(t), y_j(u) \}, 
 D_n \bigr )) ],</code>
</p>
<p> where <code class="reqn">T_j^*</code> denotes the time-to-event for subject <code class="reqn">j</code> for
whom we wish to plan the next visit, <code class="reqn">Y_j(t)</code> the available longitudinal measurements
of this subject up to time <code class="reqn">t</code>, <code class="reqn">y_j(u)</code> the future longitudinal measurement we
wish to plan at time <code class="reqn">u &gt; t</code>, and <code class="reqn">D_n</code> the data set that was used to fit the 
joint model.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>summary</code></td>
<td>
<p>a numeric matrix with first column the time points at which the
longitudinal measurement is hypothetically taken, second column the estimated 
information we gain by obtaining the measurement, and third column the estimated 
cumulative risk of an event up to the particular time point denoted in the first column.</p>
</td></tr>
<tr><td><code>full.results</code></td>
<td>
<p>a numeric matrix with columns representing the time points, rows
the Monte Carlo samples, and entries the value of log posterio predictive density.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 3),
    random = list(id = pdDiag(form = ~ ns(year, 3))), data = pbc2)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

dynInfo(jointFit, newdata = pbc2[pbc2$id == 2, ], Dt = 5)[[1]]

## End(Not run)
</code></pre>

<hr>
<h2 id='fitted+20+26amp+3B+20residuals'>Fitted Values and Residuals for Joint Models</h2><span id='topic+fitted.JMbayes'></span><span id='topic+residuals.JMbayes'></span>

<h3>Description</h3>

<p>Calculates fitted values for joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
fitted(object, 
    process = c("Longitudinal", "longitudinal", "Event", "event"), 
    type = c("Marginal", "marginal", "Subject", "subject"), nullY = FALSE, ...)

## S3 method for class 'JMbayes'
residuals(object, 
    process = c("Longitudinal", "longitudinal", "Event", "event"), 
    type = c("Marginal", "marginal", "Subject", "subject", 
             "Martingale", "martingale", "nullMartingale", "nullmartingale"),
    standardized = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>jointModel</code>.</p>
</td></tr>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_process">process</code></td>
<td>
<p>for which model (i.e., linear mixed model or survival model) to calculate fitted values or residuals.</p>
</td></tr>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_type">type</code></td>
<td>
<p>what type of fitted values or residuals to calculate. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_nully">nullY</code></td>
<td>
<p>logical; if <code>TRUE</code> the association parameters that connect the longitudinal and event time process 
are set to zero.</p>
</td></tr>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_standardized">standardized</code></td>
<td>
<p>logical; if <code>TRUE</code> standardized residuals are calculated.</p>
</td></tr>
<tr><td><code id="fitted+2B20+2B26amp+2B3B+2B20residuals_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>process = "Longitudinal"</code>, let <code class="reqn">X</code> denote the design matrix for the fixed effects <code class="reqn">\beta</code>, and 
<code class="reqn">Z</code> the design matrix for the random effects <code class="reqn">b</code>. Then for <code>type = "Marginal"</code> the fitted values are 
<code class="reqn">X \hat{\beta},</code> whereas for <code>type = "Subject"</code> they are <code class="reqn">X \hat{\beta} + Z \hat{b}</code>, where <code class="reqn">\hat{\beta}</code>
and <code class="reqn">\hat{b}</code> denote the corresponding posterior means for the fixed and random effects. The corresponding residuals 
are calculated by subtracting the fitted values from the observed data <code class="reqn">y</code>. If <code>type = "Subject"</code> and 
<code>standardized = TRUE</code>, the residuals are divided by the estimated residual standard error.
</p>
<p>For <code>process = "Event"</code> function <code>fitted()</code> calculates the cumulative hazard function at each time point a longitudinal
measurement has been recorded. If <code>nullY = TRUE</code>, then the cumulative hazard is calculated without the contribution of the
longitudinal process. Function <code>residuals()</code> calculates the martingales residuals or the martingale residuals without the 
contribution of the longitudinal process when <code>type = "nullMartingale"</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of fitted values or residuals.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
              random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ 1, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

fitted(jointFit, process = "Event")
residuals(jointFit, type = "Subject", standardized = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='gt'> The Generalized Student's t Distribution </h2><span id='topic+dgt'></span><span id='topic+pgt'></span><span id='topic+qgt'></span><span id='topic+rgt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the generalized Student's t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgt(x, mu = 0, sigma = 1, df = stop("no df arg"), log = FALSE)

pgt(q, mu = 0, sigma = 1, df = stop("no df arg")) 

qgt(p, mu = 0, sigma = 1, df = stop("no df arg"))

rgt(n, mu = 0, sigma = 1, df = stop("no df arg"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gt_+3A_x">x</code>, <code id="gt_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="gt_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="gt_+3A_n">n</code></td>
<td>
<p>a numeric scalar denoting the number of observations.</p>
</td></tr>
<tr><td><code id="gt_+3A_mu">mu</code></td>
<td>
<p>a vector of means.</p>
</td></tr>
<tr><td><code id="gt_+3A_sigma">sigma</code></td>
<td>
<p>a vector of standard deviations.</p>
</td></tr>
<tr><td><code id="gt_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code> the density is computed in the log scale.</p>
</td></tr>
<tr><td><code id="gt_+3A_df">df</code></td>
<td>
<p>a numeric scalar denoting the degrees of freedom.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dgt</code> gives the density, <code>pgt</code> gives the distribution function, 
<code>qgt</code> gives the quantile function, and <code>rgt</code> generates random deviates.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- rnorm(10, mean = 10, sd = 3)
dgt(x, mu = 10, sigma = 3, df = 4)
rgt(10, mu = 10, sigma = 3, df = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='IndvPred_lme'>Individualized Predictions from Linear Mixed Models</h2><span id='topic+IndvPred_lme'></span><span id='topic+extract_lmeComponents'></span>

<h3>Description</h3>

<p>Calculates subject-specific predictions for new subjects from a linear mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IndvPred_lme(lmeObject, newdata, timeVar, times = NULL, M = 200L,
    interval = c("confidence", "prediction"), all_times = FALSE,
    level = 0.95, return_data = FALSE, seed = 1L)
    
extract_lmeComponents(lmeObject, timeVar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IndvPred_lme_+3A_lmeobject">lmeObject</code></td>
<td>
<p>an object inheriting from class <code>lme</code> or class <code>lmeComponents</code>.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_newdata">newdata</code></td>
<td>
<p>a data frame in which to look for variables with which to predict.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_timevar">timeVar</code></td>
<td>
<p>a character string specifying the time variable in the linear mixed 
model.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_interval">interval</code></td>
<td>
<p>a character string indicating what type of intervals should be computed.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_all_times">all_times</code></td>
<td>
<p>logical; should predictions be calculated at all <code>times</code> or only 
at the ones that are after the last observed time of each subject.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_level">level</code></td>
<td>
<p>a numeric scalar denoting the tolerance/confidence level.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_times">times</code></td>
<td>
<p>a numeric vector denoting the time points for which we wish to compute the 
subject-specific predictions after the last available measurement provided in 
<code>newdata</code>. Default is a sequence of 100 equally spaced time points 
from the smallest to the largest follow-up time of all subjects.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_m">M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples. 
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_return_data">return_data</code></td>
<td>
<p>logical; if <code>TRUE</code> the data frame supplied in
<code>newdata</code> is returned augmented with the outputs of the function.</p>
</td></tr>
<tr><td><code id="IndvPred_lme_+3A_seed">seed</code></td>
<td>
<p>numeric scalar, the random seed used to produce the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return_data = TRUE</code>, a the data frame <code>newdata</code> with extra rows for the
time points at which predictions were calculated, and extra columns with the predictions
and the limits of the pointwise confidence intervals.
</p>
<p>If <code>return_data = FALSE</code>, a list with components
</p>
<table>
<tr><td><code>times_to_pred</code></td>
<td>
<p>time points at which predictions were calculated.</p>
</td></tr>
<tr><td><code>predicted_y</code></td>
<td>
<p>the predictions.</p>
</td></tr>
<tr><td><code>low</code></td>
<td>
<p>the lower limits of the pointwise confidence intervals.</p>
</td></tr>
<tr><td><code>upp</code></td>
<td>
<p>the upper limits of the pointwise confidence intervals.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.JMbayes">predict.JMbayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * ns(year, 2), data = subset(pbc2, id != 2), 
        random = ~ ns(year, 2) | id)
        
DF &lt;- IndvPred_lme(fitLME, newdata = subset(pbc2, id == 2), timeVar = "year", 
    M = 500, return_data = TRUE)
    
require(lattice)
xyplot(pred + low + upp ~ year | id, data = DF,
    type = "l", col = c(2,1,1), lty = c(1,2,2), lwd = 2,
    ylab = "Average log serum Bilirubin")
    
# extract_lmeComponents() extract the required components from the lme object
# that are required to calculate the predictions; this is a light weight version of
# the object, e.g.,
fitLME_light &lt;- extract_lmeComponents(fitLME, timeVar = "year")

DF &lt;- IndvPred_lme(fitLME_light, newdata = subset(pbc2, id == 2), timeVar = "year", 
    M = 500, return_data = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='JMbayesObject'>Fitted JMbayes Object</h2><span id='topic+JMbayesObject'></span>

<h3>Description</h3>

<p>An object returned by the <code>jointModelBayes</code> function, inheriting from class <code>JMbayes</code> and representing a fitted
joint model for longitudinal and time-to-event data. Objects of this class have methods for the generic functions 
<code>coef</code>, <code>confint</code>, <code>fixed.effects</code>, <code>logLik</code>, <code>plot</code>, <code>print</code>, 
<code>random.effects</code>, <code>summary</code>, and <code>vcov</code>.
</p>


<h3>Value</h3>

<p>The following components must be included in a legitimate <code>JMbayes</code> object.
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>a list with the MCMC samples for each parameter (except from the random effects if control argument <code>keepRE</code> is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code>postMeans</code></td>
<td>
<p>a list with posterior means.</p>
</td></tr>
<tr><td><code>postModes</code></td>
<td>
<p>a list with posterior modes calculated using kernel desnisty estimation.</p>
</td></tr>
<tr><td><code>postVarsRE</code></td>
<td>
<p>a list with the posterior variance-covariance matrix for the random effects of each subject.</p>
</td></tr>
<tr><td><code>StErr</code></td>
<td>
<p>a list with posterior standard errors.</p>
</td></tr>
<tr><td><code>EffectiveSize</code></td>
<td>
<p>a list with effective sample sizes.</p>
</td></tr>
<tr><td><code>StDev</code></td>
<td>
<p>a list with posterior standard deviations.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>a list with 95% credible intervals.</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>the variance-covariance matrix of the model's parameters based.</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>
<p>the pD value.</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>the deviance information criterion value.</p>
</td></tr>
<tr><td><code>CPO</code></td>
<td>
<p>the conditional predictive ordinate value.</p>
</td></tr>
<tr><td><code>LPML</code></td>
<td>
<p>the log pseudo marginal likelihood value.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>the time used to fit the model.</p>
</td></tr>
<tr><td><code>scales</code></td>
<td>
<p>a list with scaling constants in the Metropolis algorithm.</p>
</td></tr>
<tr><td><code>Covs</code></td>
<td>
<p>a list with the covariance matrices of the proposals in the Metropolis algorithm.</p>
</td></tr>
<tr><td><code>acceptRates</code></td>
<td>
<p>a list of acceptance rates.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>a list with the design matrices for the longitudinal and event processes.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list with the response vectors for the longitudinal and event processes.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>a list of data frames with the data used to fit the models.</p>
</td></tr>
<tr><td><code>Terms</code></td>
<td>
<p>a list of terms objects for the various parts of the joint model.</p>
</td></tr>
<tr><td><code>Funs</code></td>
<td>
<p>a list of functions used for the various parts of the joint model.</p>
</td></tr>
<tr><td><code>Forms</code></td>
<td>
<p>a list of formulas for the two submodels.</p>
</td></tr>
<tr><td><code>timeVar</code></td>
<td>
<p>the value of the <code>timeVar</code> argument</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>the value of the <code>control</code> argument.</p>
</td></tr>
<tr><td><code>densLongCheck</code></td>
<td>
<p>a logical indicating whether a scale parameter is required in the longitudinal submodel.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>the value of the <code>param</code> argument.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a list with the specification of the prior distributions for the model's parameters. This has the same components as
the <code>priors</code> argument of the <code><a href="#topic+jointModelBayes">jointModelBayes</a></code> function.</p>
</td></tr>
<tr><td><code>baseHaz</code></td>
<td>
<p>the value of the <code>baseHaz</code> argument.</p>
</td></tr>
<tr><td><code>df.RE</code></td>
<td>
<p>the value of the <code>df.RE</code> argument.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code>
</p>

<hr>
<h2 id='jointModelBayes'>
Joint Models for Longitudinal and Time-to-Event Data
</h2><span id='topic+jointModelBayes'></span>

<h3>Description</h3>

<p>Fits shared parameter joint models for longitudinal and survival outcomes under a Bayesian approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointModelBayes(lmeObject, survObject, timeVar,  
    param = c("td-value", "td-extra", "td-both", "shared-betasRE", "shared-RE"), 
    extraForm = NULL, baseHaz = c("P-splines", "regression-splines"), 
    transFun = NULL, densLong = NULL, lag = 0, df.RE = NULL, 
    estimateWeightFun = FALSE, weightFun = NULL, init = NULL, 
    priors = NULL, scales = NULL, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jointModelBayes_+3A_lmeobject">lmeObject</code></td>
<td>
<p>an object of class 'lme' fitted by function <code>lme()</code> from package <b>nlme</b> or by function <code>glmmPQL()</code> 
from package <b>MASS</b>.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_survobject">survObject</code></td>
<td>
<p>an object of class 'coxph' fitted by function <code>coxph()</code> from package <b>survival</b>.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_timevar">timeVar</code></td>
<td>
<p>a character string indicating the time variable in the mixed effects model.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_param">param</code></td>
<td>
<p>a character string specifying the type of association structure between the longitudinal and 
survival processes. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_extraform">extraForm</code></td>
<td>
<p>a list with components <code>fixed</code> a formula representing the fixed-effects part of the user-defined term, 
<code>indFixed</code> a numeric vector indicating which fixed effects of <code>lmeObject</code> are involved in the user-defined term, 
<code>random</code> a formula representing the random-effects part of the user-defined term, and <code>indRamdom</code> a 
numeric vector indicating which random effects of <code>lmeObject</code> are involved in the user-defined term. 
Required only when <code>param = "td-extra"</code> or <code>param = "td-both"</code>. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_basehaz">baseHaz</code></td>
<td>
<p>a character string specifying the type of the baseline hazard function. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_transfun">transFun</code></td>
<td>
<p>a function or a named list with elements <code>value</code> and <code>extra</code> which should be functions. 
In either case the functions should always have two arguments, namely <code>x</code> and <code>data</code> 
(even when the second one is not needed). The purpose is to transform the <code>value</code> and/or <code>extra</code>,
for example including an interaction term, a nonlinear function, etc.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_denslong">densLong</code></td>
<td>
<p>a function with arguments <code>y</code>, <code>eta.y</code>, <code>scale</code>, <code>log</code>, and <code>data</code> that calculates the
density of the longitudinal outcome. <code>y</code> denotes the longitudinal responses, <code>eta.y</code> the linear predictor that
includes the fixed and random effects, <code>scale</code> a possible scale parameter (e.g., the measurement error standard deviation),
<code>log</code> a logical argument that controls whether the density should be calculated in the log scale, and <code>data</code> a 
data frame which may be used to extract variables used in the definition of the density function (e.g., a censoring indicator for
left censored longitudinal data).</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_lag">lag</code></td>
<td>
<p>a numeric scalar denoting a lag effect in the time-dependent covariate represented by the mixed model; default is 0.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_df.re">df.RE</code></td>
<td>
<p>a numeric scalar denoting the number of degrees of freedom for the Student's-<code class="reqn">t</code> random-effects distribution. If <code>NULL</code>
the random effects are assumed to have a multivariate normal distribution.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_estimateweightfun">estimateWeightFun</code></td>
<td>
<p>logical; experimental, not in use yet.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_weightfun">weightFun</code></td>
<td>
<p>a weight function; experimental, not in use yet.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_init">init</code></td>
<td>
<p>a named list of user-specified initial values:
</p>

<dl>
<dt>betas</dt><dd><p>the vector of fixed effects for the linear mixed effects model.</p>
</dd>
<dt>tau</dt><dd><p>the precision parameter from the linear mixed effects model (i.e., <code class="reqn">\tau = 1/\sigma^2</code> with <code class="reqn">\sigma</code> 
denoting the error terms standard deviation).</p>
</dd>
<dt>invD</dt><dd><p>the inverse variance-covariance matrix of the random effects.</p>
</dd>
<dt>b</dt><dd><p>a matrix of random effects values.</p>
</dd>
<dt>gammas</dt><dd><p>the vector of baseline covariates for the survival model.</p>
</dd>
<dt>alphas</dt><dd><p>the association parameter(s).</p>
</dd>
<dt>Dalphas</dt><dd><p>the association parameter for the true slopes formulation.</p>
</dd>
<dt>Bs.gammas</dt><dd><p>the vector of spline coefficients for the spline-approximated baseline risk function.</p>
</dd>
</dl>

<p>When this list of initial values does not contain some of these components or contains components 
not of the appropriate length, then the default initial values are used instead.
</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_priors">priors</code></td>
<td>
<p>a named list of user-specified prior parameters:
</p>

<dl>
<dt>priorMean.betas</dt><dd><p>the prior mean vector of the normal prior for the fixed effects of the linear mixed effects model.</p>
</dd>
<dt>priorTau.betas</dt><dd><p>the prior precision matrix of the normal prior for the fixed effects of the 
linear mixed effects model.</p>
</dd>
<dt>priorA.tau</dt><dd><p>the prior shape parameter of the Gamma prior for the precision parameter of the 
linear mixed effects model.</p>
</dd>
<dt>priorB.tau</dt><dd><p>the prior rate parameter of the Gamma prior for the precision parameter of the 
linear mixed effects model.</p>
</dd>
<dt>priorMean.gammas</dt><dd><p>the prior mean vector of the normal prior for the regression coefficients of the survival model.</p>
</dd>
<dt>priorTau.gammas</dt><dd><p>the prior precision matrix of the normal prior for the regression coefficients of 
the survival model.</p>
</dd>
<dt>priorMean.alphas</dt><dd><p>the prior mean vector of the normal prior for the association parameter in the survival model.</p>
</dd>
<dt>priorTau.alphas</dt><dd><p>the prior precision matrix of the normal prior for the association parameter in
the survival model.</p>
</dd>
<dt>priorMean.Dalphas</dt><dd><p>the prior mean vector of the normal prior for the slope association parameter 
in the survival model.</p>
</dd>
<dt>priorTau.Dalphas</dt><dd><p>the prior precision matrix of the normal prior for the slope association parameter
in the survival model.</p>
</dd>
<dt>priorMean.Bs.gammas</dt><dd><p>the prior mean vector of the normal prior for the spline coefficients of the 
baseline risk function.</p>
</dd>
<dt>priorTau.Bs.gammas</dt><dd><p>the prior precision matrix of the normal prior for the spline coefficients of 
the baseline risk function.</p>
</dd>
<dt>priorA.tauBs</dt><dd><p>the prior shape parameter of the Gamma prior for the precision parameter of the 
penalty term when <code>baseHaz = "P-splines"</code>.</p>
</dd>
<dt>priorB.tauBs</dt><dd><p>the prior rate parameter of the Gamma prior for the precision parameter of the 
penal term when <code>baseHaz = "P-splines"</code>.</p>
</dd>
<dt>priorR.D</dt><dd><p>the prior precision matrix of the Wishart prior for the precision matrix of the random effects.</p>
</dd>
<dt>priorK.D</dt><dd><p>the degrees of freedom of the Wishart prior for the precision matrix of the random effects.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jointModelBayes_+3A_scales">scales</code></td>
<td>
<p>a named list with names as in <code>init</code> specifying scaling constants for the proposal distributions 
in the Metropolis algorithm.</p>
</td></tr>
<tr><td><code id="jointModelBayes_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>
        
<dl>
<dt>adapt</dt><dd><p>logical default <code>FALSE</code>; should adaptive Metropolis be used. Currently experimental.</p>
</dd>
<dt>n.iter</dt><dd><p>integer specifying the total number of iterations; default is 20000.</p>
</dd>
<dt>n.burnin</dt><dd><p>integer specifying how many of <code>n.iter</code> to discard as burn-in; default is 3000.</p>
</dd>
<dt>n.thin</dt><dd><p>integer specifying the thinning of the chains; default is to set <code>n.thin</code> such that 2000 samples are kept.</p>
</dd>
<dt>n.adapt</dt><dd><p>integer specifying the number of iterations to use for adaptation; default is 3000.</p>
</dd>
<dt>keepRE</dt><dd><p>logical; if <code>TRUE</code> the MCMC samples for the random effect are kept in the output object.</p>
</dd>
<dt>priorVar</dt><dd><p>integer used as the prior precision in the normal prior for the fixed effects, 
the regression coefficients of the survival submodel, the association parameters, the extra association parameters, 
and in the spline coefficients; default is 100.</p>
</dd>
<dt>knots</dt><dd><p>a numeric vector of knots positions for the spline approximation of the log baseline risk function; 
default is <code>NULL</code>, which means that the knots are calculated based on the percentiles of the observed event times.</p>
</dd>
<dt>ObsTimes.knots</dt><dd><p>logical; if <code>TRUE</code> (default), the knots are set using the percentiles of the observed event times
(i.e., including both true events and censored observations). If <code>FALSE</code>, the knots are set based on the percentiles of
the true event times alone.</p>
</dd>
<dt>lng.in.kn</dt><dd><p>a numeric scalar indicating the number of knots to use (based on the percentiles); default is 15 for the penalized
spline baseline hazard and 5 for the regression spline baseline hazard.</p>
</dd>
<dt>ordSpline</dt><dd><p>a numeric scalar setting the order of the spline function. This is the number of coefficients in 
each piecewise polynomial segment, thus a cubic spline has order 4; default is 4.</p>
</dd>
<dt>diff</dt><dd><p>a numeric scalar setting the order of the differences in the calculation of the penalty term for the penalized 
baseline hazard; default is 2.</p>
</dd>
<dt>seed</dt><dd><p>a numeric scalar setting the random seed; default is 1.</p>
</dd>
<dt>verbose</dt><dd><p>logical; if <code>TRUE</code> (default), a progress bar is shown in the console.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="jointModelBayes_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>jointModelBayes</code> fits joint models for longitudinal and survival data under a Bayesian approach. For the longitudinal 
responses a linear mixed effects model represented by the <code>lmeObject</code> is assumed, unless the user specifies his own probability 
density function using argument <code>densLong</code>. For the survival times, let <code class="reqn">w_i</code> denote the vector of baseline covariates in 
<code>survObject</code>, with associated parameter vector <code class="reqn">\gamma</code>, <code class="reqn">m_i(t)</code> the subject-specific linear predictor at time point 
<code class="reqn">t</code> as defined by the mixed model (i.e., <code class="reqn">m_i(t)</code> equals the fixed-effects part <code>+</code> random-effects part of the mixed 
effects model for sample unit <code class="reqn">i</code>), <code class="reqn">m_i'(t)</code> denotes an extra user-defined term (based on the specification of argument 
<code>extraForm</code>) to be included in the linear predictor of the survival submodel, and <code class="reqn">\alpha</code> and <code class="reqn">\alpha_e</code> vector of 
association parameters for <code class="reqn">m_i(t)</code> and <code class="reqn">m_i'(t)</code>, respectively. Then, <code>jointModelBayes</code>
assumes a relative risk model of the form </p>
<p style="text-align: center;"><code class="reqn">h_i(t) = h_0(t) \exp\{\gamma^\top w_i + f(m_i(t), m_i'(t), b_i; \alpha, \alpha_e)\},</code>
</p>
 
<p>where the baseline risk function is approximated using splines, i.e., </p>
<p style="text-align: center;"><code class="reqn">\log h_0(t) = \sum_k \tilde\gamma_k B(t; \lambda),</code>
</p>
 
<p>with <code class="reqn">B(.)</code> denoting a B-spline basis function, <code class="reqn">\lambda</code> a vector of knots, and <code class="reqn">\tilde \gamma_k</code> the corresponding 
splines coefficients (<code class="reqn">\tilde \gamma</code> correspond to <code>Bs.gammas</code> above). Argument <code>baseHaz</code> specifies whether a 
penalized- or regression-spline-approximation is employed. For the former the P-splines approach of Eilers and Marx (1996) is used, 
namely the prior for <code class="reqn">\tilde \gamma</code> is taken to be proportional to </p>
<p style="text-align: center;"><code class="reqn">p(\tilde \gamma) \propto 
\exp \Bigl(- \frac{\tau_{bs}}{2} \tilde \gamma^\top \Delta^\top \Delta \tilde \gamma \Bigr),</code>
</p>
<p> where <code class="reqn">\Delta</code> denotes the 
differences matrix (the order of the differences is set by the control argument <code>diff</code>).
</p>
<p>Function <code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d)</code> specifies the association structure between the two processes. In particular, for
<code>param = "td-value"</code>, </p>
<p style="text-align: center;"><code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d) = f_1(m_i(t)) \alpha,</code>
</p>
<p> for <code>param = "td-extra"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d) = f_2(m_i'(t)) \alpha_e,</code>
</p>
<p> for <code>param = "td-both"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d) = f_1(m_i(t)) \alpha + f_2(m_i'(t)) \alpha_e,</code>
</p>
<p> for <code>param = "shared-RE"</code>, 
</p>
<p style="text-align: center;"><code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d) = \alpha^\top b_i,</code>
</p>
<p> and for <code>param = "shared-betasRE"</code>,
</p>
<p style="text-align: center;"><code class="reqn">f(m_i(t), m_i'(t), b_i; \alpha, \alpha_d) = \alpha^\top (\beta^* + b_i),</code>
</p>
<p> where <code class="reqn">f_1(.)</code> and <code class="reqn">f_2(.)</code> denote possible
transformation functions, <code class="reqn">b_i</code> denotes the vector of random effects for 
the <code class="reqn">i</code>th subject and <code class="reqn">\beta^*</code> the fixed effects that correspond to the random effects.
</p>


<h3>Value</h3>

<p>See <code><a href="#topic+JMbayesObject">JMbayesObject</a></code> for the components of the fit.
</p>


<h3>Note</h3>

<p>1. The <code>lmeObject</code> argument should represent a mixed model object without any special structure in the random-effects
covariance matrix (i.e., no use of <code>pdMats</code>).
</p>
<p>2. The <code>lmeObject</code> object should not contain any within-group correlation structure (i.e., <code>correlation</code> 
argument of <code>lme()</code>) or within-group heteroscedasticity structure (i.e., <code>weights</code> argument of <code>lme()</code>).
</p>
<p>3. It is assumed that the linear mixed effects model <code>lmeObject</code> and the survival model <code>survObject</code> have been 
fitted to the same subjects. Moreover, it is assumed that the ordering of the subjects is the same for both 
<code>lmeObject</code> and <code>survObject</code>, i.e., that the first line in the data frame containing the event times 
corresponds to the first set of lines identified by the grouping variable in the data frame containing the repeated 
measurements, and so on. Furthermore, the scale of the time variable (e.g., days, months, years) should be the same in both
the <code>lmeObject</code> and <code>survObject</code> objects.
</p>
<p>4. In the <code>print</code> and <code>summary</code> generic functions for class <code>jointModel</code>, the estimated coefficients (and
standard errors for the <code>summary</code> generic) for the event process are augmented with the element &quot;Assoct&quot; that 
corresponds to the association parameter <code class="reqn">\alpha</code> and the element &quot;AssoctE&quot; that corresponds to the parameter 
<code class="reqn">\alpha_e</code> when <code>parameterization</code> is <code>"td-extra"</code> or <code>"td-both"</code> (see <b>Details</b>).
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2000) Joint modelling of longitudinal measurements and event time data.
<em>Biostatistics</em> <b>1</b>, 465&ndash;480.
</p>
<p>Hsieh, F., Tseng, Y.-K. and Wang, J.-L. (2006) Joint modeling of survival and longitudinal data: Likelihood 
approach revisited. <em>Biometrics</em> <b>62</b>, 1037&ndash;1043.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: With 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011) Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Tsiatis, A. and Davidian, M. (2004) Joint modeling of longitudinal and time-to-event data: an overview. 
<em>Statistica Sinica</em> <b>14</b>, 809&ndash;834.
</p>
<p>Wulfsohn, M. and Tsiatis, A. (1997) A joint model for survival and longitudinal data measured with error. 
<em>Biometrics</em> <b>53</b>, 330&ndash;339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.JMbayes">coef.JMbayes</a></code>,
<code><a href="#topic+ranef.JMbayes">ranef.JMbayes</a></code>, 
<code><a href="#topic+logLik.JMbayes">logLik.JMbayes</a></code>, 
<code><a href="#topic+survfitJM">survfitJM</a></code>,
<code><a href="#topic+aucJM">aucJM</a></code>,
<code><a href="#topic+dynCJM">dynCJM</a></code>,
<code><a href="#topic+prederrJM">prederrJM</a></code>, 
<code><a href="#topic+predict.JMbayes">predict.JMbayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# A joint model for the AIDS dataset:
# First we fit the linear mixed model for the longitudinal measurements of
# sqrt CD4 cell counts
lmeFit.aids &lt;- lme(CD4 ~ obstime * drug, random = ~ obstime | patient, data = aids)
# next we fit the Cox model for the time to death (including the 'x = TRUE' argument)
survFit.aids &lt;- coxph(Surv(Time, death) ~ drug, data = aids.id, x = TRUE)

# the corresponding joint model is fitted by (the default is to assume 
# the current value parameterization)
jointFit.aids &lt;- jointModelBayes(lmeFit.aids, survFit.aids, timeVar = "obstime")
summary(jointFit.aids)

# A joint model for the PBC dataset:
# We first fit the linear mixed and Cox models. In the first we include 
# splines to model flexibly the subject-specific longitudinal trajectories
lmeFit.pbc &lt;- lme(log(serBilir) ~ ns(year, 2),
    random = list(id = pdDiag(form = ~ ns(year, 2))), data = pbc2)
survFit.pbc &lt;- coxph(Surv(years, status2) ~ 1, data = pbc2.id, x = TRUE)

# the corresponding joint model is fitted by:
jointFit.pbc &lt;- jointModelBayes(lmeFit.pbc, survFit.pbc, timeVar = "year", 
    baseHaz = "regression-splines")
summary(jointFit.pbc)

# we update the joint model fitted for the PBC dataset by including
# the time-dependent slopes term. To achieve this we need to define 
# the 'extraForm' argument, in which we use function dns() to numerically
# compute the derivative of the natural cubic spline. In addition, we increase
# the number of MCMC iterations to 35000
dform = list(fixed = ~ 0 + dns(year, 2), random = ~ 0 + dns(year, 2),
    indFixed = 2:3, indRandom = 2:3)
jointFit.pbc2 &lt;- update(jointFit.pbc, param = "td-both", extraForm = dform,
    n.iter = 35000)
summary(jointFit.pbc2)

# we fit the same model with the shared random effects formulation
jointFit.pbc3 &lt;- update(jointFit.pbc, param = "shared-betasRE")
summary(jointFit.pbc3)

# a joint model for left censored longitudinal data
# we create artificial left censoring in serum bilirubin
pbc2$CensInd &lt;- as.numeric(pbc2$serBilir &lt;= 0.8)
pbc2$serBilir2 &lt;- pbc2$serBilir
pbc2$serBilir2[pbc2$CensInd == 1] &lt;- 0.8

censdLong &lt;- function (y, eta.y, scale, log = FALSE, data) {
    log.f &lt;- dnorm(x = y, mean = eta.y, sd = scale, log = TRUE)
    log.F &lt;- pnorm(q = y, mean = eta.y, sd = scale, log.p = TRUE)
    ind &lt;- data$CensInd
    if (log) {
        (1 - ind) * log.f + ind * log.F
    } else {
        exp((1 - ind) * log.f + ind * log.F)
    }
}
lmeFit.pbc2 &lt;- lme(log(serBilir2) ~ ns(year, 2), data = pbc2,
                   random = ~ ns(year, 2) | id, method = "ML")
jointFit.pbc4 &lt;- jointModelBayes(lmeFit.pbc2, survFit.pbc, timeVar = "year",
                                  densLong = censdLong)

summary(jointFit.pbc4)

# a joint model for a binary outcome
pbc2$serBilirD &lt;- 1 * (pbc2$serBilir &gt; 1.8)
lmeFit.pbc3 &lt;- glmmPQL(serBilirD ~ year, random = ~ year | id, 
	family = binomial, data = pbc2)

dLongBin &lt;- function (y, eta.y, scale, log = FALSE, data) {
    dbinom(x = y, size = 1, prob = plogis(eta.y), log = log)
}

jointFit.pbc5 &lt;- jointModelBayes(lmeFit.pbc3, survFit.pbc, timeVar = "year", 
	densLong = dLongBin)

summary(jointFit.pbc5)


# create start-stop counting process variables
pbc &lt;- pbc2[c("id", "serBilir", "drug", "year", "years",
              "status2", "spiders")]
pbc$start &lt;- pbc$year
splitID &lt;- split(pbc[c("start", "years")], pbc$id)
pbc$stop &lt;- unlist(lapply(splitID,
                          function (d) c(d$start[-1], d$years[1]) ))
pbc$event &lt;- with(pbc, ave(status2, id,
                           FUN = function (x) c(rep(0, length(x)-1), x[1])))
pbc &lt;- pbc[!is.na(pbc$spiders), ]

# left-truncation
pbc &lt;- pbc[pbc$start != 0, ] 

lmeFit.pbc &lt;- lme(log(serBilir) ~ drug * ns(year, 2),
                  random = ~ ns(year, 2) | id, data = pbc)

tdCox.pbc &lt;- coxph(Surv(start, stop, event) ~ drug * spiders + cluster(id),
                   data = pbc, x = TRUE, model = TRUE)

jointFit.pbc6 &lt;- jointModelBayes(lmeFit.pbc, tdCox.pbc, timeVar = "year")

summary(jointFit.pbc6)

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.JMbayes'>Log-Likelihood for Joint Models</h2><span id='topic+logLik.JMbayes'></span>

<h3>Description</h3>

<p>Computes the log-likelihood for a fitted joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
logLik(object, thetas, b, priors = TRUE, marginal.b = TRUE, 
    marginal.thetas = FALSE, full.Laplace = FALSE, useModes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.JMbayes_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_thetas">thetas</code></td>
<td>
<p>a list with values for the joint model's parameters. This should have the same structure as
the <code>coefficients</code> component of a fitted joint model. If missing <code>object$postMeans</code> is used.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_b">b</code></td>
<td>
<p>a numeric matrix with random effects value. This should have the same structure as
the <code>ranef</code> component of a fitted joint model. If missing <code>ranef(object)</code> is used.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_priors">priors</code></td>
<td>
<p>logical, if <code>TRUE</code> the priors are also included in the computation.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_marginal.b">marginal.b</code></td>
<td>
<p>logical, if <code>TRUE</code> the marginal log-likelihood over the random effects is returned.
This marginalization is done using a Laplace approximation.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_marginal.thetas">marginal.thetas</code></td>
<td>
<p>logical, if <code>TRUE</code> the marginal log-likelihood over the parameters is returned.
This marginalization is done using a Laplace approximation.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_full.laplace">full.Laplace</code></td>
<td>
<p>logical, if <code>FALSE</code> the posterior means and posterior variances are used in the Laplace
approximation instead of the posterior modes and posterior hessian matrix of the random effects. Sacrificing a bit of
accuracy, this will be much faster than calculating the posterior modes. Relevant only when <code>marginal.b = TRUE</code>.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_usemodes">useModes</code></td>
<td>
<p>logical, if <code>TRUE</code> the modes are used in the Laplace approximation otherwise the means.</p>
</td></tr>
<tr><td><code id="logLik.JMbayes_+3A_...">...</code></td>
<td>
<p>extra arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">y_i</code> denote the vectors of longitudinal responses, <code class="reqn">T_i</code> the observed event time, and <code class="reqn">\delta_i</code> 
the event indicator for subject <code class="reqn">i</code> (<code class="reqn">i = 1, \ldots, n</code>). Let also <code class="reqn">p(y_i | b_i; \theta)</code> denote the probability
density function (pdf) for the linear mixed model, <code class="reqn">p(T_i, \delta_i | b_i; \theta)</code> the pdf for the survival submodel, and
<code class="reqn">p(b_i; \theta)</code> the multivariate normal pdf for the random effects, where <code class="reqn">\theta</code> denotes the full parameter vector. Then,
if <code>priors = TRUE</code>, and <code>marginal.b = TRUE</code>, function <code>logLik()</code> computes 
</p>
<p style="text-align: center;"><code class="reqn">\log \int p(y_i | b_i; \theta) p(T_i, \delta_i | b_i; \theta) p(b_i; \theta) db_i + \log p(\theta),</code>
</p>

<p>where <code class="reqn">p(\theta)</code> denotes the prior distribution for the parameters. If <code>priors = FALSE</code> the prior is excluded from the
computation, i.e., </p>
<p style="text-align: center;"><code class="reqn">\log \int p(y_i | b_i; \theta) p(T_i, \delta_i | b_i; \theta) p(b_i; \theta) db_i,</code>
</p>
<p> and when 
<code>marginal.b = FALSE</code>, then the conditional on the random effects log-likelihood is computed, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">\log p(y_i | b_i; \theta) + \log p(T_i, \delta_i | b_i; \theta) + \log p(b_i; \theta) + \log p(\theta),</code>
</p>
<p> when 
<code>priors = TRUE</code> and </p>
<p style="text-align: center;"><code class="reqn">\log p(y_i | b_i; \theta) + \log p(T_i, \delta_i | b_i; \theta) + \log p(b_i; \theta),</code>
</p>

<p>when <code>priors = FALSE</code>.
</p>


<h3>Value</h3>

<p>a numeric scalar of class <code>logLik</code> with the value of the log-likelihood. It also has
the attributes <code>df</code> the number of parameter (excluding the random effects), and <code>nobs</code>
the number of subjects. 
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D., Hatfield, L., Carlin, B. and Takkenberg, J. (2014). Combining dynamic predictions from joint models for longitudinal and time-to-event data using Bayesian model averaging. <em>Journal of the American Statistical Association</em>. to appear.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2, 
    random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ 1, data = pbc2.id, x = TRUE)

jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

logLik(jointFit)
logLik(jointFit, priors = FALSE)
logLik(jointFit, marginal.b = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='marglogLik'> Calculates Marginal Subject-specific Log-Likelihood Contributions </h2><span id='topic+marglogLik'></span>

<h3>Description</h3>

<p>This function computes marginal subject-specific log-likelihood contributions based on a fitted joint model. The marginalization is done
with respect to both the random effects and the parameters using a Laplace approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marglogLik(object, newdata, idVar = "id", method = "BFGS", control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marglogLik_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="marglogLik_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="marglogLik_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="marglogLik_+3A_method">method</code></td>
<td>
<p>the <code>method</code> argument of <code>optim()</code>.</p>
</td></tr>
<tr><td><code id="marglogLik_+3A_control">control</code></td>
<td>
<p>the <code>control</code> argument of <code>optim()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector of marginal log-likelihood contributions.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit a joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
    random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)

jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# we compute marginal log-likelihood contribution for Subject 2
ND &lt;- pbc2[pbc2$id == 2, ] # the data of Subject 2
marglogLik(jointFit, newdata = ND)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvglmer'>
Multivariate Mixed Models
</h2><span id='topic+mvglmer'></span>

<h3>Description</h3>

<p>Fits multivariate mixed models under a Bayesian approach using JAGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvglmer(formulas, data, families, engine = c("JAGS", "STAN"), 
    overdispersion = FALSE, priors = NULL, init = NULL, control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvglmer_+3A_formulas">formulas</code></td>
<td>
<p>a list of R formulas representing the mixed models; 
these should be <b>lme4</b>-type formulas.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_data">data</code></td>
<td>
<p>a data.frame that contains all the variable to be used when fitting the
multivariate mixed model.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_families">families</code></td>
<td>
<p>a list of families objects correspond to each outcome.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_engine">engine</code></td>
<td>
<p>a character string indicating whether to use JAGS or STAN to fit the model.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_overdispersion">overdispersion</code></td>
<td>
<p>logical; for Poisson outcomes, should an overdispersion parameter
be included.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_priors">priors</code></td>
<td>
<p>a named list of user-specified prior parameters:
</p>

<dl>
<dt>taus_betas</dt><dd><p>the prior precision parameter for the fixed effects; default
is 0.001.</p>
</dd>
<dt>priorK.D</dt><dd><p>degrees of freedom for the wishart prior for the inverse
covariance matrix of the random effects; default is number of random effects 
plus one.</p>
</dd>
<dt>priorR.D</dt><dd><p>precision matrix of the wishart prior for the inverse
covariance matrix of the random effects; default to a diagonal matrix with
diagonal ellements given a Gamma prior with parameters <code>A_R.D</code> and 
<code>A_R.D</code>.</p>
</dd>
<dt>A_R.D</dt><dd><p>the prior shape parameter of the Gamma prior for the diagonal 
elements of the precision matrix of the wishart prior for the inverse 
covariance matrix of the random effects; default is 0.5.</p>
</dd>
<dt>B_R.D</dt><dd><p>the prior shape parameter of the Gamma prior for the diagonal 
elements of the precision matrix of the wishart prior for the inverse 
covariance matrix of the random effects; default is 0.001.</p>
</dd>
<dt>tau_half_cauchy</dt><dd><p>prior precision parameter of a half-Cauchy distribution for 
the precision parameter of a random intercept, when only a single outcome is
specified with a single random effect; default is 0.1.</p>
</dd>
<dt>A_tau</dt><dd><p>the prior shape parameter for the precision of the error terms of
Gaussian outcomes.</p>
</dd>
<dt>B_tau</dt><dd><p>the prior rate parameter for the precision of the error terms of
Gaussian outcomes.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mvglmer_+3A_init">init</code></td>
<td>
<p>a list of initial values.</p>
</td></tr>
<tr><td><code id="mvglmer_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>
        
<dl>
<dt>n.iter</dt><dd><p>integer specifying the total number of iterations after burn in; 
default is 28000.</p>
</dd>
<dt>n.burnin</dt><dd><p>integer specifying how many of iterations to discard as burn-in; 
default is 3000.</p>
</dd>
<dt>n.thin</dt><dd><p>integer specifying the thinning of the chains; 
default is 50.</p>
</dd>
<dt>n.adapt</dt><dd><p>integer specifying the number of adapt iterations in which the 
acceptance rates are checked; default is 3000.</p>
</dd>
<dt>n.chains</dt><dd><p>integer specifying the number of chains to use; default is 2.</p>
</dd>
<dt>n.processors</dt><dd><p>integer specifying the number of processors to use; 
default is the number of available processors minus one.</p>
</dd>
<dt>working.directory</dt><dd><p>a character string giving the path on where to save
the JAGS model; default is the working directory.</p>
</dd>
<dt>clear.model</dt><dd><p>logical; should the JAGS models be deleted after the model has
run; default is <code>TRUE</code>.</p>
</dd>
<dt>seed</dt><dd><p>an integer setting the random seed; default is 1.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mvglmer_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates a JAGS program representing a multivariate mixed effects that is run
with JAGS using the <b>jagsUI</b> package. Currently only Gaussian, Bernoulli and Poisson
longitudinal outcomes can be handled. 
</p>


<h3>Value</h3>

<p>A list of class <code>mvglmer</code> with components:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>a list with the MCMC samples for each parameter.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>a list with design matrices and responses vectors extracted by applying
the <code>formulas</code> in <code>data</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a copy of <code>data</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the <code>control</code> values used in the fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>a list with information over the MCMC (i.e., time it took, iterations, 
etc.).</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>the DIC value for the fitted model.</p>
</td></tr>
<tr><td><code>pD</code></td>
<td>
<p>the pD valu for the fitted model.</p>
</td></tr>
<tr><td><code>Rhat</code></td>
<td>
<p>a list with the Rhat convergence diagnostics for each parameter.</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a copy of the priors used.</p>
</td></tr>
<tr><td><code>postMeans</code></td>
<td>
<p>a list with posterior means.</p>
</td></tr>
<tr><td><code>postModes</code></td>
<td>
<p>a list with posterior modes calculated using kernel desnisty estimation.</p>
</td></tr>
<tr><td><code>EffectiveSize</code></td>
<td>
<p>a list with effective sample sizes.</p>
</td></tr>
<tr><td><code>StErr</code></td>
<td>
<p>a list with posterior standard errors.</p>
</td></tr>
<tr><td><code>StDev</code></td>
<td>
<p>a list with posterior standard deviations.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>a list with 95% credible intervals.</p>
</td></tr>
<tr><td><code>Pvalues</code></td>
<td>
<p>a list of tail probabilities for containg the zero value.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvJointModelBayes">mvJointModelBayes</a></code>,
<code><a href="#topic+jointModelBayes">jointModelBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
MixedModelFit &lt;- mvglmer(list(log(serBilir) ~ year + (year | id),
                               spiders ~ year + (1 | id)), data = pbc2,
                          families = list(gaussian, binomial))

summary(MixedModelFit)
plot(MixedModelFit)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvJointModelBayes'>
Multivariate Joint Models for Longitudinal and Time-to-Event Data
</h2><span id='topic+mvJointModelBayes'></span>

<h3>Description</h3>

<p>Fits multivariate shared parameter joint models for longitudinal and survival outcomes under a Bayesian approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvJointModelBayes(mvglmerObject, survObject, timeVar,
    Formulas = list(NULL), Interactions = list(NULL),
    transFuns = NULL, priors = NULL, multiState = FALSE, 
    data_MultiState = NULL, idVar_MultiState = "id", 
    control = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvJointModelBayes_+3A_mvglmerobject">mvglmerObject</code></td>
<td>
<p>an object of class 'mvglmer' fitted by function 
<code>mvglmer()</code>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_survobject">survObject</code></td>
<td>
<p>an object of class 'coxph' fitted by function <code>coxph()</code> or
'survreg' fitted by function <code>survreg()</code> from package <b>survival</b>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_timevar">timeVar</code></td>
<td>
<p>a character string indicating the time variable in the multivariate 
mixed effects model.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_formulas">Formulas</code></td>
<td>
<p>a list of lists. Each inner list should have components 
<code>fixed</code> a formula representing the fixed-effects part of the user-defined term,
<code>indFixed</code> a numeric vector indicating which fixed effects of 
<code>mvglmerObject</code> are involved in the user-defined term, 
<code>random</code> a formula representing the random-effects part of the user-defined term, 
and <code>indRamdom</code> a numeric vector indicating which random effects of 
<code>mvglmerObject</code> are involved in the user-defined term. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_interactions">Interactions</code></td>
<td>
<p>a list specifying interaction terms for the components of the 
longitudinal outcomes that are included in the survival submodel. See <b>Examples</b>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_transfuns">transFuns</code></td>
<td>
<p>a character vector providing transformations of the linear predictors of
the mixed models that enter in the linear predictor of the relative risk model. 
Currently available options are <code>"identity"</code> (identity function), 
<code>"expit"</code> (logistic transformation), <code>"exp"</code>, <code>"log"</code>, <code>"log2"</code>,
<code>"log10"</code> and <code>"sqrt"</code>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_priors">priors</code></td>
<td>
<p>a named list of user-specified prior parameters:
</p>

<dl>
<dt>mean_Bs_gammas</dt><dd><p>the prior mean vector of the normal prior for the B-splines 
coefficients used to approximate the baseline hazard.</p>
</dd>
<dt>Tau_Bs_gammas</dt><dd><p>the prior precision matrix of the normal prior for the B-splines 
coefficients used to approximate the baseline hazard.</p>
</dd>
<dt>mean_gammas</dt><dd><p>the prior mean vector of the normal prior for the regression 
coefficients of baseline covariates.</p>
</dd>
<dt>Tau_gammas</dt><dd><p>the prior precision matrix of the normal prior for the regression 
coefficients of baseline covariates.</p>
</dd>
<dt>mean_alphas</dt><dd><p>the prior mean vector of the normal prior for the association
parameters.</p>
</dd>
<dt>Tau_alphas</dt><dd><p>the prior mean vector of the normal prior for the association
parameters.</p>
</dd>
<dt>A_tau_Bs_gammas</dt><dd><p>the prior shape parameter of the Gamma prior for the
precision parameter of the penalty term for the B-splines coefficients for
the baseline hazard.</p>
</dd>
<dt>B_tau_Bs_gammas</dt><dd><p>the prior rate parameter of the Gamma prior for the
precision parameter of the penalty term for the B-splines coefficients for
the baseline hazard.</p>
</dd>
<dt>shrink_gammas</dt><dd><p>logical; should the regression coefficients for the baseline
covariates be shrinked.</p>
</dd>
<dt>A_tau_gammas</dt><dd><p>the prior shape parameter of the Gamma prior for the
precision parameter of the global penalty term baseline regression coefficients.
Only relevant when <code>shrink_gammas = TRUE</code>.</p>
</dd>
<dt>B_tau_gammas</dt><dd><p>the prior rate parameter of the Gamma prior for the
precision parameter of the penalty term for the baseline regression coefficients. 
Only relevant when <code>shrink_gammas = TRUE</code>.</p>
</dd>
<dt>A_phi_gammas</dt><dd><p>the prior shape parameter of the Gamma prior for the
precision parameters of each baseline regression coefficients.
Only relevant when <code>shrink_gammas = TRUE</code>.</p>
</dd>
<dt>B_phi_gammas</dt><dd><p>the prior rate parameter of the Gamma prior for the
precision parameters of each baseline regression coefficients.
Only relevant when <code>shrink_gammas = TRUE</code>.</p>
</dd>
<dt>shrink_alphas</dt><dd><p>logical; should the association parameters be shrinked.</p>
</dd>
<dt>A_tau_alphas</dt><dd><p>the prior shape parameter of the Gamma prior for the
precision parameter of the global penalty term for the association parameters.
Only relevant when <code>shrink_alphas = TRUE</code>.</p>
</dd>
<dt>B_tau_alphas</dt><dd><p>the prior rate parameter of the Gamma prior for the
precision parameter of the penalty term for the association parameters. 
Only relevant when <code>shrink_alphas = TRUE</code>.</p>
</dd>
<dt>A_phi_alphas</dt><dd><p>the prior shape parameter of the Gamma prior for the
precision parameters of each association parameter.
Only relevant when <code>shrink_alphas = TRUE</code>.</p>
</dd>
<dt>B_phi_alphas</dt><dd><p>the prior rate parameter of the Gamma prior for the
precision parameters of each association parameter.
Only relevant when <code>shrink_alphas = TRUE</code>.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_multistate">multiState</code></td>
<td>
<p>logical; if <code>TRUE</code> then a joint model for longitudinal and 
multi-state survival data is fitted.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_data_multistate">data_MultiState</code></td>
<td>
<p>A data.frame that contains all the variables which were used to fit the multi-state model. This data.frame should be in long format and include one row for each transition for which a subject is at risk. A column called <code>trans</code> indicating the transition to which each row corresponds to, must be included in the data.frame. Function <code>msprep()</code> from package <b>mstate</b> can be used to easily convert datasets from wide format (one row per subject) to long format while including the necessary 
<code>trans</code> column. For more information and examples see the documentation for function <code>msprep()</code> from package <b>mstate</b>.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_idvar_multistate">idVar_MultiState</code></td>
<td>
<p>A character string indicating the id variable in <code>data_MultiState</code> for the multi-state model.</p>
</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_control">control</code></td>
<td>
<p>a list of control values with components:
</p>
        
<dl>
<dt>n_iter</dt><dd><p>integer specifying the total number of iterations after burn in; 
default is 300.</p>
</dd>
<dt>n_burnin</dt><dd><p>integer specifying how many of iterations to discard as burn-in; 
default is 1000.</p>
</dd>
<dt>n_thin</dt><dd><p>integer specifying the thinning of the chains; 
default is 300.</p>
</dd>
<dt>n_block</dt><dd><p>integer specifying the number of block iterations in which the 
acceptance rates are checked; default is 100.</p>
</dd>
<dt>target_acc</dt><dd><p>a numeric scalar denoting the target acceptance rate; 
default is 0.234.</p>
</dd>
<dt>knots</dt><dd><p>a numeric vector of knots positions for the spline approximation of 
the log baseline risk function; default is <code>NULL</code>, which means that the 
knots are calculated based on the percentiles of the observed event times.</p>
</dd>
<dt>ObsTimes.knots</dt><dd><p>logical; if <code>TRUE</code> (default), the knots are set using 
the percentiles of the observed event times (i.e., including both true events 
and censored observations). If <code>FALSE</code>, the knots are set based on the 
percentiles of the true event times alone.</p>
</dd>
<dt>lng.in.kn</dt><dd><p>a numeric scalar indicating the number of knots to use (based on 
the percentiles); default is 15.</p>
</dd>
<dt>ordSpline</dt><dd><p>an integer setting the order of the spline function. This is the 
number of coefficients in each piecewise polynomial segment, thus a cubic 
spline has order 4; default is 4.</p>
</dd>
<dt>diff</dt><dd><p>an integer setting the order of the differences in the calculation of 
the penalty term for the penalized baseline hazard; default is 2.</p>
</dd>
<dt>seed</dt><dd><p>an integer setting the random seed; default is 1.</p>
</dd>
<dt>n_cores</dt><dd><p>an integer specifying the number of cores to use. Default is the
the available cores minus one.</p>
</dd>
<dt>GQsurv</dt><dd><p>a character string specifying the type of Gaussian quadrature to 
be used. Options are &quot;GaussKronrod&quot; (default) and &quot;GaussLegendre&quot;.</p>
</dd>
<dt>GQsurv.k</dt><dd><p>an integer specifying the number of quadrature points; 
default is 15.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="mvJointModelBayes_+3A_...">...</code></td>
<td>
<p>options passed to the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mathematical details regarding the definition of the multivariate joint model, and
the capabilities of the package can be found in the vignette in the <code>doc</code> directory.
</p>


<h3>Value</h3>

<p>A list of class <code>mvJMbayes</code> with components:
</p>
<table>
<tr><td><code>mcmc</code></td>
<td>
<p>a list with the MCMC samples for each parameter.</p>
</td></tr>
<tr><td><code>components</code></td>
<td>
<p>a copy of the <code>components</code> element of <code>mvglmerObject</code>.</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>a list of data used to fit the model.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>a copy of the <code>control</code> values used in the fit.</p>
</td></tr>
<tr><td><code>mcmc.info</code></td>
<td>
<p>a list with information over the MCMC (i.e., time it took, iterations, 
etc.).</p>
</td></tr>
<tr><td><code>priors</code></td>
<td>
<p>a copy of the priors used.</p>
</td></tr>
<tr><td><code>postwMeans</code></td>
<td>
<p>a list with posterior weighted means.</p>
</td></tr>
<tr><td><code>postMeans</code></td>
<td>
<p>a list with posterior means.</p>
</td></tr>
<tr><td><code>postModes</code></td>
<td>
<p>a list with posterior modes calculated using kernel desnisty estimation.</p>
</td></tr>
<tr><td><code>EffectiveSize</code></td>
<td>
<p>a list with effective sample sizes.</p>
</td></tr>
<tr><td><code>StErr</code></td>
<td>
<p>a list with posterior standard errors.</p>
</td></tr>
<tr><td><code>StDev</code></td>
<td>
<p>a list with posterior standard deviations.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>a list with 95% credible intervals.</p>
</td></tr>
<tr><td><code>Pvalues</code></td>
<td>
<p>a list of tail probabilities for containg the zero value.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a>
</p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2000) Joint modelling of longitudinal measurements and event time data.
<em>Biostatistics</em> <b>1</b>, 465&ndash;480.
</p>
<p>Hsieh, F., Tseng, Y.-K. and Wang, J.-L. (2006) Joint modeling of survival and longitudinal data: Likelihood 
approach revisited. <em>Biometrics</em> <b>62</b>, 1037&ndash;1043.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: With 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011) Dynamic predictions and prospective accuracy in joint models for longitudinal 
and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>
<p>Tsiatis, A. and Davidian, M. (2004) Joint modeling of longitudinal and time-to-event data: an overview. 
<em>Statistica Sinica</em> <b>14</b>, 809&ndash;834.
</p>
<p>Wulfsohn, M. and Tsiatis, A. (1997) A joint model for survival and longitudinal data measured with error. 
<em>Biometrics</em> <b>53</b>, 330&ndash;339.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvglmer">mvglmer</a></code>,
<code><a href="#topic+jointModelBayes">jointModelBayes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
pbc2.id$Time &lt;- pbc2.id$years
pbc2.id$event &lt;- as.numeric(pbc2.id$status != "alive")

##########################################################################################

##############################################
# Univariate joint model for serum bilirubin #
##############################################

# [1] Fit the mixed model using mvglmer(). The main arguments of this function are:
# 'formulas' a list of lme4-like formulas (a formular per outcome),
# 'data' a data.frame that contains all the variables specified in 'formulas' (NAs allowed),
# 'families' a list of family objects specifying the type of each outcome (currently only
# gaussian, binomial and poisson are allowed).
MixedModelFit1 &lt;- mvglmer(list(log(serBilir) ~ year + (year | id)), data = pbc2,
                          families = list(gaussian))

# [2] Fit a Cox model, specifying the baseline covariates to be included in the joint
# model; you need to set argument 'model' to TRUE.
CoxFit1 &lt;- coxph(Surv(Time, event) ~ drug + age, data = pbc2.id, model = TRUE)

# [3] The basic joint model is fitted using a call to mvJointModelBayes(), which is very
# similar to JointModelBayes(), i.e.,
JMFit1 &lt;- mvJointModelBayes(MixedModelFit1, CoxFit1, timeVar = "year")
summary(JMFit1)
plot(JMFit1)

##########################################################################################

#########################################################
# Bivariate joint model for serum bilirubin and spiders #
#########################################################

MixedModelFit2 &lt;- mvglmer(list(log(serBilir) ~ year + (year | id),
                               spiders ~ year + (1 | id)), data = pbc2,
                          families = list(gaussian, binomial))

CoxFit2 &lt;- coxph(Surv(Time, event) ~ drug + age, data = pbc2.id, model = TRUE)

JMFit2 &lt;- mvJointModelBayes(MixedModelFit2, CoxFit2, timeVar = "year")
summary(JMFit2)
plot(JMFit2)

##########################################################################################

#######################
# slopes &amp; area terms #
#######################

# We extend model 'JMFit2' by including the value and slope term for bilirubin, and
# the area term for spiders (in the log-odds scale). To include these terms into the model
# we specify the 'Formulas' argument. This is specified in a similar manner as the
# 'derivForms' argument of jointModelBayes(). In particular, it should be a list of lists.
# Each component of the outer list should have as name the name of the corresponding
# outcome variable. Then in the inner list we need to specify four components, namely,
# 'fixed' &amp; 'random' R formulas specifying the fixed and random effects part of the term
# to be included, and 'indFixed' &amp; 'indRandom' integer indicices specifying which of the
# original fixed and random effects are involved in the claculation of the new term. In
# the inner list you can also optionally specify a name for the term you want to include.
# Notes: (1) For terms not specified in the 'Formulas' list, the default value functional
# form is used. (2) If for a particular outcome you want to include both the value
# functional form and an extra term, then you need to specify that in the 'Formulas'
# using two entries. To include the value functional form you only need to set the
# corresponding to 'value', and for the second term to specify the inner list. See
# example below on how to include the value and slope for serum bilirubin (for example,
# if the list below the entry '"log(serBilir)" = "value"' was not give, then only the
# slope term would have been included in the survival submodel).

Forms &lt;- list("log(serBilir)" = "value",
              "log(serBilir)" = list(fixed = ~ 1, random = ~ 1,
                                     indFixed = 2, indRandom = 2, name = "slope"),
              "spiders" = list(fixed = ~ 0 + year + I(year^2/2), random = ~ 0 + year,
                               indFixed = 1:2, indRandom = 1, name = "area"))

JMFit3 &lt;- update(JMFit2, Formulas = Forms)
summary(JMFit3)
plot(JMFit3)

##########################################################################################

#####################
# Interaction terms #
#####################

# We further extend the previous model by including the interactions terms between the
# terms specified in 'Formulas' and 'drug'. The names specified in the list that defined
# the interaction factors should match with the names of the output from 'JMFit3'; the
# only exception is with regard to the 'value' functional form. See specification below
# (to include the interaction of the value term of 'log(serBilir)' with 'drug', in the
# list we can either specify as name of the corresponding formula 'log(serBilir)_value'
# or just 'log(serBilir)'):

Ints &lt;- list("log(serBilir)" = ~ drug, "log(serBilir)_slope" = ~ drug,
             "spiders_area" = ~ drug)

# because of the many association parameters we have, we place a shrinkage prior on the
# alpha coefficients. In particular, if we have K association parameters, we assume that
# alpha_k ~ N(0, tau * phi_k), k = 1, ..., K. The precision parameters tau and phi_k are
# given Gamma priors. Precision tau is global shrinkage parameter, and phi_k a specific
# per alpha coefficient.
JMFit4 &lt;- update(JMFit3, Interactions = Ints, priors = list(shrink_alphas = TRUE))
summary(JMFit4)
plot(JMFit4)

##########################################################################################

########################
# Time-varying effects #
########################

# We allow the association parameter to vary with time; the time-varying coefficients are
# approximated with P-splines
JMFit_tveffect &lt;- mvJointModelBayes(MixedModelFit1, CoxFit1, timeVar = "year",
                    Interactions = list("log(serBilir)_value" = ~ 0 + tve(Time, df = 8)))

plot(JMFit_tveffect, "tv_effect")


##########################################################################################

############################
# Interval censoring terms #
############################

# create artificial interval censoring in the PBC data set
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")
pbc2$status3 &lt;- as.character(pbc2$status)
ff &lt;- function (x) {
    out &lt;- if (x[1L] %in% c('dead', 'transplanted')) 'dead' else 
        switch(sample(1:3, 1), '1' = "alive", '2' = "left", '3' = "interval")
    rep(out, length(x))
}
pbc2$status3 &lt;- unlist(with(pbc2, lapply(split(status3, id), ff)), use.names = FALSE)
pbc2$status3 &lt;- unname(with(pbc2, sapply(status3, function (x) 
    switch(x, 'dead' = 1, 'alive' = 0, 'left' = 2, 'interval' = 3))))
pbc2$yearsU &lt;- as.numeric(NA)
pbc2$yearsU[pbc2$status3 == 3] &lt;- pbc2$years[pbc2$status3 == 3] + 
    runif(sum(pbc2$status3 == 3), 0, 4)
pbc2.id &lt;- pbc2[!duplicated(pbc2$id), ]

# next we fit a weibull model for interval censored data
survFit &lt;- survreg(Surv(years, yearsU, status3, type = "interval") ~ drug + age, 
                   data = pbc2.id, model = TRUE)

# next we fit the joint model (we use 'MixedModelFit1' from above)
JMFit_intcens &lt;- mvJointModelBayes(MixedModelFit1, survFit, timeVar = "year")
summary(JMFit_intcens)

## End(Not run)
</code></pre>

<hr>
<h2 id='pbc2'>Mayo Clinic Primary Biliary Cirrhosis Data</h2><span id='topic+pbc2'></span><span id='topic+pbc2.id'></span>

<h3>Description</h3>

<p>Followup of 312 randomised patients with primary biliary cirrhosis, a rare autoimmune liver disease, at Mayo Clinic.
</p>


<h3>Format</h3>

<p>A data frame with 1945 observations on the following 20 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 312 patients.</p>
</dd>
<dt><code>years</code></dt><dd><p>number of years between registration and the earlier of death, transplantion, or study 
analysis time.</p>
</dd>
<dt><code>status</code></dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code> and <code>dead</code>.</p>
</dd>
<dt><code>drug</code></dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicil</code>.</p>
</dd>
<dt><code>age</code></dt><dd><p>at registration in years.</p>
</dd>
<dt><code>sex</code></dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt><code>year</code></dt><dd><p>number of years between enrollment and this visit date, remaining values on the line of 
data refer to this visit.</p>
</dd>
<dt><code>ascites</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>hepatomegaly</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>spiders</code></dt><dd><p>a factor with levels <code>No</code> and <code>Yes</code>.</p>
</dd>
<dt><code>edema</code></dt><dd><p>a factor with levels <code>No edema</code> (i.e., no edema and no diuretic therapy for edema),
<code>edema no diuretics</code> (i.e., edema present without diuretics, or edema resolved by diuretics), and 
<code>edema despite diuretics</code> (i.e., edema despite diuretic therapy).</p>
</dd>
<dt><code>serBilir</code></dt><dd><p>serum bilirubin in mg/dl.</p>
</dd>
<dt><code>serChol</code></dt><dd><p>serum cholesterol in mg/dl.</p>
</dd>
<dt><code>albumin</code></dt><dd><p>albumin in gm/dl.</p>
</dd>
<dt><code>alkaline</code></dt><dd><p>alkaline phosphatase in U/liter.</p>
</dd>
<dt><code>SGOT</code></dt><dd><p>SGOT in U/ml.</p>
</dd>
<dt><code>platelets</code></dt><dd><p>platelets per cubic ml / 1000.</p>
</dd>
<dt><code>prothrombin</code></dt><dd><p>prothrombin time in seconds.</p>
</dd>
<dt><code>histologic</code></dt><dd><p>histologic stage of disease.</p>
</dd>
<dt><code>status2</code></dt><dd><p>a numeric vector with the value 1 denoting if the patient was dead,
and 0 if the patient was alive or transplanted.</p>
</dd>
</dl>



<h3>Note</h3>

<p>The data frame <code>pbc2.id</code> contains the first measurement for each patient. This data frame is used to 
fit the survival model. 
</p>


<h3>References</h3>

<p>Fleming, T. and Harrington, D. (1991) <em>Counting Processes and Survival Analysis</em>. Wiley, New York.
</p>
<p>Therneau, T. and Grambsch, P. (2000) <em>Modeling Survival Data: Extending the Cox Model</em>. Springer-Verlag, New York.
</p>

<hr>
<h2 id='plot'>MCMC Diagnostics for Joint Models</h2><span id='topic+plot.JMbayes'></span>

<h3>Description</h3>

<p>Produces MCMC diagnostics plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
plot(x, which = c("trace", "autocorr", "density", "CPO", "weightFun"), 
    param = c("betas", "sigma", "D", "gammas", "alphas", "Dalphas", 
        "shapes", "Bs.gammas", "tauBs"), ask = TRUE, max.t = NULL, 
    from = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_which">which</code></td>
<td>
<p>which types of plots to produce.</p>
</td></tr>
<tr><td><code id="plot_+3A_param">param</code></td>
<td>
<p>for which parameter to produce the MCMC diagnostic plots; default is for all parameters.</p>
</td></tr>
<tr><td><code id="plot_+3A_ask">ask</code></td>
<td>
<p>logical, if <code>TRUE</code> the user is asked for input, before a new figure is drawn.</p>
</td></tr>
<tr><td><code id="plot_+3A_max.t">max.t</code></td>
<td>
<p>numeric scalar; up to which time point to plot the weight function, default is up to the
third quantile of the observed event times.</p>
</td></tr>
<tr><td><code id="plot_+3A_from">from</code></td>
<td>
<p>numeric scalar; from which time point to start plotting the weight function, default is zero.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ 1 | id, data = pbc2)

# survival regression fit
fitSURV &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)

# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModelBayes(fitLME, fitSURV, timeVar = "year")

plot(fitJOINT)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.survfitJM'>Plot Method for survfit.JMbayes and survfit.mvJMbayes Objects</h2><span id='topic+plot.survfit.JMbayes'></span><span id='topic+plot.survfit.mvJMbayes'></span>

<h3>Description</h3>

<p>Produces plots of conditional probabilities of survival.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'survfit.JMbayes'
plot(x, estimator = c("both", "mean", "median"), 
    which = NULL, fun = NULL, invlink = NULL, conf.int = FALSE, 
    fill.area = FALSE, col.area = "grey", col.abline = "black", col.points = "black",
    add.last.time.axis.tick = FALSE, include.y = FALSE, main = NULL, 
    xlab = NULL, ylab = NULL, ylab2 = NULL, lty = NULL, col = NULL, 
    lwd = NULL, pch = NULL, ask = NULL, legend = FALSE, ...,
    cex.axis.z = 1, cex.lab.z = 1, xlim = NULL)
    
## S3 method for class 'survfit.mvJMbayes'
plot(x, split = c(1, 1), which_subjects = NULL, 
    which_outcomes = NULL, surv_in_all = TRUE, include.y = TRUE, fun = NULL,
    abline = NULL,
    main = NULL, xlab = "Time", ylab = NULL, zlab = "Event-Free Probability",
    include_CI = TRUE, fill_area_CI = TRUE, col_points = "black", 
    pch_points = 1, col_lines = "red", col_lines_CI = "black", 
    col_fill_CI = "lightgrey", lwd_lines = 2, lty_lines_CI = 2, 
    cex_xlab = 1, cex_ylab = 1, cex_zlab = 1, cex_main = 1, 
    cex_axis = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.survfitJM_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>survfit.JMbayes</code> or class 
<code>survfit.mvJMbayes</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_estimator">estimator</code></td>
<td>
<p>character string specifying, whether to include in the plot the mean of
the conditional probabilities of survival, the median or both. The mean and median are
taken as estimates of these conditional probabilities over the M replications of the
Monte Carlo scheme described in <code><a href="#topic+survfitJM">survfitJM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_which">which</code></td>
<td>
<p>an integer or character vector specifying for which subjects to produce the 
plot. If a character vector, then is should contain a subset of the values of the 
<code>idVar</code> variable of the <code>newdata</code> argument of <code><a href="#topic+survfitJM">survfitJM</a></code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_which_subjects">which_subjects</code></td>
<td>
<p>an integer vector specifying for which subjects to produce the 
plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_split">split</code></td>
<td>
<p>a integer vector of length 2 indicating in how many panels to construct,
i.e., number of rows and number of columns.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_which_outcomes">which_outcomes</code></td>
<td>
<p>integer vector indicating which longitudinal outcomes to include 
in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_surv_in_all">surv_in_all</code></td>
<td>
<p>logical; should the survival function be included in all panels.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_fun">fun</code></td>
<td>
<p>a vectorized function defining a transformation of the survival curve. For 
example, with <code>fun=log</code> the log-survival curve is drawn.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_abline">abline</code></td>
<td>
<p>a list with arguments to <code>abline()</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_invlink">invlink</code></td>
<td>
<p>a function to transform the fitted values of the longitudinal outcome.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_conf.int">conf.int</code>, <code id="plot.survfitJM_+3A_include_ci">include_CI</code></td>
<td>
<p>logical; if <code>TRUE</code>, then a pointwise confidence 
interval is included in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_fill.area">fill.area</code>, <code id="plot.survfitJM_+3A_fill_area_ci">fill_area_CI</code></td>
<td>
<p>logical; if <code>TRUE</code> the area defined by the 
confidence interval of the survival function is put in color.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col.area">col.area</code>, <code id="plot.survfitJM_+3A_col_fill_ci">col_fill_CI</code></td>
<td>
<p>the color of the area defined by the confidence interval of
the survival function.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col.abline">col.abline</code>, <code id="plot.survfitJM_+3A_col.points">col.points</code>, <code id="plot.survfitJM_+3A_col_points">col_points</code>, <code id="plot.survfitJM_+3A_col_lines">col_lines</code>, <code id="plot.survfitJM_+3A_col_lines_ci">col_lines_CI</code></td>
<td>
<p>the color for the 
vertical line and the points when <code>include.y</code> is <code>TRUE</code>.</p>
</td></tr> 
<tr><td><code id="plot.survfitJM_+3A_add.last.time.axis.tick">add.last.time.axis.tick</code></td>
<td>
<p>logical; if <code>TRUE</code>, a tick is added in the x-axis 
for the last available time point for which a longitudinal measurement was available.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_include.y">include.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, two plots are produced per subject, i.e., 
the plot of conditional probabilities of survival and a scatterplot of his 
longitudinal measurements.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_main">main</code></td>
<td>
<p>a character string specifying the title in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_xlab">xlab</code></td>
<td>
<p>a character string specifying the x-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_ylab">ylab</code></td>
<td>
<p>a character string specifying the y-axis label in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_ylab2">ylab2</code></td>
<td>
<p>a character string specifying the y-axis label in the plot, 
when <code>include.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_zlab">zlab</code></td>
<td>
<p>a character string specifying the z-axis (vertical right-hand side) label 
in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_lty">lty</code>, <code id="plot.survfitJM_+3A_lty_lines_ci">lty_lines_CI</code></td>
<td>
<p>what types of lines to use.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_col">col</code></td>
<td>
<p>which colors to use.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_lwd">lwd</code>, <code id="plot.survfitJM_+3A_lwd_lines">lwd_lines</code></td>
<td>
<p>the thickness of the lines.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_pch">pch</code>, <code id="plot.survfitJM_+3A_pch_points">pch_points</code></td>
<td>
<p>the type of points to use.</p>
</td></tr>  
<tr><td><code id="plot.survfitJM_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is asked before each plot, 
see <code>par()</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend is included in the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_cex.axis.z">cex.axis.z</code>, <code id="plot.survfitJM_+3A_cex.lab.z">cex.lab.z</code></td>
<td>
<p>the par <code>cex</code> argument for the axis at side 4, 
when <code>include.y = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_cex_xlab">cex_xlab</code>, <code id="plot.survfitJM_+3A_cex_ylab">cex_ylab</code>, <code id="plot.survfitJM_+3A_cex_zlab">cex_zlab</code>, <code id="plot.survfitJM_+3A_cex_main">cex_main</code>, <code id="plot.survfitJM_+3A_cex_axis">cex_axis</code></td>
<td>
<p>the par <code>cex</code> argument for the axis
in side 1 (x-axis), side 2 (y-axis), side 4 (z-axis) and the title of the plot.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_xlim">xlim</code></td>
<td>
<p>the par <code>xlim</code> argument.</p>
</td></tr>
<tr><td><code id="plot.survfitJM_+3A_...">...</code></td>
<td>
<p>extra graphical parameters passed to <code>plot()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
    random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# we will compute survival probabilities for Subject 2 in a dynamic manner, 
# i.e., after each longitudinal measurement is recorded
ND &lt;- pbc2[pbc2$id == 2, ] # the data of Subject 2
survPreds &lt;- vector("list", nrow(ND))
for (i in 1:nrow(ND)) {
    survPreds[[i]] &lt;- survfitJM(jointFit, newdata = ND[1:i, ])
}

# the default call to the plot method using the first three
# longitudinal measurements
plot(survPreds[[3]])

# we produce the corresponding plot
par(mfrow = c(2, 2), oma = c(0, 2, 0, 2))
for (i in c(1,3,5,7)) {
    plot(survPreds[[i]], estimator = "median", conf.int = TRUE,
        include.y = TRUE, main = paste("Follow-up time:",
            round(survPreds[[i]]$last.time, 1)), ylab = "", ylab2 = "")
}
mtext("log serum bilirubin", side = 2, line = -1, outer = TRUE)
mtext("Survival Probability", side = 4, line = -1, outer = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='prederrJM'>Prediction Errors for Joint Models</h2><span id='topic+prederrJM'></span><span id='topic+prederrJM.JMbayes'></span><span id='topic+prederrJM.mvJMbayes'></span>

<h3>Description</h3>

 
<p>Using the available longitudinal information up to a starting time point, this function computes an estimate 
of the prediction error of survival at a horizon time point based on joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prederrJM(object, newdata, Tstart, Thoriz, ...)

## S3 method for class 'JMbayes'
prederrJM(object, newdata, Tstart, Thoriz, 
    lossFun = c("square", "absolute"), interval = FALSE, idVar = "id", 
    simulate = FALSE, M = 100, ...)

## S3 method for class 'mvJMbayes'
prederrJM(object, newdata, Tstart, Thoriz, 
    lossFun = c("square", "absolute"), interval = FALSE, idVar = "id", 
    M = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prederrJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code> or <code>mvJMbayes</code>.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_tstart">Tstart</code></td>
<td>
<p>numeric scalar denoting the time point up to which longitudinal information is to be used to derive predictions.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_thoriz">Thoriz</code></td>
<td>
<p>numeric scalar denoting the time point for which a prediction of the survival status is of interest; <code>Thoriz</code> mast be later than <code>Tstart</code>.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_lossfun">lossFun</code></td>
<td>
<p>either the options <code>"absolute"</code> or <code>"square"</code> (default),  or a user-specified loss function. 
As the names suggest, 
when <code>lossFun = "absolute"</code> the loss function is <code class="reqn">L(x) = |x|</code>, whereas when <code>lossFun = "square"</code> the loss function is 
<code class="reqn">L(x) = x^2</code>. If a user-specified function is supplied, this should have a single argument and be vectorized.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_interval">interval</code></td>
<td>
<p>logical; if <code>TRUE</code> the weighted prediction error in the interval <code>[Tstart, Thoriz]</code> is calculated, while
if <code>FALSE</code> the prediction error at time <code>Thoriz</code> is calculated using the longitudinal information up to time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code id="prederrJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. See <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_m">M</code></td>
<td>
<p>a numeric scalar denoting the number of Monte Carlo samples; see <code><a href="#topic+survfitJM">survfitJM</a></code> for mote details.</p>
</td></tr>
<tr><td><code id="prederrJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>) and using the data supplied in argument <code>newdata</code>, this function
computes the following estimate of the prediction: </p>
<p style="text-align: center;"><code class="reqn">PE(u | t) = \{R(t)\}^{-1} \sum_{i: T_i \geq s} I(T_i \geq u) 
  L\{1 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \delta_i I(T_i &lt; u) L\{0 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>
 
<p style="text-align: center;"><code class="reqn">+ (1 - \delta_i) I(T_i &lt; u) [S_i(u \mid T_i, \tilde{y}_i(t)) L\{1 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}</code>
</p>

<p style="text-align: center;"><code class="reqn">+ \{1 - S_i(u \mid T_i, \tilde{y}_i(t))\} L\{0 - Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)\}],</code>
</p>

<p>where <code class="reqn">R(t)</code> denotes the number of subjects at risk at time <code class="reqn">t = </code> <code>Tstart</code>, <code class="reqn">\tilde{y}_i(t) = \{y_i(s), 0 \leq s \leq t\}</code> denotes the available 
longitudinal measurements up to time <code class="reqn">t</code>, <code class="reqn">T_i</code> denotes the observed event time for subject <code class="reqn">i</code>, <code class="reqn">\delta_i</code> is the event indicator, 
<code class="reqn">s</code> is the starting time point <code>Tstart</code> up to which the longitudinal information is used, and <code class="reqn">u &gt; s</code> is the horizon time point <code>Thoriz</code>.
Function <code class="reqn">L(.)</code> is the loss function that can be the absolute value (i.e., <code class="reqn">L(x) = |x|</code>), the squared value (i.e., <code class="reqn">L(x) = x^2</code>), 
or a user-specified function. The probabilities <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code> are calculated by <code><a href="#topic+survfitJM">survfitJM</a></code>.
</p>
<p>When <code>interval</code> is set to <code>TRUE</code>, then function <code>prederrJM</code> computes the integrated prediction error in the interval 
<code class="reqn">(u,t) =</code> <code>(Tstart, Thoriz)</code> defined as </p>
<p style="text-align: center;"><code class="reqn">IPE(u | t) = \sum_{i: t \leq T_i \leq u} w_i(T_i) PE(T_i | t),</code>
</p>
<p> where 
</p>
<p style="text-align: center;"><code class="reqn">w_i(T_i) = \frac{\delta_i G(T_i) / G(t)}{\sum_{i: t \leq T_i \leq u} \delta_i G(T_i) / G(t)},</code>
</p>
<p> with <code class="reqn">G(.)</code> denoting
the Kaplan-Meier estimator of the censoring time distribution.
</p>


<h3>Value</h3>

<p>A list of class <code>prederrJM</code> with components:
</p>
<table>
<tr><td><code>prederr</code></td>
<td>
<p>a numeric scalar denoting the estimated prediction error.</p>
</td></tr>
<tr><td><code>nr</code></td>
<td>
<p>a numeric scalar denoting the number of subjects at risk at time <code>Tstart</code>.</p>
</td></tr>  
<tr><td><code>Tstart</code></td>
<td>
<p>a copy of the <code>Tstart</code> argument.</p>
</td></tr>
<tr><td><code>Thoriz</code></td>
<td>
<p>a copy of the <code>Thoriz</code> argument.</p>
</td></tr>
<tr><td><code>interval</code></td>
<td>
<p>a copy of the <code>interval</code> argument.</p>
</td></tr>
<tr><td><code>classObject</code></td>
<td>
<p>the class of <code>object</code>.</p>
</td></tr>
<tr><td><code>nameObject</code></td>
<td>
<p>the name of <code>object</code>.</p>
</td></tr>
<tr><td><code>lossFun</code></td>
<td>
<p>a copy of the <code>lossFun</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Henderson, R., Diggle, P. and Dobson, A. (2002). Identification and efficacy of 
longitudinal markers for survival. <em>Biostatistics</em> <b>3</b>, 33&ndash;50.
</p>
<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for 
longitudinal and time-to-event data. <em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM">survfitJM</a></code>, <code><a href="#topic+aucJM">aucJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
    random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# prediction error at year 10 using longitudinal data up to year 5 
prederrJM(jointFit, pbc2, Tstart = 5, Thoriz = 10)
prederrJM(jointFit, pbc2, Tstart = 5, Thoriz = 6.5, interval = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict'>Predictions for Joint Models</h2><span id='topic+predict.JMbayes'></span>

<h3>Description</h3>

<p>Calculates predicted values for the longitudinal part of a joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
predict(object, newdata, type = c("Marginal", "Subject"),
    interval = c("none", "confidence", "prediction"), level = 0.95, idVar = "id", 
    FtTimes = NULL, last.time = NULL, LeftTrunc_var = NULL, 
    M = 300, returnData = FALSE, scale = 1.6, 
    weight = rep(1, nrow(newdata)), invlink = NULL, seed = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>a data frame in which to look for variables with which to predict.</p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p>a character string indicating the type of predictions to compute,
marginal or subject-specific. See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="predict_+3A_interval">interval</code></td>
<td>
<p>a character string indicating what type of intervals should be computed.</p>
</td></tr>
<tr><td><code id="predict_+3A_level">level</code></td>
<td>
<p>a numeric scalar denoting the tolerance/confidence level.</p>
</td></tr>
<tr><td><code id="predict_+3A_idvar">idVar</code></td>
<td>
<p>a character string indicating the name of the variable in 
<code>newdata</code> that corresponds to the subject identifier; required 
when <code>type = "Subject"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_fttimes">FtTimes</code></td>
<td>
<p>a list with components numeric vectors denoting the time points 
for which we wish to compute subject-specific predictions after the last
available measurement provided in <code>newdata</code>. For each subject in
<code>newdata</code> the default is a sequence of 25 equally spaced time points 
from the last available measurement to the maximum follow-up time of all 
subjects (plus a small quantity). This argument is only used when 
<code>type = "Subject"</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_last.time">last.time</code></td>
<td>
<p>a numeric vector. This specifies the known time at which each of the subjects in <code>newdata</code>
was known to be alive. If <code>NULL</code>, then this is automatically taken as the last time each subject provided a longitudinal
measurement. If a numeric vector, then it is assumed to contain this last time point for each subject.</p>
</td></tr>
<tr><td><code id="predict_+3A_lefttrunc_var">LeftTrunc_var</code></td>
<td>
<p>character string indicating the name of the variable in <code>newdata</code> that denotes the left-truncation
time.</p>
</td></tr>
<tr><td><code id="predict_+3A_m">M</code></td>
<td>
<p>numeric scalar denoting the number of Monte Carlo samples. 
See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="predict_+3A_returndata">returnData</code></td>
<td>
<p>logical; if <code>TRUE</code> the data frame supplied in
<code>newdata</code> is returned augmented with the outputs of the function.</p>
</td></tr>
<tr><td><code id="predict_+3A_scale">scale</code></td>
<td>
<p>a numeric value setting the scaling of the covariance matrix
of the empirical Bayes estimates in the Metropolis step during the 
Monte Carlo sampling.</p>
</td></tr>
<tr><td><code id="predict_+3A_weight">weight</code></td>
<td>
<p>a numeric vector of weights to be applied to the predictions of each subject.</p>
</td></tr>
<tr><td><code id="predict_+3A_invlink">invlink</code></td>
<td>
<p>a function to tranform the linear predictor of the mixed model to fitted means;
relevant when the user has specified her own density for the longitudinal outcome in 
<code><a href="#topic+jointModelBayes">jointModelBayes</a></code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_seed">seed</code></td>
<td>
<p>numeric scalar, the random seed used to produce the results.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>type = "Marginal"</code>, this function computes predicted values for the 
fixed-effects part of the longitudinal submodel. In particular,
let <code class="reqn">X</code> denote the fixed-effects design matrix calculated using
<code>newdata</code>. The <code>predict()</code> calculates <code class="reqn">\hat{y} = X \hat{\beta}</code>,
and if <code>interval = "confidence"</code>, then it calculates the confidence intervals
based on the percentiles of the MCMC sample for <code class="reqn">\beta</code>.
</p>
<p>When <code>type = "Subject"</code>, this functions computes subject-specific 
predictions for the longitudinal outcome based on the joint model. 
This accomplished with a Monte Carlo simulation scheme, similar to the one
described in <code><a href="#topic+survfitJM">survfitJM</a></code>. The only difference is in Step 3, where
for <code>interval = "confidence"</code> <code class="reqn">y_i^* = X_i \beta^* + Z_i b_i^*</code>, whereas
for <code>interval = "prediction"</code> <code class="reqn">y_i^*</code> is a random vector from a normal 
distribution with mean <code class="reqn">X_i \beta^* + Z_i b_i^*</code> and standard deviation 
<code class="reqn">\sigma^*</code>. Based on this Monte Carlo simulation scheme we take as 
estimate of <code class="reqn">\hat{y}_i</code> the average of the <code>M</code> estimates <code class="reqn">y_i^*</code> 
from each Monte Carlo sample. Confidence intervals are constructed using the 
percentiles of <code class="reqn">y_i^*</code> from the Monte Carlo samples.
</p>


<h3>Value</h3>

<p>If <code>se.fit = FALSE</code> a numeric vector of predicted values, otherwise a
list with components <code>pred</code> the predicted values, <code>se.fit</code> the
standard error for the fitted values, and <code>low</code> and <code>upp</code> the lower
and upper limits of the confidence interval. If <code>returnData = TRUE</code>, it
returns the data frame <code>newdata</code> with the previously mentioned components
added.
</p>


<h3>Note</h3>

<p>The user is responsible to appropriately set the <code>invlink</code> argument when a user-specified
mixed effects model has been fitted.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survfitJM.JMbayes">survfitJM.JMbayes</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, data = pbc2,
    random = ~ year | id)
# survival regression fit
fitSURV &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, 
    x = TRUE)
# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModelBayes(fitLME, fitSURV, timeVar = "year")

DF &lt;- with(pbc2, expand.grid(drug = levels(drug),
    year = seq(min(year), max(year), len = 100)))
Ps &lt;- predict(fitJOINT, DF, interval = "confidence", return = TRUE)
require(lattice)
xyplot(pred + low + upp ~ year | drug, data = Ps,
    type = "l", col = c(2,1,1), lty = c(1,2,2), lwd = 2,
    ylab = "Average log serum Bilirubin")


# Subject-specific predictions
ND &lt;- pbc2[pbc2$id == 2, ]
Ps.ss &lt;- predict(fitJOINT, ND, type = "Subject",
  interval = "confidence", return = TRUE)
xyplot(pred + low + upp ~ year | id, data = Ps.ss,
    type = "l", col = c(2,1,1), lty = c(1,2,2), lwd = 2,
    ylab = "Average log serum Bilirubin")

## End(Not run)
</code></pre>

<hr>
<h2 id='prothro'>Prednisone versus Placebo in Liver Cirrhosis Patients</h2><span id='topic+prothro'></span><span id='topic+prothros'></span>

<h3>Description</h3>

<p>A randomized trial on 488 liver cirrhosis patients
</p>


<h3>Format</h3>

<p>Two data frames with the following variable.
</p>

<dl>
<dt><code>id</code></dt><dd><p>patients identifier; in total there are 467 patients.</p>
</dd>
<dt><code>pro</code></dt><dd><p>prothrobin measurements.</p>
</dd>
<dt><code>time</code></dt><dd><p>for data frame <code>prothro</code> the time points at which the prothrobin measurements were taken; 
for data frame <code>prothros</code> the time to death or censoring.</p>
</dd>
<dt><code>death</code></dt><dd><p>a numeric vector with 0 denoting censoring and 1 death.</p>
</dd>
<dt><code>treat</code></dt><dd><p>randomized treatment; a factor with levels &quot;placebo&quot; and &quot;prednisone&quot;.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.gllamm.org/books/readme.html#14.6">http://www.gllamm.org/books/readme.html#14.6</a>, 
</p>


<h3>References</h3>

<p>Andersen, P. K., Borgan, O., Gill, R. D. and Keiding, N. (1993). 
<em>Statistical Models Based on Counting Processes</em>. New York: Springer. 
</p>

<hr>
<h2 id='ranef'>Random Effects Estimates for Joint Models</h2><span id='topic+ranef.JMbayes'></span>

<h3>Description</h3>

<p>Extracts the random effects estimates from a fitted joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
ranef(object, postVar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranef_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code>.</p>
</td></tr>
<tr><td><code id="ranef_+3A_postvar">postVar</code></td>
<td>
<p>logical; if <code>TRUE</code> the variance of the posterior distribution is also returned.</p>
</td></tr>
<tr><td><code id="ranef_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric matrix with rows denoting the individuals and columns the random effects (e.g., intercepts, slopes, etc.). 
If <code>postVar = TRUE</code>, the numeric matrix has an extra attribute &ldquo;postVar&quot;.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coef.JMbayes">coef.JMbayes</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# linear mixed model fit
fitLME &lt;- lme(log(serBilir) ~ drug * year, random = ~ 1 | id, data = pbc2)
# survival regression fit
fitSURV &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)

# joint model fit, under the (default) Weibull model
fitJOINT &lt;- jointModelBayes(fitLME, fitSURV, timeVar = "year")
ranef(fitJOINT)

## End(Not run)
</code></pre>

<hr>
<h2 id='runDynPred'> Shiny Application for Dynamic Predictions </h2><span id='topic+runDynPred'></span>

<h3>Description</h3>

<p>This function loads the shiny package and runs the application for calculating dynamic predictions using package JMbayes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runDynPred(type = c("JM", "lme"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runDynPred_+3A_type">type</code></td>
<td>
<p>character string indicating whether dynamic predictions are based on 
joint models or mixed models alone.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value returned.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
runDynPred()

## End(Not run)
</code></pre>

<hr>
<h2 id='survfitJM'>Prediction in Joint Models</h2><span id='topic+survfitJM'></span><span id='topic+survfitJM.JMbayes'></span><span id='topic+survfitJM.mvJMbayes'></span>

<h3>Description</h3>

 
<p>This function computes the conditional probability of surviving later times than the last observed time for which a
longitudinal measurement was available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survfitJM(object, newdata, ...)

## S3 method for class 'JMbayes'
survfitJM(object, newdata, 
   type = c("SurvProb", "Density"), idVar = "id", 
   simulate = TRUE, survTimes = NULL, last.time = NULL, 
   LeftTrunc_var = NULL, M = 200L, 
   CI.levels = c(0.025, 0.975), log = FALSE, scale = 1.6, 
   weight = rep(1, nrow(newdata)), 
   init.b = NULL, seed = 1L, ...)

## S3 method for class 'mvJMbayes'
survfitJM(object, newdata, 
    survTimes = NULL, idVar = "id", last.time = NULL, 
    M = 200L, scale = 1.6, log = FALSE, 
    CI.levels = c(0.025, 0.975), seed = 1L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survfitJM_+3A_object">object</code></td>
<td>
<p>an object inheriting from class <code>JMBayes</code> or <code>mvJMBayes</code>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_newdata">newdata</code></td>
<td>
<p>a data frame that contains the longitudinal and covariate information for the subjects for which prediction 
of survival probabilities is required. The names of the variables in this data frame must be the same as in the data frames that
were used to fit the linear mixed effects model (using <code>lme()</code>) and the survival model (using <code>coxph()</code>)
that were supplied as the two first argument of <code><a href="#topic+jointModelBayes">jointModelBayes</a></code>. In addition, this data frame should contain a variable 
that identifies the different subjects (see also argument <code>idVar</code>).</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_type">type</code></td>
<td>
<p>character string indicating what to compute, i.e., survival probabilities or the log conditional density.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_idvar">idVar</code></td>
<td>
<p>the name of the variable in <code>newdata</code> that identifies the different subjects.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_simulate">simulate</code></td>
<td>
<p>logical; if <code>TRUE</code>, a Monte Carlo approach is used to estimate survival probabilities. If <code>FALSE</code>,
a first order estimator is used instead. (see <b>Details</b>)</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_survtimes">survTimes</code></td>
<td>
<p>a numeric vector of times for which prediction survival probabilities are to be computed.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_last.time">last.time</code></td>
<td>
<p>a numeric vector or character string. This specifies the known time at which each of the subjects in <code>newdata</code>
was known to be alive. If <code>NULL</code>, then this is automatically taken as the last time each subject provided a longitudinal
measurement. If a numeric vector, then it is assumed to contain this last time point for each subject. If a character string, then
it should be a variable in the data frame <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_lefttrunc_var">LeftTrunc_var</code></td>
<td>
<p>character string indicating the name of the variable in <code>newdata</code> that denotes the left-truncation
time.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_m">M</code></td>
<td>
<p>integer denoting how many Monte Carlo samples to use &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_ci.levels">CI.levels</code></td>
<td>
<p>a numeric vector of length two that specifies which quantiles to use for the calculation of confidence interval for the 
predicted probabilities &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_log">log</code></td>
<td>
<p>logical, should results be returned in the log scale.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_scale">scale</code></td>
<td>
<p>a numeric scalar that controls the acceptance rate of the Metropolis-Hastings algorithm &ndash; see <b>Details</b>.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_weight">weight</code></td>
<td>
<p>a numeric vector of weights to be applied to the predictions of each subject.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_init.b">init.b</code></td>
<td>
<p>a numeric matrix of initial values for the random effects. These are used in the optimization procedure that finds the 
mode of the posterior distribution described in Step 2 below.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_seed">seed</code></td>
<td>
<p>numeric scalar, the random seed used to produce the results.</p>
</td></tr>
<tr><td><code id="survfitJM_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a fitted joint model (represented by <code>object</code>), and a history of longitudinal responses 
<code class="reqn">\tilde{y}_i(t) = \{y_i(s), 0 \leq s \leq t\}</code> and a covariates vector <code class="reqn">x_i</code> (stored in
<code>newdata</code>), this function provides estimates of <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code>, i.e., the conditional probability of surviving time <code class="reqn">u</code> given that subject <code class="reqn">i</code>, with covariate information
<code class="reqn">x_i</code>, has survived up to time <code class="reqn">t</code> and has provided longitudinal the measurements <code class="reqn">\tilde{y}_i(t)</code>.
</p>
<p>To estimate <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \tilde{y}_i(t), x_i)</code> and if <code>simulate = TRUE</code>, a 
Monte Carlo procedure is followed with the following steps:
</p>

<dl>
<dt>Step 1:</dt><dd><p>Take randomly a realization, say <code class="reqn">\theta^*</code> from the MCMC sample of posterior of the joint model represented by <code>object</code>.</p>
</dd>
<dt>Step 2:</dt><dd><p>Simulate random effects values, say <code class="reqn">b_i^*</code>, from their posterior distribution given survival up to time <code class="reqn">t</code>,
the vector of longitudinal responses <code class="reqn">\tilde{y}_i(t)</code> and <code class="reqn">\theta^*</code>. This is achieved using a Metropolis-Hastings algorithm with
independent proposals from a properly centered and scaled multivariate <code class="reqn">t</code> distribution. The <code>scale</code> argument controls the 
acceptance rate for this algorithm.</p>
</dd>
<dt>Step 3</dt><dd><p>Using <code class="reqn">\theta^*</code> and <code class="reqn">b_i^*</code>, compute <code class="reqn">Pr(T_i &gt; u | T_i &gt; t, b_i^*, x_i; \theta^*)</code>.</p>
</dd>
<dt>Step 4:</dt><dd><p>Repeat Steps 1-3 <code>M</code> times.</p>
</dd>
</dl>

<p>Based on the <code>M</code> estimates of the conditional probabilities, we compute useful summary statistics, such as their mean, median, and
percentiles (to produce a confidence interval).
</p>
<p>If <code>simulate = FALSE</code>, then survival probabilities are estimated using the formula </p>
<p style="text-align: center;"><code class="reqn">Pr(T_i &gt; u | T_i &gt; t, \hat{b}_i, x_i; 
    \hat{\theta}),</code>
</p>
<p> where <code class="reqn">\hat{\theta}</code> denotes the posterior means for the parameters, 
and <code class="reqn">\hat{b}_i</code> denotes the posterior means for the random effects.
</p>


<h3>Value</h3>

<p>A list of class <code>survfit.JMbayes</code> with components:
</p>
<table>
<tr><td><code>summaries</code></td>
<td>
<p>a list with elements numeric matrices with numeric summaries of the predicted probabilities for each subject.</p>
</td></tr>
<tr><td><code>survTimes</code></td>
<td>
<p>a copy of the <code>survTimes</code> argument.</p>
</td></tr>
<tr><td><code>last.time</code></td>
<td>
<p>a numeric vector with the time of the last available longitudinal measurement of each subject.</p>
</td></tr>
<tr><td><code>obs.times</code></td>
<td>
<p>a list with elements numeric vectors denoting the timings of the longitudinal measurements for each subject.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a list with elements numeric vectors denoting the longitudinal responses for each subject.</p>
</td></tr>
<tr><td><code>full.results</code></td>
<td>
<p>a list with elements numeric matrices with predicted probabilities for each subject in each replication of the Monte Carlo
scheme described above.</p>
</td></tr>
<tr><td><code>success.rate</code></td>
<td>
<p>a numeric vector with the success rates of the Metropolis-Hastings algorithm described above for each subject.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>a copy of the <code>scale</code> argument.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>References</h3>

<p>Rizopoulos, D. (2016). The R package JMbayes for fitting joint models for longitudinal and
time-to-event data using MCMC. <em>Journal of Statistical Software</em> <b>72(7)</b>, 1&ndash;45.
doi:10.18637/jss.v072.i07.
</p>
<p>Rizopoulos, D. (2012) <em>Joint Models for Longitudinal and Time-to-Event Data: with 
Applications in R</em>. Boca Raton: Chapman and Hall/CRC.
</p>
<p>Rizopoulos, D. (2011). Dynamic predictions and prospective accuracy in joint models for longitudinal and time-to-event data. 
<em>Biometrics</em> <b>67</b>, 819&ndash;829.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.survfit.JMbayes">plot.survfit.JMbayes</a></code>, <code><a href="#topic+predict.JMbayes">predict.JMbayes</a></code>, 
<code><a href="#topic+aucJM">aucJM</a></code>, <code><a href="#topic+dynCJM">dynCJM</a></code>, <code><a href="#topic+prederrJM">prederrJM</a></code>, <code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# we construct the composite event indicator (transplantation or death)
pbc2$status2 &lt;- as.numeric(pbc2$status != "alive")
pbc2.id$status2 &lt;- as.numeric(pbc2.id$status != "alive")

# we fit the joint model using splines for the subject-specific 
# longitudinal trajectories and a spline-approximated baseline
# risk function
lmeFit &lt;- lme(log(serBilir) ~ ns(year, 2), data = pbc2,
    random = ~ ns(year, 2) | id)
survFit &lt;- coxph(Surv(years, status2) ~ drug, data = pbc2.id, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "year")

# we will compute survival probabilities for Subject 2 in a dynamic manner, 
# i.e., after each longitudinal measurement is recorded
ND &lt;- pbc2[pbc2$id == 2, ] # the data of Subject 2
survPreds &lt;- vector("list", nrow(ND))
for (i in 1:nrow(ND)) {
    survPreds[[i]] &lt;- survfitJM(jointFit, newdata = ND[1:i, ])
}
survPreds

###########################################################################

# Predictions from multivariate models

pbc2 &lt;- pbc2[!is.na(pbc2$serChol), ]
pbc2.id &lt;- pbc2[!duplicated(pbc2$id), ]
pbc2.id$Time &lt;- pbc2.id$years
pbc2.id$event &lt;- as.numeric(pbc2.id$status != "alive")

# Fit a trivariate joint model
MixedModelFit &lt;- mvglmer(list(log(serBilir) ~ year + (year | id),
                              sqrt(serChol) ~ year + (year | id),
                              hepatomegaly ~ year + (year | id)), data = pbc2,
                         families = list(gaussian, gaussian, binomial), engine = "STAN")

CoxFit &lt;- coxph(Surv(Time, event) ~ drug + age, data = pbc2.id, model = TRUE)

JMFit &lt;- mvJointModelBayes(MixedModelFit, CoxFit, timeVar = "year")

# We want survival probabilities for three subjects
ND &lt;- pbc2[pbc2$id %in% c(2, 25, 81), ]

sprobs &lt;- survfitJM(JMFit, ND)
sprobs

# Basic plot
plot(sprobs)

# split in a 2 rows 2 columns and include the survival function in 
# a separate panel; plot only the third &amp; first subjects; change various defaults
plot(sprobs, split = c(3, 2), surv_in_all = FALSE, which_subjects = c(3, 1),
     lty_lines_CI = 3, col_lines = "blue", col_fill_CI = "red", 
     col_points = "pink", pch_points = 12)

###########################################################################

# run Shiny app
runDynPred()

## End(Not run)
</code></pre>

<hr>
<h2 id='tve'> Time-Varying Effects using P-splines </h2><span id='topic+tve'></span>

<h3>Description</h3>

<p>A B-spline expansion of the input variables to be used for a time-varying effect 
in the specification of joint model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tve(x, df = NULL, knots = NULL, ord = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tve_+3A_x">x</code></td>
<td>
<p>a numeric input variable.</p>
</td></tr>
<tr><td><code id="tve_+3A_df">df</code></td>
<td>
<p>integer denoting the degrees of freedom.</p>
</td></tr>
<tr><td><code id="tve_+3A_knots">knots</code></td>
<td>
<p>a numeric vector of knots.</p>
</td></tr>
<tr><td><code id="tve_+3A_ord">ord</code></td>
<td>
<p>an integer denoting the order of the spline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>tve</code>.
</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>

<hr>
<h2 id='xtable'>xtable Method from Joint Models.</h2><span id='topic+xtable.JMbayes'></span>

<h3>Description</h3>

<p>produces a LaTeX table with the results of a joint model using package xtable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JMbayes'
xtable(x, caption = NULL, label = NULL, align = NULL,
    digits = NULL, display = NULL, which = c("all", "Longitudinal", "Event"),
    varNames.Long = NULL, varNames.Event = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtable_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code>JMbayes</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_caption">caption</code></td>
<td>
<p>the <code>caption</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_label">label</code></td>
<td>
<p>the <code>label</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_align">align</code></td>
<td>
<p>the <code>align</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_digits">digits</code></td>
<td>
<p>the <code>digits</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_display">display</code></td>
<td>
<p>the <code>display</code> argument of <code>xtable()</code>.</p>
</td></tr>
<tr><td><code id="xtable_+3A_which">which</code></td>
<td>
<p>a character string indicating which results to include in the
LaTeX table. Options are all results, the results of longitudinal
submodel or the results of the survival submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_varnames.long">varNames.Long</code></td>
<td>
<p>a character vector of the variable names for the
longitudinal submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_varnames.event">varNames.Event</code></td>
<td>
<p>a character vector of the variable names for the
survival submodel.</p>
</td></tr>
<tr><td><code id="xtable_+3A_...">...</code></td>
<td>
<p>additional arguments; currently none is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A LaTeX code chunk with the results of the joint modeling analysis.</p>


<h3>Author(s)</h3>

<p>Dimitris Rizopoulos <a href="mailto:d.rizopoulos@erasmusmc.nl">d.rizopoulos@erasmusmc.nl</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+jointModelBayes">jointModelBayes</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
prothro$t0 &lt;- as.numeric(prothro$time == 0)
lmeFit &lt;- lme(pro ~ treat * (time + t0), random = ~ time | id, data = prothro)
survFit &lt;- coxph(Surv(Time, death) ~ treat, data = prothros, x = TRUE)
jointFit &lt;- jointModelBayes(lmeFit, survFit, timeVar = "time")
    
if (require("xtable")) {
    xtable:::xtable(jointFit, math.style.negative = TRUE)
}

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
