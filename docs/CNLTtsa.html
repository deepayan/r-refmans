<!DOCTYPE html><html lang="en"><head><title>Help for package CNLTtsa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CNLTtsa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CNLTtsa-package'>
<p>Complex-Valued Wavelet Lifting for Univariate and Bivariate Time Series Analysis</p></a></li>
<li><a href='#Baidu'>
<p>End of second returns for Google from 1st March 2011</p></a></li>
<li><a href='#cnlt.biv'>
<p>Performs 'nondecimated' complex-valued wavelet lifting for bivariate time series analysis</p></a></li>
<li><a href='#cnlt.spec'>
<p>A function to compute CNLT spectral quantities for univariate and bivariate series</p></a></li>
<li><a href='#cnlt.univ'><p>Performs 'nondecimated' complex-valued wavelet lifting for univariate time series analysis</p></a></li>
<li><a href='#cnltspec.plot'>
<p>A function to plot CNLT spectral quantities of interest</p></a></li>
<li><a href='#Google'>
<p>End of second returns for Google from 1st March 2011</p></a></li>
<li><a href='#pre.per'>
<p>Functions to form periodogram objects with a common time and scale bins for bivariate series with different sampling grids for each component</p></a></li>
<li><a href='#smooth.over.scale'>
<p>Function to perform smoothing over scale of spectral quantities</p></a></li>
<li><a href='#smooth.over.time'>
<p>Function to perform smoothing over time of spectral quantities</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Complex-Valued Wavelet Lifting for Univariate and Bivariate Time
Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-07-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Jean Hamilton [aut],
  Matt Nunes [aut, cre],
  Marina Knight [ctb],
  Piotr Fryzlewicz [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of recent complex-valued wavelet spectral procedures for analysis of irregularly sampled signals, see Hamilton et al (2018) &lt;<a href="https://doi.org/10.1080%2F00401706.2017.1281846">doi:10.1080/00401706.2017.1281846</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.1), adlift, nlt, CNLTreg, fields</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-07-18 12:37:29 UTC; nunes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-07-18 13:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='CNLTtsa-package'>
Complex-Valued Wavelet Lifting for Univariate and Bivariate Time Series Analysis
</h2><span id='topic+CNLTtsa-package'></span><span id='topic+CNLTtsa'></span>

<h3>Description</h3>

<p>Implementations of recent complex-valued wavelet spectral procedures for analysis of irregularly sampled signals, see Hamilton et al (2018) &lt;doi:10.1080/00401706.2017.1281846&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CNLTtsa</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Complex-Valued Wavelet Lifting for Univariate and Bivariate Time Series Analysis</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-07-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Jean Hamilton [aut], Matt Nunes [aut, cre], Marina Knight [ctb], Piotr Fryzlewicz [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Jean", "Hamilton", role="aut"),person("Matt","Nunes", role=c("aut","cre"),email="nunesrpackages@gmail.com"),person("Marina", "Knight", role="ctb"), person("Piotr", "Fryzlewicz", role="ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementations of recent complex-valued wavelet spectral procedures for analysis of irregularly sampled signals, see Hamilton et al (2018) &lt;doi:10.1080/00401706.2017.1281846&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.1), adlift, nlt, CNLTreg, fields</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
Baidu                   End of second returns for Google from 1st March
                        2011
CNLTtsa-package         Complex-Valued Wavelet Lifting for Univariate
                        and Bivariate Time Series Analysis
Google                  End of second returns for Google from 1st March
                        2011
cnlt.biv                Performs 'nondecimated' complex-valued wavelet
                        lifting for bivariate time series analysis
cnlt.spec               A function to compute CNLT spectral quantities
                        for univariate and bivariate series
cnlt.univ               Performs 'nondecimated' complex-valued wavelet
                        lifting for univariate time series analysis
cnltspec.plot           A function to plot CNLT spectral quantities of
                        interest
pre.per                 Functions to form periodogram objects with a
                        common time and scale bins for bivariate series
                        with different sampling grids for each
                        component
smooth.over.scale       Function to perform smoothing over scale of
                        spectral quantities
smooth.over.time        Function to perform smoothing over time of
                        spectral quantities
</pre>
<p>The main routines of the package are <code><a href="#topic+cnlt.univ">cnlt.univ</a></code> and <code><a href="#topic+cnlt.biv">cnlt.biv</a></code> which perform the nondecimated complex-valued lifting transform
for univariate and bivariate time series, respectively; <code><a href="#topic+cnlt.spec">cnlt.spec</a></code> computes spectral quantities of interest, for example the coherence and phase between two components of a bivariate series.
</p>


<h3>Author(s)</h3>

<p>Jean Hamilton [aut], Matt Nunes [aut, cre], Marina Knight [ctb], Piotr Fryzlewicz [ctb]
</p>
<p>Maintainer: Matt Nunes &lt;nunesrpackages@gmail.com&gt;
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
For related literature on the lifting methodology adopted in the technique, see<br /><br />
Knight, M. I. and Nason, G. P. (2009) A 'nondecimated' wavelet transform. <em>Stat. Comput.</em>
<b>19</b> (1), 1&ndash;16.<br /><br />
Knight, M. I., Nunes, M. A. and Nason, G. P. (2012) Spectral Estimation for Locally Stationary Time Series with Missing Observations. <em>Stat. Comput.</em>
<b>22</b> (4), 877&ndash;895.
</p>


<h3>See Also</h3>

<p><code><a href="CNLTreg.html#topic+cnlt.reg">cnlt.reg</a></code></p>

<hr>
<h2 id='Baidu'>
End of second returns for Google from 1st March 2011
</h2><span id='topic+Baidu'></span>

<h3>Description</h3>

<p>Often several trades per second of a stock occur; this dataset consists of the last quoted value for each second for 1st March 2011.
Thus the finest sampling interval is one second, but as there are seconds with no trades, the data have an unequally spaced sampling regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Baidu")</code></pre>


<h3>Format</h3>

<p>A data frame with 7984 observations on the following 3 variables.
</p>

<dl>
<dt><code>Time</code></dt><dd><p>A variable with the time of the trade.</p>
</dd>
<dt><code>Seconds.index</code></dt><dd><p>An index representing the time (in seconds) from the start of the data, representing the sampling regime of the series.</p>
</dd>
<dt><code>Return</code></dt><dd><p>The return price of the stock.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Baidu)

plot(Baidu$Seconds.index,Baidu$Return,type="l")
</code></pre>

<hr>
<h2 id='cnlt.biv'>
Performs 'nondecimated' complex-valued wavelet lifting for bivariate time series analysis
</h2><span id='topic+cnlt.biv'></span>

<h3>Description</h3>

<p>The forward complex-valued lifting transform for decomposing a signal of interest is dependent on the trajectory (lifting order) used in the forward lifting transform.
This procedure uses trajectory bootstrapping to provide (complex-valued) time-scale information at all times and scales for bivariate series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnlt.biv(x1, x2 = NULL, f1, f2, P = 100, nkeep = 2, use.same.trajectories = FALSE, 
verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnlt.biv_+3A_x1">x1</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_x2">x2</code></td>
<td>
<p>An optional vector of grid values corresponding to <span class="env">f2</span>. Can be of any length, not necessarily equally spaced.  If not specified (<code>NULL</code>), then the same grid is used for <code>f2</code> as <code>f1</code>, i.e. <span class="env">x1</span>.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_f1">f1</code></td>
<td>
<p>A vector of function values of the first component of a bivariate series, corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_f2">f2</code></td>
<td>
<p>A vector of function values of the second component of a bivariate series, corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_p">P</code></td>
<td>
<p>Number of trajectories to be used in the nondecimated lifting transform.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_nkeep">nkeep</code></td>
<td>
<p>Number of scaling points we want at the end of the transform. The usual choice is <code>nkeep</code>=2.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_use.same.trajectories">use.same.trajectories</code></td>
<td>
<p>A boolean variable indicating whether the same set of trajectories should be used for both components of the bivariate signal.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_verbose">verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td></tr>
<tr><td><code id="cnlt.biv_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code>, see the function documentation for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function applies the forward complex wavelet lifting transform <code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code> <span class="env">P</span> times on both (<span class="env">x</span>,<span class="env">f1</span>) and (<span class="env">x</span>,<span class="env">f2</span>), each with a different random lifting
trajectory.  This results in <span class="env">P</span> sets of complex-valued detail coefficients, along with their associated scales.  This information is stored in order to compute the
cross-periodograms for the bivariate series (<span class="env">x</span>,<span class="env">f1</span>,<span class="env">f2</span>).  The &ldquo;degree of asymmetry&quot; in the prediction is also recorded.
This is the ratio between the maximum distance to the removed point to one of its neighbours and the minimum distance from the removed point to one of its neighbours,
see Chapter 5.3 in Sanderson (2010) for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>cnlt</code> (subclasses <code>biv</code> and either <code>SG</code> or <code>DG</code>).<br />
If both components have the same grid (subclass <code>SG</code>), a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>x1</code></td>
<td>
<p>The sampling grid corresponding to <span class="env">f1</span> used for the decomposition.</p>
</td></tr>
<tr><td><code>x2</code></td>
<td>
<p>The sampling grid corresponding to <span class="env">f2</span> used for the decomposition.  If the object is of subclass <code>SG</code>, <code>x1</code> is the same as <code>x2</code>.</p>
</td></tr>
<tr><td><code>det1</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to detail coefficients associated to point <code>x_i</code> and <span class="env">f1</span>.</p>
</td></tr>
<tr><td><code>det2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to detail coefficients associated to point <code>x_i</code> and <span class="env">f2</span>.</p>
</td></tr>
<tr><td><code>lre</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the scales (integrals) when lifting point <code>x_i</code> and <span class="env">f1</span>.</p>
</td></tr>
<tr><td><code>lreA</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the degree of asymmetry of the neighbourhood used in the prediction step of point <code>x_i</code>, see description above.</p>
</td></tr>
</table>
<p>If both components have different sampling grids, the additional following list components are returned:<br />
</p>
<table role = "presentation">
<tr><td><code>lre2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the scales (integrals) when lifting point <code>x_i2</code> and <span class="env">f2</span>.</p>
</td></tr>
<tr><td><code>lreA2</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the degree of asymmetry of the neighbourhood used in the prediction step of point <code>x_i2</code> with <span class="env">f2</span>, see description above.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Using a large number of trajectories for long datasets could take a long time!</p>


<h3>Author(s)</h3>

<p>Matt Nunes, Jean Hamilton
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
Sanderson, J. (2010) Wavelet methods for time series with bivariate observations and irregular sampling grids. PhD Thesis, University of Bristol, UK.<br /><br />
For the real-valued equivalent procedure, see also<br />
Knight, M. I., Nunes, M. A. and Nason, G. P. (2012) Spectral Estimation for Locally Stationary Time Series with Missing Observations. <em>Stat. Comput.</em>
<b>22</b> (4), 877&ndash;895.
</p>


<h3>See Also</h3>

<p><code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code>,
<code>link{cnlt.univ}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a bivariate series example with same grids

# simulate data, e.g. two sinusoids
dat &lt;- seq(from=1, to=3, by=0.1)
x1 &lt;- cumsum(sample(dat, 200, TRUE))

y1 &lt;-sin(2*pi*(1/25)*x1) + sin(2*pi*(1/50)*x1)+ 1*sin(2*pi*(1/10)*x1)+ rnorm(length(x1), 0,0.2)
y3 &lt;- c(sin(2*pi*(1/25)*x1[1:100]),sin(2*pi*(1/25)*x1[97:196]))+ rnorm(length(x1), 0,0.1)

## Not run: 
y1y3.dec&lt;-cnlt.biv(x1, f1=y1, f2=y3, P = 500)

# the complex detail coefficients corresponding to the first timepoint are:

y1y3.dec$det1[[1]]


## End(Not run)

# a bivariate series example with different grids

# load some data in

data(Baidu)
data(Google)

## Not run: 
BaiGoo&lt;-cnlt.biv(Baidu$Seconds[1:100], Google$Seconds[1:100], Baidu$Return[1:100], 
Google$Return[1:100], P = 500)

# now look at some of the coefficients from the decomposition
# (the complex detail coefficients corresponding to the first timepoint:

BaiGoo$det1[[1]]
BaiGoo$det2[[1]]

## End(Not run)

</code></pre>

<hr>
<h2 id='cnlt.spec'>
A function to compute CNLT spectral quantities for univariate and bivariate series
</h2><span id='topic+cnlt.spec'></span><span id='topic+cnlt.spec.SG'></span><span id='topic+cnlt.spec.DG'></span>

<h3>Description</h3>

<p>The function takes a nondecimated complex lifting decomposition of a univariate or bivariate series, and uses
smoothing before computing spectral quantities such as the complex periodograms, coherence and phase
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnlt.spec(x, ...)
## S3 method for class 'SG'
cnlt.spec(x, M = 50, fact = 1, ...)
## S3 method for class 'DG'
cnlt.spec(x, M = 50, fact = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnlt.spec_+3A_x">x</code></td>
<td>
<p>An object of class <code>cnlt</code>, i.e. the output from either <code><a href="#topic+cnlt.univ">cnlt.univ</a></code> or <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="cnlt.spec_+3A_m">M</code></td>
<td>
<p>The smoothing parameter (binwidth) or vector of smoothing parameters (one for each scale) for the time-domain kernel smoothing method, see <code><a href="#topic+smooth.over.time">smooth.over.time</a></code>.</p>
</td></tr>
<tr><td><code id="cnlt.spec_+3A_fact">fact</code></td>
<td>
<p>If <code>length(M)==1</code>, a factor indicating how the smoothing parameter (binwidth) in the time-domain kernel smoothing method should increase from 
one scale to the next, see <code><a href="#topic+smooth.over.time">smooth.over.time</a></code>.</p>
</td></tr>
<tr><td><code id="cnlt.spec_+3A_...">...</code></td>
<td>
<p>Any other parameters to be passed to the scale smoothing function, see the documentation for <code><a href="#topic+smooth.over.scale">smooth.over.scale</a></code> for univariate <code>cnlt</code> objects, or <code><a href="#topic+pre.per">pre.per</a></code> for bivariate <code>cnlt</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For univariate series, the nondecimated complex lifting object can be used to form a spectral object by smoothing the squared details over scale (with <code><a href="#topic+smooth.over.scale">smooth.over.scale</a></code>), and then smoothing over time (using <code><a href="#topic+smooth.over.time">smooth.over.time</a></code>).  Smoothing over scale is done via <code>smooth.spline</code>; smoothing over time is done with a kernel smoother (e.g. a &quot;box&quot; kernel for a moving average).
See Hamilton et al. (2018) for more details.	
</p>


<h3>Value</h3>

<p>An object of class <code>cnlt.spec</code> (subclasses: <code>DG</code>, <code>SG</code>, <code>univ</code>, <code>biv</code>).  <br />
</p>
<p>For subclass <code>univ</code>, a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>S1</code></td>
<td>
<p>A spectral object (matrix) of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the univariate series.</p>
</td></tr>
<tr><td><code>mscale</code></td>
<td>
<p>A vector of scales corresponding to the rows of the spectrum <code>S1</code> (after smoothing the periodogram), see <code><a href="#topic+smooth.over.scale">smooth.over.scale</a></code>.</p>
</td></tr>
<tr><td><code>mtime</code></td>
<td>
<p>The vector <code>cnltobj$x</code>, the vector of times corresponding to the columns of the spectrum <code>S1</code>.</p>
</td></tr>
</table>
<p>For subclass <code>biv</code>, a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>coh</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the coherence between the two components of the bivariate series.</p>
</td></tr>
<tr><td><code>phase</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the phase between the two components of the bivariate series.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the co-periodogram of the bivariate series.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the quadrature periodogram of the bivariate series.</p>
</td></tr>
<tr><td><code>S1</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the first component of the bivariate series.</p>
</td></tr>
<tr><td><code>S2</code></td>
<td>
<p>A matrix of dimension <code>length(mscale) x length(mtime)</code>, corresponding to the spectrum of the second component of the  bivariate series.</p>
</td></tr>
<tr><td><code>mscale</code></td>
<td>
<p>A vector of scales corresponding to the rows of the spectrum <code>S1</code> (after smoothing the periodogram), see <code><a href="#topic+smooth.over.scale">smooth.over.scale</a></code>.</p>
</td></tr>
<tr><td><code>mtime</code></td>
<td>
<p>A vector of times corresponding to the columns of the spectrum <code>S1</code>.  If the class of <code>cnlt.obj</code> is <code>SG</code>, this is <code>cnlt.obj$x1</code>, else this is a vector formed by binning detail coefficients within equal intervals of time, see <code><a href="#topic+pre.per">pre.per</a></code> for more details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matt Nunes, Jean Hamilton
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cnlt.biv">cnlt.biv</a></code>,
<code><a href="#topic+cnlt.univ">cnlt.univ</a></code>,
<code><a href="#topic+cnltspec.plot">cnltspec.plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# read some data in (a bivariate series)

## Not run: 

data(Baidu)
data(Google)

BaiGoo&lt;-cnlt.biv(Baidu$Seconds[1:100], Google$Seconds[1:100], Baidu$Return[1:100], 
Google$Return[1:100], P = 500)

specobj&lt;-cnlt.spec(BaiGoo,M=10,fact=1.05, Tstar=20)

## End(Not run)

</code></pre>

<hr>
<h2 id='cnlt.univ'>Performs 'nondecimated' complex-valued wavelet lifting for univariate time series analysis</h2><span id='topic+cnlt.univ'></span>

<h3>Description</h3>

<p>The forward complex-valued lifting transform for decomposing a signal of interest is dependent on the trajectory (lifting order) used in the forward lifting transform.  
This procedure uses trajectory bootstrapping to provide (complex-valued) time-scale information at all times and scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnlt.univ(x, f, P = 100, nkeep = 2, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnlt.univ_+3A_x">x</code></td>
<td>
<p>A vector of grid values. Can be of any length, not necessarily equally spaced.</p>
</td></tr>
<tr><td><code id="cnlt.univ_+3A_f">f</code></td>
<td>
<p>A vector of function values corresponding to <span class="env">x</span>. Must be of the same length as <span class="env">x</span>.</p>
</td></tr>
<tr><td><code id="cnlt.univ_+3A_p">P</code></td>
<td>
<p>Number of trajectories to be used in the nondecimated lifting transform.</p>
</td></tr>
<tr><td><code id="cnlt.univ_+3A_nkeep">nkeep</code></td>
<td>
<p>Number of scaling points we want at the end of the transform. The usual choice is <code>nkeep</code>=2.</p>
</td></tr>
<tr><td><code id="cnlt.univ_+3A_verbose">verbose</code></td>
<td>
<p>Indicates whether useful messages should be printed to the console during the procedure.</p>
</td></tr>
<tr><td><code id="cnlt.univ_+3A_...">...</code></td>
<td>
<p>Any other arguments to be passed to <code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code>, see the function documentation for more details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this function applies the forward complex wavelet lifting transform <code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code> <span class="env">P</span> times, each with a different random lifting 
trajectory.  This results in <span class="env">P</span> sets of complex-valued detail coefficients, along with their associated scales.  This information is stored in order to compute the 
periodogram for (<span class="env">x</span>,<span class="env">f</span>).  The &ldquo;degree of asymmetry&quot; in the prediction is also recorded.  
This is the ratio between the maximum distance to the removed point to one of its neighbours and the minimum distance from the removed point to one of its neighbours, 
see Chapter 5.3 in Sanderson (2010) for more details.
</p>


<h3>Value</h3>

<p>An object of class <code>cnlt</code> (subclasses: <code>univ</code>, <code>SG</code>).  A list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>The sampling grid corresponding to <span class="env">f</span> used for the decomposition.</p>
</td></tr>
<tr><td><code>det1</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to detail coefficients associated to point <code>x_i</code>.</p>
</td></tr>
<tr><td><code>lre</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the scales (integrals) when lifting point <code>x_i</code>.</p>
</td></tr>
<tr><td><code>lreA</code></td>
<td>
<p>A list, entry <code>i</code> corresponding to the degree of asymmetry of the neighbourhood used in the prediction step of point <code>x_i</code>, see description above.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Using a large number of trajectories for long datasets could take a long time!</p>


<h3>Author(s)</h3>

<p>Jean Hamilton, Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
Sanderson, J. (2010) Wavelet methods for time series with bivariate observations and irregular sampling grids. PhD Thesis, University of Bristol, UK.<br /><br />
For the real-valued equivalent procedure, see also<br />
Knight, M. I., Nunes, M. A. and Nason, G. P. (2012) Spectral Estimation for Locally Stationary Time Series with Missing Observations. <em>Stat. Comput.</em>
<b>22</b> (4), 877&ndash;895.
</p>


<h3>See Also</h3>

<p><code><a href="CNLTreg.html#topic+fwtnppermC">fwtnppermC</a></code>,
<code>link{get.percoeffsC.biv}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-sort(runif(100))

y &lt;-sin(2*pi*(1/25)*x) + sin(2*pi*(1/50)*x)

## Not run: 
xy.dec&lt;-cnlt.univ(x,y,P=300)

xy.dec$det[[1]][1:10]

## End(Not run)

</code></pre>

<hr>
<h2 id='cnltspec.plot'>
A function to plot CNLT spectral quantities of interest
</h2><span id='topic+cnltspec.plot'></span>

<h3>Description</h3>

<p>The function takes a spectral quantity and plots it according to user inputted graphical options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnltspec.plot(spec, timevec, scalevec, zrange = NULL, xtitle = "Time", ytitle = "Scale", 
col.scale = tim.colors(64)[1:45], SFratio = 2, dt = 1, parsw = 3, axis4 = FALSE, 
frequencies = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cnltspec.plot_+3A_spec">spec</code></td>
<td>
<p>A spectral quantity, i.e. contained in a <code>cnlt.spec</code> object.  For example, this could be the coherence between components of a bivariate series.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_timevec">timevec</code></td>
<td>
<p>A vector corresponding to the x-axis of the spectral object, often time or a sampling grid.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_scalevec">scalevec</code></td>
<td>
<p>A vector of scales corresponding to the y-axis of the spectral object.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_zrange">zrange</code></td>
<td>
<p>An optional length two vector specifying the range of the z-axis of the plot.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_xtitle">xtitle</code></td>
<td>
<p>A label for the x-axis of the plot.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_ytitle">ytitle</code></td>
<td>
<p>A label for the y-axis of the plot.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_col.scale">col.scale</code></td>
<td>
<p>a color palette to use for the spectral plot.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_sfratio">SFratio</code></td>
<td>
<p>A number specifying the relationship between scale and Fourier frequency, see <span class="env">frequencies</span> argument, and Sanderson (2010), chapter 6.2.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_dt">dt</code></td>
<td>
<p>A sampling interval, used to compute the relationship between scale and Fourier frequency, see Sanderson (2010), chapter 6.2.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_parsw">parsw</code></td>
<td>
<p>A number from 1 to 3, specifying different spacings between the plot and the legend.  This is useful if you want to do call <code>cnltspec.plot</code> multiple times for e.g. multi-panel plots.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_axis4">axis4</code></td>
<td>
<p>An optional boolean variable indicating whether a 4th (right) axis should be added to the plot.</p>
</td></tr>
<tr><td><code id="cnltspec.plot_+3A_frequencies">frequencies</code></td>
<td>
<p>If <code>axis4 = TRUE</code>, an optional vector for the ticks on the 4th axis.  If these are not specified, then a vector of Fourier frequencies are plotted, with the relationship between scale and frequency specified by <span class="env">SFratio</span>, see Sanderson (2010), chapter 6.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spectral quantity is plotted.
</p>


<h3>Author(s)</h3>

<p>Jean Hamilton, Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.<br /><br />
Sanderson, J. (2010) Wavelet methods for time series with bivariate observations and irregular sampling grids. PhD Thesis, University of Bristol, UK.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cnlt.spec">cnlt.spec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data, e.g. two sinusoids
dat &lt;- seq(from=1, to=3, by=0.1)
x1 &lt;- cumsum(sample(dat, 200, TRUE)) 

y1 &lt;-sin(2*pi*(1/25)*x1) + sin(2*pi*(1/50)*x1)+ 1*sin(2*pi*(1/10)*x1)+ rnorm(length(x1), 0,0.2)
y3 &lt;- c(sin(2*pi*(1/25)*x1[1:100]),sin(2*pi*(1/25)*x1[97:196]))+ rnorm(length(x1), 0,0.1)

## Not run: 

y1y3.dec&lt;-cnlt.biv(x1, f1=y1, f2=y3, P = 500)

y1y3spec&lt;-cnlt.spec(y1y3.dec)

cnltspec.plot(y1y3spec$coh,y1y3spec$mtime,y1y3spec$mscale)

## End(Not run)

</code></pre>

<hr>
<h2 id='Google'>
End of second returns for Google from 1st March 2011
</h2><span id='topic+Google'></span>

<h3>Description</h3>

<p>Often several trades per second of a stock occur; this dataset consists of the last quoted value for each second for 1st March 2011. 
Thus the finest sampling interval is one second, but as there are seconds with no trades, the data have an unequally spaced sampling regime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Google")</code></pre>


<h3>Format</h3>

<p>A data frame with 6526 observations on the following 3 variables.
</p>

<dl>
<dt><code>Time</code></dt><dd><p>A variable with the time of the trade.</p>
</dd>
<dt><code>Seconds.index</code></dt><dd><p>An index representing the time (in seconds) from the start of the data, representing the sampling regime of the series.</p>
</dd>
<dt><code>Return</code></dt><dd><p>The return price of the stock.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hamilton, J., Nunes, M. A, Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Google)

plot(Google$Seconds.index,Google$Return,type="l")
</code></pre>

<hr>
<h2 id='pre.per'>
Functions to form periodogram objects with a common time and scale bins for bivariate series with different sampling grids for each component
</h2><span id='topic+pre.per'></span><span id='topic+pre.per.sample'></span><span id='topic+pre.per.comb'></span>

<h3>Description</h3>

<p>The CNLT forms detail coefficients for each component of a bivariate series.  Due to the two components having different sampling grids, the details (and associated scales) won't have a common association for both series.  Hence the details are sampled and mapped to a common timescale and a common set of scales via binning and averaging.  These functions compute spectral objects on these common times / scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre.per(x, det, lre, lreA, scale.range = NULL, time.range = NULL, Arange = NULL, 
Jstar = 20, Tstar = 50)
pre.per.comb(spec1, spec2)
pre.per.sample(spec1, spec2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pre.per_+3A_x">x</code></td>
<td>
<p>A vector corrsponding to the sampling grid of a component of a series.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_det">det</code></td>
<td>
<p>A list of (real or imaginary parts of) the detail coefficients from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_lre">lre</code></td>
<td>
<p>A list of scales (removed integral lengths) corresponding to <span class="env">det</span> from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_lrea">lreA</code></td>
<td>
<p>A list of asymmetry values from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_scale.range">scale.range</code></td>
<td>
<p>An optional two-vector specifying the range of scales to be considered in the resulting output spectrum.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_time.range">time.range</code></td>
<td>
<p>An optional two-vector specifying the range of times to be considered in the resulting output spectrum.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_arange">Arange</code></td>
<td>
<p>An optional two-vector specifying whether the values used in forming the output spectrum should be limited to those from a specific range of asymmetry values,
see Sanderson (2010), chapter 6.2.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_jstar">Jstar</code></td>
<td>
<p>The number of artificial scales in the output spectrum.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_tstar">Tstar</code></td>
<td>
<p>The number of artificial times in the output spectrum.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_spec1">spec1</code></td>
<td>
<p>A periodogram corresponding to the first component of a bivariate series.</p>
</td></tr>
<tr><td><code id="pre.per_+3A_spec2">spec2</code></td>
<td>
<p>A periodogram corresponding to the second component of a bivariate series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a bivariate series where the two components have different sampling grids, the co- /quadrature periodogram values are first formed using <code>pre.per</code>, 
using a vector of <span class="env">Tstar</span> equal time intervals, specified by setting <span class="env">Tstar</span> and optionally <span class="env">time.range</span>; they are also binned into <span class="env">Jstar</span> 
equal artificial levels by setting <span class="env">Jstar</span> and optionally <span class="env">scale.range</span>.  The details are sampled using a common sampling vector with <code>pre.per.sample</code>, 
and then combined using <code>pre.per.comb</code>. The periodogram is then smoothed over time. See Hamilton et al (2018), section 2.3 for more details. 
</p>


<h3>Value</h3>

<p>For <code>pre.per</code>, a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>A matrix of dimension <code>Jstar x Tstar</code> corrsponding to a quadrature periodogram / co-periodogram of a bivariate series.</p>
</td></tr>
<tr><td><code>mscale</code></td>
<td>
<p>A vector of scales (of length <span class="env">Jstar</span>) corresponding to the rows of the spectrum <code>spec</code>.</p>
</td></tr>
<tr><td><code>mtime</code></td>
<td>
<p>A vector of times (of length <span class="env">Tstar</span>) corresponding to the columns of the spectrum <code>spec</code>.</p>
</td></tr>
</table>
<p>For <code>pre.per.sample</code>, a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>spec1</code></td>
<td>
<p>A matrix of dimension <code>Jstar x Tstar</code> corrsponding to a periodogram of the first component of a bivariate series.</p>
</td></tr>
<tr><td><code>spec2</code></td>
<td>
<p>A matrix of dimension <code>Jstar x Tstar</code> corrsponding to a periodogram of the second component of a bivariate series.</p>
</td></tr>
</table>
<p>For <code>pre.per.comb</code>, a list with components:<br />
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>A matrix of dimension <code>Jstar x Tstar</code> corrsponding to a periodogram / quadrature periodogram / co-periodogram of a bivariate series.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that these functions aren't intended to be used directly, but are called internally from the function <code><a href="#topic+cnlt.spec.DG">cnlt.spec.DG</a></code>.  <br />
Note also that the argument <span class="env">Tstar</span> should be chosen small enough so that the range of the sampling grid <span class="env">x</span> can be divided into equally spaced intervals, 
with *at least one* gridpoint in an interval.  
</p>


<h3>Author(s)</h3>

<p>Jean Hamilton, Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cnlt.spec.DG">cnlt.spec.DG</a></code>,
<code><a href="#topic+smooth.over.time">smooth.over.time</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simulate data, e.g. two sinusoids
dat &lt;- seq(from=1, to=3, by=0.1)
x1 &lt;- cumsum(sample(dat, 200, TRUE))
x2 &lt;- cumsum(sample(dat, 200, TRUE))

y1 &lt;-sin(2*pi*(1/25)*x1) + sin(2*pi*(1/50)*x1)+ 1*sin(2*pi*(1/10)*x1)+ rnorm(length(x1), 0,0.2)
y3 &lt;- sin(2*pi*(1/25)*x2[97:196]) + rnorm(length(x2), 0,0.1)

## Not run: 
y1y3.dec&lt;-cnlt.biv(x1, f1=y1, f2=y3, P = 500)

# compute the co-periodogram for the first component...

C1 &lt;- pre.per(x1, sapply(y1y3.dec$det1,Re), y1y3.dec$lre1, y1y3.dec$lreA1, Jstar = 10)

# .. and for the second component
C2 &lt;- pre.per(x1, sapply(y1y3.dec$det2,Re), y1y3.dec$lre2, y1y3.dec$lreA2, Jstar = 10)

## End(Not run)

</code></pre>

<hr>
<h2 id='smooth.over.scale'>
Function to perform smoothing over scale of spectral quantities
</h2><span id='topic+smooth.over.scale'></span>

<h3>Description</h3>

<p>This function uses simple averaging or smoothing splines to smooth spectra over scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.over.scale(x, det1, det2, lre, lreA, scale.range = NULL, Arange = NULL, 
Jstar = 20, splines = FALSE, positive = FALSE, dfS = 10, interpolate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.over.scale_+3A_x">x</code></td>
<td>
<p>A vector corrsponding to the sampling grid of the component of a univariate series, or both components of a bivariate series with identical sampling grids.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_det1">det1</code></td>
<td>
<p>A list of (real or imaginary parts of) the component 1 detail coefficients from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_det2">det2</code></td>
<td>
<p>A list of (real or imaginary parts of) the component 2 detail coefficients from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_lre">lre</code></td>
<td>
<p>A list of scales (removed integral lengths) corresponding to <span class="env">det</span> from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_lrea">lreA</code></td>
<td>
<p>A list of asymmetry values from a CNLT decomposition, such as from the output of <code><a href="#topic+cnlt.biv">cnlt.biv</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_scale.range">scale.range</code></td>
<td>
<p>An optional two-vector specifying the range of scales to be considered in the resulting output spectrum.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_arange">Arange</code></td>
<td>
<p>An optional two-vector specifying whether the values used in forming the output spectrum should be limited to those from a specific range of asymmetry values,  
see Sanderson (2010), chapter 6.2.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_jstar">Jstar</code></td>
<td>
<p>The number of artificial scales in the output spectrum.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_splines">splines</code></td>
<td>
<p>An indicator variable whether smoothing splines should be used for the scale-based smoothing, or simple averaging (<code>splines = FALSE</code>).</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_positive">positive</code></td>
<td>
<p>An indicator variable whether the smoothing should ensure that the resulting output is positive or not (e.g. for spectra).</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_dfs">dfS</code></td>
<td>
<p>An argument, if <code>splines = TRUE</code>, specifying the number of degrees of freedom for the smoothing spline.</p>
</td></tr>
<tr><td><code id="smooth.over.scale_+3A_interpolate">interpolate</code></td>
<td>
<p>An indicator variable for whether interpolation should be used in the smoothing spline method for predicting values outside the range of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a univariate series or a bivariate series where the two components have the same sampling grids, the co- /quadrature periodogram values are first formed. 
They are then smoothed over scale (per timepoint), to give spectral values corresponding to equal artificial levels by setting <span class="env">Jstar</span> and optionally 
<span class="env">scale.range</span>.  
</p>


<h3>Value</h3>

<p>A list with the following components:<br />
</p>
<table role = "presentation">
<tr><td><code>spec</code></td>
<td>
<p>A matrix of dimension <code>Jstar x length(x)</code> corrsponding to a periodogram / co-periodogram / quadrature periodogram.</p>
</td></tr>
<tr><td><code>mscale</code></td>
<td>
<p>A vector of scales (of length <span class="env">Jstar</span>) corresponding to the rows of the spectrum <code>spec</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean Hamilton, Matt Nunes
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cnlt.spec.SG">cnlt.spec.SG</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x&lt;-sort(runif(100))

y &lt;-sin(2*pi*(1/25)*x) + sin(2*pi*(1/50)*x)

## Not run: 
xy.dec&lt;-cnlt.univ(x,y,P=300)

# compute the real part of the spectrum (real details^2) and smooth over scale
ReS &lt;- smooth.over.scale(x, sapply(xy.dec$det1,Re), sapply(xy.dec$det1,Re), xy.dec$lre, 
xy.dec$lreA, positive = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='smooth.over.time'>
Function to perform smoothing over time of spectral quantities
</h2><span id='topic+smooth.over.time'></span>

<h3>Description</h3>

<p>This function uses a running mean (box kernel) smoother to smooth spectra over time, with potentially different smoothing parameters used for each scale of the spectra
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth.over.time(x, spec, M, fact = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="smooth.over.time_+3A_x">x</code></td>
<td>
<p>A vector corrsponding to the sampling grid of a component of a series.</p>
</td></tr>
<tr><td><code id="smooth.over.time_+3A_spec">spec</code></td>
<td>
<p>A spectral object (matrix), with rows corrsponding to different scales.</p>
</td></tr>
<tr><td><code id="smooth.over.time_+3A_m">M</code></td>
<td>
<p>The smoothing parameter (binwidth) or vector of smoothing parameters (one for each scale) for the smoothing method.</p>
</td></tr>
<tr><td><code id="smooth.over.time_+3A_fact">fact</code></td>
<td>
<p>If <code>length(M)==1</code>, a factor indicating how the smoothing parameter (binwidth) in the time-domain kernel smoothing method should increase from one scale to the next.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes in a matrix and performs a kernel smoother on row <code>i</code> of the matrix, using a bandwidth of <code>M[i]</code> if <code>length(M)==nrow(spec)</code>, and <code>M * fact^{i-1}</code> if <code>length(M)==1</code>.  Thus if the scaling factor, <span class="env">fact</span>, is chosen to be greater than one, a wider kernel is used for the smoothing for later scales. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>smooth.spec</code></td>
<td>
<p>A matrix of same dimension  as <span class="env">spec</span>, containing smoothed spectral values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jean Hamilton
</p>


<h3>References</h3>

<p>Hamilton, J., Nunes, M. A., Knight, M. I. and Fryzlewicz, P. (2018) Complex-valued wavelet lifting and applications.
<em>Technometrics</em>, <b>60</b> (1), 48-60, DOI 10.1080/00401706.2017.1281846.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cnlt.spec">cnlt.spec</a></code>,
<code><a href="#topic+pre.per">pre.per</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-sort(runif(100))

y &lt;-sin(2*pi*(1/25)*x) + sin(2*pi*(1/50)*x)

## Not run: 
xy.dec&lt;-cnlt.univ(x,y,P=300)

# compute the real part of the spectrum (real details^2) and smooth over scale, then over time
ReS &lt;- smooth.over.scale(x, sapply(xy.dec$det1,Re), sapply(xy.dec$det1,Re), xy.dec$lre, 
xy.dec$lreA, positive = TRUE)

ReS.smooth &lt;- smooth.over.time(x,ReS$spec,5,1.05)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
