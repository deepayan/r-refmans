<!DOCTYPE html><html lang="en"><head><title>Help for package ggQC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ggQC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#capability.summary'><p>Calculate Summary of Quality Performance Parameters</p></a></li>
<li><a href='#cBar_LCL'><p>Lower Control Limit: Count Data (c-chart)</p></a></li>
<li><a href='#cBar_UCL'><p>Upper Control Limit: Count Data (c-chart)</p></a></li>
<li><a href='#Cp'><p>Calculate Cp</p></a></li>
<li><a href='#Cpk'><p>Calculate Cpk</p></a></li>
<li><a href='#DNS'><p>Calculate Distance to Nearest Specification Limit</p></a></li>
<li><a href='#LD'><p>Calculate Distance to Lower Specification Limit</p></a></li>
<li><a href='#mR'><p>Mean One-Point Moving Range</p></a></li>
<li><a href='#mR_points'><p>One Point Moving Range of Vector</p></a></li>
<li><a href='#mR_UCL'><p>Mean One-Point Moving Range Upper Control Limit (UCL)</p></a></li>
<li><a href='#npBar'><p>Mean Value: Binomial Data (np-chart)</p></a></li>
<li><a href='#npBar_LCL'><p>Lower Control Limit: Binomial Data (np-chart)</p></a></li>
<li><a href='#npBar_UCL'><p>Upper Control Limit: Binomial Data (np-chart)</p></a></li>
<li><a href='#pBar'><p>Mean Proportion: Binomial Data (p-chart)</p></a></li>
<li><a href='#pBar_LCL'><p>Lower Control Limit: Binomial Data (p-chart)</p></a></li>
<li><a href='#pBar_UCL'><p>Upper Control Limit: Binomial Data (p-chart)</p></a></li>
<li><a href='#Pp'><p>Calculate Pp</p></a></li>
<li><a href='#Ppk'><p>Calculate Cpk</p></a></li>
<li><a href='#process_tolerance'><p>Calculate QC Process Tolerance</p></a></li>
<li><a href='#QC_Capability'><p>Calculate Summary of Quality Performance Parameters</p></a></li>
<li><a href='#QC_Lines'><p>Calculate QC Limits</p></a></li>
<li><a href='#QC_Violations'><p>Calculate QC Violations</p></a></li>
<li><a href='#QCrange'><p>Range: Max Min Difference</p></a></li>
<li><a href='#rBar'><p>Mean Subgroup Range</p></a></li>
<li><a href='#rBar_LCL'><p>Mean Subgroup Range Lower Control Limit (LCL)</p></a></li>
<li><a href='#rBar_UCL'><p>Mean Subgroup Range Upper Control Limit (UCL)</p></a></li>
<li><a href='#rMedian'><p>Median of Subgroup Ranges</p></a></li>
<li><a href='#rMedian_LCL'><p>Median of Subgroup Ranges Lower Control Limit (LCL)</p></a></li>
<li><a href='#rMedian_UCL'><p>Median of Subgroup Ranges Upper Control Limit (UCL)</p></a></li>
<li><a href='#sBar'><p>Mean Subgroup Standard Deviation</p></a></li>
<li><a href='#sBar_LCL'><p>Mean Subgroup Standard Deviation Lower Control Limit (LCL)</p></a></li>
<li><a href='#sBar_UCL'><p>Mean Subgroup Standard Deviation Upper Control Limit (UCL)</p></a></li>
<li><a href='#stat_mR'><p>Generate mR chart in ggplot</p></a></li>
<li><a href='#stat_pareto'><p>Generate a Pareto Plot with ggplot</p></a></li>
<li><a href='#stat_QC'><p>Produce QC Charts with ggplot Framework.</p></a></li>
<li><a href='#stat_QC_cap_hlabels'><p>horizontal Label Capability Stat</p></a></li>
<li><a href='#stat_QC_cap_hlines'><p>horizontal Line Capability Stat</p></a></li>
<li><a href='#stat_QC_cap_summary'><p>horizontal Label Capability Stat</p></a></li>
<li><a href='#stat_QC_cap_vlabels'><p>Vertical Label Capability Stat</p></a></li>
<li><a href='#stat_QC_cap_vlines'><p>Vertical Line Capability Stat</p></a></li>
<li><a href='#stat_QC_CAPA'><p>Generic Function for drawing QC capability information on plots</p></a></li>
<li><a href='#stat_QC_Capability'><p>Auto QC Capability Stat Function</p></a></li>
<li><a href='#stat_QC_labels'><p>Write QC Line Labels to ggplot QC Charts.</p></a></li>
<li><a href='#stat_qc_violations'><p>Inspect QC Violations</p></a></li>
<li><a href='#uBar'><p>Mean Rate: Count Data (u-chart)</p></a></li>
<li><a href='#uBar_LCL'><p>Lower Control Limit: Count Data (u-chart)</p></a></li>
<li><a href='#uBar_UCL'><p>Upper Control Limit: Count Data (u-chart)</p></a></li>
<li><a href='#UD'><p>Calculate Distance to Upper Specification Limit</p></a></li>
<li><a href='#xBar_Bar'><p>Mean of Subgroup Means</p></a></li>
<li><a href='#xBar_one_LCL'><p>xBar_One Lower Control Limit (LCL)</p></a></li>
<li><a href='#xBar_one_UCL'><p>xBar_One Upper Control Limit (UCL)</p></a></li>
<li><a href='#xBar_rBar_LCL'><p>Mean of Subgroup Means Lower Control Limit (LCL)</p></a></li>
<li><a href='#xBar_rBar_UCL'><p>Mean of Subgroup Means Upper Control Limit (UCL)</p></a></li>
<li><a href='#xBar_rMedian_LCL'><p>Mean of Subgroup Means Lower Control Limit (LCL) based on Median Range</p></a></li>
<li><a href='#xBar_rMedian_UCL'><p>Mean of Subgroup Means Upper Control Limit (UCL) based on Median Range</p></a></li>
<li><a href='#xBar_sBar_LCL'><p>Mean of Subgroup Means Lower Control Limit (LCL) based on Standard Deviation</p></a></li>
<li><a href='#xBar_sBar_UCL'><p>Mean of Subgroup Means Upper Control Limit (UCL) based on Standard Deviation</p></a></li>
<li><a href='#xMedian_Bar'><p>Mean of Subgroup Medians</p></a></li>
<li><a href='#xMedian_rBar_LCL'><p>Mean of Subgroup Medians Lower Control Limit (LCL) based on Mean Range</p></a></li>
<li><a href='#xMedian_rBar_UCL'><p>Mean of Subgroup Medians Upper Control Limit (UCL) based on mean Range</p></a></li>
<li><a href='#xMedian_rMedian_LCL'><p>Mean of Subgroup Medians Lower Control Limit (LCL) based on Median Range</p></a></li>
<li><a href='#xMedian_rMedian_UCL'><p>Mean of Subgroup Medians Upper Control Limit (UCL) based on Median Range</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quality Control Charts for 'ggplot'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.31</td>
</tr>
<tr>
<td>Author:</td>
<td>Kenith Grey</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kenith Grey &lt;kenithgrey@r-bar.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Plot single and faceted type quality control charts
  for 'ggplot'.  </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, gridExtra, knitr, rmarkdown, reshape2, plyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, stats, dplyr, tidyr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-01 01:41:15 UTC; billy</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-01 05:20:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='capability.summary'>Calculate Summary of Quality Performance Parameters</h2><span id='topic+capability.summary'></span>

<h3>Description</h3>

<p>function to report listing of quality performance parameters
</p>

<ul>
<li> <p><b>Proc. Tolerance (sigma)</b>: Describes the number of your process sigma (from QC charting) that can fit in your customer's specification window (the larger the better).
</p>
</li>
<li> <p><b>DNS (sigma)</b>: Distance to Nearest Specification (DNS) limit. Measure of how centered your process is and how close you are to the nearest process limit in sigma units.
</p>
</li>
<li> <p><b>Cp</b>: Describes how many times your 6 sigma process window (from QC charting) can fit in your customer's specification window (the larger the better)
</p>
</li>
<li> <p><b>Cpk</b>: Describes how centered your process is relative to customer specifications. How many times can you fit a 3 sigma window (from QC charting) between your process center and the nearest customer specification limit.
</p>
</li>
<li> <p><b>Pp</b>: Describes how many times your 6 sigma process window (overall standard deviation) can fit in your customer's specification window (the larger the better)
</p>
</li>
<li> <p><b>Ppk</b>: Describes how centered your process is relative to customer specifications. How many times can you fit a 3 sigma window (overall standard deviation) between your process center and the nearest customer specification limit.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>capability.summary(LSL, USL, QC.Center, QC.Sigma, s.Sigma, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="capability.summary_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="capability.summary_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="capability.summary_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="capability.summary_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="capability.summary_+3A_s.sigma">s.Sigma</code></td>
<td>
<p>number, the sigma value determined from overall standard deviation (i.e., sd()).</p>
</td></tr>
<tr><td><code id="capability.summary_+3A_digits">digits</code></td>
<td>
<p>integer, how many digits to report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame , listing of metric labels and value
</p>

<hr>
<h2 id='cBar_LCL'>Lower Control Limit: Count Data (c-chart)</h2><span id='topic+cBar_LCL'></span>

<h3>Description</h3>

<p>Calculates lower control limit (LCL) for count data acquired
over the same-sized area of opportunity. Negative values are reported as 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cBar_LCL(y, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cBar_LCL_+3A_y">y</code></td>
<td>
<p>Vector of count data. Each observation having the
same-area of opportunity.</p>
</td></tr>
<tr><td><code id="cBar_LCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="cBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; 3-sigma lower control limit (LCL). Function returns 0 for negative values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
y &lt;- rpois(30, 9)
cBar_LCL(y)

</code></pre>

<hr>
<h2 id='cBar_UCL'>Upper Control Limit: Count Data (c-chart)</h2><span id='topic+cBar_UCL'></span>

<h3>Description</h3>

<p>Calculates upper control limit (UCL) for count data acquired
over the same-sized area of opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cBar_UCL(y, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cBar_UCL_+3A_y">y</code></td>
<td>
<p>Vector of count data. Each observation having the
same-area of opportunity.</p>
</td></tr>
<tr><td><code id="cBar_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="cBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; 3-sigma upper control limit (UCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
y &lt;- rpois(30, 9)
cBar_UCL(y)

</code></pre>

<hr>
<h2 id='Cp'>Calculate Cp</h2><span id='topic+Cp'></span>

<h3>Description</h3>

<p>function to calculate Cp - &quot;The elbowroom or margin your process&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cp(LSL, USL, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cp_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="Cp_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="Cp_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, Cp value (unitless)
</p>

<hr>
<h2 id='Cpk'>Calculate Cpk</h2><span id='topic+Cpk'></span>

<h3>Description</h3>

<p>function to calculate Cpk - &quot;measure of process centering&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cpk(LSL, USL, QC.Center, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cpk_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="Cpk_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="Cpk_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="Cpk_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, Cpk value (unitless)
</p>

<hr>
<h2 id='DNS'>Calculate Distance to Nearest Specification Limit</h2><span id='topic+DNS'></span>

<h3>Description</h3>

<p>function to calculate a standardized distance to the nearest specification limit (sigma units)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNS(LSL, USL, QC.Center, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DNS_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="DNS_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="DNS_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="DNS_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, standardized distance to the nearest specification limit (sigma units)
</p>

<hr>
<h2 id='LD'>Calculate Distance to Lower Specification Limit</h2><span id='topic+LD'></span>

<h3>Description</h3>

<p>function to calculate a standardized distance to the Lower specification limit (sigma units)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LD(LSL, USL, QC.Center, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LD_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="LD_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="LD_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="LD_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, standardized distance to the lower specification limit (sigma units)
</p>

<hr>
<h2 id='mR'>Mean One-Point Moving Range</h2><span id='topic+mR'></span>

<h3>Description</h3>

<p>Calculates the mean one-point moving range used when constructing a moving-range chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mR(y, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mR_+3A_y">y</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="mR_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="mR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean one-point moving range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
values &lt;- rnorm(n = 100, mean = 25, sd = 1)
mR(values)
</code></pre>

<hr>
<h2 id='mR_points'>One Point Moving Range of Vector</h2><span id='topic+mR_points'></span>

<h3>Description</h3>

<p>Calculates a one-point moving range vector given an input vector of values.
Output often used to produce mR-chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mR_points(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mR_points_+3A_y">y</code></td>
<td>
<p>: vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of one-point moving range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- seq(-5:5)
mR_points(y)
</code></pre>

<hr>
<h2 id='mR_UCL'>Mean One-Point Moving Range Upper Control Limit (UCL)</h2><span id='topic+mR_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean one-point moving range UCL used when constructing a moving-range chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mR_UCL(y, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mR_UCL_+3A_y">y</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="mR_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="mR_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean one-point moving range UCL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
values &lt;- rnorm(n = 100, mean = 25, sd = 1)
mR_UCL(values)
</code></pre>

<hr>
<h2 id='npBar'>Mean Value: Binomial Data (np-chart)</h2><span id='topic+npBar'></span>

<h3>Description</h3>

<p>Calculates the mean value for
binomial count data acquired over the same-sized area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npBar(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npBar_+3A_y">y</code></td>
<td>
<p>Vector of binomial count data (not proportions). Each observation
having the same-area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_+3A_n">n</code></td>
<td>
<p>A number representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="npBar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
npBar(y = p, n = 30)

</code></pre>

<hr>
<h2 id='npBar_LCL'>Lower Control Limit: Binomial Data (np-chart)</h2><span id='topic+npBar_LCL'></span>

<h3>Description</h3>

<p>Calculates lower control limit (LCL) for
binomial count data acquired over the same-sized area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npBar_LCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npBar_LCL_+3A_y">y</code></td>
<td>
<p>Vector of binomial count data (not proportions). Each observation
having the same-area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_LCL_+3A_n">n</code></td>
<td>
<p>A number representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_LCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="npBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; 3-sigma upper control limit (LCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
npBar_LCL(y = p, n = 30)

</code></pre>

<hr>
<h2 id='npBar_UCL'>Upper Control Limit: Binomial Data (np-chart)</h2><span id='topic+npBar_UCL'></span>

<h3>Description</h3>

<p>Calculates upper control limit (UCL) for
binomial count data acquired over the same-sized area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>npBar_UCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="npBar_UCL_+3A_y">y</code></td>
<td>
<p>Vector of binomial count data (not proportions). Each observation
having the same-area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_UCL_+3A_n">n</code></td>
<td>
<p>A number representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="npBar_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="npBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; 3-sigma upper control limit (UCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
npBar_UCL(y = p, n = 30)

</code></pre>

<hr>
<h2 id='pBar'>Mean Proportion: Binomial Data (p-chart)</h2><span id='topic+pBar'></span>

<h3>Description</h3>

<p>Calculates overall mean proportion
for binomial proportion data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pBar(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pBar_+3A_y">y</code></td>
<td>
<p>Vector of binomial proportion data (not counts). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="pBar_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="pBar_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="pBar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mean proportion, length equal to length of
parameter y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
n &lt;- rpois(100, 100)
pBar(y = p/n, n = n)

</code></pre>

<hr>
<h2 id='pBar_LCL'>Lower Control Limit: Binomial Data (p-chart)</h2><span id='topic+pBar_LCL'></span>

<h3>Description</h3>

<p>Calculates point-wise lower control limit (LCL)
for binomial proportion data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pBar_LCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pBar_LCL_+3A_y">y</code></td>
<td>
<p>Vector of binomial proportion data (not counts). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="pBar_LCL_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="pBar_LCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="pBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector; point-wise 3-sigma lower control limit (LCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
n &lt;- rpois(100, 100)
pBar_LCL(y = p/n, n = n)

</code></pre>

<hr>
<h2 id='pBar_UCL'>Upper Control Limit: Binomial Data (p-chart)</h2><span id='topic+pBar_UCL'></span>

<h3>Description</h3>

<p>Calculates point-wise upper control limit (UCL)
for binomial proportion data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pBar_UCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pBar_UCL_+3A_y">y</code></td>
<td>
<p>Vector of binomial proportion data (not counts). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="pBar_UCL_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="pBar_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="pBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector; point-wise 3-sigma upper control limit (UCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
p &lt;- rbinom(n = 100, size = 30, prob = .2)
n &lt;- rpois(100, 100)
pBar_UCL(y = p/n, n = n)

</code></pre>

<hr>
<h2 id='Pp'>Calculate Pp</h2><span id='topic+Pp'></span>

<h3>Description</h3>

<p>function to calculate Pp - &quot;The elbowroom or margin your process&quot; uses overall sigma value not the QC chart sigma values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pp(LSL, USL, s.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Pp_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="Pp_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="Pp_+3A_s.sigma">s.Sigma</code></td>
<td>
<p>number, the sigma value determined from overall standard deviation (i.e., sd()).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, Pp value (unitless)
</p>

<hr>
<h2 id='Ppk'>Calculate Cpk</h2><span id='topic+Ppk'></span>

<h3>Description</h3>

<p>function to calculate Cpk - &quot;measure of process centering&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ppk(LSL, USL, QC.Center, s.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ppk_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="Ppk_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="Ppk_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="Ppk_+3A_s.sigma">s.Sigma</code></td>
<td>
<p>number, the sigma value determined from overall standard deviation (i.e., sd()).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, Ppk value (unitless)
</p>

<hr>
<h2 id='process_tolerance'>Calculate QC Process Tolerance</h2><span id='topic+process_tolerance'></span>

<h3>Description</h3>

<p>function to calculate a standardized process tolerance with sigma unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_tolerance(LSL, USL, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_tolerance_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="process_tolerance_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="process_tolerance_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, standardized process tolerance value in sigma units
</p>

<hr>
<h2 id='QC_Capability'>Calculate Summary of Quality Performance Parameters</h2><span id='topic+QC_Capability'></span>

<h3>Description</h3>

<p>function to report listing of quality performance parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QC_Capability(data = NULL, value = NULL, grouping = NULL,
  formula = NULL, method = "xBar.rBar", na.rm = FALSE, LSL = NULL,
  USL = NULL, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QC_Capability_+3A_data">data</code></td>
<td>
<p>vector or dataframe, as indicated below for each chart type
</p>

<ul>
<li> <p><b>Individuals (XmR)</b>: vector of values;
</p>
</li>
<li> <p><b>Studentized</b>: dataframe
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Capability_+3A_value">value</code></td>
<td>
<p>string, <b>Studentized Charts</b>, name of numeric vector in dataframe with values of interest.</p>
</td></tr>
<tr><td><code id="QC_Capability_+3A_grouping">grouping</code></td>
<td>
<p>string, <b>Studentized Charts</b>, name of single factor/variable to split
the dataframe &quot;values&quot; by</p>
</td></tr>
<tr><td><code id="QC_Capability_+3A_formula">formula</code></td>
<td>
<p><b>Studentized Charts</b>: a formula,
such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="QC_Capability_+3A_method">method</code></td>
<td>
<p>string, calling one of the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Capability_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="QC_Capability_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="QC_Capability_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit
</p>

<ul>
<li> <p><b>Proc. Tolerance (sigma)</b>: Describes the number of your process sigma (from QC charting) that can fit in your customer's specification window (the larger the better).
</p>
</li>
<li> <p><b>DNS (sigma)</b>: Distance to Nearest Specification (DNS) limit. Measure of how centered your process is and how close you are to the nearest process limit in sigma units.
</p>
</li>
<li> <p><b>Cp</b>: Describes how many times your 6 sigma process window (from QC charting) can fit in your customer's specification window (the larger the better)
</p>
</li>
<li> <p><b>Cpk</b>: Describes how centered your process is relative to customer specifications. How many times can you fit a 3 sigma window (from QC charting) between your process center and the nearest customer specification limit.
</p>
</li>
<li> <p><b>Pp</b>: Describes how many times your 6 sigma process window (overall standard deviation) can fit in your customer's specification window (the larger the better)
</p>
</li>
<li> <p><b>Ppk</b>: Describes how centered your process is relative to customer specifications. How many times can you fit a 3 sigma window (overall standard deviation) between your process center and the nearest customer specification limit.
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Capability_+3A_digits">digits</code></td>
<td>
<p>integer, how many digits to report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame , listing of metric labels and value
</p>

<hr>
<h2 id='QC_Lines'>Calculate QC Limits</h2><span id='topic+QC_Lines'></span>

<h3>Description</h3>

<p>Calculates QC chart lines for the following chart types and reports in a dataframe:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: mR, XmR,
</p>
</li>
<li> <p><b>Attribute Charts</b>: c, np, p, u,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian,
</p>
</li>
<li> <p><b>Dispersion Charts</b>: rBar, rMedian, sBar.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>QC_Lines(data = NULL, value = NULL, grouping = NULL,
  formula = NULL, n = NULL, method = "xBar.rBar", na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QC_Lines_+3A_data">data</code></td>
<td>
<p>vector or dataframe, as indicated below for each chart type
</p>

<ul>
<li> <p><b>Individuals &amp; Attribute Charts</b>: vector of values;
</p>
</li>
<li> <p><b>Studentized &amp; Dispersion Charts</b>: dataframe
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Lines_+3A_value">value</code></td>
<td>
<p>string, <b>Studentized Charts</b> and <b>Dispersion Charts</b>, numeric vector in dataframe with values of interest</p>
</td></tr>
<tr><td><code id="QC_Lines_+3A_grouping">grouping</code></td>
<td>
<p>string, <b>Studentized Charts</b> and <b>Dispersion Charts</b>: single factor/variable to split
the dataframe &quot;values&quot; by</p>
</td></tr>
<tr><td><code id="QC_Lines_+3A_formula">formula</code></td>
<td>
<p><b>Studentized Charts</b> and <b>Dispersion Charts</b>: a formula,
such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="QC_Lines_+3A_n">n</code></td>
<td>
<p>number or vector as indicated below for each chart type.
</p>

<ul>
<li> <p><b>Individuals Charts</b>: No effect
</p>
</li>
<li> <p><b>Attribute Charts</b>: (p and u) vector, indicating sample area of opportunity.
</p>
</li>
<li> <p><b>Attribute Charts</b>: (np) number, indicating constant sampling area of opportunity.
</p>
</li>
<li> <p><b>Studentized Charts</b>: number, user specified subgroup size.
</p>
</li>
<li> <p><b>Dispersion Charts</b>: No effect
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Lines_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: mR, XmR,
</p>
</li>
<li> <p><b>Attribute Charts</b>: c, np, p, u,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li>
<li> <p><b>Dispersion Charts</b>: rBar, rMedian, sBar.
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Lines_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe,
</p>

<ul>
<li> <p><b>Attribute Data:</b> (p and u) Center Line, Upper Control Limit and Lower Control limit for each point.
</p>
</li>
<li> <p><b>Other Data</b>: single line dataframe, with relevant control limits noted in column headings.
</p>
</li></ul>



<h3>Note</h3>

<p>If using the <b>formula</b> argument do not use <b>value</b> and <b>group</b> arguments.
</p>


<h3>References</h3>

<p>Wheeler, DJ, and DS Chambers. Understanding Statistical Process Control, 2nd Ed. Knoxville, TN: SPC, 1992. Print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################
#  Example 1: Charts other than "p" or "u"  #
#############################################

# Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(plyr)
 require(ggplot2)

# Setup Data --------------------------------------------------------------
 set.seed(5555)
 Process1 &lt;- data.frame(processID = as.factor(rep(1,100)),
                        metric_value = rnorm(100,0,1),
                        subgroup_sample=rep(1:20, each=5),
                        Process_run_id = 1:100)
 set.seed(5555)
 Process2 &lt;- data.frame(processID = as.factor(rep(2,100)),
                        metric_value = rnorm(100,5, 1),
                        subgroup_sample=rep(1:10, each=10),
                        Process_run_id = 101:200)

 Both_Processes &lt;- rbind(Process1, Process2)

# QC Values For Individuals -----------------------------------------------
 # All Together
   QC_Lines(data = Both_Processes$metric_value, method = "XmR")


 # For Each Process
   ddply(Both_Processes, .variables = "processID",
     .fun =function(df){
       QC_Lines(data = df$metric_value, method = "XmR")
     }
   )

# QC Values For Studentized Runs-------------------------------------------
 # All Together
   QC_Lines(data = Both_Processes,
        formula = metric_value ~ subgroup_sample)


 # For Each Process
   ddply(Both_Processes, .variables = "processID",
     .fun =function(df){
       QC_Lines(data = df, formula = metric_value ~ subgroup_sample)
     }
   )


########################
#  Example 2 "p" data  #
########################

# Setup p Data ------------------------------------------------------------
 set.seed(5555)
 bin_data &lt;- data.frame(
   trial = 1:30,
   Num_Incomplete_Items = rpois(n = 30, lambda = 30),
   Num_Items_in_Set = runif(n = 30, min = 50, max = 100))

 bin_data$Proportion_Incomplete &lt;- bin_data$Num_Incomplete_Items/bin_data$Num_Items_in_Set

# QC_Lines for "p" data ---------------------------------------------------
 QC_Lines(data = bin_data$Proportion_Incomplete,
        n = bin_data$Num_Items_in_Set, method="p")


########################
#  Example 3 "u" data  #
########################

# Setup u Data ------------------------------------------------------------
 set.seed(5555)
 bin_data &lt;- data.frame(
   trial=1:30,
   Num_of_Blemishes = rpois(n = 30, lambda = 30),
   Num_Items_Inspected = runif(n = 30, min = 50, max = 100))

 bin_data$Blemish_Rate &lt;- bin_data$Num_of_Blemishes/bin_data$Num_Items_Inspected


# QC Lines for "u" data ---------------------------------------------------
 QC_Lines(data = bin_data$Blemish_Rate,
        n = bin_data$Num_Items_Inspected, method="u")
</code></pre>

<hr>
<h2 id='QC_Violations'>Calculate QC Violations</h2><span id='topic+QC_Violations'></span>

<h3>Description</h3>

<p>function that calculates QC violations on sequentially ordered data
based on the following 4 rules:
</p>

<ul>
<li> <p><b>Violation Same Side:</b> 8 or more consecutive, same-side points
</p>
</li>
<li> <p><b>Violation 1 Sigma:</b> 4 or more consecutive, same-side points exceeding 1 sigma
</p>
</li>
<li> <p><b>Violation 2 Sigma:</b> 2 or more consecutive, same-side points exceeding 2 sigma
</p>
</li>
<li> <p><b>Violation 3 Sigma:</b> any points exceeding 3 sigma
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>QC_Violations(data, value = NULL, grouping = NULL, formula = NULL,
  method = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QC_Violations_+3A_data">data</code></td>
<td>
<p>vector or dataframe, as indicated below for each chart type
</p>

<ul>
<li> <p><b>Individuals</b>: vector of values;
</p>
</li>
<li> <p><b>Studentized Charts</b>: dataframe
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Violations_+3A_value">value</code></td>
<td>
<p><b>Studentized Charts</b>: numeric vector in dataframe with values of interest</p>
</td></tr>
<tr><td><code id="QC_Violations_+3A_grouping">grouping</code></td>
<td>
<p><b>Studentized Charts</b>: single factor/variable to split
the dataframe &quot;values&quot; by</p>
</td></tr>
<tr><td><code id="QC_Violations_+3A_formula">formula</code></td>
<td>
<p><b>Studentized Charts</b>: a formula,
such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="QC_Violations_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="QC_Violations_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe, with the following columns
</p>

<ul>
<li> <p><b>data</b>: The input data if XmR, mean or median by group for Studentized methods
</p>
</li>
<li> <p><b>z_score</b>: z-score for the data point
</p>
</li>
<li> <p><b>Index</b>: number, indicating the order of the input data
</p>
</li>
<li> <p><b>Violation_Result</b>: description of the type of test being run.
</p>

<ul>
<li> <p><b>Violation Same Side:</b> 8 or more consecutive, same-side points
</p>
</li>
<li> <p><b>Violation 1 Sigma:</b> 4 or more consecutive, same-side points exceeding 1 sigma
</p>
</li>
<li> <p><b>Violation 2 Sigma:</b> 2 or more consecutive, same-side points exceeding 2 sigma
</p>
</li>
<li> <p><b>Violation 3 Sigma:</b> any points exceeding 3 sigma
</p>
</li></ul>

</li>
<li> <p><b>Index</b>: boolean, does the data point violate the rule?
</p>
</li></ul>



<h3>Note</h3>

<p>If using the <b>formula</b> argument do not use <b>value</b> and <b>group</b> arguments.
</p>


<h3>References</h3>

<p>Wheeler, DJ, and DS Chambers. Understanding Statistical Process Control, 2nd Ed. Knoxville, TN: SPC, 1992. Print.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################
#  Example 1: XmR Check Violations  #
#####################################
# Load Libraries ----------------------------------------------------------
 require(ggQC)

# Setup Data --------------------------------------------------------------

    set.seed(5555)
    QC_XmR &lt;- data.frame(
    data = c(c(-1, 2.3, 2.4, 2.5),                        #Outlier Data
          sample(c(rnorm(60),5,-5), 62, replace = FALSE), #Normal Data
          c(1,-.3, -2.4,-2.6,-2.5,-2.7, .3)),             #Outlier Data
    Run_Order = 1:73                                      #Run Order
    )

   QC_Vs &lt;- QC_Violations(data  = QC_XmR$data, method = "XmR")

#######################################
#  Example 2: Xbar Check Violations   #
#######################################

# Setup Some Data ------------------------------------------------------------
     QC_xBar.rBar &lt;- do.call(rbind, lapply(1:3, function(X){
       set.seed(5555+X)                                   #Loop over 3 seeds
       data.frame(
         sub_group = rep(1:42),                           #Define Subgroups
         sub_class = letters[X],
         c(
          c(runif(n = 5, min = 2.0,3.2)),                 #Outlier Data
          sample(c(rnorm(30),5,-4), 32, replace = FALSE), #Normal Data
          c(runif(n = 5, min = -3.2, max = -2.0))         #Outlier Data
         )
      )
     }
   )
)

colnames(QC_xBar.rBar) &lt;- c("sub_group","sub_class", "value")
QC_Vs &lt;- QC_Violations(data  = QC_xBar.rBar,
                       formula = value~sub_group,
                       method = "xBar.rBar")
</code></pre>

<hr>
<h2 id='QCrange'>Range: Max Min Difference</h2><span id='topic+QCrange'></span>

<h3>Description</h3>

<p>Given a set of numbers, function calculates the difference between the maximum and minimum value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QCrange(y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QCrange_+3A_y">y</code></td>
<td>
<p>: vector of values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y &lt;- seq(-5:5)
QCrange(y)
</code></pre>

<hr>
<h2 id='rBar'>Mean Subgroup Range</h2><span id='topic+rBar'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup range used when constructing a XbarR chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBar(data, value, grouping, formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rBar_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rBar_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rBar_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rBar_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rBar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rBar(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='rBar_LCL'>Mean Subgroup Range Lower Control Limit (LCL)</h2><span id='topic+rBar_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup range Lower control limit
(UCL) used when constructing a XbarR chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBar_LCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rBar_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rBar_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rBar_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rBar_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup range lower control limit (LCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rBar_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='rBar_UCL'>Mean Subgroup Range Upper Control Limit (UCL)</h2><span id='topic+rBar_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup range upper control limit
(UCL) used when constructing a XbarR chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rBar_UCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rBar_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rBar_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rBar_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rBar_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup range upper control limit (UCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rBar_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='rMedian'>Median of Subgroup Ranges</h2><span id='topic+rMedian'></span>

<h3>Description</h3>

<p>Calculates the median of subgroup ranges, used when constructing xBar_rMedian charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMedian(data, value, grouping, formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rMedian_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rMedian_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rMedian_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rMedian_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rMedian_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; median subgroup range.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rMedian(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='rMedian_LCL'>Median of Subgroup Ranges Lower Control Limit (LCL)</h2><span id='topic+rMedian_LCL'></span>

<h3>Description</h3>

<p>Calculates the median of subgroup range Lower control limit
(LCL) used when constructing a xBar_rMedian chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMedian_LCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rMedian_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rMedian_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rMedian_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rMedian_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rMedian_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; median of subgroup range lower control limit (LCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rMedian_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='rMedian_UCL'>Median of Subgroup Ranges Upper Control Limit (UCL)</h2><span id='topic+rMedian_UCL'></span>

<h3>Description</h3>

<p>Calculates the median of subgroup range upper control limit
(UCL) used when constructing a xBar_rMedian chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rMedian_UCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rMedian_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="rMedian_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="rMedian_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="rMedian_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="rMedian_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; median of subgroup range upper control limit (UCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
rMedian_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='sBar'>Mean Subgroup Standard Deviation</h2><span id='topic+sBar'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup standard deviation used when constructing a XbarS chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sBar(data, value, grouping, formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sBar_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="sBar_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="sBar_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="sBar_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="sBar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup standard deviation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
sBar(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='sBar_LCL'>Mean Subgroup Standard Deviation Lower Control Limit (LCL)</h2><span id='topic+sBar_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup standard deviation Lower control limit
(UCL) used when constructing a XbarS chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sBar_LCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sBar_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="sBar_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="sBar_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="sBar_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="sBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup standard deviation lower control limit (LCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
sBar_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='sBar_UCL'>Mean Subgroup Standard Deviation Upper Control Limit (UCL)</h2><span id='topic+sBar_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup standard deviation upper control limit
(UCL) used when constructing a XbarS chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sBar_UCL(data = data, value = value, grouping = grouping,
  formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sBar_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="sBar_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="sBar_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="sBar_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="sBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean subgroup standard deviation upper control limit (UCL).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
sBar_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='stat_mR'>Generate mR chart in ggplot</h2><span id='topic+stat_mR'></span>

<h3>Description</h3>

<p>ggplot stat used to create a mR chart in ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_mR(mapping = NULL, data = NULL, geom = "point",
  position = "identity", show.legend = NA, inherit.aes = TRUE,
  na.rm = FALSE, color.mr_point = "black", color.mr_line = "black",
  color.qc_limits = "red", color.qc_center = "blue", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_mR_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_color.mr_point">color.mr_point</code></td>
<td>
<p>color, to be used for the mR points.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_color.mr_line">color.mr_line</code></td>
<td>
<p>color, to be used for line connecting points.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_color.qc_limits">color.qc_limits</code></td>
<td>
<p>color, used to colorize the plot's upper and lower mR control limits.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_color.qc_center">color.qc_center</code></td>
<td>
<p>color, used to colorize the plot's center line.</p>
</td></tr>
<tr><td><code id="stat_mR_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data need to produce the mR plot in ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
#  Example 1: mR Chart  #
#########################

# Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(ggplot2)

# Setup Data --------------------------------------------------------------
 set.seed(5555)
 Process1 &lt;- data.frame(processID = as.factor(rep(1,100)),
                        metric_value = rnorm(100,0,1),
                        subgroup_sample=rep(1:20, each=5),
                        Process_run_id = 1:100)
 set.seed(5556)
 Process2 &lt;- data.frame(processID = as.factor(rep(2,100)),
                        metric_value = rnorm(100,5, 1),
                        subgroup_sample=rep(1:10, each=10),
                        Process_run_id = 101:200)

 Both_Processes &lt;- rbind(Process1, Process2)

# One Plot Both Processes -------------------------------------------------
 ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
   stat_mR() + ylab("Moving Range")

# Facet Plot - Both Processes ---------------------------------------------
 ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
   stat_mR() + ylab("Moving Range") +
   facet_grid(.~processID, scales = "free_x")
</code></pre>

<hr>
<h2 id='stat_pareto'>Generate a Pareto Plot with ggplot</h2><span id='topic+stat_pareto'></span>

<h3>Description</h3>

<p>stat function to create ggplot Pareto chart
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_pareto(mapping = NULL, data = NULL, geom = "point",
  position = "identity", show.legend = NA, inherit.aes = TRUE,
  group = 1, na.rm = FALSE, point.color = "black", point.size = 2,
  line.color = "black", line.size = 0.5, bars.fill = c("red",
  "white"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_pareto_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_group">group</code></td>
<td>
<p>defines grouping for variable for pareto plot, default and suggested is 1.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_point.color">point.color</code></td>
<td>
<p>color, used to define point color of cumulative percentage line</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_point.size">point.size</code></td>
<td>
<p>number, used to define point size of cumulative percentage line</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_line.color">line.color</code></td>
<td>
<p>color, used to define line color of cumulative percentage line</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_line.size">line.size</code></td>
<td>
<p>color, used to define line weight of cumulative percentage line</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_bars.fill">bars.fill</code></td>
<td>
<p>character vector length 2, start and end colors for pareto bars.</p>
</td></tr>
<tr><td><code id="stat_pareto_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pareto plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>############################
#  Example 1: Pareto Plot  #
############################

# Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(ggplot2)

# Setup Data --------------------------------------------------------------
 df &lt;- data.frame(
                  x = letters[1:10],
                  y = as.integer(runif(n = 10, min = 0, max=100))
                 )

# Render Pareto Plot ------------------------------------------------------


ggplot(df, aes(x=x, y=y)) +
 stat_pareto(point.color = "red",
             point.size = 3,
             line.color = "black",
             #size.line = 1,
             bars.fill = c("blue", "orange"),
 )
</code></pre>

<hr>
<h2 id='stat_QC'>Produce QC Charts with ggplot Framework.</h2><span id='topic+stat_QC'></span>

<h3>Description</h3>

<p>Produce QC charts with ggplot framework. Support for faceting and
layering of multiple QC chart lines on a single plot. Charts supported (see method argument for call):
</p>

<ul>
<li> <p><b>Individuals Charts</b>: mR, XmR,
</p>
</li>
<li> <p><b>Attribute Charts</b>: c, np, p, u,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian,
</p>
</li>
<li> <p><b>Dispersion Charts</b>: rBar, rMedian, sBar.
</p>
</li></ul>

<p>To label chart lines see <a href="#topic+stat_QC_labels">stat_QC_labels</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC(mapping = NULL, data = NULL, geom = "hline",
  position = "identity", na.rm = FALSE, show.legend = NA,
  inherit.aes = TRUE, n = NULL, method = "xBar.rBar",
  color.qc_limits = "red", color.qc_center = "blue",
  color.point = "black", color.line = "black",
  physical.limits = c(NA, NA), auto.label = FALSE,
  limit.txt.label = c("LCL", "UCL"), label.digits = 1,
  show.1n2.sigma = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_n">n</code></td>
<td>
<p>number, for
</p>

<ul>
<li> <p><b>Studentized Charts</b>, used for custom or hypothetical subgroup size.
</p>
</li>
<li> <p><b>np Charts</b>, used to specify a fixed area of opportunity.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: mR, XmR,
</p>
</li>
<li> <p><b>Attribute Charts</b>: c, np, p, u,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li>
<li> <p><b>Dispersion Charts</b>: rBar, rMedian, sBar.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_+3A_color.qc_limits">color.qc_limits</code></td>
<td>
<p>color, used to colorize the plot's upper and lower control limits.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_color.qc_center">color.qc_center</code></td>
<td>
<p>color, used to colorize the plot's center line.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_color.point">color.point</code></td>
<td>
<p>color, used to colorize points in studentized plots. You will need geom_point() for C, P, U, NP, and XmR charts.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_color.line">color.line</code></td>
<td>
<p>color, used to colorize lines connecting points in studentized plots. You will need geom_line() for C, P, U, NP, and XmR charts.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_physical.limits">physical.limits</code></td>
<td>
<p>vector, specify lower physical boundary and upper physical boundary</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_auto.label">auto.label</code></td>
<td>
<p>boolean setting, if T labels graph with control limits.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_limit.txt.label">limit.txt.label</code></td>
<td>
<p>vector, provides option for naming or not showing the limit text labels (e.g., UCL, LCL)
</p>

<ul>
<li> <p><b>limit.txt.label = c(&quot;LCL&quot;, &quot;UCL&quot;)</b>: default
</p>
</li>
<li> <p><b>limit.txt.label = c(&quot;Low&quot;, &quot;High&quot;)</b>: changes the label text to low and high
</p>
</li>
<li> <p><b>limit.txt.label = NA</b>: does not show label text.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_+3A_label.digits">label.digits</code></td>
<td>
<p>integer, number of decimal places to display.</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_show.1n2.sigma">show.1n2.sigma</code></td>
<td>
<p>boolean setting, if T labels graph 1 and 2 sigma lines. Line color is set by color.qc_limits</p>
</td></tr>
<tr><td><code id="stat_QC_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(ggplot2)

# Setup Data --------------------------------------------------------------
 set.seed(5555)
 Process1 &lt;- data.frame(processID = as.factor(rep(1,100)),
                        metric_value = rnorm(100,0,1),
                        subgroup_sample = rep(1:20, each=5),
                        Process_run_id = 1:100)
 set.seed(5556)
 Process2 &lt;- data.frame(processID = as.factor(rep(2,100)),
                        metric_value = rnorm(100,5, 1),
                        subgroup_sample = rep(1:10, each=10),
                        Process_run_id = 101:200)

 Both_Processes &lt;- rbind(Process1, Process2)

#############################
#  Example 1:  XmR Chart    #
#############################


EX1.1 &lt;- ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
 geom_point() + geom_line() + stat_QC(method="XmR") +
 stat_QC_labels(method="XmR", digits = 2) +
 facet_grid(.~processID, scales = "free_x")
#EX1.1

EX1.2 &lt;- ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
 stat_mR() + ylab("Moving Range") +
 stat_QC_labels(method="mR", digits = 2) +
 facet_grid(.~processID, scales = "free_x")
#EX1.2

#############################
#  Example 2:  XbarR Chart  #
#############################

EX2.1 &lt;- ggplot(Both_Processes, aes(x = subgroup_sample,
                          y = metric_value,
                          group = processID)) +
 stat_summary(fun.y = "mean", color = "blue", geom = c("point")) +
 stat_summary(fun.y = "mean", color = "blue", geom = c("line")) +
 stat_QC(method = "xBar.rBar") + facet_grid(.~processID, scales = "free_x")
#EX2.1

EX2.2 &lt;- ggplot(Both_Processes, aes(x = subgroup_sample,
                          y = metric_value,
                          group = processID)) +
 stat_summary(fun.y = "QCrange", color = "blue", geom = "point") +
 stat_summary(fun.y = "QCrange", color = "blue", geom = "line") +
 stat_QC(method = "rBar") +
 ylab("Range") +
 facet_grid(.~processID, scales = "free_x")
 #EX2.2

#############################
#  Example 3:  p Chart      #
#############################
# p chart Setup -----------------------------------------------------------
 set.seed(5556)
 bin_data &lt;- data.frame(
   trial=1:30,
   Num_Incomplete_Items = rpois(30, lambda = 30),
   Num_Items_in_Set = runif(n = 30, min = 50, max = 100))
   bin_data$Proportion_Incomplete &lt;- bin_data$Num_Incomplete_Items/bin_data$Num_Items_in_Set

# Plot p chart ------------------------------------------------------------
EX3.1 &lt;- ggplot(data = bin_data, aes(x=trial,
                           y=Proportion_Incomplete,
                           n=Num_Items_in_Set)) +
 geom_point() + geom_line() +
 stat_QC(method = "p")
 #EX3.1

#############################
#  Example 4:  u Chart      #
#############################
# u chart Setup -----------------------------------------------------------
 set.seed(5555)
 bin_data &lt;- data.frame(
   trial=1:30,
   Num_of_Blemishes = rpois(30, lambda = 30),
   Num_Items_Inspected = runif(n = 30, min = 50, max = 100)
   )
   bin_data$Blemish_Rate &lt;- bin_data$Num_of_Blemishes/bin_data$Num_Items_Inspected

# Plot u chart ------------------------------------------------------------
EX4.1 &lt;- ggplot(data = bin_data, aes(x=trial,
                           y=Blemish_Rate,
                           n=Num_Items_Inspected)) +
 geom_point() + geom_line() +
 stat_QC(method = "u")
#EX4.1

#############################
#  Example 5:  np Chart     #
#############################
# np chart Setup -----------------------------------------------------------
 set.seed(5555)
 bin_data &lt;- data.frame(
   trial=1:30,
   NumNonConforming = rbinom(30, 30, prob = .50))
 Units_Tested_Per_Batch &lt;- 60

# Plot np chart ------------------------------------------------------------
 EX5.1 &lt;- ggplot(data = bin_data, aes(trial, NumNonConforming)) +
  geom_point() +
  stat_QC(method = "np", n = Units_Tested_Per_Batch)
#EX5.1

#############################
#  Example 6:  c Chart     #
#############################
# c chart Setup -----------------------------------------------------------
 set.seed(5555)
 Process1 &lt;- data.frame(Process_run_id = 1:30,
                        Counts=rpois(n = 30, lambda = 25),
                        Group = "A")
 Process2 &lt;- data.frame(Process_run_id = 1:30,
                        Counts = rpois(n = 30, lambda = 5),
                        Group = "B")

 all_processes &lt;- rbind(Process1, Process2)
# Plot C Chart ------------------------------------------------------------

 EX6.1 &lt;- ggplot(all_processes, aes(x=Process_run_id, y = Counts)) +
   geom_point() + geom_line() +
   stat_QC(method = "c", auto.label = TRUE, label.digits = 2) +
   scale_x_continuous(expand =  expand_scale(mult = .25)) +
   facet_grid(.~Group)
# EX6.1
</code></pre>

<hr>
<h2 id='stat_QC_cap_hlabels'>horizontal Label Capability Stat</h2><span id='topic+stat_QC_cap_hlabels'></span>

<h3>Description</h3>

<p>Draws horizontal Lables on horizontal Capability lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_cap_hlabels(LSL, USL, method = "xBar.rBar", show = c("LSL",
  "USL"), mapping = NULL, data = NULL, inherit.aes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_cap_hlabels_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_show">show</code></td>
<td>
<p>vector, indicating which lines to draw ie., c(&quot;LCL&quot;, &quot;LSL&quot;, &quot;X&quot;, &quot;USL&quot;, &quot;UCL&quot;)
</p>

<ul>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>LSL</b>: Lower Specification Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>USL</b>: Upper Specification Limit
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlabels_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>horizontal lines for histogram and density plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_cap_hlines'>horizontal Line Capability Stat</h2><span id='topic+stat_QC_cap_hlines'></span>

<h3>Description</h3>

<p>Draws horizontal Capability Lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_cap_hlines(LSL, USL, method = "xBar.rBar", show = c("LSL",
  "USL"), mapping = NULL, data = NULL, inherit.aes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_cap_hlines_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_show">show</code></td>
<td>
<p>vector, indicating which lines to draw ie., c(&quot;LCL&quot;, &quot;LSL&quot;, &quot;X&quot;, &quot;USL&quot;, &quot;UCL&quot;)
</p>

<ul>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>LSL</b>: Lower Specification Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>USL</b>: Upper Specification Limit
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_hlines_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>horizontal lines for histogram and density plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_cap_summary'>horizontal Label Capability Stat</h2><span id='topic+stat_QC_cap_summary'></span>

<h3>Description</h3>

<p>Draws horizontal Lables on horizontal Capability lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_cap_summary(LSL, USL, method = "xBar.rBar", px = Inf,
  py = -Inf, show = c("Cp", "Cpk", "Pp", "Ppk"), digits = 8,
  mapping = NULL, data = NULL, inherit.aes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_cap_summary_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_px">px</code></td>
<td>
<p>numeric, x position for table. Use Inf to force label to x-limit.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_py">py</code></td>
<td>
<p>numeric, y position for table. Use Inf to force label to y-limits. May also need vjust parameter.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_show">show</code></td>
<td>
<p>vector, indicating which lines to draw ie.,
c(&quot;TOL&quot;,&quot;DNS&quot;, &quot;Cp&quot;, &quot;Cpk&quot;, &quot;Pp&quot;, &quot;Ppk&quot;, &quot;LCL&quot;, &quot;X&quot;, &quot;UCL&quot;, &quot;Sig&quot;).
The order given in the vector is the order presented in the graph.
</p>

<ul>
<li> <p><b>TOL</b>: Tolerance in Sigma Units  (USL-LSL)/sigma
</p>
</li>
<li> <p><b>DNS</b>: Distance to Nearest Specification Limit in Simga Units
</p>
</li>
<li> <p><b>Cp</b>: Cp (Within)
</p>
</li>
<li> <p><b>Cpk</b>: Cpk (Within)
</p>
</li>
<li> <p><b>Pp</b>: Pp (Between)
</p>
</li>
<li> <p><b>Ppk</b>: Ppk (Between)
</p>
</li>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li>
<li> <p><b>Sig</b>: Sigma from control charts
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_digits">digits</code></td>
<td>
<p>integer, how many digits to report.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_summary_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>horizontal lines for histogram and density plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_cap_vlabels'>Vertical Label Capability Stat</h2><span id='topic+stat_QC_cap_vlabels'></span>

<h3>Description</h3>

<p>Draws Vertical Lables on Vertical Capability lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_cap_vlabels(LSL, USL, method = "xBar.rBar", show = c("LSL",
  "USL"), mapping = NULL, data = NULL, inherit.aes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_cap_vlabels_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_show">show</code></td>
<td>
<p>vector, indicating which lines to draw ie., c(&quot;LCL&quot;, &quot;LSL&quot;, &quot;X&quot;, &quot;USL&quot;, &quot;UCL&quot;)
</p>

<ul>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>LSL</b>: Lower Specification Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>USL</b>: Upper Specification Limit
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlabels_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vertical lines for histogram and density plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_cap_vlines'>Vertical Line Capability Stat</h2><span id='topic+stat_QC_cap_vlines'></span>

<h3>Description</h3>

<p>Draws Vertical Capability Stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_cap_vlines(LSL, USL, method = "xBar.rBar", show = c("LSL",
  "USL"), mapping = NULL, data = NULL, inherit.aes = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_cap_vlines_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_show">show</code></td>
<td>
<p>vector, indicating which lines to draw ie., c(&quot;LCL&quot;, &quot;LSL&quot;, &quot;X&quot;, &quot;USL&quot;, &quot;UCL&quot;)
</p>

<ul>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>LSL</b>: Lower Specification Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>USL</b>: Upper Specification Limit
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_cap_vlines_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vertical lines for histogram and density plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_CAPA'>Generic Function for drawing QC capability information on plots</h2><span id='topic+stat_QC_CAPA'></span>

<h3>Description</h3>

<p>Generic Function for drawing QC capability information on plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_CAPA(LSL, USL, method = "xBar.rBar", digits = 1,
  mapping = NULL, data = NULL, geom = "vline",
  position = "identity", na.rm = FALSE, show.legend = NA,
  inherit.aes = TRUE, show = c("LSL", "USL"), direction = "v",
  type = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_CAPA_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_digits">digits</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_na.rm">na.rm</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_show">show</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_direction">direction</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_type">type</code></td>
<td>
<p>-</p>
</td></tr>
<tr><td><code id="stat_QC_CAPA_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot control charts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)


# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                       Value = rnorm(100,10,1),
                       Subgroup = rep(1:20, each=5),
                       Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                       Value = rnorm(100,20, 1),
                       Subgroup = rep(1:10, each=10),
                       Process_run_id = 101:200)

df &lt;- rbind(Process1, Process2)

######################
## Example 1 XmR    ##
######################
##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

method &lt;- "XmR"

# Normal Histogram XmR --------------------------------------------------------

EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1, color="purple") +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +
  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
  ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------

EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_histogram(binwidth = 1) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),#show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  facet_grid(.~ProcessID) + ylim(0,45)
#EX1.2

# Facet Density Plot XmR -------------------------------------------------

EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="purple", trim=TRUE) +
  geom_hline(yintercept=0, color="grey") +
  stat_QC_cap_vlines(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, show=c("X", "LSL", "USL"), method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=2, size=4) +

  scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

# Facet Density Plot XmR --------------------------------------------------

EX1.4 &lt;- ggplot(df[order(df$Process_run_id),],
                aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
  geom_density(bw = .4, fill="grey", trim=TRUE ) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
  # geom_hline(yintercept=0, color="black") +
  facet_grid(.~ProcessID) + ylim(0,.5)
#EX1.4


########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################

method &lt;- "xBar.rBar" #Alternativly Use "xBar.sBar" if desired


# Single Histogram xBar.rBar ----------------------------------------------

EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1


# Faceted Histogram xBar.rBar ---------------------------------------------

EX2.2 &lt;- ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.2

# Single Density xBar.rBar ----------------------------------------------

EX2.3 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.3

# Faceted Density xBar.rBar ---------------------------------------------

EX2.4 &lt;-  ggplot(df, aes(x=Value, QC.Subgroup=Subgroup)) +
  geom_density(bw = .4, fill="grey", alpha=.4) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))+
  facet_grid(.~ProcessID, scales="free_x")
#EX2.4


###############################
##  Example 3: xBar.rMedian  ##
###############################

## Plots involving medians should give warning: "median based QC methods represent
## at best *potential* process capability"

##These plot work the same as in examples 2.X; below is an example.

method &lt;- "xBar.rMedian"
EX3.1 &lt;- ggplot(df[order(df$Process_run_id),], aes(x=Value, QC.Subgroup=Run)) +
  geom_histogram(binwidth = 1) +
  stat_QC_cap_vlines(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_vlabels(LSL = 5, USL = 15, method=method) +
  stat_QC_cap_summary(LSL = 5, USL = 15, method=method, #py=.3,
                      #show="ALL",
                      #show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk",
                      #       "LCL", "X", "UCL", "Sig"),
                      #show=c("Sig","TOL", "DNS"),
                      show=c("TOL","DNS", "Cp", "Cpk", "Pp", "Ppk"),
                      color="black", digits=4, size=4) +
  scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8)))
#EX3.1
</code></pre>

<hr>
<h2 id='stat_QC_Capability'>Auto QC Capability Stat Function</h2><span id='topic+stat_QC_Capability'></span>

<h3>Description</h3>

<p>Draws lines, lables and summary statistics. Works best with histogram and density plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_Capability(LSL, USL, method = "xBar.rBar",
  show.lines = c("LSL", "USL"), line.direction = "v",
  show.line.labels = TRUE, line.label.size = 3,
  show.cap.summary = c("Cp", "Cpk", "Pp", "Ppk"), cap.summary.size = 4,
  px = Inf, py = -Inf, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_Capability_+3A_lsl">LSL</code></td>
<td>
<p>numeric, Customer's lower specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_usl">USL</code></td>
<td>
<p>numeric, Customer's Upper specification limit</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_show.lines">show.lines</code></td>
<td>
<p>vector, indicating which lines to draw ie., c(&quot;LCL&quot;, &quot;LSL&quot;, &quot;X&quot;, &quot;USL&quot;, &quot;UCL&quot;)
</p>

<ul>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>LSL</b>: Lower Specification Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>USL</b>: Upper Specification Limit
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_line.direction">line.direction</code></td>
<td>
<p>string &quot;v&quot; or &quot;h&quot;, specifies which direction to draw lines.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_show.line.labels">show.line.labels</code></td>
<td>
<p>boolean, if TRUE then draw.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_line.label.size">line.label.size</code></td>
<td>
<p>numeric, control the size of the line labels.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_show.cap.summary">show.cap.summary</code></td>
<td>
<p>vector, indicating which lines to draw ie.,
c(&quot;TOL&quot;,&quot;DNS&quot;, &quot;Cp&quot;, &quot;Cpk&quot;, &quot;Pp&quot;, &quot;Ppk&quot;, &quot;LCL&quot;, &quot;X&quot;, &quot;UCL&quot;, &quot;Sig&quot;).
The order given in the vector is the order presented in the graph.
</p>

<ul>
<li> <p><b>TOL</b>: Tolerance in Sigma Units  (USL-LSL)/sigma
</p>
</li>
<li> <p><b>DNS</b>: Distance to Nearest Specification Limit in Simga Units
</p>
</li>
<li> <p><b>Cp</b>: Cp (Within)
</p>
</li>
<li> <p><b>Cpk</b>: Cpk (Within)
</p>
</li>
<li> <p><b>Pp</b>: Pp (Between)
</p>
</li>
<li> <p><b>Ppk</b>: Ppk (Between)
</p>
</li>
<li> <p><b>LCL</b>: Lower Control Limit
</p>
</li>
<li> <p><b>X</b>: Process Center
</p>
</li>
<li> <p><b>UCL</b>: Upper Control Limit
</p>
</li>
<li> <p><b>Sig</b>: Sigma from control charts
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_cap.summary.size">cap.summary.size</code></td>
<td>
<p>numeric, control the size/scale of the summary text box.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_px">px</code></td>
<td>
<p>numeric, x position for summary text box. Use Inf to force label to x-limit.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_py">py</code></td>
<td>
<p>numeric, y position for summary text box. Use Inf to force label to y-limits. May also need vjust parameter.</p>
</td></tr>
<tr><td><code id="stat_QC_Capability_+3A_digits">digits</code></td>
<td>
<p>integer, how many digits to report.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>capability layer for histogram and density plots.
</p>


<h3>See Also</h3>

<p>for more control over lines, labels, and capability data see the following functions:
</p>

<ul>
<li> <p><code><a href="#topic+stat_QC_cap_vlabels">stat_QC_cap_vlabels</a></code>
</p>
</li>
<li> <p><code><a href="#topic+stat_QC_cap_hlabels">stat_QC_cap_hlabels</a></code>
</p>
</li>
<li> <p><code><a href="#topic+stat_QC_cap_vlines">stat_QC_cap_vlines</a></code>
</p>
</li>
<li> <p><code><a href="#topic+stat_QC_cap_hlines">stat_QC_cap_hlines</a></code>
</p>
</li>
<li> <p><code><a href="#topic+stat_QC_cap_summary">stat_QC_cap_summary</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load Libraries ----------------------------------------------------------
require(ggQC)
require(ggplot2)
# Setup Data --------------------------------------------------------------
set.seed(5555)
Process1 &lt;- data.frame(ProcessID = as.factor(rep(1,100)),
                      Value = rnorm(100,10,1),
                      Subgroup = rep(1:20, each=5),
                      Process_run_id = 1:100)
set.seed(5556)
Process2 &lt;- data.frame(ProcessID = as.factor(rep(2,100)),
                      Value = rnorm(100,20, 1),
                      Subgroup = rep(1:10, each=10),
                      Process_run_id = 101:200)
df &lt;- rbind(Process1, Process2)

######################
##  Example 1 XmR   ##
######################

##You may need to use the r-studio Zoom for these plots or make the size of the
##stat_QC_cap_summary smaller with size = some number"

# Normal Histogram XmR --------------------------------------------------------
EX1.1 &lt;-  ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
geom_histogram(binwidth = 1, color="purple") +
 geom_hline(yintercept=0, color="grey") +
 stat_QC_Capability(LSL=5, USL=15, show.cap.summary = "all", method="XmR") +
 scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8))) +
 ylim(0,45)
#Ex1.1

# Facet Histogram XmR -----------------------------------------------------
EX1.2 &lt;- ggplot(df[order(df$Process_run_id),],
aes(x=Value, QC.Subgroup=Subgroup, color=ProcessID)) +
geom_histogram(binwidth = 1) +
 geom_hline(yintercept=0, color="grey") +
 stat_QC_Capability(LSL=5, USL=15, show.cap.summary = "all", method="XmR") +
 scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) +
 facet_grid(.~ProcessID, scales = "free_x") + ylim(0,45)
#EX1.2

# Normal Density XmR --------------------------------------------------------
EX1.3 &lt;- ggplot(df[df$ProcessID == 1,], aes(x=Value, QC.Subgroup=Subgroup)) +
geom_density(bw = .4, fill="purple", trim=TRUE) +
 geom_hline(yintercept=0, color="grey") +
 stat_QC_Capability(LSL=5, USL=15, show.cap.summary = "all", method="XmR") +
 scale_x_continuous(expand =  expand_scale(mult = c(0.15,.8)))  + ylim(0,.5)
#EX1.3

########################################
##  Example 2: xBar.rBar or xBar.sBar ##
########################################
# Single Histogram xBar.rBar ----------------------------------------------
EX2.1 &lt;- ggplot(df[df$ProcessID==1,], aes(x=Value, QC.Subgroup=Subgroup)) +
 geom_histogram(binwidth = 1) +
 stat_QC_Capability(LSL=5, USL=15, method="xBar.rBar") +
 scale_x_continuous(expand =  ggplot2::expand_scale(mult = c(0.15,.8))) #+
#EX2.1
</code></pre>

<hr>
<h2 id='stat_QC_labels'>Write QC Line Labels to ggplot QC Charts.</h2><span id='topic+stat_QC_labels'></span>

<h3>Description</h3>

<p>Write QC line labels to ggplot QC Charts. Useful if you want
to see the value of the center line and QC limits. see method argument
for methods supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_QC_labels(mapping = NULL, data = NULL, geom = "label",
  position = "identity", na.rm = FALSE, show.legend = NA,
  inherit.aes = TRUE, n = NULL, digits = 1, method = "xBar.rBar",
  color.qc_limits = "red", color.qc_center = "black", text.size = 3,
  physical.limits = c(NA, NA), limit.txt.label = c("LCL", "UCL"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_QC_labels_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_n">n</code></td>
<td>
<p>number, for
</p>

<ul>
<li> <p><b>Studentized Charts</b>, used for custom or hypothetical subgroup size.
</p>
</li>
<li> <p><b>np Charts</b>, used to specify a fixed area of opportunity.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_digits">digits</code></td>
<td>
<p>integer, indicating the number of decimal places</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: mR, XmR,
</p>
</li>
<li> <p><b>Attribute Charts</b>: c, np, p, u,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li>
<li> <p><b>Dispersion Charts</b>: rBar, rMedian, sBar.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_color.qc_limits">color.qc_limits</code></td>
<td>
<p>color, used to colorize the plot's upper and lower mR control limits.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_color.qc_center">color.qc_center</code></td>
<td>
<p>color, used to colorize the plot's center line.</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_text.size">text.size</code></td>
<td>
<p>number, size of the text label</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_physical.limits">physical.limits</code></td>
<td>
<p>vector, specify lower physical boundary and upper physical boundary</p>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_limit.txt.label">limit.txt.label</code></td>
<td>
<p>vector, provides option for naming or not showing the limit text labels (e.g., UCL, LCL)
</p>

<ul>
<li> <p><b>limit.txt.label = c(&quot;LCL&quot;, &quot;UCL&quot;)</b>: default
</p>
</li>
<li> <p><b>limit.txt.label = c(&quot;Low&quot;, &quot;High&quot;)</b>: changes the label text to low and high
</p>
</li>
<li> <p><b>limit.txt.label = NA</b>: does not show label text.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_QC_labels_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data need to produce the mR plot in ggplot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################
#  Example 1: mR Chart  #
#########################

# Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(ggplot2)

# Setup Data --------------------------------------------------------------
 set.seed(5555)
 Process1 &lt;- data.frame(processID = as.factor(rep(1,100)),
                        metric_value = rnorm(100,0,1),
                        subgroup_sample=rep(1:20, each=5),
                        Process_run_id = 1:100)
 set.seed(5556)
 Process2 &lt;- data.frame(processID = as.factor(rep(2,100)),
                        metric_value = rnorm(100,5, 1),
                        subgroup_sample=rep(1:10, each=10),
                        Process_run_id = 101:200)

 Both_Processes &lt;- rbind(Process1, Process2)

# Facet Plot - Both Processes ---------------------------------------------
EX1.1 &lt;- ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
 geom_point() + geom_line() + stat_QC(method="XmR") +
 stat_QC_labels(method="XmR", digits = 2) +
 facet_grid(.~processID, scales = "free_x")
#EX1.1

EX1.2 &lt;- ggplot(Both_Processes, aes(x=Process_run_id, y = metric_value)) +
 stat_mR() + ylab("Moving Range") +
 stat_QC_labels(method="mR", digits = 2) +
 facet_grid(.~processID, scales = "free_x")
#EX1.2

#############################
#  Example 2:  XbarR Chart  #
#############################
# Facet Plot - Studentized Process ----------------------------------------

EX2.1 &lt;- ggplot(Both_Processes, aes(x=subgroup_sample,
                          y = metric_value,
                          group = processID)) +
 geom_point(alpha=.2) +
 stat_summary(fun.y = "mean", color="blue", geom=c("point")) +
 stat_summary(fun.y = "mean", color="blue", geom=c("line")) +
 stat_QC() + facet_grid(.~processID, scales = "free_x") +
 stat_QC_labels(text.size =3, label.size=.1)
#EX2.1

EX2.2 &lt;- ggplot(Both_Processes, aes(x=subgroup_sample,
                          y = metric_value,
                          group = processID)) +
 stat_summary(fun.y = "QCrange", color="blue", geom = "point") +
 stat_summary(fun.y = "QCrange", color="blue", geom = "line") +
 stat_QC(method="rBar") +
 stat_QC_labels(digits=2, method="rBar") +
 ylab("Range") +
 facet_grid(.~processID, scales = "free_x")
 #EX2.2
</code></pre>

<hr>
<h2 id='stat_qc_violations'>Inspect QC Violations</h2><span id='topic+stat_qc_violations'></span>

<h3>Description</h3>

<p>ggplot stat function that renders a faceted plot of QC violations
based on the following 4 rules:
</p>

<ul>
<li> <p><b>Violation Same Side:</b> 8 or more consecutive, same-side points
</p>
</li>
<li> <p><b>Violation 1 Sigma:</b> 4 or more consecutive, same-side points exceeding 1 sigma
</p>
</li>
<li> <p><b>Violation 2 Sigma:</b> 2 or more consecutive, same-side points exceeding 2 sigma
</p>
</li>
<li> <p><b>Violation 3 Sigma:</b> any points exceeding 3 sigma
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>stat_qc_violations(mapping = NULL, data = NULL, geom = "point",
  position = "identity", show.legend = NA, inherit.aes = TRUE,
  na.rm = FALSE, method = "xBar.rBar", geom_points = TRUE,
  geom_line = TRUE, point.size = 1.5, point.color = "black",
  violation_point.color = "red", line.color = NULL,
  rule.color = "darkgreen", show.facets = c(1:4), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_qc_violations_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code> or
<code><a href="ggplot2.html#topic+aes_">aes_()</a></code>. If specified and <code>inherit.aes = TRUE</code> (the
default), it is combined with the default mapping at the top level of the
plot. You must supply <code>mapping</code> if there is no plot mapping.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_geom">geom</code></td>
<td>
<p>The geometric object to use display the data</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of
a call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be
stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_method">method</code></td>
<td>
<p>string, calling the following methods:
</p>

<ul>
<li> <p><b>Individuals Charts</b>: XmR,
</p>
</li>
<li> <p><b>Studentized Charts</b>: xBar.rBar, xBar.rMedian, xBar.sBar, xMedian.rBar,
xMedian.rMedian
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_geom_points">geom_points</code></td>
<td>
<p>boolean, draw points</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_geom_line">geom_line</code></td>
<td>
<p>boolean, draw line</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_point.size">point.size</code></td>
<td>
<p>number, size of points on chart</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_point.color">point.color</code></td>
<td>
<p>string, color of points on charts (e.g., &quot;black&quot;)</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_violation_point.color">violation_point.color</code></td>
<td>
<p>string, color of violation points on charts (e.g., &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_line.color">line.color</code></td>
<td>
<p>string, color of lines connecting points</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_rule.color">rule.color</code></td>
<td>
<p>string, color or horizontal rules indicating distribution center and sigma levels</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_show.facets">show.facets</code></td>
<td>
<p>vector, selects violation facet 1 through 4. eg., c(1:4), c(1,4)</p>
</td></tr>
<tr><td><code id="stat_qc_violations_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>faceted plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#####################################
#  Example 1: XmR Check Violations  #
#####################################
# Load Libraries ----------------------------------------------------------
 require(ggQC)
 require(ggplot2)

# Setup Data --------------------------------------------------------------

    set.seed(5555)
    QC_XmR &lt;- data.frame(
    data = c(c(-1, 2.3, 2.4, 2.5),                        #Outlier Data
          sample(c(rnorm(60),5,-5), 62, replace = FALSE), #Normal Data
          c(1,-.3, -2.4,-2.6,-2.5,-2.7, .3)),             #Outlier Data
    Run_Order = 1:73                                      #Run Order
    )


# Render QC Violation Plot ------------------------------------------------------

   EX1 &lt;- ggplot(QC_XmR, aes(x = Run_Order, y = data)) +
     stat_qc_violations(method = "XmR")   #Makes facet graph with violations
   #EX1
#######################################
#  Example 2: Xbar Check Violations   #
#######################################

# Setup Some Data ------------------------------------------------------------
     QC_xBar.rBar &lt;- do.call(rbind, lapply(1:3, function(X){
       set.seed(5555+X)                                   #Loop over 3 seeds
       data.frame(
         sub_group = rep(1:42),                           #Define Subgroups
         sub_class = letters[X],
         c(
          c(runif(n = 5, min = 2.0,3.2)),                 #Outlier Data
          sample(c(rnorm(30),5,-4), 32, replace = FALSE), #Normal Data
          c(runif(n = 5, min = -3.2, max = -2.0))         #Outlier Data
         )
      )
     }
   )
)

colnames(QC_xBar.rBar) &lt;- c("sub_group","sub_class", "value")

# Render QC Violation Plot --------------------------------------------------
    EX2 &lt;- ggplot(QC_xBar.rBar, aes(x = sub_group, y = value)) +
      stat_qc_violations(method = "xBar.rBar")
      #stat_qc_violations(method="xBar.rMedian")
      #stat_qc_violations(method="xBar.sBar")
      #stat_qc_violations(method="xMedian.rBar")
      #stat_qc_violations(method="xMedian.rMedian")
   #EX2

#######################################
#  Example 3: Selected Facets         #
#######################################

# Render QC Violation Plot --------------------------------------------------
    EX3 &lt;- ggplot(QC_xBar.rBar, aes(x = sub_group, y = value)) +
      stat_qc_violations(method = "xBar.rBar", show.facets = c(4))

   #EX3


#######################################################
# Complete User Control - Bypass stat_qc_violation   #
#######################################################
#### The code below has two options if you are looking for complete
#### control over the look and feel of the graph. Use option 1 or option
#### 2 as appropriate. If you want something quick and easy use examples above.

##### Option 1: Setup for XmR Type Data
 # QC_XmR: Defined in Example 1
   QC_Vs &lt;- QC_Violations(data  = QC_XmR$data, method = "XmR")
   QC_Stats &lt;- QC_Lines(data  = QC_XmR$data, method = "XmR")
   MEAN &lt;- QC_Stats$mean
   SIGMA &lt;- QC_Stats$sigma

##### Option 2: Setup for xBar.rBar Type Data
 # QC_xBar.rBar: Defined in Example 2
   QC_Vs &lt;- QC_Violations(data  = QC_xBar.rBar,
                          formula = value~sub_group,
                          method = "xBar.rBar")
   QC_Stats &lt;- QC_Lines(data  = QC_xBar.rBar,
                        formula = value~sub_group,
                        method = "xBar.rBar")
   MEAN &lt;- QC_Stats$xBar_Bar
   SIGMA &lt;- QC_Stats$sigma

##### Setup second table for horizontal rules
 FacetNames &lt;- c("Violation Same Side",
                 "Violation 1 Sigma",
                 "Violation 2 Sigma",
                 "Violation 3 Sigma")

 QC_Vs$Violation_Result &lt;- ordered(QC_Vs$Violation_Result,
                                     levels=FacetNames)

 QC_Stats_df &lt;- data.frame(
   Violation_Result = factor(x = FacetNames, levels = FacetNames),
   SigmaPlus = MEAN+SIGMA*0:3,
   MEAN = MEAN,
   SigmaMinus = MEAN-SIGMA*0:3
 )

##### Make the Plot
 ggplot(QC_Vs, aes(x=Index, y=data, color=Violation, group=1)) +
   geom_point() + geom_line() +
   facet_grid(.~Violation_Result) +
   geom_hline(data = QC_Stats_df, aes(yintercept = c(SigmaPlus))) +
   geom_hline(data = QC_Stats_df, aes(yintercept = c(SigmaMinus))) +
   geom_hline(data = QC_Stats_df, aes(yintercept = c(MEAN)))
</code></pre>

<hr>
<h2 id='uBar'>Mean Rate: Count Data (u-chart)</h2><span id='topic+uBar'></span>

<h3>Description</h3>

<p>Calculates overall mean rate
for count data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uBar(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uBar_+3A_y">y</code></td>
<td>
<p>Vector of counts per unit opportunity (rate). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="uBar_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="uBar_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="uBar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of mean rate, length equal to length of
parameter y.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
counts &lt;- rpois(100, 25)
n &lt;- rpois(100, 15)
uBar(y = counts / n, n = n)

</code></pre>

<hr>
<h2 id='uBar_LCL'>Lower Control Limit: Count Data (u-chart)</h2><span id='topic+uBar_LCL'></span>

<h3>Description</h3>

<p>Calculates point-wise lower control limit (LCL)
for count data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uBar_LCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uBar_LCL_+3A_y">y</code></td>
<td>
<p>Vector of counts per unit opportunity (rate). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="uBar_LCL_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="uBar_LCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="uBar_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector; point-wise 3-sigma lower control limit (LCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
counts &lt;- rpois(100, 25)
n &lt;- rpois(100, 15)
uBar_LCL(y = counts / n, n = n)
</code></pre>

<hr>
<h2 id='uBar_UCL'>Upper Control Limit: Count Data (u-chart)</h2><span id='topic+uBar_UCL'></span>

<h3>Description</h3>

<p>Calculates point-wise upper control limit (UCL)
for count data acquired over a variable area of
opportunity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uBar_UCL(y, n, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uBar_UCL_+3A_y">y</code></td>
<td>
<p>Vector of counts per unit opportunity (rate). Observations
may have a different area of opportunity, n.</p>
</td></tr>
<tr><td><code id="uBar_UCL_+3A_n">n</code></td>
<td>
<p>A vector representing the area of opportunity.</p>
</td></tr>
<tr><td><code id="uBar_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="uBar_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector; point-wise 3-sigma upper control limit (UCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
counts &lt;- rpois(100, 25)
n &lt;- rpois(100, 15)
uBar_UCL(y = counts / n, n = n)

</code></pre>

<hr>
<h2 id='UD'>Calculate Distance to Upper Specification Limit</h2><span id='topic+UD'></span>

<h3>Description</h3>

<p>function to calculate a standardized distance to the Upper specification limit (sigma units)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UD(LSL, USL, QC.Center, QC.Sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UD_+3A_lsl">LSL</code></td>
<td>
<p>number, customer's lower specification limit.</p>
</td></tr>
<tr><td><code id="UD_+3A_usl">USL</code></td>
<td>
<p>number, customer's upper specification limit.</p>
</td></tr>
<tr><td><code id="UD_+3A_qc.center">QC.Center</code></td>
<td>
<p>number, the mean or median value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
<tr><td><code id="UD_+3A_qc.sigma">QC.Sigma</code></td>
<td>
<p>number, the sigma value determined from an XmR plot or a Studentized (e.g., xBar) analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, standardized distance to the upper specification limit (sigma units)
</p>

<hr>
<h2 id='xBar_Bar'>Mean of Subgroup Means</h2><span id='topic+xBar_Bar'></span>

<h3>Description</h3>

<p>Calculates the mean subgroup means used when constructing a xBar-R or xBar-S charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_Bar(data, value, grouping, formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_Bar_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_Bar_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_Bar_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_Bar_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="xBar_Bar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_Bar(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_one_LCL'>xBar_One Lower Control Limit (LCL)</h2><span id='topic+xBar_one_LCL'></span>

<h3>Description</h3>

<p>Calculates the xBar_One LCL used when constructing a xBar-One chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_one_LCL(y, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_one_LCL_+3A_y">y</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="xBar_one_LCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="xBar_one_LCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; xBar_One Lower Control Limit (LCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
values &lt;- rnorm(n = 100, mean = 25, sd = 1)
xBar_one_LCL(values)
</code></pre>

<hr>
<h2 id='xBar_one_UCL'>xBar_One Upper Control Limit (UCL)</h2><span id='topic+xBar_one_UCL'></span>

<h3>Description</h3>

<p>Calculates the xBar_One UCL used when constructing a xBar-One chart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_one_UCL(y, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_one_UCL_+3A_y">y</code></td>
<td>
<p>Vector of values</p>
</td></tr>
<tr><td><code id="xBar_one_UCL_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
<tr><td><code id="xBar_one_UCL_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; xBar_One Upper Control Limit (UCL)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
values &lt;- rnorm(n = 100, mean = 25, sd = 1)
xBar_one_UCL(values)
</code></pre>

<hr>
<h2 id='xBar_rBar_LCL'>Mean of Subgroup Means Lower Control Limit (LCL)</h2><span id='topic+xBar_rBar_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means lower control limit used when constructing a xBar-R charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_rBar_LCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_rBar_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_rBar_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_rBar_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_rBar_LCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_rBar_LCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_rBar_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means lower control limit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_rBar_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_rBar_UCL'>Mean of Subgroup Means Upper Control Limit (UCL)</h2><span id='topic+xBar_rBar_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means upper control limit used when constructing a xBar-R charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_rBar_UCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_rBar_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_rBar_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_rBar_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_rBar_UCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_rBar_UCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_rBar_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means upper control limit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_rBar_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_rMedian_LCL'>Mean of Subgroup Means Lower Control Limit (LCL) based on Median Range</h2><span id='topic+xBar_rMedian_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means lower control limit based on the
median range. The result is used when constructing a xBar-rMedian charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_rMedian_LCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_rMedian_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_rMedian_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_LCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_LCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_rMedian_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means Lower Control Limit (LCL) based on Median Range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_rMedian_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_rMedian_UCL'>Mean of Subgroup Means Upper Control Limit (UCL) based on Median Range</h2><span id='topic+xBar_rMedian_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means upper control limit based on the
median range. The result is used when constructing a xBar-rMedian charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_rMedian_UCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_rMedian_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_rMedian_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_UCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_rMedian_UCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_rMedian_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means Upper Control Limit (UCL) based on Median Range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_rMedian_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_sBar_LCL'>Mean of Subgroup Means Lower Control Limit (LCL) based on Standard Deviation</h2><span id='topic+xBar_sBar_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means lower control limit based on the
standard deviation. The result is used when constructing a xBar-S charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_sBar_LCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_sBar_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_sBar_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_sBar_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_sBar_LCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_sBar_LCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_sBar_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means Lower Control Limit (LCL) based on standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_sBar_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xBar_sBar_UCL'>Mean of Subgroup Means Upper Control Limit (UCL) based on Standard Deviation</h2><span id='topic+xBar_sBar_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup means upper control limit based on the
standard deviation. The result is used when constructing a xBar-S charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBar_sBar_UCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xBar_sBar_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xBar_sBar_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xBar_sBar_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xBar_sBar_UCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xBar_sBar_UCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xBar_sBar_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means Upper Control Limit (UCL) based on standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_sBar_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xMedian_Bar'>Mean of Subgroup Medians</h2><span id='topic+xMedian_Bar'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup medians used when constructing a xMedian-R charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xMedian_Bar(data, value, grouping, formula = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xMedian_Bar_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xMedian_Bar_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xMedian_Bar_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xMedian_Bar_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
<tr><td><code id="xMedian_Bar_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup medians.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xMedian_Bar(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xMedian_rBar_LCL'>Mean of Subgroup Medians Lower Control Limit (LCL) based on Mean Range</h2><span id='topic+xMedian_rBar_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup medians lower control limit based on the
mean range. The result is used when constructing a xMedian-R charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xMedian_rBar_LCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xMedian_rBar_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xMedian_rBar_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_LCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_LCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xMedian_rBar_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup medians Lower Control Limit (LCL) based on mean range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xBar_rMedian_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xMedian_rBar_UCL'>Mean of Subgroup Medians Upper Control Limit (UCL) based on mean Range</h2><span id='topic+xMedian_rBar_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup medians upper control limit based on the
mean subgroup range. The result is used when constructing a xMedian-R charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xMedian_rBar_UCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xMedian_rBar_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xMedian_rBar_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_UCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xMedian_rBar_UCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xMedian_rBar_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup means Upper Control Limit (UCL) based on Median Range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xMedian_rBar_UCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xMedian_rMedian_LCL'>Mean of Subgroup Medians Lower Control Limit (LCL) based on Median Range</h2><span id='topic+xMedian_rMedian_LCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup medians lower control limit based on the
median subgroup range. The result is used when constructing a xMedian-rMedian charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xMedian_rMedian_LCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xMedian_rMedian_LCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_LCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_LCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_LCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_LCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_LCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup median Lower Control Limit (LCL) based on Median Range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xMedian_rMedian_LCL(data = df, formula = v~g)
</code></pre>

<hr>
<h2 id='xMedian_rMedian_UCL'>Mean of Subgroup Medians Upper Control Limit (UCL) based on Median Range</h2><span id='topic+xMedian_rMedian_UCL'></span>

<h3>Description</h3>

<p>Calculates the mean of subgroup medians upper control limit based on the
median subgroup range. The result is used when constructing a xMedian-rMedian charts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xMedian_rMedian_UCL(data, value, grouping, n = NULL, natural = F,
  formula = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xMedian_rMedian_UCL_+3A_data">data</code></td>
<td>
<p>data frame to be processed</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_UCL_+3A_value">value</code></td>
<td>
<p>numeric vector in a data frame with values of interest.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_UCL_+3A_grouping">grouping</code></td>
<td>
<p>single factor/variable to split the data frame &quot;values&quot; by.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_UCL_+3A_n">n</code></td>
<td>
<p>a number indicating a hypothetical subgroup size other than, function determined subgroup n
determined by the floor length of subgroup values.</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_UCL_+3A_natural">natural</code></td>
<td>
<p>logical, if TRUE calculate limits for individuals (n=1) else calculate for
n determined by the floor length of subgroup values</p>
</td></tr>
<tr><td><code id="xMedian_rMedian_UCL_+3A_formula">formula</code></td>
<td>
<p>a formula, such as y ~ x1 + x2, where the y variable is
numeric data to be split into groups according to the grouping x
factors/variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number; mean of subgroup median upper Control Limit (UCL) based on Median Range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(5555)
df &lt;- data.frame(v=rnorm(60, 0, 1), g=rep(c("A","B","C","D","E"), each=12))
xMedian_rMedian_UCL(data = df, formula = v~g)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
