<!DOCTYPE html><html lang="en"><head><title>Help for package microbenchmark</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {microbenchmark}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#autoplot.microbenchmark'><p>Autoplot method for microbenchmark objects: Prettier graphs for</p>
microbenchmark using ggplot2</a></li>
<li><a href='#boxplot.microbenchmark'><p>Boxplot of <code>microbenchmark</code> timings.</p></a></li>
<li><a href='#coalesce'><p>Return first non null argument.</p></a></li>
<li><a href='#convert_to_unit'><p>Convert timings to different units.</p></a></li>
<li><a href='#determine_unit'><p>Normalize timing units to one of the supported values</p></a></li>
<li><a href='#find_prefix'><p>Find SI prefix for unit</p></a></li>
<li><a href='#get_nanotime'><p>Return the current value of the platform timer.</p></a></li>
<li><a href='#microbenchmark'><p>Sub-millisecond accurate timing of expression evaluation.</p></a></li>
<li><a href='#microtiming_precision'><p>Estimate precision of timing routines.</p></a></li>
<li><a href='#print.microbenchmark'><p>Print <code>microbenchmark</code> timings.</p></a></li>
<li><a href='#summary.microbenchmark'><p>Summarize <code>microbenchmark</code> timings.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Accurate Timing Functions</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides infrastructure to accurately measure and compare
        the execution time of R expressions.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joshuaulrich/microbenchmark/">https://github.com/joshuaulrich/microbenchmark/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joshuaulrich/microbenchmark/issues/">https://github.com/joshuaulrich/microbenchmark/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, multcomp, RUnit</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>On a Unix-alike, one of the C functions
mach_absolute_time (macOS), clock_gettime or gethrtime. If none
of these is found, the obsolescent POSIX function gettimeofday
will be tried.</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-03 22:50:33 UTC; josh</td>
</tr>
<tr>
<td>Author:</td>
<td>Olaf Mersmann [aut],
  Claudia Beleites [ctb],
  Rainer Hurling [ctb],
  Ari Friedman [ctb],
  Joshua M. Ulrich [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua M. Ulrich &lt;josh.m.ulrich@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-04 18:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='autoplot.microbenchmark'>Autoplot method for microbenchmark objects: Prettier graphs for
microbenchmark using ggplot2</h2><span id='topic+autoplot.microbenchmark'></span>

<h3>Description</h3>

<p>Uses ggplot2 to produce a more legible graph of microbenchmark timings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot.microbenchmark(
  object,
  ...,
  order = NULL,
  log = TRUE,
  unit = NULL,
  y_max = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.microbenchmark_+3A_object">object</code></td>
<td>
<p>A microbenchmark object.</p>
</td></tr>
<tr><td><code id="autoplot.microbenchmark_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="autoplot.microbenchmark_+3A_order">order</code></td>
<td>
<p>Names of output column(s) to order the results.</p>
</td></tr>
<tr><td><code id="autoplot.microbenchmark_+3A_log">log</code></td>
<td>
<p>If <code>TRUE</code> the time axis will be on log scale.</p>
</td></tr>
<tr><td><code id="autoplot.microbenchmark_+3A_unit">unit</code></td>
<td>
<p>The unit to use for graph labels.</p>
</td></tr>
<tr><td><code id="autoplot.microbenchmark_+3A_y_max">y_max</code></td>
<td>
<p>The upper limit of the y axis, in the unit automatically
chosen for the time axis (defaults to the maximum value).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Author(s)</h3>

<p>Ari Friedman, Olaf Mersmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("ggplot2", quietly = TRUE)) {
    tm &lt;- microbenchmark(rchisq(100, 0),
                         rchisq(100, 1),
                         rchisq(100, 2),
                         rchisq(100, 3),
                         rchisq(100, 5), times=1000L)
    ggplot2::autoplot(tm)

    # add a custom title
    ggplot2::autoplot(tm) + ggplot2::ggtitle("my timings")
}
</code></pre>

<hr>
<h2 id='boxplot.microbenchmark'>Boxplot of <code>microbenchmark</code> timings.</h2><span id='topic+boxplot.microbenchmark'></span>

<h3>Description</h3>

<p>Boxplot of <code>microbenchmark</code> timings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'microbenchmark'
boxplot(
  x,
  unit = "t",
  log = TRUE,
  xlab,
  ylab,
  horizontal = FALSE,
  main = "microbenchmark timings",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxplot.microbenchmark_+3A_x">x</code></td>
<td>
<p>A <code>microbenchmark</code> object.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_unit">unit</code></td>
<td>
<p>Unit in which the results be plotted.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_log">log</code></td>
<td>
<p>Should times be plotted on log scale?</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_xlab">xlab</code></td>
<td>
<p>X axis label.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_ylab">ylab</code></td>
<td>
<p>Y axis label.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_horizontal">horizontal</code></td>
<td>
<p>Switch X and Y axes.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="boxplot.microbenchmark_+3A_...">...</code></td>
<td>
<p>Passed on to boxplot.formula.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>

<hr>
<h2 id='coalesce'>Return first non null argument.</h2><span id='topic+coalesce'></span>

<h3>Description</h3>

<p>This function is useful when processing complex arguments with multiple
possible defaults based on other arguments that may or may not have been
provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesce(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coalesce_+3A_...">...</code></td>
<td>
<p>List of values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>First non null element in <code>...</code>.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>

<hr>
<h2 id='convert_to_unit'>Convert timings to different units.</h2><span id='topic+convert_to_unit'></span>

<h3>Description</h3>

<p>The following units of time are supported </p>

<dl>
<dt>&ldquo;ns&rdquo;</dt><dd><p>Nanoseconds.</p>
</dd>
<dt>&ldquo;us&rdquo;</dt><dd><p>Microseconds.</p>
</dd>
<dt>&ldquo;ms&rdquo;</dt><dd><p>Milliseconds.</p>
</dd>
<dt>&ldquo;s&rdquo;</dt><dd><p>Seconds.</p>
</dd>
<dt>&ldquo;t&rdquo;</dt><dd><p>Appropriately prefixed time unit.</p>
</dd>
<dt>&ldquo;hz&rdquo;</dt><dd><p>Hertz / evaluations per second.</p>
</dd>
<dt>&ldquo;eps&rdquo;</dt><dd><p>Evaluations per second / Hertz.</p>
</dd>
<dt>&ldquo;khz&rdquo;</dt><dd><p>Kilohertz / 1000s of evaluations per second.</p>
</dd>
<dt>&ldquo;mhz&rdquo;</dt><dd><p>Megahertz / 1000000s of evaluations per second.</p>
</dd>
<dt>&ldquo;f&rdquo;</dt><dd><p>Appropriately prefixed frequency unit.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>convert_to_unit(object, unit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_to_unit_+3A_object">object</code></td>
<td>
<p>A <code>microbenchmark</code> object.</p>
</td></tr>
<tr><td><code id="convert_to_unit_+3A_unit">unit</code></td>
<td>
<p>A unit of time. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the converted time values with an
attribute <code>unit</code> which is a printable name of the unit of
time.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>

<hr>
<h2 id='determine_unit'>Normalize timing units to one of the supported values</h2><span id='topic+determine_unit'></span>

<h3>Description</h3>

<p>We support the following units of time
</p>

<dl>
<dt>&ldquo;ns&rdquo;, &ldquo;nanoseconds&rdquo;</dt><dd></dd>
<dt>&ldquo;us&rdquo;, &ldquo;microseconds&rdquo;</dt><dd></dd>
<dt>&ldquo;ms&rdquo;, &ldquo;milliseconds&rdquo;</dt><dd></dd>
<dt>&ldquo;s&rdquo;, &ldquo;secs&rdquo;, &ldquo;seconds&rdquo;</dt><dd></dd>
<dt>&ldquo;t&rdquo;, &ldquo;time&rdquo;</dt><dd><p>Appropriately prefixed time unit.</p>
</dd>
<dt>&ldquo;eps&rdquo;</dt><dd><p>Evaluations per second / Hertz.</p>
</dd>
<dt>&ldquo;hz&rdquo;</dt><dd><p>Hertz / evaluations per second.</p>
</dd>
<dt>&ldquo;khz&rdquo;</dt><dd><p>Kilohertz / 1000s of evaluations per second.</p>
</dd>
<dt>&ldquo;mhz&rdquo;</dt><dd><p>Megahertz / 1000000s of evaluations per second.</p>
</dd>
<dt>&ldquo;f&rdquo;, &ldquo;frequency&rdquo;</dt><dd><p>Appropriately prefixed frequency unit.</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>determine_unit(object = NULL, unit = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="determine_unit_+3A_object">object</code></td>
<td>
<p>A 'microbenchmark' object.</p>
</td></tr>
<tr><td><code id="determine_unit_+3A_unit">unit</code></td>
<td>
<p>A unit of time. See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the converted time values with an
attribute <code>unit</code> which is a printable name of the unit of
time.
</p>


<h3>Author(s)</h3>

<p>Joshua M. Ulrich
</p>

<hr>
<h2 id='find_prefix'>Find SI prefix for unit</h2><span id='topic+find_prefix'></span>

<h3>Description</h3>

<p>Find SI prefix for unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_prefix(x, f = min, minexp = -Inf, maxexp = Inf, mu = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="find_prefix_+3A_x">x</code></td>
<td>
<p>a numeric</p>
</td></tr>
<tr><td><code id="find_prefix_+3A_f">f</code></td>
<td>
<p>function that produces the number from <code>x</code> that is used to
determine the prefix, e.g. <code><a href="base.html#topic+min">min</a></code> or
<code><a href="stats.html#topic+median">median</a></code>.</p>
</td></tr>
<tr><td><code id="find_prefix_+3A_minexp">minexp</code></td>
<td>
<p>minimum (decimal) exponent to consider, 
e.g. -3 to suppress prefixes smaller than milli (m).</p>
</td></tr>
<tr><td><code id="find_prefix_+3A_maxexp">maxexp</code></td>
<td>
<p>maximum (decimal) exponent to consider, 
e.g. 3 to suppress prefixes larger than kilo (k).</p>
</td></tr>
<tr><td><code id="find_prefix_+3A_mu">mu</code></td>
<td>
<p>if <code>TRUE</code>, should a proper mu be used for micro, otherwise use
u as ASCII-compatible replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character with the SI prefix
</p>


<h3>Author(s)</h3>

<p>Claudia Beleites
</p>

<hr>
<h2 id='get_nanotime'>Return the current value of the platform timer.</h2><span id='topic+get_nanotime'></span>

<h3>Description</h3>

<p>The current value of the most accurate timer of the platform is
returned. This can be used as a time stamp for logging or similar
purposes. Please note that there is no common reference, that is,
the timer value cannot be converted to a date and time value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_nanotime()
</code></pre>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>

<hr>
<h2 id='microbenchmark'>Sub-millisecond accurate timing of expression evaluation.</h2><span id='topic+microbenchmark'></span>

<h3>Description</h3>

<p><code>microbenchmark</code> serves as a more accurate replacement of the
often seen <code>system.time(replicate(1000, expr))</code>
expression. It tries hard to accurately measure only the time it
takes to evaluate <code>expr</code>. To achieved this, the
sub-millisecond (supposedly nanosecond) accurate timing functions
most modern operating systems provide are used. Additionally all
evaluations of the expressions are done in C code to minimize any
overhead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microbenchmark(
  ...,
  list = NULL,
  times = 100L,
  unit = NULL,
  check = NULL,
  control = list(),
  setup = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="microbenchmark_+3A_...">...</code></td>
<td>
<p>Expressions to benchmark.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_list">list</code></td>
<td>
<p>List of unevaluated expressions to benchmark.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_times">times</code></td>
<td>
<p>Number of times to evaluate each expression.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_unit">unit</code></td>
<td>
<p>Default unit used in <code>summary</code> and <code>print</code>.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_check">check</code></td>
<td>
<p>A function to check if the expressions are equal. By default <code>NULL</code> which omits the check.
In addition to a function, a string can be supplied.
The string &lsquo;equal&rsquo; will compare all values using <code><a href="base.html#topic+all.equal">all.equal</a></code>, &lsquo;equivalent&rsquo; will compare all values using <code><a href="base.html#topic+all.equal">all.equal</a></code> and check.attributes = FALSE, and &lsquo;identical&rsquo; will compare all values using <code><a href="base.html#topic+identical">identical</a></code>.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_control">control</code></td>
<td>
<p>List of control arguments. See Details.</p>
</td></tr>
<tr><td><code id="microbenchmark_+3A_setup">setup</code></td>
<td>
<p>An unevaluated expression to be run (untimed) before each benchmark expression.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only meant for micro-benchmarking small pieces of
source code and to compare their relative performance
characteristics. You should generally avoid benchmarking larger
chunks of your code using this function. Instead, try using the R
profiler to detect hot spots and consider rewriting them in C/C++
or FORTRAN.
</p>
<p>The <code>control</code> list can contain the following entries:
</p>

<dl>
<dt>order</dt><dd><p>the order in which the expressions are evaluated.
&ldquo;random&rdquo; (the default) randomizes the execution order,
&ldquo;inorder&rdquo; executes each expression in order and
&ldquo;block&rdquo; executes all repetitions of each expression
as one block.</p>
</dd>
<dt>warmup</dt><dd><p>the number of iterations to run the timing code before
evaluating the expressions in .... These warm-up iterations are used
to estimate the timing overhead as well as spinning up the processor
from any sleep or idle states it might be in. The default value is 2.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Object of class &lsquo;microbenchmark&rsquo;, a data frame with
columns <code>expr</code> and <code>time</code>. <code>expr</code> contains the
deparsed expression as passed to <code>microbenchmark</code> or the name
of the argument if the expression was passed as a named
argument. <code>time</code> is the measured execution time of the
expression in nanoseconds. The order of the observations in the
data frame is the order in which they were executed.
</p>


<h3>Note</h3>

<p>Depending on the underlying operating system, different
methods are used for timing. On Windows the
<code>QueryPerformanceCounter</code> interface is used to measure the
time passed. For Linux the <code>clock_gettime</code> API is used and on
Solaris the <code>gethrtime</code> function. Finally on MacOS X the,
undocumented, <code>mach_absolute_time</code> function is used to avoid
a dependency on the CoreServices Framework.
</p>
<p>Before evaluating each expression <code>times</code> times, the overhead
of calling the timing functions and the C function call overhead
are estimated. This estimated overhead is subtracted from each
measured evaluation time. Should the resulting timing be negative,
a warning is thrown and the respective value is replaced by
<code>0</code>. If the timing is zero, a warning is raised.
Should all evaluations result in one of the two error conditions described above, an error is raised.
</p>
<p>One platform on which the clock resolution is known to be too low to measure short runtimes with the required precision is 
Oracle&reg;
Solaris 
on some 
SPARC&reg;
hardware.
Reports of other platforms with similar problems are welcome.
Please contact the package maintainer.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.microbenchmark">print.microbenchmark</a></code> to display and
<code><a href="#topic+boxplot.microbenchmark">boxplot.microbenchmark</a></code> or
<code><a href="#topic+autoplot.microbenchmark">autoplot.microbenchmark</a></code> to plot the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Measure the time it takes to dispatch a simple function call
## compared to simply evaluating the constant \code{NULL}
f &lt;- function() NULL
res &lt;- microbenchmark(NULL, f(), times=1000L)

## Print results:
print(res)

## Plot results:
boxplot(res)

## Pretty plot:
if (requireNamespace("ggplot2")) {
  ggplot2::autoplot(res)
}

## Example check usage
my_check &lt;- function(values) {
  all(sapply(values[-1], function(x) identical(values[[1]], x)))
}

f &lt;- function(a, b)
  2 + 2

a &lt;- 2
## Check passes
microbenchmark(2 + 2, 2 + a, f(2, a), f(2, 2), check=my_check)
## Not run: 
a &lt;- 3
## Check fails
microbenchmark(2 + 2, 2 + a, f(2, a), f(2, 2), check=my_check)

## End(Not run)
## Example setup usage
set.seed(21)
x &lt;- rnorm(10)
microbenchmark(x, rnorm(10), check=my_check, setup=set.seed(21))
## Will fail without setup
## Not run: 
microbenchmark(x, rnorm(10), check=my_check)

## End(Not run)
## using check
a &lt;- 2
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='identical')
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equal')
attr(a, 'abc') &lt;- 123
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equivalent')
## check='equal' will fail due to difference in attribute
## Not run: 
microbenchmark(2 + 2, 2 + a, sum(2, a), sum(2, 2), check='equal')

## End(Not run)
</code></pre>

<hr>
<h2 id='microtiming_precision'>Estimate precision of timing routines.</h2><span id='topic+microtiming_precision'></span>

<h3>Description</h3>

<p>This function is currently experimental. Its main use is to judge
the quality of the underlying timer implementation of the
operating system. The function measures the overhead of timing a C
function call <code>rounds</code> times and returns all non-zero timings
observed. This can be used to judge the granularity and resolution
of the timing subsystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>microtiming_precision(rounds = 100L, warmup = 2^18)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="microtiming_precision_+3A_rounds">rounds</code></td>
<td>
<p>Number of measurements used to estimate the precision.</p>
</td></tr>
<tr><td><code id="microtiming_precision_+3A_warmup">warmup</code></td>
<td>
<p>Number of iterations used to warm up the CPU.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of observed non-zero timings.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>

<hr>
<h2 id='print.microbenchmark'>Print <code>microbenchmark</code> timings.</h2><span id='topic+print.microbenchmark'></span>

<h3>Description</h3>

<p>Print <code>microbenchmark</code> timings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'microbenchmark'
print(x, unit, order, signif, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.microbenchmark_+3A_x">x</code></td>
<td>
<p>An object of class <code>microbenchmark</code>.</p>
</td></tr>
<tr><td><code id="print.microbenchmark_+3A_unit">unit</code></td>
<td>
<p>What unit to print the timings in. Default value taken
from to option <code>microbenchmark.unit</code> (see example).</p>
</td></tr>
<tr><td><code id="print.microbenchmark_+3A_order">order</code></td>
<td>
<p>If present, order results according to this column of the output.</p>
</td></tr>
<tr><td><code id="print.microbenchmark_+3A_signif">signif</code></td>
<td>
<p>If present, limit the number of significant digits shown.</p>
</td></tr>
<tr><td><code id="print.microbenchmark_+3A_...">...</code></td>
<td>
<p>Passed to <code>print.data.frame</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>The available units are nanoseconds (<code>"ns"</code>), microseconds
(<code>"us"</code>), milliseconds (<code>"ms"</code>), seconds (<code>"s"</code>)
and evaluations per seconds (<code>"eps"</code>) and relative runtime
compared to the best median time (<code>"relative"</code>).
</p>
<p>If the <code>multcomp</code> package is available a statistical
ranking is calculated and displayed in compact letter display from
in the <code>cld</code> column.
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxplot.microbenchmark">boxplot.microbenchmark</a></code> and
<code><a href="#topic+autoplot.microbenchmark">autoplot.microbenchmark</a></code> for a plot methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a1 &lt;- a2 &lt;- a3 &lt;- a4 &lt;- numeric(0)

res &lt;- microbenchmark(a1 &lt;- c(a1, 1),
                      a2 &lt;- append(a2, 1),
                      a3[length(a3) + 1] &lt;- 1,
                      a4[[length(a4) + 1]] &lt;- 1,
                      times=100L)
print(res)
## Change default unit to relative runtime
options(microbenchmark.unit="relative")
print(res)
## Change default unit to evaluations per second
options(microbenchmark.unit="eps")
print(res)

</code></pre>

<hr>
<h2 id='summary.microbenchmark'>Summarize <code>microbenchmark</code> timings.</h2><span id='topic+summary.microbenchmark'></span>

<h3>Description</h3>

<p>Summarize <code>microbenchmark</code> timings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'microbenchmark'
summary(object, unit, ..., include_cld = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.microbenchmark_+3A_object">object</code></td>
<td>
<p>An object of class <code>microbenchmark</code>.</p>
</td></tr>
<tr><td><code id="summary.microbenchmark_+3A_unit">unit</code></td>
<td>
<p>What unit to print the timings in. If none is given,
either the <code>unit</code> attribute of <code>object</code> or the option
<code>microbenchmark.unit</code> is used and if neither is set
&ldquo;t&rdquo; is used.</p>
</td></tr>
<tr><td><code id="summary.microbenchmark_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary.microbenchmark_+3A_include_cld">include_cld</code></td>
<td>
<p>Calculate <code>cld</code> using <code>multcomp::glht()</code>
and add it to the output. Set to <code>FALSE</code> if the calculation takes
too long.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the aggregated results.
</p>


<h3>Note</h3>

<p>The available units are nanoseconds (<code>"ns"</code>),
microseconds (<code>"us"</code>), milliseconds (<code>"ms"</code>), seconds
(<code>"s"</code>) and evaluations per seconds (<code>"eps"</code>) and
relative runtime compared to the best median time
(<code>"relative"</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.microbenchmark">print.microbenchmark</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
