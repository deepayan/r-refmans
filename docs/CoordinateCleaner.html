<!DOCTYPE html><html lang="en-gb"><head><title>Help for package CoordinateCleaner</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CoordinateCleaner}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CoordinateCleaner-package'><p>CoordinateCleaner</p></a></li>
<li><a href='#aohi'><p>Artificial Hotspot Occurrence Inventory</p></a></li>
<li><a href='#buffland'><p>Global Coastlines buffered by 1 degree</p></a></li>
<li><a href='#buffsea'><p>Global Coastlines buffered by -1 degree</p></a></li>
<li><a href='#cc_aohi'><p>Identify Coordinates in Artificial Hotspot Occurrence Inventory</p></a></li>
<li><a href='#cc_cap'><p>Identify Coordinates in Vicinity of Country Capitals.</p></a></li>
<li><a href='#cc_cen'><p>Identify Coordinates in Vicinity of Country and Province Centroids</p></a></li>
<li><a href='#cc_coun'><p>Identify Coordinates Outside their Reported Country</p></a></li>
<li><a href='#cc_dupl'><p>Identify Duplicated Records</p></a></li>
<li><a href='#cc_equ'><p>Identify Records with Identical lat/lon</p></a></li>
<li><a href='#cc_gbif'><p>Identify Records Assigned to GBIF Headquarters</p></a></li>
<li><a href='#cc_inst'><p>Identify Records in the Vicinity of Biodiversity Institutions</p></a></li>
<li><a href='#cc_iucn'><p>Identify Records Outside Natural Ranges</p></a></li>
<li><a href='#cc_outl'><p>Identify Geographic Outliers in Species Distributions</p></a></li>
<li><a href='#cc_sea'><p>Identify Non-terrestrial Coordinates</p></a></li>
<li><a href='#cc_urb'><p>Identify Records Inside Urban Areas</p></a></li>
<li><a href='#cc_val'><p>Identify Invalid lat/lon Coordinates</p></a></li>
<li><a href='#cc_zero'><p>Identify Zero Coordinates</p></a></li>
<li><a href='#cd_ddmm'><p>Identify Datasets with a Degree Conversion Error</p></a></li>
<li><a href='#cd_round'><p>Identify Datasets with Rasterized Coordinates</p></a></li>
<li><a href='#cf_age'><p>Identify Fossils with Outlier Age</p></a></li>
<li><a href='#cf_equal'><p>Identify Fossils with equal min and max age</p></a></li>
<li><a href='#cf_outl'><p>Identify Outlier Records in Space and Time</p></a></li>
<li><a href='#cf_range'><p>Identify Fossils with Extreme Age Ranges</p></a></li>
<li><a href='#clean_coordinates'><p>Geographic Cleaning of Coordinates from Biologic Collections</p></a></li>
<li><a href='#clean_dataset'><p>Coordinate Cleaning using Dataset Properties</p></a></li>
<li><a href='#clean_fossils'><p>Geographic and Temporal Cleaning of Records from Fossil Collections</p></a></li>
<li><a href='#countryref'><p>Country Centroids and Country Capitals</p></a></li>
<li><a href='#institutions'><p>Global Locations of Biodiversity Institutions</p></a></li>
<li><a href='#is.spatialvalid'><p>Check spatialvalid object</p></a></li>
<li><a href='#pbdb_example'><p>Example data from the Paleobiologydatabase</p></a></li>
<li><a href='#plot.spatialvalid'><p>Plot Method for Class Spatialvalid</p></a></li>
<li><a href='#write_pyrate'><p>Create Input Files for PyRate</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Automated Cleaning of Occurrence Records from Biological
Collections</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Automated flagging of common spatial and temporal
    errors in biological and paleontological collection data, for the use
    in conservation, ecology and paleontology. Includes automated tests to
    easily flag (and exclude) records assigned to country or province
    centroid, the open ocean, the headquarters of the Global Biodiversity
    Information Facility, urban areas or the location of biodiversity
    institutions (museums, zoos, botanical gardens, universities).
    Furthermore identifies per species outlier coordinates, zero
    coordinates, identical latitude/longitude and invalid coordinates.
    Also implements an algorithm to identify data sets with a significant
    proportion of rounded coordinates. Especially suited for large data
    sets. The reference for the methodology is: Zizka et al. (2019)
    &lt;<a href="https://doi.org/10.1111%2F2041-210X.13152">doi:10.1111/2041-210X.13152</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/CoordinateCleaner/issues">https://github.com/ropensci/CoordinateCleaner/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, geosphere, ggplot2, graphics, grDevices, methods,
rgbif, rnaturalearth (&ge; 0.3.2), stats, terra, tidyselect,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>countrycode, covr, knitr, magrittr, maps, rmarkdown,
rnaturalearthdata, sf, testthat, viridis</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-gb</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GDAL (&gt;= 2.0.1)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-24 19:17:49 UTC; brunovilela</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Zizka [aut, cre],
  Daniele Silvestro [ctb],
  Tobias Andermann [ctb],
  Josue Azevedo [ctb],
  Camila Duarte Ritter [ctb],
  Daniel Edler [ctb],
  Harith Farooq [ctb],
  Andrei Herdean [ctb],
  Maria Ariza [ctb],
  Ruud Scharn [ctb],
  Sten Svanteson [ctb],
  Niklas Wengstrom [ctb],
  Vera Zizka [ctb],
  Alexandre Antonelli [ctb],
  Bruno Vilela [ctb] (Bruno updated the package to remove dependencies on
    sp, raster, rgdal, maptools, and rgeos packages),
  Irene Steves [rev] (Irene reviewed the package for ropensci, see
    &lt;https://github.com/ropensci/onboarding/issues/210&gt;),
  Francisco Rodriguez-Sanchez [rev] (Francisco reviewed the package for
    ropensci, see &lt;https://github.com/ropensci/onboarding/issues/210&gt;)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Zizka &lt;zizka.alexander@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-24 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CoordinateCleaner-package'>CoordinateCleaner</h2><span id='topic+CoordinateCleaner-package'></span><span id='topic+CoordinateCleaner'></span>

<h3>Description</h3>

<p>Automated Cleaning of Occurrence Records from Biological Collections
</p>


<h3>Details</h3>

<p>Automated flagging of common spatial and temporal errors in biological and
paleontological collection data, for the use in conservation, ecology and
paleontology. Includes automated tests to easily flag (and exclude) records
assigned to country or province centroid, the open ocean, the headquarters of
the Global Biodiversity Information Facility, urban areas or the location of
biodiversity institutions (museums, zoos, botanical gardens, universities).
Furthermore identifies per species outlier coordinates, zero coordinates,
identical latitude/longitude and invalid coordinates. Also implements an
algorithm to identify data sets with a significant proportion of rounded
coordinates. Especially suited for large data sets. See
&lt;https://ropensci.github.io/CoordinateCleaner/&gt; for more details and
tutorials.
</p>


<h3>Author(s)</h3>

<p>Alexander Zizka, Daniele Silvestro, Tobias Andermann, Josue Azevedo, 
Camila Duarte Ritter, Daniel Edler, Harith Farooq, Andrei Herdean, Maria Ariza, 
Ruud Scharn, Sten Svantesson, Niklas Wengstrom, Vera Zizka
</p>

<hr>
<h2 id='aohi'>Artificial Hotspot Occurrence Inventory</h2><span id='topic+aohi'></span>

<h3>Description</h3>

<p>A data frame with information on Artificial Hotspot Occurrence Inventory (AHOI)
as available in Park et al 2022. For more details see reference.
</p>


<h3>Source</h3>

<p><a href="https://onlinelibrary.wiley.com/doi/10.1111/jbi.14543">https://onlinelibrary.wiley.com/doi/10.1111/jbi.14543</a>
</p>


<h3>References</h3>

<p>Park, D. S., Xie, Y., Thammavong, H. T., Tulaiha, R., &amp; Feng, X.
(2023). Artificial Hotspot Occurrence Inventory (AHOI). Journal of
Biogeography, 50, 441â€“449. <a href="https://doi.org/10.1111/jbi.14543">doi:10.1111/jbi.14543</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("aohi")
</code></pre>

<hr>
<h2 id='buffland'>Global Coastlines buffered by 1 degree</h2><span id='topic+buffland'></span>

<h3>Description</h3>

<p>A <code>SpatVector</code> with global coastlines, with a 1 degree buffer to extent coastlines as alternative reference for <code><a href="#topic+cc_sea">cc_sea</a></code>. Can be useful to identify species in the sea, without flagging records in mangroves, marshes, etc.
</p>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/downloads/10m-physical-vectors/">https://www.naturalearthdata.com/downloads/10m-physical-vectors/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("buffland")
</code></pre>

<hr>
<h2 id='buffsea'>Global Coastlines buffered by -1 degree</h2><span id='topic+buffsea'></span>

<h3>Description</h3>

<p>A <code>SpatVector</code> with global coastlines, with a -1 degree buffer to extent coastlines as alternative reference for <code><a href="#topic+cc_sea">cc_sea</a></code>. Can be useful to identify marine species on land without flagging records in estuaries, etc.
</p>


<h3>Source</h3>

<p><a href="https://www.naturalearthdata.com/downloads/10m-physical-vectors/">https://www.naturalearthdata.com/downloads/10m-physical-vectors/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("buffsea")
</code></pre>

<hr>
<h2 id='cc_aohi'>Identify Coordinates in Artificial Hotspot Occurrence Inventory</h2><span id='topic+cc_aohi'></span>

<h3>Description</h3>

<p>Removes or flags records within Artificial Hotspot Occurrence Inventory.
Poorly geo-referenced occurrence records in biological databases are often
erroneously geo-referenced to highly recurring coordinates that were assessed
by Park et al 2022. See the reference for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_aohi(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  taxa = c("Aves", "Insecta", "Mammalia", "Plantae"),
  buffer = 10000,
  geod = TRUE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_aohi_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_species">species</code></td>
<td>
<p>character string. The column with the species identity. Only
required if verify = TRUE.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_taxa">taxa</code></td>
<td>
<p>Artificial Hotspot Occurrence Inventory (AHOI) were created based
on four different taxa, birds, insecta, mammalia, and plantae. Users can
choose to keep all, or any specific taxa subset to define the AHOI locations.
Default is to keep all: c(&quot;Aves&quot;, &quot;Insecta&quot;, &quot;Mammalia&quot;, &quot;Plantae&quot;).</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_buffer">buffer</code></td>
<td>
<p>The buffer around each capital coordinate (the centre of the
city), where records should be flagged as problematic. Units depend on
geod. Default = 10 kilometres.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_geod">geod</code></td>
<td>
<p>logical. If TRUE the radius around each capital is calculated
based on a sphere, buffer is in meters and independent of latitude. If
FALSE the radius is calculated assuming planar coordinates and varies
slightly with latitude. Default = TRUE.
See https://seethedatablog.wordpress.com/ for detail and credits.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_aohi_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>References</h3>

<p>Park, D. S., Xie, Y., Thammavong, H. T., Tulaiha, R., &amp; Feng, X.
(2023). Artificial Hotspot Occurrence Inventory (AHOI). Journal of
Biogeography, 50, 441â€“449. <a href="https://doi.org/10.1111/jbi.14543">doi:10.1111/jbi.14543</a>
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = c(runif(99, -180, 180), -47.92), 
                decimalLatitude = c(runif(99, -90,90), -15.78))
cc_aohi(x)

</code></pre>

<hr>
<h2 id='cc_cap'>Identify Coordinates in Vicinity of Country Capitals.</h2><span id='topic+cc_cap'></span>

<h3>Description</h3>

<p>Removes or flags records within a certain radius around country capitals.
Poorly geo-referenced occurrence records in biological databases are often
erroneously geo-referenced to capitals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_cap(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  buffer = 10000,
  geod = TRUE,
  ref = NULL,
  verify = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_cap_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_species">species</code></td>
<td>
<p>character string. The column with the species identity. Only
required if verify = TRUE.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_buffer">buffer</code></td>
<td>
<p>The buffer around each capital coordinate (the centre of the
city), where records should be flagged as problematic. Units depend on
geod. Default = 10 kilometres.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_geod">geod</code></td>
<td>
<p>logical. If TRUE the radius around each capital is calculated
based on a sphere, buffer is in meters and independent of latitude. If
FALSE the radius is calculated assuming planar coordinates and varies
slightly with latitude. Default = TRUE.
See https://seethedatablog.wordpress.com/ for detail and credits.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_ref">ref</code></td>
<td>
<p>SpatVector (geometry: polygons). Providing the geographic
gazetteer. Can be any SpatVector (geometry: polygons), but the structure
must be identical to <code><a href="#topic+countryref">countryref</a></code>.  Default =
<code><a href="#topic+countryref">countryref</a></code>.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_verify">verify</code></td>
<td>
<p>logical. If TRUE records are only flagged if they are the only
record in a given species flagged close to a given reference. If FALSE, the
distance is the only criterion</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_cap_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- data.frame(species = letters[1:10],
                decimalLongitude = c(runif(99, -180, 180), -47.882778),
                decimalLatitude = c(runif(99, -90, 90), -15.793889))

cc_cap(x)
cc_cap(x, value = "flagged")

## End(Not run)
</code></pre>

<hr>
<h2 id='cc_cen'>Identify Coordinates in Vicinity of Country and Province Centroids</h2><span id='topic+cc_cen'></span>

<h3>Description</h3>

<p>Removes or flags records within a radius around the geographic centroids of political
countries and provinces. Poorly geo-referenced occurrence records in
biological databases are often erroneously geo-referenced to centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_cen(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  buffer = 1000,
  geod = TRUE,
  test = "both",
  ref = NULL,
  verify = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_cen_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_species">species</code></td>
<td>
<p>character string. The column with the species identity. Only
required if verify = TRUE.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_buffer">buffer</code></td>
<td>
<p>numerical. The buffer around each province or country
centroid, where records should be flagged as problematic. Units depend on geod.  
Default = 1 kilometre.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_geod">geod</code></td>
<td>
<p>logical. If TRUE the radius around each capital is calculated
based on a sphere, buffer is in meters and independent of latitude. If
FALSE the radius is calculated assuming planar coordinates and varies
slightly with latitude. Default = TRUE.
See https://seethedatablog.wordpress.com/ for detail and credits.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_test">test</code></td>
<td>
<p>a character string. Specifying the details of the test. One of
c(&ldquo;both&rdquo;, &ldquo;country&rdquo;, &ldquo;provinces&rdquo;).  If both tests for
country and province centroids.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_ref">ref</code></td>
<td>
<p>SpatVector (geometry: polygons). Providing the geographic
gazetteer. Can be any SpatVector (geometry: polygons), but the structure
must be identical to <code><a href="#topic+countryref">countryref</a></code>.  Default =
<code><a href="#topic+countryref">countryref</a></code>.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_verify">verify</code></td>
<td>
<p>logical. If TRUE records are only flagged if they are the only
record in a given species flagged close to a given reference. If FALSE, the
distance is the only criterion</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_cen_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = c(runif(99, -180, 180), -47.92), 
                decimalLatitude = c(runif(99, -90,90), -15.78))
cc_cen(x, geod = FALSE)

## Not run: 
cc_inst(x, value = "flagged", buffer = 50000) #geod = T

## End(Not run)

</code></pre>

<hr>
<h2 id='cc_coun'>Identify Coordinates Outside their Reported Country</h2><span id='topic+cc_coun'></span>

<h3>Description</h3>

<p>Removes or flags mismatches between geographic coordinates and additional
country information (usually this information is reliably reported with
specimens). Such a mismatch can occur for example, if latitude and longitude
are switched.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_coun(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  iso3 = "countrycode",
  value = "clean",
  ref = NULL,
  ref_col = "iso_a3",
  verbose = TRUE,
  buffer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_coun_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_iso3">iso3</code></td>
<td>
<p>a character string. The column with the country assignment of
each record in three letter ISO code. Default = &ldquo;countrycode&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_ref">ref</code></td>
<td>
<p>SpatVector (geometry: polygons). Providing the geographic
gazetteer. Can be any SpatVector (geometry: polygons), but the structure
must be identical to <code>rnaturalearth::ne_countries(scale = "medium",
returnclass = "sf")</code>.
Default = <code>rnaturalearth::ne_countries(scale = "medium", returnclass =
"sf")</code></p>
</td></tr>
<tr><td><code id="cc_coun_+3A_ref_col">ref_col</code></td>
<td>
<p>the column name in the reference dataset, containing the
relevant ISO codes for matching. Default is to &quot;iso_a3_eh&quot; which refers to
the ISO-3 codes in the reference dataset. See notes.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="cc_coun_+3A_buffer">buffer</code></td>
<td>
<p>numeric. Units are in meters. If provided, a buffer is
created around each country polygon.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>The ref_col argument allows to adapt the function to the structure of
alternative reference datasets. For instance, for
<code>rnaturalearth::ne_countries(scale = "small")</code>, the default will fail,
but ref_col = &quot;iso_a3&quot; will work.
</p>
<p>With the default reference, records are flagged if they fall outside
the terrestrial territory of countries, hence records in territorial waters
might be flagged. See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a>
for more details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
x &lt;- data.frame(species = letters[1:10],
                decimalLongitude = runif(100, -20, 30),
                decimalLatitude = runif(100, 35,60),
                countrycode = "RUS")

cc_coun(x, value = "flagged")#non-terrestrial records are flagged as wrong.

## End(Not run)

</code></pre>

<hr>
<h2 id='cc_dupl'>Identify Duplicated Records</h2><span id='topic+cc_dupl'></span>

<h3>Description</h3>

<p>Removes or flags duplicated records based on species name and coordinates, as well as
user-defined additional columns. True (specimen) duplicates or duplicates
from the same species can make up the bulk of records in a biological
collection database, but are undesirable for many analyses. Both can be
flagged with this function, the former given enough additional information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_dupl(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  additions = NULL,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_dupl_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_species">species</code></td>
<td>
<p>a character string. The column with the species name. Default
= &ldquo;species&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_additions">additions</code></td>
<td>
<p>a vector of character strings. Additional columns to be
included in the test for duplication. For example as below, collector name
and collector number.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_dupl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = sample(x = 0:10, size = 100, replace = TRUE), 
                decimalLatitude = sample(x = 0:10, size = 100, replace = TRUE),
                collector = "Bonpl",
                collector.number = c(1001, 354),
                collection = rep(c("K", "WAG","FR", "P", "S"), 20))

cc_dupl(x, value = "flagged")
cc_dupl(x, additions = c("collector", "collector.number"))

</code></pre>

<hr>
<h2 id='cc_equ'>Identify Records with Identical lat/lon</h2><span id='topic+cc_equ'></span>

<h3>Description</h3>

<p>Removes or flags records with equal latitude and longitude coordinates,
either exact or absolute. Equal coordinates can often indicate data entry
errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_equ(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  test = "absolute",
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_equ_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_equ_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_equ_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_equ_+3A_test">test</code></td>
<td>
<p>character string. Defines if coordinates are compared exactly
(&ldquo;identical&rdquo;) or on the absolute scale (i.e. -1 = 1,
&ldquo;absolute&rdquo;). Default is to &ldquo;absolute&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_equ_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_equ_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = runif(100, -180, 180), 
                decimalLatitude = runif(100, -90,90))

cc_equ(x)
cc_equ(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cc_gbif'>Identify Records Assigned to GBIF Headquarters</h2><span id='topic+cc_gbif'></span>

<h3>Description</h3>

<p>Removes or flags records within 0.5 degree radius around the GBIF headquarters in
Copenhagen, DK.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_gbif(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  buffer = 1000,
  geod = TRUE,
  verify = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_gbif_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_species">species</code></td>
<td>
<p>character string. The column with the species identity. Only
required if verify = TRUE.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_buffer">buffer</code></td>
<td>
<p>numerical. The buffer around the GBIF headquarters,
where records should be flagged as problematic. Units depend on geod. Default = 100 m.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_geod">geod</code></td>
<td>
<p>logical. If TRUE the radius is calculated
based on a sphere, buffer is in meters. If FALSE
the radius is calculated in degrees. Default = T.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_verify">verify</code></td>
<td>
<p>logical. If TRUE records are only flagged if they are the only
record in a given species flagged close to a given reference. If FALSE, the
distance is the only criterion</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_gbif_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not recommended if working with records from Denmark or the Copenhagen area.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = "A", 
                decimalLongitude = c(12.58, 12.58), 
                decimalLatitude = c(55.67, 30.00))
                
cc_gbif(x)
cc_gbif(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cc_inst'>Identify Records in the Vicinity of Biodiversity Institutions</h2><span id='topic+cc_inst'></span>

<h3>Description</h3>

<p>Removes or flags records assigned to the location of zoos, botanical gardens,
herbaria, universities and museums, based on a global database of ~10,000 such
biodiversity institutions. Coordinates from these locations can be related to
data-entry errors, false automated geo-reference or individuals in
captivity/horticulture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_inst(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  buffer = 100,
  geod = FALSE,
  ref = NULL,
  verify = FALSE,
  verify_mltpl = 10,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_inst_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_species">species</code></td>
<td>
<p>character string. The column with the species identity. Only
required if verify = TRUE.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_buffer">buffer</code></td>
<td>
<p>numerical. The buffer around each institution, where records
should be flagged as problematic, in decimal degrees.  Default = 100m.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_geod">geod</code></td>
<td>
<p>logical. If TRUE the radius around each capital is calculated
based on a sphere, buffer is in meters and independent of latitude. If
FALSE the radius is calculated assuming planar coordinates and varies
slightly with latitude. Default = TRUE.
See https://seethedatablog.wordpress.com/ for detail and credits.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_ref">ref</code></td>
<td>
<p>SpatVector (geometry: polygons). Providing the geographic
gazetteer. Can be any SpatVector (geometry: polygons), but the structure
must be identical to <code><a href="#topic+institutions">institutions</a></code>.  Default =
<code><a href="#topic+institutions">institutions</a></code></p>
</td></tr>
<tr><td><code id="cc_inst_+3A_verify">verify</code></td>
<td>
<p>logical. If TRUE, records close to institutions are only
flagged, if there are no other records of the same species in the greater
vicinity (a radius of buffer * verify_mltpl).</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_verify_mltpl">verify_mltpl</code></td>
<td>
<p>numerical. indicates the factor by which the radius for
verify exceeds the radius of the initial test. Default = 10, which might be
suitable if geod is TRUE, but might be too large otherwise.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_inst_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the buffer radius is in degrees, thus will differ slightly between
different latitudes.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10],
                decimalLongitude = c(runif(99, -180, 180), 37.577800),
                decimalLatitude = c(runif(99, -90,90), 55.710800))

#large buffer for demonstration, using geod = FALSE for shorter runtime
cc_inst(x, value = "flagged", buffer = 10, geod = FALSE)

## Not run: 
#' cc_inst(x, value = "flagged", buffer = 50000) #geod = T

## End(Not run)

</code></pre>

<hr>
<h2 id='cc_iucn'>Identify Records Outside Natural Ranges</h2><span id='topic+cc_iucn'></span>

<h3>Description</h3>

<p>Removes or flags records outside of the provided natural range polygon, on a per species basis. 
Expects one entry per species. See the example or 
<a href="https://www.iucnredlist.org/resources/spatial-data-download">https://www.iucnredlist.org/resources/spatial-data-download</a> for 
the required polygon structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_iucn(
  x,
  range,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  buffer = 0,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_iucn_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_range">range</code></td>
<td>
<p>a SpatVector of natural ranges for species in x. 
Must contain a column named as indicated by <code>species</code>. See details.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_species">species</code></td>
<td>
<p>a character string. The column with the species name. 
Default = &ldquo;species&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_buffer">buffer</code></td>
<td>
<p>numerical. The buffer around each species' range,
from where records should be flagged as problematic, in meters. Default = 0.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_iucn_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Download natural range maps in suitable format for amphibians, birds,
mammals and reptiles
from <a href="https://www.iucnredlist.org/resources/spatial-data-download">https://www.iucnredlist.org/resources/spatial-data-download</a>.
Note: the buffer radius is in degrees, thus will differ slightly between
different latitudes.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)

x &lt;- data.frame(species = c("A", "B"),
decimalLongitude = runif(100, -170, 170),
decimalLatitude = runif(100, -80,80))

range_species_A &lt;- cbind(c(-45,-45,-60,-60,-45), c(-10,-25,-25,-10,-10))
rangeA &lt;- terra::vect(range_species_A, "polygons")
range_species_B &lt;- cbind(c(15,15,32,32,15), c(10,-10,-10,10,10))
rangeB &lt;- terra::vect(range_species_B, "polygons")
range &lt;- terra::vect(list(rangeA, rangeB))
range$binomial &lt;- c("A", "B")

cc_iucn(x = x, range = range, buffer = 0)

</code></pre>

<hr>
<h2 id='cc_outl'>Identify Geographic Outliers in Species Distributions</h2><span id='topic+cc_outl'></span>

<h3>Description</h3>

<p>Removes out or flags records that are outliers in geographic space according
to the method defined via the <code>method</code> argument. Geographic outliers
often represent erroneous coordinates, for example due to data entry errors,
imprecise geo-references, individuals in horticulture/captivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_outl(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  method = "quantile",
  mltpl = 5,
  tdi = 1000,
  value = "clean",
  sampling_thresh = 0,
  verbose = TRUE,
  min_occs = 7,
  thinning = FALSE,
  thinning_res = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_outl_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_species">species</code></td>
<td>
<p>character string. The column with the species name. Default =
&ldquo;species&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_method">method</code></td>
<td>
<p>character string.  Defining the method for outlier selection.
See details. One of &ldquo;distance&rdquo;, &ldquo;quantile&rdquo;, &ldquo;mad&rdquo;.
Default = &ldquo;quantile&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_mltpl">mltpl</code></td>
<td>
<p>numeric. The multiplier of the interquartile range
(<code>method == 'quantile'</code>) or median absolute deviation (<code>method ==
'mad'</code>)to identify outliers. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_tdi">tdi</code></td>
<td>
<p>numeric.  The minimum absolute distance (<code>method ==
'distance'</code>) of a record to all other records of a species to be identified
as outlier, in km. See details. Default = 1000.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_sampling_thresh">sampling_thresh</code></td>
<td>
<p>numeric. Cut off threshold for the sampling
correction. Indicates the quantile of sampling in which outliers should be
ignored. For instance, if <code>sampling_thresh</code> == 0.25, records in the
25
(no sampling correction).</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_min_occs">min_occs</code></td>
<td>
<p>Minimum number of geographically unique datapoints needed for
a species to be tested. This is necessary for reliable outlier estimation.
Species with fewer than min_occs records will not be tested and the output
value will be 'TRUE'. Default is to 7. If <code>method == 'distance'</code>,
consider a lower threshold.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_thinning">thinning</code></td>
<td>
<p>forces a raster approximation for the distance calculation.
This is routinely used for species with more than 10,000 records for
computational reasons, but can be enforced for smaller datasets, which is
recommended when sampling is very uneven.</p>
</td></tr>
<tr><td><code id="cc_outl_+3A_thinning_res">thinning_res</code></td>
<td>
<p>The resolution for the spatial thinning in decimal
degrees. Default = 0.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for outlier identification depends on the <code>method</code> argument.
If &ldquo;quantile&rdquo;: a boxplot method is used and records are flagged as
outliers if their <em>mean</em> distance to all other records of the same
species is larger than mltpl * the interquartile range of the mean distance
of all records of this species. If &ldquo;mad&rdquo;: the median absolute
deviation is used. In this case a record is flagged as outlier, if the
<em>mean</em> distance to all other records of the same species is larger than
the median of the mean distance of all points plus/minus the mad of the mean
distances of all records of the species * mltpl. If &ldquo;distance&rdquo;:
records are flagged as outliers, if the <em>minimum</em> distance to the next
record of the species is &gt; <code>tdi</code>. For species with records from &gt; 10000
unique locations a random sample of 1000 records is used for the distance
matrix calculation. The test skips species with fewer than <code>min_occs</code>,
geographically unique records.
</p>
<p>The likelihood of occurrence records being erroneous outliers is linked to
the sampling effort in any given location. To account for this, the
sampling_cor option fetches the number of occurrence records available from
www.gbif.org, per country as a proxy of sampling effort. The outlier test
(the mean distance) for each records is than weighted by the log transformed
number of records per square kilometre in this country. See for
<a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13152">https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13152</a>
an example and further explanation of the outlier test.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10],
                decimalLongitude = runif(100, -180, 180),
                decimalLatitude = runif(100, -90,90))

cc_outl(x)
cc_outl(x, method = "quantile", value = "flagged")
cc_outl(x, method = "distance", value = "flagged", tdi = 10000)
cc_outl(x, method = "distance", value = "flagged", tdi = 1000)

</code></pre>

<hr>
<h2 id='cc_sea'>Identify Non-terrestrial Coordinates</h2><span id='topic+cc_sea'></span>

<h3>Description</h3>

<p>Removes or flags coordinates outside the reference landmass. Can be used to
restrict datasets to terrestrial taxa, or exclude records from the open
ocean, when depending on the reference (see details). Often records of
terrestrial taxa can be found in the open ocean, mostly due to switched
latitude and longitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_sea(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  ref = NULL,
  scale = 110,
  value = "clean",
  speedup = TRUE,
  verbose = TRUE,
  buffer = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_sea_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_ref">ref</code></td>
<td>
<p>SpatVector (geometry: polygons). Providing the geographic
gazetteer. Can be any SpatVector (geometry: polygons), but the structure
must be identical to rnaturalearth::ne_download(scale = 110, type = 'land',
category = 'physical', returnclass = 'sf'). Default =
rnaturalearth::ne_download(scale = 110, type = 'land', category =
'physical', returnclass = 'sf').</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_scale">scale</code></td>
<td>
<p>the scale of the default reference, as downloaded from natural
earth. Must be one of 10, 50, 110. Higher numbers equal higher detail.
Default = 110.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_speedup">speedup</code></td>
<td>
<p>logical. Using heuristic to speed up the analysis for large
data sets with many records per location.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="cc_sea_+3A_buffer">buffer</code></td>
<td>
<p>numeric. Units are in meters. If provided, a buffer is
created around the sea polygon, or ref provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some cases flagging records close of the coastline is not recommendable,
because of the low precision of the reference dataset, minor GPS imprecision
or because a dataset might include coast or marshland species. If you only
want to flag records in the open ocean, consider using a buffered landmass
reference, e.g.: <code><a href="#topic+buffland">buffland</a></code>.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = runif(10, -30, 30), 
                decimalLatitude = runif(10, -30, 30))
                
cc_sea(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cc_urb'>Identify Records Inside Urban Areas</h2><span id='topic+cc_urb'></span>

<h3>Description</h3>

<p>Removes or flags records from inside urban areas, based on a geographic
gazetteer. Often records from large databases span substantial time periods
(centuries) and old records might represent habitats which today are replaced
by city area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_urb(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  ref = NULL,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_urb_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_urb_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_urb_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_urb_+3A_ref">ref</code></td>
<td>
<p>a SpatVector. Providing the geographic gazetteer
with the urban areas. See details. By default
rnaturalearth::ne_download(scale = 'medium', type = 'urban_areas',
returnclass = &quot;sf&quot;). Can be any <code>SpatVector</code>, but the
structure must be identical to <code>rnaturalearth::ne_download()</code>.</p>
</td></tr>
<tr><td><code id="cc_urb_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_urb_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
x &lt;- data.frame(species = letters[1:10],
                decimalLongitude = runif(100, -180, 180),
                decimalLatitude = runif(100, -90,90))

cc_urb(x)
cc_urb(x, value = "flagged")

## End(Not run)

</code></pre>

<hr>
<h2 id='cc_val'>Identify Invalid lat/lon Coordinates</h2><span id='topic+cc_val'></span>

<h3>Description</h3>

<p>Removes or flags non-numeric and not available coordinates
as well as lat &gt;90, lat &lt;-90, lon &gt; 180 and lon &lt; -180 are flagged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_val(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_val_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_val_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_val_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_val_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_val_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test is obligatory before running any further tests of
CoordinateCleaner, as additional tests only run with valid coordinates.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_zero">cc_zero</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = c(runif(106, -180, 180), NA, "13W33'", "67,09", 305), 
                decimalLatitude = runif(110, -90,90))
                
cc_val(x)
cc_val(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cc_zero'>Identify Zero Coordinates</h2><span id='topic+cc_zero'></span>

<h3>Description</h3>

<p>Removes or flags records with either zero longitude or latitude and a radius
around the point at zero longitude and zero latitude. These problems are
often due to erroneous data-entry or geo-referencing and can lead to typical
patterns of high diversity around the equator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc_zero(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  buffer = 0.5,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cc_zero_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cc_zero_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_zero_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cc_zero_+3A_buffer">buffer</code></td>
<td>
<p>numerical. The buffer around the 0/0 point,
where records should be flagged as problematic, in decimal
degrees.  Default = 0.5.</p>
</td></tr>
<tr><td><code id="cc_zero_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cc_zero_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Coordinates: 
<code><a href="#topic+cc_aohi">cc_aohi</a>()</code>,
<code><a href="#topic+cc_cap">cc_cap</a>()</code>,
<code><a href="#topic+cc_cen">cc_cen</a>()</code>,
<code><a href="#topic+cc_coun">cc_coun</a>()</code>,
<code><a href="#topic+cc_dupl">cc_dupl</a>()</code>,
<code><a href="#topic+cc_equ">cc_equ</a>()</code>,
<code><a href="#topic+cc_gbif">cc_gbif</a>()</code>,
<code><a href="#topic+cc_inst">cc_inst</a>()</code>,
<code><a href="#topic+cc_iucn">cc_iucn</a>()</code>,
<code><a href="#topic+cc_outl">cc_outl</a>()</code>,
<code><a href="#topic+cc_sea">cc_sea</a>()</code>,
<code><a href="#topic+cc_urb">cc_urb</a>()</code>,
<code><a href="#topic+cc_val">cc_val</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- data.frame(species = "A", 
                decimalLongitude = c(0,34.84, 0, 33.98), 
                decimalLatitude = c(23.08, 0, 0, 15.98))
                
cc_zero(x)
cc_zero(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cd_ddmm'>Identify Datasets with a Degree Conversion Error</h2><span id='topic+cd_ddmm'></span>

<h3>Description</h3>

<p>This test flags datasets where a significant fraction of records has
been subject to a common degree minute to decimal degree conversion error,
where the degree sign is recognized as decimal delimiter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd_ddmm(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  ds = "dataset",
  pvalue = 0.025,
  diff = 1,
  mat_size = 1000,
  min_span = 2,
  value = "clean",
  verbose = TRUE,
  diagnostic = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cd_ddmm_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_ds">ds</code></td>
<td>
<p>a character string. The column with the dataset of each record. In
case <code>x</code> should be treated as a single dataset, identical for all
records.  Default = &ldquo;dataset&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_pvalue">pvalue</code></td>
<td>
<p>numeric. The p-value for the one-sided t-test to flag the test
as passed or not. Both ddmm.pvalue and diff must be met. Default = 0.025.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_diff">diff</code></td>
<td>
<p>numeric. The threshold difference for the ddmm test. Indicates
by which fraction the records with decimals below 0.6 must outnumber the
records with decimals above 0.6. Default = 1</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_mat_size">mat_size</code></td>
<td>
<p>numeric. The size of the matrix for the binomial test. Must
be changed in decimals (e.g. 100, 1000, 10000). Adapt to dataset size,
generally 100 is better for datasets &lt; 10000 records, 1000 is better for
datasets with 10000 - 1M records. Higher values also work reasonably well
for smaller datasets, therefore, default = 1000. For large datasets try
10000.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_min_span">min_span</code></td>
<td>
<p>numeric. The minimum geographic extent of datasets to be
tested. Default = 2.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="cd_ddmm_+3A_diagnostic">diagnostic</code></td>
<td>
<p>logical. If TRUE plots the analyses matrix for each
dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the degree sign is recognized as decimal delimiter during coordinate
conversion, no coordinate decimals above 0.59 (59') are possible. The test
here uses a binomial test to test if a significant proportion of records in
a dataset have been subject to this problem. The test is best adjusted via
the diff argument. The lower <code>diff</code>, the stricter the test. Also scales
with dataset size. Empirically, for datasets with &lt; 5,000 unique coordinate
records <code>diff = 0.1</code> has proven reasonable flagging most datasets with
&gt;25% problematic records and all dataset with &gt;50% problematic records.
For datasets between 5,000 and 100,000 geographic unique records <code>diff
= 0.01</code> is recommended, for datasets between 100,000 and 1 M records diff =
0.001, and so on.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
with summary statistics and flags for each dataset (&ldquo;dataset&rdquo;) or a
<code>data.frame</code> containing the records considered correct by the test
(&ldquo;clean&rdquo;) or a logical vector (&ldquo;flags&rdquo;), with TRUE = test passed and FALSE =
test failed/potentially problematic. Default =
&ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+cd_round">cd_round</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
clean &lt;- data.frame(species = letters[1:10], 
                decimalLongitude = runif(100, -180, 180), 
                decimalLatitude = runif(100, -90,90),
                dataset = "FR")
                
cd_ddmm(x = clean, value = "flagged")

#problematic dataset
lon &lt;- sample(0:180, size = 100, replace = TRUE) + runif(100, 0,0.59)
lat &lt;- sample(0:90, size = 100, replace = TRUE) + runif(100, 0,0.59)

prob &lt;-  data.frame(species = letters[1:10], 
                decimalLongitude = lon, 
                decimalLatitude = lat,
                dataset = "FR")
                
cd_ddmm(x = prob, value = "flagged")

</code></pre>

<hr>
<h2 id='cd_round'>Identify Datasets with Rasterized Coordinates</h2><span id='topic+cd_round'></span>

<h3>Description</h3>

<p>Flags datasets with periodicity patterns indicative of a rasterized
(lattice) collection scheme, as often obtain from e.g. atlas data. Using a
combination of autocorrelation and sliding-window outlier detection to
identify periodicity patterns in the data. See 
<a href="https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13152">https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13152</a>
for further details and 
a description of the algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cd_round(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  ds = "dataset",
  T1 = 7,
  reg_out_thresh = 2,
  reg_dist_min = 0.1,
  reg_dist_max = 2,
  min_unique_ds_size = 4,
  graphs = TRUE,
  test = "both",
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cd_round_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_ds">ds</code></td>
<td>
<p>a character string. The column with the dataset of each record. In
case <code>x</code> should be treated as a single dataset, identical for all
records.  Default = &ldquo;dataset&rdquo;.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_t1">T1</code></td>
<td>
<p>numeric.  The threshold for outlier detection in a in an
interquantile range based test. This is the major parameter to specify the
sensitivity of the test: lower values, equal higher detection rate. Values
between 7-11 are recommended. Default = 7.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_reg_out_thresh">reg_out_thresh</code></td>
<td>
<p>numeric. Threshold on the number of equal distances
between outlier points.  See details.  Default = 2.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_reg_dist_min">reg_dist_min</code></td>
<td>
<p>numeric.  The minimum detection distance between
outliers in degrees (the minimum resolution of grids that will be flagged).
Default = 0.1.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_reg_dist_max">reg_dist_max</code></td>
<td>
<p>numeric.  The maximum detection distance between
outliers in degrees (the maximum resolution of grids that will be flagged).
Default = 2.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_min_unique_ds_size">min_unique_ds_size</code></td>
<td>
<p>numeric.  The minimum number of unique locations
(values in the tested column) for datasets to be included in the test.
Default = 4.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_graphs">graphs</code></td>
<td>
<p>logical. If TRUE, diagnostic plots are produced.  Default =
TRUE.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_test">test</code></td>
<td>
<p>character string.  Indicates which column to test. Either
&ldquo;lat&rdquo; for latitude, &ldquo;lon&rdquo; for longitude, or &ldquo;both&rdquo; for
both.  In the latter case datasets are only flagged if both test are failed.
Default = &ldquo;both&rdquo;</p>
</td></tr>
<tr><td><code id="cd_round_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cd_round_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
with summary statistics and flags for each dataset (&ldquo;dataset&rdquo;) or a
<code>data.frame</code> containing the records considered correct by the test
(&ldquo;clean&rdquo;) or a logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE =
test failed/potentially problematic. Default =
&ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other Datasets: 
<code><a href="#topic+cd_ddmm">cd_ddmm</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#simulate bias grid, one degree resolution, 10% error on a 1000 records dataset
#simulate biased fraction of the data, grid resolution = 1 degree
#simulate non-biased fraction of the data
  bi &lt;- sample(3 + 0:5, size = 100, replace = TRUE)
  mu &lt;- runif(3, 0, 15)
  sig &lt;- runif(3, 0.1, 5)
  cl &lt;- rnorm(n = 900, mean = mu, sd = sig)
  lon &lt;- c(cl, bi)
  
  bi &lt;- sample(9:13, size = 100, replace = TRUE)
  mu &lt;- runif(3, 0, 15)
  sig &lt;- runif(3, 0.1, 5)
  cl &lt;- rnorm(n = 900, mean = mu, sd = sig)
  lat &lt;- c(cl, bi)
  
  #add biased data
  
  inp &lt;- data.frame(decimalLongitude = lon,
                    decimalLatitude = lat,
                    dataset = "test")
            
          
  #run test
  ## Not run: 
  cd_round(inp, value = "dataset")
  
## End(Not run)
  

</code></pre>

<hr>
<h2 id='cf_age'>Identify Fossils with Outlier Age</h2><span id='topic+cf_age'></span>

<h3>Description</h3>

<p>Removes or flags records that are temporal outliers based on
interquantile ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_age(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  min_age = "min_ma",
  max_age = "max_ma",
  taxon = "accepted_name",
  method = "quantile",
  size_thresh = 7,
  mltpl = 5,
  replicates = 5,
  flag_thresh = 0.5,
  uniq_loc = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cf_age_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records with taxon names, ages, 
and geographic coordinates.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
To identify unique records if <code>uniq_loc  = TRUE</code>.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;. To identify unique records if <code>uniq_loc  = T</code>.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_taxon">taxon</code></td>
<td>
<p>character string. The column with the taxon name. If
&ldquo;&rdquo;, searches for outliers over the entire dataset, otherwise per
specified taxon. Default = &ldquo;accepted_name&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_method">method</code></td>
<td>
<p>character string.  Defining the method for outlier
selection.  See details. Either &ldquo;quantile&rdquo; or &ldquo;mad&rdquo;.  Default
= &ldquo;quantile&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_size_thresh">size_thresh</code></td>
<td>
<p>numeric.  The minimum number of records needed for a
dataset to be tested. Default = 10.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_mltpl">mltpl</code></td>
<td>
<p>numeric. The multiplier of the interquartile range
(<code>method == 'quantile'</code>) or median absolute deviation (<code>method ==
'mad'</code>) to identify outliers. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_replicates">replicates</code></td>
<td>
<p>numeric. The number of replications for the distance
matrix calculation. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_flag_thresh">flag_thresh</code></td>
<td>
<p>numeric.  The fraction of passed replicates necessary to pass the test. 
See details. Default = 0.5.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_uniq_loc">uniq_loc</code></td>
<td>
<p>logical.  If TRUE only single records per location and time
point (and taxon if <code>taxon</code> != &quot;&quot;) are used for the outlier testing.
Default = T.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cf_age_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outlier detection is based on an interquantile range test. A temporal
distance matrix among all records is calculated based on a single point selected by random
between the minimum and maximum age for each record. The mean distance for
each point to all neighbours is calculated and the sum of these distances
is then tested against the interquantile range and flagged as an outlier if
<code class="reqn">x &gt; IQR(x) + q_75 * mltpl</code>. The test is replicated &lsquo;replicates&rsquo;
times, to account for dating uncertainty. Records are flagged as outliers
if they are flagged by a fraction of more than &lsquo;flag.thresh&rsquo;
replicates. Only datasets/taxa comprising more than &lsquo;size_thresh&rsquo;
records are tested. Distance are calculated as Euclidean distance.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other fossils: 
<code><a href="#topic+cf_equal">cf_equal</a>()</code>,
<code><a href="#topic+cf_outl">cf_outl</a>()</code>,
<code><a href="#topic+cf_range">cf_range</a>()</code>,
<code><a href="#topic+write_pyrate">write_pyrate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- c(runif(n = 11, min = 10, max = 25), 62.5)
x &lt;- data.frame(species = c(letters[1:10], rep("z", 2)),
                min_ma = minages,
                max_ma = c(minages[1:11] + runif(n = 11, min = 0, max = 5), 65))

cf_age(x, value = "flagged", taxon = "")

# unique locations only
x &lt;- data.frame(species = c(letters[1:10], rep("z", 2)),
                decimalLongitude = c(runif(n = 10, min = 4, max = 16), 75, 7),
                decimalLatitude = c(runif(n = 12, min = -5, max = 5)),
                min_ma = minages, 
                max_ma = c(minages[1:11] + runif(n = 11, min = 0, max = 5), 65))

cf_age(x, value = "flagged", taxon = "", uniq_loc = TRUE)

</code></pre>

<hr>
<h2 id='cf_equal'>Identify Fossils with equal min and max age</h2><span id='topic+cf_equal'></span>

<h3>Description</h3>

<p>Removes or flags records with equal minimum and maximum age.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_equal(
  x,
  min_age = "min_ma",
  max_age = "max_ma",
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cf_equal_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records with taxon names, ages, 
and geographic coordinates.</p>
</td></tr>
<tr><td><code id="cf_equal_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_equal_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_equal_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cf_equal_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other fossils: 
<code><a href="#topic+cf_age">cf_age</a>()</code>,
<code><a href="#topic+cf_outl">cf_outl</a>()</code>,
<code><a href="#topic+cf_range">cf_range</a>()</code>,
<code><a href="#topic+write_pyrate">write_pyrate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- runif(n = 10, min = 0.1, max = 25)
x &lt;- data.frame(species = letters[1:10], 
                min_ma = minages, 
                max_ma = minages + runif(n = 10, min = 0, max = 10))
x &lt;- rbind(x, data.frame(species = "z", 
                min_ma = 5, 
                max_ma = 5))
                
cf_equal(x, value = "flagged")

</code></pre>

<hr>
<h2 id='cf_outl'>Identify Outlier Records in Space and Time</h2><span id='topic+cf_outl'></span>

<h3>Description</h3>

<p>Removes or flags records of fossils that are spatio-temporal outliers based on
interquantile ranges. Records are flagged if they are either extreme in time
or space, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_outl(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  min_age = "min_ma",
  max_age = "max_ma",
  taxon = "accepted_name",
  method = "quantile",
  size_thresh = 7,
  mltpl = 5,
  replicates = 5,
  flag_thresh = 0.5,
  uniq_loc = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cf_outl_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records with taxon names, ages, 
and geographic coordinates.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
To identify unique records if <code>uniq_loc  = TRUE</code>.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;. To identify unique records if <code>uniq_loc  = T</code>.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_taxon">taxon</code></td>
<td>
<p>character string. The column with the taxon name. If
&ldquo;&rdquo;, searches for outliers over the entire dataset, otherwise per
specified taxon. Default = &ldquo;accepted_name&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_method">method</code></td>
<td>
<p>character string.  Defining the method for outlier
selection.  See details. Either &ldquo;quantile&rdquo; or &ldquo;mad&rdquo;.  Default
= &ldquo;quantile&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_size_thresh">size_thresh</code></td>
<td>
<p>numeric.  The minimum number of records needed for a
dataset to be tested. Default = 10.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_mltpl">mltpl</code></td>
<td>
<p>numeric. The multiplier of the interquartile range
(<code>method == 'quantile'</code>) or median absolute deviation (<code>method ==
'mad'</code>) to identify outliers. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_replicates">replicates</code></td>
<td>
<p>numeric. The number of replications for the distance
matrix calculation. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_flag_thresh">flag_thresh</code></td>
<td>
<p>numeric.  The fraction of passed replicates necessary to pass the test. 
See details. Default = 0.5.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_uniq_loc">uniq_loc</code></td>
<td>
<p>logical.  If TRUE only single records per location and time
point (and taxon if <code>taxon</code> != &quot;&quot;) are used for the outlier testing.
Default = T.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cf_outl_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The outlier detection is based on an interquantile range test. In a first
step a distance matrix of geographic distances among all records is
calculate. Subsequently a similar distance matrix of temporal distances
among all records is calculated based on a single point selected by random
between the minimum and maximum age for each record. The mean distance for
each point to all neighbours is calculated for both matrices and spatial and
temporal distances are scaled to the same range. The sum of these distanced
is then tested against the interquantile range and flagged as an outlier if
<code class="reqn">x &gt; IQR(x) + q_75 * mltpl</code>. The test is replicated &lsquo;replicates&rsquo;
times, to account for temporal uncertainty. Records are flagged as outliers
if they are flagged by a fraction of more than &lsquo;flag.thres&rsquo;
replicates. Only datasets/taxa comprising more than &lsquo;size_thresh&rsquo;
records are tested. Note that geographic distances are calculated as
geospheric distances for datasets (or taxa) with fewer than 10,000 records
and approximated as Euclidean distances for datasets/taxa with 10,000 to
25,000 records. Datasets/taxa comprising more than 25,000 records are
skipped.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other fossils: 
<code><a href="#topic+cf_age">cf_age</a>()</code>,
<code><a href="#topic+cf_equal">cf_equal</a>()</code>,
<code><a href="#topic+cf_range">cf_range</a>()</code>,
<code><a href="#topic+write_pyrate">write_pyrate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- c(runif(n = 11, min = 10, max = 25), 62.5)
x &lt;- data.frame(species = c(letters[1:10], rep("z", 2)),
                lng = c(runif(n = 10, min = 4, max = 16), 75, 7),
                lat = c(runif(n = 12, min = -5, max = 5)),
                min_ma = minages, 
                max_ma = c(minages[1:11] + runif(n = 11, min = 0, max = 5), 65))

cf_outl(x, value = "flagged", taxon = "")

</code></pre>

<hr>
<h2 id='cf_range'>Identify Fossils with Extreme Age Ranges</h2><span id='topic+cf_range'></span>

<h3>Description</h3>

<p>Removes or flags records with an unexpectedly large temporal range, based on a quantile
outlier test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cf_range(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  min_age = "min_ma",
  max_age = "max_ma",
  taxon = "accepted_name",
  method = "quantile",
  mltpl = 5,
  size_thresh = 7,
  max_range = 500,
  uniq_loc = FALSE,
  value = "clean",
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cf_range_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records with taxon names, ages, 
and geographic coordinates.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
To identify unique records if <code>uniq_loc  = TRUE</code>.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;. To identify unique records if <code>uniq_loc  = T</code>.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_taxon">taxon</code></td>
<td>
<p>character string. The column with the taxon name. If
&ldquo;&rdquo;, searches for outliers over the entire dataset, otherwise per
specified taxon. Default = &ldquo;accepted_name&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_method">method</code></td>
<td>
<p>character string.  Defining the method for outlier
selection.  See details. Either &ldquo;quantile&rdquo; or &ldquo;mad&rdquo;.  Default
= &ldquo;quantile&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_mltpl">mltpl</code></td>
<td>
<p>numeric. The multiplier of the interquartile range
(<code>method == 'quantile'</code>) or median absolute deviation (<code>method ==
'mad'</code>) to identify outliers. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_size_thresh">size_thresh</code></td>
<td>
<p>numeric.  The minimum number of records needed for a
dataset to be tested. Default = 10.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_max_range">max_range</code></td>
<td>
<p>numeric. A absolute maximum time interval between min age
and max age. Only relevant for <code>method</code> = &ldquo;time&rdquo;.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_uniq_loc">uniq_loc</code></td>
<td>
<p>logical.  If TRUE only single records per location and time
point (and taxon if <code>taxon</code> != &quot;&quot;) are used for the outlier testing.
Default = T.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_value">value</code></td>
<td>
<p>character string.  Defining the output value. See value.</p>
</td></tr>
<tr><td><code id="cf_range_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument, either a <code>data.frame</code>
containing the records considered correct by the test (&ldquo;clean&rdquo;) or a
logical vector (&ldquo;flagged&rdquo;), with TRUE = test passed and FALSE = test
failed/potentially problematic . Default = &ldquo;clean&rdquo;.
</p>


<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more
details and tutorials.
</p>


<h3>See Also</h3>

<p>Other fossils: 
<code><a href="#topic+cf_age">cf_age</a>()</code>,
<code><a href="#topic+cf_equal">cf_equal</a>()</code>,
<code><a href="#topic+cf_outl">cf_outl</a>()</code>,
<code><a href="#topic+write_pyrate">write_pyrate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- runif(n = 11, min = 0.1, max = 25)
x &lt;- data.frame(species = c(letters[1:10], "z"),
                lng = c(runif(n = 9, min = 4, max = 16), 75, 7),
                lat = c(runif(n = 11, min = -5, max = 5)),
                min_ma = minages, 
                max_ma = minages + c(runif(n = 10, min = 0, max = 5), 25))

cf_range(x, value = "flagged", taxon = "")

</code></pre>

<hr>
<h2 id='clean_coordinates'>Geographic Cleaning of Coordinates from Biologic Collections</h2><span id='topic+clean_coordinates'></span><span id='topic+summary.spatialvalid'></span>

<h3>Description</h3>

<p>Cleaning geographic coordinates by multiple empirical tests to flag
potentially erroneous coordinates, addressing issues common in biological
collection databases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_coordinates(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  species = "species",
  countries = NULL,
  tests = c("capitals", "centroids", "equal", "gbif", "institutions", "outliers", "seas",
    "zeros"),
  capitals_rad = 10000,
  centroids_rad = 1000,
  centroids_detail = "both",
  inst_rad = 100,
  outliers_method = "quantile",
  outliers_mtp = 5,
  outliers_td = 1000,
  outliers_size = 7,
  range_rad = 0,
  zeros_rad = 0.5,
  capitals_ref = NULL,
  centroids_ref = NULL,
  country_ref = NULL,
  country_refcol = "iso_a3",
  country_buffer = NULL,
  inst_ref = NULL,
  range_ref = NULL,
  seas_ref = NULL,
  seas_scale = 50,
  seas_buffer = NULL,
  urban_ref = NULL,
  aohi_rad = NULL,
  value = "spatialvalid",
  verbose = TRUE,
  report = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_coordinates_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_species">species</code></td>
<td>
<p>a character string. A vector of the same length as rows in x,
with the species identity for each record.  If NULL, <code>tests</code> must not
include the &quot;outliers&quot; or &quot;duplicates&quot; tests.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_countries">countries</code></td>
<td>
<p>a character string. The column with the country assignment
of each record in three letter ISO code. Default = &ldquo;countrycode&rdquo;. If
missing, the countries test is skipped.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_tests">tests</code></td>
<td>
<p>a vector of character strings, indicating which tests to run.
See details for all tests available. Default = c(&quot;capitals&quot;, &quot;centroids&quot;,
&quot;equal&quot;, &quot;gbif&quot;, &quot;institutions&quot;, &quot;outliers&quot;, &quot;seas&quot;, &quot;zeros&quot;)</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_capitals_rad">capitals_rad</code></td>
<td>
<p>numeric. The radius around capital coordinates in meters.
Default = 10000.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_centroids_rad">centroids_rad</code></td>
<td>
<p>numeric. The radius around centroid coordinates in
meters. Default = 1000.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_centroids_detail">centroids_detail</code></td>
<td>
<p>a <code>character string</code>. If set to &lsquo;country&rsquo;
only country (adm-0) centroids are tested, if set to &lsquo;provinces&rsquo;
only province (adm-1) centroids are tested.  Default = &lsquo;both&rsquo;.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_inst_rad">inst_rad</code></td>
<td>
<p>numeric. The radius around biodiversity institutions
coordinates in metres. Default = 100.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_outliers_method">outliers_method</code></td>
<td>
<p>The method used for outlier testing. See details.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_outliers_mtp">outliers_mtp</code></td>
<td>
<p>numeric. The multiplier for the interquartile range of
the outlier test.  If NULL <code>outliers.td</code> is used.  Default = 5.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_outliers_td">outliers_td</code></td>
<td>
<p>numeric.  The minimum distance of a record to all other
records of a species to be identified as outlier, in km. Default = 1000.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_outliers_size">outliers_size</code></td>
<td>
<p>numerical.  The minimum number of records in a dataset
to run the taxon-specific outlier test.  Default = 7.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_range_rad">range_rad</code></td>
<td>
<p>buffer around natural ranges. Default = 0.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_zeros_rad">zeros_rad</code></td>
<td>
<p>numeric. The radius around 0/0 in degrees. Default = 0.5.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_capitals_ref">capitals_ref</code></td>
<td>
<p>a <code>data.frame</code> with alternative reference data for
the country capitals test. If missing, the <code>countryref</code> dataset is
used. Alternatives must be identical in structure.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_centroids_ref">centroids_ref</code></td>
<td>
<p>a <code>data.frame</code> with alternative reference data for
the centroid test. If NULL, the <code>countryref</code> dataset is used.
Alternatives must be identical in structure.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_country_ref">country_ref</code></td>
<td>
<p>a <code>SpatVector</code> as alternative reference
for the countries test. If NULL, the
<code>rnaturalearth:ne_countries('medium', returnclass = "sf")</code> dataset is used.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_country_refcol">country_refcol</code></td>
<td>
<p>the column name in the reference dataset, containing
the relevant ISO codes for matching. Default is to &quot;iso_a3_eh&quot; which
referes to the ISO-3 codes in the reference dataset. See notes.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_country_buffer">country_buffer</code></td>
<td>
<p>numeric. Units are in meters. If provided, a buffer is
created around each country polygon.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_inst_ref">inst_ref</code></td>
<td>
<p>a <code>data.frame</code> with alternative reference data for the
biodiversity institution test. If NULL, the <code>institutions</code> dataset is
used.  Alternatives must be identical in structure.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_range_ref">range_ref</code></td>
<td>
<p>a <code>SpatVector</code> of species natural ranges.
Required to include the 'ranges' test. See <code><a href="#topic+cc_iucn">cc_iucn</a></code> for
details.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_seas_ref">seas_ref</code></td>
<td>
<p>a <code>SpatVector</code> as alternative reference
for the seas test. If NULL, the rnaturalearth::ne_download(scale = 110,
type = 'land', category = 'physical', returnclass = &quot;sf&quot;) dataset is used.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_seas_scale">seas_scale</code></td>
<td>
<p>The scale of the default landmass reference. Must be one of
10, 50, 110. Higher numbers equal higher detail. Default = 50.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_seas_buffer">seas_buffer</code></td>
<td>
<p>numeric. Units are in meters. If provided, a buffer is
created around sea polygon.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_urban_ref">urban_ref</code></td>
<td>
<p>a <code>SpatVector</code> as alternative reference
for the urban test. If NULL, the test is skipped. See details for a
reference gazetteers.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_aohi_rad">aohi_rad</code></td>
<td>
<p>numeric. The radius around aohi coordinates in
meters. Default = 1000.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_value">value</code></td>
<td>
<p>a character string defining the output value. See the value
section for details. one of &lsquo;spatialvalid&rsquo;, &lsquo;summary&rsquo;,
&lsquo;clean&rsquo;. Default = &lsquo;<code>spatialvalid</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="clean_coordinates_+3A_report">report</code></td>
<td>
<p>logical or character.  If TRUE a report file is written to the
working directory, summarizing the cleaning results. If a character, the
path to which the file should be written.  Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function needs all coordinates to be formally valid according to WGS84.
If the data contains invalid coordinates, the function will stop and return a
vector flagging the invalid records. TRUE = non-problematic coordinate, FALSE
= potentially problematic coordinates.
</p>

<ul>
<li><p> capitals tests a radius around adm-0 capitals. The
radius is <code>capitals_rad</code>.
</p>
</li>
<li><p> centroids tests a radius around country centroids.
The radius is <code>centroids_rad</code>.
</p>
</li>
<li><p> countries tests if coordinates are from the
country indicated in the country column.  <em>Switched off by default.</em>
</p>
</li>
<li><p> duplicates tests for duplicate records. This
checks for identical coordinates or if a species vector is provided for
identical coordinates within a species. All but the first records are flagged
as duplicates. <em>Switched off by default.</em>
</p>
</li>
<li><p> equal tests for equal absolute longitude and latitude.
</p>
</li>
<li><p> gbif tests a one-degree radius around the GBIF
headquarters in Copenhagen, Denmark.
</p>
</li>
<li><p> institutions tests a radius around known
biodiversity institutions from <code>instiutions</code>. The radius is
<code>inst_rad</code>.
</p>
</li>
<li><p> outliers tests each species for outlier records.
Depending on the <code>outliers_mtp</code> and <code>outliers.td</code> arguments either
flags records that are a minimum distance away from all other records of this
species (<code>outliers_td</code>) or records that are outside a multiple of the
interquartile range of minimum distances to the next neighbour of this
species (<code>outliers_mtp</code>). Three different methods are available for the
outlier test: &quot;If &ldquo;outlier&rdquo; a boxplot method is used and records are
flagged as outliers if their <em>mean</em> distance to all other records of the
same species is larger than mltpl * the interquartile range of the mean
distance of all records of this species. If &ldquo;mad&rdquo; the median absolute
deviation is used. In this case a record is flagged as outlier, if the
<em>mean</em> distance to all other records of the same species is larger than
the median of the mean distance of all points plus/minus the mad of the mean
distances of all records of the species * mltpl. If &ldquo;distance&rdquo; records
are flagged as outliers, if the <em>minimum</em> distance to the next record of
the species is &gt; <code>tdi</code>.
</p>
</li>
<li><p> ranges tests if records fall within provided natural range polygons on
a per species basis. See <code><a href="#topic+cc_iucn">cc_iucn</a></code> for details.
</p>
</li>
<li><p> seas tests if coordinates fall into the ocean.
</p>
</li>
<li><p> urban tests if coordinates are from urban areas.
<em>Switched off by default</em>
</p>
</li>
<li><p> validity checks if coordinates correspond to a lat/lon coordinate reference system.
This test is always on, since all records need to pass for any other test to
run.
</p>
</li>
<li><p> zeros tests for plain zeros, equal latitude and
longitude and a radius around the point 0/0. The radius is <code>zeros.rad</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>Depending on the output argument:
</p>

<dl>
<dt>&ldquo;spatialvalid&rdquo;</dt><dd><p>an object of class <code>spatialvalid</code> similar to x
with one column added for each test. TRUE = clean coordinate entry, FALSE = potentially
problematic coordinate entries.  The .summary column is FALSE if any test flagged
the respective coordinate.</p>
</dd>
<dt>&ldquo;flagged&rdquo;</dt><dd><p>a logical vector with the
same order as the input data summarizing the results of all test. TRUE =
clean coordinate, FALSE = potentially problematic (= at least one test
failed).</p>
</dd>
<dt>&ldquo;clean&rdquo;</dt><dd><p>a <code>data.frame</code> similar to x
with potentially problematic records removed</p>
</dd>
</dl>



<h3>Note</h3>

<p>Always tests for coordinate validity: non-numeric or missing
coordinates and coordinates exceeding the global extent (lon/lat, WGS84).
See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more details
and tutorials.
</p>
<p>The country_refcol argument allows to adapt the function to the
structure of alternative reference datasets. For instance, for
<code>rnaturalearth::ne_countries(scale = "small", returnclass = "sf")</code>, the default will fail,
but country_refcol = &quot;iso_a3&quot; will work.
</p>


<h3>See Also</h3>

<p>Other Wrapper functions: 
<code><a href="#topic+clean_dataset">clean_dataset</a>()</code>,
<code><a href="#topic+clean_fossils">clean_fossils</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

exmpl &lt;- data.frame(species = sample(letters, size = 250, replace = TRUE),
                    decimalLongitude = runif(250, min = 42, max = 51),
                    decimalLatitude = runif(250, min = -26, max = -11))

test &lt;- clean_coordinates(x = exmpl, 
                          tests = c("equal"))
                                    
## Not run: 
#run more tests
test &lt;- clean_coordinates(x = exmpl, 
                          tests = c("capitals", 
                          "centroids","equal", 
                          "gbif", "institutions", 
                          "outliers", "seas", 
                          "zeros"))

## End(Not run)
                                 
                                    
summary(test)

</code></pre>

<hr>
<h2 id='clean_dataset'>Coordinate Cleaning using Dataset Properties</h2><span id='topic+clean_dataset'></span>

<h3>Description</h3>

<p>Tests for problems associated with coordinate conversions and rounding,
based on dataset properties. Includes test to identify contributing datasets with
potential errors with converting ddmm to dd.dd, and
periodicity in the data decimals indicating rounding or a raster basis
linked to low coordinate precision. Specifically:
</p>

<ul>
<li><p> ddmm  tests for erroneous conversion from a degree
minute format (ddmm) to a decimal degree (dd.dd) format
</p>
</li>
<li><p> periodicity test for periodicity in the data,
which can indicate imprecise coordinates, due to rounding or rasterization.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>clean_dataset(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  ds = "dataset",
  tests = c("ddmm", "periodicity"),
  value = "dataset",
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_dataset_+3A_x">x</code></td>
<td>
<p>data.frame. Containing geographical coordinates and species names.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_ds">ds</code></td>
<td>
<p>a character string. The column with the dataset of each record. In
case <code>x</code> should be treated as a single dataset, identical for all
records. Default = &ldquo;dataset&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_tests">tests</code></td>
<td>
<p>a vector of character strings, indicating which tests to run.
See details for all tests available. Default = c(&quot;ddmm&quot;, &quot;periodicity&quot;)</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_value">value</code></td>
<td>
<p>a character string.  Defining the output value. See value.
Default = &ldquo;dataset&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="clean_dataset_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code><a href="#topic+cd_ddmm">cd_ddmm</a></code> and
<code><a href="#topic+cd_round">cd_round</a></code> to customize test sensitivity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These tests are based on the statistical distribution of coordinates and
their decimals within
datasets of geographic distribution records to identify datasets with
potential errors/biases. Three potential error sources can be identified.
The ddmm flag tests for the particular pattern that emerges if geographical
coordinates in a degree minute annotation are transferred into decimal
degrees, simply replacing the degree symbol with the decimal point. This
kind of problem has been observed by in older datasets first recorded on
paper using typewriters, where e.g. a floating point was used as symbol for
degrees. The function uses a binomial test to check if more records than
expected have decimals below 0.6 (which is the maximum that can be obtained
in minutes, as one degree has 60 minutes) and if the number of these records
is higher than those above 0.59 by a certain proportion. The periodicity
test uses rate estimation in a Poisson process to estimate if there is
periodicity in the decimals of a dataset (as would be expected by for
example rounding or data that was collected in a raster format) and if there
is an over proportional number of records with the decimal 0 (full degrees)
which indicates rounding and thus low precision. The default values are
empirically optimized by with GBIF data, but should probably be adapted.
</p>


<h3>Value</h3>

<p>Depending on the &lsquo;value&rsquo; argument:
</p>

<dl>
<dt>&ldquo;dataset&rdquo;</dt><dd><p>a <code>data.frame</code> with the
the test summary statistics for each dataset in <code>x</code></p>
</dd>
<dt>&ldquo;clean&rdquo;</dt><dd><p>a <code>data.frame</code> containing only
records from datasets in <code>x</code> that passed the tests</p>
</dd>
<dt>&ldquo;flagged&rdquo;</dt><dd><p>a logical vector of the same length as
rows in <code>x</code>, with TRUE = test passed and
FALSE = test failed/potentially problematic.</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more details
and tutorials.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cd_ddmm">cd_ddmm</a></code> <code><a href="#topic+cd_round">cd_round</a></code>
</p>
<p>Other Wrapper functions: 
<code><a href="#topic+clean_coordinates">clean_coordinates</a>()</code>,
<code><a href="#topic+clean_fossils">clean_fossils</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Create test dataset
clean &lt;- data.frame(dataset = rep("clean", 1000),
                    decimalLongitude = runif(min = -43, max = -40, n = 1000),
                    decimalLatitude = runif(min = -13, max = -10, n = 1000))
                    
bias.long &lt;- c(round(runif(min = -42, max = -40, n = 500), 1),
               round(runif(min = -42, max = -40, n = 300), 0),
               runif(min = -42, max = -40, n = 200))
bias.lat &lt;- c(round(runif(min = -12, max = -10, n = 500), 1),
              round(runif(min = -12, max = -10, n = 300), 0),
              runif(min = -12, max = -10, n = 200))
bias &lt;- data.frame(dataset = rep("biased", 1000),
                   decimalLongitude = bias.long,
                   decimalLatitude = bias.lat)
test &lt;- rbind(clean, bias)

## Not run:                   
#run clean_dataset
flags &lt;- clean_dataset(test)

#check problems
#clean
hist(test[test$dataset == rownames(flags[flags$summary,]), "decimalLongitude"])
#biased
hist(test[test$dataset == rownames(flags[!flags$summary,]), "decimalLongitude"])


## End(Not run)
</code></pre>

<hr>
<h2 id='clean_fossils'>Geographic and Temporal Cleaning of Records from Fossil Collections</h2><span id='topic+clean_fossils'></span>

<h3>Description</h3>

<p>Cleaning records by multiple empirical tests to flag potentially erroneous
coordinates and time-spans, addressing issues common in fossil collection
databases. Individual tests can be activated via the tests argument:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_fossils(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  min_age = "min_ma",
  max_age = "max_ma",
  taxon = "accepted_name",
  tests = c("agesequal", "centroids", "equal", "gbif", "institutions", "spatiotemp",
    "temprange", "validity", "zeros"),
  countries = NULL,
  centroids_rad = 0.05,
  centroids_detail = "both",
  inst_rad = 0.001,
  outliers_method = "quantile",
  outliers_threshold = 5,
  outliers_size = 7,
  outliers_replicates = 5,
  zeros_rad = 0.5,
  centroids_ref = NULL,
  country_ref = NULL,
  inst_ref = NULL,
  value = "spatialvalid",
  verbose = TRUE,
  report = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_fossils_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records, containing taxon names, ages,
and geographic coordinates..</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_taxon">taxon</code></td>
<td>
<p>character string. The column with the taxon name. If
&ldquo;&rdquo;, searches for outliers over the entire dataset, otherwise per
specified taxon. Default = &ldquo;accepted_name&rdquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_tests">tests</code></td>
<td>
<p>vector of character strings, indicating which tests to run.
See details for all tests available. Default = c(&quot;centroids&quot;,
&quot;equal&quot;, &quot;gbif&quot;, &quot;institutions&quot;, &quot;temprange&quot;, &quot;spatiotemp&quot;, &quot;agesequal&quot;, &quot;zeros&quot;)</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_countries">countries</code></td>
<td>
<p>a character string. The column with the country assignment
of each record in three letter ISO code. Default = &ldquo;countrycode&rdquo;. If
missing, the countries test is skipped.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_centroids_rad">centroids_rad</code></td>
<td>
<p>numeric. The radius around centroid coordinates in
meters. Default = 1000.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_centroids_detail">centroids_detail</code></td>
<td>
<p>a <code>character string</code>. If set to &lsquo;country&rsquo;
only country (adm-0) centroids are tested, if set to &lsquo;provinces&rsquo;
only province (adm-1) centroids are tested.  Default = &lsquo;both&rsquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_inst_rad">inst_rad</code></td>
<td>
<p>numeric. The radius around biodiversity institutions
coordinates in metres. Default = 100.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_outliers_method">outliers_method</code></td>
<td>
<p>The method used for outlier testing. See details.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_outliers_threshold">outliers_threshold</code></td>
<td>
<p>numerical.  The multiplier for the interquantile
range for outlier detection. The higher the number, the more conservative
the outlier tests.  See <code><a href="#topic+cf_outl">cf_outl</a></code> for details. Default = 3.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_outliers_size">outliers_size</code></td>
<td>
<p>numerical.  The minimum number of records in a dataset
to run the taxon-specific outlier test.  Default = 7.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_outliers_replicates">outliers_replicates</code></td>
<td>
<p>numeric. The number of replications for the
distance matrix calculation. See details.  Default = 5.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_zeros_rad">zeros_rad</code></td>
<td>
<p>numeric. The radius around 0/0 in degrees. Default = 0.5.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_centroids_ref">centroids_ref</code></td>
<td>
<p>a <code>data.frame</code> with alternative reference data for
the centroid test. If NULL, the <code>countryref</code> dataset is used.
Alternatives must be identical in structure.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_country_ref">country_ref</code></td>
<td>
<p>a <code>SpatVector</code> as alternative reference
for the countries test. If NULL, the
<code>rnaturalearth:ne_countries('medium', returnclass = "sf")</code> dataset is used.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_inst_ref">inst_ref</code></td>
<td>
<p>a <code>data.frame</code> with alternative reference data for the
biodiversity institution test. If NULL, the <code>institutions</code> dataset is
used.  Alternatives must be identical in structure.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_value">value</code></td>
<td>
<p>a character string defining the output value. See the value
section for details. one of &lsquo;spatialvalid&rsquo;, &lsquo;summary&rsquo;,
&lsquo;clean&rsquo;. Default = &lsquo;<code>spatialvalid</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_verbose">verbose</code></td>
<td>
<p>logical. If TRUE reports the name of the test and the number
of records flagged.</p>
</td></tr>
<tr><td><code id="clean_fossils_+3A_report">report</code></td>
<td>
<p>logical or character.  If TRUE a report file is written to the
working directory, summarizing the cleaning results. If a character, the
path to which the file should be written.  Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> agesequal tests for equal minimum and maximum age.
</p>
</li>
<li><p> centroids tests a radius around country centroids.
The radius is <code>centroids_rad</code>.
</p>
</li>
<li><p> countries tests if coordinates are from the
country indicated in the country column.  <em>Switched off by default.</em>
</p>
</li>
<li><p> equal tests for equal absolute longitude and latitude.
</p>
</li>
<li><p> gbif tests a one-degree radius around the GBIF
headquarters in Copenhagen, Denmark.
</p>
</li>
<li><p> institutions tests a radius around known
biodiversity institutions from <code>instiutions</code>. The radius is
<code>inst_rad</code>.
</p>
</li>
<li><p> spatiotemp test for records which are outlier in time and space. See below for details.
</p>
</li>
<li><p> temprange tests for records with unexpectedly large temporal ranges,
using a quantile-based outlier test.
</p>
</li>
<li><p> validity checks if coordinates correspond to a lat/lon coordinate reference system.
This test is always on, since all records need to pass for any other test to run.
</p>
</li>
<li><p> zeros tests for plain zeros, equal latitude and
longitude and a radius around the point 0/0. The radius is <code>zeros_rad</code>.
The outlier detection in &lsquo;spatiotemp&rsquo; is based on an interquantile range test. In a first
step a distance matrix of geographic distances among all records is
calculate. Subsequently a similar distance matrix of temporal distances
among all records is calculated based on a single point selected by random
between the minimum and maximum age for each record. The mean distance for
each point to all neighbours is calculated for both matrices and spatial and
temporal distances are scaled to the same range. The sum of these distanced
is then tested against the interquantile range and flagged as an outlier if
<code class="reqn">x &gt; IQR(x) + q_75 * mltpl</code>. The test is replicated &lsquo;replicates&rsquo;
times, to account for temporal uncertainty. Records are flagged as outliers
if they are flagged by a fraction of more than &lsquo;flag_thresh&rsquo;
replicates. Only datasets/taxa comprising more than &lsquo;size.thresh&rsquo;
records are tested. Note that geographic distances are calculated as
geospheric distances for datasets (or taxa) with fewer than 10,000 records
and approximated as Euclidean distances for datasets/taxa with 10,000 to
25,000 records. Datasets/taxa comprising more than 25,000 records are
skipped.
</p>
</li></ul>



<h3>Value</h3>

<p>Depending on the output argument:
</p>

<dl>
<dt>&ldquo;spatialvalid&rdquo;</dt><dd><p>an object of class <code>spatialvalid</code> similar to x
with one column added for each test. TRUE = clean coordinate entry, FALSE = potentially
problematic coordinate entries.  The .summary column is FALSE if any test flagged
the respective coordinate.</p>
</dd>
<dt>&ldquo;flagged&rdquo;</dt><dd><p>a logical vector with the
same order as the input data summarizing the results of all test. TRUE =
clean coordinate, FALSE = potentially problematic (= at least one test
failed).</p>
</dd>
<dt>&ldquo;clean&rdquo;</dt><dd><p>a <code>data.frame</code> similar to x
with potentially problematic records removed</p>
</dd>
</dl>



<h3>Note</h3>

<p>Always tests for coordinate validity: non-numeric or missing
coordinates and coordinates exceeding the global extent (lon/lat, WGS84).
</p>
<p>See <a href="https://ropensci.github.io/CoordinateCleaner/">https://ropensci.github.io/CoordinateCleaner/</a> for more details
and tutorials.
</p>


<h3>See Also</h3>

<p>Other Wrapper functions: 
<code><a href="#topic+clean_coordinates">clean_coordinates</a>()</code>,
<code><a href="#topic+clean_dataset">clean_dataset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- runif(250, 0, 65)
exmpl &lt;- data.frame(accepted_name = sample(letters, size = 250, replace = TRUE),
                    decimalLongitude = runif(250, min = 42, max = 51),
                    decimalLatitude = runif(250, min = -26, max = -11),
                    min_ma = minages,
                    max_ma = minages + runif(250, 0.1, 65))

test &lt;- clean_fossils(x = exmpl)

summary(test)

</code></pre>

<hr>
<h2 id='countryref'>Country Centroids and Country Capitals</h2><span id='topic+countryref'></span>

<h3>Description</h3>

<p>A <code>data.frame</code> with coordinates of country and province centroids and
country capitals as reference for the <code><a href="#topic+clean_coordinates">clean_coordinates</a></code>,
<code><a href="#topic+cc_cen">cc_cen</a></code> and <code><a href="#topic+cc_cap">cc_cap</a></code> functions. Coordinates are
based on the Central Intelligence Agency World Factbook
<a href="https://www.cia.gov/the-world-factbook/">https://www.cia.gov/the-world-factbook/</a>,
<a href="https://thematicmapping.org/downloads/world_borders.php">https://thematicmapping.org/downloads/world_borders.php</a> and geolocate
<a href="https://geo-locate.org">https://geo-locate.org</a>.
</p>


<h3>Format</h3>

<p>A data frame with 5,305 observations on 13 variables.
#' </p>
 
<dl>
<dt>iso3</dt><dd><p>ISO-3 code for each country, in case of provinces also referring to the country.</p>
</dd>
<dt>iso2</dt><dd><p>ISO-2 code for each country, in case of provinces also referring to the country.</p>
</dd> 
<dt>adm1_code</dt><dd><p>adm code for countries and provinces.</p>
</dd> 
<dt>name</dt><dd><p>a factor; name of the country or province.</p>
</dd> 
<dt>type</dt><dd><p>identifying if the entry refers to a country or province level.</p>
</dd> 
<dt>centroid.lon</dt><dd><p>Longitude of the country centroid.</p>
</dd>
<dt>centroid.lat</dt><dd><p>Latitude of the country centroid.</p>
</dd>
<dt>capital</dt><dd><p>Name of the country capital, empty for provinces.</p>
</dd>
<dt>capital.lon</dt><dd><p>Longitude of the country capital.</p>
</dd>
<dt>capital.lat</dt><dd><p>Latitude of the country capital.</p>
</dd>
<dt>area_sqkm</dt><dd><p>The area of the country or province.</p>
</dd>
<dt>uncertaintyRadiusMeters</dt><dd><p>The uncertainty of the country centroid.</p>
</dd>
<dt>source</dt><dd><p>The data source. Currently only available for <a href="https://geo-locate.org">https://geo-locate.org</a></p>
</dd></dl>



<h3>Source</h3>

<p>CENTRAL INTELLIGENCE AGENCY (2014) <em>The World Factbook</em>,
Washington, DC.
</p>
<p><a href="https://www.cia.gov/the-world-factbook/">https://www.cia.gov/the-world-factbook/</a>
<a href="https://thematicmapping.org/downloads/world_borders.php">https://thematicmapping.org/downloads/world_borders.php</a>
<a href="https://geo-locate.org">https://geo-locate.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(countryref)
head(countryref)
</code></pre>

<hr>
<h2 id='institutions'>Global Locations of Biodiversity Institutions</h2><span id='topic+institutions'></span>

<h3>Description</h3>

<p>A global gazetteer for biodiversity institutions from various sources,
including zoos, museums, botanical gardens, GBIF contributors, herbaria,
university collections.
</p>


<h3>Format</h3>

<p>A data frame with 12170 observations on 12 variables.
</p>


<h3>Source</h3>

<p>Compiled from various sources: </p>
 <ul>
<li><p> Global Biodiversity
Information Facility <a href="https://www.gbif.org/">https://www.gbif.org/</a> </p>
</li>
<li><p> Wikipedia
<a href="https://www.wikipedia.org/">https://www.wikipedia.org/</a> </p>
</li>
<li><p> Geonames <a href="https://www.geonames.org/">https://www.geonames.org/</a> </p>
</li>
<li><p> The Global
Registry of Biodiversity Repositories </p>
</li>
<li><p> Index
Herbariorum <a href="https://sweetgum.nybg.org/science/ih/">https://sweetgum.nybg.org/science/ih/</a>
</p>
</li>
<li><p> Botanic Gardens Conservation International <a href="https://www.bgci.org/">https://www.bgci.org/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(institutions)
str(institutions)

</code></pre>

<hr>
<h2 id='is.spatialvalid'>Check spatialvalid object</h2><span id='topic+is.spatialvalid'></span>

<h3>Description</h3>

<p>Test if its argument is a spatialvalid object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.spatialvalid(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.spatialvalid_+3A_x">x</code></td>
<td>
<p>the object to be tested</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns <code>TRUE</code> if its argument is a spatialvalid
</p>

<hr>
<h2 id='pbdb_example'>Example data from the Paleobiologydatabase</h2><span id='topic+pbdb_example'></span>

<h3>Description</h3>

<p>A dataset of 5000 flowering plant fossil occurrences as example for data of the paleobiology Database, downloaded using the paleobioDB packages as specified in the vignette &ldquo;Cleaning_PBDB_fossils_with_CoordinateCleaner&rdquo;.
</p>


<h3>Format</h3>

<p>A data frame with 5000 observations on 36 variables.
</p>


<h3>Source</h3>

 
<ul>
<li><p> The Paleobiology database <a href="https://paleobiodb.org/">https://paleobiodb.org/</a> 
</p>
</li>
<li><p> Sara Varela, Javier Gonzalez Hernandez and Luciano Fabris Sgarbi (2016). 
paleobioDB: Download and Process Data from the Paleobiology Database. 
R package version 0.5.0. <a href="https://CRAN.R-project.org/package=paleobioDB">https://CRAN.R-project.org/package=paleobioDB</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(institutions)
str(institutions)

</code></pre>

<hr>
<h2 id='plot.spatialvalid'>Plot Method for Class Spatialvalid</h2><span id='topic+plot.spatialvalid'></span>

<h3>Description</h3>

<p>A set of plots to explore objects of the class <code>spatialvalid</code>. A plot
to visualize the flags from clean_coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatialvalid'
plot(
  x,
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  bgmap = NULL,
  clean = TRUE,
  details = FALSE,
  pts_size = 1,
  font_size = 10,
  zoom_f = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.spatialvalid_+3A_x">x</code></td>
<td>
<p>an object of the class <code>spatialvalid</code> as from
<code><a href="#topic+clean_coordinates">clean_coordinates</a></code>.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_lon">lon</code></td>
<td>
<p>character string. The column with the longitude coordinates.
Default = &ldquo;decimalLongitude&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_lat">lat</code></td>
<td>
<p>character string. The column with the latitude coordinates.
Default = &ldquo;decimalLatitude&rdquo;.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_bgmap">bgmap</code></td>
<td>
<p>an object of the class <code>SpatVector</code> or <code>sf</code> used as
background map. Default = ggplot::borders()</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_clean">clean</code></td>
<td>
<p>logical.  If TRUE, non-flagged coordinates are included in the
map.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_details">details</code></td>
<td>
<p>logical. If TRUE, occurrences are color-coded by the type of
flag.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_pts_size">pts_size</code></td>
<td>
<p>numeric. The point size for the plot.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_font_size">font_size</code></td>
<td>
<p>numeric. The font size for the legend and axes</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_zoom_f">zoom_f</code></td>
<td>
<p>numeric. the fraction by which to expand the plotting area 
from the occurrence records. Increase, if countries do not show 
up on the background map.</p>
</td></tr>
<tr><td><code id="plot.spatialvalid_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the records flagged as potentially erroneous by
<code><a href="#topic+clean_coordinates">clean_coordinates</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clean_coordinates">clean_coordinates</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

exmpl &lt;- data.frame(species = sample(letters, size = 250, replace = TRUE),
                    decimalLongitude = runif(250, min = 42, max = 51),
                    decimalLatitude = runif(250, min = -26, max = -11))

test &lt;- clean_coordinates(exmpl, species = "species", 
                          tests = c("sea", "gbif", "zeros"),
                          verbose = FALSE)

summary(test)
plot(test)
</code></pre>

<hr>
<h2 id='write_pyrate'>Create Input Files for PyRate</h2><span id='topic+write_pyrate'></span>

<h3>Description</h3>

<p>Creates the input necessary to run Pyrate, based on a data.frame with fossil
ages (as derived e.g. from clean_fossils) and a vector of the
extinction status for each sample. Creates files in the working directory!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pyrate(
  x,
  status,
  fname,
  taxon = "accepted_name",
  min_age = "min_ma",
  max_age = "max_ma",
  trait = NULL,
  path = getwd(),
  replicates = 1,
  cutoff = NULL,
  random = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write_pyrate_+3A_x">x</code></td>
<td>
<p>data.frame. Containing fossil records with taxon names, ages, 
and geographic coordinates.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_status">status</code></td>
<td>
<p>a vector of character strings of length <code>nrow(x)</code>.
Indicating for each record &ldquo;extinct&rdquo; or &ldquo;extant&rdquo;.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_fname">fname</code></td>
<td>
<p>a character string. The prefix to use for the output files.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_taxon">taxon</code></td>
<td>
<p>character string. The column with the taxon name. 
Default = &ldquo;accepted_name&rdquo;.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_min_age">min_age</code></td>
<td>
<p>character string. The column with the minimum age. Default
= &ldquo;min_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_max_age">max_age</code></td>
<td>
<p>character string. The column with the maximum age. Default
= &ldquo;max_ma&rdquo;.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_trait">trait</code></td>
<td>
<p>a numeric vector of length <code>nrow(x)</code>. Indicating trait
values for each record. Optional.  Default = NULL.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_path">path</code></td>
<td>
<p>a character string. giving the absolute path to write the output
files. Default is the working directory.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_replicates">replicates</code></td>
<td>
<p>a numerical. The number of replicates for the randomized
age generation. See details. Default = 1.</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_cutoff">cutoff</code></td>
<td>
<p>a numerical. Specify a threshold to exclude fossil occurrences
with a high temporal uncertainty, i.e. with a wide temporal range between
min_age and max_age. Examples: cutoff=NULL (default; all occurrences are
kept in the data set) cutoff=5 (all occurrences with a temporal range of 5
Myr or higher are excluded from the data set)</p>
</td></tr>
<tr><td><code id="write_pyrate_+3A_random">random</code></td>
<td>
<p>logical. Specify whether to take a random age (between MinT
and MaxT) for each occurrence or the midpoint age. Note that this option
defaults to TRUE if several replicates are generated (i.e. replicates &gt; 1).
Examples: random = TRUE (default) random = FALSE (use midpoint ages)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The replicate option allows the user to generate several replicates of the
data set in a single input file, each time re-drawing the ages of the
occurrences at random from uniform distributions with boundaries MinT and
MaxT. The replicates can be analysed in different runs (see PyRate command
-j) and combining the results of these replicates is a way to account for
the uncertainty of the true ages of the fossil occurrences. Examples:
replicates=1 (default, generates 1 data set), replicates=10 (generates 10
random replicates of the data set).
</p>


<h3>Value</h3>

<p>PyRate input files in the working directory.
</p>


<h3>Note</h3>

<p>See <a href="https://github.com/dsilvestro/PyRate/wiki">https://github.com/dsilvestro/PyRate/wiki</a> for more details
and tutorials on PyRate and PyRate input.
</p>


<h3>See Also</h3>

<p>Other fossils: 
<code><a href="#topic+cf_age">cf_age</a>()</code>,
<code><a href="#topic+cf_equal">cf_equal</a>()</code>,
<code><a href="#topic+cf_outl">cf_outl</a>()</code>,
<code><a href="#topic+cf_range">cf_range</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
minages &lt;- runif(250, 0, 65)
exmpl &lt;- data.frame(accepted_name = sample(letters, size = 250, replace = TRUE),
                    lng = runif(250, min = 42, max = 51),
                    lat = runif(250, min = -26, max = -11),
                    min_ma = minages,
                    max_ma = minages + runif(250, 0.1, 65))

#a vector with the status for each record, 
#make sure species are only classified as either extinct or extant, 
#otherwise the function will drop an error

status &lt;- sample(c("extinct", "extant"), size = nrow(exmpl), replace = TRUE)

#or from a list of species
status &lt;- sample(c("extinct", "extant"), size = length(letters), replace = TRUE)
names(status) &lt;- letters
status &lt;- status[exmpl$accepted_name]

## Not run: 
write_pyrate(x = exmpl,fname = "test", status = status)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
