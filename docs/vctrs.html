<!DOCTYPE html><html><head><title>Help for package vctrs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vctrs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%0%'><p>Default value for empty vectors</p></a></li>
<li><a href='#as-is'><p>AsIs S3 class</p></a></li>
<li><a href='#data_frame'><p>Construct a data frame</p></a></li>
<li><a href='#df_list'><p>Collect columns for data frame construction</p></a></li>
<li><a href='#df_ptype2'><p>Coercion between two data frames</p></a></li>
<li><a href='#faq-compatibility-types'><p>FAQ - How is the compatibility of vector types decided?</p></a></li>
<li><a href='#faq-error-incompatible-attributes'><p>FAQ - Error/Warning: Some attributes are incompatible</p></a></li>
<li><a href='#faq-error-scalar-type'><p>FAQ - Error: Input must be a vector</p></a></li>
<li><a href='#fields'><p>Tools for accessing the fields of a record.</p></a></li>
<li><a href='#howto-faq-coercion'><p>FAQ - How to implement ptype2 and cast methods?</p></a></li>
<li><a href='#howto-faq-coercion-data-frame'><p>FAQ - How to implement ptype2 and cast methods? (Data frames)</p></a></li>
<li><a href='#howto-faq-fix-scalar-type-error'><p>FAQ - Why isn't my class treated as a vector?</p></a></li>
<li><a href='#internal-faq-matches-algorithm'><p>Internal FAQ - Implementation of <code>vec_locate_matches()</code></p></a></li>
<li><a href='#internal-faq-ptype2-identity'><p>Internal FAQ - <code>vec_ptype2()</code>, <code>NULL</code>, and unspecified vectors</p></a></li>
<li><a href='#list_drop_empty'><p>Drop empty elements from a list</p></a></li>
<li><a href='#list_of'><p><code>list_of</code> S3 class for homogenous lists</p></a></li>
<li><a href='#maybe_lossy_cast'><p>Lossy cast error</p></a></li>
<li><a href='#missing'><p>Missing values</p></a></li>
<li><a href='#name_spec'><p>Name specifications</p></a></li>
<li><a href='#new_data_frame'><p>Assemble attributes for data frame construction</p></a></li>
<li><a href='#new_date'><p>Date, date-time, and duration S3 classes</p></a></li>
<li><a href='#new_factor'><p>Factor/ordered factor S3 class</p></a></li>
<li><a href='#new_list_of'><p>Create list_of subclass</p></a></li>
<li><a href='#new_partial'><p>Partial type</p></a></li>
<li><a href='#new_rcrd'><p>rcrd (record) S3 class</p></a></li>
<li><a href='#new_vctr'><p>vctr (vector) S3 class</p></a></li>
<li><a href='#obj_is_list'><p>List checks</p></a></li>
<li><a href='#obj_print'><p><code>print()</code> and <code>str()</code> generics.</p></a></li>
<li><a href='#order-radix'><p>Order and sort vectors</p></a></li>
<li><a href='#partial_factor'><p>Partially specify a factor</p></a></li>
<li><a href='#partial_frame'><p>Partially specify columns of a data frame</p></a></li>
<li><a href='#reference-faq-compatibility'><p>FAQ - Is my class compatible with vctrs?</p></a></li>
<li><a href='#runs'><p>Runs</p></a></li>
<li><a href='#s3_register'><p>Register a method for a suggested dependency</p></a></li>
<li><a href='#table'><p>Table S3 class</p></a></li>
<li><a href='#theory-faq-coercion'><p>FAQ - How does coercion work in vctrs?</p></a></li>
<li><a href='#theory-faq-recycling'><p>FAQ - How does recycling work in vctrs and the tidyverse?</p></a></li>
<li><a href='#unspecified'><p>A 1d vector of unspecified type</p></a></li>
<li><a href='#vctrs-conditions'><p>Custom conditions for vctrs package</p></a></li>
<li><a href='#vctrs-data-frame'><p>vctrs methods for data frames</p></a></li>
<li><a href='#vctrs-package'><p>vctrs: Vector Helpers</p></a></li>
<li><a href='#vec_arith'><p>Arithmetic operations</p></a></li>
<li><a href='#vec_as_index'><p>Convert to an index vector</p></a></li>
<li><a href='#vec_as_location'><p>Create a vector of locations</p></a></li>
<li><a href='#vec_as_names'><p>Retrieve and repair names</p></a></li>
<li><a href='#vec_as_names_legacy'><p>Repair names with legacy method</p></a></li>
<li><a href='#vec_as_subscript'><p>Convert to a base subscript type</p></a></li>
<li><a href='#vec_assert'><p>Assert an argument has known prototype and/or size</p></a></li>
<li><a href='#vec_bind'><p>Combine many data frames into one data frame</p></a></li>
<li><a href='#vec_c'><p>Combine many vectors into one vector</p></a></li>
<li><a href='#vec_cast'><p>Cast a vector to a specified type</p></a></li>
<li><a href='#vec_cbind_frame_ptype'><p>Frame prototype</p></a></li>
<li><a href='#vec_chop'><p>Chopping</p></a></li>
<li><a href='#vec_compare'><p>Compare two vectors</p></a></li>
<li><a href='#vec_count'><p>Count unique values in a vector</p></a></li>
<li><a href='#vec_data'><p>Extract underlying data</p></a></li>
<li><a href='#vec_default_cast'><p>Default cast and ptype2 methods</p></a></li>
<li><a href='#vec_detect_complete'><p>Complete</p></a></li>
<li><a href='#vec_duplicate'><p>Find duplicated values</p></a></li>
<li><a href='#vec_empty'><p>Is a vector empty</p></a></li>
<li><a href='#vec_equal'><p>Equality</p></a></li>
<li><a href='#vec_equal_na'><p>Missing values</p></a></li>
<li><a href='#vec_expand_grid'><p>Create a data frame from all combinations of the inputs</p></a></li>
<li><a href='#vec_fill_missing'><p>Fill in missing values with the previous or following value</p></a></li>
<li><a href='#vec_group'><p>Identify groups</p></a></li>
<li><a href='#vec_init'><p>Initialize a vector</p></a></li>
<li><a href='#vec_interleave'><p>Interleave many vectors into one vector</p></a></li>
<li><a href='#vec_is_list'><p>List checks</p></a></li>
<li><a href='#vec_locate_matches'><p>Locate observations matching specified conditions</p></a></li>
<li><a href='#vec_locate_sorted_groups'><p>Locate sorted groups</p></a></li>
<li><a href='#vec_match'><p>Find matching observations across vectors</p></a></li>
<li><a href='#vec_math'><p>Mathematical operations</p></a></li>
<li><a href='#vec_names'><p>Get or set the names of a vector</p></a></li>
<li><a href='#vec_order'><p>Order and sort vectors</p></a></li>
<li><a href='#vec_proxy'><p>Proxy and restore</p></a></li>
<li><a href='#vec_proxy_compare'><p>Comparison and order proxy</p></a></li>
<li><a href='#vec_proxy_equal'><p>Equality proxy</p></a></li>
<li><a href='#vec_ptype'><p>Find the prototype of a set of vectors</p></a></li>
<li><a href='#vec_ptype_full'><p>Vector type as a string</p></a></li>
<li><a href='#vec_ptype_full.integer64'><p>64 bit integers</p></a></li>
<li><a href='#vec_ptype2.logical'><p>Find the common type for a pair of vectors</p></a></li>
<li><a href='#vec_rank'><p>Compute ranks</p></a></li>
<li><a href='#vec_recycle'><p>Vector recycling</p></a></li>
<li><a href='#vec_repeat'><p>Expand the length of a vector</p></a></li>
<li><a href='#vec_seq_along'><p>Useful sequences</p></a></li>
<li><a href='#vec_size'><p>Number of observations</p></a></li>
<li><a href='#vec_slice'><p>Get or set observations in a vector</p></a></li>
<li><a href='#vec_split'><p>Split a vector into groups</p></a></li>
<li><a href='#vec_type'><p>Deprecated type functions</p></a></li>
<li><a href='#vec_unchop'><p>Chopping</p></a></li>
<li><a href='#vec_unique'><p>Find and count unique values</p></a></li>
<li><a href='#vec-rep'><p>Repeat a vector</p></a></li>
<li><a href='#vec-set'><p>Set operations</p></a></li>
<li><a href='#vector-checks'><p>Vector checks</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Vector Helpers</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Defines new notions of prototype and size that are used to
    provide tools for consistent and well-founded type-coercion and
    size-recycling, and are in turn connected to ideas of type- and
    size-stability useful for analysing function interfaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vctrs.r-lib.org/">https://vctrs.r-lib.org/</a>, <a href="https://github.com/r-lib/vctrs">https://github.com/r-lib/vctrs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/vctrs/issues">https://github.com/r-lib/vctrs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.4.0), glue, lifecycle (&ge; 1.0.3), rlang (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit64, covr, crayon, dplyr (&ge; 0.8.5), generics, knitr,
pillar (&ge; 1.4.4), pkgdown (&ge; 2.0.1), rmarkdown, testthat (&ge;
3.0.0), tibble (&ge; 3.1.3), waldo (&ge; 0.2.0), withr, xml2,
zeallot</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 16:27:12 UTC; davis</td>
</tr>
<tr>
<td>Author:</td>
<td>Hadley Wickham [aut],
  Lionel Henry [aut],
  Davis Vaughan [aut, cre],
  data.table team [cph] (Radix sort based on data.table's forder() and
    their contribution to R's order()),
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Davis Vaughan &lt;davis@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+250+25'>Default value for empty vectors</h2><span id='topic++250+25'></span>

<h3>Description</h3>

<p>Use this inline operator when you need to provide a default value for
empty (as defined by <code><a href="#topic+vec_is_empty">vec_is_empty()</a></code>) vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %0% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B250+2B25_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="+2B250+2B25_+3A_y">y</code></td>
<td>
<p>Value to use if <code>x</code> is empty. To preserve type-stability, should
be the same type as <code>x</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>1:10 %0% 5
integer() %0% 5
</code></pre>

<hr>
<h2 id='as-is'>AsIs S3 class</h2><span id='topic+as-is'></span><span id='topic+vec_ptype2.AsIs'></span>

<h3>Description</h3>

<p>These functions help the base AsIs class fit into the vctrs type system
by providing coercion and casting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AsIs'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")
</code></pre>

<hr>
<h2 id='data_frame'>Construct a data frame</h2><span id='topic+data_frame'></span>

<h3>Description</h3>

<p><code>data_frame()</code> constructs a data frame. It is similar to
<code><a href="base.html#topic+data.frame">base::data.frame()</a></code>, but there are a few notable differences that make it
more in line with vctrs principles. The Properties section outlines these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_frame(
  ...,
  .size = NULL,
  .name_repair = c("check_unique", "unique", "universal", "minimal", "unique_quiet",
    "universal_quiet"),
  .error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_frame_+3A_...">...</code></td>
<td>
<p>Vectors to become columns in the data frame. When inputs are
named, those names are used for column names.</p>
</td></tr>
<tr><td><code id="data_frame_+3A_.size">.size</code></td>
<td>
<p>The number of rows in the data frame. If <code>NULL</code>, this will
be computed as the common size of the inputs.</p>
</td></tr>
<tr><td><code id="data_frame_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"check_unique"</code>, <code>"unique"</code>, <code>"universal"</code>,
<code>"minimal"</code>, <code>"unique_quiet"</code>, or <code>"universal_quiet"</code>. See <code><a href="#topic+vec_as_names">vec_as_names()</a></code>
for the meaning of these options.</p>
</td></tr>
<tr><td><code id="data_frame_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no column names are supplied, <code>""</code> will be used as a default name for all
columns. This is applied before name repair occurs, so the default name
repair of <code>"check_unique"</code> will error if any unnamed inputs are supplied and
<code>"unique"</code> (or <code>"unique_quiet"</code>) will repair the empty string column names
appropriately. If the column names don't matter, use a <code>"minimal"</code> name
repair for convenience and performance.
</p>


<h3>Properties</h3>


<ul>
<li><p> Inputs are <a href="#topic+theory-faq-recycling">recycled</a> to a common size with
<code><a href="#topic+vec_recycle_common">vec_recycle_common()</a></code>.
</p>
</li>
<li><p> With the exception of data frames, inputs are not modified in any way.
Character vectors are never converted to factors, and lists are stored
as-is for easy creation of list-columns.
</p>
</li>
<li><p> Unnamed data frame inputs are automatically unpacked. Named data frame
inputs are stored unmodified as data frame columns.
</p>
</li>
<li> <p><code>NULL</code> inputs are completely ignored.
</p>
</li>
<li><p> The dots are dynamic, allowing for splicing of lists with <code style="white-space: pre;">&#8288;!!!&#8288;</code> and
unquoting.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+df_list">df_list()</a></code> for safely creating a data frame's underlying data structure from
individual columns. <code><a href="#topic+new_data_frame">new_data_frame()</a></code> for constructing the actual data
frame from that underlying data structure. Together, these can be useful
for developers when creating new data frame subclasses supporting
standard evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_frame(x = 1, y = 2)

# Inputs are recycled using tidyverse recycling rules
data_frame(x = 1, y = 1:3)

# Strings are never converted to factors
class(data_frame(x = "foo")$x)

# List columns can be easily created
df &lt;- data_frame(x = list(1:2, 2, 3:4), y = 3:1)

# However, the base print method is suboptimal for displaying them,
# so it is recommended to convert them to tibble
if (rlang::is_installed("tibble")) {
  tibble::as_tibble(df)
}

# Named data frame inputs create data frame columns
df &lt;- data_frame(x = data_frame(y = 1:2, z = "a"))

# The `x` column itself is another data frame
df$x

# Again, it is recommended to convert these to tibbles for a better
# print method
if (rlang::is_installed("tibble")) {
  tibble::as_tibble(df)
}

# Unnamed data frame input is automatically unpacked
data_frame(x = 1, data_frame(y = 1:2, z = "a"))
</code></pre>

<hr>
<h2 id='df_list'>Collect columns for data frame construction</h2><span id='topic+df_list'></span>

<h3>Description</h3>

<p><code>df_list()</code> constructs the data structure underlying a data
frame, a named list of equal-length vectors. It is often used in
combination with <code><a href="#topic+new_data_frame">new_data_frame()</a></code> to safely and consistently create
a helper function for data frame subclasses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_list(
  ...,
  .size = NULL,
  .unpack = TRUE,
  .name_repair = c("check_unique", "unique", "universal", "minimal", "unique_quiet",
    "universal_quiet"),
  .error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_list_+3A_...">...</code></td>
<td>
<p>Vectors of equal-length. When inputs are named, those names
are used for names of the resulting list.</p>
</td></tr>
<tr><td><code id="df_list_+3A_.size">.size</code></td>
<td>
<p>The common size of vectors supplied in <code>...</code>. If <code>NULL</code>, this
will be computed as the common size of the inputs.</p>
</td></tr>
<tr><td><code id="df_list_+3A_.unpack">.unpack</code></td>
<td>
<p>Should unnamed data frame inputs be unpacked? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="df_list_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"check_unique"</code>, <code>"unique"</code>, <code>"universal"</code>,
<code>"minimal"</code>, <code>"unique_quiet"</code>, or <code>"universal_quiet"</code>. See <code><a href="#topic+vec_as_names">vec_as_names()</a></code>
for the meaning of these options.</p>
</td></tr>
<tr><td><code id="df_list_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Properties</h3>


<ul>
<li><p> Inputs are <a href="#topic+theory-faq-recycling">recycled</a> to a common size with
<code><a href="#topic+vec_recycle_common">vec_recycle_common()</a></code>.
</p>
</li>
<li><p> With the exception of data frames, inputs are not modified in any way.
Character vectors are never converted to factors, and lists are stored
as-is for easy creation of list-columns.
</p>
</li>
<li><p> Unnamed data frame inputs are automatically unpacked. Named data frame
inputs are stored unmodified as data frame columns.
</p>
</li>
<li> <p><code>NULL</code> inputs are completely ignored.
</p>
</li>
<li><p> The dots are dynamic, allowing for splicing of lists with <code style="white-space: pre;">&#8288;!!!&#8288;</code> and
unquoting.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+new_data_frame">new_data_frame()</a></code> for constructing data frame subclasses from a validated
input. <code><a href="#topic+data_frame">data_frame()</a></code> for a fast data frame creation helper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># `new_data_frame()` can be used to create custom data frame constructors
new_fancy_df &lt;- function(x = list(), n = NULL, ..., class = NULL) {
  new_data_frame(x, n = n, ..., class = c(class, "fancy_df"))
}

# Combine this constructor with `df_list()` to create a safe,
# consistent helper function for your data frame subclass
fancy_df &lt;- function(...) {
  data &lt;- df_list(...)
  new_fancy_df(data)
}

df &lt;- fancy_df(x = 1)
class(df)
</code></pre>

<hr>
<h2 id='df_ptype2'>Coercion between two data frames</h2><span id='topic+df_ptype2'></span><span id='topic+df_cast'></span><span id='topic+tib_ptype2'></span><span id='topic+tib_cast'></span>

<h3>Description</h3>

<p><code>df_ptype2()</code> and <code>df_cast()</code> are the two functions you need to
call from <code>vec_ptype2()</code> and <code>vec_cast()</code> methods for data frame
subclasses. See <a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a>.
Their main job is to determine the common type of two data frames,
adding and coercing columns as needed, or throwing an incompatible
type error when the columns are not compatible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_ptype2(x, y, ..., x_arg = "", y_arg = "", call = caller_env())

df_cast(x, to, ..., x_arg = "", to_arg = "", call = caller_env())

tib_ptype2(x, y, ..., x_arg = "", y_arg = "", call = caller_env())

tib_cast(x, to, ..., x_arg = "", to_arg = "", call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_ptype2_+3A_x">x</code>, <code id="df_ptype2_+3A_y">y</code>, <code id="df_ptype2_+3A_to">to</code></td>
<td>
<p>Subclasses of data frame.</p>
</td></tr>
<tr><td><code id="df_ptype2_+3A_...">...</code></td>
<td>
<p>If you call <code>df_ptype2()</code> or <code>df_cast()</code> from a
<code>vec_ptype2()</code> or <code>vec_cast()</code> method, you must forward the dots
passed to your method on to <code>df_ptype2()</code> or <code>df_cast()</code>.</p>
</td></tr>
<tr><td><code id="df_ptype2_+3A_x_arg">x_arg</code>, <code id="df_ptype2_+3A_y_arg">y_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>y</code>. These are used
in error messages to inform the user about the locations of
incompatible types (see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="df_ptype2_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="df_ptype2_+3A_to_arg">to_arg</code></td>
<td>
<p>Argument name <code>to</code> used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> When <code>x</code> and <code>y</code> are not compatible, an error of class
<code>vctrs_error_incompatible_type</code> is thrown.
</p>
</li>
<li><p> When <code>x</code> and <code>y</code> are compatible, <code>df_ptype2()</code> returns the common
type as a bare data frame. <code>tib_ptype2()</code> returns the common type
as a bare tibble.
</p>
</li></ul>


<hr>
<h2 id='faq-compatibility-types'>FAQ - How is the compatibility of vector types decided?</h2><span id='topic+faq-compatibility-types'></span>

<h3>Description</h3>

<p>Two vectors are <strong>compatible</strong> when you can safely:
</p>

<ul>
<li><p> Combine them into one larger vector.
</p>
</li>
<li><p> Assign values from one of the vectors into the other vector.
</p>
</li></ul>

<p>Examples of compatible types are integer and double vectors. On the
other hand, integer and character vectors are not compatible.
</p>


<h3>Common type of multiple vectors</h3>

<p>There are two possible outcomes when multiple vectors of different types
are combined into a larger vector:
</p>

<ul>
<li><p> An incompatible type error is thrown because some of the types are not
compatible:
</p>
<div class="sourceCode r"><pre>df1 &lt;- data.frame(x = 1:3)
df2 &lt;- data.frame(x = "foo")
dplyr::bind_rows(df1, df2)
#&gt; Error in `dplyr::bind_rows()`:
#&gt; ! Can't combine `..1$x` &lt;integer&gt; and `..2$x` &lt;character&gt;.
</pre></div>
</li>
<li><p> The vectors are combined into a vector that has the common type of all
inputs. In this example, the common type of integer and logical is
integer:
</p>
<div class="sourceCode r"><pre>df1 &lt;- data.frame(x = 1:3)
df2 &lt;- data.frame(x = FALSE)
dplyr::bind_rows(df1, df2)
#&gt;   x
#&gt; 1 1
#&gt; 2 2
#&gt; 3 3
#&gt; 4 0
</pre></div>
</li></ul>

<p>In general, the common type is the <em>richer</em> type, in other words the
type that can represent the most values. Logical vectors are at the
bottom of the hierarchy of numeric types because they can only represent
two values (not counting missing values). Then come integer vectors, and
then doubles. Here is the vctrs type hierarchy for the fundamental
vectors:
</p>
<p><img src="../help/figures/coerce.png" alt="coerce.png" />
</p>


<h3>Type conversion and lossy cast errors</h3>

<p>Type compatibility does not necessarily mean that you can <strong>convert</strong>
one type to the other type. That’s because one of the types might
support a larger set of possible values. For instance, integer and
double vectors are compatible, but double vectors can’t be converted to
integer if they contain fractional values.
</p>
<p>When vctrs can’t convert a vector because the target type is not as rich
as the source type, it throws a lossy cast error. Assigning a fractional
number to an integer vector is a typical example of a lossy cast error:
</p>
<div class="sourceCode r"><pre>int_vector &lt;- 1:3
vec_assign(int_vector, 2, 0.001)
#&gt; Error in `vec_assign()`:
#&gt; ! Can't convert from &lt;double&gt; to &lt;integer&gt; due to loss of precision.
#&gt; * Locations: 1
</pre></div>


<h3>How to make two vector classes compatible?</h3>

<p>If you encounter two vector types that you think should be compatible,
they might need to implement coercion methods. Reach out to the
author(s) of the classes and ask them if it makes sense for their
classes to be compatible.
</p>
<p>These developer FAQ items provide guides for implementing coercion
methods:
</p>

<ul>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li></ul>


<hr>
<h2 id='faq-error-incompatible-attributes'>FAQ - Error/Warning: Some attributes are incompatible</h2><span id='topic+faq-error-incompatible-attributes'></span>

<h3>Description</h3>

<p>This error occurs when <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code> or <code><a href="#topic+vec_cast">vec_cast()</a></code> are supplied
vectors of the same classes with different attributes. In this
case, vctrs doesn't know how to combine the inputs.
</p>
<p>To fix this error, the maintainer of the class should implement
self-to-self coercion methods for <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code> and <code><a href="#topic+vec_cast">vec_cast()</a></code>.
</p>


<h3>Implementing coercion methods</h3>


<ul>
<li><p> For an overview of how these generics work and their roles in vctrs,
see <code><a href="#topic+theory-faq-coercion">?theory-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li>
<li><p> For a tutorial about implementing vctrs classes from scratch, see
<code>vignette("s3-vector")</code>.
</p>
</li></ul>


<hr>
<h2 id='faq-error-scalar-type'>FAQ - Error: Input must be a vector</h2><span id='topic+faq-error-scalar-type'></span>

<h3>Description</h3>

<p>This error occurs when a function expects a vector and gets a scalar
object instead. This commonly happens when some code attempts to assign
a scalar object as column in a data frame:
</p>
<div class="sourceCode r"><pre>fn &lt;- function() NULL
tibble::tibble(x = fn)
#&gt; Error in `tibble::tibble()`:
#&gt; ! All columns in a tibble must be vectors.
#&gt; x Column `x` is a function.

fit &lt;- lm(1:3 ~ 1)
tibble::tibble(x = fit)
#&gt; Error in `tibble::tibble()`:
#&gt; ! All columns in a tibble must be vectors.
#&gt; x Column `x` is a `lm` object.
</pre></div>


<h3>Vectorness in base R and in the tidyverse</h3>

<p>In base R, almost everything is a vector or behaves like a vector. In
the tidyverse we have chosen to be a bit stricter about what is
considered a vector. The main question we ask ourselves to decide on the
vectorness of a type is whether it makes sense to include that object as
a column in a data frame.
</p>
<p>The main difference is that S3 lists are considered vectors by base R
but in the tidyverse that’s not the case by default:
</p>
<div class="sourceCode r"><pre>fit &lt;- lm(1:3 ~ 1)

typeof(fit)
#&gt; [1] "list"
class(fit)
#&gt; [1] "lm"

# S3 lists can be subset like a vector using base R:
fit[c(1, 4)]
#&gt; $coefficients
#&gt; (Intercept) 
#&gt;           2 
#&gt; 
#&gt; $rank
#&gt; [1] 1

# But not in vctrs
vctrs::vec_slice(fit, c(1, 4))
#&gt; Error in `vctrs::vec_slice()`:
#&gt; ! `x` must be a vector, not a &lt;lm&gt; object.
</pre></div>
<p>Defused function calls are another (more esoteric) example:
</p>
<div class="sourceCode r"><pre>call &lt;- quote(foo(bar = TRUE, baz = FALSE))
call
#&gt; foo(bar = TRUE, baz = FALSE)

# They can be subset like a vector using base R:
call[1:2]
#&gt; foo(bar = TRUE)
lapply(call, function(x) x)
#&gt; [[1]]
#&gt; foo
#&gt; 
#&gt; $bar
#&gt; [1] TRUE
#&gt; 
#&gt; $baz
#&gt; [1] FALSE

# But not with vctrs:
vctrs::vec_slice(call, 1:2)
#&gt; Error in `vctrs::vec_slice()`:
#&gt; ! `x` must be a vector, not a call.
</pre></div>


<h3>I get a scalar type error but I think this is a bug</h3>

<p>It’s possible the author of the class needs to do some work to declare
their class a vector. Consider reaching out to the author. We have
written a <a href="#topic+howto-faq-fix-scalar-type-error">developer FAQ page</a> to
help them fix the issue.
</p>

<hr>
<h2 id='fields'>Tools for accessing the fields of a record.</h2><span id='topic+fields'></span><span id='topic+n_fields'></span><span id='topic+field'></span><span id='topic+field+3C-'></span>

<h3>Description</h3>

<p>A <a href="#topic+rcrd">rcrd</a> behaves like a vector, so <code>length()</code>, <code>names()</code>, and <code>$</code> can
not provide access to the fields of the underlying list. These helpers do:
<code>fields()</code> is equivalent to <code>names()</code>; <code>n_fields()</code> is equivalent to
<code>length()</code>; <code>field()</code> is equivalent to <code>$</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fields(x)

n_fields(x)

field(x, i)

field(x, i) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fields_+3A_x">x</code></td>
<td>
<p>A <a href="#topic+rcrd">rcrd</a>, i.e. a list of equal length vectors with unique names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_rcrd(list(x = 1:3, y = 3:1, z = letters[1:3]))
n_fields(x)
fields(x)

field(x, "y")
field(x, "y") &lt;- runif(3)
field(x, "y")
</code></pre>

<hr>
<h2 id='howto-faq-coercion'>FAQ - How to implement ptype2 and cast methods?</h2><span id='topic+howto-faq-coercion'></span>

<h3>Description</h3>

<p>This guide illustrates how to implement <code>vec_ptype2()</code> and <code>vec_cast()</code>
methods for existing classes. Related topics:
</p>

<ul>
<li><p> For an overview of how these generics work and their roles in vctrs,
see <code><a href="#topic+theory-faq-coercion">?theory-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li>
<li><p> For a tutorial about implementing vctrs classes from scratch, see
<code>vignette("s3-vector")</code>
</p>
</li></ul>



<h4>The natural number class</h4>

<p>We’ll illustrate how to implement coercion methods with a simple class
that represents natural numbers. In this scenario we have an existing
class that already features a constructor and methods for <code>print()</code> and
subset.
</p>
<div class="sourceCode r"><pre>#' @export
new_natural &lt;- function(x) {
  if (is.numeric(x) || is.logical(x)) {
    stopifnot(is_whole(x))
    x &lt;- as.integer(x)
  } else {
    stop("Can't construct natural from unknown type.")
  }
  structure(x, class = "my_natural")
}
is_whole &lt;- function(x) {
  all(x %% 1 == 0 | is.na(x))
}

#' @export
print.my_natural &lt;- function(x, ...) {
  cat("&lt;natural&gt;\n")
  x &lt;- unclass(x)
  NextMethod()
}
#' @export
`[.my_natural` &lt;- function(x, i, ...) {
  new_natural(NextMethod())
}
</pre></div>
<div class="sourceCode r"><pre>new_natural(1:3)
#&gt; &lt;natural&gt;
#&gt; [1] 1 2 3
new_natural(c(1, NA))
#&gt; &lt;natural&gt;
#&gt; [1]  1 NA
</pre></div>



<h4>Roxygen workflow</h4>

<p>To implement methods for generics, first import the generics in your
namespace and redocument:
</p>
<div class="sourceCode r"><pre>#' @importFrom vctrs vec_ptype2 vec_cast
NULL
</pre></div>
<p>Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
</p>
<p>Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with <code>s3_register()</code>.
</p>



<h4>Implementing <code>vec_ptype2()</code></h4>



<h5>The self-self method</h5>

<p>The first method to implement is the one that signals that your class is
compatible with itself:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_natural.my_natural &lt;- function(x, y, ...) {
  x
}

vec_ptype2(new_natural(1), new_natural(2:3))
#&gt; &lt;natural&gt;
#&gt; integer(0)
</pre></div>
<p><code>vec_ptype2()</code> implements a fallback to try and be compatible with
simple classes, so it may seem that you don’t need to implement the
self-self coercion method. However, you must implement it explicitly
because this is how vctrs knows that a class that is implementing vctrs
methods (for instance this disable fallbacks to <code>base::c()</code>). Also, it
makes your class a bit more efficient.
</p>



<h5>The parent and children methods</h5>

<p>Our natural number class is conceptually a parent of <code style="white-space: pre;">&#8288;&lt;logical&gt;&#8288;</code> and a
child of <code style="white-space: pre;">&#8288;&lt;integer&gt;&#8288;</code>, but the class is not compatible with logical,
integer, or double vectors yet:
</p>
<div class="sourceCode r"><pre>vec_ptype2(TRUE, new_natural(2:3))
#&gt; Error:
#&gt; ! Can't combine `TRUE` &lt;logical&gt; and `new_natural(2:3)` &lt;my_natural&gt;.

vec_ptype2(new_natural(1), 2:3)
#&gt; Error:
#&gt; ! Can't combine `new_natural(1)` &lt;my_natural&gt; and `2:3` &lt;integer&gt;.
</pre></div>
<p>We’ll specify the twin methods for each of these classes, returning the
richer class in each case.
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_natural.logical &lt;- function(x, y, ...) {
  # The order of the classes in the method name follows the order of
  # the arguments in the function signature, so `x` is the natural
  # number and `y` is the logical
  x
}
#' @export
vec_ptype2.logical.my_natural &lt;- function(x, y, ...) {
  # In this case `y` is the richer natural number
  y
}
</pre></div>
<p>Between a natural number and an integer, the latter is the richer class:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_natural.integer &lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.integer.my_natural &lt;- function(x, y, ...) {
  x
}
</pre></div>
<p>We no longer get common type errors for logical and integer:
</p>
<div class="sourceCode r"><pre>vec_ptype2(TRUE, new_natural(2:3))
#&gt; &lt;natural&gt;
#&gt; integer(0)

vec_ptype2(new_natural(1), 2:3)
#&gt; integer(0)
</pre></div>
<p>We are not done yet. Pairwise coercion methods must be implemented for
all the connected nodes in the coercion hierarchy, which include double
vectors further up. The coercion methods for grand-parent types must be
implemented separately:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_natural.double &lt;- function(x, y, ...) {
  y
}
#' @export
vec_ptype2.double.my_natural &lt;- function(x, y, ...) {
  x
}
</pre></div>



<h5>Incompatible attributes</h5>

<p>Most of the time, inputs are incompatible because they have different
classes for which no <code>vec_ptype2()</code> method is implemented. More rarely,
inputs could be incompatible because of their attributes. In that case
incompatibility is signalled by calling <code>stop_incompatible_type()</code>.
</p>
<p>In the following example, we implement a self-self ptype2 method for a
hypothetical subclass of <code style="white-space: pre;">&#8288;&lt;factor&gt;&#8288;</code> that has stricter combination
semantics. The method throws an error when the levels of the two factors
are not compatible.
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_strict_factor.my_strict_factor &lt;- function(x, y, ..., x_arg = "", y_arg = "") {
  if (!setequal(levels(x), levels(y))) {
    stop_incompatible_type(x, y, x_arg = x_arg, y_arg = y_arg)
  }

  x
}
</pre></div>
<p>Note how the methods need to take <code>x_arg</code> and <code>y_arg</code> parameters and
pass them on to <code>stop_incompatible_type()</code>. These argument tags help
create more informative error messages when the common type
determination is for a column of a data frame. They are part of the
generic signature but can usually be left out if not used.
</p>




<h4>Implementing <code>vec_cast()</code></h4>

<p>Corresponding <code>vec_cast()</code> methods must be implemented for all
<code>vec_ptype2()</code> methods. The general pattern is to convert the argument
<code>x</code> to the type of <code>to</code>. The methods should validate the values in <code>x</code>
and make sure they conform to the values of <code>to</code>.
</p>
<p>Please note that for historical reasons, the order of the classes in the
method name is in reverse order of the arguments in the function
signature. The first class represents <code>to</code>, whereas the second class
represents <code>x</code>.
</p>
<p>The self-self method is easy in this case, it just returns the target
input:
</p>
<div class="sourceCode r"><pre>#' @export
vec_cast.my_natural.my_natural &lt;- function(x, to, ...) {
  x
}
</pre></div>
<p>The other types need to be validated. We perform input validation in the
<code>new_natural()</code> constructor, so that’s a good fit for our <code>vec_cast()</code>
implementations.
</p>
<div class="sourceCode r"><pre>#' @export
vec_cast.my_natural.logical &lt;- function(x, to, ...) {
  # The order of the classes in the method name is in reverse order
  # of the arguments in the function signature, so `to` is the natural
  # number and `x` is the logical
  new_natural(x)
}
vec_cast.my_natural.integer &lt;- function(x, to, ...) {
  new_natural(x)
}
vec_cast.my_natural.double &lt;- function(x, to, ...) {
  new_natural(x)
}
</pre></div>
<p>With these methods, vctrs is now able to combine logical and natural
vectors. It properly returns the richer type of the two, a natural
vector:
</p>
<div class="sourceCode r"><pre>vec_c(TRUE, new_natural(1), FALSE)
#&gt; &lt;natural&gt;
#&gt; [1] 1 1 0
</pre></div>
<p>Because we haven’t implemented conversions <em>from</em> natural, it still
doesn’t know how to combine natural with the richer integer and double
types:
</p>
<div class="sourceCode r"><pre>vec_c(new_natural(1), 10L)
#&gt; Error in `vec_c()`:
#&gt; ! Can't convert `..1` &lt;my_natural&gt; to &lt;integer&gt;.
vec_c(1.5, new_natural(1))
#&gt; Error in `vec_c()`:
#&gt; ! Can't convert `..2` &lt;my_natural&gt; to &lt;double&gt;.
</pre></div>
<p>This is quick work which completes the implementation of coercion
methods for vctrs:
</p>
<div class="sourceCode r"><pre>#' @export
vec_cast.logical.my_natural &lt;- function(x, to, ...) {
  # In this case `to` is the logical and `x` is the natural number
  attributes(x) &lt;- NULL
  as.logical(x)
}
#' @export
vec_cast.integer.my_natural &lt;- function(x, to, ...) {
  attributes(x) &lt;- NULL
  as.integer(x)
}
#' @export
vec_cast.double.my_natural &lt;- function(x, to, ...) {
  attributes(x) &lt;- NULL
  as.double(x)
}
</pre></div>
<p>And we now get the expected combinations.
</p>
<div class="sourceCode r"><pre>vec_c(new_natural(1), 10L)
#&gt; [1]  1 10

vec_c(1.5, new_natural(1))
#&gt; [1] 1.5 1.0
</pre></div>


<hr>
<h2 id='howto-faq-coercion-data-frame'>FAQ - How to implement ptype2 and cast methods? (Data frames)</h2><span id='topic+howto-faq-coercion-data-frame'></span>

<h3>Description</h3>

<p>This guide provides a practical recipe for implementing <code>vec_ptype2()</code>
and <code>vec_cast()</code> methods for coercions of data frame subclasses. Related
topics:
</p>

<ul>
<li><p> For an overview of the coercion mechanism in vctrs, see
<code><a href="#topic+theory-faq-coercion">?theory-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li></ul>

<p>Coercion of data frames occurs when different data frame classes are
combined in some way. The two main methods of combination are currently
row-binding with <code><a href="#topic+vec_rbind">vec_rbind()</a></code> and col-binding with
<code><a href="#topic+vec_cbind">vec_cbind()</a></code> (which are in turn used by a number of
dplyr and tidyr functions). These functions take multiple data frame
inputs and automatically coerce them to their common type.
</p>
<p>vctrs is generally strict about the kind of automatic coercions that are
performed when combining inputs. In the case of data frames we have
decided to be a bit less strict for convenience. Instead of throwing an
incompatible type error, we fall back to a base data frame or a tibble
if we don’t know how to combine two data frame subclasses. It is still a
good idea to specify the proper coercion behaviour for your data frame
subclasses as soon as possible.
</p>
<p>We will see two examples in this guide. The first example is about a
data frame subclass that has no particular attributes to manage. In the
second example, we implement coercion methods for a tibble subclass that
includes potentially incompatible attributes.
</p>


<h4>Roxygen workflow</h4>

<p>To implement methods for generics, first import the generics in your
namespace and redocument:
</p>
<div class="sourceCode r"><pre>#' @importFrom vctrs vec_ptype2 vec_cast
NULL
</pre></div>
<p>Note that for each batches of methods that you add to your package, you
need to export the methods and redocument immediately, even during
development. Otherwise they won’t be in scope when you run unit tests
e.g. with testthat.
</p>
<p>Implementing double dispatch methods is very similar to implementing
regular S3 methods. In these examples we are using roxygen2 tags to
register the methods, but you can also register the methods manually in
your NAMESPACE file or lazily with <code>s3_register()</code>.
</p>



<h4>Parent methods</h4>

<p>Most of the common type determination should be performed by the parent
class. In vctrs, double dispatch is implemented in such a way that you
need to call the methods for the parent class manually. For
<code>vec_ptype2()</code> this means you need to call <code>df_ptype2()</code> (for data frame
subclasses) or <code>tib_ptype2()</code> (for tibble subclasses). Similarly,
<code>df_cast()</code> and <code>tib_cast()</code> are the workhorses for <code>vec_cast()</code> methods
of subtypes of <code>data.frame</code> and <code>tbl_df</code>. These functions take the union
of the columns in <code>x</code> and <code>y</code>, and ensure shared columns have the same
type.
</p>
<p>These functions are much less strict than <code>vec_ptype2()</code> and
<code>vec_cast()</code> as they accept any subclass of data frame as input. They
always return a <code>data.frame</code> or a <code>tbl_df</code>. You will probably want to
write similar functions for your subclass to avoid repetition in your
code. You may want to export them as well if you are expecting other
people to derive from your class.
</p>



<h4>A <code>data.table</code> example</h4>

<p>This example is the actual implementation of vctrs coercion methods for
<code>data.table</code>. This is a simple example because we don’t have to keep
track of attributes for this class or manage incompatibilities. See the
tibble section for a more complicated example.
</p>
<p>We first create the <code>dt_ptype2()</code> and <code>dt_cast()</code> helpers. They wrap
around the parent methods <code>df_ptype2()</code> and <code>df_cast()</code>, and transform
the common type or converted input to a data table. You may want to
export these helpers if you expect other packages to derive from your
data frame class.
</p>
<p>These helpers should always return data tables. To this end we use the
conversion generic <code>as.data.table()</code>. Depending on the tools available
for the particular class at hand, a constructor might be appropriate as
well.
</p>
<div class="sourceCode r"><pre>dt_ptype2 &lt;- function(x, y, ...) {
  as.data.table(df_ptype2(x, y, ...))
}
dt_cast &lt;- function(x, to, ...) {
  as.data.table(df_cast(x, to, ...))
}
</pre></div>
<p>We start with the self-self method:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.data.table.data.table &lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
</pre></div>
<p>Between a data frame and a data table, we consider the richer type to be
data table. This decision is not based on the value coverage of each
data structures, but on the idea that data tables have richer behaviour.
Since data tables are the richer type, we call <code>dt_type2()</code> from the
<code>vec_ptype2()</code> method. It always returns a data table, no matter the
order of arguments:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.data.table.data.frame &lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.data.table &lt;- function(x, y, ...) {
  dt_ptype2(x, y, ...)
}
</pre></div>
<p>The <code>vec_cast()</code> methods follow the same pattern, but note how the
method for coercing to data frame uses <code>df_cast()</code> rather than
<code>dt_cast()</code>.
</p>
<p>Also, please note that for historical reasons, the order of the classes
in the method name is in reverse order of the arguments in the function
signature. The first class represents <code>to</code>, whereas the second class
represents <code>x</code>.
</p>
<div class="sourceCode r"><pre>#' @export
vec_cast.data.table.data.table &lt;- function(x, to, ...) {
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.table.data.frame &lt;- function(x, to, ...) {
  # `x` is a data.frame to be converted to a data.table
  dt_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.data.table &lt;- function(x, to, ...) {
  # `x` is a data.table to be converted to a data.frame
  df_cast(x, to, ...)
}
</pre></div>
<p>With these methods vctrs is now able to combine data tables with data
frames:
</p>
<div class="sourceCode r"><pre>vec_cbind(data.frame(x = 1:3), data.table(y = "foo"))
#&gt;    x   y
#&gt; 1: 1 foo
#&gt; 2: 2 foo
#&gt; 3: 3 foo
</pre></div>



<h4>A tibble example</h4>

<p>In this example we implement coercion methods for a tibble subclass that
carries a colour as a scalar metadata:
</p>
<div class="sourceCode r"><pre># User constructor
my_tibble &lt;- function(colour = NULL, ...) {
  new_my_tibble(tibble::tibble(...), colour = colour)
}
# Developer constructor
new_my_tibble &lt;- function(x, colour = NULL) {
  stopifnot(is.data.frame(x))
  tibble::new_tibble(
    x,
    colour = colour,
    class = "my_tibble",
    nrow = nrow(x)
  )
}

df_colour &lt;- function(x) {
  if (inherits(x, "my_tibble")) {
    attr(x, "colour")
  } else {
    NULL
  }
}

#'@export
print.my_tibble &lt;- function(x, ...) {
  cat(sprintf("&lt;%s: %s&gt;\n", class(x)[[1]], df_colour(x)))
  cli::cat_line(format(x)[-1])
}
</pre></div>
<p>This subclass is very simple. All it does is modify the header.
</p>
<div class="sourceCode r"><pre>red &lt;- my_tibble("red", x = 1, y = 1:2)
red
#&gt; &lt;my_tibble: red&gt;
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2

red[2]
#&gt; &lt;my_tibble: red&gt;
#&gt;       y
#&gt;   &lt;int&gt;
#&gt; 1     1
#&gt; 2     2

green &lt;- my_tibble("green", z = TRUE)
green
#&gt; &lt;my_tibble: green&gt;
#&gt;   z    
#&gt;   &lt;lgl&gt;
#&gt; 1 TRUE
</pre></div>
<p>Combinations do not work properly out of the box, instead vctrs falls
back to a bare tibble:
</p>
<div class="sourceCode r"><pre>vec_rbind(red, tibble::tibble(x = 10:12))
#&gt; # A tibble: 5 x 2
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2
#&gt; 3    10    NA
#&gt; 4    11    NA
#&gt; 5    12    NA
</pre></div>
<p>Instead of falling back to a data frame, we would like to return a
<code style="white-space: pre;">&#8288;&lt;my_tibble&gt;&#8288;</code> when combined with a data frame or a tibble. Because this
subclass has more metadata than normal data frames (it has a colour), it
is a <em>supertype</em> of tibble and data frame, i.e. it is the richer type.
This is similar to how a grouped tibble is a more general type than a
tibble or a data frame. Conceptually, the latter are pinned to a single
constant group.
</p>
<p>The coercion methods for data frames operate in two steps:
</p>

<ul>
<li><p> They check for compatible subclass attributes. In our case the tibble
colour has to be the same, or be undefined.
</p>
</li>
<li><p> They call their parent methods, in this case
<code><a href="#topic+tib_ptype2">tib_ptype2()</a></code> and <code><a href="#topic+tib_cast">tib_cast()</a></code> because
we have a subclass of tibble. This eventually calls the data frame
methods <code><a href="#topic+df_ptype2">df_ptype2()</a></code> and
<code><a href="#topic+tib_ptype2">tib_ptype2()</a></code> which match the columns and their
types.
</p>
</li></ul>

<p>This process should usually be wrapped in two functions to avoid
repetition. Consider exporting these if you expect your class to be
derived by other subclasses.
</p>
<p>We first implement a helper to determine if two data frames have
compatible colours. We use the <code>df_colour()</code> accessor which returns
<code>NULL</code> when the data frame colour is undefined.
</p>
<div class="sourceCode r"><pre>has_compatible_colours &lt;- function(x, y) {
  x_colour &lt;- df_colour(x) %||% df_colour(y)
  y_colour &lt;- df_colour(y) %||% x_colour
  identical(x_colour, y_colour)
}
</pre></div>
<p>Next we implement the coercion helpers. If the colours are not
compatible, we call <code>stop_incompatible_cast()</code> or
<code>stop_incompatible_type()</code>. These strict coercion semantics are
justified because in this class colour is a <em>data</em> attribute. If it were
a non essential <em>detail</em> attribute, like the timezone in a datetime, we
would just standardise it to the value of the left-hand side.
</p>
<p>In simpler cases (like the data.table example), these methods do not
need to take the arguments suffixed in <code style="white-space: pre;">&#8288;_arg&#8288;</code>. Here we do need to take
these arguments so we can pass them to the <code>stop_</code> functions when we
detect an incompatibility. They also should be passed to the parent
methods.
</p>
<div class="sourceCode r"><pre>#' @export
my_tib_cast &lt;- function(x, to, ..., x_arg = "", to_arg = "") {
  out &lt;- tib_cast(x, to, ..., x_arg = x_arg, to_arg = to_arg)

  if (!has_compatible_colours(x, to)) {
    stop_incompatible_cast(
      x,
      to,
      x_arg = x_arg,
      to_arg = to_arg,
      details = "Can't combine colours."
    )
  }

  colour &lt;- df_colour(x) %||% df_colour(to)
  new_my_tibble(out, colour = colour)
}
#' @export
my_tib_ptype2 &lt;- function(x, y, ..., x_arg = "", y_arg = "") {
  out &lt;- tib_ptype2(x, y, ..., x_arg = x_arg, y_arg = y_arg)

  if (!has_compatible_colours(x, y)) {
    stop_incompatible_type(
      x,
      y,
      x_arg = x_arg,
      y_arg = y_arg,
      details = "Can't combine colours."
    )
  }

  colour &lt;- df_colour(x) %||% df_colour(y)
  new_my_tibble(out, colour = colour)
}
</pre></div>
<p>Let’s now implement the coercion methods, starting with the self-self
methods.
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_tibble.my_tibble &lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_cast.my_tibble.my_tibble &lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
</pre></div>
<p>We can now combine compatible instances of our class!
</p>
<div class="sourceCode r"><pre>vec_rbind(red, red)
#&gt; &lt;my_tibble: red&gt;
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2
#&gt; 3     1     1
#&gt; 4     1     2

vec_rbind(green, green)
#&gt; &lt;my_tibble: green&gt;
#&gt;   z    
#&gt;   &lt;lgl&gt;
#&gt; 1 TRUE 
#&gt; 2 TRUE

vec_rbind(green, red)
#&gt; Error in `my_tib_ptype2()`:
#&gt; ! Can't combine `..1` &lt;my_tibble&gt; and `..2` &lt;my_tibble&gt;.
#&gt; Can't combine colours.
</pre></div>
<p>The methods for combining our class with tibbles follow the same
pattern. For ptype2 we return our class in both cases because it is the
richer type:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_tibble.tbl_df &lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.tbl_df.my_tibble &lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
</pre></div>
<p>For cast are careful about returning a tibble when casting to a tibble.
Note the call to <code>vctrs::tib_cast()</code>:
</p>
<div class="sourceCode r"><pre>#' @export
vec_cast.my_tibble.tbl_df &lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.tbl_df.my_tibble &lt;- function(x, to, ...) {
  tib_cast(x, to, ...)
}
</pre></div>
<p>From this point, we get correct combinations with tibbles:
</p>
<div class="sourceCode r"><pre>vec_rbind(red, tibble::tibble(x = 10:12))
#&gt; &lt;my_tibble: red&gt;
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2
#&gt; 3    10    NA
#&gt; 4    11    NA
#&gt; 5    12    NA
</pre></div>
<p>However we are not done yet. Because the coercion hierarchy is different
from the class hierarchy, there is no inheritance of coercion methods.
We’re not getting correct behaviour for data frames yet because we
haven’t explicitly specified the methods for this class:
</p>
<div class="sourceCode r"><pre>vec_rbind(red, data.frame(x = 10:12))
#&gt; # A tibble: 5 x 2
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2
#&gt; 3    10    NA
#&gt; 4    11    NA
#&gt; 5    12    NA
</pre></div>
<p>Let’s finish up the boiler plate:
</p>
<div class="sourceCode r"><pre>#' @export
vec_ptype2.my_tibble.data.frame &lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}
#' @export
vec_ptype2.data.frame.my_tibble &lt;- function(x, y, ...) {
  my_tib_ptype2(x, y, ...)
}

#' @export
vec_cast.my_tibble.data.frame &lt;- function(x, to, ...) {
  my_tib_cast(x, to, ...)
}
#' @export
vec_cast.data.frame.my_tibble &lt;- function(x, to, ...) {
  df_cast(x, to, ...)
}
</pre></div>
<p>This completes the implementation:
</p>
<div class="sourceCode r"><pre>vec_rbind(red, data.frame(x = 10:12))
#&gt; &lt;my_tibble: red&gt;
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     1     2
#&gt; 3    10    NA
#&gt; 4    11    NA
#&gt; 5    12    NA
</pre></div>


<hr>
<h2 id='howto-faq-fix-scalar-type-error'>FAQ - Why isn't my class treated as a vector?</h2><span id='topic+howto-faq-fix-scalar-type-error'></span>

<h3>Description</h3>

<p>The tidyverse is a bit stricter than base R regarding what kind of
objects are considered as vectors (see the <a href="#topic+faq-error-scalar-type">user FAQ</a> about this topic). Sometimes vctrs won’t
treat your class as a vector when it should.
</p>


<h4>Why isn’t my list class considered a vector?</h4>

<p>By default, S3 lists are not considered to be vectors by vctrs:
</p>
<div class="sourceCode r"><pre>my_list &lt;- structure(list(), class = "my_class")

vctrs::vec_is(my_list)
#&gt; [1] FALSE
</pre></div>
<p>To be treated as a vector, the class must either inherit from <code>"list"</code>
explicitly:
</p>
<div class="sourceCode r"><pre>my_explicit_list &lt;- structure(list(), class = c("my_class", "list"))
vctrs::vec_is(my_explicit_list)
#&gt; [1] TRUE
</pre></div>
<p>Or it should implement a <code>vec_proxy()</code> method that returns its input if
explicit inheritance is not possible or troublesome:
</p>
<div class="sourceCode r"><pre>#' @export
vec_proxy.my_class &lt;- function(x, ...) x

vctrs::vec_is(my_list)
#&gt; [1] FALSE
</pre></div>
<p>Note that explicit inheritance is the preferred way because this makes
it possible for your class to dispatch on <code>list</code> methods of S3 generics:
</p>
<div class="sourceCode r"><pre>my_generic &lt;- function(x) UseMethod("my_generic")
my_generic.list &lt;- function(x) "dispatched!"

my_generic(my_list)
#&gt; Error in UseMethod("my_generic"): no applicable method for 'my_generic' applied to an object of class "my_class"

my_generic(my_explicit_list)
#&gt; [1] "dispatched!"
</pre></div>



<h4>Why isn’t my data frame class considered a vector?</h4>

<p>The most likely explanation is that the data frame has not been properly
constructed.
</p>
<p>However, if you get an “Input must be a vector” error with a data frame
subclass, it probably means that the data frame has not been properly
constructed. The main cause of these errors are data frames whose <em>base
class</em> is not <code>"data.frame"</code>:
</p>
<div class="sourceCode r"><pre>my_df &lt;- data.frame(x = 1)
class(my_df) &lt;- c("data.frame", "my_class")

vctrs::obj_check_vector(my_df)
#&gt; Error:
#&gt; ! `my_df` must be a vector, not a &lt;data.frame/my_class&gt; object.
</pre></div>
<p>This is problematic as many tidyverse functions won’t work properly:
</p>
<div class="sourceCode r"><pre>dplyr::slice(my_df, 1)
#&gt; Error in `vec_slice()`:
#&gt; ! `x` must be a vector, not a &lt;data.frame/my_class&gt; object.
</pre></div>
<p>It is generally not appropriate to declare your class to be a superclass
of another class. We generally consider this undefined behaviour (UB).
To fix these errors, you can simply change the construction of your data
frame class so that <code>"data.frame"</code> is a base class, i.e. it should come
last in the class vector:
</p>
<div class="sourceCode r"><pre>class(my_df) &lt;- c("my_class", "data.frame")

vctrs::obj_check_vector(my_df)

dplyr::slice(my_df, 1)
#&gt;   x
#&gt; 1 1
</pre></div>


<hr>
<h2 id='internal-faq-matches-algorithm'>Internal FAQ - Implementation of <code>vec_locate_matches()</code></h2><span id='topic+internal-faq-matches-algorithm'></span>

<h3>Description</h3>

<p><code>vec_locate_matches()</code> is similar to <code>vec_match()</code>, but detects <em>all</em> matches by default, and can match on conditions other than equality (like <code>&gt;=</code> and <code>&lt;</code>). There are also various other arguments to limit or adjust exactly which kinds of matches are returned. Here is an example:
</p>
<div class="sourceCode r"><pre>x &lt;- c("a", "b", "a", "c", "d")
y &lt;- c("d", "b", "a", "d", "a", "e")

# For each value of `x`, find all matches in `y`
# - The "c" in `x` doesn't have a match, so it gets an NA location by default
# - The "e" in `y` isn't matched by anything in `x`, so it is dropped by default
vec_locate_matches(x, y)
#&gt;   needles haystack
#&gt; 1       1        3
#&gt; 2       1        5
#&gt; 3       2        2
#&gt; 4       3        3
#&gt; 5       3        5
#&gt; 6       4       NA
#&gt; 7       5        1
#&gt; 8       5        4
</pre></div>


<h3>Algorithm description</h3>



<h4>Overview and <code>==</code></h4>

<p>The simplest (approximate) way to think about the algorithm that <code>df_locate_matches_recurse()</code> uses is that it sorts both inputs, and then starts at the midpoint in <code>needles</code> and uses a binary search to find each needle in <code>haystack</code>. Since there might be multiple of the same needle, we find the location of the lower and upper duplicate of that needle to handle all duplicates of that needle at once. Similarly, if there are duplicates of a matching <code>haystack</code> value, we find the lower and upper duplicates of the match.
</p>
<p>If the condition is <code>==</code>, that is pretty much all we have to do. For each needle, we then record 3 things: the location of the needle, the location of the lower match in the haystack, and the match size (i.e. <code>loc_upper_match - loc_lower_match + 1</code>). This later gets expanded in <code>expand_compact_indices()</code> into the actual output.
</p>
<p>After recording the matches for a single needle, we perform the same procedure on the LHS and RHS of that needle (remember we started on the midpoint needle). i.e. from <code style="white-space: pre;">&#8288;[1, loc_needle-1]&#8288;</code> and <code style="white-space: pre;">&#8288;[loc_needle+1, size_needles]&#8288;</code>, again taking the midpoint of those two ranges, finding their respective needle in the haystack, recording matches, and continuing on to the next needle. This iteration proceeds until we run out of needles.
</p>
<p>When we have a data frame with multiple columns, we add a layer of recursion to this. For the first column, we find the locations of the lower/upper duplicate of the current needle, and we find the locations of the lower/upper matches in the haystack. If we are on the final column in the data frame, we record the matches, otherwise we pass this information on to another call to <code>df_locate_matches_recurse()</code>, bumping the column index and using these refined lower/upper bounds as the starting bounds for the next column.
</p>
<p>I think an example would be useful here, so below I step through this process for a few iterations:
</p>
<div class="sourceCode r"><pre># these are sorted already for simplicity
needles &lt;- data_frame(x = c(1, 1, 2, 2, 2, 3), y = c(1, 2, 3, 4, 5, 3))
haystack &lt;- data_frame(x = c(1, 1, 2, 2, 3), y = c(2, 3, 4, 4, 1))

needles
#&gt;   x y
#&gt; 1 1 1
#&gt; 2 1 2
#&gt; 3 2 3
#&gt; 4 2 4
#&gt; 5 2 5
#&gt; 6 3 3

haystack
#&gt;   x y
#&gt; 1 1 2
#&gt; 2 1 3
#&gt; 3 2 4
#&gt; 4 2 4
#&gt; 5 3 1

## Column 1, iteration 1

# start at midpoint in needles
# this corresponds to x==2
loc_mid_needles &lt;- 3L

# finding all x==2 values in needles gives us:
loc_lower_duplicate_needles &lt;- 3L
loc_upper_duplicate_needles &lt;- 5L

# finding matches in haystack give us:
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 4L

# compute LHS/RHS bounds for next needle
lhs_loc_lower_bound_needles &lt;- 1L # original lower bound
lhs_loc_upper_bound_needles &lt;- 2L # lower_duplicate-1

rhs_loc_lower_bound_needles &lt;- 6L # upper_duplicate+1
rhs_loc_upper_bound_needles &lt;- 6L # original upper bound

# We still have a 2nd column to check. So recurse and pass on the current
# duplicate and match bounds to start the 2nd column with.

## Column 2, iteration 1

# midpoint of [3, 5]
# value y==4
loc_mid_needles &lt;- 4L

loc_lower_duplicate_needles &lt;- 4L
loc_upper_duplicate_needles &lt;- 4L

loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 4L

# last column, so record matches
# - this was location 4 in needles
# - lower match in haystack is at loc 3
# - match size is 2

# Now handle LHS and RHS of needle midpoint
lhs_loc_lower_bound_needles &lt;- 3L # original lower bound
lhs_loc_upper_bound_needles &lt;- 3L # lower_duplicate-1

rhs_loc_lower_bound_needles &lt;- 5L # upper_duplicate+1
rhs_loc_upper_bound_needles &lt;- 5L # original upper bound

## Column 2, iteration 2 (using LHS bounds)

# midpoint of [3,3]
# value of y==3
loc_mid_needles &lt;- 3L

loc_lower_duplicate_needles &lt;- 3L
loc_upper_duplicate_needles &lt;- 3L

# no match! no y==3 in haystack for x==2
# lower-match will always end up &gt; upper-match in this case
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 2L

# no LHS or RHS needle values to do, so we are done here

## Column 2, iteration 3 (using RHS bounds)

# same as above, range of [5,5], value of y==5, which has no match in haystack

## Column 1, iteration 2 (LHS of first x needle)

# Now we are done with the x needles from [3,5], so move on to the LHS and RHS
# of that. Here we would do the LHS:

# midpoint of [1,2]
loc_mid_needles &lt;- 1L

# ...

## Column 1, iteration 3 (RHS of first x needle)

# midpoint of [6,6]
loc_mid_needles &lt;- 6L

# ...
</pre></div>
<p>In the real code, rather than comparing the double values of the columns directly, we replace each column with pseudo &quot;joint ranks&quot; computed between the i-th column of <code>needles</code> and the i-th column of <code>haystack</code>. It is approximately like doing <code>vec_rank(vec_c(needles$x, haystack$x), type = "dense")</code>, then splitting the resulting ranks back up into their corresponding needle/haystack columns. This keeps the recursion code simpler, because we only have to worry about comparing integers.
</p>



<h4>Non-equi conditions and containers</h4>

<p>At this point we can talk about non-equi conditions like <code>&lt;</code> or <code>&gt;=</code>. The general idea is pretty simple, and just builds on the above algorithm. For example, start with the <code>x</code> column from needles/haystack above:
</p>
<div class="sourceCode r"><pre>needles$x
#&gt; [1] 1 1 2 2 2 3

haystack$x
#&gt; [1] 1 1 2 2 3
</pre></div>
<p>If we used a condition of <code>&lt;=</code>, then we'd do everything the same as before:
</p>

<ul>
<li><p> Midpoint in needles is location 3, value <code>x==2</code>
</p>
</li>
<li><p> Find lower/upper duplicates in needles, giving locations <code style="white-space: pre;">&#8288;[3, 5]&#8288;</code>
</p>
</li>
<li><p> Find lower/upper <em>exact</em> match in haystack, giving locations <code style="white-space: pre;">&#8288;[3, 4]&#8288;</code>
</p>
</li></ul>

<p>At this point, we need to &quot;adjust&quot; the <code>haystack</code> match bounds to account for the condition. Since <code>haystack</code> is ordered, our &quot;rule&quot; for <code>&lt;=</code> is to keep the lower match location the same, but extend the upper match location to the upper bound, so we end up with <code style="white-space: pre;">&#8288;[3, 5]&#8288;</code>. We know we can extend the upper match location because every haystack value after the exact match should be less than the needle. Then we just record the matches and continue on normally.
</p>
<p>This approach is really nice, because we only have to exactly match the <code>needle</code> in <code>haystack</code>. We don't have to compare each needle against every value in <code>haystack</code>, which would take a massive amount of time.
</p>
<p>However, it gets slightly more complex with data frames with multiple columns. Let's go back to our original <code>needles</code> and <code>haystack</code> data frames and apply the condition <code>&lt;=</code> to each column. Here is another worked example, which shows a case where our &quot;rule&quot; falls apart on the second column.
</p>
<div class="sourceCode r"><pre>needles
#&gt;   x y
#&gt; 1 1 1
#&gt; 2 1 2
#&gt; 3 2 3
#&gt; 4 2 4
#&gt; 5 2 5
#&gt; 6 3 3

haystack
#&gt;   x y
#&gt; 1 1 2
#&gt; 2 1 3
#&gt; 3 2 4
#&gt; 4 2 4
#&gt; 5 3 1

# `condition = c("&lt;=", "&lt;=")`

## Column 1, iteration 1

# x == 2
loc_mid_needles &lt;- 3L

loc_lower_duplicate_needles &lt;- 3L
loc_upper_duplicate_needles &lt;- 5L

# finding exact matches in haystack give us:
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 4L

# because haystack is ordered we know we can expand the upper bound automatically
# to include everything past the match. i.e. needle of x==2 must be less than
# the haystack value at loc 5, which we can check by seeing that it is x==3.
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 5L

## Column 2, iteration 1

# needles range of [3, 5]
# y == 4
loc_mid_needles &lt;- 4L

loc_lower_duplicate_needles &lt;- 4L
loc_upper_duplicate_needles &lt;- 4L

# finding exact matches in haystack give us:
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 4L

# lets try using our rule, which tells us we should be able to extend the upper
# bound:
loc_lower_match_haystack &lt;- 3L
loc_upper_match_haystack &lt;- 5L

# but the haystack value of y at location 5 is y==1, which is not less than y==4
# in the needles! looks like our rule failed us.
</pre></div>
<p>If you read through the above example, you'll see that the rule didn't work here. The problem is that while <code>haystack</code> is ordered (by <code>vec_order()</code>s standards), each column isn't ordered <em>independently</em> of the others. Instead, each column is ordered within the &quot;group&quot; created by previous columns. Concretely, <code>haystack</code> here has an ordered <code>x</code> column, but if you look at <code>haystack$y</code> by itself, it isn't ordered (because of that 1 at the end). That is what causes the rule to fail.
</p>
<div class="sourceCode r"><pre>haystack
#&gt;   x y
#&gt; 1 1 2
#&gt; 2 1 3
#&gt; 3 2 4
#&gt; 4 2 4
#&gt; 5 3 1
</pre></div>
<p>To fix this, we need to create haystack &quot;containers&quot; where the values within each container are all <em>totally</em> ordered. For <code>haystack</code> that would create 2 containers and look like:
</p>
<div class="sourceCode r"><pre>haystack[1:4,]
#&gt; # A tibble: 4 × 2
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     1     2
#&gt; 2     1     3
#&gt; 3     2     4
#&gt; 4     2     4

haystack[5,]
#&gt; # A tibble: 1 × 2
#&gt;       x     y
#&gt;   &lt;dbl&gt; &lt;dbl&gt;
#&gt; 1     3     1
</pre></div>
<p>This is essentially what <code>computing_nesting_container_ids()</code> does. You can actually see these ids with the helper, <code>compute_nesting_container_info()</code>:
</p>
<div class="sourceCode r"><pre>haystack2 &lt;- haystack

# we really pass along the integer ranks, but in this case that is equivalent
# to converting our double columns to integers
haystack2$x &lt;- as.integer(haystack2$x)
haystack2$y &lt;- as.integer(haystack2$y)

info &lt;- compute_nesting_container_info(haystack2, condition = c("&lt;=", "&lt;="))

# the ids are in the second slot.
# container ids break haystack into [1, 4] and [5, 5].
info[[2]]
#&gt; [1] 0 0 0 0 1
</pre></div>
<p>So the idea is that for each needle, we look in each haystack container and find all the matches, then we aggregate all of the matches once at the end. <code>df_locate_matches_with_containers()</code> has the job of iterating over the containers.
</p>
<p>Computing totally ordered containers can be expensive, but luckily it doesn't happen very often in normal usage.
</p>

<ul>
<li><p> If there are all <code>==</code> conditions, we don't need containers (i.e. any equi join)
</p>
</li>
<li><p> If there is only 1 non-equi condition and no conditions after it, we don't need containers (i.e. most rolling joins)
</p>
</li>
<li><p> Otherwise the typical case where we need containers is if we have something like <code style="white-space: pre;">&#8288;date &gt;= lower, date &lt;= upper&#8288;</code>. Even so, the computation cost generally scales with the number of columns in <code>haystack</code> you compute containers with (here 2), and it only really slows down around 4 columns or so, which I haven't ever seen a real life example of.
</p>
</li></ul>



<hr>
<h2 id='internal-faq-ptype2-identity'>Internal FAQ - <code>vec_ptype2()</code>, <code>NULL</code>, and unspecified vectors</h2><span id='topic+internal-faq-ptype2-identity'></span>

<h3>Description</h3>



<h4>Promotion monoid</h4>

<p>Promotions (i.e. automatic coercions) should always transform inputs to
their richer type to avoid losing values of precision. <code>vec_ptype2()</code>
returns the <em>richer</em> type of two vectors, or throws an incompatible type
error if none of the two vector types include the other. For example,
the richer type of integer and double is the latter because double
covers a larger range of values than integer.
</p>
<p><code>vec_ptype2()</code> is a <a href="https://en.wikipedia.org/wiki/Monoid">monoid</a> over
vectors, which in practical terms means that it is a well behaved
operation for
<a href="https://purrr.tidyverse.org/reference/reduce.html">reduction</a>.
Reduction is an important operation for promotions because that is how
the richer type of multiple elements is computed. As a monoid,
<code>vec_ptype2()</code> needs an identity element, i.e. a value that doesn’t
change the result of the reduction. vctrs has two identity values,
<code>NULL</code> and <strong>unspecified</strong> vectors.
</p>



<h4>The <code>NULL</code> identity</h4>

<p>As an identity element that shouldn’t influence the determination of the
common type of a set of vectors, <code>NULL</code> is promoted to any type:
</p>
<div class="sourceCode r"><pre>vec_ptype2(NULL, "")
#&gt; character(0)
vec_ptype2(1L, NULL)
#&gt; integer(0)
</pre></div>
<p>The common type of <code>NULL</code> and <code>NULL</code> is the identity <code>NULL</code>:
</p>
<div class="sourceCode r"><pre>vec_ptype2(NULL, NULL)
#&gt; NULL
</pre></div>
<p>This way the result of <code>vec_ptype2(NULL, NULL)</code> does not influence
subsequent promotions:
</p>
<div class="sourceCode r"><pre>vec_ptype2(
  vec_ptype2(NULL, NULL),
  ""
)
#&gt; character(0)
</pre></div>



<h4>Unspecified vectors</h4>

<p>In the vctrs coercion system, logical vectors of missing values are also
automatically promoted to the type of any other vector, just like
<code>NULL</code>. We call these vectors unspecified. The special coercion
semantics of unspecified vectors serve two purposes:
</p>

<ol>
<li><p> It makes it possible to assign vectors of <code>NA</code> inside any type of
vectors, even when they are not coercible with logical:
</p>
<div class="sourceCode r"><pre>x &lt;- letters[1:5]
vec_assign(x, 1:2, c(NA, NA))
#&gt; [1] NA  NA  "c" "d" "e"
</pre></div>
</li>
<li><p> We can’t put <code>NULL</code> in a data frame, so we need an identity element
that behaves more like a vector. Logical vectors of <code>NA</code> seem a
natural fit for this.
</p>
</li></ol>

<p>Unspecified vectors are thus promoted to any other type, just like
<code>NULL</code>:
</p>
<div class="sourceCode r"><pre>vec_ptype2(NA, "")
#&gt; character(0)
vec_ptype2(1L, c(NA, NA))
#&gt; integer(0)
</pre></div>



<h4>Finalising common types</h4>

<p>vctrs has an internal vector type of class <code>vctrs_unspecified</code>. Users
normally don’t see such vectors in the wild, but they do come up when
taking the common type of an unspecified vector with another identity
value:
</p>
<div class="sourceCode r"><pre>vec_ptype2(NA, NA)
#&gt; &lt;unspecified&gt; [0]
vec_ptype2(NA, NULL)
#&gt; &lt;unspecified&gt; [0]
vec_ptype2(NULL, NA)
#&gt; &lt;unspecified&gt; [0]
</pre></div>
<p>We can’t return <code>NA</code> here because <code>vec_ptype2()</code> normally returns empty
vectors. We also can’t return <code>NULL</code> because unspecified vectors need to
be recognised as logical vectors if they haven’t been promoted at the
end of the reduction.
</p>
<div class="sourceCode r"><pre>vec_ptype_finalise(vec_ptype2(NULL, NA))
#&gt; logical(0)
</pre></div>
<p>See the output of <code>vec_ptype_common()</code> which performs the reduction and
finalises the type, ready to be used by the caller:
</p>
<div class="sourceCode r"><pre>vec_ptype_common(NULL, NULL)
#&gt; NULL
vec_ptype_common(NA, NULL)
#&gt; logical(0)
</pre></div>
<p>Note that <strong>partial</strong> types in vctrs make use of the same mechanism.
They are finalised with <code>vec_ptype_finalise()</code>.
</p>


<hr>
<h2 id='list_drop_empty'>Drop empty elements from a list</h2><span id='topic+list_drop_empty'></span>

<h3>Description</h3>

<p><code>list_drop_empty()</code> removes empty elements from a list. This includes <code>NULL</code>
elements along with empty vectors, like <code>integer(0)</code>. This is equivalent to,
but faster than, <code>vec_slice(x, list_sizes(x) != 0L)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_drop_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_drop_empty_+3A_x">x</code></td>
<td>
<p>A list.</p>
</td></tr>
</table>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(1, NULL, integer(), 2)
list_drop_empty(x)
</code></pre>

<hr>
<h2 id='list_of'><code>list_of</code> S3 class for homogenous lists</h2><span id='topic+list_of'></span><span id='topic+as_list_of'></span><span id='topic+is_list_of'></span><span id='topic+vec_ptype2.vctrs_list_of'></span><span id='topic+vec_cast.vctrs_list_of'></span>

<h3>Description</h3>

<p>A <code>list_of</code> object is a list where each element has the same type.
Modifying the list with <code>$</code>, <code>[</code>, and <code>[[</code> preserves the constraint
by coercing all input items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_of(..., .ptype = NULL)

as_list_of(x, ...)

is_list_of(x)

## S3 method for class 'vctrs_list_of'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'vctrs_list_of'
vec_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_of_+3A_...">...</code></td>
<td>
<p>Vectors to coerce.</p>
</td></tr>
<tr><td><code id="list_of_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>...</code>.
</p>
<p>Alternatively, you can supply <code>.ptype</code> to give the output known type.
If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code> you must supply this value:
this is a convenient way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="list_of_+3A_x">x</code></td>
<td>
<p>For <code>as_list_of()</code>, a vector to be coerced to list_of.</p>
</td></tr>
<tr><td><code id="list_of_+3A_y">y</code>, <code id="list_of_+3A_to">to</code></td>
<td>
<p>Arguments to <code>vec_ptype2()</code> and <code>vec_cast()</code>.</p>
</td></tr>
<tr><td><code id="list_of_+3A_x_arg">x_arg</code>, <code id="list_of_+3A_y_arg">y_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>y</code>. These are used
in error messages to inform the user about the locations of
incompatible types (see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike regular lists, setting a list element to <code>NULL</code> using <code>[[</code>
does not remove it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list_of(1:3, 5:6, 10:15)
if (requireNamespace("tibble", quietly = TRUE)) {
  tibble::tibble(x = x)
}

vec_c(list_of(1, 2), list_of(FALSE, TRUE))
</code></pre>

<hr>
<h2 id='maybe_lossy_cast'>Lossy cast error</h2><span id='topic+maybe_lossy_cast'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>By default, lossy casts are an error. Use <code>allow_lossy_cast()</code> to
silence these errors and continue with the partial results. In this
case the lost values are typically set to <code>NA</code> or to a lower value
resolution, depending on the type of cast.
</p>
<p>Lossy cast errors are thrown by <code>maybe_lossy_cast()</code>. Unlike
functions prefixed with <code>stop_</code>, <code>maybe_lossy_cast()</code> usually
returns a result. If a lossy cast is detected, it throws an error,
unless it's been wrapped in <code>allow_lossy_cast()</code>. In that case, it
returns the result silently.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maybe_lossy_cast(
  result,
  x,
  to,
  lossy = NULL,
  locations = NULL,
  ...,
  loss_type = c("precision", "generality"),
  x_arg,
  to_arg,
  call = caller_env(),
  details = NULL,
  message = NULL,
  class = NULL,
  .deprecation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maybe_lossy_cast_+3A_result">result</code></td>
<td>
<p>The result of a potentially lossy cast.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_x">x</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_to">to</code></td>
<td>
<p>Type to cast to.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_lossy">lossy</code></td>
<td>
<p>A logical vector indicating which elements of <code>result</code>
were lossy.
</p>
<p>Can also be a single <code>TRUE</code>, but note that <code>locations</code> picks up
locations from this vector by default. In this case, supply your
own location vector, possibly empty.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_locations">locations</code></td>
<td>
<p>An optional integer vector giving the
locations where <code>x</code> lost information.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_...">...</code>, <code id="maybe_lossy_cast_+3A_class">class</code></td>
<td>
<p>Only use these fields when creating a subclass.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_loss_type">loss_type</code></td>
<td>
<p>The kind of lossy cast to be mentioned in error
messages. Can be loss of precision (for instance from double to
integer) or loss of generality (from character to factor).</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_x_arg">x_arg</code></td>
<td>
<p>Argument name for <code>x</code>, used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_to_arg">to_arg</code></td>
<td>
<p>Argument name <code>to</code> used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_details">details</code></td>
<td>
<p>Any additional human readable details.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_message">message</code></td>
<td>
<p>An overriding message for the error. <code>details</code> and
<code>message</code> are mutually exclusive, supplying both is an error.</p>
</td></tr>
<tr><td><code id="maybe_lossy_cast_+3A_.deprecation">.deprecation</code></td>
<td>
<p>If <code>TRUE</code>, the error is downgraded to a
deprecation warning. This is useful for transitioning your class
to a stricter conversion scheme. The warning advises your users
to wrap their code with <code>allow_lossy_cast()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='missing'>Missing values</h2><span id='topic+missing'></span><span id='topic+vec_detect_missing'></span><span id='topic+vec_any_missing'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_detect_missing()</code> returns a logical vector the same size as <code>x</code>. For
each element of <code>x</code>, it returns <code>TRUE</code> if the element is missing, and <code>FALSE</code>
otherwise.
</p>
</li>
<li> <p><code>vec_any_missing()</code> returns a single <code>TRUE</code> or <code>FALSE</code> depending on whether
or not <code>x</code> has <em>any</em> missing values.
</p>
</li></ul>



<h4>Differences with <code><a href="Matrix.html#topic+is.na">is.na()</a></code></h4>

<p>Data frame rows are only considered missing if every element in the row is
missing. Similarly, <a href="#topic+new_rcrd">record vector</a> elements are only considered
missing if every field in the record is missing. Put another way, rows with
<em>any</em> missing values are considered <a href="#topic+vec_detect_complete">incomplete</a>, but
only rows with <em>all</em> missing values are considered missing.
</p>
<p>List elements are only considered missing if they are <code>NULL</code>.
</p>



<h3>Usage</h3>

<pre><code class='language-R'>vec_detect_missing(x)

vec_any_missing(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="missing_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_detect_missing()</code> returns a logical vector the same size as <code>x</code>.
</p>
</li>
<li> <p><code>vec_any_missing()</code> returns a single <code>TRUE</code> or <code>FALSE</code>.
</p>
</li></ul>



<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vec_detect_complete">vec_detect_complete()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, NA, 4, NA)

vec_detect_missing(x)
vec_any_missing(x)

# Data frames are iterated over rowwise, and only report a row as missing
# if every element of that row is missing. If a row is only partially
# missing, it is said to be incomplete, but not missing.
y &lt;- c("a", "b", NA, "d", "e")
df &lt;- data_frame(x = x, y = y)

df$missing &lt;- vec_detect_missing(df)
df$incomplete &lt;- !vec_detect_complete(df)
df
</code></pre>

<hr>
<h2 id='name_spec'>Name specifications</h2><span id='topic+name_spec'></span>

<h3>Description</h3>

<p>A name specification describes how to combine an inner and outer
names. This sort of name combination arises when concatenating
vectors or flattening lists. There are two possible cases:
</p>

<ul>
<li><p> Named vector:
</p>
<div class="sourceCode"><pre>vec_c(outer = c(inner1 = 1, inner2 = 2))
</pre></div>
</li>
<li><p> Unnamed vector:
</p>
<div class="sourceCode"><pre>vec_c(outer = 1:2)
</pre></div>
</li></ul>

<p>In r-lib and tidyverse packages, these cases are errors by default,
because there's no behaviour that works well for every case.
Instead, you can provide a name specification that describes how to
combine the inner and outer names of inputs. Name specifications
can refer to:
</p>

<ul>
<li> <p><code>outer</code>: The external name recycled to the size of the input
vector.
</p>
</li>
<li> <p><code>inner</code>: Either the names of the input vector, or a sequence of
integer from 1 to the size of the vector if it is unnamed.
</p>
</li></ul>



<h3>Arguments</h3>

<table>
<tr><td><code id="name_spec_+3A_name_spec">name_spec</code>, <code id="name_spec_+3A_.name_spec">.name_spec</code></td>
<td>
<p>A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like <code>outer = c(inner = 1)</code>, or when they have length greater than 1: <code>outer = 1:2</code>. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
</p>

<ul>
<li><p> A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
</p>
</li>
<li><p> An anonymous function as a purrr-style formula.
</p>
</li>
<li><p> A glue specification of the form <code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> An <code><a href="rlang.html#topic+zap">rlang::zap()</a></code> object, in which case both outer and inner
names are ignored and the result is unnamed.
</p>
</li></ul>

<p>See the <a href="#topic+name_spec">name specification topic</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># By default, named inputs must be length 1:
vec_c(name = 1)         # ok
try(vec_c(name = 1:3))  # bad

# They also can't have internal names, even if scalar:
try(vec_c(name = c(internal = 1)))  # bad

# Pass a name specification to work around this. A specification
# can be a glue string referring to `outer` and `inner`:
vec_c(name = 1:3, other = 4:5, .name_spec = "{outer}")
vec_c(name = 1:3, other = 4:5, .name_spec = "{outer}_{inner}")

# They can also be functions:
my_spec &lt;- function(outer, inner) paste(outer, inner, sep = "_")
vec_c(name = 1:3, other = 4:5, .name_spec = my_spec)

# Or purrr-style formulas for anonymous functions:
vec_c(name = 1:3, other = 4:5, .name_spec = ~ paste0(.x, .y))
</code></pre>

<hr>
<h2 id='new_data_frame'>Assemble attributes for data frame construction</h2><span id='topic+new_data_frame'></span>

<h3>Description</h3>

<p><code>new_data_frame()</code> constructs a new data frame from an existing list. It is
meant to be performant, and does not check the inputs for correctness in any
way. It is only safe to use after a call to <code><a href="#topic+df_list">df_list()</a></code>, which collects and
validates the columns used to construct the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_data_frame(x = list(), n = NULL, ..., class = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_data_frame_+3A_x">x</code></td>
<td>
<p>A named list of equal-length vectors. The lengths are not
checked; it is responsibility of the caller to make sure they are
equal.</p>
</td></tr>
<tr><td><code id="new_data_frame_+3A_n">n</code></td>
<td>
<p>Number of rows. If <code>NULL</code>, will be computed from the length of
the first element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="new_data_frame_+3A_...">...</code>, <code id="new_data_frame_+3A_class">class</code></td>
<td>
<p>Additional arguments for creating subclasses.
</p>
<p>The following attributes have special behavior:
</p>

<ul>
<li> <p><code>"names"</code> is preferred if provided, overriding existing names in <code>x</code>.
</p>
</li>
<li> <p><code>"row.names"</code> is preferred if provided, overriding both <code>n</code> and the size
implied by <code>x</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+df_list">df_list()</a></code> for a way to safely construct a data frame's underlying
data structure from individual columns. This can be used to create a
named list for further use by <code>new_data_frame()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_data_frame(list(x = 1:10, y = 10:1))
</code></pre>

<hr>
<h2 id='new_date'>Date, date-time, and duration S3 classes</h2><span id='topic+new_date'></span><span id='topic+new_datetime'></span><span id='topic+new_duration'></span><span id='topic+vec_ptype2.Date'></span><span id='topic+vec_ptype2.POSIXct'></span><span id='topic+vec_ptype2.POSIXlt'></span><span id='topic+vec_ptype2.difftime'></span><span id='topic+vec_cast.Date'></span><span id='topic+vec_cast.POSIXct'></span><span id='topic+vec_cast.POSIXlt'></span><span id='topic+vec_cast.difftime'></span><span id='topic+vec_arith.Date'></span><span id='topic+vec_arith.POSIXct'></span><span id='topic+vec_arith.POSIXlt'></span><span id='topic+vec_arith.difftime'></span>

<h3>Description</h3>


<ul>
<li><p> A <code>date</code> (<a href="base.html#topic+Date">Date</a>) is a double vector. Its value represent the number
of days since the Unix &quot;epoch&quot;, 1970-01-01. It has no attributes.
</p>
</li>
<li><p> A <code>datetime</code> (<a href="base.html#topic+POSIXct">POSIXct</a> is a double vector. Its value represents the
number of seconds since the Unix &quot;Epoch&quot;, 1970-01-01. It has a single
attribute: the timezone (<code>tzone</code>))
</p>
</li>
<li><p> A <code>duration</code> (<a href="base.html#topic+difftime">difftime</a>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>new_date(x = double())

new_datetime(x = double(), tzone = "")

new_duration(x = double(), units = c("secs", "mins", "hours", "days", "weeks"))

## S3 method for class 'Date'
vec_ptype2(x, y, ...)

## S3 method for class 'POSIXct'
vec_ptype2(x, y, ...)

## S3 method for class 'POSIXlt'
vec_ptype2(x, y, ...)

## S3 method for class 'difftime'
vec_ptype2(x, y, ...)

## S3 method for class 'Date'
vec_cast(x, to, ...)

## S3 method for class 'POSIXct'
vec_cast(x, to, ...)

## S3 method for class 'POSIXlt'
vec_cast(x, to, ...)

## S3 method for class 'difftime'
vec_cast(x, to, ...)

## S3 method for class 'Date'
vec_arith(op, x, y, ...)

## S3 method for class 'POSIXct'
vec_arith(op, x, y, ...)

## S3 method for class 'POSIXlt'
vec_arith(op, x, y, ...)

## S3 method for class 'difftime'
vec_arith(op, x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_date_+3A_x">x</code></td>
<td>
<p>A double vector representing the number of days since UNIX
epoch for <code>new_date()</code>, number of seconds since UNIX epoch for
<code>new_datetime()</code>, and number of <code>units</code> for <code>new_duration()</code>.</p>
</td></tr>
<tr><td><code id="new_date_+3A_tzone">tzone</code></td>
<td>
<p>Time zone. A character vector of length 1. Either <code>""</code> for
the local time zone, or a value from <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code></p>
</td></tr>
<tr><td><code id="new_date_+3A_units">units</code></td>
<td>
<p>Units of duration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function help the base <code>Date</code>, <code>POSIXct</code>, and <code>difftime</code> classes fit
into the vctrs type system by providing constructors, coercion functions,
and casting functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>new_date(0)
new_datetime(0, tzone = "UTC")
new_duration(1, "hours")
</code></pre>

<hr>
<h2 id='new_factor'>Factor/ordered factor S3 class</h2><span id='topic+new_factor'></span><span id='topic+new_ordered'></span><span id='topic+vec_ptype2.factor'></span><span id='topic+vec_ptype2.ordered'></span><span id='topic+vec_cast.factor'></span><span id='topic+vec_cast.ordered'></span>

<h3>Description</h3>

<p>A <a href="base.html#topic+factor">factor</a> is an integer with attribute <code>levels</code>, a character vector. There
should be one level for each integer between 1 and <code>max(x)</code>.
An <a href="base.html#topic+ordered">ordered</a> factor has the same properties as a factor, but possesses
an extra class that marks levels as having a total ordering.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_factor(x = integer(), levels = character(), ..., class = character())

new_ordered(x = integer(), levels = character())

## S3 method for class 'factor'
vec_ptype2(x, y, ...)

## S3 method for class 'ordered'
vec_ptype2(x, y, ...)

## S3 method for class 'factor'
vec_cast(x, to, ...)

## S3 method for class 'ordered'
vec_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_factor_+3A_x">x</code></td>
<td>
<p>Integer values which index in to <code>levels</code>.</p>
</td></tr>
<tr><td><code id="new_factor_+3A_levels">levels</code></td>
<td>
<p>Character vector of labels.</p>
</td></tr>
<tr><td><code id="new_factor_+3A_...">...</code>, <code id="new_factor_+3A_class">class</code></td>
<td>
<p>Used to for subclasses.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions help the base factor and ordered factor classes fit in to
the vctrs type system by providing constructors, coercion functions,
and casting functions. <code>new_factor()</code> and <code>new_ordered()</code> are low-level
constructors - they only check that types, but not values, are valid, so
are for expert use only.
</p>

<hr>
<h2 id='new_list_of'>Create list_of subclass</h2><span id='topic+new_list_of'></span>

<h3>Description</h3>

<p>Create list_of subclass
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_list_of(x = list(), ptype = logical(), ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_list_of_+3A_x">x</code></td>
<td>
<p>A list</p>
</td></tr>
<tr><td><code id="new_list_of_+3A_ptype">ptype</code></td>
<td>
<p>The prototype which every element of <code>x</code> belongs to</p>
</td></tr>
<tr><td><code id="new_list_of_+3A_...">...</code></td>
<td>
<p>Additional attributes used by subclass</p>
</td></tr>
<tr><td><code id="new_list_of_+3A_class">class</code></td>
<td>
<p>Optional subclass name</p>
</td></tr>
</table>

<hr>
<h2 id='new_partial'>Partial type</h2><span id='topic+new_partial'></span><span id='topic+is_partial'></span><span id='topic+vec_ptype_finalise'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Use <code>new_partial()</code> when constructing a new partial type subclass;
and use <code>is_partial()</code> to test if a type is partial. All subclasses
need to provide a <code>vec_ptype_finalise()</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_partial(..., class = character())

is_partial(x)

vec_ptype_finalise(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_partial_+3A_...">...</code></td>
<td>
<p>Attributes of the partial type</p>
</td></tr>
<tr><td><code id="new_partial_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As the name suggests, a partial type <em>partially</em> specifies a type, and
it must be combined with data to yield a full type. A useful example
of a partial type is <code><a href="#topic+partial_frame">partial_frame()</a></code>, which makes it possible to
specify the type of just a few columns in a data frame. Use this constructor
if you're making your own partial type.
</p>

<hr>
<h2 id='new_rcrd'>rcrd (record) S3 class</h2><span id='topic+new_rcrd'></span><span id='topic+ses'></span><span id='topic+rcrd'></span>

<h3>Description</h3>

<p>The rcrd class extends <a href="#topic+vctr">vctr</a>. A rcrd is composed of 1 or more <a href="#topic+field">field</a>s,
which must be vectors of the same length. Is designed specifically for
classes that can naturally be decomposed into multiple vectors of the same
length, like <a href="base.html#topic+POSIXlt">POSIXlt</a>, but where the organisation should be considered
an implementation detail invisible to the user (unlike a <a href="base.html#topic+data.frame">data.frame</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_rcrd(fields, ..., class = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_rcrd_+3A_fields">fields</code></td>
<td>
<p>A list or a data frame. Lists must be rectangular
(same sizes), and contain uniquely named vectors (at least
one). <code>fields</code> is validated with <code><a href="#topic+df_list">df_list()</a></code> to ensure uniquely
named vectors.</p>
</td></tr>
<tr><td><code id="new_rcrd_+3A_...">...</code></td>
<td>
<p>Additional attributes</p>
</td></tr>
<tr><td><code id="new_rcrd_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
</table>

<hr>
<h2 id='new_vctr'>vctr (vector) S3 class</h2><span id='topic+new_vctr'></span><span id='topic+vctr'></span>

<h3>Description</h3>

<p>This abstract class provides a set of useful default methods that makes it
considerably easier to get started with a new S3 vector class. See
<code>vignette("s3-vector")</code> to learn how to use it to create your own S3
vector classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_vctr(.data, ..., class = character(), inherit_base_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="new_vctr_+3A_.data">.data</code></td>
<td>
<p>Foundation of class. Must be a vector</p>
</td></tr>
<tr><td><code id="new_vctr_+3A_...">...</code></td>
<td>
<p>Name-value pairs defining attributes</p>
</td></tr>
<tr><td><code id="new_vctr_+3A_class">class</code></td>
<td>
<p>Name of subclass.</p>
</td></tr>
<tr><td><code id="new_vctr_+3A_inherit_base_type">inherit_base_type</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
A single logical, or <code>NULL</code>. Does this class extend the base type of
<code>.data</code>? i.e. does the resulting object extend the behaviour of the
underlying type? Defaults to <code>FALSE</code> for all types except lists, which
are required to inherit from the base type.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>List vctrs are special cases. When created through <code>new_vctr()</code>, the
resulting list vctr should always be recognized as a list by
<code>obj_is_list()</code>. Because of this, if <code>inherit_base_type</code> is <code>FALSE</code>
an error is thrown.
</p>


<h3>Base methods</h3>

<p>The vctr class provides methods for many base generics using a smaller
set of generics defined by this package. Generally, you should think
carefully before overriding any of the methods that vctrs implements for
you as they've been carefully planned to be internally consistent.
</p>

<ul>
<li> <p><code>[[</code> and <code>[</code> use <code>NextMethod()</code> dispatch to the underlying base function,
then restore attributes with <code>vec_restore()</code>.
<code>rep()</code> and <code style="white-space: pre;">&#8288;length&lt;-&#8288;</code> work similarly.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;[[&lt;-&#8288;</code> and <code style="white-space: pre;">&#8288;[&lt;-&#8288;</code> cast <code>value</code> to same type as <code>x</code>, then call
<code>NextMethod()</code>.
</p>
</li>
<li> <p><code>as.logical()</code>, <code>as.integer()</code>, <code>as.numeric()</code>, <code>as.character()</code>,
<code>as.Date()</code> and <code>as.POSIXct()</code> methods call <code>vec_cast()</code>.
The <code>as.list()</code> method calls <code>[[</code> repeatedly, and the <code>as.data.frame()</code>
method uses a standard technique to wrap a vector in a data frame.
</p>
</li>
<li> <p><code>as.factor()</code>, <code>as.ordered()</code> and <code>as.difftime()</code> are not generic functions
in base R, but have been reimplemented as generics in the <code>generics</code>
package. <code>vctrs</code> extends these and calls <code>vec_cast()</code>. To inherit this
behaviour in a package, import and re-export the generic of interest
from <code>generics</code>.
</p>
</li>
<li> <p><code>==</code>, <code>!=</code>, <code>unique()</code>, <code>anyDuplicated()</code>, and <code>is.na()</code> use
<code><a href="#topic+vec_proxy">vec_proxy()</a></code>.
</p>
</li>
<li> <p><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>min()</code>, <code>max()</code>, <code>range()</code>, <code>median()</code>,
<code>quantile()</code>, and <code>xtfrm()</code> methods use <code><a href="#topic+vec_proxy_compare">vec_proxy_compare()</a></code>.
</p>
</li>
<li> <p><code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>!</code>, <code>&amp;</code>, and <code>|</code> operators
use <code><a href="#topic+vec_arith">vec_arith()</a></code>.
</p>
</li>
<li><p> Mathematical operations including the Summary group generics (<code>prod()</code>,
<code>sum()</code>, <code>any()</code>, <code>all()</code>), the Math group generics (<code>abs()</code>, <code>sign()</code>,
etc), <code>mean()</code>, <code>is.nan()</code>, <code>is.finite()</code>, and <code>is.infinite()</code>
use <code><a href="#topic+vec_math">vec_math()</a></code>.
</p>
</li>
<li> <p><code>dims()</code>, <code style="white-space: pre;">&#8288;dims&lt;-&#8288;</code>, <code>dimnames()</code>, <code style="white-space: pre;">&#8288;dimnames&lt;-&#8288;</code>, <code>levels()</code>, and
<code style="white-space: pre;">&#8288;levels&lt;-&#8288;</code> methods throw errors.
</p>
</li></ul>


<hr>
<h2 id='obj_is_list'>List checks</h2><span id='topic+obj_is_list'></span><span id='topic+obj_check_list'></span><span id='topic+list_all_vectors'></span><span id='topic+list_check_all_vectors'></span><span id='topic+list_all_size'></span><span id='topic+list_check_all_size'></span>

<h3>Description</h3>


<ul>
<li> <p><code>obj_is_list()</code> tests if <code>x</code> is considered a list in the vctrs sense. It
returns <code>TRUE</code> if:
</p>

<ul>
<li> <p><code>x</code> is a bare list with no class.
</p>
</li>
<li> <p><code>x</code> is a list explicitly inheriting from <code>"list"</code>.
</p>
</li></ul>

</li>
<li> <p><code>list_all_vectors()</code> takes a list and returns <code>TRUE</code> if all elements of
that list are vectors.
</p>
</li>
<li> <p><code>list_all_size()</code> takes a list and returns <code>TRUE</code> if all elements of that
list have the same <code>size</code>.
</p>
</li>
<li> <p><code>obj_check_list()</code>, <code>list_check_all_vectors()</code>, and <code>list_check_all_size()</code>
use the above functions, but throw a standardized and informative error if
they return <code>FALSE</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>obj_is_list(x)

obj_check_list(x, ..., arg = caller_arg(x), call = caller_env())

list_all_vectors(x)

list_check_all_vectors(x, ..., arg = caller_arg(x), call = caller_env())

list_all_size(x, size)

list_check_all_size(x, size, ..., arg = caller_arg(x), call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_is_list_+3A_x">x</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;vec_*()&#8288;</code> functions, an object. For <code style="white-space: pre;">&#8288;list_*()&#8288;</code> functions, a
list.</p>
</td></tr>
<tr><td><code id="obj_is_list_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="obj_is_list_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="obj_is_list_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="obj_is_list_+3A_size">size</code></td>
<td>
<p>The size to check each element for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notably, data frames and S3 record style classes like POSIXlt are not
considered lists.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list_sizes">list_sizes()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>obj_is_list(list())
obj_is_list(list_of(1))
obj_is_list(data.frame())

list_all_vectors(list(1, mtcars))
list_all_vectors(list(1, environment()))

list_all_size(list(1:2, 2:3), 2)
list_all_size(list(1:2, 2:4), 2)

# `list_`-prefixed functions assume a list:
try(list_all_vectors(environment()))
</code></pre>

<hr>
<h2 id='obj_print'><code>print()</code> and <code>str()</code> generics.</h2><span id='topic+obj_print'></span><span id='topic+obj_print_header'></span><span id='topic+obj_print_data'></span><span id='topic+obj_print_footer'></span><span id='topic+obj_str'></span><span id='topic+obj_str_header'></span><span id='topic+obj_str_data'></span><span id='topic+obj_str_footer'></span>

<h3>Description</h3>

<p>These are constructed to be more easily extensible since you can override
the <code style="white-space: pre;">&#8288;_header()&#8288;</code>, <code style="white-space: pre;">&#8288;_data()&#8288;</code> or <code style="white-space: pre;">&#8288;_footer()&#8288;</code> components individually. The
default methods are built on top of <code>format()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obj_print(x, ...)

obj_print_header(x, ...)

obj_print_data(x, ...)

obj_print_footer(x, ...)

obj_str(x, ...)

obj_str_header(x, ...)

obj_str_data(x, ...)

obj_str_footer(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obj_print_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="obj_print_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to methods. See <code><a href="base.html#topic+print">print()</a></code> and
<code><a href="utils.html#topic+str">str()</a></code> for commonly used options</p>
</td></tr>
</table>

<hr>
<h2 id='order-radix'>Order and sort vectors</h2><span id='topic+order-radix'></span><span id='topic+vec_order_radix'></span><span id='topic+vec_sort_radix'></span>

<h3>Description</h3>

<p><code>vec_order_radix()</code> computes the order of <code>x</code>. For data frames, the order is
computed along the rows by computing the order of the first column and
using subsequent columns to break ties.
</p>
<p><code>vec_sort_radix()</code> sorts <code>x</code>. It is equivalent to <code>vec_slice(x, vec_order_radix(x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_order_radix(
  x,
  ...,
  direction = "asc",
  na_value = "largest",
  nan_distinct = FALSE,
  chr_proxy_collate = NULL
)

vec_sort_radix(
  x,
  ...,
  direction = "asc",
  na_value = "largest",
  nan_distinct = FALSE,
  chr_proxy_collate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="order-radix_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="order-radix_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="order-radix_+3A_direction">direction</code></td>
<td>
<p>Direction to sort in.
</p>

<ul>
<li><p> A single <code>"asc"</code> or <code>"desc"</code> for ascending or descending order
respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"asc"</code> or <code>"desc"</code>, specifying the direction for each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="order-radix_+3A_na_value">na_value</code></td>
<td>
<p>Ordering of missing values.
</p>

<ul>
<li><p> A single <code>"largest"</code> or <code>"smallest"</code> for ordering missing values as the
largest or smallest values respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"largest"</code> or <code>"smallest"</code>, specifying how missing values should
be ordered within each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="order-radix_+3A_nan_distinct">nan_distinct</code></td>
<td>
<p>A single logical specifying whether or not <code>NaN</code> should
be considered distinct from <code>NA</code> for double and complex vectors. If <code>TRUE</code>,
<code>NaN</code> will always be ordered between <code>NA</code> and non-missing numbers.</p>
</td></tr>
<tr><td><code id="order-radix_+3A_chr_proxy_collate">chr_proxy_collate</code></td>
<td>
<p>A function generating an alternate representation
of character vectors to use for collation, often used for locale-aware
ordering.
</p>

<ul>
<li><p> If <code>NULL</code>, no transformation is done.
</p>
</li>
<li><p> Otherwise, this must be a function of one argument. If the input contains
a character vector, it will be passed to this function after it has been
translated to UTF-8. This function should return a character vector with
the same length as the input. The result should sort as expected in the
C-locale, regardless of encoding.
</p>
</li></ul>

<p>For data frames, <code>chr_proxy_collate</code> will be applied to all character
columns.
</p>
<p>Common transformation functions include: <code>tolower()</code> for case-insensitive
ordering and <code>stringi::stri_sort_key()</code> for locale-aware ordering.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_order_radix()</code> an integer vector the same size as <code>x</code>.
</p>
</li>
<li> <p><code>vec_sort_radix()</code> a vector with the same size and type as <code>x</code>.
</p>
</li></ul>



<h3>Differences with <code>order()</code></h3>

<p>Unlike the <code>na.last</code> argument of <code>order()</code> which decides the positions of
missing values irrespective of the <code>decreasing</code> argument, the <code>na_value</code>
argument of <code>vec_order_radix()</code> interacts with <code>direction</code>. If missing values
are considered the largest value, they will appear last in ascending order,
and first in descending order.
</p>
<p>Character vectors are ordered in the C-locale. This is different from
<code>base::order()</code>, which respects <code>base::Sys.setlocale()</code>. Sorting in a
consistent locale can produce more reproducible results between different
sessions and platforms, however, the results of sorting in the C-locale
can be surprising. For example, capital letters sort before lower case
letters. Sorting <code>c("b", "C", "a")</code> with <code>vec_sort_radix()</code> will return
<code>c("C", "a", "b")</code>, but with <code>base::order()</code> will return <code>c("a", "b", "C")</code>
unless <code>base::order(method = "radix")</code> is explicitly set, which also uses
the C-locale. While sorting with the C-locale can be useful for
algorithmic efficiency, in many real world uses it can be the cause of
data analysis mistakes. To balance these trade-offs, you can supply a
<code>chr_proxy_collate</code> function to transform character vectors into an
alternative representation that orders in the C-locale in a less surprising
way. For example, providing <code><a href="base.html#topic+chartr">base::tolower()</a></code> as a transform will order the
original vector in a case-insensitive manner. Locale-aware ordering can be
achieved by providing <code>stringi::stri_sort_key()</code> as a transform, setting the
collation options as appropriate for your locale.
</p>
<p>Character vectors are always translated to UTF-8 before ordering, and before
any transform is applied by <code>chr_proxy_collate</code>.
</p>
<p>For complex vectors, if either the real or imaginary component is <code>NA</code> or
<code>NaN</code>, then the entire observation is considered missing.
</p>


<h3>Dependencies of <code>vec_order_radix()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_order">vec_proxy_order()</a></code>
</p>
</li></ul>



<h3>Dependencies of <code>vec_sort_radix()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_order_radix">vec_order_radix()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (FALSE) {

x &lt;- round(sample(runif(5), 9, replace = TRUE), 3)
x &lt;- c(x, NA)

vec_order_radix(x)
vec_sort_radix(x)
vec_sort_radix(x, direction = "desc")

# Can also handle data frames
df &lt;- data.frame(g = sample(2, 10, replace = TRUE), x = x)
vec_order_radix(df)
vec_sort_radix(df)
vec_sort_radix(df, direction = "desc")

# For data frames, `direction` and `na_value` are allowed to be vectors
# with length equal to the number of columns in the data frame
vec_sort_radix(
  df,
  direction = c("desc", "asc"),
  na_value = c("largest", "smallest")
)

# Character vectors are ordered in the C locale, which orders capital letters
# below lowercase ones
y &lt;- c("B", "A", "a")
vec_sort_radix(y)

# To order in a case-insensitive manner, provide a `chr_proxy_collate`
# function that transforms the strings to all lowercase
vec_sort_radix(y, chr_proxy_collate = tolower)

}
</code></pre>

<hr>
<h2 id='partial_factor'>Partially specify a factor</h2><span id='topic+partial_factor'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This special class can be passed as a <code>ptype</code> in order to specify that the
result should be a factor that contains at least the specified levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_factor(levels = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_factor_+3A_levels">levels</code></td>
<td>
<p>Character vector of labels.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pf &lt;- partial_factor(levels = c("x", "y"))
pf

vec_ptype_common(factor("v"), factor("w"), .ptype = pf)

</code></pre>

<hr>
<h2 id='partial_frame'>Partially specify columns of a data frame</h2><span id='topic+partial_frame'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This special class can be passed to <code>.ptype</code> in order to specify the
types of only some of the columns in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial_frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial_frame_+3A_...">...</code></td>
<td>
<p>Attributes of subclass</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>pf &lt;- partial_frame(x = double())
pf

vec_rbind(
  data.frame(x = 1L, y = "a"),
  data.frame(x = FALSE, z = 10),
  .ptype = partial_frame(x = double(), a = character())
)
</code></pre>

<hr>
<h2 id='reference-faq-compatibility'>FAQ - Is my class compatible with vctrs?</h2><span id='topic+reference-faq-compatibility'></span>

<h3>Description</h3>

<p>vctrs provides a framework for working with vector classes in a generic
way. However, it implements several compatibility fallbacks to base R
methods. In this reference you will find how vctrs tries to be
compatible with your vector class, and what base methods you need to
implement for compatibility.
</p>
<p>If you’re starting from scratch, we think you’ll find it easier to start
using <code><a href="#topic+new_vctr">new_vctr()</a></code> as documented in
<code>vignette("s3-vector")</code>. This guide is aimed for developers with
existing vector classes.
</p>


<h4>Aggregate operations with fallbacks</h4>

<p>All vctrs operations are based on four primitive generics described in
the next section. However there are many higher level operations. The
most important ones implement fallbacks to base generics for maximum
compatibility with existing classes.
</p>

<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code> falls back to the base <code>[</code> generic if no
<code><a href="#topic+vec_proxy">vec_proxy()</a></code> method is implemented. This way foreign
classes that do not implement <code><a href="#topic+vec_restore">vec_restore()</a></code> can
restore attributes based on the new subsetted contents.
</p>
</li>
<li> <p><code><a href="#topic+vec_c">vec_c()</a></code> and <code><a href="#topic+vec_rbind">vec_rbind()</a></code> now fall back to
<code><a href="base.html#topic+c">base::c()</a></code> if the inputs have a common parent class with
a <code>c()</code> method (only if they have no self-to-self <code>vec_ptype2()</code>
method).
</p>
<p>vctrs works hard to make your <code>c()</code> method success in various
situations (with <code>NULL</code> and <code>NA</code> inputs, even as first input which
would normally prevent dispatch to your method). The main downside
compared to using vctrs primitives is that you can’t combine vectors
of different classes since there is no extensible mechanism of
coercion in <code>c()</code>, and it is less efficient in some cases.
</p>
</li></ul>




<h4>The vctrs primitives</h4>

<p>Most functions in vctrs are aggregate operations: they call other vctrs
functions which themselves call other vctrs functions. The dependencies
of a vctrs functions are listed in the Dependencies section of its
documentation page. Take a look at <code><a href="#topic+vec_count">vec_count()</a></code> for an
example.
</p>
<p>These dependencies form a tree whose leaves are the four vctrs
primitives. Here is the diagram for <code>vec_count()</code>:
</p>
<p><img src="../help/figures/vec-count-deps.png" alt="vec-count-deps.png" />
</p>


<h5>The coercion generics</h5>

<p>The coercion mechanism in vctrs is based on two generics:
</p>

<ul>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li></ul>

<p>See the <a href="#topic+theory-faq-coercion">theory overview</a>.
</p>
<p>Two objects with the same class and the same attributes are always
considered compatible by ptype2 and cast. If the attributes or classes
differ, they throw an incompatible type error.
</p>
<p>Coercion errors are the main source of incompatibility with vctrs. See
the <a href="#topic+howto-faq-coercion">howto guide</a> if you need to implement methods
for these generics.
</p>



<h5>The proxy and restoration generics</h5>


<ul>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_restore">vec_restore()</a></code>
</p>
</li></ul>

<p>These generics are essential for vctrs but mostly optional.
<code>vec_proxy()</code> defaults to an <a href="base.html#topic+identity">identity</a> function and you
normally don’t need to implement it. The proxy a vector must be one of
the atomic vector types, a list, or a data frame. By default, S3 lists
that do not inherit from <code>"list"</code> do not have an identity proxy. In that
case, you need to explicitly implement <code>vec_proxy()</code> or make your class
inherit from list.
</p>



<hr>
<h2 id='runs'>Runs</h2><span id='topic+runs'></span><span id='topic+vec_identify_runs'></span><span id='topic+vec_run_sizes'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_identify_runs()</code> returns a vector of identifiers for the elements of
<code>x</code> that indicate which run of repeated values they fall in. The number of
runs is also returned as an attribute, <code>n</code>.
</p>
</li>
<li> <p><code>vec_run_sizes()</code> returns an integer vector corresponding to the size of
each run. This is identical to the <code>times</code> column from <code>vec_unrep()</code>, but
is faster if you don't need the run keys.
</p>
</li>
<li> <p><code><a href="#topic+vec_unrep">vec_unrep()</a></code> is a generalized <code><a href="base.html#topic+rle">base::rle()</a></code>. It is documented alongside
the &quot;repeat&quot; functions of <code><a href="#topic+vec_rep">vec_rep()</a></code> and <code><a href="#topic+vec_rep_each">vec_rep_each()</a></code>; look there for
more information.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_identify_runs(x)

vec_run_sizes(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runs_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="base.html#topic+rle">base::rle()</a></code>, adjacent missing values are considered identical when
constructing runs. For example, <code>vec_identify_runs(c(NA, NA))</code> will return
<code>c(1, 1)</code>, not <code>c(1, 2)</code>.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>vec_identify_runs()</code>, an integer vector with the same size as <code>x</code>. A
scalar integer attribute, <code>n</code>, is attached.
</p>
</li>
<li><p> For <code>vec_run_sizes()</code>, an integer vector with size equal to the number of
runs in <code>x</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vec_unrep">vec_unrep()</a></code> for a generalized <code><a href="base.html#topic+rle">base::rle()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "z", "z", "c", "a", "a")

vec_identify_runs(x)
vec_run_sizes(x)
vec_unrep(x)

y &lt;- c(1, 1, 1, 2, 2, 3)

# With multiple columns, the runs are constructed rowwise
df &lt;- data_frame(
  x = x,
  y = y
)

vec_identify_runs(df)
vec_run_sizes(df)
vec_unrep(df)
</code></pre>

<hr>
<h2 id='s3_register'>Register a method for a suggested dependency</h2><span id='topic+s3_register'></span>

<h3>Description</h3>

<p>Generally, the recommend way to register an S3 method is to use the
<code>S3Method()</code> namespace directive (often generated automatically by the
<code style="white-space: pre;">&#8288;@export&#8288;</code> roxygen2 tag). However, this technique requires that the generic
be in an imported package, and sometimes you want to suggest a package,
and only provide a method when that package is loaded. <code>s3_register()</code>
can be called from your package's <code>.onLoad()</code> to dynamically register
a method only if the generic's package is loaded.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="s3_register_+3A_generic">generic</code></td>
<td>
<p>Name of the generic in the form <code>pkg::generic</code>.</p>
</td></tr>
<tr><td><code id="s3_register_+3A_class">class</code></td>
<td>
<p>Name of the class</p>
</td></tr>
<tr><td><code id="s3_register_+3A_method">method</code></td>
<td>
<p>Optionally, the implementation of the method. By default,
this will be found by looking for a function called <code>generic.class</code>
in the package environment.
</p>
<p>Note that providing <code>method</code> can be dangerous if you use
devtools. When the namespace of the method is reloaded by
<code>devtools::load_all()</code>, the function will keep inheriting from
the old namespace. This might cause crashes because of dangling
<code>.Call()</code> pointers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R 3.5.0 and later, <code>s3_register()</code> is also useful when demonstrating
class creation in a vignette, since method lookup no longer always involves
the lexical scope. For R 3.6.0 and later, you can achieve a similar effect
by using &quot;delayed method registration&quot;, i.e. placing the following in your
<code>NAMESPACE</code> file:
</p>
<div class="sourceCode"><pre>if (getRversion() &gt;= "3.6.0") {
  S3method(package::generic, class)
}
</pre></div>


<h3>Usage in other packages</h3>

<p>To avoid taking a dependency on vctrs, you copy the source of
<a href="https://github.com/r-lib/vctrs/blob/main/R/register-s3.R"><code>s3_register()</code></a>
into your own package. It is licensed under the permissive
<a href="https://choosealicense.com/licenses/unlicense/">unlicense</a> to make it
crystal clear that we're happy for you to do this. There's no need to include
the license or even credit us when using this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A typical use case is to dynamically register tibble/pillar methods
# for your class. That way you avoid creating a hard dependency on packages
# that are not essential, while still providing finer control over
# printing when they are used.

.onLoad &lt;- function(...) {
  s3_register("pillar::pillar_shaft", "vctrs_vctr")
  s3_register("tibble::type_sum", "vctrs_vctr")
}
</code></pre>

<hr>
<h2 id='table'>Table S3 class</h2><span id='topic+table'></span>

<h3>Description</h3>

<p>These functions help the base table class fit into the vctrs type system
by providing coercion and casting functions.
</p>

<hr>
<h2 id='theory-faq-coercion'>FAQ - How does coercion work in vctrs?</h2><span id='topic+theory-faq-coercion'></span>

<h3>Description</h3>

<p>This is an overview of the usage of <code>vec_ptype2()</code> and <code>vec_cast()</code> and
their role in the vctrs coercion mechanism. Related topics:
</p>

<ul>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li>
<li><p> For a tutorial about implementing vctrs classes from scratch, see
<code>vignette("s3-vector")</code>.
</p>
</li></ul>



<h4>Combination mechanism in vctrs</h4>

<p>The coercion system in vctrs is designed to make combination of multiple
inputs consistent and extensible. Combinations occur in many places,
such as row-binding, joins, subset-assignment, or grouped summary
functions that use the split-apply-combine strategy. For example:
</p>
<div class="sourceCode r"><pre>vec_c(TRUE, 1)
#&gt; [1] 1 1

vec_c("a", 1)
#&gt; Error in `vec_c()`:
#&gt; ! Can't combine `..1` &lt;character&gt; and `..2` &lt;double&gt;.

vec_rbind(
  data.frame(x = TRUE),
  data.frame(x = 1, y = 2)
)
#&gt;   x  y
#&gt; 1 1 NA
#&gt; 2 1  2

vec_rbind(
  data.frame(x = "a"),
  data.frame(x = 1, y = 2)
)
#&gt; Error in `vec_rbind()`:
#&gt; ! Can't combine `..1$x` &lt;character&gt; and `..2$x` &lt;double&gt;.
</pre></div>
<p>One major goal of vctrs is to provide a central place for implementing
the coercion methods that make generic combinations possible. The two
relevant generics are <code>vec_ptype2()</code> and <code>vec_cast()</code>. They both take
two arguments and perform <strong>double dispatch</strong>, meaning that a method is
selected based on the classes of both inputs.
</p>
<p>The general mechanism for combining multiple inputs is:
</p>

<ol>
<li><p> Find the common type of a set of inputs by reducing (as in
<code>base::Reduce()</code> or <code>purrr::reduce()</code>) the <code>vec_ptype2()</code> binary
function over the set.
</p>
</li>
<li><p> Convert all inputs to the common type with <code>vec_cast()</code>.
</p>
</li>
<li><p> Initialise the output vector as an instance of this common type with
<code>vec_init()</code>.
</p>
</li>
<li><p> Fill the output vector with the elements of the inputs using
<code>vec_assign()</code>.
</p>
</li></ol>

<p>The last two steps may require <code>vec_proxy()</code> and <code>vec_restore()</code>
implementations, unless the attributes of your class are constant and do
not depend on the contents of the vector. We focus here on the first two
steps, which require <code>vec_ptype2()</code> and <code>vec_cast()</code> implementations.
</p>



<h4><code>vec_ptype2()</code></h4>

<p>Methods for <code>vec_ptype2()</code> are passed two <em>prototypes</em>, i.e. two inputs
emptied of their elements. They implement two behaviours:
</p>

<ul>
<li><p> If the types of their inputs are compatible, indicate which of them is
the richer type by returning it. If the types are of equal resolution,
return any of the two.
</p>
</li>
<li><p> Throw an error with <code>stop_incompatible_type()</code> when it can be
determined from the attributes that the types of the inputs are not
compatible.
</p>
</li></ul>



<h5>Type compatibility</h5>

<p>A type is <strong>compatible</strong> with another type if the values it represents
are a subset or a superset of the values of the other type. The notion
of “value” is to be interpreted at a high level, in particular it is not
the same as the memory representation. For example, factors are
represented in memory with integers but their values are more related to
character vectors than to round numbers:
</p>
<div class="sourceCode r"><pre># Two factors are compatible
vec_ptype2(factor("a"), factor("b"))
#&gt; factor()
#&gt; Levels: a b

# Factors are compatible with a character
vec_ptype2(factor("a"), "b")
#&gt; character(0)

# But they are incompatible with integers
vec_ptype2(factor("a"), 1L)
#&gt; Error:
#&gt; ! Can't combine `factor("a")` &lt;factor&lt;4d52a&gt;&gt; and `1L` &lt;integer&gt;.
</pre></div>



<h5>Richness of type</h5>

<p>Richness of type is not a very precise notion. It can be about richer
data (for instance a <code>double</code> vector covers more values than an integer
vector), richer behaviour (a <code>data.table</code> has richer behaviour than a
<code>data.frame</code>), or both. If you have trouble determining which one of the
two types is richer, it probably means they shouldn’t be automatically
coercible.
</p>
<p>Let’s look again at what happens when we combine a factor and a
character:
</p>
<div class="sourceCode r"><pre>vec_ptype2(factor("a"), "b")
#&gt; character(0)
</pre></div>
<p>The ptype2 method for <code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> and <code style="white-space: pre;">&#8288;&lt;factor&lt;"a"&gt;&gt;&#8288;</code> returns
<code style="white-space: pre;">&#8288;&lt;character&gt;&#8288;</code> because the former is a richer type. The factor can only
contain <code>"a"</code> strings, whereas the character can contain any strings. In
this sense, factors are a <em>subset</em> of character.
</p>
<p>Note that another valid behaviour would be to throw an incompatible type
error. This is what a strict factor implementation would do. We have
decided to be laxer in vctrs because it is easy to inadvertently create
factors instead of character vectors, especially with older versions of
R where <code>stringsAsFactors</code> is still true by default.
</p>



<h5>Consistency and symmetry on permutation</h5>

<p>Each ptype2 method should strive to have exactly the same behaviour when
the inputs are permuted. This is not always possible, for example factor
levels are aggregated in order:
</p>
<div class="sourceCode r"><pre>vec_ptype2(factor(c("a", "c")), factor("b"))
#&gt; factor()
#&gt; Levels: a c b

vec_ptype2(factor("b"), factor(c("a", "c")))
#&gt; factor()
#&gt; Levels: b a c
</pre></div>
<p>In any case, permuting the input should not return a fundamentally
different type or introduce an incompatible type error.
</p>



<h5>Coercion hierarchy</h5>

<p>The classes that you can coerce together form a coercion (or subtyping)
hierarchy. Below is a schema of the hierarchy for the base types like
integer and factor. In this diagram the directions of the arrows express
which type is richer. They flow from the bottom (more constrained types)
to the top (richer types).
</p>
<p><img src="../help/figures/coerce.png" alt="coerce.png" />
</p>
<p>A coercion hierarchy is distinct from the structural hierarchy implied
by memory types and classes. For instance, in a structural hierarchy,
factors are built on top of integers. But in the coercion hierarchy they
are more related to character vectors. Similarly, subclasses are not
necessarily coercible with their superclasses because the coercion and
structural hierarchies are separate.
</p>



<h5>Implementing a coercion hierarchy</h5>

<p>As a class implementor, you have two options. The simplest is to create
an entirely separate hierarchy. The date and date-time classes are an
example of an S3-based hierarchy that is completely separate.
Alternatively, you can integrate your class in an existing hierarchy,
typically by adding parent nodes on top of the hierarchy (your class is
richer), by adding children node at the root of the hierarchy (your
class is more constrained), or by inserting a node in the tree.
</p>
<p>These coercion hierarchies are <em>implicit</em>, in the sense that they are
implied by the <code>vec_ptype2()</code> implementations. There is no structured
way to create or modify a hierarchy, instead you need to implement the
appropriate coercion methods for all the types in your hierarchy, and
diligently return the richer type in each case. The <code>vec_ptype2()</code>
implementations are not transitive nor inherited, so all pairwise
methods between classes lying on a given path must be implemented
manually. This is something we might make easier in the future.
</p>




<h4><code>vec_cast()</code></h4>

<p>The second generic, <code>vec_cast()</code>, is the one that looks at the data and
actually performs the conversion. Because it has access to more
information than <code>vec_ptype2()</code>, it may be stricter and cause an error
in more cases. <code>vec_cast()</code> has three possible behaviours:
</p>

<ul>
<li><p> Determine that the prototypes of the two inputs are not compatible.
This must be decided in exactly the same way as for <code>vec_ptype2()</code>.
Call <code>stop_incompatible_cast()</code> if you can determine from the
attributes that the types are not compatible.
</p>
</li>
<li><p> Detect incompatible values. Usually this is because the target type is
too restricted for the values supported by the input type. For
example, a fractional number can’t be converted to an integer. The
method should throw an error in that case.
</p>
</li>
<li><p> Return the input vector converted to the target type if all values are
compatible. Whereas <code>vec_ptype2()</code> must return the same type when the
inputs are permuted, <code>vec_cast()</code> is <em>directional</em>. It always returns
the type of the right-hand side, or dies trying.
</p>
</li></ul>




<h4>Double dispatch</h4>

<p>The dispatch mechanism for <code>vec_ptype2()</code> and <code>vec_cast()</code> looks like S3
but is actually a custom mechanism. Compared to S3, it has the following
differences:
</p>

<ul>
<li><p> It dispatches on the classes of the first two inputs.
</p>
</li>
<li><p> There is no inheritance of ptype2 and cast methods. This is because
the S3 class hierarchy is not necessarily the same as the coercion
hierarchy.
</p>
</li>
<li> <p><code>NextMethod()</code> does not work. Parent methods must be called explicitly
if necessary.
</p>
</li>
<li><p> The default method is hard-coded.
</p>
</li></ul>




<h4>Data frames</h4>

<p>The determination of the common type of data frames with <code>vec_ptype2()</code>
happens in three steps:
</p>

<ol>
<li><p> Match the columns of the two input data frames. If some columns
don’t exist, they are created and filled with adequately typed <code>NA</code>
values.
</p>
</li>
<li><p> Find the common type for each column by calling <code>vec_ptype2()</code> on
each pair of matched columns.
</p>
</li>
<li><p> Find the common data frame type. For example the common type of a
grouped tibble and a tibble is a grouped tibble because the latter
is the richer type. The common type of a data table and a data frame
is a data table.
</p>
</li></ol>

<p><code>vec_cast()</code> operates similarly. If a data frame is cast to a target
type that has fewer columns, this is an error.
</p>
<p>If you are implementing coercion methods for data frames, you will need
to explicitly call the parent methods that perform the common type
determination or the type conversion described above. These are exported
as <code><a href="#topic+df_ptype2">df_ptype2()</a></code> and <code><a href="#topic+df_cast">df_cast()</a></code>.
</p>


<h5>Data frame fallbacks</h5>

<p>Being too strict with data frame combinations would cause too much pain
because there are many data frame subclasses in the wild that don’t
implement vctrs methods. We have decided to implement a special fallback
behaviour for foreign data frames. Incompatible data frames fall back to
a base data frame:
</p>
<div class="sourceCode r"><pre>df1 &lt;- data.frame(x = 1)
df2 &lt;- structure(df1, class = c("foreign_df", "data.frame"))

vec_rbind(df1, df2)
#&gt;   x
#&gt; 1 1
#&gt; 2 1
</pre></div>
<p>When a tibble is involved, we fall back to tibble:
</p>
<div class="sourceCode r"><pre>df3 &lt;- tibble::as_tibble(df1)

vec_rbind(df1, df3)
#&gt; # A tibble: 2 x 1
#&gt;       x
#&gt;   &lt;dbl&gt;
#&gt; 1     1
#&gt; 2     1
</pre></div>
<p>These fallbacks are not ideal but they make sense because all data
frames share a common data structure. This is not generally the case for
vectors. For example factors and characters have different
representations, and it is not possible to find a fallback time
mechanically.
</p>
<p>However this fallback has a big downside: implementing vctrs methods for
your data frame subclass is a breaking behaviour change. The proper
coercion behaviour for your data frame class should be specified as soon
as possible to limit the consequences of changing the behaviour of your
class in R scripts.
</p>



<hr>
<h2 id='theory-faq-recycling'>FAQ - How does recycling work in vctrs and the tidyverse?</h2><span id='topic+theory-faq-recycling'></span><span id='topic+vector_recycling_rules'></span>

<h3>Description</h3>

<p>Recycling describes the concept of repeating elements of one vector to
match the size of another. There are two rules that underlie the
“tidyverse” recycling rules:
</p>

<ul>
<li><p> Vectors of size 1 will be recycled to the size of any other vector
</p>
</li>
<li><p> Otherwise, all vectors must have the same size
</p>
</li></ul>



<h3>Examples</h3>

<p>Vectors of size 1 are recycled to the size of any other vector:
</p>
<div class="sourceCode r"><pre>tibble(x = 1:3, y = 1L)
#&gt; # A tibble: 3 x 2
#&gt;       x     y
#&gt;   &lt;int&gt; &lt;int&gt;
#&gt; 1     1     1
#&gt; 2     2     1
#&gt; 3     3     1
</pre></div>
<p>This includes vectors of size 0:
</p>
<div class="sourceCode r"><pre>tibble(x = integer(), y = 1L)
#&gt; # A tibble: 0 x 2
#&gt; # i 2 variables: x &lt;int&gt;, y &lt;int&gt;
</pre></div>
<p>If vectors aren’t size 1, they must all be the same size. Otherwise, an
error is thrown:
</p>
<div class="sourceCode r"><pre>tibble(x = 1:3, y = 4:7)
#&gt; Error in `tibble()`:
#&gt; ! Tibble columns must have compatible sizes.
#&gt; * Size 3: Existing data.
#&gt; * Size 4: Column `y`.
#&gt; i Only values of size one are recycled.
</pre></div>


<h3>vctrs backend</h3>

<p>Packages in r-lib and the tidyverse generally use
<code><a href="#topic+vec_size_common">vec_size_common()</a></code> and
<code><a href="#topic+vec_recycle_common">vec_recycle_common()</a></code> as the backends for
handling recycling rules.
</p>

<ul>
<li> <p><code>vec_size_common()</code> returns the common size of multiple vectors, after
applying the recycling rules
</p>
</li>
<li> <p><code>vec_recycle_common()</code> goes one step further, and actually recycles
the vectors to their common size
</p>
</li></ul>

<div class="sourceCode r"><pre>vec_size_common(1:3, "x")
#&gt; [1] 3

vec_recycle_common(1:3, "x")
#&gt; [[1]]
#&gt; [1] 1 2 3
#&gt; 
#&gt; [[2]]
#&gt; [1] "x" "x" "x"

vec_size_common(1:3, c("x", "y"))
#&gt; Error:
#&gt; ! Can't recycle `..1` (size 3) to match `..2` (size 2).
</pre></div>


<h3>Base R recycling rules</h3>

<p>The recycling rules described here are stricter than the ones generally
used by base R, which are:
</p>

<ul>
<li><p> If any vector is length 0, the output will be length 0
</p>
</li>
<li><p> Otherwise, the output will be length <code>max(length_x, length_y)</code>, and a
warning will be thrown if the length of the longer vector is not an
integer multiple of the length of the shorter vector.
</p>
</li></ul>

<p>We explore the base R rules in detail in <code>vignette("type-size")</code>.
</p>

<hr>
<h2 id='unspecified'>A 1d vector of unspecified type</h2><span id='topic+unspecified'></span>

<h3>Description</h3>

<p>This is a <a href="#topic+new_partial">partial type</a> used to represent logical vectors
that only contain <code>NA</code>. These require special handling because we want to
allow <code>NA</code> to specify missingness without requiring a type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unspecified(n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unspecified_+3A_n">n</code></td>
<td>
<p>Length of vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vec_ptype_show()
vec_ptype_show(NA)

vec_c(NA, factor("x"))
vec_c(NA, Sys.Date())
vec_c(NA, Sys.time())
vec_c(NA, list(1:3, 4:5))
</code></pre>

<hr>
<h2 id='vctrs-conditions'>Custom conditions for vctrs package</h2><span id='topic+vctrs-conditions'></span><span id='topic+stop_incompatible_type'></span><span id='topic+stop_incompatible_cast'></span><span id='topic+stop_incompatible_op'></span><span id='topic+stop_incompatible_size'></span><span id='topic+allow_lossy_cast'></span>

<h3>Description</h3>

<p>These functions are called for their side effect of raising
errors and warnings.
These conditions have custom classes and structures to make
testing easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stop_incompatible_type(
  x,
  y,
  ...,
  x_arg,
  y_arg,
  action = c("combine", "convert"),
  details = NULL,
  message = NULL,
  class = NULL,
  call = caller_env()
)

stop_incompatible_cast(
  x,
  to,
  ...,
  x_arg,
  to_arg,
  details = NULL,
  message = NULL,
  class = NULL,
  call = caller_env()
)

stop_incompatible_op(
  op,
  x,
  y,
  details = NULL,
  ...,
  message = NULL,
  class = NULL,
  call = caller_env()
)

stop_incompatible_size(
  x,
  y,
  x_size,
  y_size,
  ...,
  x_arg,
  y_arg,
  details = NULL,
  message = NULL,
  class = NULL,
  call = caller_env()
)

allow_lossy_cast(expr, x_ptype = NULL, to_ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vctrs-conditions_+3A_x">x</code>, <code id="vctrs-conditions_+3A_y">y</code>, <code id="vctrs-conditions_+3A_to">to</code></td>
<td>
<p>Vectors</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_...">...</code>, <code id="vctrs-conditions_+3A_class">class</code></td>
<td>
<p>Only use these fields when creating a subclass.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_x_arg">x_arg</code>, <code id="vctrs-conditions_+3A_y_arg">y_arg</code>, <code id="vctrs-conditions_+3A_to_arg">to_arg</code></td>
<td>
<p>Argument names for <code>x</code>, <code>y</code>, and <code>to</code>. Used in
error messages to inform the user about the locations of incompatible
types.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_action">action</code></td>
<td>
<p>An option to customize the incompatible type message depending
on the context. Errors thrown from <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code> use <code>"combine"</code> and
those thrown from <code><a href="#topic+vec_cast">vec_cast()</a></code> use <code>"convert"</code>.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_details">details</code></td>
<td>
<p>Any additional human readable details.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_message">message</code></td>
<td>
<p>An overriding message for the error. <code>details</code> and
<code>message</code> are mutually exclusive, supplying both is an error.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vctrs-conditions_+3A_x_ptype">x_ptype</code>, <code id="vctrs-conditions_+3A_to_ptype">to_ptype</code></td>
<td>
<p>Suppress only the casting errors where <code>x</code>
or <code>to</code> match these <a href="#topic+vec_ptype">prototypes</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code style="white-space: pre;">&#8288;stop_incompatible_*()&#8288;</code> unconditionally raise an error of class
<code>"vctrs_error_incompatible_*"</code> and <code>"vctrs_error_incompatible"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Most of the time, `maybe_lossy_cast()` returns its input normally:
maybe_lossy_cast(
  c("foo", "bar"),
  NA,
  "",
  lossy = c(FALSE, FALSE),
  x_arg = "",
  to_arg = ""
)

# If `lossy` has any `TRUE`, an error is thrown:
try(maybe_lossy_cast(
  c("foo", "bar"),
  NA,
  "",
  lossy = c(FALSE, TRUE),
  x_arg = "",
  to_arg = ""
))

# Unless lossy casts are allowed:
allow_lossy_cast(
  maybe_lossy_cast(
    c("foo", "bar"),
    NA,
    "",
    lossy = c(FALSE, TRUE),
    x_arg = "",
    to_arg = ""
  )
)

</code></pre>

<hr>
<h2 id='vctrs-data-frame'>vctrs methods for data frames</h2><span id='topic+vctrs-data-frame'></span><span id='topic+vec_ptype2.data.frame'></span><span id='topic+vec_cast.data.frame'></span>

<h3>Description</h3>

<p>These functions help the base data.frame class fit into the vctrs type system
by providing coercion and casting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
vec_ptype2(x, y, ...)

## S3 method for class 'data.frame'
vec_cast(x, to, ...)
</code></pre>

<hr>
<h2 id='vctrs-package'>vctrs: Vector Helpers</h2><span id='topic+vctrs'></span><span id='topic+vctrs-package'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#maturing"><img src="../help/figures/lifecycle-maturing.svg" alt='[Maturing]' /></a>
</p>
<p>Defines new notions of prototype and size that are
used to provide tools for consistent and well-founded type-coercion
and size-recycling, and are in turn connected to ideas of type- and
size-stability useful for analysing function interfaces.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Davis Vaughan <a href="mailto:davis@posit.co">davis@posit.co</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a>
</p>
</li>
<li><p> Lionel Henry <a href="mailto:lionel@posit.co">lionel@posit.co</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> data.table team (Radix sort based on data.table's forder() and their contribution to R's order()) [copyright holder]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://vctrs.r-lib.org/">https://vctrs.r-lib.org/</a>
</p>
</li>
<li> <p><a href="https://github.com/r-lib/vctrs">https://github.com/r-lib/vctrs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/vctrs/issues">https://github.com/r-lib/vctrs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='vec_arith'>Arithmetic operations</h2><span id='topic+vec_arith'></span><span id='topic+vec_arith.default'></span><span id='topic+vec_arith.logical'></span><span id='topic+vec_arith.numeric'></span><span id='topic+vec_arith_base'></span><span id='topic+MISSING'></span>

<h3>Description</h3>

<p>This generic provides a common double dispatch mechanism for all infix
operators (<code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>^</code>, <code>%%</code>, <code>%/%</code>, <code>!</code>, <code>&amp;</code>, <code>|</code>). It is used
to power the default arithmetic and boolean operators for <a href="#topic+vctr">vctr</a>s objects,
overcoming the limitations of the base <a href="methods.html#topic+Ops">Ops</a> generic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_arith(op, x, y, ...)

## Default S3 method:
vec_arith(op, x, y, ...)

## S3 method for class 'logical'
vec_arith(op, x, y, ...)

## S3 method for class 'numeric'
vec_arith(op, x, y, ...)

vec_arith_base(op, x, y)

MISSING()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_arith_+3A_op">op</code></td>
<td>
<p>An arithmetic operator as a string</p>
</td></tr>
<tr><td><code id="vec_arith_+3A_x">x</code>, <code id="vec_arith_+3A_y">y</code></td>
<td>
<p>A pair of vectors. For <code>!</code>, unary <code>+</code> and unary <code>-</code>, <code>y</code> will be
a sentinel object of class <code>MISSING</code>, as created by <code>MISSING()</code>.</p>
</td></tr>
<tr><td><code id="vec_arith_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vec_arith_base()</code> is provided as a convenience for writing methods. It
recycles <code>x</code> and <code>y</code> to common length then calls the base operator with the
underlying <code><a href="#topic+vec_data">vec_data()</a></code>.
</p>
<p><code>vec_arith()</code> is also used in <code>diff.vctrs_vctr()</code> method via <code>-</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stop_incompatible_op">stop_incompatible_op()</a></code> for signalling that an arithmetic
operation is not permitted/supported.
</p>
<p>See <code><a href="#topic+vec_math">vec_math()</a></code> for the equivalent for the unary mathematical
functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- as.Date("2018-01-01")
dt &lt;- as.POSIXct("2018-01-02 12:00")
t &lt;- as.difftime(12, unit = "hours")

vec_arith("-", dt, 1)
vec_arith("-", dt, t)
vec_arith("-", dt, d)

vec_arith("+", dt, 86400)
vec_arith("+", dt, t)
vec_arith("+", t, t)

vec_arith("/", t, t)
vec_arith("/", t, 2)

vec_arith("*", t, 2)
</code></pre>

<hr>
<h2 id='vec_as_index'>Convert to an index vector</h2><span id='topic+vec_as_index'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vec_as_index()</code> has been renamed to <code><a href="#topic+vec_as_location">vec_as_location()</a></code> and is
deprecated as of vctrs 0.2.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_as_index(i, n, names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_as_index_+3A_i">i</code></td>
<td>
<p>An integer, character or logical vector specifying the
locations or names of the observations to get/set. Specify
<code>TRUE</code> to index all elements (as in <code>x[]</code>), or <code>NULL</code>, <code>FALSE</code> or
<code>integer()</code> to index none (as in <code>x[NULL]</code>).</p>
</td></tr>
<tr><td><code id="vec_as_index_+3A_n">n</code></td>
<td>
<p>A single integer representing the total size of the
object that <code>i</code> is meant to index into.</p>
</td></tr>
<tr><td><code id="vec_as_index_+3A_names">names</code></td>
<td>
<p>If <code>i</code> is a character vector, <code>names</code> should be a character
vector that <code>i</code> will be matched against to construct the index. Otherwise,
not used. The default value of <code>NULL</code> will result in an error
if <code>i</code> is a character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_as_location'>Create a vector of locations</h2><span id='topic+vec_as_location'></span><span id='topic+num_as_location'></span><span id='topic+vec_as_location2'></span><span id='topic+num_as_location2'></span>

<h3>Description</h3>

<p>These helpers provide a means of standardizing common indexing
methods such as integer, character or logical indexing.
</p>

<ul>
<li> <p><code>vec_as_location()</code> accepts integer, character, or logical vectors
of any size. The output is always an integer vector that is
suitable for subsetting with <code>[</code> or <code><a href="#topic+vec_slice">vec_slice()</a></code>. It might be a
different size than the input because negative selections are
transformed to positive ones and logical vectors are transformed
to a vector of indices for the <code>TRUE</code> locations.
</p>
</li>
<li> <p><code>vec_as_location2()</code> accepts a single number or string. It returns
a single location as a integer vector of size 1. This is suitable
for extracting with <code>[[</code>.
</p>
</li>
<li> <p><code>num_as_location()</code> and <code>num_as_location2()</code> are specialized variants
that have extra options for numeric indices.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_as_location(
  i,
  n,
  names = NULL,
  ...,
  missing = c("propagate", "remove", "error"),
  arg = caller_arg(i),
  call = caller_env()
)

num_as_location(
  i,
  n,
  ...,
  missing = c("propagate", "remove", "error"),
  negative = c("invert", "error", "ignore"),
  oob = c("error", "remove", "extend"),
  zero = c("remove", "error", "ignore"),
  arg = caller_arg(i),
  call = caller_env()
)

vec_as_location2(
  i,
  n,
  names = NULL,
  ...,
  missing = c("error", "propagate"),
  arg = caller_arg(i),
  call = caller_env()
)

num_as_location2(
  i,
  n,
  ...,
  negative = c("error", "ignore"),
  missing = c("error", "propagate"),
  arg = caller_arg(i),
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_as_location_+3A_i">i</code></td>
<td>
<p>An integer, character or logical vector specifying the
locations or names of the observations to get/set. Specify
<code>TRUE</code> to index all elements (as in <code>x[]</code>), or <code>NULL</code>, <code>FALSE</code> or
<code>integer()</code> to index none (as in <code>x[NULL]</code>).</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_n">n</code></td>
<td>
<p>A single integer representing the total size of the
object that <code>i</code> is meant to index into.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_names">names</code></td>
<td>
<p>If <code>i</code> is a character vector, <code>names</code> should be a character
vector that <code>i</code> will be matched against to construct the index. Otherwise,
not used. The default value of <code>NULL</code> will result in an error
if <code>i</code> is a character vector.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_missing">missing</code></td>
<td>
<p>How should missing <code>i</code> values be handled?
</p>

<ul>
<li> <p><code>"error"</code> throws an error.
</p>
</li>
<li> <p><code>"propagate"</code> returns them as is.
</p>
</li>
<li> <p><code>"remove"</code> removes them.
</p>
</li></ul>

<p>By default, vector subscripts propagate missing values but scalar
subscripts error on them.
</p>
<p>Propagated missing values can't be combined with negative indices when
<code>negative = "invert"</code>, because they can't be meaningfully inverted.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_arg">arg</code></td>
<td>
<p>The argument name to be displayed in error messages.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_as_location_+3A_negative">negative</code></td>
<td>
<p>How should negative <code>i</code> values be handled?
</p>

<ul>
<li> <p><code>"error"</code> throws an error.
</p>
</li>
<li> <p><code>"ignore"</code> returns them as is.
</p>
</li>
<li> <p><code>"invert"</code> returns the positive location generated by inverting the
negative location. When inverting, positive and negative locations
can't be mixed. This option is only applicable for <code>num_as_location()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_as_location_+3A_oob">oob</code></td>
<td>
<p>How should out-of-bounds <code>i</code> values be handled?
</p>

<ul>
<li> <p><code>"error"</code> throws an error.
</p>
</li>
<li> <p><code>"remove"</code> removes both positive and negative out-of-bounds locations.
</p>
</li>
<li> <p><code>"extend"</code> allows positive out-of-bounds locations if they directly
follow the end of a vector. This can be used to implement extendable
vectors, like <code>letters[1:30]</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_as_location_+3A_zero">zero</code></td>
<td>
<p>How should zero <code>i</code> values be handled?
</p>

<ul>
<li> <p><code>"error"</code> throws an error.
</p>
</li>
<li> <p><code>"remove"</code> removes them.
</p>
</li>
<li> <p><code>"ignore"</code> returns them as is.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_as_location()</code> and <code>num_as_location()</code> return an integer vector that
can be used as an index in a subsetting operation.
</p>
</li>
<li> <p><code>vec_as_location2()</code> and <code>num_as_location2()</code> return an integer of size 1
that can be used a scalar index for extracting an element.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- array(1:6, c(2, 3))
dimnames(x) &lt;- list(c("r1", "r2"), c("c1", "c2", "c3"))

# The most common use case validates row indices
vec_as_location(1, vec_size(x))

# Negative indices can be used to index from the back
vec_as_location(-1, vec_size(x))

# Character vectors can be used if `names` are provided
vec_as_location("r2", vec_size(x), rownames(x))

# You can also construct an index for dimensions other than the first
vec_as_location(c("c2", "c1"), ncol(x), colnames(x))

</code></pre>

<hr>
<h2 id='vec_as_names'>Retrieve and repair names</h2><span id='topic+vec_as_names'></span>

<h3>Description</h3>

<p><code>vec_as_names()</code> takes a character vector of names and repairs it
according to the <code>repair</code> argument. It is the r-lib and tidyverse
equivalent of <code><a href="base.html#topic+make.names">base::make.names()</a></code>.
</p>
<p>vctrs deals with a few levels of name repair:
</p>

<ul>
<li> <p><code>minimal</code> names exist. The <code>names</code> attribute is not <code>NULL</code>. The
name of an unnamed element is <code>""</code> and never <code>NA</code>. For instance,
<code>vec_as_names()</code> always returns minimal names and data frames
created by the tibble package have names that are, at least,
<code>minimal</code>.
</p>
</li>
<li> <p><code>unique</code> names are <code>minimal</code>, have no duplicates, and can be used
where a variable name is expected. Empty names, <code>...</code>, and
<code>..</code> followed by a sequence of digits are banned.
</p>

<ul>
<li><p> All columns can be accessed by name via <code>df[["name"]]</code> and
<code>df$`name` </code> and <code>with(df, `name`)</code>.
</p>
</li></ul>

</li>
<li> <p><code>universal</code> names are <code>unique</code> and syntactic (see Details for
more).
</p>

<ul>
<li><p> Names work everywhere, without quoting: <code>df$name</code> and <code>with(df, name)</code> and <code>lm(name1 ~ name2, data = df)</code> and
<code>dplyr::select(df, name)</code> all work.
</p>
</li></ul>

</li></ul>

<p><code>universal</code> implies <code>unique</code>, <code>unique</code> implies <code>minimal</code>. These
levels are nested.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_as_names(
  names,
  ...,
  repair = c("minimal", "unique", "universal", "check_unique", "unique_quiet",
    "universal_quiet"),
  repair_arg = NULL,
  quiet = FALSE,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_as_names_+3A_names">names</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="vec_as_names_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_as_names_+3A_repair">repair</code></td>
<td>
<p>Either a string or a function. If a string, it must be one of
<code>"check_unique"</code>, <code>"minimal"</code>, <code>"unique"</code>, <code>"universal"</code>, <code>"unique_quiet"</code>,
or <code>"universal_quiet"</code>. If a function, it is invoked with a vector of
minimal names and must return minimal names, otherwise an error is thrown.
</p>

<ul>
<li><p> Minimal names are never <code>NULL</code> or <code>NA</code>. When an element doesn't
have a name, its minimal name is an empty string.
</p>
</li>
<li><p> Unique names are unique. A suffix is appended to duplicate
names to make them unique.
</p>
</li>
<li><p> Universal names are unique and syntactic, meaning that you can
safely use the names as variables without causing a syntax
error.
</p>
</li></ul>

<p>The <code>"check_unique"</code> option doesn't perform any name repair.
Instead, an error is raised if the names don't suit the
<code>"unique"</code> criteria.
</p>
<p>The options <code>"unique_quiet"</code> and <code>"universal_quiet"</code> are here to help the
user who calls this function indirectly, via another function which exposes
<code>repair</code> but not <code>quiet</code>. Specifying <code>repair = "unique_quiet"</code> is like
specifying <code style="white-space: pre;">&#8288;repair = "unique", quiet = TRUE&#8288;</code>. When the <code>"*_quiet"</code> options
are used, any setting of <code>quiet</code> is silently overridden.</p>
</td></tr>
<tr><td><code id="vec_as_names_+3A_repair_arg">repair_arg</code></td>
<td>
<p>If specified and <code>repair = "check_unique"</code>, any errors
will include a hint to set the <code>repair_arg</code>.</p>
</td></tr>
<tr><td><code id="vec_as_names_+3A_quiet">quiet</code></td>
<td>
<p>By default, the user is informed of any renaming
caused by repairing the names. This only concerns unique and
universal repairing. Set <code>quiet</code> to <code>TRUE</code> to silence the
messages.
</p>
<p>Users can silence the name repair messages by setting the
<code>"rlib_name_repair_verbosity"</code> global option to <code>"quiet"</code>.</p>
</td></tr>
<tr><td><code id="vec_as_names_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3><code>minimal</code> names</h3>

<p><code>minimal</code> names exist. The <code>names</code> attribute is not <code>NULL</code>. The
name of an unnamed element is <code>""</code> and never <code>NA</code>.
</p>
<p>Examples:
</p>
<div class="sourceCode"><pre>Original names of a vector with length 3: NULL
                           minimal names: "" "" ""

                          Original names: "x" NA
                           minimal names: "x" ""
</pre></div>


<h3><code>unique</code> names</h3>

<p><code>unique</code> names are <code>minimal</code>, have no duplicates, and can be used
(possibly with backticks) in contexts where a variable is
expected. Empty names, <code>...</code>, and <code>..</code> followed by a sequence of
digits are banned. If a data frame has <code>unique</code> names, you can
index it by name, and also access the columns by name. In
particular, <code>df[["name"]]</code> and <code>df$`name`</code> and also <code>with(df, `name`)</code> always work.
</p>
<p>There are many ways to make names <code>unique</code>. We append a suffix of the form
<code>...j</code> to any name that is <code>""</code> or a duplicate, where <code>j</code> is the position.
We also change <code>..#</code> and <code>...</code> to <code>...#</code>.
</p>
<p>Example:
</p>
<div class="sourceCode"><pre>Original names:     ""     "x"     "" "y"     "x"  "..2"  "..."
  unique names: "...1" "x...2" "...3" "y" "x...5" "...6" "...7"
</pre></div>
<p>Pre-existing suffixes of the form <code>...j</code> are always stripped, prior
to making names <code>unique</code>, i.e. reconstructing the suffixes. If this
interacts poorly with your names, you should take control of name
repair.
</p>


<h3><code>universal</code> names</h3>

<p><code>universal</code> names are <code>unique</code> and syntactic, meaning they:
</p>

<ul>
<li><p> Are never empty (inherited from <code>unique</code>).
</p>
</li>
<li><p> Have no duplicates (inherited from <code>unique</code>).
</p>
</li>
<li><p> Are not <code>...</code>. Do not have the form <code>..i</code>, where <code>i</code> is a
number (inherited from <code>unique</code>).
</p>
</li>
<li><p> Consist of letters, numbers, and the dot <code>.</code> or underscore <code style="white-space: pre;">&#8288;_&#8288;</code>
characters.
</p>
</li>
<li><p> Start with a letter or start with the dot <code>.</code> not followed by a
number.
</p>
</li>
<li><p> Are not a <a href="base.html#topic+reserved">reserved</a> word, e.g., <code>if</code> or <code>function</code> or <code>TRUE</code>.
</p>
</li></ul>

<p>If a vector has <code>universal</code> names, variable names can be used
&quot;as is&quot; in code. They work well with nonstandard evaluation, e.g.,
<code>df$name</code> works.
</p>
<p>vctrs has a different method of making names syntactic than
<code><a href="base.html#topic+make.names">base::make.names()</a></code>. In general, vctrs prepends one or more dots
<code>.</code> until the name is syntactic.
</p>
<p>Examples:
</p>
<div class="sourceCode"><pre> Original names:     ""     "x"    NA      "x"
universal names: "...1" "x...2" "...3" "x...4"

  Original names: "(y)"  "_z"  ".2fa"  "FALSE"
 universal names: ".y." "._z" "..2fa" ".FALSE"
</pre></div>


<h3>See Also</h3>

<p><code><a href="rlang.html#topic+names2">rlang::names2()</a></code> returns the names of an object, after
making them <code>minimal</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By default, `vec_as_names()` returns minimal names:
vec_as_names(c(NA, NA, "foo"))

# You can make them unique:
vec_as_names(c(NA, NA, "foo"), repair = "unique")

# Universal repairing fixes any non-syntactic name:
vec_as_names(c("_foo", "+"), repair = "universal")
</code></pre>

<hr>
<h2 id='vec_as_names_legacy'>Repair names with legacy method</h2><span id='topic+vec_as_names_legacy'></span>

<h3>Description</h3>

<p>This standardises names with the legacy approach that was used in
tidyverse packages (such as tibble, tidyr, and readxl) before
<code><a href="#topic+vec_as_names">vec_as_names()</a></code> was implemented. This tool is meant to help
transitioning to the new name repairing standard and will be
deprecated and removed from the package some time in the future.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_as_names_legacy(names, prefix = "V", sep = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_as_names_legacy_+3A_names">names</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="vec_as_names_legacy_+3A_prefix">prefix</code>, <code id="vec_as_names_legacy_+3A_sep">sep</code></td>
<td>
<p>Prefix and separator for repaired names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("tibble")) {

library(tibble)

# Names repair is turned off by default in tibble:
try(tibble(a = 1, a = 2))

# You can turn it on by supplying a repair method:
tibble(a = 1, a = 2, .name_repair = "universal")

# If you prefer the legacy method, use `vec_as_names_legacy()`:
tibble(a = 1, a = 2, .name_repair = vec_as_names_legacy)

}
</code></pre>

<hr>
<h2 id='vec_as_subscript'>Convert to a base subscript type</h2><span id='topic+vec_as_subscript'></span><span id='topic+vec_as_subscript2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Convert <code>i</code> to the base type expected by <code><a href="#topic+vec_as_location">vec_as_location()</a></code> or
<code><a href="#topic+vec_as_location2">vec_as_location2()</a></code>. The values of the subscript type are
not checked in any way (length, missingness, negative elements).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_as_subscript(
  i,
  ...,
  logical = c("cast", "error"),
  numeric = c("cast", "error"),
  character = c("cast", "error"),
  arg = NULL,
  call = caller_env()
)

vec_as_subscript2(
  i,
  ...,
  numeric = c("cast", "error"),
  character = c("cast", "error"),
  arg = NULL,
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_as_subscript_+3A_i">i</code></td>
<td>
<p>An integer, character or logical vector specifying the
locations or names of the observations to get/set. Specify
<code>TRUE</code> to index all elements (as in <code>x[]</code>), or <code>NULL</code>, <code>FALSE</code> or
<code>integer()</code> to index none (as in <code>x[NULL]</code>).</p>
</td></tr>
<tr><td><code id="vec_as_subscript_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_as_subscript_+3A_logical">logical</code>, <code id="vec_as_subscript_+3A_numeric">numeric</code>, <code id="vec_as_subscript_+3A_character">character</code></td>
<td>
<p>How to handle logical, numeric,
and character subscripts.
</p>
<p>If <code>"cast"</code> and the subscript is not one of the three base types
(logical, integer or character), the subscript is
<a href="#topic+vec_cast">cast</a> to the relevant base type, e.g. factors are
coerced to character. <code>NULL</code> is treated as an empty integer
vector, and is thus coercible depending on the setting of
<code>numeric</code>. Symbols are treated as character vectors and thus
coercible depending on the setting of <code>character</code>.
</p>
<p>If <code>"error"</code>, the subscript type is disallowed and triggers an
informative error.</p>
</td></tr>
<tr><td><code id="vec_as_subscript_+3A_arg">arg</code></td>
<td>
<p>The argument name to be displayed in error messages.</p>
</td></tr>
<tr><td><code id="vec_as_subscript_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_assert'>Assert an argument has known prototype and/or size</h2><span id='topic+vec_assert'></span><span id='topic+vec_is'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#questioning"><img src="../help/figures/lifecycle-questioning.svg" alt='[Questioning]' /></a>
</p>

<ul>
<li> <p><code>vec_is()</code> is a predicate that checks if its input is a vector that
conforms to a prototype and/or a size.
</p>
</li>
<li> <p><code>vec_assert()</code> throws an error when the input is not a vector or
doesn't conform.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_assert(
  x,
  ptype = NULL,
  size = NULL,
  arg = caller_arg(x),
  call = caller_env()
)

vec_is(x, ptype = NULL, size = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_assert_+3A_x">x</code></td>
<td>
<p>A vector argument to check.</p>
</td></tr>
<tr><td><code id="vec_assert_+3A_ptype">ptype</code></td>
<td>
<p>Prototype to compare against. If the prototype has a
class, its <code><a href="#topic+vec_ptype">vec_ptype()</a></code> is compared to that of <code>x</code> with
<code>identical()</code>. Otherwise, its <code><a href="base.html#topic+typeof">typeof()</a></code> is compared to that of
<code>x</code> with <code>==</code>.</p>
</td></tr>
<tr><td><code id="vec_assert_+3A_size">size</code></td>
<td>
<p>A single integer size against which to compare.</p>
</td></tr>
<tr><td><code id="vec_assert_+3A_arg">arg</code></td>
<td>
<p>Name of argument being checked. This is used in error
messages. The label of the expression passed as <code>x</code> is taken as
default.</p>
</td></tr>
<tr><td><code id="vec_assert_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vec_is()</code> returns <code>TRUE</code> or <code>FALSE</code>. <code>vec_assert()</code> either
throws a typed error (see section on error types) or returns <code>x</code>,
invisibly.
</p>


<h3>Error types</h3>

<p><code>vec_is()</code> never throws.
<code>vec_assert()</code> throws the following errors:
</p>

<ul>
<li><p> If the input is not a vector, an error of class
<code>"vctrs_error_scalar_type"</code> is raised.
</p>
</li>
<li><p> If the prototype doesn't match, an error of class
<code>"vctrs_error_assert_ptype"</code> is raised.
</p>
</li>
<li><p> If the size doesn't match, an error of class
<code>"vctrs_error_assert_size"</code> is raised.
</p>
</li></ul>

<p>Both errors inherit from <code>"vctrs_error_assert"</code>.
</p>


<h3>Lifecycle</h3>

<p>Both <code>vec_is()</code> and <code>vec_assert()</code> are questioning because their <code>ptype</code>
arguments have semantics that are challenging to define clearly and are
rarely useful.
</p>

<ul>
<li><p> Use <code><a href="#topic+obj_is_vector">obj_is_vector()</a></code> or <code><a href="#topic+obj_check_vector">obj_check_vector()</a></code> for vector checks
</p>
</li>
<li><p> Use <code><a href="#topic+vec_check_size">vec_check_size()</a></code> for size checks
</p>
</li>
<li><p> Use <code><a href="#topic+vec_cast">vec_cast()</a></code>, <code><a href="base.html#topic+inherits">inherits()</a></code>, or simple type predicates like
<code><a href="rlang.html#topic+type-predicates">rlang::is_logical()</a></code> for specific type checks
</p>
</li></ul>



<h3>Vectors and scalars</h3>

<p>Informally, a vector is a collection that makes sense to use as column in a
data frame. The following rules define whether or not <code>x</code> is considered a
vector.
</p>
<p>If no <code><a href="#topic+vec_proxy">vec_proxy()</a></code> method has been registered, <code>x</code> is a vector if:
</p>

<ul>
<li><p> The <a href="base.html#topic+typeof">base type</a> of the object is atomic: <code>"logical"</code>, <code>"integer"</code>,
<code>"double"</code>, <code>"complex"</code>, <code>"character"</code>, or <code>"raw"</code>.
</p>
</li>
<li> <p><code>x</code> is a list, as defined by <code><a href="#topic+obj_is_list">obj_is_list()</a></code>.
</p>
</li>
<li> <p><code>x</code> is a <a href="base.html#topic+data.frame">data.frame</a>.
</p>
</li></ul>

<p>If a <code>vec_proxy()</code> method has been registered, <code>x</code> is a vector if:
</p>

<ul>
<li><p> The proxy satisfies one of the above conditions.
</p>
</li>
<li><p> The base type of the proxy is <code>"list"</code>, regardless of its class. S3 lists
are thus treated as scalars unless they implement a <code>vec_proxy()</code> method.
</p>
</li></ul>

<p>Otherwise an object is treated as scalar and cannot be used as a vector.
In particular:
</p>

<ul>
<li> <p><code>NULL</code> is not a vector.
</p>
</li>
<li><p> S3 lists like <code>lm</code> objects are treated as scalars by default.
</p>
</li>
<li><p> Objects of type <a href="base.html#topic+expression">expression</a> are not treated as vectors.
</p>
</li></ul>


<hr>
<h2 id='vec_bind'>Combine many data frames into one data frame</h2><span id='topic+vec_bind'></span><span id='topic+vec_rbind'></span><span id='topic+vec_cbind'></span>

<h3>Description</h3>

<p>This pair of functions binds together data frames (and vectors), either
row-wise or column-wise. Row-binding creates a data frame with common type
across all arguments. Column-binding creates a data frame with common length
across all arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_rbind(
  ...,
  .ptype = NULL,
  .names_to = rlang::zap(),
  .name_repair = c("unique", "universal", "check_unique", "unique_quiet",
    "universal_quiet"),
  .name_spec = NULL,
  .error_call = current_env()
)

vec_cbind(
  ...,
  .ptype = NULL,
  .size = NULL,
  .name_repair = c("unique", "universal", "check_unique", "minimal", "unique_quiet",
    "universal_quiet"),
  .error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_bind_+3A_...">...</code></td>
<td>
<p>Data frames or vectors.
</p>
<p>When the inputs are named:
</p>

<ul>
<li> <p><code>vec_rbind()</code> assigns names to row names unless <code>.names_to</code> is
supplied. In that case the names are assigned in the column
defined by <code>.names_to</code>.
</p>
</li>
<li> <p><code>vec_cbind()</code> creates packed data frame columns with named
inputs.
</p>
</li></ul>

<p><code>NULL</code> inputs are silently ignored. Empty (e.g. zero row) inputs
will not appear in the output, but will affect the derived <code>.ptype</code>.</p>
</td></tr>
<tr><td><code id="vec_bind_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>...</code>.
</p>
<p>Alternatively, you can supply <code>.ptype</code> to give the output known type.
If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code> you must supply this value:
this is a convenient way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="vec_bind_+3A_.names_to">.names_to</code></td>
<td>
<p>This controls what to do with input names supplied in <code>...</code>.
</p>

<ul>
<li><p> By default, input names are <a href="rlang.html#topic+zap">zapped</a>.
</p>
</li>
<li><p> If a string, specifies a column where the input names will be
copied. These names are often useful to identify rows with
their original input. If a column name is supplied and <code>...</code> is
not named, an integer column is used instead.
</p>
</li>
<li><p> If <code>NULL</code>, the input names are used as row names.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_bind_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"unique"</code>, <code>"universal"</code>, <code>"check_unique"</code>,
<code>"unique_quiet"</code>, or  <code>"universal_quiet"</code>. See <code><a href="#topic+vec_as_names">vec_as_names()</a></code> for the
meaning of these options.
</p>
<p>With <code>vec_rbind()</code>, the repair function is applied to all inputs
separately. This is because <code>vec_rbind()</code> needs to align their
columns before binding the rows, and thus needs all inputs to
have unique names. On the other hand, <code>vec_cbind()</code> applies the
repair function after all inputs have been concatenated together
in a final data frame. Hence <code>vec_cbind()</code> allows the more
permissive minimal names repair.</p>
</td></tr>
<tr><td><code id="vec_bind_+3A_.name_spec">.name_spec</code></td>
<td>
<p>A name specification (as documented in <code><a href="#topic+vec_c">vec_c()</a></code>)
for combining the outer inputs names in <code>...</code> and the inner row
names of the inputs. This only has an effect when <code>.names_to</code> is
set to <code>NULL</code>, which causes the input names to be assigned as row
names.</p>
</td></tr>
<tr><td><code id="vec_bind_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_bind_+3A_.size">.size</code></td>
<td>
<p>If, <code>NULL</code>, the default, will determine the number of rows in
<code>vec_cbind()</code> output by using the tidyverse <a href="#topic+theory-faq-recycling">recycling rules</a>.
</p>
<p>Alternatively, specify the desired number of rows, and any inputs of length
1 will be recycled appropriately.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, or subclass of data frame.
</p>
<p>If <code>...</code> is a mix of different data frame subclasses, <code>vec_ptype2()</code>
will be used to determine the output type. For <code>vec_rbind()</code>, this
will determine the type of the container and the type of each column;
for <code>vec_cbind()</code> it only determines the type of the output container.
If there are no non-<code>NULL</code> inputs, the result will be <code>data.frame()</code>.
</p>


<h3>Invariants</h3>

<p>All inputs are first converted to a data frame. The conversion for
1d vectors depends on the direction of binding:
</p>

<ul>
<li><p> For <code>vec_rbind()</code>, each element of the vector becomes a column in
a single row.
</p>
</li>
<li><p> For <code>vec_cbind()</code>, each element of the vector becomes a row in a
single column.
</p>
</li></ul>

<p>Once the inputs have all become data frames, the following
invariants are observed for row-binding:
</p>

<ul>
<li> <p><code>vec_size(vec_rbind(x, y)) == vec_size(x) + vec_size(y)</code>
</p>
</li>
<li> <p><code>vec_ptype(vec_rbind(x, y)) = vec_ptype_common(x, y)</code>
</p>
</li></ul>

<p>Note that if an input is an empty vector, it is first converted to
a 1-row data frame with 0 columns. Despite being empty, its
effective size for the total number of rows is 1.
</p>
<p>For column-binding, the following invariants apply:
</p>

<ul>
<li> <p><code>vec_size(vec_cbind(x, y)) == vec_size_common(x, y)</code>
</p>
</li>
<li> <p><code>vec_ptype(vec_cbind(x, y)) == vec_cbind(vec_ptype(x), vec_ptype(x))</code>
</p>
</li></ul>



<h3>Dependencies</h3>



<h4>vctrs dependencies</h4>


<ul>
<li> <p><code><a href="#topic+vec_cast_common">vec_cast_common()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_init">vec_init()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_assign">vec_assign()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_restore">vec_restore()</a></code>
</p>
</li></ul>




<h4>base dependencies of <code>vec_rbind()</code></h4>


<ul>
<li> <p><code><a href="base.html#topic+c">base::c()</a></code>
</p>
</li></ul>

<p>If columns to combine inherit from a common class,
<code>vec_rbind()</code> falls back to <code>base::c()</code> if there exists a <code>c()</code>
method implemented for this class hierarchy.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+vec_c">vec_c()</a></code> for combining 1d vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># row binding -----------------------------------------

# common columns are coerced to common class
vec_rbind(
  data.frame(x = 1),
  data.frame(x = FALSE)
)

# unique columns are filled with NAs
vec_rbind(
  data.frame(x = 1),
  data.frame(y = "x")
)

# null inputs are ignored
vec_rbind(
  data.frame(x = 1),
  NULL,
  data.frame(x = 2)
)

# bare vectors are treated as rows
vec_rbind(
  c(x = 1, y = 2),
  c(x = 3)
)

# default names will be supplied if arguments are not named
vec_rbind(
  1:2,
  1:3,
  1:4
)

# column binding --------------------------------------

# each input is recycled to have common length
vec_cbind(
  data.frame(x = 1),
  data.frame(y = 1:3)
)

# bare vectors are treated as columns
vec_cbind(
  data.frame(x = 1),
  y = letters[1:3]
)

# if you supply a named data frame, it is packed in a single column
data &lt;- vec_cbind(
  x = data.frame(a = 1, b = 2),
  y = 1
)
data

# Packed data frames are nested in a single column. This makes it
# possible to access it through a single name:
data$x

# since the base print method is suboptimal with packed data
# frames, it is recommended to use tibble to work with these:
if (rlang::is_installed("tibble")) {
  vec_cbind(x = tibble::tibble(a = 1, b = 2), y = 1)
}

# duplicate names are flagged
vec_cbind(x = 1, x = 2)

</code></pre>

<hr>
<h2 id='vec_c'>Combine many vectors into one vector</h2><span id='topic+vec_c'></span>

<h3>Description</h3>

<p>Combine all arguments into a new vector of common type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_c(
  ...,
  .ptype = NULL,
  .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal", "unique_quiet",
    "universal_quiet"),
  .error_arg = "",
  .error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_c_+3A_...">...</code></td>
<td>
<p>Vectors to coerce.</p>
</td></tr>
<tr><td><code id="vec_c_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>...</code>.
</p>
<p>Alternatively, you can supply <code>.ptype</code> to give the output known type.
If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code> you must supply this value:
this is a convenient way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="vec_c_+3A_.name_spec">.name_spec</code></td>
<td>
<p>A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like <code>outer = c(inner = 1)</code>, or when they have length greater than 1: <code>outer = 1:2</code>. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
</p>

<ul>
<li><p> A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
</p>
</li>
<li><p> An anonymous function as a purrr-style formula.
</p>
</li>
<li><p> A glue specification of the form <code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> An <code><a href="rlang.html#topic+zap">rlang::zap()</a></code> object, in which case both outer and inner
names are ignored and the result is unnamed.
</p>
</li></ul>

<p>See the <a href="#topic+name_spec">name specification topic</a>.</p>
</td></tr>
<tr><td><code id="vec_c_+3A_.name_repair">.name_repair</code></td>
<td>
<p>How to repair names, see <code>repair</code> options in
<code><a href="#topic+vec_as_names">vec_as_names()</a></code>.</p>
</td></tr>
<tr><td><code id="vec_c_+3A_.error_arg">.error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="vec_c_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with class given by <code>.ptype</code>, and length equal to the
sum of the <code>vec_size()</code> of the contents of <code>...</code>.
</p>
<p>The vector will have names if the individual components have names
(inner names) or if the arguments are named (outer names). If both
inner and outer names are present, an error is thrown unless a
<code>.name_spec</code> is provided.
</p>


<h3>Invariants</h3>


<ul>
<li> <p><code>vec_size(vec_c(x, y)) == vec_size(x) + vec_size(y)</code>
</p>
</li>
<li> <p><code>vec_ptype(vec_c(x, y)) == vec_ptype_common(x, y)</code>.
</p>
</li></ul>



<h3>Dependencies</h3>



<h4>vctrs dependencies</h4>


<ul>
<li> <p><code><a href="#topic+vec_cast_common">vec_cast_common()</a></code> with fallback
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_restore">vec_restore()</a></code>
</p>
</li></ul>




<h4>base dependencies</h4>


<ul>
<li> <p><code><a href="base.html#topic+c">base::c()</a></code>
</p>
</li></ul>

<p>If inputs inherit from a common class hierarchy, <code>vec_c()</code> falls
back to <code>base::c()</code> if there exists a <code>c()</code> method implemented for
this class hierarchy.
</p>



<h3>See Also</h3>

<p><code><a href="#topic+vec_cbind">vec_cbind()</a></code>/<code><a href="#topic+vec_rbind">vec_rbind()</a></code> for combining data frames by rows
or columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_c(FALSE, 1L, 1.5)

# Date/times --------------------------
c(Sys.Date(), Sys.time())
c(Sys.time(), Sys.Date())

vec_c(Sys.Date(), Sys.time())
vec_c(Sys.time(), Sys.Date())

# Factors -----------------------------
c(factor("a"), factor("b"))
vec_c(factor("a"), factor("b"))


# By default, named inputs must be length 1:
vec_c(name = 1)
try(vec_c(name = 1:3))

# Pass a name specification to work around this:
vec_c(name = 1:3, .name_spec = "{outer}_{inner}")

# See `?name_spec` for more examples of name specifications.
</code></pre>

<hr>
<h2 id='vec_cast'>Cast a vector to a specified type</h2><span id='topic+vec_cast'></span><span id='topic+vec_cast_common'></span><span id='topic+vec_cast.logical'></span><span id='topic+vec_cast.integer'></span><span id='topic+vec_cast.double'></span><span id='topic+vec_cast.complex'></span><span id='topic+vec_cast.raw'></span><span id='topic+vec_cast.character'></span><span id='topic+vec_cast.list'></span>

<h3>Description</h3>

<p><code>vec_cast()</code> provides directional conversions from one type of
vector to another. Along with <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>, this generic forms
the foundation of type coercions in vctrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_cast(x, to, ..., x_arg = caller_arg(x), to_arg = "", call = caller_env())

vec_cast_common(..., .to = NULL, .arg = "", .call = caller_env())

## S3 method for class 'logical'
vec_cast(x, to, ...)

## S3 method for class 'integer'
vec_cast(x, to, ...)

## S3 method for class 'double'
vec_cast(x, to, ...)

## S3 method for class 'complex'
vec_cast(x, to, ...)

## S3 method for class 'raw'
vec_cast(x, to, ...)

## S3 method for class 'character'
vec_cast(x, to, ...)

## S3 method for class 'list'
vec_cast(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_cast_+3A_x">x</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_to">to</code>, <code id="vec_cast_+3A_.to">.to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_...">...</code></td>
<td>
<p>For <code>vec_cast_common()</code>, vectors to cast. For
<code>vec_cast()</code>, <code>vec_cast_default()</code>, and <code>vec_restore()</code>, these
dots are only for future extensions and should be empty.</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_x_arg">x_arg</code></td>
<td>
<p>Argument name for <code>x</code>, used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_to_arg">to_arg</code></td>
<td>
<p>Argument name <code>to</code> used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_call">call</code>, <code id="vec_cast_+3A_.call">.call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_cast_+3A_.arg">.arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same length as <code>x</code> with the same type as <code>to</code>,
or an error if the cast is not possible. An error is generated if
information is lost when casting between compatible types (i.e. when
there is no 1-to-1 mapping for a specific value).
</p>


<h3>Implementing coercion methods</h3>


<ul>
<li><p> For an overview of how these generics work and their roles in vctrs,
see <code><a href="#topic+theory-faq-coercion">?theory-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li>
<li><p> For a tutorial about implementing vctrs classes from scratch, see
<code>vignette("s3-vector")</code>.
</p>
</li></ul>



<h3>Dependencies of <code>vec_cast_common()</code></h3>



<h4>vctrs dependencies</h4>


<ul>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li></ul>




<h4>base dependencies</h4>

<p>Some functions enable a base-class fallback for
<code>vec_cast_common()</code>. In that case the inputs are deemed compatible
when they have the same <a href="base.html#topic+typeof">base type</a> and inherit from
the same base class.
</p>



<h3>See Also</h3>

<p>Call <code><a href="#topic+stop_incompatible_cast">stop_incompatible_cast()</a></code> when you determine from the
attributes that an input can't be cast to the target type.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># x is a double, but no information is lost
vec_cast(1, integer())

# When information is lost the cast fails
try(vec_cast(c(1, 1.5), integer()))
try(vec_cast(c(1, 2), logical()))

# You can suppress this error and get the partial results
allow_lossy_cast(vec_cast(c(1, 1.5), integer()))
allow_lossy_cast(vec_cast(c(1, 2), logical()))

# By default this suppress all lossy cast errors without
# distinction, but you can be specific about what cast is allowed
# by supplying prototypes
allow_lossy_cast(vec_cast(c(1, 1.5), integer()), to_ptype = integer())
try(allow_lossy_cast(vec_cast(c(1, 2), logical()), to_ptype = integer()))

# No sensible coercion is possible so an error is generated
try(vec_cast(1.5, factor("a")))

# Cast to common type
vec_cast_common(factor("a"), factor(c("a", "b")))
</code></pre>

<hr>
<h2 id='vec_cbind_frame_ptype'>Frame prototype</h2><span id='topic+vec_cbind_frame_ptype'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>This is an experimental generic that returns zero-columns variants
of a data frame. It is needed for <code><a href="#topic+vec_cbind">vec_cbind()</a></code>, to work around the
lack of colwise primitives in vctrs. Expect changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_cbind_frame_ptype(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_cbind_frame_ptype_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="vec_cbind_frame_ptype_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_chop'>Chopping</h2><span id='topic+vec_chop'></span><span id='topic+list_unchop'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_chop()</code> provides an efficient method to repeatedly slice a vector. It
captures the pattern of <code>map(indices, vec_slice, x = x)</code>. When no indices
are supplied, it is generally equivalent to <code><a href="base.html#topic+as.list">as.list()</a></code>.
</p>
</li>
<li> <p><code>list_unchop()</code> combines a list of vectors into a single vector, placing
elements in the output according to the locations specified by <code>indices</code>.
It is similar to <code><a href="#topic+vec_c">vec_c()</a></code>, but gives greater control over how the elements
are combined. When no indices are supplied, it is identical to <code>vec_c()</code>,
but typically a little faster.
</p>
</li></ul>

<p>If <code>indices</code> selects every value in <code>x</code> exactly once, in any order, then
<code>list_unchop()</code> is the inverse of <code>vec_chop()</code> and the following invariant
holds:
</p>
<div class="sourceCode"><pre>list_unchop(vec_chop(x, indices = indices), indices = indices) == x
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>vec_chop(x, ..., indices = NULL, sizes = NULL)

list_unchop(
  x,
  ...,
  indices = NULL,
  ptype = NULL,
  name_spec = NULL,
  name_repair = c("minimal", "unique", "check_unique", "universal", "unique_quiet",
    "universal_quiet"),
  error_arg = "x",
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_chop_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_indices">indices</code></td>
<td>
<p>For <code>vec_chop()</code>, a list of positive integer vectors to
slice <code>x</code> with, or <code>NULL</code>. Can't be used if <code>sizes</code> is already specified.
If both <code>indices</code> and <code>sizes</code> are <code>NULL</code>, <code>x</code> is split into its individual
elements, equivalent to using an <code>indices</code> of <code>as.list(vec_seq_along(x))</code>.
</p>
<p>For <code>list_unchop()</code>, a list of positive integer vectors specifying the
locations to place elements of <code>x</code> in. Each element of <code>x</code> is recycled to
the size of the corresponding index vector. The size of <code>indices</code> must
match the size of <code>x</code>. If <code>NULL</code>, <code>x</code> is combined in the order it is
provided in, which is equivalent to using <code><a href="#topic+vec_c">vec_c()</a></code>.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_sizes">sizes</code></td>
<td>
<p>An integer vector of non-negative sizes representing sequential
indices to slice <code>x</code> with, or <code>NULL</code>. Can't be used if <code>indices</code> is already
specified.
</p>
<p>For example, <code>sizes = c(2, 4)</code> is equivalent to <code>indices = list(1:2, 3:6)</code>,
but is typically faster.
</p>
<p><code>sum(sizes)</code> must be equal to <code>vec_size(x)</code>, i.e. <code>sizes</code> must completely
partition <code>x</code>, but an individual size is allowed to be <code>0</code>.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_ptype">ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>x</code>. Alternatively, you
can supply <code>ptype</code> to give the output a known type.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_name_spec">name_spec</code></td>
<td>
<p>A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like <code>outer = c(inner = 1)</code>, or when they have length greater than 1: <code>outer = 1:2</code>. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
</p>

<ul>
<li><p> A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
</p>
</li>
<li><p> An anonymous function as a purrr-style formula.
</p>
</li>
<li><p> A glue specification of the form <code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> An <code><a href="rlang.html#topic+zap">rlang::zap()</a></code> object, in which case both outer and inner
names are ignored and the result is unnamed.
</p>
</li></ul>

<p>See the <a href="#topic+name_spec">name specification topic</a>.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_name_repair">name_repair</code></td>
<td>
<p>How to repair names, see <code>repair</code> options in
<code><a href="#topic+vec_as_names">vec_as_names()</a></code>.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_error_arg">error_arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="vec_chop_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_chop()</code>: A list where each element has the same type as <code>x</code>. The size
of the list is equal to <code>vec_size(indices)</code>, <code>vec_size(sizes)</code>, or
<code>vec_size(x)</code> depending on whether or not <code>indices</code> or <code>sizes</code> is provided.
</p>
</li>
<li> <p><code>list_unchop()</code>: A vector of type <code>vec_ptype_common(!!!x)</code>, or <code>ptype</code>, if
specified. The size is computed as <code>vec_size_common(!!!indices)</code> unless
the indices are <code>NULL</code>, in which case the size is <code>vec_size_common(!!!x)</code>.
</p>
</li></ul>



<h3>Dependencies of <code>vec_chop()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Dependencies of <code>list_unchop()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_c">vec_c()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_chop(1:5)

# These two are equivalent
vec_chop(1:5, indices = list(1:2, 3:5))
vec_chop(1:5, sizes = c(2, 3))

# Can also be used on data frames
vec_chop(mtcars, indices = list(1:3, 4:6))

# If `indices` selects every value in `x` exactly once,
# in any order, then `list_unchop()` inverts `vec_chop()`
x &lt;- c("a", "b", "c", "d")
indices &lt;- list(2, c(3, 1), 4)
vec_chop(x, indices = indices)
list_unchop(vec_chop(x, indices = indices), indices = indices)

# When unchopping, size 1 elements of `x` are recycled
# to the size of the corresponding index
list_unchop(list(1, 2:3), indices = list(c(1, 3, 5), c(2, 4)))

# Names are retained, and outer names can be combined with inner
# names through the use of a `name_spec`
lst &lt;- list(x = c(a = 1, b = 2), y = 1)
list_unchop(lst, indices = list(c(3, 2), c(1, 4)), name_spec = "{outer}_{inner}")

# An alternative implementation of `ave()` can be constructed using
# `vec_chop()` and `list_unchop()` in combination with `vec_group_loc()`
ave2 &lt;- function(.x, .by, .f, ...) {
  indices &lt;- vec_group_loc(.by)$loc
  chopped &lt;- vec_chop(.x, indices = indices)
  out &lt;- lapply(chopped, .f, ...)
  list_unchop(out, indices = indices)
}

breaks &lt;- warpbreaks$breaks
wool &lt;- warpbreaks$wool

ave2(breaks, wool, mean)

identical(
  ave2(breaks, wool, mean),
  ave(breaks, wool, FUN = mean)
)

# If you know your input is sorted and you'd like to split on the groups,
# `vec_run_sizes()` can be efficiently combined with `sizes`
df &lt;- data_frame(
  g = c(2, 5, 5, 6, 6, 6, 6, 8, 9, 9),
  x = 1:10
)
vec_chop(df, sizes = vec_run_sizes(df$g))

# If you have a list of homogeneous vectors, sometimes it can be useful to
# unchop, apply a function to the flattened vector, and then rechop according
# to the original indices. This can be done efficiently with `list_sizes()`.
x &lt;- list(c(1, 2, 1), c(3, 1), 5, double())
x_flat &lt;- list_unchop(x)
x_flat &lt;- x_flat + max(x_flat)
vec_chop(x_flat, sizes = list_sizes(x))
</code></pre>

<hr>
<h2 id='vec_compare'>Compare two vectors</h2><span id='topic+vec_compare'></span>

<h3>Description</h3>

<p>Compare two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_compare(x, y, na_equal = FALSE, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_compare_+3A_x">x</code>, <code id="vec_compare_+3A_y">y</code></td>
<td>
<p>Vectors with compatible types and lengths.</p>
</td></tr>
<tr><td><code id="vec_compare_+3A_na_equal">na_equal</code></td>
<td>
<p>Should <code>NA</code> values be considered equal?</p>
</td></tr>
<tr><td><code id="vec_compare_+3A_.ptype">.ptype</code></td>
<td>
<p>Override to optionally specify common type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector with values -1 for <code>x &lt; y</code>, 0 if <code>x == y</code>,
and 1 if <code>x &gt; y</code>. If <code>na_equal</code> is <code>FALSE</code>, the result will be <code>NA</code>
if either <code>x</code> or <code>y</code> is <code>NA</code>.
</p>


<h3>S3 dispatch</h3>

<p><code>vec_compare()</code> is not generic for performance; instead it uses
<code><a href="#topic+vec_proxy_compare">vec_proxy_compare()</a></code> to create a proxy that is used in the comparison.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_cast_common">vec_cast_common()</a></code> with fallback
</p>
</li>
<li> <p><code><a href="#topic+vec_recycle_common">vec_recycle_common()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy_compare">vec_proxy_compare()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_compare(c(TRUE, FALSE, NA), FALSE)
vec_compare(c(TRUE, FALSE, NA), FALSE, na_equal = TRUE)

vec_compare(1:10, 5)
vec_compare(runif(10), 0.5)
vec_compare(letters[1:10], "d")

df &lt;- data.frame(x = c(1, 1, 1, 2), y = c(0, 1, 2, 1))
vec_compare(df, data.frame(x = 1, y = 1))
</code></pre>

<hr>
<h2 id='vec_count'>Count unique values in a vector</h2><span id='topic+vec_count'></span>

<h3>Description</h3>

<p>Count the number of unique values in a vector. <code>vec_count()</code> has two
important differences to <code>table()</code>: it returns a data frame, and when
given multiple inputs (as a data frame), it only counts combinations that
appear in the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_count(x, sort = c("count", "key", "location", "none"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_count_+3A_x">x</code></td>
<td>
<p>A vector (including a data frame).</p>
</td></tr>
<tr><td><code id="vec_count_+3A_sort">sort</code></td>
<td>
<p>One of &quot;count&quot;, &quot;key&quot;, &quot;location&quot;, or &quot;none&quot;.
</p>

<ul>
<li><p> &quot;count&quot;, the default, puts most frequent values at top
</p>
</li>
<li><p> &quot;key&quot;, orders by the output key column (i.e. unique values of <code>x</code>)
</p>
</li>
<li><p> &quot;location&quot;, orders by location where key first seen. This is useful
if you want to match the counts up to other unique/duplicated functions.
</p>
</li>
<li><p> &quot;none&quot;, leaves unordered. This is not guaranteed to produce the same
ordering across R sessions, but is the fastest method.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns <code>key</code> (same type as <code>x</code>) and
<code>count</code> (an integer vector).
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_order">vec_order()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_count(mtcars$vs)
vec_count(iris$Species)

# If you count a data frame you'll get a data frame
# column in the output
str(vec_count(mtcars[c("vs", "am")]))

# Sorting ---------------------------------------

x &lt;- letters[rpois(100, 6)]
# default is to sort by frequency
vec_count(x)

# by can sort by key
vec_count(x, sort = "key")

# or location of first value
vec_count(x, sort = "location")
head(x)

# or not at all
vec_count(x, sort = "none")
</code></pre>

<hr>
<h2 id='vec_data'>Extract underlying data</h2><span id='topic+vec_data'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p>Extract the data underlying an S3 vector object, i.e. the underlying
(named) atomic vector, data frame, or list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_data(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_data_+3A_x">x</code></td>
<td>
<p>A vector or object implementing <code>vec_proxy()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data underlying <code>x</code>, free from any attributes except the names.
</p>


<h3>Difference with <code>vec_proxy()</code></h3>


<ul>
<li> <p><code>vec_data()</code> returns unstructured data. The only attributes
preserved are names, dims, and dimnames.
</p>
<p>Currently, due to the underlying memory architecture of R, this
creates a full copy of the data for atomic vectors.
</p>
</li>
<li> <p><code>vec_proxy()</code> may return structured data. This generic is the
main customisation point for accessing memory values in vctrs,
along with <code><a href="#topic+vec_restore">vec_restore()</a></code>.
</p>
<p>Methods must return a vector type. Records and data frames will
be processed rowwise.
</p>
</li></ul>


<hr>
<h2 id='vec_default_cast'>Default cast and ptype2 methods</h2><span id='topic+vec_default_cast'></span><span id='topic+vec_default_ptype2'></span>

<h3>Description</h3>

<p>These functions are automatically called when no <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code> or
<code><a href="#topic+vec_cast">vec_cast()</a></code> method is implemented for a pair of types.
</p>

<ul>
<li><p> They apply special handling if one of the inputs is of type
<code>AsIs</code> or <code>sfc</code>.
</p>
</li>
<li><p> They attempt a number of fallbacks in cases where it would be too
inconvenient to be strict:
</p>

<ul>
<li><p> If the class and attributes are the same they are considered
compatible. <code>vec_default_cast()</code> returns <code>x</code> in this case.
</p>
</li>
<li><p> In case of incompatible data frame classes, they fall back to
<code>data.frame</code>. If an incompatible subclass of tibble is
involved, they fall back to <code>tbl_df</code>.
</p>
</li></ul>

</li>
<li><p> Otherwise, an error is thrown with <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code> or
<code><a href="#topic+stop_incompatible_cast">stop_incompatible_cast()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_default_cast(x, to, ..., x_arg = "", to_arg = "", call = caller_env())

vec_default_ptype2(x, y, ..., x_arg = "", y_arg = "", call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_default_cast_+3A_x">x</code></td>
<td>
<p>Vectors to cast.</p>
</td></tr>
<tr><td><code id="vec_default_cast_+3A_to">to</code></td>
<td>
<p>Type to cast to. If <code>NULL</code>, <code>x</code> will be returned as is.</p>
</td></tr>
<tr><td><code id="vec_default_cast_+3A_...">...</code></td>
<td>
<p>For <code>vec_cast_common()</code>, vectors to cast. For
<code>vec_cast()</code>, <code>vec_cast_default()</code>, and <code>vec_restore()</code>, these
dots are only for future extensions and should be empty.</p>
</td></tr>
<tr><td><code id="vec_default_cast_+3A_x_arg">x_arg</code></td>
<td>
<p>Argument name for <code>x</code>, used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="vec_default_cast_+3A_to_arg">to_arg</code></td>
<td>
<p>Argument name <code>to</code> used in error messages to
inform the user about the locations of incompatible types
(see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="vec_default_cast_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_detect_complete'>Complete</h2><span id='topic+vec_detect_complete'></span>

<h3>Description</h3>

<p><code>vec_detect_complete()</code> detects &quot;complete&quot; observations. An observation is
considered complete if it is non-missing. For most vectors, this implies that
<code>vec_detect_complete(x) == !vec_detect_missing(x)</code>.
</p>
<p>For data frames and matrices, a row is only considered complete if all
elements of that row are non-missing. To compare, <code>!vec_detect_missing(x)</code>
detects rows that are partially complete (they have at least one non-missing
value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_detect_complete(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_detect_complete_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <a href="#topic+new_rcrd">record</a> type vector is similar to a data frame, and is only
considered complete if all fields are non-missing.
</p>


<h3>Value</h3>

<p>A logical vector with the same size as <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+complete.cases">stats::complete.cases()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, NA, 4, NA)

# For most vectors, this is identical to `!vec_detect_missing(x)`
vec_detect_complete(x)
!vec_detect_missing(x)

df &lt;- data_frame(
  x = x,
  y = c("a", "b", NA, "d", "e")
)

# This returns `TRUE` where all elements of the row are non-missing.
# Compare that with `!vec_detect_missing()`, which detects rows that have at
# least one non-missing value.
df2 &lt;- df
df2$all_non_missing &lt;- vec_detect_complete(df)
df2$any_non_missing &lt;- !vec_detect_missing(df)
df2
</code></pre>

<hr>
<h2 id='vec_duplicate'>Find duplicated values</h2><span id='topic+vec_duplicate'></span><span id='topic+vec_duplicate_any'></span><span id='topic+vec_duplicate_detect'></span><span id='topic+vec_duplicate_id'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_duplicate_any()</code>: detects the presence of duplicated values,
similar to <code><a href="base.html#topic+anyDuplicated">anyDuplicated()</a></code>.
</p>
</li>
<li> <p><code>vec_duplicate_detect()</code>: returns a logical vector describing if each
element of the vector is duplicated elsewhere. Unlike <code><a href="base.html#topic+duplicated">duplicated()</a></code>, it
reports all duplicated values, not just the second and subsequent
repetitions.
</p>
</li>
<li> <p><code>vec_duplicate_id()</code>: returns an integer vector giving the location of
the first occurrence of the value.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_duplicate_any(x)

vec_duplicate_detect(x)

vec_duplicate_id(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_duplicate_+3A_x">x</code></td>
<td>
<p>A vector (including a data frame).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_duplicate_any()</code>: a logical vector of length 1.
</p>
</li>
<li> <p><code>vec_duplicate_detect()</code>: a logical vector the same length as <code>x</code>.
</p>
</li>
<li> <p><code>vec_duplicate_id()</code>: an integer vector the same length as <code>x</code>.
</p>
</li></ul>



<h3>Missing values</h3>

<p>In most cases, missing values are not considered to be equal, i.e.
<code>NA == NA</code> is not <code>TRUE</code>. This behaviour would be unappealing here,
so these functions consider all <code>NAs</code> to be equal. (Similarly,
all <code>NaN</code> are also considered to be equal.)
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vec_unique">vec_unique()</a></code> for functions that work with the dual of duplicated
values: unique values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_duplicate_any(1:10)
vec_duplicate_any(c(1, 1:10))

x &lt;- c(10, 10, 20, 30, 30, 40)
vec_duplicate_detect(x)
# Note that `duplicated()` doesn't consider the first instance to
# be a duplicate
duplicated(x)

# Identify elements of a vector by the location of the first element that
# they're equal to:
vec_duplicate_id(x)
# Location of the unique values:
vec_unique_loc(x)
# Equivalent to `duplicated()`:
vec_duplicate_id(x) == seq_along(x)
</code></pre>

<hr>
<h2 id='vec_empty'>Is a vector empty</h2><span id='topic+vec_empty'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#defunct"><img src="../help/figures/lifecycle-defunct.svg" alt='[Defunct]' /></a>
</p>
<p>This function is defunct, please use <code><a href="#topic+vec_is_empty">vec_is_empty()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_empty_+3A_x">x</code></td>
<td>
<p>An object.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_equal'>Equality</h2><span id='topic+vec_equal'></span>

<h3>Description</h3>

<p><code>vec_equal()</code> tests if two vectors are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_equal(x, y, na_equal = FALSE, .ptype = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_equal_+3A_x">x</code>, <code id="vec_equal_+3A_y">y</code></td>
<td>
<p>Vectors with compatible types and lengths.</p>
</td></tr>
<tr><td><code id="vec_equal_+3A_na_equal">na_equal</code></td>
<td>
<p>Should <code>NA</code> values be considered equal?</p>
</td></tr>
<tr><td><code id="vec_equal_+3A_.ptype">.ptype</code></td>
<td>
<p>Override to optionally specify common type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as the common size of <code>x</code> and <code>y</code>.
Will only contain <code>NA</code>s if <code>na_equal</code> is <code>FALSE</code>.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_cast_common">vec_cast_common()</a></code> with fallback
</p>
</li>
<li> <p><code><a href="#topic+vec_recycle_common">vec_recycle_common()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vec_detect_missing">vec_detect_missing()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_equal(c(TRUE, FALSE, NA), FALSE)
vec_equal(c(TRUE, FALSE, NA), FALSE, na_equal = TRUE)

vec_equal(5, 1:10)
vec_equal("d", letters[1:10])

df &lt;- data.frame(x = c(1, 1, 2, 1), y = c(1, 2, 1, NA))
vec_equal(df, data.frame(x = 1, y = 2))
</code></pre>

<hr>
<h2 id='vec_equal_na'>Missing values</h2><span id='topic+vec_equal_na'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vec_equal_na()</code> has been renamed to <code><a href="#topic+vec_detect_missing">vec_detect_missing()</a></code> and is deprecated
as of vctrs 0.5.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_equal_na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_equal_na_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same size as <code>x</code>.
</p>

<hr>
<h2 id='vec_expand_grid'>Create a data frame from all combinations of the inputs</h2><span id='topic+vec_expand_grid'></span>

<h3>Description</h3>

<p><code>vec_expand_grid()</code> creates a new data frame by creating a grid of all
possible combinations of the input vectors. It is inspired by
<code><a href="base.html#topic+expand.grid">expand.grid()</a></code>. Compared with <code>expand.grid()</code>, it:
</p>

<ul>
<li><p> Produces sorted output by default by varying the first column the slowest,
rather than the fastest. Control this with <code>.vary</code>.
</p>
</li>
<li><p> Never converts strings to factors.
</p>
</li>
<li><p> Does not add additional attributes.
</p>
</li>
<li><p> Drops <code>NULL</code> inputs.
</p>
</li>
<li><p> Can expand any vector type, including data frames and <a href="#topic+new_rcrd">records</a>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_expand_grid(
  ...,
  .vary = "slowest",
  .name_repair = "check_unique",
  .error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_expand_grid_+3A_...">...</code></td>
<td>
<p>Name-value pairs. The name will become the column name in the
resulting data frame.</p>
</td></tr>
<tr><td><code id="vec_expand_grid_+3A_.vary">.vary</code></td>
<td>
<p>One of:
</p>

<ul>
<li> <p><code>"slowest"</code> to vary the first column slowest. This produces sorted
output and is generally the most useful.
</p>
</li>
<li> <p><code>"fastest"</code> to vary the first column fastest. This matches the behavior
of <code><a href="base.html#topic+expand.grid">expand.grid()</a></code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_expand_grid_+3A_.name_repair">.name_repair</code></td>
<td>
<p>One of <code>"check_unique"</code>, <code>"unique"</code>, <code>"universal"</code>,
<code>"minimal"</code>, <code>"unique_quiet"</code>, or <code>"universal_quiet"</code>. See <code><a href="#topic+vec_as_names">vec_as_names()</a></code>
for the meaning of these options.</p>
</td></tr>
<tr><td><code id="vec_expand_grid_+3A_.error_call">.error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If any input is empty (i.e. size 0), then the result will have 0 rows.
</p>
<p>If no inputs are provided, the result is a 1 row data frame with 0 columns.
This is consistent with the fact that <code>prod()</code> with no inputs returns <code>1</code>.
</p>


<h3>Value</h3>

<p>A data frame with as many columns as there are inputs in <code>...</code> and as many
rows as the <code><a href="base.html#topic+prod">prod()</a></code> of the sizes of the inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_expand_grid(x = 1:2, y = 1:3)

# Use `.vary` to match `expand.grid()`:
vec_expand_grid(x = 1:2, y = 1:3, .vary = "fastest")

# Can also expand data frames
vec_expand_grid(
  x = data_frame(a = 1:2, b = 3:4),
  y = 1:4
)
</code></pre>

<hr>
<h2 id='vec_fill_missing'>Fill in missing values with the previous or following value</h2><span id='topic+vec_fill_missing'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>vec_fill_missing()</code> fills gaps of missing values with the previous or
following non-missing value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_fill_missing(
  x,
  direction = c("down", "up", "downup", "updown"),
  max_fill = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_fill_missing_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_fill_missing_+3A_direction">direction</code></td>
<td>
<p>Direction in which to fill missing values. Must be either
<code>"down"</code>, <code>"up"</code>, <code>"downup"</code>, or <code>"updown"</code>.</p>
</td></tr>
<tr><td><code id="vec_fill_missing_+3A_max_fill">max_fill</code></td>
<td>
<p>A single positive integer specifying the maximum number of
sequential missing values that will be filled. If <code>NULL</code>, there is
no limit.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(NA, NA, 1, NA, NA, NA, 3, NA, NA)

# Filling down replaces missing values with the previous non-missing value
vec_fill_missing(x, direction = "down")

# To also fill leading missing values, use `"downup"`
vec_fill_missing(x, direction = "downup")

# Limit the number of sequential missing values to fill with `max_fill`
vec_fill_missing(x, max_fill = 1)

# Data frames are filled rowwise. Rows are only considered missing
# if all elements of that row are missing.
y &lt;- c(1, NA, 2, NA, NA, 3, 4, NA, 5)
df &lt;- data_frame(x = x, y = y)
df

vec_fill_missing(df)
</code></pre>

<hr>
<h2 id='vec_group'>Identify groups</h2><span id='topic+vec_group'></span><span id='topic+vec_group_id'></span><span id='topic+vec_group_loc'></span><span id='topic+vec_group_rle'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>

<ul>
<li> <p><code>vec_group_id()</code> returns an identifier for the group that each element of
<code>x</code> falls in, constructed in the order that they appear. The number of
groups is also returned as an attribute, <code>n</code>.
</p>
</li>
<li> <p><code>vec_group_loc()</code> returns a data frame containing a <code>key</code> column with the
unique groups, and a <code>loc</code> column with the locations of each group in <code>x</code>.
</p>
</li>
<li> <p><code>vec_group_rle()</code> locates groups in <code>x</code> and returns them run length
encoded in the order that they appear. The return value is a rcrd object
with fields for the <code>group</code> identifiers and the run <code>length</code> of the
corresponding group. The number of groups is also returned as an
attribute, <code>n</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_group_id(x)

vec_group_loc(x)

vec_group_rle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_group_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_group_id()</code>: An integer vector with the same size as <code>x</code>.
</p>
</li>
<li> <p><code>vec_group_loc()</code>: A two column data frame with size equal to
<code>vec_size(vec_unique(x))</code>.
</p>

<ul>
<li><p> A <code>key</code> column of type <code>vec_ptype(x)</code>
</p>
</li>
<li><p> A <code>loc</code> column of type list, with elements of type integer.
</p>
</li></ul>

</li>
<li> <p><code>vec_group_rle()</code>: A <code>vctrs_group_rle</code> rcrd object with two integer
vector fields: <code>group</code> and <code>length</code>.
</p>
</li></ul>

<p>Note that when using <code>vec_group_loc()</code> for complex types, the default
<code>data.frame</code> print method will be suboptimal, and you will want to coerce
into a tibble to better understand the output.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>purrr &lt;- c("p", "u", "r", "r", "r")
vec_group_id(purrr)
vec_group_rle(purrr)

groups &lt;- mtcars[c("vs", "am")]
vec_group_id(groups)

group_rle &lt;- vec_group_rle(groups)
group_rle

# Access fields with `field()`
field(group_rle, "group")
field(group_rle, "length")

# `vec_group_id()` is equivalent to
vec_match(groups, vec_unique(groups))

vec_group_loc(mtcars$vs)
vec_group_loc(mtcars[c("vs", "am")])

if (require("tibble")) {
  as_tibble(vec_group_loc(mtcars[c("vs", "am")]))
}
</code></pre>

<hr>
<h2 id='vec_init'>Initialize a vector</h2><span id='topic+vec_init'></span>

<h3>Description</h3>

<p>Initialize a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_init(x, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_init_+3A_x">x</code></td>
<td>
<p>Template of vector to initialize.</p>
</td></tr>
<tr><td><code id="vec_init_+3A_n">n</code></td>
<td>
<p>Desired size of result.</p>
</td></tr>
</table>


<h3>Dependencies</h3>


<ul>
<li><p> vec_slice()
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_init(1:10, 3)
vec_init(Sys.Date(), 5)
vec_init(mtcars, 2)
</code></pre>

<hr>
<h2 id='vec_interleave'>Interleave many vectors into one vector</h2><span id='topic+vec_interleave'></span>

<h3>Description</h3>

<p><code>vec_interleave()</code> combines multiple vectors together, much like <code><a href="#topic+vec_c">vec_c()</a></code>,
but does so in such a way that the elements of each vector are interleaved
together.
</p>
<p>It is a more efficient equivalent to the following usage of <code>vec_c()</code>:
</p>
<div class="sourceCode"><pre>vec_interleave(x, y) == vec_c(x[1], y[1], x[2], y[2], ..., x[n], y[n])
</pre></div>


<h3>Usage</h3>

<pre><code class='language-R'>vec_interleave(
  ...,
  .ptype = NULL,
  .name_spec = NULL,
  .name_repair = c("minimal", "unique", "check_unique", "universal", "unique_quiet",
    "universal_quiet")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_interleave_+3A_...">...</code></td>
<td>
<p>Vectors to interleave. These will be
<a href="#topic+theory-faq-recycling">recycled</a> to a common size.</p>
</td></tr>
<tr><td><code id="vec_interleave_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>...</code>.
</p>
<p>Alternatively, you can supply <code>.ptype</code> to give the output known type.
If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code> you must supply this value:
this is a convenient way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="vec_interleave_+3A_.name_spec">.name_spec</code></td>
<td>
<p>A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like <code>outer = c(inner = 1)</code>, or when they have length greater than 1: <code>outer = 1:2</code>. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
</p>

<ul>
<li><p> A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
</p>
</li>
<li><p> An anonymous function as a purrr-style formula.
</p>
</li>
<li><p> A glue specification of the form <code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> An <code><a href="rlang.html#topic+zap">rlang::zap()</a></code> object, in which case both outer and inner
names are ignored and the result is unnamed.
</p>
</li></ul>

<p>See the <a href="#topic+name_spec">name specification topic</a>.</p>
</td></tr>
<tr><td><code id="vec_interleave_+3A_.name_repair">.name_repair</code></td>
<td>
<p>How to repair names, see <code>repair</code> options in
<code><a href="#topic+vec_as_names">vec_as_names()</a></code>.</p>
</td></tr>
</table>


<h3>Dependencies</h3>



<h4>vctrs dependencies</h4>


<ul>
<li> <p><code><a href="#topic+list_unchop">list_unchop()</a></code>
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'># The most common case is to interleave two vectors
vec_interleave(1:3, 4:6)

# But you aren't restricted to just two
vec_interleave(1:3, 4:6, 7:9, 10:12)

# You can also interleave data frames
x &lt;- data_frame(x = 1:2, y = c("a", "b"))
y &lt;- data_frame(x = 3:4, y = c("c", "d"))

vec_interleave(x, y)
</code></pre>

<hr>
<h2 id='vec_is_list'>List checks</h2><span id='topic+vec_is_list'></span><span id='topic+vec_check_list'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions have been deprecated as of vctrs 0.6.0.
</p>

<ul>
<li> <p><code>vec_is_list()</code> has been renamed to <code><a href="#topic+obj_is_list">obj_is_list()</a></code>.
</p>
</li>
<li> <p><code>vec_check_list()</code> has been renamed to <code><a href="#topic+obj_check_list">obj_check_list()</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_is_list(x)

vec_check_list(x, ..., arg = caller_arg(x), call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_is_list_+3A_x">x</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;vec_*()&#8288;</code> functions, an object. For <code style="white-space: pre;">&#8288;list_*()&#8288;</code> functions, a
list.</p>
</td></tr>
<tr><td><code id="vec_is_list_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_is_list_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="vec_is_list_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_locate_matches'>Locate observations matching specified conditions</h2><span id='topic+vec_locate_matches'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>vec_locate_matches()</code> is a more flexible version of <code><a href="#topic+vec_match">vec_match()</a></code> used to
identify locations where each value of <code>needles</code> matches one or multiple
values in <code>haystack</code>. Unlike <code>vec_match()</code>, <code>vec_locate_matches()</code> returns
all matches by default, and can match on binary conditions other than
equality, such as <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, and <code>&lt;=</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_locate_matches(
  needles,
  haystack,
  ...,
  condition = "==",
  filter = "none",
  incomplete = "compare",
  no_match = NA_integer_,
  remaining = "drop",
  multiple = "all",
  relationship = "none",
  nan_distinct = FALSE,
  chr_proxy_collate = NULL,
  needles_arg = "needles",
  haystack_arg = "haystack",
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_locate_matches_+3A_needles">needles</code>, <code id="vec_locate_matches_+3A_haystack">haystack</code></td>
<td>
<p>Vectors used for matching.
</p>

<ul>
<li> <p><code>needles</code> represents the vector to search for.
</p>
</li>
<li> <p><code>haystack</code> represents the vector to search in.
</p>
</li></ul>

<p>Prior to comparison, <code>needles</code> and <code>haystack</code> are coerced to the same type.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_condition">condition</code></td>
<td>
<p>Condition controlling how <code>needles</code> should be compared
against <code>haystack</code> to identify a successful match.
</p>

<ul>
<li><p> One of: <code>"=="</code>, <code>"&gt;"</code>, <code>"&gt;="</code>, <code>"&lt;"</code>, or <code>"&lt;="</code>.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(needles)</code> character vector
containing only the above options, specifying how matching is determined
for each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_filter">filter</code></td>
<td>
<p>Filter to be applied to the matched results.
</p>

<ul>
<li> <p><code>"none"</code> doesn't apply any filter.
</p>
</li>
<li> <p><code>"min"</code> returns only the minimum haystack value matching the current
needle.
</p>
</li>
<li> <p><code>"max"</code> returns only the maximum haystack value matching the current
needle.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(needles)</code> character vector
containing only the above options, specifying a filter to apply to
each column.
</p>
</li></ul>

<p>Filters don't have any effect on <code>"=="</code> conditions, but are useful for
computing &quot;rolling&quot; matches with other conditions.
</p>
<p>A filter can return multiple haystack matches for a particular needle
if the maximum or minimum haystack value is duplicated in <code>haystack</code>. These
can be further controlled with <code>multiple</code>.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_incomplete">incomplete</code></td>
<td>
<p>Handling of missing and <a href="#topic+vec_detect_complete">incomplete</a>
values in <code>needles</code>.
</p>

<ul>
<li> <p><code>"compare"</code> uses <code>condition</code> to determine whether or not a missing value
in <code>needles</code> matches a missing value in <code>haystack</code>. If <code>condition</code> is
<code>==</code>, <code>&gt;=</code>, or <code>&lt;=</code>, then missing values will match.
</p>
</li>
<li> <p><code>"match"</code> always allows missing values in <code>needles</code> to match missing
values in <code>haystack</code>, regardless of the <code>condition</code>.
</p>
</li>
<li> <p><code>"drop"</code> drops incomplete values in <code>needles</code> from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any <code>needles</code> are incomplete.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned
in the <code>haystack</code> column for values of <code>needles</code> that are incomplete. If
<code>no_match = NA</code>, setting <code>incomplete = NA</code> forces incomplete values in
<code>needles</code> to be treated like unmatched values.
</p>
</li></ul>

<p><code>nan_distinct</code> determines whether a <code>NA</code> is allowed to match a <code>NaN</code>.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_no_match">no_match</code></td>
<td>
<p>Handling of <code>needles</code> without a match.
</p>

<ul>
<li> <p><code>"drop"</code> drops <code>needles</code> with zero matches from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if any <code>needles</code> have zero matches.
</p>
</li>
<li><p> If a single integer is provided, this represents the value returned in
the <code>haystack</code> column for values of <code>needles</code> that have zero matches. The
default represents an unmatched needle with <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_remaining">remaining</code></td>
<td>
<p>Handling of <code>haystack</code> values that <code>needles</code> never matched.
</p>

<ul>
<li> <p><code>"drop"</code> drops remaining <code>haystack</code> values from the result.
Typically, this is the desired behavior if you only care when <code>needles</code>
has a match.
</p>
</li>
<li> <p><code>"error"</code> throws an error if there are any remaining <code>haystack</code>
values.
</p>
</li>
<li><p> If a single integer is provided (often <code>NA</code>), this represents the value
returned in the <code>needles</code> column for the remaining <code>haystack</code> values
that <code>needles</code> never matched. Remaining <code>haystack</code> values are always
returned at the end of the result.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_multiple">multiple</code></td>
<td>
<p>Handling of <code>needles</code> with multiple matches. For each needle:
</p>

<ul>
<li> <p><code>"all"</code> returns all matches detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"any"</code> returns any match detected in <code>haystack</code> with no guarantees on
which match will be returned. It is often faster than <code>"first"</code> and
<code>"last"</code> if you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>haystack</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>haystack</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_relationship">relationship</code></td>
<td>
<p>Handling of the expected relationship between
<code>needles</code> and <code>haystack</code>. If the expectations chosen from the list below
are invalidated, an error is thrown.
</p>

<ul>
<li> <p><code>"none"</code> doesn't perform any relationship checks.
</p>
</li>
<li> <p><code>"one-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"one-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches at most 1 value in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-one"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches at most 1 value in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

</li>
<li> <p><code>"many-to-many"</code> expects:
</p>

<ul>
<li><p> Each value in <code>needles</code> matches any number of values in <code>haystack</code>.
</p>
</li>
<li><p> Each value in <code>haystack</code> matches any number of values in <code>needles</code>.
</p>
</li></ul>

<p>This performs no checks, and is identical to <code>"none"</code>, but is provided to
allow you to be explicit about this relationship if you know it exists.
</p>
</li>
<li> <p><code>"warn-many-to-many"</code> doesn't assume there is any known relationship, but
will warn if <code>needles</code> and <code>haystack</code> have a many-to-many relationship
(which is typically unexpected), encouraging you to either take a closer
look at your inputs or make this relationship explicit by specifying
<code>"many-to-many"</code>.
</p>
</li></ul>

<p><code>relationship</code> is applied after <code>filter</code> and <code>multiple</code> to allow potential
multiple matches to be filtered out first.
</p>
<p><code>relationship</code> doesn't handle cases where there are zero matches. For that,
see <code>no_match</code> and <code>remaining</code>.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_nan_distinct">nan_distinct</code></td>
<td>
<p>A single logical specifying whether or not <code>NaN</code> should
be considered distinct from <code>NA</code> for double and complex vectors. If <code>TRUE</code>,
<code>NaN</code> will always be ordered between <code>NA</code> and non-missing numbers.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_chr_proxy_collate">chr_proxy_collate</code></td>
<td>
<p>A function generating an alternate representation
of character vectors to use for collation, often used for locale-aware
ordering.
</p>

<ul>
<li><p> If <code>NULL</code>, no transformation is done.
</p>
</li>
<li><p> Otherwise, this must be a function of one argument. If the input contains
a character vector, it will be passed to this function after it has been
translated to UTF-8. This function should return a character vector with
the same length as the input. The result should sort as expected in the
C-locale, regardless of encoding.
</p>
</li></ul>

<p>For data frames, <code>chr_proxy_collate</code> will be applied to all character
columns.
</p>
<p>Common transformation functions include: <code>tolower()</code> for case-insensitive
ordering and <code>stringi::stri_sort_key()</code> for locale-aware ordering.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_needles_arg">needles_arg</code>, <code id="vec_locate_matches_+3A_haystack_arg">haystack_arg</code></td>
<td>
<p>Argument tags for <code>needles</code> and <code>haystack</code>
used in error messages.</p>
</td></tr>
<tr><td><code id="vec_locate_matches_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+vec_match">vec_match()</a></code> is identical to (but often slightly faster than):
</p>
<div class="sourceCode"><pre>vec_locate_matches(
  needles,
  haystack,
  condition = "==",
  multiple = "first",
  nan_distinct = TRUE
)
</pre></div>
<p><code>vec_locate_matches()</code> is extremely similar to a SQL join between <code>needles</code>
and <code>haystack</code>, with the default being most similar to a left join.
</p>
<p>Be very careful when specifying match <code>condition</code>s. If a condition is
misspecified, it is very easy to accidentally generate an exponentially
large number of matches.
</p>


<h3>Value</h3>

<p>A two column data frame containing the locations of the matches.
</p>

<ul>
<li> <p><code>needles</code> is an integer vector containing the location of
the needle currently being matched.
</p>
</li>
<li> <p><code>haystack</code> is an integer vector containing the location of the
corresponding match in the haystack for the current needle.
</p>
</li></ul>



<h3>Dependencies of <code>vec_locate_matches()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_order_radix">vec_order_radix()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_detect_complete">vec_detect_complete()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, NA, 3, NaN)
y &lt;- c(2, 1, 4, NA, 1, 2, NaN)

# By default, for each value of `x`, all matching locations in `y` are
# returned
matches &lt;- vec_locate_matches(x, y)
matches

# The result can be used to slice the inputs to align them
data_frame(
  x = vec_slice(x, matches$needles),
  y = vec_slice(y, matches$haystack)
)

# If multiple matches are present, control which is returned with `multiple`
vec_locate_matches(x, y, multiple = "first")
vec_locate_matches(x, y, multiple = "last")
vec_locate_matches(x, y, multiple = "any")

# Use `relationship` to add constraints and error on multiple matches if
# they aren't expected
try(vec_locate_matches(x, y, relationship = "one-to-one"))

# In this case, the `NA` in `y` matches two rows in `x`
try(vec_locate_matches(x, y, relationship = "one-to-many"))

# By default, `NA` is treated as being identical to `NaN`.
# Using `nan_distinct = TRUE` treats `NA` and `NaN` as different values, so
# `NA` can only match `NA`, and `NaN` can only match `NaN`.
vec_locate_matches(x, y, nan_distinct = TRUE)

# If you never want missing values to match, set `incomplete = NA` to return
# `NA` in the `haystack` column anytime there was an incomplete value
# in `needles`.
vec_locate_matches(x, y, incomplete = NA)

# Using `incomplete = NA` allows us to enforce the one-to-many relationship
# that we couldn't before
vec_locate_matches(x, y, relationship = "one-to-many", incomplete = NA)

# `no_match` allows you to specify the returned value for a needle with
# zero matches. Note that this is different from an incomplete value,
# so specifying `no_match` allows you to differentiate between incomplete
# values and unmatched values.
vec_locate_matches(x, y, incomplete = NA, no_match = 0L)

# If you want to require that every `needle` has at least 1 match, set
# `no_match` to `"error"`:
try(vec_locate_matches(x, y, incomplete = NA, no_match = "error"))

# By default, `vec_locate_matches()` detects equality between `needles` and
# `haystack`. Using `condition`, you can detect where an inequality holds
# true instead. For example, to find every location where `x[[i]] &gt;= y`:
matches &lt;- vec_locate_matches(x, y, condition = "&gt;=")

data_frame(
  x = vec_slice(x, matches$needles),
  y = vec_slice(y, matches$haystack)
)

# You can limit which matches are returned with a `filter`. For example,
# with the above example you can filter the matches returned by `x[[i]] &gt;= y`
# down to only the ones containing the maximum `y` value of those matches.
matches &lt;- vec_locate_matches(x, y, condition = "&gt;=", filter = "max")

# Here, the matches for the `3` needle value have been filtered down to
# only include the maximum haystack value of those matches, `2`. This is
# often referred to as a rolling join.
data_frame(
  x = vec_slice(x, matches$needles),
  y = vec_slice(y, matches$haystack)
)

# In the very rare case that you need to generate locations for a
# cross match, where every value of `x` is forced to match every
# value of `y` regardless of what the actual values are, you can
# replace `x` and `y` with integer vectors of the same size that contain
# a single value and match on those instead.
x_proxy &lt;- vec_rep(1L, vec_size(x))
y_proxy &lt;- vec_rep(1L, vec_size(y))
nrow(vec_locate_matches(x_proxy, y_proxy))
vec_size(x) * vec_size(y)

# By default, missing values will match other missing values when using
# `==`, `&gt;=`, or `&lt;=` conditions, but not when using `&gt;` or `&lt;` conditions.
# This is similar to how `vec_compare(x, y, na_equal = TRUE)` works.
x &lt;- c(1, NA)
y &lt;- c(NA, 2)

vec_locate_matches(x, y, condition = "&lt;=")
vec_locate_matches(x, y, condition = "&lt;")

# You can force missing values to match regardless of the `condition`
# by using `incomplete = "match"`
vec_locate_matches(x, y, condition = "&lt;", incomplete = "match")

# You can also use data frames for `needles` and `haystack`. The
# `condition` will be recycled to the number of columns in `needles`, or
# you can specify varying conditions per column. In this example, we take
# a vector of date `values` and find all locations where each value is
# between lower and upper bounds specified by the `haystack`.
values &lt;- as.Date("2019-01-01") + 0:9
needles &lt;- data_frame(lower = values, upper = values)

set.seed(123)
lower &lt;- as.Date("2019-01-01") + sample(10, 10, replace = TRUE)
upper &lt;- lower + sample(3, 10, replace = TRUE)
haystack &lt;- data_frame(lower = lower, upper = upper)

# (values &gt;= lower) &amp; (values &lt;= upper)
matches &lt;- vec_locate_matches(needles, haystack, condition = c("&gt;=", "&lt;="))

data_frame(
  lower = vec_slice(lower, matches$haystack),
  value = vec_slice(values, matches$needle),
  upper = vec_slice(upper, matches$haystack)
)
</code></pre>

<hr>
<h2 id='vec_locate_sorted_groups'>Locate sorted groups</h2><span id='topic+vec_locate_sorted_groups'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>vec_locate_sorted_groups()</code> returns a data frame containing a <code>key</code> column
with sorted unique groups, and a <code>loc</code> column with the locations of each
group in <code>x</code>. It is similar to <code><a href="#topic+vec_group_loc">vec_group_loc()</a></code>, except the groups are
returned sorted rather than by first appearance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_locate_sorted_groups(
  x,
  ...,
  direction = "asc",
  na_value = "largest",
  nan_distinct = FALSE,
  chr_proxy_collate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_locate_sorted_groups_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_locate_sorted_groups_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_locate_sorted_groups_+3A_direction">direction</code></td>
<td>
<p>Direction to sort in.
</p>

<ul>
<li><p> A single <code>"asc"</code> or <code>"desc"</code> for ascending or descending order
respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"asc"</code> or <code>"desc"</code>, specifying the direction for each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_sorted_groups_+3A_na_value">na_value</code></td>
<td>
<p>Ordering of missing values.
</p>

<ul>
<li><p> A single <code>"largest"</code> or <code>"smallest"</code> for ordering missing values as the
largest or smallest values respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"largest"</code> or <code>"smallest"</code>, specifying how missing values should
be ordered within each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_locate_sorted_groups_+3A_nan_distinct">nan_distinct</code></td>
<td>
<p>A single logical specifying whether or not <code>NaN</code> should
be considered distinct from <code>NA</code> for double and complex vectors. If <code>TRUE</code>,
<code>NaN</code> will always be ordered between <code>NA</code> and non-missing numbers.</p>
</td></tr>
<tr><td><code id="vec_locate_sorted_groups_+3A_chr_proxy_collate">chr_proxy_collate</code></td>
<td>
<p>A function generating an alternate representation
of character vectors to use for collation, often used for locale-aware
ordering.
</p>

<ul>
<li><p> If <code>NULL</code>, no transformation is done.
</p>
</li>
<li><p> Otherwise, this must be a function of one argument. If the input contains
a character vector, it will be passed to this function after it has been
translated to UTF-8. This function should return a character vector with
the same length as the input. The result should sort as expected in the
C-locale, regardless of encoding.
</p>
</li></ul>

<p>For data frames, <code>chr_proxy_collate</code> will be applied to all character
columns.
</p>
<p>Common transformation functions include: <code>tolower()</code> for case-insensitive
ordering and <code>stringi::stri_sort_key()</code> for locale-aware ordering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vec_locate_sorted_groups(x)</code> is equivalent to, but faster than:
</p>
<div class="sourceCode"><pre>info &lt;- vec_group_loc(x)
vec_slice(info, vec_order(info$key))
</pre></div>


<h3>Value</h3>

<p>A two column data frame with size equal to <code>vec_size(vec_unique(x))</code>.
</p>

<ul>
<li><p> A <code>key</code> column of type <code>vec_ptype(x)</code>.
</p>
</li>
<li><p> A <code>loc</code> column of type list, with elements of type integer.
</p>
</li></ul>



<h3>Dependencies of <code>vec_locate_sorted_groups()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_order">vec_proxy_order()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  g = sample(2, 10, replace = TRUE),
  x = c(NA, sample(5, 9, replace = TRUE))
)

# `vec_locate_sorted_groups()` is similar to `vec_group_loc()`, except keys
# are returned ordered rather than by first appearance.
vec_locate_sorted_groups(df)

vec_group_loc(df)
</code></pre>

<hr>
<h2 id='vec_match'>Find matching observations across vectors</h2><span id='topic+vec_match'></span><span id='topic+vec_in'></span>

<h3>Description</h3>

<p><code>vec_in()</code> returns a logical vector based on whether <code>needle</code> is found in
haystack. <code>vec_match()</code> returns an integer vector giving location of
<code>needle</code> in <code>haystack</code>, or <code>NA</code> if it's not found.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_match(
  needles,
  haystack,
  ...,
  na_equal = TRUE,
  needles_arg = "",
  haystack_arg = ""
)

vec_in(
  needles,
  haystack,
  ...,
  na_equal = TRUE,
  needles_arg = "",
  haystack_arg = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_match_+3A_needles">needles</code>, <code id="vec_match_+3A_haystack">haystack</code></td>
<td>
<p>Vector of <code>needles</code> to search for in vector haystack.
<code>haystack</code> should usually be unique; if not <code>vec_match()</code> will only
return the location of the first match.
</p>
<p><code>needles</code> and <code>haystack</code> are coerced to the same type prior to
comparison.</p>
</td></tr>
<tr><td><code id="vec_match_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_match_+3A_na_equal">na_equal</code></td>
<td>
<p>If <code>TRUE</code>, missing values in <code>needles</code> can be
matched to missing values in <code>haystack</code>. If <code>FALSE</code>, they
propagate, missing values in <code>needles</code> are represented as <code>NA</code> in
the return value.</p>
</td></tr>
<tr><td><code id="vec_match_+3A_needles_arg">needles_arg</code>, <code id="vec_match_+3A_haystack_arg">haystack_arg</code></td>
<td>
<p>Argument tags for <code>needles</code> and
<code>haystack</code> used in error messages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vec_in()</code> is equivalent to <a href="base.html#topic++25in+25">%in%</a>; <code>vec_match()</code> is equivalent to <code>match()</code>.
</p>


<h3>Value</h3>

<p>A vector the same length as <code>needles</code>. <code>vec_in()</code> returns a
logical vector; <code>vec_match()</code> returns an integer vector.
</p>


<h3>Missing values</h3>

<p>In most cases places in R, missing values are not considered to be equal,
i.e. <code>NA == NA</code> is not <code>TRUE</code>. The exception is in matching functions
like <code><a href="base.html#topic+match">match()</a></code> and <code><a href="base.html#topic+merge">merge()</a></code>, where an <code>NA</code> will match another <code>NA</code>.
By <code>vec_match()</code> and <code>vec_in()</code> will match <code>NA</code>s; but you can control
this behaviour with the <code>na_equal</code> argument.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_cast_common">vec_cast_common()</a></code> with fallback
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>hadley &lt;- strsplit("hadley", "")[[1]]
vec_match(hadley, letters)

vowels &lt;- c("a", "e", "i", "o", "u")
vec_match(hadley, vowels)
vec_in(hadley, vowels)

# Only the first index of duplicates is returned
vec_match(c("a", "b"), c("a", "b", "a", "b"))
</code></pre>

<hr>
<h2 id='vec_math'>Mathematical operations</h2><span id='topic+vec_math'></span><span id='topic+vec_math_base'></span>

<h3>Description</h3>

<p>This generic provides a common dispatch mechanism for all regular unary
mathematical functions. It is used as a common wrapper around many of the
Summary group generics, the Math group generics, and a handful of other
mathematical functions like <code>mean()</code> (but not <code>var()</code> or <code>sd()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_math(.fn, .x, ...)

vec_math_base(.fn, .x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_math_+3A_.fn">.fn</code></td>
<td>
<p>A mathematical function from the base package, as a string.</p>
</td></tr>
<tr><td><code id="vec_math_+3A_.x">.x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vec_math_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>.fn</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vec_math_base()</code> is provided as a convenience for writing methods. It
calls the base <code>.fn</code> on the underlying <code><a href="#topic+vec_data">vec_data()</a></code>.
</p>


<h3>Included functions</h3>


<ul>
<li><p> From the <a href="methods.html#topic+Summary">Summary</a> group generic:
<code>prod()</code>, <code>sum()</code>, <code>any()</code>, <code>all()</code>.
</p>
</li>
<li><p> From the <a href="methods.html#topic+Math">Math</a> group generic:
<code>abs()</code>, <code>sign()</code>, <code>sqrt()</code>, <code>ceiling()</code>, <code>floor()</code>, <code>trunc()</code>, <code>cummax()</code>,
<code>cummin()</code>, <code>cumprod()</code>, <code>cumsum()</code>, <code>log()</code>, <code>log10()</code>, <code>log2()</code>,
<code>log1p()</code>, <code>acos()</code>, <code>acosh()</code>, <code>asin()</code>, <code>asinh()</code>, <code>atan()</code>, <code>atanh()</code>,
<code>exp()</code>, <code>expm1()</code>, <code>cos()</code>, <code>cosh()</code>, <code>cospi()</code>, <code>sin()</code>, <code>sinh()</code>,
<code>sinpi()</code>, <code>tan()</code>, <code>tanh()</code>, <code>tanpi()</code>, <code>gamma()</code>, <code>lgamma()</code>,
<code>digamma()</code>, <code>trigamma()</code>.
</p>
</li>
<li><p> Additional generics: <code>mean()</code>, <code>is.nan()</code>, <code>is.finite()</code>, <code>is.infinite()</code>.
</p>
</li></ul>

<p>Note that <code>median()</code> is currently not implemented, and <code>sd()</code> and
<code>var()</code> are currently not generic and so do not support custom
classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vec_arith">vec_arith()</a></code> for the equivalent for the arithmetic infix operators.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- new_vctr(c(1, 2.5, 10))
x

abs(x)
sum(x)
cumsum(x)
</code></pre>

<hr>
<h2 id='vec_names'>Get or set the names of a vector</h2><span id='topic+vec_names'></span><span id='topic+vec_names2'></span><span id='topic+vec_set_names'></span>

<h3>Description</h3>

<p>These functions work like <code><a href="rlang.html#topic+names2">rlang::names2()</a></code>, <code><a href="base.html#topic+names">names()</a></code> and <code><a href="base.html#topic+names+3C-">names&lt;-()</a></code>,
except that they return or modify the the rowwise names of the vector. These are:
</p>

<ul>
<li><p> The usual <code>names()</code> for atomic vectors and lists
</p>
</li>
<li><p> The row names for data frames and matrices
</p>
</li>
<li><p> The names of the first dimension for arrays
Rowwise names are size consistent: the length of the names always equals
<code><a href="#topic+vec_size">vec_size()</a></code>.
</p>
</li></ul>

<p><code>vec_names2()</code> returns the repaired names from a vector, even if it is unnamed.
See <code><a href="#topic+vec_as_names">vec_as_names()</a></code> for details on name repair.
</p>
<p><code>vec_names()</code> is a bare-bones version that returns <code>NULL</code> if the vector is
unnamed.
</p>
<p><code>vec_set_names()</code> sets the names or removes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_names2(
  x,
  ...,
  repair = c("minimal", "unique", "universal", "check_unique", "unique_quiet",
    "universal_quiet"),
  quiet = FALSE
)

vec_names(x)

vec_set_names(x, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_names_+3A_x">x</code></td>
<td>
<p>A vector with names</p>
</td></tr>
<tr><td><code id="vec_names_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_names_+3A_repair">repair</code></td>
<td>
<p>Either a string or a function. If a string, it must be one of
<code>"check_unique"</code>, <code>"minimal"</code>, <code>"unique"</code>, <code>"universal"</code>, <code>"unique_quiet"</code>,
or <code>"universal_quiet"</code>. If a function, it is invoked with a vector of
minimal names and must return minimal names, otherwise an error is thrown.
</p>

<ul>
<li><p> Minimal names are never <code>NULL</code> or <code>NA</code>. When an element doesn't
have a name, its minimal name is an empty string.
</p>
</li>
<li><p> Unique names are unique. A suffix is appended to duplicate
names to make them unique.
</p>
</li>
<li><p> Universal names are unique and syntactic, meaning that you can
safely use the names as variables without causing a syntax
error.
</p>
</li></ul>

<p>The <code>"check_unique"</code> option doesn't perform any name repair.
Instead, an error is raised if the names don't suit the
<code>"unique"</code> criteria.
</p>
<p>The options <code>"unique_quiet"</code> and <code>"universal_quiet"</code> are here to help the
user who calls this function indirectly, via another function which exposes
<code>repair</code> but not <code>quiet</code>. Specifying <code>repair = "unique_quiet"</code> is like
specifying <code style="white-space: pre;">&#8288;repair = "unique", quiet = TRUE&#8288;</code>. When the <code>"*_quiet"</code> options
are used, any setting of <code>quiet</code> is silently overridden.</p>
</td></tr>
<tr><td><code id="vec_names_+3A_quiet">quiet</code></td>
<td>
<p>By default, the user is informed of any renaming
caused by repairing the names. This only concerns unique and
universal repairing. Set <code>quiet</code> to <code>TRUE</code> to silence the
messages.
</p>
<p>Users can silence the name repair messages by setting the
<code>"rlib_name_repair_verbosity"</code> global option to <code>"quiet"</code>.</p>
</td></tr>
<tr><td><code id="vec_names_+3A_names">names</code></td>
<td>
<p>A character vector, or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vec_names2()</code> returns the names of <code>x</code>, repaired.
<code>vec_names()</code> returns the names of <code>x</code> or <code>NULL</code> if unnamed.
<code>vec_set_names()</code> returns <code>x</code> with names updated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_names2(1:3)
vec_names2(1:3, repair = "unique")
vec_names2(c(a = 1, b = 2))

# `vec_names()` consistently returns the rowwise names of data frames and arrays:
vec_names(data.frame(a = 1, b = 2))
names(data.frame(a = 1, b = 2))
vec_names(mtcars)
names(mtcars)
vec_names(Titanic)
names(Titanic)

vec_set_names(1:3, letters[1:3])
vec_set_names(data.frame(a = 1:3), letters[1:3])
</code></pre>

<hr>
<h2 id='vec_order'>Order and sort vectors</h2><span id='topic+vec_order'></span><span id='topic+vec_sort'></span>

<h3>Description</h3>

<p>Order and sort vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_order(
  x,
  ...,
  direction = c("asc", "desc"),
  na_value = c("largest", "smallest")
)

vec_sort(
  x,
  ...,
  direction = c("asc", "desc"),
  na_value = c("largest", "smallest")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_order_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_order_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_order_+3A_direction">direction</code></td>
<td>
<p>Direction to sort in. Defaults to <code>asc</code>ending.</p>
</td></tr>
<tr><td><code id="vec_order_+3A_na_value">na_value</code></td>
<td>
<p>Should <code>NA</code>s be treated as the largest or smallest values?</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_order()</code> an integer vector the same size as <code>x</code>.
</p>
</li>
<li> <p><code>vec_sort()</code> a vector with the same size and type as <code>x</code>.
</p>
</li></ul>



<h3>Differences with <code>order()</code></h3>

<p>Unlike the <code>na.last</code> argument of <code>order()</code> which decides the
positions of missing values irrespective of the <code>decreasing</code>
argument, the <code>na_value</code> argument of <code>vec_order()</code> interacts with
<code>direction</code>. If missing values are considered the largest value,
they will appear last in ascending order, and first in descending
order.
</p>


<h3>Dependencies of <code>vec_order()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_order">vec_proxy_order()</a></code>
</p>
</li></ul>



<h3>Dependencies of <code>vec_sort()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_order">vec_proxy_order()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_order">vec_order()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- round(c(runif(9), NA), 3)
vec_order(x)
vec_sort(x)
vec_sort(x, direction = "desc")

# Can also handle data frames
df &lt;- data.frame(g = sample(2, 10, replace = TRUE), x = x)
vec_order(df)
vec_sort(df)
vec_sort(df, direction = "desc")

# Missing values interpreted as largest values are last when
# in increasing order:
vec_order(c(1, NA), na_value = "largest", direction = "asc")
vec_order(c(1, NA), na_value = "largest", direction = "desc")
</code></pre>

<hr>
<h2 id='vec_proxy'>Proxy and restore</h2><span id='topic+vec_proxy'></span><span id='topic+vec_restore'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a>
</p>
<p><code>vec_proxy()</code> returns the data structure containing the values of a
vector. This data structure is usually the vector itself. In this
case the proxy is the <a href="base.html#topic+identity">identity function</a>, which is
the default <code>vec_proxy()</code> method.
</p>
<p>Only experts should implement special <code>vec_proxy()</code> methods, for
these cases:
</p>

<ul>
<li><p> A vector has vectorised attributes, i.e. metadata for
each element of the vector. These <em>record types</em> are implemented
in vctrs by returning a data frame in the proxy method. If you're
starting your class from scratch, consider deriving from the
<code><a href="#topic+new_rcrd">rcrd</a></code> class. It implements the appropriate data
frame proxy and is generally the preferred way to create a record
class.
</p>
</li>
<li><p> When you're implementing a vector on top of a non-vector type,
like an environment or an S4 object. This is currently only
partially supported.
</p>
</li>
<li><p> S3 lists are considered scalars by default. This is the safe
choice for list objects such as returned by <code>stats::lm()</code>. To
declare that your S3 list class is a vector, you normally add
<code>"list"</code> to the right of your class vector. Explicit inheritance
from list is generally the preferred way to declare an S3 list in
R, for instance it makes it possible to dispatch on
<code>generic.list</code> S3 methods.
</p>
<p>If you can't modify your class vector, you can implement an
identity proxy (i.e. a proxy method that just returns its input)
to let vctrs know this is a vector list and not a scalar.
</p>
</li></ul>

<p><code>vec_restore()</code> is the inverse operation of <code>vec_proxy()</code>. It
should only be called on vector proxies.
</p>

<ul>
<li><p> It undoes the transformations of <code>vec_proxy()</code>.
</p>
</li>
<li><p> It restores attributes and classes. These may be lost when the
memory values are manipulated. For example slicing a subset of a
vector's proxy causes a new proxy to be allocated.
</p>
</li></ul>

<p>By default vctrs restores all attributes and classes
automatically. You only need to implement a <code>vec_restore()</code> method
if your class has attributes that depend on the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_proxy(x, ...)

vec_restore(x, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_proxy_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vec_proxy_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_proxy_+3A_to">to</code></td>
<td>
<p>The original vector to restore to.</p>
</td></tr>
</table>


<h3>Proxying</h3>

<p>You should only implement <code>vec_proxy()</code> when your type is designed
around a non-vector class. I.e. anything that is not either:
</p>

<ul>
<li><p> An atomic vector
</p>
</li>
<li><p> A bare list
</p>
</li>
<li><p> A data frame
</p>
</li></ul>

<p>In this case, implement <code>vec_proxy()</code> to return such a vector
class. The vctrs operations such as <code><a href="#topic+vec_slice">vec_slice()</a></code> are applied on
the proxy and <code>vec_restore()</code> is called to restore the original
representation of your type.
</p>
<p>The most common case where you need to implement <code>vec_proxy()</code> is
for S3 lists. In vctrs, S3 lists are treated as scalars by
default. This way we don't treat objects like model fits as
vectors. To prevent vctrs from treating your S3 list as a scalar,
unclass it in the <code>vec_proxy()</code> method. For instance, here is the
definition for <code>list_of</code>:
</p>
<div class="sourceCode"><pre>vec_proxy.vctrs_list_of &lt;- function(x) {
  unclass(x)
}
</pre></div>
<p>Another case where you need to implement a proxy is <a href="#topic+new_rcrd">record types</a>. Record types should return a data frame, as in
the <code>POSIXlt</code> method:
</p>
<div class="sourceCode"><pre>vec_proxy.POSIXlt &lt;- function(x) {
  new_data_frame(unclass(x))
}
</pre></div>
<p>Note that you don't need to implement <code>vec_proxy()</code> when your class
inherits from <code>vctrs_vctr</code> or <code>vctrs_rcrd</code>.
</p>


<h3>Restoring</h3>

<p>A restore is a specialised type of cast, primarily used in
conjunction with <code>NextMethod()</code> or a C-level function that works on
the underlying data structure. A <code>vec_restore()</code> method can make
the following assumptions about <code>x</code>:
</p>

<ul>
<li><p> It has the correct type.
</p>
</li>
<li><p> It has the correct names.
</p>
</li>
<li><p> It has the correct <code>dim</code> and <code>dimnames</code> attributes.
</p>
</li>
<li><p> It is unclassed. This way you can call vctrs generics with <code>x</code>
without triggering an infinite loop of restoration.
</p>
</li></ul>

<p>The length may be different (for example after <code><a href="#topic+vec_slice">vec_slice()</a></code> has
been called), and all other attributes may have been lost. The
method should restore all attributes so that after restoration,
<code>vec_restore(vec_data(x), x)</code> yields <code>x</code>.
</p>
<p>To understand the difference between <code>vec_cast()</code> and <code>vec_restore()</code>
think about factors: it doesn't make sense to cast an integer to a factor,
but if <code>NextMethod()</code> or another low-level function has stripped attributes,
you still need to be able to restore them.
</p>
<p>The default method copies across all attributes so you only need to
provide your own method if your attributes require special care
(i.e. they are dependent on the data in some way). When implementing
your own method, bear in mind that many R users add attributes to track
additional metadata that is important to them, so you should preserve any
attributes that don't require special handling for your class.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code>x</code> must be a vector in the vctrs sense (see <code><a href="#topic+vec_is">vec_is()</a></code>)
</p>
</li>
<li><p> By default the underlying data is returned as is (identity proxy)
</p>
</li></ul>

<p>All vector classes have a proxy, even those who don't implement any
vctrs methods. The exception is S3 lists that don't inherit from
<code>"list"</code> explicitly. These might have to implement an identity
proxy for compatibility with vctrs (see discussion above).
</p>

<hr>
<h2 id='vec_proxy_compare'>Comparison and order proxy</h2><span id='topic+vec_proxy_compare'></span><span id='topic+vec_proxy_order'></span>

<h3>Description</h3>

<p><code>vec_proxy_compare()</code> and <code>vec_proxy_order()</code> return proxy objects, i.e.
an atomic vector or data frame of atomic vectors.
</p>
<p>For <code><a href="#topic+vctr">vctrs_vctr</a></code> objects:
</p>

<ul>
<li> <p><code>vec_proxy_compare()</code> determines the behavior of <code>&lt;</code>, <code>&gt;</code>, <code>&gt;=</code>
and <code>&lt;=</code> (via <code><a href="#topic+vec_compare">vec_compare()</a></code>); and <code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>, and
<code><a href="stats.html#topic+quantile">quantile()</a></code>.
</p>
</li>
<li> <p><code>vec_proxy_order()</code> determines the behavior of <code>order()</code> and <code>sort()</code>
(via <code>xtfrm()</code>).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_proxy_compare(x, ...)

vec_proxy_order(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_proxy_compare_+3A_x">x</code></td>
<td>
<p>A vector x.</p>
</td></tr>
<tr><td><code id="vec_proxy_compare_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method of <code>vec_proxy_compare()</code> assumes that all classes built
on top of atomic vectors or records are comparable. Internally the default
calls <code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>. If your class is not comparable, you will need
to provide a <code>vec_proxy_compare()</code> method that throws an error.
</p>
<p>The behavior of <code>vec_proxy_order()</code> is identical to <code>vec_proxy_compare()</code>,
with the exception of lists. Lists are not comparable, as comparing
elements of different types is undefined. However, to allow ordering of
data frames containing list-columns, the ordering proxy of a list is
generated as an integer vector that can be used to order list elements
by first appearance.
</p>
<p>If a class implements a <code>vec_proxy_compare()</code> method, it usually doesn't need
to provide a <code>vec_proxy_order()</code> method, because the latter is implemented
by forwarding to <code>vec_proxy_compare()</code> by default. Classes inheriting from
list are an exception: due to the default <code>vec_proxy_order()</code> implementation,
<code>vec_proxy_compare()</code> and <code>vec_proxy_order()</code> should be provided for such
classes (with identical implementations) to avoid mismatches between
comparison and sorting.
</p>


<h3>Value</h3>

<p>A 1d atomic vector or a data frame.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code> called by default in <code>vec_proxy_compare()</code>
</p>
</li>
<li> <p><code><a href="#topic+vec_proxy_compare">vec_proxy_compare()</a></code> called by default in <code>vec_proxy_order()</code>
</p>
</li></ul>



<h3>Data frames</h3>

<p>If the proxy for <code>x</code> is a data frame, the proxy function is automatically
recursively applied on all columns as well. After applying the proxy
recursively, if there are any data frame columns present in the proxy, then
they are unpacked. Finally, if the resulting data frame only has a single
column, then it is unwrapped and a vector is returned as the proxy.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Lists are not comparable
x &lt;- list(1:2, 1, 1:2, 3)
try(vec_compare(x, x))

# But lists are orderable by first appearance to allow for
# ordering data frames with list-cols
df &lt;- new_data_frame(list(x = x))
vec_sort(df)
</code></pre>

<hr>
<h2 id='vec_proxy_equal'>Equality proxy</h2><span id='topic+vec_proxy_equal'></span>

<h3>Description</h3>

<p>Returns a proxy object (i.e. an atomic vector or data frame of atomic
vectors). For <a href="#topic+vctr">vctr</a>s, this determines the behaviour of <code>==</code> and
<code>!=</code> (via <code><a href="#topic+vec_equal">vec_equal()</a></code>); <code><a href="base.html#topic+unique">unique()</a></code>, <code><a href="base.html#topic+duplicated">duplicated()</a></code> (via
<code><a href="#topic+vec_unique">vec_unique()</a></code> and <code><a href="#topic+vec_duplicate_detect">vec_duplicate_detect()</a></code>); <code><a href="Matrix.html#topic+is.na">is.na()</a></code> and <code><a href="Matrix.html#topic+anyNA">anyNA()</a></code>
(via <code><a href="#topic+vec_detect_missing">vec_detect_missing()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_proxy_equal(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_proxy_equal_+3A_x">x</code></td>
<td>
<p>A vector x.</p>
</td></tr>
<tr><td><code id="vec_proxy_equal_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method calls <code><a href="#topic+vec_proxy">vec_proxy()</a></code>, as the default underlying
vector data should be equal-able in most cases. If your class is
not equal-able, provide a <code>vec_proxy_equal()</code> method that throws an
error.
</p>


<h3>Value</h3>

<p>A 1d atomic vector or a data frame.
</p>


<h3>Data frames</h3>

<p>If the proxy for <code>x</code> is a data frame, the proxy function is automatically
recursively applied on all columns as well. After applying the proxy
recursively, if there are any data frame columns present in the proxy, then
they are unpacked. Finally, if the resulting data frame only has a single
column, then it is unwrapped and a vector is returned as the proxy.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code> called by default
</p>
</li></ul>


<hr>
<h2 id='vec_ptype'>Find the prototype of a set of vectors</h2><span id='topic+vec_ptype'></span><span id='topic+vec_ptype_common'></span><span id='topic+vec_ptype_show'></span>

<h3>Description</h3>

<p><code>vec_ptype()</code> returns the unfinalised prototype of a single vector.
<code>vec_ptype_common()</code> finds the common type of multiple vectors.
<code>vec_ptype_show()</code> nicely prints the common type of any number of
inputs, and is designed for interactive exploration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_ptype(x, ..., x_arg = "", call = caller_env())

vec_ptype_common(..., .ptype = NULL, .arg = "", .call = caller_env())

vec_ptype_show(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_ptype_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_ptype_+3A_...">...</code></td>
<td>
<p>For <code>vec_ptype()</code>, these dots are for future extensions and must
be empty.
</p>
<p>For <code>vec_ptype_common()</code> and <code>vec_ptype_show()</code>, vector inputs.</p>
</td></tr>
<tr><td><code id="vec_ptype_+3A_x_arg">x_arg</code></td>
<td>
<p>Argument name for <code>x</code>. This is used in error messages to inform
the user about the locations of incompatible types.</p>
</td></tr>
<tr><td><code id="vec_ptype_+3A_call">call</code>, <code id="vec_ptype_+3A_.call">.call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_ptype_+3A_.ptype">.ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>...</code>.
</p>
<p>Alternatively, you can supply <code>.ptype</code> to give the output known type.
If <code>getOption("vctrs.no_guessing")</code> is <code>TRUE</code> you must supply this value:
this is a convenient way to make production code demand fixed types.</p>
</td></tr>
<tr><td><code id="vec_ptype_+3A_.arg">.arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vec_ptype()</code> and <code>vec_ptype_common()</code> return a prototype
(a size-0 vector)
</p>


<h3><code>vec_ptype()</code></h3>

<p><code>vec_ptype()</code> returns <a href="#topic+vec_size">size</a> 0 vectors potentially
containing attributes but no data. Generally, this is just
<code>vec_slice(x, 0L)</code>, but some inputs require special
handling.
</p>

<ul>
<li><p> While you can't slice <code>NULL</code>, the prototype of <code>NULL</code> is
itself. This is because we treat <code>NULL</code> as an identity value in
the <code>vec_ptype2()</code> monoid.
</p>
</li>
<li><p> The prototype of logical vectors that only contain missing values
is the special <a href="#topic+unspecified">unspecified</a> type, which can be coerced to any
other 1d type. This allows bare <code>NA</code>s to represent missing values
for any 1d vector type.
</p>
</li></ul>

<p>See <a href="#topic+internal-faq-ptype2-identity">internal-faq-ptype2-identity</a> for more information about
identity values.
</p>
<p><code>vec_ptype()</code> is a <em>performance</em> generic. It is not necessary to implement it
because the default method will work for any vctrs type. However the default
method builds around other vctrs primitives like <code>vec_slice()</code> which incurs
performance costs. If your class has a static prototype, you might consider
implementing a custom <code>vec_ptype()</code> method that returns a constant. This will
improve the performance of your class in many cases (<a href="#topic+vec_ptype2">common type</a> imputation in particular).
</p>
<p>Because it may contain unspecified vectors, the prototype returned
by <code>vec_ptype()</code> is said to be <strong>unfinalised</strong>. Call
<code><a href="#topic+vec_ptype_finalise">vec_ptype_finalise()</a></code> to finalise it. Commonly you will need the
finalised prototype as returned by <code>vec_slice(x, 0L)</code>.
</p>


<h3><code>vec_ptype_common()</code></h3>

<p><code>vec_ptype_common()</code> first finds the prototype of each input, then
successively calls <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code> to find a common type. It returns
a <a href="#topic+vec_ptype_finalise">finalised</a> prototype.
</p>


<h3>Dependencies of <code>vec_ptype()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code> for returning an empty slice
</p>
</li></ul>



<h3>Dependencies of <code>vec_ptype_common()</code></h3>


<ul>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_ptype_finalise">vec_ptype_finalise()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Unknown types ------------------------------------------
vec_ptype_show()
vec_ptype_show(NA)
vec_ptype_show(NULL)

# Vectors ------------------------------------------------
vec_ptype_show(1:10)
vec_ptype_show(letters)
vec_ptype_show(TRUE)

vec_ptype_show(Sys.Date())
vec_ptype_show(Sys.time())
vec_ptype_show(factor("a"))
vec_ptype_show(ordered("a"))

# Matrices -----------------------------------------------
# The prototype of a matrix includes the number of columns
vec_ptype_show(array(1, dim = c(1, 2)))
vec_ptype_show(array("x", dim = c(1, 2)))

# Data frames --------------------------------------------
# The prototype of a data frame includes the prototype of
# every column
vec_ptype_show(iris)

# The prototype of multiple data frames includes the prototype
# of every column that in any data frame
vec_ptype_show(
  data.frame(x = TRUE),
  data.frame(y = 2),
  data.frame(z = "a")
)
</code></pre>

<hr>
<h2 id='vec_ptype_full'>Vector type as a string</h2><span id='topic+vec_ptype_full'></span><span id='topic+vec_ptype_abbr'></span>

<h3>Description</h3>

<p><code>vec_ptype_full()</code> displays the full type of the vector. <code>vec_ptype_abbr()</code>
provides an abbreviated summary suitable for use in a column heading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_ptype_full(x, ...)

vec_ptype_abbr(x, ..., prefix_named = FALSE, suffix_shape = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_ptype_full_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vec_ptype_full_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_ptype_full_+3A_prefix_named">prefix_named</code></td>
<td>
<p>If <code>TRUE</code>, add a prefix for named vectors.</p>
</td></tr>
<tr><td><code id="vec_ptype_full_+3A_suffix_shape">suffix_shape</code></td>
<td>
<p>If <code>TRUE</code> (the default), append the shape of
the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>


<h3>S3 dispatch</h3>

<p>The default method for <code>vec_ptype_full()</code> uses the first element of the
class vector. Override this method if your class has parameters that should
be prominently displayed.
</p>
<p>The default method for <code>vec_ptype_abbr()</code> <code><a href="base.html#topic+abbreviate">abbreviate()</a></code>s <code>vec_ptype_full()</code>
to 8 characters. You should almost always override, aiming for 4-6
characters where possible.
</p>
<p>These arguments are handled by the generic and not passed to methods:
</p>

<ul>
<li> <p><code>prefix_named</code>
</p>
</li>
<li> <p><code>suffix_shape</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>cat(vec_ptype_full(1:10))
cat(vec_ptype_full(iris))

cat(vec_ptype_abbr(1:10))
</code></pre>

<hr>
<h2 id='vec_ptype_full.integer64'>64 bit integers</h2><span id='topic+vec_ptype_full.integer64'></span><span id='topic+vec_ptype_abbr.integer64'></span><span id='topic+vec_ptype2.integer64'></span><span id='topic+vec_cast.integer64'></span>

<h3>Description</h3>

<p>A <code>integer64</code> is a 64 bits integer vector, implemented in the <code>bit64</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'integer64'
vec_ptype_full(x, ...)

## S3 method for class 'integer64'
vec_ptype_abbr(x, ...)

## S3 method for class 'integer64'
vec_ptype2(x, y, ...)

## S3 method for class 'integer64'
vec_cast(x, to, ...)
</code></pre>


<h3>Details</h3>

<p>These functions help the <code>integer64</code> class from <code>bit64</code> in to
the vctrs type system by providing coercion functions
and casting functions.
</p>

<hr>
<h2 id='vec_ptype2.logical'>Find the common type for a pair of vectors</h2><span id='topic+vec_ptype2.logical'></span><span id='topic+vec_ptype2.integer'></span><span id='topic+vec_ptype2.double'></span><span id='topic+vec_ptype2.complex'></span><span id='topic+vec_ptype2.character'></span><span id='topic+vec_ptype2.raw'></span><span id='topic+vec_ptype2.list'></span><span id='topic+vec_ptype2'></span>

<h3>Description</h3>

<p><code>vec_ptype2()</code> defines the coercion hierarchy for a set of related
vector types. Along with <code><a href="#topic+vec_cast">vec_cast()</a></code>, this generic forms the
foundation of type coercions in vctrs.
</p>
<p><code>vec_ptype2()</code> is relevant when you are implementing vctrs methods
for your class, but it should not usually be called directly. If
you need to find the common type of a set of inputs, call
<code><a href="#topic+vec_ptype_common">vec_ptype_common()</a></code> instead. This function supports multiple
inputs and <a href="#topic+vec_ptype_finalise">finalises</a> the common type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'logical'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'integer'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'double'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'complex'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'character'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'raw'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

## S3 method for class 'list'
vec_ptype2(x, y, ..., x_arg = "", y_arg = "")

vec_ptype2(
  x,
  y,
  ...,
  x_arg = caller_arg(x),
  y_arg = caller_arg(y),
  call = caller_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_ptype2.logical_+3A_x">x</code>, <code id="vec_ptype2.logical_+3A_y">y</code></td>
<td>
<p>Vector types.</p>
</td></tr>
<tr><td><code id="vec_ptype2.logical_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_ptype2.logical_+3A_x_arg">x_arg</code>, <code id="vec_ptype2.logical_+3A_y_arg">y_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>y</code>. These are used
in error messages to inform the user about the locations of
incompatible types (see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code>).</p>
</td></tr>
<tr><td><code id="vec_ptype2.logical_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Implementing coercion methods</h3>


<ul>
<li><p> For an overview of how these generics work and their roles in vctrs,
see <code><a href="#topic+theory-faq-coercion">?theory-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for simple vectors,
see <code><a href="#topic+howto-faq-coercion">?howto-faq-coercion</a></code>.
</p>
</li>
<li><p> For an example of implementing coercion methods for data frame
subclasses, see
<code><a href="#topic+howto-faq-coercion-data-frame">?howto-faq-coercion-data-frame</a></code>.
</p>
</li>
<li><p> For a tutorial about implementing vctrs classes from scratch, see
<code>vignette("s3-vector")</code>.
</p>
</li></ul>



<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_ptype">vec_ptype()</a></code> is applied to <code>x</code> and <code>y</code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code> when you determine from the
attributes that an input can't be cast to the target type.
</p>

<hr>
<h2 id='vec_rank'>Compute ranks</h2><span id='topic+vec_rank'></span>

<h3>Description</h3>

<p><code>vec_rank()</code> computes the sample ranks of a vector. For data frames, ranks
are computed along the rows, using all columns after the first to break
ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_rank(
  x,
  ...,
  ties = c("min", "max", "sequential", "dense"),
  incomplete = c("rank", "na"),
  direction = "asc",
  na_value = "largest",
  nan_distinct = FALSE,
  chr_proxy_collate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_rank_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_rank_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_rank_+3A_ties">ties</code></td>
<td>
<p>Ranking of duplicate values.
</p>

<ul>
<li> <p><code>"min"</code>: Use the current rank for all duplicates. The next non-duplicate
value will have a rank incremented by the number of duplicates present.
</p>
</li>
<li> <p><code>"max"</code>: Use the current rank <code>+ n_duplicates - 1</code> for all duplicates.
The next non-duplicate value will have a rank incremented by the number of
duplicates present.
</p>
</li>
<li> <p><code>"sequential"</code>: Use an increasing sequence of ranks starting at the
current rank, applied to duplicates in order of appearance.
</p>
</li>
<li> <p><code>"dense"</code>: Use the current rank for all duplicates. The next
non-duplicate value will have a rank incremented by <code>1</code>, effectively
removing any gaps in the ranking.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_rank_+3A_incomplete">incomplete</code></td>
<td>
<p>Ranking of missing and <a href="#topic+vec_detect_complete">incomplete</a>
observations.
</p>

<ul>
<li> <p><code>"rank"</code>: Rank incomplete observations normally. Missing values within
incomplete observations will be affected by <code>na_value</code> and <code>nan_distinct</code>.
</p>
</li>
<li> <p><code>"na"</code>: Don't rank incomplete observations at all. Instead, they are
given a rank of <code>NA</code>. In this case, <code>na_value</code> and <code>nan_distinct</code> have
no effect.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_rank_+3A_direction">direction</code></td>
<td>
<p>Direction to sort in.
</p>

<ul>
<li><p> A single <code>"asc"</code> or <code>"desc"</code> for ascending or descending order
respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"asc"</code> or <code>"desc"</code>, specifying the direction for each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_rank_+3A_na_value">na_value</code></td>
<td>
<p>Ordering of missing values.
</p>

<ul>
<li><p> A single <code>"largest"</code> or <code>"smallest"</code> for ordering missing values as the
largest or smallest values respectively.
</p>
</li>
<li><p> For data frames, a length <code>1</code> or <code>ncol(x)</code> character vector containing
only <code>"largest"</code> or <code>"smallest"</code>, specifying how missing values should
be ordered within each column.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_rank_+3A_nan_distinct">nan_distinct</code></td>
<td>
<p>A single logical specifying whether or not <code>NaN</code> should
be considered distinct from <code>NA</code> for double and complex vectors. If <code>TRUE</code>,
<code>NaN</code> will always be ordered between <code>NA</code> and non-missing numbers.</p>
</td></tr>
<tr><td><code id="vec_rank_+3A_chr_proxy_collate">chr_proxy_collate</code></td>
<td>
<p>A function generating an alternate representation
of character vectors to use for collation, often used for locale-aware
ordering.
</p>

<ul>
<li><p> If <code>NULL</code>, no transformation is done.
</p>
</li>
<li><p> Otherwise, this must be a function of one argument. If the input contains
a character vector, it will be passed to this function after it has been
translated to UTF-8. This function should return a character vector with
the same length as the input. The result should sort as expected in the
C-locale, regardless of encoding.
</p>
</li></ul>

<p>For data frames, <code>chr_proxy_collate</code> will be applied to all character
columns.
</p>
<p>Common transformation functions include: <code>tolower()</code> for case-insensitive
ordering and <code>stringi::stri_sort_key()</code> for locale-aware ordering.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike <code><a href="base.html#topic+rank">base::rank()</a></code>, when <code>incomplete = "rank"</code> all missing values are
given the same rank, rather than an increasing sequence of ranks. When
<code>nan_distinct = FALSE</code>, <code>NaN</code> values are given the same rank as <code>NA</code>,
otherwise they are given a rank that differentiates them from <code>NA</code>.
</p>
<p>Like <code><a href="#topic+vec_order_radix">vec_order_radix()</a></code>, ordering is done in the C-locale. This can affect
the ranks of character vectors, especially regarding how uppercase and
lowercase letters are ranked. See the documentation of <code><a href="#topic+vec_order_radix">vec_order_radix()</a></code>
for more information.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_order_radix">vec_order_radix()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(5L, 6L, 3L, 3L, 5L, 3L)

vec_rank(x, ties = "min")
vec_rank(x, ties = "max")

# Sequential ranks use an increasing sequence for duplicates
vec_rank(x, ties = "sequential")

# Dense ranks remove gaps between distinct values,
# even if there are duplicates
vec_rank(x, ties = "dense")

y &lt;- c(NA, x, NA, NaN)

# Incomplete values match other incomplete values by default, and their
# overall position can be adjusted with `na_value`
vec_rank(y, na_value = "largest")
vec_rank(y, na_value = "smallest")

# NaN can be ranked separately from NA if required
vec_rank(y, nan_distinct = TRUE)

# Rank in descending order. Since missing values are the largest value,
# they are given a rank of `1` when ranking in descending order.
vec_rank(y, direction = "desc", na_value = "largest")

# Give incomplete values a rank of `NA` by setting `incomplete = "na"`
vec_rank(y, incomplete = "na")

# Can also rank data frames, using columns after the first to break ties
z &lt;- c(2L, 3L, 4L, 4L, 5L, 2L)
df &lt;- data_frame(x = x, z = z)
df

vec_rank(df)
</code></pre>

<hr>
<h2 id='vec_recycle'>Vector recycling</h2><span id='topic+vec_recycle'></span><span id='topic+vec_recycle_common'></span>

<h3>Description</h3>

<p><code>vec_recycle(x, size)</code> recycles a single vector to a given size.
<code>vec_recycle_common(...)</code> recycles multiple vectors to their common size. All
functions obey the <a href="#topic+theory-faq-recycling">vctrs recycling rules</a>, and will
throw an error if recycling is not possible. See <code><a href="#topic+vec_size">vec_size()</a></code> for the precise
definition of size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_recycle(x, size, ..., x_arg = "", call = caller_env())

vec_recycle_common(..., .size = NULL, .arg = "", .call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_recycle_+3A_x">x</code></td>
<td>
<p>A vector to recycle.</p>
</td></tr>
<tr><td><code id="vec_recycle_+3A_size">size</code></td>
<td>
<p>Desired output size.</p>
</td></tr>
<tr><td><code id="vec_recycle_+3A_...">...</code></td>
<td>
<p>Depending on the function used:
</p>

<ul>
<li><p> For <code>vec_recycle_common()</code>, vectors to recycle.
</p>
</li>
<li><p> For <code>vec_recycle()</code>, these dots should be empty.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vec_recycle_+3A_x_arg">x_arg</code></td>
<td>
<p>Argument name for <code>x</code>. These are used in error
messages to inform the user about which argument has an
incompatible size.</p>
</td></tr>
<tr><td><code id="vec_recycle_+3A_call">call</code>, <code id="vec_recycle_+3A_.call">.call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_recycle_+3A_.size">.size</code></td>
<td>
<p>Desired output size. If omitted,
will use the common size from <code><a href="#topic+vec_size_common">vec_size_common()</a></code>.</p>
</td></tr>
<tr><td><code id="vec_recycle_+3A_.arg">.arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
</table>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Inputs with 1 observation are recycled
vec_recycle_common(1:5, 5)
vec_recycle_common(integer(), 5)
## Not run: 
vec_recycle_common(1:5, 1:2)

## End(Not run)

# Data frames and matrices are recycled along their rows
vec_recycle_common(data.frame(x = 1), 1:5)
vec_recycle_common(array(1:2, c(1, 2)), 1:5)
vec_recycle_common(array(1:3, c(1, 3, 1)), 1:5)
</code></pre>

<hr>
<h2 id='vec_repeat'>Expand the length of a vector</h2><span id='topic+vec_repeat'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vec_repeat()</code> has been replaced with <code><a href="#topic+vec_rep">vec_rep()</a></code> and <code><a href="#topic+vec_rep_each">vec_rep_each()</a></code> and is
deprecated as of vctrs 0.3.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_repeat(x, each = 1L, times = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_repeat_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vec_repeat_+3A_each">each</code></td>
<td>
<p>Number of times to repeat each element of <code>x</code>.</p>
</td></tr>
<tr><td><code id="vec_repeat_+3A_times">times</code></td>
<td>
<p>Number of times to repeat the whole vector of <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector the same type as <code>x</code> with size <code>vec_size(x) * times * each</code>.
</p>

<hr>
<h2 id='vec_seq_along'>Useful sequences</h2><span id='topic+vec_seq_along'></span><span id='topic+vec_init_along'></span>

<h3>Description</h3>

<p><code>vec_seq_along()</code> is equivalent to <code><a href="base.html#topic+seq_along">seq_along()</a></code> but uses size, not length.
<code>vec_init_along()</code> creates a vector of missing values with size matching
an existing object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_seq_along(x)

vec_init_along(x, y = x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_seq_along_+3A_x">x</code>, <code id="vec_seq_along_+3A_y">y</code></td>
<td>
<p>Vectors</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_seq_along()</code> an integer vector with the same size as <code>x</code>.
</p>
</li>
<li> <p><code>vec_init_along()</code> a vector with the same type as <code>x</code> and the same size
as <code>y</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_seq_along(mtcars)
vec_init_along(head(mtcars))
</code></pre>

<hr>
<h2 id='vec_size'>Number of observations</h2><span id='topic+vec_size'></span><span id='topic+vec_size_common'></span><span id='topic+list_sizes'></span><span id='topic+vec_is_empty'></span>

<h3>Description</h3>

<p><code>vec_size(x)</code> returns the size of a vector. <code>vec_is_empty()</code>
returns <code>TRUE</code> if the size is zero, <code>FALSE</code> otherwise.
</p>
<p>The size is distinct from the <code><a href="base.html#topic+length">length()</a></code> of a vector because it
generalises to the &quot;number of observations&quot; for 2d structures,
i.e. it's the number of rows in matrix or a data frame.  This
definition has the important property that every column of a data
frame (even data frame and matrix columns) have the same size.
<code>vec_size_common(...)</code> returns the common size of multiple vectors.
</p>
<p><code>list_sizes()</code> returns an integer vector containing the size of each element
of a list. It is nearly equivalent to, but faster than,
<code>map_int(x, vec_size)</code>, with the exception that <code>list_sizes()</code> will
error on non-list inputs, as defined by <code><a href="#topic+obj_is_list">obj_is_list()</a></code>. <code>list_sizes()</code> is
to <code>vec_size()</code> as <code><a href="base.html#topic+lengths">lengths()</a></code> is to <code><a href="base.html#topic+length">length()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_size(x)

vec_size_common(
  ...,
  .size = NULL,
  .absent = 0L,
  .arg = "",
  .call = caller_env()
)

list_sizes(x)

vec_is_empty(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_size_+3A_x">x</code>, <code id="vec_size_+3A_...">...</code></td>
<td>
<p>Vector inputs or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="vec_size_+3A_.size">.size</code></td>
<td>
<p>If <code>NULL</code>, the default, the output size is determined by
recycling the lengths of all elements of <code>...</code>. Alternatively, you can
supply <code>.size</code> to force a known size; in this case, <code>x</code> and <code>...</code> are
ignored.</p>
</td></tr>
<tr><td><code id="vec_size_+3A_.absent">.absent</code></td>
<td>
<p>The size used when no input is provided, or when all input
is <code>NULL</code>. If left as <code>NULL</code> when no input is supplied, an error is thrown.</p>
</td></tr>
<tr><td><code id="vec_size_+3A_.arg">.arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="vec_size_+3A_.call">.call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is no vctrs helper that retrieves the number of columns: as this
is a property of the <a href="#topic+vec_ptype_show">type</a>.
</p>
<p><code>vec_size()</code> is equivalent to <code>NROW()</code> but has a name that is easier to
pronounce, and throws an error when passed non-vector inputs.
</p>


<h3>Value</h3>

<p>An integer (or double for long vectors).
</p>
<p><code>vec_size_common()</code> returns <code>.absent</code> if all inputs are <code>NULL</code> or
absent, <code>0L</code> by default.
</p>


<h3>Invariants</h3>


<ul>
<li> <p><code>vec_size(dataframe)</code> == <code>vec_size(dataframe[[i]])</code>
</p>
</li>
<li> <p><code>vec_size(matrix)</code> == <code>vec_size(matrix[, i, drop = FALSE])</code>
</p>
</li>
<li> <p><code>vec_size(vec_c(x, y))</code> == <code>vec_size(x)</code> + <code>vec_size(y)</code>
</p>
</li></ul>



<h3>The size of NULL</h3>

<p>The size of <code>NULL</code> is hard-coded to <code>0L</code> in <code>vec_size()</code>.
<code>vec_size_common()</code> returns <code>.absent</code> when all inputs are <code>NULL</code>
(if only some inputs are <code>NULL</code>, they are simply ignored).
</p>
<p>A default size of 0 makes sense because sizes are most often
queried in order to compute a total size while assembling a
collection of vectors. Since we treat <code>NULL</code> as an absent input by
principle, we return the identity of sizes under addition to
reflect that an absent input doesn't take up any size.
</p>
<p>Note that other defaults might make sense under different
circumstances. For instance, a default size of 1 makes sense for
finding the common size because 1 is the identity of the recycling
rules.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+vec_slice">vec_slice()</a></code> for a variation of <code>[</code> compatible with <code>vec_size()</code>,
and <code><a href="#topic+vec_recycle">vec_recycle()</a></code> to <a href="#topic+theory-faq-recycling">recycle</a> vectors to common
length.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec_size(1:100)
vec_size(mtcars)
vec_size(array(dim = c(3, 5, 10)))

vec_size_common(1:10, 1:10)
vec_size_common(1:10, 1)
vec_size_common(integer(), 1)

list_sizes(list("a", 1:5, letters))
</code></pre>

<hr>
<h2 id='vec_slice'>Get or set observations in a vector</h2><span id='topic+vec_slice'></span><span id='topic+vec_slice+3C-'></span><span id='topic+vec_assign'></span>

<h3>Description</h3>

<p>This provides a common interface to extracting and modifying observations
for all vector types, regardless of dimensionality. It is an analog to <code>[</code>
that matches <code><a href="#topic+vec_size">vec_size()</a></code> instead of <code>length()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_slice(x, i, ..., error_call = current_env())

vec_slice(x, i) &lt;- value

vec_assign(x, i, value, ..., x_arg = "", value_arg = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_slice_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_slice_+3A_i">i</code></td>
<td>
<p>An integer, character or logical vector specifying the
locations or names of the observations to get/set. Specify
<code>TRUE</code> to index all elements (as in <code>x[]</code>), or <code>NULL</code>, <code>FALSE</code> or
<code>integer()</code> to index none (as in <code>x[NULL]</code>).</p>
</td></tr>
<tr><td><code id="vec_slice_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec_slice_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec_slice_+3A_value">value</code></td>
<td>
<p>Replacement values. <code>value</code> is cast to the type of
<code>x</code>, but only if they have a common type. See below for examples
of this rule.</p>
</td></tr>
<tr><td><code id="vec_slice_+3A_x_arg">x_arg</code>, <code id="vec_slice_+3A_value_arg">value_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>value</code>. These are used
in error messages to inform the user about the locations of
incompatible types and sizes (see <code><a href="#topic+stop_incompatible_type">stop_incompatible_type()</a></code> and
<code><a href="#topic+stop_incompatible_size">stop_incompatible_size()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same type as <code>x</code>.
</p>


<h3>Genericity</h3>

<p>Support for S3 objects depends on whether the object implements a
<code><a href="#topic+vec_proxy">vec_proxy()</a></code> method.
</p>

<ul>
<li><p> When a <code>vec_proxy()</code> method exists, the proxy is sliced and
<code>vec_restore()</code> is called on the result.
</p>
</li>
<li><p> Otherwise <code>vec_slice()</code> falls back to the base generic <code>[</code>.
</p>
</li></ul>

<p>Note that S3 lists are treated as scalars by default, and will
cause an error if they don't implement a <code><a href="#topic+vec_proxy">vec_proxy()</a></code> method.
</p>


<h3>Differences with base R subsetting</h3>


<ul>
<li> <p><code>vec_slice()</code> only slices along one dimension. For
two-dimensional types, the first dimension is subsetted.
</p>
</li>
<li> <p><code>vec_slice()</code> preserves attributes by default.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;vec_slice&lt;-()&#8288;</code> is type-stable and always returns the same type
as the LHS.
</p>
</li></ul>



<h3>Dependencies</h3>



<h4>vctrs dependencies</h4>


<ul>
<li> <p><code><a href="#topic+vec_proxy">vec_proxy()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_restore">vec_restore()</a></code>
</p>
</li></ul>




<h4>base dependencies</h4>


<ul>
<li> <p><code>base::`[`</code>
</p>
</li></ul>

<p>If a non-data-frame vector class doesn't have a <code><a href="#topic+vec_proxy">vec_proxy()</a></code>
method, the vector is sliced with <code>[</code> instead.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(10)
x
vec_slice(x, 1:3)

# You can assign with the infix variant:
vec_slice(x, 2) &lt;- 100
x

# Or with the regular variant that doesn't modify the original input:
y &lt;- vec_assign(x, 3, 500)
y
x


# Slicing objects of higher dimension:
vec_slice(mtcars, 1:3)

# Type stability --------------------------------------------------

# The assign variant is type stable. It always returns the same
# type as the input.
x &lt;- 1:5
vec_slice(x, 2) &lt;- 20.0

# `x` is still an integer vector because the RHS was cast to the
# type of the LHS:
vec_ptype(x)

# Compare to `[&lt;-`:
x[2] &lt;- 20.0
vec_ptype(x)


# Note that the types must be coercible for the cast to happen.
# For instance, you can cast a double vector of whole numbers to an
# integer vector:
vec_cast(1, integer())

# But not fractional doubles:
try(vec_cast(1.5, integer()))

# For this reason you can't assign fractional values in an integer
# vector:
x &lt;- 1:3
try(vec_slice(x, 2) &lt;- 1.5)
</code></pre>

<hr>
<h2 id='vec_split'>Split a vector into groups</h2><span id='topic+vec_split'></span>

<h3>Description</h3>

<p>This is a generalisation of <code><a href="base.html#topic+split">split()</a></code> that can split by any type of vector,
not just factors. Instead of returning the keys in the character names,
the are returned in a separate parallel vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_split(x, by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_split_+3A_x">x</code></td>
<td>
<p>Vector to divide into groups.</p>
</td></tr>
<tr><td><code id="vec_split_+3A_by">by</code></td>
<td>
<p>Vector whose unique values defines the groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns and size equal to
<code>vec_size(vec_unique(by))</code>. The <code>key</code> column has the same type as
<code>by</code>, and the <code>val</code> column is a list containing elements of type
<code>vec_ptype(x)</code>.
</p>
<p>Note for complex types, the default <code>data.frame</code> print method will be
suboptimal, and you will want to coerce into a tibble to better
understand the output.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_group_loc">vec_group_loc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_chop">vec_chop()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vec_split(mtcars$cyl, mtcars$vs)
vec_split(mtcars$cyl, mtcars[c("vs", "am")])

if (require("tibble")) {
  as_tibble(vec_split(mtcars$cyl, mtcars[c("vs", "am")]))
  as_tibble(vec_split(mtcars, mtcars[c("vs", "am")]))
}
</code></pre>

<hr>
<h2 id='vec_type'>Deprecated type functions</h2><span id='topic+vec_type'></span><span id='topic+vec_type_common'></span><span id='topic+vec_type2'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>These functions have been renamed:
</p>

<ul>
<li> <p><code>vec_type()</code> =&gt; <code><a href="#topic+vec_ptype">vec_ptype()</a></code>
</p>
</li>
<li> <p><code>vec_type2()</code> =&gt; <code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code>vec_type_common()</code> =&gt; <code><a href="#topic+vec_ptype_common">vec_ptype_common()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_type(x)

vec_type_common(..., .ptype = NULL)

vec_type2(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_type_+3A_x">x</code>, <code id="vec_type_+3A_y">y</code>, <code id="vec_type_+3A_...">...</code>, <code id="vec_type_+3A_.ptype">.ptype</code></td>
<td>
<p>Arguments for deprecated functions.</p>
</td></tr>
</table>

<hr>
<h2 id='vec_unchop'>Chopping</h2><span id='topic+vec_unchop'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p><code>vec_unchop()</code> has been renamed to <code><a href="#topic+list_unchop">list_unchop()</a></code> and is deprecated as of
vctrs 0.5.0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_unchop(
  x,
  indices = NULL,
  ptype = NULL,
  name_spec = NULL,
  name_repair = c("minimal", "unique", "check_unique", "universal")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_unchop_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="vec_unchop_+3A_indices">indices</code></td>
<td>
<p>For <code>vec_chop()</code>, a list of positive integer vectors to
slice <code>x</code> with, or <code>NULL</code>. Can't be used if <code>sizes</code> is already specified.
If both <code>indices</code> and <code>sizes</code> are <code>NULL</code>, <code>x</code> is split into its individual
elements, equivalent to using an <code>indices</code> of <code>as.list(vec_seq_along(x))</code>.
</p>
<p>For <code>list_unchop()</code>, a list of positive integer vectors specifying the
locations to place elements of <code>x</code> in. Each element of <code>x</code> is recycled to
the size of the corresponding index vector. The size of <code>indices</code> must
match the size of <code>x</code>. If <code>NULL</code>, <code>x</code> is combined in the order it is
provided in, which is equivalent to using <code><a href="#topic+vec_c">vec_c()</a></code>.</p>
</td></tr>
<tr><td><code id="vec_unchop_+3A_ptype">ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type across all elements of <code>x</code>. Alternatively, you
can supply <code>ptype</code> to give the output a known type.</p>
</td></tr>
<tr><td><code id="vec_unchop_+3A_name_spec">name_spec</code></td>
<td>
<p>A name specification for combining
inner and outer names. This is relevant for inputs passed with a
name, when these inputs are themselves named, like <code>outer = c(inner = 1)</code>, or when they have length greater than 1: <code>outer = 1:2</code>. By default, these cases trigger an error. You can resolve
the error by providing a specification that describes how to
combine the names or the indices of the inner vector with the
name of the input. This specification can be:
</p>

<ul>
<li><p> A function of two arguments. The outer name is passed as a
string to the first argument, and the inner names or positions
are passed as second argument.
</p>
</li>
<li><p> An anonymous function as a purrr-style formula.
</p>
</li>
<li><p> A glue specification of the form <code>"{outer}_{inner}"</code>.
</p>
</li>
<li><p> An <code><a href="rlang.html#topic+zap">rlang::zap()</a></code> object, in which case both outer and inner
names are ignored and the result is unnamed.
</p>
</li></ul>

<p>See the <a href="#topic+name_spec">name specification topic</a>.</p>
</td></tr>
<tr><td><code id="vec_unchop_+3A_name_repair">name_repair</code></td>
<td>
<p>How to repair names, see <code>repair</code> options in
<code><a href="#topic+vec_as_names">vec_as_names()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_chop()</code>: A list where each element has the same type as <code>x</code>. The size
of the list is equal to <code>vec_size(indices)</code>, <code>vec_size(sizes)</code>, or
<code>vec_size(x)</code> depending on whether or not <code>indices</code> or <code>sizes</code> is provided.
</p>
</li>
<li> <p><code>list_unchop()</code>: A vector of type <code>vec_ptype_common(!!!x)</code>, or <code>ptype</code>, if
specified. The size is computed as <code>vec_size_common(!!!indices)</code> unless
the indices are <code>NULL</code>, in which case the size is <code>vec_size_common(!!!x)</code>.
</p>
</li></ul>


<hr>
<h2 id='vec_unique'>Find and count unique values</h2><span id='topic+vec_unique'></span><span id='topic+vec_unique_loc'></span><span id='topic+vec_unique_count'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_unique()</code>: the unique values. Equivalent to <code><a href="base.html#topic+unique">unique()</a></code>.
</p>
</li>
<li> <p><code>vec_unique_loc()</code>: the locations of the unique values.
</p>
</li>
<li> <p><code>vec_unique_count()</code>: the number of unique values.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_unique(x)

vec_unique_loc(x)

vec_unique_count(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_unique_+3A_x">x</code></td>
<td>
<p>A vector (including a data frame).</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>vec_unique()</code>: a vector the same type as <code>x</code> containing only unique
values.
</p>
</li>
<li> <p><code>vec_unique_loc()</code>: an integer vector, giving locations of unique values.
</p>
</li>
<li> <p><code>vec_unique_count()</code>: an integer vector of length 1, giving the
number of unique values.
</p>
</li></ul>



<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li></ul>



<h3>Missing values</h3>

<p>In most cases, missing values are not considered to be equal, i.e.
<code>NA == NA</code> is not <code>TRUE</code>. This behaviour would be unappealing here,
so these functions consider all <code>NAs</code> to be equal. (Similarly,
all <code>NaN</code> are also considered to be equal.)
</p>


<h3>See Also</h3>

<p><a href="#topic+vec_duplicate">vec_duplicate</a> for functions that work with the dual of
unique values: duplicated values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rpois(100, 8)
vec_unique(x)
vec_unique_loc(x)
vec_unique_count(x)

# `vec_unique()` returns values in the order that encounters them
# use sort = "location" to match to the result of `vec_count()`
head(vec_unique(x))
head(vec_count(x, sort = "location"))

# Normally missing values are not considered to be equal
NA == NA

# But they are for the purposes of considering uniqueness
vec_unique(c(NA, NA, NA, NA, 1, 2, 1))
</code></pre>

<hr>
<h2 id='vec-rep'>Repeat a vector</h2><span id='topic+vec-rep'></span><span id='topic+vec_rep'></span><span id='topic+vec_rep_each'></span><span id='topic+vec_unrep'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_rep()</code> repeats an entire vector a set number of <code>times</code>.
</p>
</li>
<li> <p><code>vec_rep_each()</code> repeats each element of a vector a set number of <code>times</code>.
</p>
</li>
<li> <p><code>vec_unrep()</code> compresses a vector with repeated values. The repeated values
are returned as a <code>key</code> alongside the number of <code>times</code> each key is
repeated.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vec_rep(
  x,
  times,
  ...,
  error_call = current_env(),
  x_arg = "x",
  times_arg = "times"
)

vec_rep_each(
  x,
  times,
  ...,
  error_call = current_env(),
  x_arg = "x",
  times_arg = "times"
)

vec_unrep(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec-rep_+3A_x">x</code></td>
<td>
<p>A vector.</p>
</td></tr>
<tr><td><code id="vec-rep_+3A_times">times</code></td>
<td>
<p>For <code>vec_rep()</code>, a single integer for the number of times to repeat
the entire vector.
</p>
<p>For <code>vec_rep_each()</code>, an integer vector of the number of times to repeat
each element of <code>x</code>. <code>times</code> will be <a href="#topic+theory-faq-recycling">recycled</a> to
the size of <code>x</code>.</p>
</td></tr>
<tr><td><code id="vec-rep_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec-rep_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vec-rep_+3A_x_arg">x_arg</code>, <code id="vec-rep_+3A_times_arg">times_arg</code></td>
<td>
<p>Argument names for errors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using <code>vec_unrep()</code> and <code>vec_rep_each()</code> together is similar to using
<code><a href="base.html#topic+rle">base::rle()</a></code> and <code><a href="base.html#topic+rle">base::inverse.rle()</a></code>. The following invariant shows
the relationship between the two functions:
</p>
<div class="sourceCode"><pre>compressed &lt;- vec_unrep(x)
identical(x, vec_rep_each(compressed$key, compressed$times))
</pre></div>
<p>There are two main differences between <code>vec_unrep()</code> and <code><a href="base.html#topic+rle">base::rle()</a></code>:
</p>

<ul>
<li> <p><code>vec_unrep()</code> treats adjacent missing values as equivalent, while <code>rle()</code>
treats them as different values.
</p>
</li>
<li> <p><code>vec_unrep()</code> works along the size of <code>x</code>, while <code>rle()</code> works along its
length. This means that <code>vec_unrep()</code> works on data frames by compressing
repeated rows.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>vec_rep()</code>, a vector the same type as <code>x</code> with size
<code>vec_size(x) * times</code>.
</p>
<p>For <code>vec_rep_each()</code>, a vector the same type as <code>x</code> with size
<code>sum(vec_recycle(times, vec_size(x)))</code>.
</p>
<p>For <code>vec_unrep()</code>, a data frame with two columns, <code>key</code> and <code>times</code>. <code>key</code>
is a vector with the same type as <code>x</code>, and <code>times</code> is an integer vector.
</p>


<h3>Dependencies</h3>


<ul>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Repeat the entire vector
vec_rep(1:2, 3)

# Repeat within each vector
vec_rep_each(1:2, 3)
x &lt;- vec_rep_each(1:2, c(3, 4))
x

# After using `vec_rep_each()`, you can recover the original vector
# with `vec_unrep()`
vec_unrep(x)

df &lt;- data.frame(x = 1:2, y = 3:4)

# `rep()` repeats columns of data frames, and returns lists
rep(df, each = 2)

# `vec_rep()` and `vec_rep_each()` repeat rows, and return data frames
vec_rep(df, 2)
vec_rep_each(df, 2)

# `rle()` treats adjacent missing values as different
y &lt;- c(1, NA, NA, 2)
rle(y)

# `vec_unrep()` treats them as equivalent
vec_unrep(y)
</code></pre>

<hr>
<h2 id='vec-set'>Set operations</h2><span id='topic+vec-set'></span><span id='topic+vec_set_intersect'></span><span id='topic+vec_set_difference'></span><span id='topic+vec_set_union'></span><span id='topic+vec_set_symmetric_difference'></span>

<h3>Description</h3>


<ul>
<li> <p><code>vec_set_intersect()</code> returns all values in both <code>x</code> and <code>y</code>.
</p>
</li>
<li> <p><code>vec_set_difference()</code> returns all values in <code>x</code> but not <code>y</code>. Note
that this is an asymmetric set difference, meaning it is not commutative.
</p>
</li>
<li> <p><code>vec_set_union()</code> returns all values in either <code>x</code> or <code>y</code>.
</p>
</li>
<li> <p><code>vec_set_symmetric_difference()</code> returns all values in either <code>x</code> or <code>y</code>
but not both. This is a commutative difference.
</p>
</li></ul>

<p>Because these are <em>set</em> operations, these functions only return unique values
from <code>x</code> and <code>y</code>, returned in the order they first appeared in the original
input. Names of <code>x</code> and <code>y</code> are retained on the result, but names are always
taken from <code>x</code> if the value appears in both inputs.
</p>
<p>These functions work similarly to <code><a href="base.html#topic+intersect">intersect()</a></code>, <code><a href="base.html#topic+setdiff">setdiff()</a></code>, and <code><a href="base.html#topic+union">union()</a></code>,
but don't strip attributes and can be used with data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_set_intersect(
  x,
  y,
  ...,
  ptype = NULL,
  x_arg = "x",
  y_arg = "y",
  error_call = current_env()
)

vec_set_difference(
  x,
  y,
  ...,
  ptype = NULL,
  x_arg = "x",
  y_arg = "y",
  error_call = current_env()
)

vec_set_union(
  x,
  y,
  ...,
  ptype = NULL,
  x_arg = "x",
  y_arg = "y",
  error_call = current_env()
)

vec_set_symmetric_difference(
  x,
  y,
  ...,
  ptype = NULL,
  x_arg = "x",
  y_arg = "y",
  error_call = current_env()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec-set_+3A_x">x</code>, <code id="vec-set_+3A_y">y</code></td>
<td>
<p>A pair of vectors.</p>
</td></tr>
<tr><td><code id="vec-set_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vec-set_+3A_ptype">ptype</code></td>
<td>
<p>If <code>NULL</code>, the default, the output type is determined by
computing the common type between <code>x</code> and <code>y</code>. If supplied, both <code>x</code> and
<code>y</code> will be cast to this type.</p>
</td></tr>
<tr><td><code id="vec-set_+3A_x_arg">x_arg</code>, <code id="vec-set_+3A_y_arg">y_arg</code></td>
<td>
<p>Argument names for <code>x</code> and <code>y</code>. These are used in error
messages.</p>
</td></tr>
<tr><td><code id="vec-set_+3A_error_call">error_call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are treated as equal to other missing values. For doubles and
complexes, <code>NaN</code> are equal to other <code>NaN</code>, but not to <code>NA</code>.
</p>


<h3>Value</h3>

<p>A vector of the common type of <code>x</code> and <code>y</code> (or <code>ptype</code>, if supplied)
containing the result of the corresponding set function.
</p>


<h3>Dependencies</h3>



<h4><code>vec_set_intersect()</code></h4>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li></ul>




<h4><code>vec_set_difference()</code></h4>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li></ul>




<h4><code>vec_set_union()</code></h4>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_c">vec_c()</a></code>
</p>
</li></ul>




<h4><code>vec_set_symmetric_difference()</code></h4>


<ul>
<li> <p><code><a href="#topic+vec_proxy_equal">vec_proxy_equal()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_slice">vec_slice()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_ptype2">vec_ptype2()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_cast">vec_cast()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+vec_c">vec_c()</a></code>
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 1, 4, 3)
y &lt;- c(2, 5, 5, 1)

# All unique values in both `x` and `y`.
# Duplicates in `x` and `y` are always removed.
vec_set_intersect(x, y)

# All unique values in `x` but not `y`
vec_set_difference(x, y)

# All unique values in either `x` or `y`
vec_set_union(x, y)

# All unique values in either `x` or `y` but not both
vec_set_symmetric_difference(x, y)

# These functions can also be used with data frames
x &lt;- data_frame(
  a = c(2, 3, 2, 2),
  b = c("j", "k", "j", "l")
)
y &lt;- data_frame(
  a = c(1, 2, 2, 2, 3),
  b = c("j", "l", "j", "l", "j")
)

vec_set_intersect(x, y)
vec_set_difference(x, y)
vec_set_union(x, y)
vec_set_symmetric_difference(x, y)

# Vector names don't affect set membership, but if you'd like to force
# them to, you can transform the vector into a two column data frame
x &lt;- c(a = 1, b = 2, c = 2, d = 3)
y &lt;- c(c = 2, b = 1, a = 3, d = 3)

vec_set_intersect(x, y)

x &lt;- data_frame(name = names(x), value = unname(x))
y &lt;- data_frame(name = names(y), value = unname(y))

vec_set_intersect(x, y)
</code></pre>

<hr>
<h2 id='vector-checks'>Vector checks</h2><span id='topic+vector-checks'></span><span id='topic+obj_is_vector'></span><span id='topic+obj_check_vector'></span><span id='topic+vec_check_size'></span>

<h3>Description</h3>


<ul>
<li> <p><code>obj_is_vector()</code> tests if <code>x</code> is considered a vector in the vctrs sense.
See <em>Vectors and scalars</em> below for the exact details.
</p>
</li>
<li> <p><code>obj_check_vector()</code> uses <code>obj_is_vector()</code> and throws a standardized and
informative error if it returns <code>FALSE</code>.
</p>
</li>
<li> <p><code>vec_check_size()</code> tests if <code>x</code> has size <code>size</code>, and throws an informative
error if it doesn't.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>obj_is_vector(x)

obj_check_vector(x, ..., arg = caller_arg(x), call = caller_env())

vec_check_size(x, size, ..., arg = caller_arg(x), call = caller_env())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vector-checks_+3A_x">x</code></td>
<td>
<p>For <code style="white-space: pre;">&#8288;obj_*()&#8288;</code> functions, an object. For <code style="white-space: pre;">&#8288;vec_*()&#8288;</code> functions, a
vector.</p>
</td></tr>
<tr><td><code id="vector-checks_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
<tr><td><code id="vector-checks_+3A_arg">arg</code></td>
<td>
<p>An argument name as a string. This argument
will be mentioned in error messages as the input that is at the
origin of a problem.</p>
</td></tr>
<tr><td><code id="vector-checks_+3A_call">call</code></td>
<td>
<p>The execution environment of a currently
running function, e.g. <code>caller_env()</code>. The function will be
mentioned in error messages as the source of the error. See the
<code>call</code> argument of <code><a href="rlang.html#topic+abort">abort()</a></code> for more information.</p>
</td></tr>
<tr><td><code id="vector-checks_+3A_size">size</code></td>
<td>
<p>The size to check for.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>obj_is_vector()</code> returns a single <code>TRUE</code> or <code>FALSE</code>.
</p>
</li>
<li> <p><code>obj_check_vector()</code> returns <code>NULL</code> invisibly, or errors.
</p>
</li>
<li> <p><code>vec_check_size()</code> returns <code>NULL</code> invisibly, or errors.
</p>
</li></ul>



<h3>Vectors and scalars</h3>

<p>Informally, a vector is a collection that makes sense to use as column in a
data frame. The following rules define whether or not <code>x</code> is considered a
vector.
</p>
<p>If no <code><a href="#topic+vec_proxy">vec_proxy()</a></code> method has been registered, <code>x</code> is a vector if:
</p>

<ul>
<li><p> The <a href="base.html#topic+typeof">base type</a> of the object is atomic: <code>"logical"</code>, <code>"integer"</code>,
<code>"double"</code>, <code>"complex"</code>, <code>"character"</code>, or <code>"raw"</code>.
</p>
</li>
<li> <p><code>x</code> is a list, as defined by <code><a href="#topic+obj_is_list">obj_is_list()</a></code>.
</p>
</li>
<li> <p><code>x</code> is a <a href="base.html#topic+data.frame">data.frame</a>.
</p>
</li></ul>

<p>If a <code>vec_proxy()</code> method has been registered, <code>x</code> is a vector if:
</p>

<ul>
<li><p> The proxy satisfies one of the above conditions.
</p>
</li>
<li><p> The base type of the proxy is <code>"list"</code>, regardless of its class. S3 lists
are thus treated as scalars unless they implement a <code>vec_proxy()</code> method.
</p>
</li></ul>

<p>Otherwise an object is treated as scalar and cannot be used as a vector.
In particular:
</p>

<ul>
<li> <p><code>NULL</code> is not a vector.
</p>
</li>
<li><p> S3 lists like <code>lm</code> objects are treated as scalars by default.
</p>
</li>
<li><p> Objects of type <a href="base.html#topic+expression">expression</a> are not treated as vectors.
</p>
</li></ul>



<h3>Technical limitations</h3>


<ul>
<li><p> Support for S4 vectors is currently limited to objects that inherit from an
atomic type.
</p>
</li>
<li><p> Subclasses of <a href="base.html#topic+data.frame">data.frame</a> that <em>append</em> their class to the back of the
<code>"class"</code> attribute are not treated as vectors. If you inherit from an S3
class, always prepend your class to the front of the <code>"class"</code> attribute
for correct dispatch. This matches our general principle of allowing
subclasses but not mixins.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>obj_is_vector(1)

# Data frames are vectors
obj_is_vector(data_frame())

# Bare lists are vectors
obj_is_vector(list())

# S3 lists are vectors if they explicitly inherit from `"list"`
x &lt;- structure(list(), class = c("my_list", "list"))
obj_is_list(x)
obj_is_vector(x)

# But if they don't explicitly inherit from `"list"`, they aren't
# automatically considered to be vectors. Instead, vctrs considers this
# to be a scalar object, like a linear model returned from `lm()`.
y &lt;- structure(list(), class = "my_list")
obj_is_list(y)
obj_is_vector(y)

# `obj_check_vector()` throws an informative error if the input
# isn't a vector
try(obj_check_vector(y))

# `vec_check_size()` throws an informative error if the size of the
# input doesn't match `size`
vec_check_size(1:5, size = 5)
try(vec_check_size(1:5, size = 4))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
