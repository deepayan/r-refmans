<!DOCTYPE html><html lang="en"><head><title>Help for package RGBM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RGBM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_names'>
<p>Add row and column names to the adjacency matrix A</p></a></li>
<li><a href='#apply_row_deviation'>
<p>Apply row-wise deviation on the inferred GRN</p></a></li>
<li><a href='#consider_previous_information'>
<p>Remember the intermediate inferred GRN while generating the final inferred GRN</p></a></li>
<li><a href='#first_GBM_step'>
<p>Perform either LS-Boost or LAD-Boost (<code>GBM</code>) on expression matrix E followed by the <code>null_model_refinement_step</code></p></a></li>
<li><a href='#GBM'>
<p>Calculate Gene Regulatory Network from Expression data using either LS-TreeBoost or LAD-TreeBoost</p></a></li>
<li><a href='#GBM.test'>
<p>Test GBM predictor</p></a></li>
<li><a href='#GBM.train'>
<p>Train GBM predictor</p></a></li>
<li><a href='#get_colids'>
<p>Get the indices of recitifed list of Tfs for individual target gene</p></a></li>
<li><a href='#get_filepaths'>
<p>Generate filepaths to maintain adjacency matrices and images</p></a></li>
<li><a href='#get_ko_experiments'>
<p>Get indices of experiments where knockout or knockdown happened</p></a></li>
<li><a href='#get_tf_indices'>
<p>Get the indices of all the TFs from the data</p></a></li>
<li><a href='#normalize_matrix_colwise'>
<p>Column normalize the obtained adjacency matrix</p></a></li>
<li><a href='#null_model_refinement_step'>
<p>Perform the null model refinement step</p></a></li>
<li><a href='#regularized_GBM_step'>
<p>Perform the regularized GBM modelling once the initial GRN is inferred</p></a></li>
<li><a href='#regulate_regulon_size'>
<p>Regulate the size of the regulon for each TF</p></a></li>
<li><a href='#RGBM'>
<p>Regularized Gradient Boosting Machine for inferring GRN</p></a></li>
<li><a href='#RGBM.test'>
<p>Test rgbm predictor</p></a></li>
<li><a href='#RGBM.train'>
<p>Train RGBM predictor</p></a></li>
<li><a href='#second_GBM_step'>
<p>Re-iterate through the core GBM model building with optimal set of Tfs for each target gene</p></a></li>
<li><a href='#select_ideal_k'>
<p>Identifies the optimal value of k i.e. top k Tfs for each target gene</p></a></li>
<li><a href='#test_regression_stump_R'>
<p>Test the regression model</p></a></li>
<li><a href='#train_regression_stump_R'>
<p>Train the regression stump</p></a></li>
<li><a href='#transform_importance_to_weights'>
<p>Log transforms the edge-weights in the inferred GRN</p></a></li>
<li><a href='#v2l'>
<p>Convert adjacency matrix to a list of edges</p></a></li>
<li><a href='#z_score_effect'>
<p>Generates a matrix S2 of size Ntfs x Ntargets using the null-mutant zscore algorithm <cite>Prill, Robert J., et al</cite></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>LS-TreeBoost and LAD-TreeBoost for Gene Regulatory Network
Reconstruction</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-13</td>
</tr>
<tr>
<td>Author:</td>
<td>Raghvendra Mall [aut, cre],
  Khalid Kunji [aut],
  Melissa O'Neill [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raghvendra Mall &lt;raghvendra5688@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides an implementation of Regularized LS-TreeBoost &amp; LAD-TreeBoost algorithm for Regulatory Network inference from any type of expression data (Microarray/RNA-seq etc).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>foreach, plyr, doParallel</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-13 05:20:19 UTC; raghvendra</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-14 08:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_names'>
Add row and column names to the adjacency matrix A
</h2><span id='topic+add_names'></span>

<h3>Description</h3>

<p>Here we add the names of the transcription factors (Tfs) as rownames and names of the target genes as column names to the adjacency matrix A.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_names(A, tfs, targets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_names_+3A_a">A</code></td>
<td>

<p>Adjacency matrix A obtained as a result of GBM procedure.
</p>
</td></tr>
<tr><td><code id="add_names_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors.
</p>
</td></tr>
<tr><td><code id="add_names_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case of DREAM Challenge datasets list of transcription factors is same as list of target genes and are referred as G1, ..., G100.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='apply_row_deviation'>
Apply row-wise deviation on the inferred GRN
</h2><span id='topic+apply_row_deviation'></span>

<h3>Description</h3>

<p>This function performs a row-wise standard deviation of network A to generate an S1 matrix which is then used to modify the weights in network A</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_row_deviation(A,Ntfs,Ntargets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_row_deviation_+3A_a">A</code></td>
<td>

<p>Inferred GRN in the form of Ntfs-by-Ntargets matrix
</p>
</td></tr>
<tr><td><code id="apply_row_deviation_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="apply_row_deviation_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Refined adjacency matrix A in the form of Ntfs-by-Ntargets matrix
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='consider_previous_information'>
Remember the intermediate inferred GRN while generating the final inferred GRN
</h2><span id='topic+consider_previous_information'></span>

<h3>Description</h3>

<p>This function combines the adjacency matrix A_prev obtained as a result of <code><a href="#topic+first_GBM_step">first_GBM_step</a></code> with the adjacency matrix A obtained as a result of <code><a href="#topic+second_GBM_step">second_GBM_step</a></code>. All the edges in the matrix A which have non-zero weights are given machine precision weights initially. We then perform a harmonic mean for each element of A_prev and A to obtain a regularized adjacency matrix (A_final). As a result of this procedure transcriptional regulations which were strong and present in both A_prev and A end up getting highest weights in A_final. We finally remove all edges whose weights are less than machine precision from A_final. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consider_previous_information(A, A_prev,real)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consider_previous_information_+3A_a">A</code></td>
<td>

<p>Inferred GRN from the <code><a href="#topic+second_GBM_step">second_GBM_step</a></code>
</p>
</td></tr>
<tr><td><code id="consider_previous_information_+3A_a_prev">A_prev</code></td>
<td>

<p>Inferred GRN from the <code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>
</td></tr>
<tr><td><code id="consider_previous_information_+3A_real">real</code></td>
<td>

<p>Numeric value 0 or 1 corresponding to simulated or real experiment respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an adjacency matrix A_final of the form Ntfs-by-Ntargets
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+first_GBM_step">first_GBM_step</a></code>, <code><a href="#topic+second_GBM_step">second_GBM_step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The function is currently defined as
function (A, A_prev) 
{
  #Utilize Past Information also to not remove true positives
  A_prev[A_prev==0] &lt;- .Machine$double.eps;
  A_prev &lt;- transform_importance_to_weights(A_prev);
  A[A==0] &lt;- .Machine$double.eps;
  epsilon &lt;- 1/log(1/.Machine$double.eps);
  A &lt;- transform_importance_to_weights(A);
  A_final &lt;- 2*A*A_prev/(A+A_prev);
  A_final &lt;- A_final - epislon;
  A_final[A_final&lt;0] &lt;- 0.0;
  return(A_final);
}
</code></pre>

<hr>
<h2 id='first_GBM_step'>
Perform either LS-Boost or LAD-Boost (<code><a href="#topic+GBM">GBM</a></code>) on expression matrix E followed by the <code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code>
</h2><span id='topic+first_GBM_step'></span>

<h3>Description</h3>

<p>This function utilizes the core gradient boosting machine model (<code><a href="#topic+GBM">GBM</a></code>) followed by the refinement step to generate the first adjacency matrix A of size p x p using the list of Tfs and the set of target genes. Several such adjacency matrices (A) are obtained based on the number of iterations to be performed. All these adjacency matrices are averaged to reduce the noise in the inferred intermediate GRN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>first_GBM_step(E, K, tfs, targets, Ntfs, Ntargets, lf, M, nu,s_f, no_iterations)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="first_GBM_step_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes.  By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors. In case of presence of prior mechanistic network it is a subset of all the p genes whereas in absence of such a mechanistic network it is a list of names of all the p genes. 
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes. In case of presence of prior mechanistic network it is a subset of all the p genes whereas in absence of such a mechanistic network it is a list of names of all the p genes. 
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_lf">lf</code></td>
<td>

<p>Loss Function: 1 -&gt; Least Squares and 2 -&gt; Least Absolute Deviation  
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_m">M</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of transcription factors, 0&lt;s_f&lt;=1. Fraction of transcription factors from E, as indicated by <code>tfs</code> vector, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="first_GBM_step_+3A_no_iterations">no_iterations</code></td>
<td>

<p>Number of iterations to perform equivalent to building that many core LS-Boost/LAD-Boost models and then averaging them to have smooth edge-weights in the inferred intermediate GRN. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Intermediate Gene Regulatory Network in form of a Ntfs-by-Ntargets adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+second_GBM_step">second_GBM_step</a></code>
</p>

<hr>
<h2 id='GBM'>
Calculate Gene Regulatory Network from Expression data using either LS-TreeBoost or LAD-TreeBoost
</h2><span id='topic+GBM'></span>

<h3>Description</h3>

<p>This function calculates a Ntfs-by-Ntargets adjacency matrix A from N-by-p expression matrix E. E is expected to be given as input. E is assumed to have p columns corresponding to all the genes, Ntfs represents the number of transcription factors and Ntargets represents the number of target genes and N rows corresponding to different experiments. Additionally, GBM function takes matrix of initial perturbations of genes K of the same size as E, and other parameters including which loss function to use (LS = 1, LAD = 2). As a result, GBM returns a squared matrix A of edge confidences of size Ntfs-by-Ntargets. A subset of known transcription factors can be defined as a subset of all p genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBM(E = matrix(rnorm(100), 10, 10), K = matrix(0, nrow(E), ncol(E)), 
     tfs = paste0("G",c(1:10)), targets = paste0("G",c(1:10)), 
     s_s = 1, s_f = 0.3, lf = 1, 
     M = 5000,nu = 0.001, scale = TRUE,center = TRUE, optimization.stage = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GBM_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes. By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors
</p>
</td></tr>
<tr><td><code id="GBM_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes
</p>
</td></tr>
<tr><td><code id="GBM_+3A_s_s">s_s</code></td>
<td>

<p>Sampling rate of experiments, 0&lt;s_s&lt;=1. Fraction of rows of E, which will be sampled with replacement to calculate each extension in boosting model. By default it's 1.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of transcription factors, 0&lt;s_f&lt;=1. Fraction of transcription factors from E, as indicated by <code>tfs</code> vector, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_lf">lf</code></td>
<td>

<p>Loss function: 1 -&gt; Least Squares, 2 -&gt; Least Absolute deviation
</p>
</td></tr>
<tr><td><code id="GBM_+3A_m">M</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_scale">scale</code></td>
<td>

<p>Logical flag indicating if each column of E should be scaled to be unit standard deviation. By default it's TRUE.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_center">center</code></td>
<td>

<p>Logical flag indicating if each column of E should be scaled to be zero mean. By default it's TRUE.
</p>
</td></tr>
<tr><td><code id="GBM_+3A_optimization.stage">optimization.stage</code></td>
<td>

<p>Numerical flag indicating if re-evaluation of edge confidences should be applied after calculating initial V, optimization.stage={0,1,2}. If optimization.stage=0, no re-evaluation will be applied. If optimization.stage=1, variance-based optimization will be applied. If optimization.stage=2, variance-based and z-score based optimizations will be applied.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>A</code></td>
<td>

<p>Gene Regulatory Network in form of a Ntfs-by-Ntargets adjacency matrix.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GBM.train">GBM.train</a></code>, <code><a href="#topic+GBM.test">GBM.test</a></code>, <code><a href="#topic+v2l">v2l</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load RGBM library
library("RGBM")
# this step is optional, it helps speed up calculations, run in parallel on 2 processors
library(doParallel)
cl &lt;- makeCluster(2)
# run network inference on a 100-by-100 dummy expression data.
V = GBM()
stopCluster(cl)
</code></pre>

<hr>
<h2 id='GBM.test'>
Test GBM predictor
</h2><span id='topic+GBM.test'></span>

<h3>Description</h3>

<p>This function tests a regression model for a given <code>X.test</code> feature matrix, <code>Y.test</code> response vector, and working parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBM.test(model, X.test, Y.test, M.test)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GBM.test_+3A_model">model</code></td>
<td>

<p>Model returned by <code><a href="#topic+GBM.train">GBM.train</a></code> function.
</p>
</td></tr>
<tr><td><code id="GBM.test_+3A_x.test">X.test</code></td>
<td>

<p>Input N-by-p feature matrix of unseen samples. Columns correspond to features, rows correspond to samples.
</p>
</td></tr>
<tr><td><code id="GBM.test_+3A_y.test">Y.test</code></td>
<td>

<p>Input N-element response vector of unseen samples.
</p>
</td></tr>
<tr><td><code id="GBM.test_+3A_m.test">M.test</code></td>
<td>

<p>Number of extensions of boosting model to take when predicting response. Must be not greater than <code>M.train</code> used when training boosting model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of regression
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GBM.train">GBM.train</a></code>
</p>

<hr>
<h2 id='GBM.train'>
Train GBM predictor
</h2><span id='topic+GBM.train'></span>

<h3>Description</h3>

<p>This function trains a regression model for a given <code>X.train</code> feature matrix, <code>Y.train</code> response vector, and working parameters. A model returned by this function can be used to predict response for unseen data with <code><a href="#topic+GBM.test">GBM.test</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GBM.train(X.train, Y.train, s_f = 0.3, s_s = 1, lf =1, M.train = 5000, nu = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GBM.train_+3A_x.train">X.train</code></td>
<td>

<p>Input N-by-p feature matrix of training samples. Columns correspond to features, rows correspond to samples.
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_y.train">Y.train</code></td>
<td>

<p>Input N-element response vector of training samples.
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of features, 0&lt;s_f&lt;=1. Fraction of columns from X.train, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_s_s">s_s</code></td>
<td>

<p>Sampling rate of samples, 0&lt;s_s&lt;=1. Fraction of rows from X.train, which will be sampled with replacement to calculate each extension in boosting model. By default it's 1.
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_lf">lf</code></td>
<td>

<p>Loss function: 1-&gt; Least Squares and 2 -&gt; Least Absolute Deviation
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_m.train">M.train</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="GBM.train_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Regression model is a structure containing all the information needed to predict response for unseen data
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GBM.test">GBM.test</a></code>
</p>

<hr>
<h2 id='get_colids'>
Get the indices of recitifed list of Tfs for individual target gene 
</h2><span id='topic+get_colids'></span>

<h3>Description</h3>

<p>This function is used to identify the recitified list of transcription factors for individual target genes after analysing the variable importance scores (where non-essential Tfs are pruned). These list of Tfs are usually different for individual target genes. Hence we maintain this in the form an adjacency matrix where the rownames correspond to all the Tfs and colnames correspond to all the target genes. Each column is a binary vector where all the values corresponding to the rectified Tfs active for that target are 1 while rest of the values are zeros.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_colids(A, ideal_k, tfs, targets, Ntfs, Ntargets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_colids_+3A_a">A</code></td>
<td>

<p>Adjacency Matrix A obtained after the GBM and refinement step.
</p>
</td></tr>
<tr><td><code id="get_colids_+3A_ideal_k">ideal_k</code></td>
<td>

<p>A vector containing the optimal value of k (no of active TFs) for each target gene obtained from <code><a href="#topic+select_ideal_k">select_ideal_k</a></code>.
</p>
</td></tr>
<tr><td><code id="get_colids_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors.
</p>
</td></tr>
<tr><td><code id="get_colids_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes.
</p>
</td></tr>
<tr><td><code id="get_colids_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="get_colids_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an adjacency matrix where the rownames correspond to all the Tfs and colnames correspond to all the target genes. Each column is a binary vector where all the values corresponding to the rectified Tfs active for that target are 1 while rest of the values are zeros.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_tf_indices">get_tf_indices</a></code>
</p>

<hr>
<h2 id='get_filepaths'>
Generate filepaths to maintain adjacency matrices and images
</h2><span id='topic+get_filepaths'></span>

<h3>Description</h3>

<p>This function generates a set of filepaths which are used to keep the adjacency matrix A obtained after the <code><a href="#topic+first_GBM_step">first_GBM_step</a></code> + <code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code>. It also generates a path where an image of the variable importance curves for several target genes can be kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_filepaths(A_prev, experimentid, outputpath, sample_type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_filepaths_+3A_a_prev">A_prev</code></td>
<td>

<p>Adjacency matrix A obtained after <code><a href="#topic+first_GBM_step">first_GBM_step</a></code> + <code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code>.
</p>
</td></tr>
<tr><td><code id="get_filepaths_+3A_experimentid">experimentid</code></td>
<td>

<p>The id of the experiment being conducted. It takes natural numbers like 1,2,3 etc. By default it's 1.
</p>
</td></tr>
<tr><td><code id="get_filepaths_+3A_outputpath">outputpath</code></td>
<td>

<p>Location where the Adjacency_Matrix and Images folder will be created.
</p>
</td></tr>
<tr><td><code id="get_filepaths_+3A_sample_type">sample_type</code></td>
<td>

<p>String arguement representing a label for the experiment i.e. in case of DREAM3 challenge sample_type=&quot;DREAM3&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame where the first element in the data frame is the location where the Adjacency_Matrix folder is located in the filesystem, second element represents the location where the Images folder is located in the filesystem, third element represents the path to the file where the Adjacency_Matrix will be written.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='get_ko_experiments'>
Get indices of experiments where knockout or knockdown happened
</h2><span id='topic+get_ko_experiments'></span>

<h3>Description</h3>

<p>This function provides the indices of all those samples (out of N) where it is known apriori that a gene was either knocked-out or was knocked-down. This information is useful for the <code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code> which utilizes the <code><a href="#topic+z_score_effect">z_score_effect</a></code> technique (with the help of this information).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ko_experiments(K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_ko_experiments_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes.  By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a vector containing the indices of all the samples where a gene was knocked-out/down.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code>, <code><a href="#topic+z_score_effect">z_score_effect</a></code>
</p>

<hr>
<h2 id='get_tf_indices'>
Get the indices of all the TFs from the data
</h2><span id='topic+get_tf_indices'></span>

<h3>Description</h3>

<p>This function provides the indices of all the transcription factors which are present in the expression matrix. In case of DREAM Challenges it will return the indices as 1,...,p for all the p genes in the data as the transcription factors are not known beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tf_indices(E, tfs, Ntfs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_tf_indices_+3A_e">E</code></td>
<td>

<p>E is the expression matrix of size N x p where N is number of examples and p is the number of genes. Here the column names of expression matrix is the list of all the genes present in the E matrix. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="get_tf_indices_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors.
</p>
</td></tr>
<tr><td><code id="get_tf_indices_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the indices of all the transcription factors present in E matrix.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_colids">get_colids</a></code>
</p>

<hr>
<h2 id='normalize_matrix_colwise'>
Column normalize the obtained adjacency matrix
</h2><span id='topic+normalize_matrix_colwise'></span>

<h3>Description</h3>

<p>We perform a column normalization on an adjacency matrix A equivalent to inferred GRN 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_matrix_colwise(A,Ntargets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_matrix_colwise_+3A_a">A</code></td>
<td>

<p>Inferred GRN in the form of Ntfs-by-Ntargets matrix
</p>
</td></tr>
<tr><td><code id="normalize_matrix_colwise_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Column Normalized GRN of size Ntfs-by-Ntargets
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='null_model_refinement_step'>
Perform the null model refinement step
</h2><span id='topic+null_model_refinement_step'></span>

<h3>Description</h3>

<p>We used this function for refining the edge-weights in an inferred GRN (A) by utilizing matrix (S2) obtained from null-mutant zscore effect (<code><a href="#topic+z_score_effect">z_score_effect</a></code>) as shown in <cite>Slawek J, Arodz T</cite> i.e. A = A x S2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>null_model_refinement_step(E, A, K,tfs, targets, Ntfs, Ntargets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="null_model_refinement_step_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_a">A</code></td>
<td>

<p>Intermediate GRN network in the form of a p-by-p adjacency matrix.
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes.  By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_ntfs">Ntfs</code></td>
<td>

<p>Number of transcription factors used while building the GBM (<code><a href="#topic+GBM">GBM</a></code>) model.
</p>
</td></tr>
<tr><td><code id="null_model_refinement_step_+3A_ntargets">Ntargets</code></td>
<td>

<p>Number of targets used while building the GBM (<code><a href="#topic+GBM">GBM</a></code>) model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a refined adjacency matrix A in the form of a Ntfs-by-Ntargets matrix.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>References</h3>

<p>Slawek J, Arodz T. ENNET: inferring large gene regulatory networks from expression data using gradient boosting. BMC systems biology. 2013 Oct 22;7(1):1.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+z_score_effect">z_score_effect</a></code>
</p>

<hr>
<h2 id='regularized_GBM_step'>
Perform the regularized GBM modelling once the initial GRN is inferred
</h2><span id='topic+regularized_GBM_step'></span>

<h3>Description</h3>

<p>This function undertakes all the proposed steps for regularizing the list of transcription factors for individual target gene followed by re-iterating through the core GBM model and the refinement step to produce the final reverse engineered GRN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regularized_GBM_step(E, A_prev, K, tfs, targets, Ntfs, Ntargets, lf, M, nu, s_f,
                     experimentid, outputpath, sample_type, mink=0,real=0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regularized_GBM_step_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_a_prev">A_prev</code></td>
<td>

<p>An intermediate inferred GRN obtained from <code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes. By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_lf">lf</code></td>
<td>

<p>Loss Function: 1 -&gt; Least Squares and 2 -&gt; Least Absolute Deviation  
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_m">M</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of transcription factors, 0&lt;s_f&lt;=1. Fraction of transcription factors from E, as indicated by <code>tfs</code> vector, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_experimentid">experimentid</code></td>
<td>

<p>The id of the experiment being conducted. It takes natural numbers like 1,2,3 etc. By default it's 1.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_outputpath">outputpath</code></td>
<td>

<p>Location where the Adjacency_Matrix and Images folder will be created.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_sample_type">sample_type</code></td>
<td>

<p>String arguement representing a label for the experiment i.e. in case of DREAM3 challenge sample_type=&quot;DREAM3&quot;.
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_mink">mink</code></td>
<td>

<p>User specified threshold i.e. the minimum number of Tfs to be considered while optimizing the L-curve criterion. By default it's 0. 
</p>
</td></tr>
<tr><td><code id="regularized_GBM_step_+3A_real">real</code></td>
<td>

<p>Numeric value 0 or 1 corresponding to simulated or real experiment respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the final inferred GRN in form of Ntfs-by-Ntargets matrix
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>

<hr>
<h2 id='regulate_regulon_size'>
Regulate the size of the regulon for each TF
</h2><span id='topic+regulate_regulon_size'></span>

<h3>Description</h3>

<p>We control the size of the regulon for each TF by using a heuristic to remove the edges whose weights are small
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regulate_regulon_size(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regulate_regulon_size_+3A_a">A</code></td>
<td>

<p>Inferred GRN in the form of Ntfs-by-Ntargets matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Refined adjacency matrix A in the form of Ntfs-by-Ntargets matrix
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='RGBM'>
Regularized Gradient Boosting Machine for inferring GRN
</h2><span id='topic+RGBM'></span>

<h3>Description</h3>

<p>This function performs the proposed regularized gradient boosting machines for reverse engineering GRN. It allows the user to provide prior information in the form of a mechanistic network g_M and after generation of an initially inferred GRN using the core GBM model undergoes a pruning step. Here we detect and remove isolated nodes using the <code><a href="#topic+select_ideal_k">select_ideal_k</a></code> function along with identification of the optimal set of transcription factors for each target gene. We then re-iterate through the GBM followed by the refinement step to generate the final re-constructed GRN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGBM(E = matrix(rnorm(100), 10, 10), K = matrix(0, nrow(E), ncol(E)), 
     g_M = matrix(1, 10, 10), tfs = paste0("G", c(1:10)), 
     targets = paste0("G", c(1:10)), lf = 1, M = 5000, nu = 0.001, s_f = 0.3,
     no_iterations = 2, mink = 0, experimentid = 1, outputpath= "DEFAULT",
     sample_type = "Exp1_", real = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGBM_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all p genes and Ntfs represents the number of transcription factors and Ntargets represents the number of target genes.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes.  By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_g_m">g_M</code></td>
<td>

<p>Initial mechanistic network in the form of an adajcency matrix (Ntf-by-Ntargets). Here each column is a binary vector where only those elements are 1 when the corresponding transcription factor has a connection with that target gene. Colnames of g_M should be same as names of targets and Rownames of g_M should be same as names of Tfs. By default it's a matrix of ones of size Ntfs x Ntargets.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_lf">lf</code></td>
<td>

<p>Loss Function: 1 -&gt; Least Squares and 2 -&gt; Least Absolute Deviation
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_m">M</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of transcription factors, 0&lt;s_f&lt;=1. Fraction of transcription factors from E, as indicated by <code>tfs</code> vector, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_no_iterations">no_iterations</code></td>
<td>

<p>Number of times initial GRN to be constructed and then averaged to generate smooth edge weights for the initial GRN as shown in <code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_mink">mink</code></td>
<td>

<p>specified threshold i.e. the minimum number of Tfs to be considered while optimizing the L-curve criterion. By default it's 0. 
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_experimentid">experimentid</code></td>
<td>

<p>The id of the experiment being conducted. It takes natural numbers like 1,2,3 etc. By default it's 1.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_outputpath">outputpath</code></td>
<td>

<p>Location where intermediate Adjacency_Matrix and Images folder will be created.  By default 
it's a temp directory (e.g. /tmp/Rtmp...)
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_sample_type">sample_type</code></td>
<td>

<p>String arguement representing a label for the experiment i.e. in case of DREAM3 challenge sample_type=&quot;DREAM3&quot;.
</p>
</td></tr>
<tr><td><code id="RGBM_+3A_real">real</code></td>
<td>

<p>Numeric value 0 or 1 corresponding to simulated or real experiment respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the final inferred GRN of form Ntfs-by-Ntargets adjacency matrix.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+select_ideal_k">select_ideal_k</a></code>, <code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load RGBM library
library("RGBM")
# this step is optional, it helps speed up calculations, run in parallel on 2 processors
library(doParallel)
cl &lt;- makeCluster(2)
# run network inference on a 100-by-100 dummy expression data.
A = RGBM()
stopCluster(cl)

</code></pre>

<hr>
<h2 id='RGBM.test'>
Test rgbm predictor
</h2><span id='topic+RGBM.test'></span>

<h3>Description</h3>

<p>This function tests a regression model for a given <code>X.test</code> feature matrix, <code>Y.test</code> response vector, and working parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGBM.test(model, X.test, Y.test, M.test)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGBM.test_+3A_model">model</code></td>
<td>

<p>Model returned by <code><a href="#topic+RGBM.train">RGBM.train</a></code> function.
</p>
</td></tr>
<tr><td><code id="RGBM.test_+3A_x.test">X.test</code></td>
<td>

<p>Input S-by-P feature matrix of unseen samples. Columns correspond to features, rows correspond to samples.
</p>
</td></tr>
<tr><td><code id="RGBM.test_+3A_y.test">Y.test</code></td>
<td>

<p>Input S-element response vector of unseen samples.
</p>
</td></tr>
<tr><td><code id="RGBM.test_+3A_m.test">M.test</code></td>
<td>

<p>Number of extensions of boosting model to take when predicting response. Must be not greater than <code>M.train</code> used when training boosting model.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of regression
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;raghvendra5688@gmail.com&gt;
</p>

<hr>
<h2 id='RGBM.train'>
Train RGBM predictor
</h2><span id='topic+RGBM.train'></span>

<h3>Description</h3>

<p>This function trains a regression model for a given <code>X.train</code> feature matrix, <code>Y.train</code> response vector, and working parameters. A model returned by this function can be used to predict response for unseen data with <code><a href="#topic+RGBM.test">RGBM.test</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGBM.train(X.train, Y.train, s_f = 0.3, s_s = 1, lf = 1, M.train = 5000, nu = 0.001)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGBM.train_+3A_x.train">X.train</code></td>
<td>

<p>Input S-by-P feature matrix of training samples. Columns correspond to features, rows correspond to samples.
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_y.train">Y.train</code></td>
<td>

<p>Input S-element response vector of training samples.
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of features, 0&lt;s_f&lt;=1. Fraction of columns from X.train, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_s_s">s_s</code></td>
<td>

<p>Sampling rate of samples, 0&lt;s_s&lt;=1. Fraction of rows from X.train, which will be sampled with replacement to calculate each extension in boosting model. By default it's 1.
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_lf">lf</code></td>
<td>

<p>Loss function: 1-&gt; Least Squares and 2 -&gt; Least Absolute Deviation
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_m.train">M.train</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="RGBM.train_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Regression model is a structure containing all the information needed to predict response for unseen data
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;raghvendra5688@gmail.com&gt;
</p>

<hr>
<h2 id='second_GBM_step'>
Re-iterate through the core GBM model building with optimal set of Tfs for each target gene 
</h2><span id='topic+second_GBM_step'></span>

<h3>Description</h3>

<p>This function re-performs the core GBM model building (only one time) using the optimal set of transcription factors obtained from <code><a href="#topic+select_ideal_k">select_ideal_k</a></code> followed by <code><a href="#topic+get_colids">get_colids</a></code> for individual target gene to return a regularized GRN. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>second_GBM_step(E, K, df_colids, tfs, targets, Ntfs, Ntargets, lf,  M,  nu, s_f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="second_GBM_step_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes. By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_df_colids">df_colids</code></td>
<td>

<p>A matrix made up of column vectors where each column vector represents the optimal set of active Tfs which regulate each target gene and obtained from <code><a href="#topic+get_colids">get_colids</a></code>. Some column vectors are just made up of zeros indicating that corresponding target genes are isolated and not regulated by any Tf
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_lf">lf</code></td>
<td>

<p>Loss Function: 1 -&gt; Least Squares and 2 -&gt; Least Absolute Deviation  
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_m">M</code></td>
<td>

<p>Number of extensions in boosting model, e.g. number of iterations of the main loop of RGBM algorithm. By default it's 5000.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_nu">nu</code></td>
<td>

<p>Shrinkage factor, learning rate, 0&lt;nu&lt;=1. Each extension to boosting model will be multiplied by the learning rate. By default it's 0.001.
</p>
</td></tr>
<tr><td><code id="second_GBM_step_+3A_s_f">s_f</code></td>
<td>

<p>Sampling rate of transcription factors, 0&lt;s_f&lt;=1. Fraction of transcription factors from E, as indicated by <code>tfs</code> vector, which will be sampled without replacement to calculate each extesion in boosting model. By default it's 0.3.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a regularized GRN of the form Ntfs-by-Ntargets
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+first_GBM_step">first_GBM_step</a></code>
</p>

<hr>
<h2 id='select_ideal_k'>
Identifies the optimal value of k i.e. top k Tfs for each target gene
</h2><span id='topic+select_ideal_k'></span>

<h3>Description</h3>

<p>This function detects the optimal number of transcription factors which are regulating each target gene. This number is different for different target genes. It utilizes a heuristic to also detect the isolated targets which are not regulated by any transcription factor. To the detect the optimal number of Tfs for each target gene, it uses a notion similar to that used for optimization of the L-curve criterion for Tikonov regularization by evaluating the variable importance curve for each target gene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_ideal_k(experimentid, mink, filepath, imagepath, adjacency_matrix_path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="select_ideal_k_+3A_experimentid">experimentid</code></td>
<td>

<p>The id of the experiment being conducted. It takes natural numbers like 1,2,3 etc. By default it's 1.
</p>
</td></tr>
<tr><td><code id="select_ideal_k_+3A_mink">mink</code></td>
<td>

<p>User specified threshold i.e. the minimum number of Tfs to be considered while optimizing the L-curve criterion. By default it's 0. 
</p>
</td></tr>
<tr><td><code id="select_ideal_k_+3A_filepath">filepath</code></td>
<td>

<p>Path where some intermediate files will be written and provided by the function <code><a href="#topic+get_filepaths">get_filepaths</a></code>.
</p>
</td></tr>
<tr><td><code id="select_ideal_k_+3A_imagepath">imagepath</code></td>
<td>

<p>Path where an image of the variable importance curves for first 16 target genes will be written and provided by the function <code><a href="#topic+get_filepaths">get_filepaths</a></code>.
</p>
</td></tr>
<tr><td><code id="select_ideal_k_+3A_adjacency_matrix_path">adjacency_matrix_path</code></td>
<td>

<p>Path where an intermediate adjacency matrix will be written and provided by the function <code><a href="#topic+get_filepaths">get_filepaths</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector where each element represents the optimal number of transcription factors for each target gene.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='test_regression_stump_R'>
Test the regression model
</h2><span id='topic+test_regression_stump_R'></span>

<h3>Description</h3>

<p>Test the regression model for each target gene
</p>


<h3>Format</h3>

<p>The format is:
List of 4
$ name         : chr &quot;test_regression_stump_R&quot;
$ address      :Class 'RegisteredNativeSymbol' &lt;externalptr&gt; 
$ dll          :List of 5
..$ name         : chr &quot;RGBM&quot;
..$ path         : chr &quot;/home/raghvendra/R/x86_64-pc-linux-gnu-library/3.3/RGBM/libs/RGBM.so&quot;
..$ dynamicLookup: logi TRUE
..$ handle       :Class 'DLLHandle' &lt;externalptr&gt; 
..$ info         :Class 'DLLInfoReference' &lt;externalptr&gt; 
..- attr(*, &quot;class&quot;)= chr &quot;DLLInfo&quot;
$ numParameters: int 15
- attr(*, &quot;class&quot;)= chr [1:2] &quot;CRoutine&quot; &quot;NativeSymbolInfo&quot;
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='train_regression_stump_R'>
Train the regression stump
</h2><span id='topic+train_regression_stump_R'></span>

<h3>Description</h3>

<p>Train the regression stump for each target gene
</p>


<h3>Format</h3>

<p>The format is:
List of 4
$ name         : chr &quot;train_regression_stump_R&quot;
$ address      :Class 'RegisteredNativeSymbol' &lt;externalptr&gt; 
$ dll          :List of 5
..$ name         : chr &quot;RGBM&quot;
..$ path         : chr &quot;/home/raghvendra/R/x86_64-pc-linux-gnu-library/3.3/RGBM/libs/RGBM.so&quot;
..$ dynamicLookup: logi TRUE
..$ handle       :Class 'DLLHandle' &lt;externalptr&gt; 
..$ info         :Class 'DLLInfoReference' &lt;externalptr&gt; 
..- attr(*, &quot;class&quot;)= chr &quot;DLLInfo&quot;
$ numParameters: int 15
- attr(*, &quot;class&quot;)= chr [1:2] &quot;CRoutine&quot; &quot;NativeSymbolInfo&quot;
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='transform_importance_to_weights'>
Log transforms the edge-weights in the inferred GRN
</h2><span id='topic+transform_importance_to_weights'></span>

<h3>Description</h3>

<p>This function performs an inverse absolute log-transformation of the non-zero edge weights in the final inferred GRN (A) to make the edge-weights more comprehensible and understandable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_importance_to_weights(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_importance_to_weights_+3A_a">A</code></td>
<td>

<p>Inferred GRN in the form of Ntfs-by-Ntargets matrix
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Refined adjacency matrix A in the form of Ntfs-by-Ntargets matrix
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='v2l'>
Convert adjacency matrix to a list of edges
</h2><span id='topic+v2l'></span>

<h3>Description</h3>

<p>This function converts adjacency matrix A to a sorted list of edges, e.g. a list in which edges are sorted by decreasing confidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>v2l(A, max = 1e+05, check.names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="v2l_+3A_a">A</code></td>
<td>

<p>Input adjacency matrix.
</p>
</td></tr>
<tr><td><code id="v2l_+3A_max">max</code></td>
<td>

<p>Maximal length of the resulting list. This number may be lower than the number of all the edges from adjacency matrix. Then only top <code>max</code> edges will be returned.
</p>
</td></tr>
<tr><td><code id="v2l_+3A_check.names">check.names</code></td>
<td>

<p>Checks name of the gene ids
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of sorted edges: (1) list of sources (2) list of destinations (3) list of confidences. Elements in all the lists correspond to each other.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>

<hr>
<h2 id='z_score_effect'>
Generates a matrix S2 of size Ntfs x Ntargets using the null-mutant zscore algorithm <cite>Prill, Robert J., et al</cite>
</h2><span id='topic+z_score_effect'></span>

<h3>Description</h3>

<p>This function generates a matrix of the form Ntfs-by-Ntargets using the steps proposed in null-mutant zscore method and acts as a refinement step for the inferred GRN where this matrix is multiplied element by element with the inferred adjacency matrix A. However, this step is only effective in presence of additional source of information like knockout, knockdown or which genes are intially perturbed in time-series expression data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_score_effect(E, K, tfs, targets, Ntfs, Ntargets)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z_score_effect_+3A_e">E</code></td>
<td>

<p>N-by-p expression matrix. Columns correspond to genes, rows correspond to experiments. E is expected to be already normalized using standard methods, for example RMA. Colnames of E is the set of all genes. 
</p>
</td></tr>
<tr><td><code id="z_score_effect_+3A_k">K</code></td>
<td>

<p>N-by-p initial perturbation matrix. It directly corresponds to E matrix, e.g. if K[i,j] is equal to 1, it means that gene j was knocked-out in experiment i. Single gene knock-out experiments are rows of K with only one value 1. Colnames of K is set to be the set of all genes. By default it's a matrix of zeros of the same size as E, e.g. unknown initial perturbation state of genes.
</p>
</td></tr>
<tr><td><code id="z_score_effect_+3A_tfs">tfs</code></td>
<td>

<p>List of names of transcription factors
</p>
</td></tr>
<tr><td><code id="z_score_effect_+3A_targets">targets</code></td>
<td>

<p>List of names of target genes
</p>
</td></tr>
<tr><td><code id="z_score_effect_+3A_ntfs">Ntfs</code></td>
<td>

<p>Total number of transcription factors used in the experiment.
</p>
</td></tr>
<tr><td><code id="z_score_effect_+3A_ntargets">Ntargets</code></td>
<td>

<p>Total number of target genes used in the experiment.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an S2 matrix of form Ntfs-by-Ntargets. In absence of any additional knockout/knockdown/perturbation information the S2 matrix is a matrix of ones.
</p>


<h3>Author(s)</h3>

<p>Raghvendra Mall &lt;rmall@hbku.edu.qa&gt;
</p>


<h3>References</h3>

<p>Prill, Robert J., et al. &quot;Towards a rigorous assessment of systems biology models: the DREAM3 challenges.&quot; PloS one 5.2 (2010): e9202.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+null_model_refinement_step">null_model_refinement_step</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
