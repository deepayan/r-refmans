<!DOCTYPE html><html><head><title>Help for package cassandRa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cassandRa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EcoLinkPredict'><p>Predicting Missing Links</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#CalcHostLevelCoverage'><p>Estimated probabilities of missing links based on the host Level Coverage Deficit</p></a></li>
<li><a href='#ComputeCI'><p>Compute Basic Confidence Intervals</p></a></li>
<li><a href='#CoverageEstimator'><p>Coverage Estimator, using Chao1 Index, Turing-Good or Binomial depending on what is possible</p></a></li>
<li><a href='#CreateListObject'><p>Generates a network list from a food web</p></a></li>
<li><a href='#FitAllModels'><p>Fit all the models</p></a></li>
<li><a href='#FitBothMandC'><p>Fit Matching-Centrality Model</p></a></li>
<li><a href='#FitCentrality'><p>Fit Centrality Model</p></a></li>
<li><a href='#FitMatching'><p>Fit Latent Trait (Matching Model)</p></a></li>
<li><a href='#FitSBM'><p>Fit SBM Model</p></a></li>
<li><a href='#make_true_and_sample_web'><p>Make an artificial bipartite networks with some properties of ecological networks, then sample from it</p></a></li>
<li><a href='#Optimise_SBM'><p>Custom optimiser function for SBM models</p></a></li>
<li><a href='#Optimiser'><p>Optimiser wrapper for network models</p></a></li>
<li><a href='#PlotFit'><p>Plot the fitted network models</p></a></li>
<li><a href='#PlotRarefaction'><p>Plot Metric Response To Network Rarefaction</p></a></li>
<li><a href='#PredictLinks'><p>Generates a network list from a food web and fits all network models</p></a></li>
<li><a href='#RarefyNetwork'><p>Recalculate Network Metrics With Rarefied Webs</p></a></li>
<li><a href='#SortResponseCategory'><p>Adds a dataframe that defines each interaction as true positive, false negative or true negative</p></a></li>
<li><a href='#TestAllModels'><p>Test the models by AUC</p></a></li>
<li><a href='#TestAUC'><p>Test via AUC the predictive capacity of each model or combination of models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Finds Missing Links and Metric Confidence Intervals in
Ecological Bipartite Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods to deal with under sampling in ecological bipartite networks. Includes 
     tools to fit a variety of statistical network models and sample coverage estimators to highlight most likely 
     missing links. Also includes simple functions to resample from observed networks to generate confidence 
     intervals for common ecological network metrics. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>bipartite (&ge; 2.11), reshape2 (&ge; 1.4.3), magrittr (&ge; 1.5),
vegan (&ge; 2.5-3), purrr (&ge; 0.2.5), dplyr, tidyr(&ge; 0.8),
ggplot2 (&ge; 3.1.0), boot</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr (&ge; 1.20), rmarkdown (&ge; 1.10), pROC (&ge; 1.13.0),
lattice</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-07-02 15:42:24 UTC; pemb4504</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Terry [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Terry &lt;christerry3@btinternet.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-07-03 15:10:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='EcoLinkPredict'>Predicting Missing Links</h2><span id='topic+EcoLinkPredict'></span><span id='topic+EcoLinkPredict-package'></span>

<h3>Description</h3>

<p>Package to make assessments of the most likely location of missing links and to test the effect of
sample rarefaction or extrapolation on the confidence of bipartite network metrics.
</p>


<h3>Details</h3>

<p>The models to predict missing links are discussed in XXX.
</p>
<p>See vignette for discussion and examples.
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>Pipe operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='CalcHostLevelCoverage'>Estimated probabilities of missing links based on the host Level Coverage Deficit</h2><span id='topic+CalcHostLevelCoverage'></span>

<h3>Description</h3>

<p>Calls CoverageEstimator() to calculate host-level coverage deficit, then divides this by the number
of unobserved interactions of that host.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CalcHostLevelCoverage(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CalcHostLevelCoverage_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network list, with 'C_defmatrix', a matrix of probabilities based on coverage deficit, and
'OverallChaoEst' an estimate of the overall coverage deficit of the network.
</p>

<hr>
<h2 id='ComputeCI'>Compute Basic Confidence Intervals</h2><span id='topic+ComputeCI'></span>

<h3>Description</h3>

<p>Compute Basic Confidence Intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeCI(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeCI_+3A_df">df</code></td>
<td>
<p>A data frame produced by <code>RarefyNetwork()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe detailing confidence intervals at each tested sample size
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(Safariland, package = 'bipartite')
 X&lt;-RarefyNetwork(Safariland, n_per_level = 100)
 PlotRarefaction(X)
</code></pre>

<hr>
<h2 id='CoverageEstimator'>Coverage Estimator, using Chao1 Index, Turing-Good or Binomial depending on what is possible</h2><span id='topic+CoverageEstimator'></span>

<h3>Description</h3>

<p>An estimate of the sample coverage, which tries to use the most appropriate method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CoverageEstimator(x, cutoff = 5, BayesPrior = "Flat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CoverageEstimator_+3A_x">x</code></td>
<td>
<p>A vector of integers, the observed sample counts</p>
</td></tr>
<tr><td><code id="CoverageEstimator_+3A_cutoff">cutoff</code></td>
<td>
<p>When to switch from binomial model to Chao1 estimator</p>
</td></tr>
<tr><td><code id="CoverageEstimator_+3A_bayesprior">BayesPrior</code></td>
<td>
<p>Prior to use. Either 'Flat' or 'Jeffereys'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sample coverage is defined as the probability that the next interaction drawn is of a type not yet seen
</p>
<p>If the sample size is at or below a cutoff (5) or if all the samples are singletons,
this is calculated as the posterior mean of a binomial model using a flat prior (this can be changed
to a Jeffereys).
</p>
<p>If there are singletons but no doubletons, the Turing-Good estimate is used:   c_hat = 1 - (f1/n)
</p>
<p>If there are both singletons and doubletons, the Chao1 index is used:
</p>
<p>c_hat = 1 -( (f1/n) * ( (f1*(n-1))/((n-1)*(f1+(2*f2)))   )  )
</p>


<h3>Value</h3>

<p>c_hat, the estimated coverage. (i.e. 1-  C_def)
</p>

<hr>
<h2 id='CreateListObject'>Generates a network list from a food web</h2><span id='topic+CreateListObject'></span>

<h3>Description</h3>

<p>Gets a network in the base bipartite package format into a list format. N.B. Throughout this package
uses hosts to refer to the focal layer, and 'wasps' the response layer, although this could equally
be 'plants' and 'pollinators'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateListObject(web)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CreateListObject_+3A_web">web</code></td>
<td>
<p>in format specified by the bipartite package. Rows = focal layer, columns = response layer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network list for use with other functions in EcoLinkPredict package
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Safariland, package = 'bipartite')
demolist&lt;-CreateListObject(Safariland)
str(demolist)
</code></pre>

<hr>
<h2 id='FitAllModels'>Fit all the models</h2><span id='topic+FitAllModels'></span>

<h3>Description</h3>

<p>Internal function called by <code>PredictLinks()</code>
Fits the coverage deficit, Trait, Centrality, Matching-Centrality and SBM models by sequentially
calling the individual functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitAllModels(list, RepeatModels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitAllModels_+3A_list">list</code></td>
<td>
<p>A network list</p>
</td></tr>
<tr><td><code id="FitAllModels_+3A_repeatmodels">RepeatModels</code></td>
<td>
<p>How many times to fit each model from different starting points. Uses best half (rounding up)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A network list including the model fit
</p>

<hr>
<h2 id='FitBothMandC'>Fit Matching-Centrality Model</h2><span id='topic+FitBothMandC'></span>

<h3>Description</h3>

<p>Fit a model that contains both a trait-matching and a centrality term based on Rohr et al. (2016)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitBothMandC(list, N_runs = 10, maxit = 10000,
  method = "Nelder-Mead", ExtraSettings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitBothMandC_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
<tr><td><code id="FitBothMandC_+3A_n_runs">N_runs</code></td>
<td>
<p>Number of different start points for k2 and lambda to try. The best (maximum likelihood)
half will be used to construct the probability matrix</p>
</td></tr>
<tr><td><code id="FitBothMandC_+3A_maxit">maxit</code></td>
<td>
<p>Default = 10'000</p>
</td></tr>
<tr><td><code id="FitBothMandC_+3A_method">method</code></td>
<td>
<p>Passed to optim, default = 'Nelder-Mead'</p>
</td></tr>
<tr><td><code id="FitBothMandC_+3A_extrasettings">ExtraSettings</code></td>
<td>
<p>Other control settings to pass to optim()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Network list with added 'B_par',the best fitting parameters, 'M_ProbsMatrix', the probability matrix
</p>


<h3>References</h3>

<p>Rohr, R.P., Naisbit, R.E., Mazza, C. &amp; Bersier, L.-F. (2016). Matching-centrality
decomposition and the forecasting of new links in networks. Proc. R. Soc. B Biol. Sci., 283, 20152702
</p>

<hr>
<h2 id='FitCentrality'>Fit Centrality Model</h2><span id='topic+FitCentrality'></span>

<h3>Description</h3>

<p>Repeatedly fits a centrality model to a binary interaction network to return a probability matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitCentrality(list, N_runs = 10, maxit = 10000,
  method = "Nelder-Mead", ExtraSettings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitCentrality_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
<tr><td><code id="FitCentrality_+3A_n_runs">N_runs</code></td>
<td>
<p>Number of start points to try. The best (maximum likelihood) half will be used to construct the probability matrix</p>
</td></tr>
<tr><td><code id="FitCentrality_+3A_maxit">maxit</code></td>
<td>
<p>Default = 10'000</p>
</td></tr>
<tr><td><code id="FitCentrality_+3A_method">method</code></td>
<td>
<p>Passed to optim, default = 'Nelder-Mead'</p>
</td></tr>
<tr><td><code id="FitCentrality_+3A_extrasettings">ExtraSettings</code></td>
<td>
<p>Other control settings to pass to optim()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Network list with added 'C_par', best fitting parameters, C_ProbsMatrix, the probability matrix
</p>

<hr>
<h2 id='FitMatching'>Fit Latent Trait (Matching Model)</h2><span id='topic+FitMatching'></span>

<h3>Description</h3>

<p>Repeatedly fits a latent trait model to a binary interaction network to return a probability matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitMatching(list, N_runs = 10, maxit = 10000, method = "Nelder-Mead",
  ExtraSettings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitMatching_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
<tr><td><code id="FitMatching_+3A_n_runs">N_runs</code></td>
<td>
<p>Number of start points for k2 and lambda to try. The best (maximum likelihood) half will
be used to construct the probability matrix</p>
</td></tr>
<tr><td><code id="FitMatching_+3A_maxit">maxit</code></td>
<td>
<p>Default = 10'000</p>
</td></tr>
<tr><td><code id="FitMatching_+3A_method">method</code></td>
<td>
<p>Passed to optim, default = 'Nelder-Mead'</p>
</td></tr>
<tr><td><code id="FitMatching_+3A_extrasettings">ExtraSettings</code></td>
<td>
<p>Other control settings to pass to optim()</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The optimiser is started at values derived from the row-sums and column-sums of a CCA analysis,
which correspond closely to latent traits by matching closely related species together.
</p>
<p>The k2 and lambda parameters are started from points drawn from a uniform distribution 0:1.
</p>


<h3>Value</h3>

<p>Network list with added 'M_par',the best fitting parameters, 'M_ProbsMatrix', the probability matrix
</p>

<hr>
<h2 id='FitSBM'>Fit SBM Model</h2><span id='topic+FitSBM'></span>

<h3>Description</h3>

<p>Fit SBM Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FitSBM(list, n_SBM = 10, G = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FitSBM_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
<tr><td><code id="FitSBM_+3A_n_sbm">n_SBM</code></td>
<td>
<p>Number of SBM models to fit. Default is 10. The top half (rounding up) are retained
and averaged to produce a probability matrix.</p>
</td></tr>
<tr><td><code id="FitSBM_+3A_g">G</code></td>
<td>
<p>The number of groups to divide the top layer and the focal layer into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Network list with 'SBM_ProbsMat', a matrix of probabilities assigned to each possible interaction,
'SBM1', the best model fit derived from Optimise_SBM(), and 'SBM_G', the number of fitted groups.
</p>

<hr>
<h2 id='make_true_and_sample_web'>Make an artificial bipartite networks with some properties of ecological networks, then sample from it</h2><span id='topic+make_true_and_sample_web'></span>

<h3>Description</h3>

<p>Core model adapted from: &quot;Sampling bias is a challenge [...]: lessons from a quantitative nichemodel&quot; by
Jochen Frund, Kevin S. McCann and Neal M. Williams
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_true_and_sample_web(seed = NULL, specpar = 1, n_hosts = 10,
  n_wasps = 10, TargetTrueConn = 0.5, SampleObs = 1000,
  abun_mean = 5, abun_sdlog = 1, traitvsnested = 0.5,
  hosttrait_n = "two")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_true_and_sample_web_+3A_seed">seed</code></td>
<td>
<p>Random number generator seed, if specified.</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_specpar">specpar</code></td>
<td>
<p>Specialisation parameter, equal to 1/sd of the normal curve that defines the consumption range</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_n_hosts">n_hosts</code></td>
<td>
<p>Number of focal level species (e.g. hosts, flowers)</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_n_wasps">n_wasps</code></td>
<td>
<p>Number of non-focal level species (e.g. parasitic wasps, pollinators)</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_targettrueconn">TargetTrueConn</code></td>
<td>
<p>Proportion of possible interactions to keep</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_sampleobs">SampleObs</code></td>
<td>
<p>Number of samples to draw</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_abun_mean">abun_mean</code></td>
<td>
<p>Mean abundance level (log scale).</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_abun_sdlog">abun_sdlog</code></td>
<td>
<p>Distributon of abundance level (SD log scale).</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_traitvsnested">traitvsnested</code></td>
<td>
<p>The relative balance between the nestedness generator and the trait-based generator</p>
</td></tr>
<tr><td><code id="make_true_and_sample_web_+3A_hosttrait_n">hosttrait_n</code></td>
<td>
<p>Number of trait dimensions. Default 'two', uses two traits, with one dominant. 'single' and 'multi' retained from Frund et al.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Abundances are assigned by generating abundances that match a log-normal distribution (but without
introducing noise)
</p>


<h3>Value</h3>

<p>A network list containing 'obs' a matrix of observations, 'TrueWeb' a matrix of the 'true']
drawn web, and number of other properties of these networks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_true_and_sample_web()
</code></pre>

<hr>
<h2 id='Optimise_SBM'>Custom optimiser function for SBM models</h2><span id='topic+Optimise_SBM'></span>

<h3>Description</h3>

<p>Designed to be called by FitSBM()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Optimise_SBM(i = NULL, A, G, N_Rounds_max = 500, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Optimise_SBM_+3A_i">i</code></td>
<td>
<p>Seed</p>
</td></tr>
<tr><td><code id="Optimise_SBM_+3A_a">A</code></td>
<td>
<p>Binary Interaction Matrix</p>
</td></tr>
<tr><td><code id="Optimise_SBM_+3A_g">G</code></td>
<td>
<p>Number of Groups</p>
</td></tr>
<tr><td><code id="Optimise_SBM_+3A_n_rounds_max">N_Rounds_max</code></td>
<td>
<p>Maximum number round to keep drawing</p>
</td></tr>
<tr><td><code id="Optimise_SBM_+3A_plot">plot</code></td>
<td>
<p>If set to TRUE, plots the progress of likelihood improvement, used to check if convergence is good.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on optimising algorithm described in Larremore, D.B., Clauset, A. &amp; Jacobs, A.Z. (2014).
Efficiently inferring community structure in bipartite networks. Phys. Rev. E - Stat. Nonlinear,
Soft Matter Phys., 90, 1-12
</p>
<p>Initially all species are randomly assigned to groups. Then, one at a time, each species is swapped
into a different group and the likelihood of the model assessed (with SBMLik()).
</p>
<p>The best model of all these swaps is then selected (even if it is worse) and used in the next round of swapping.
</p>
<p>This fits the 'degree-corrected' biSBM mdoel of Larremore et al., which is generally better when there are broad degree distributions
</p>
<p>This is repeated until either n_rounds_max is reached, or the (most commonly), if the best model
in the last 20 is within 0.1 log-likelihood of the best overall (implying it has stopped improving).
</p>


<h3>Value</h3>

<p>A list containing 'LogLik' (the maximum likelihood found) 'SB_H', the group assignments of the host,
'SB_W', the group assignments of the other level, and 'Omega_rs', the interaction probabilities between groups.
</p>

<hr>
<h2 id='Optimiser'>Optimiser wrapper for network models</h2><span id='topic+Optimiser'></span>

<h3>Description</h3>

<p>Optimiser wrapper for network models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Optimiser(i = NULL, maxit = 10000, method = "Nelder-Mead", A, N_p,
  fixedSt_P = c(), N_unif_P = 0, func, ExtraSettings = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Optimiser_+3A_i">i</code></td>
<td>
<p>RNG Seed to set</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations to be passed to optim (default is 10000)</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_method">method</code></td>
<td>
<p>Optimiser method to pass to optim. Default is</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_a">A</code></td>
<td>
<p>Interaction Presence-Absence matrix</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_n_p">N_p</code></td>
<td>
<p>Number of parameters to draw from a normal distribution</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_fixedst_p">fixedSt_P</code></td>
<td>
<p>Vector of fixed parameters to pass</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_n_unif_p">N_unif_P</code></td>
<td>
<p>Number of parameters to take from a uniform distribution</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_func">func</code></td>
<td>
<p>Function to optimiser</p>
</td></tr>
<tr><td><code id="Optimiser_+3A_extrasettings">ExtraSettings</code></td>
<td>
<p>Additional setting to pass to control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'fit' object form optim, with a few of the input parameters attached.
</p>

<hr>
<h2 id='PlotFit'>Plot the fitted network models</h2><span id='topic+PlotFit'></span>

<h3>Description</h3>

<p>Takes the output from other functions (including <code>PredictLinks()</code>) to visualise the fit to the
data and predictions of missing links.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotFit(list, Matrix_to_plot, OrderBy = "Default", addDots = TRUE,
  title = NULL, Combine = "+", RemoveTP = FALSE, GuidesOff = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotFit_+3A_list">list</code></td>
<td>
<p>A list-format network (output from xxx)</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_matrix_to_plot">Matrix_to_plot</code></td>
<td>
<p>Which matrix / matrices to plot. One or more of 'C_def','C', 'M', 'B', 'SBM'</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_orderby">OrderBy</code></td>
<td>
<p>How to order the plot. One of 'Default','Degree','Manual', 'LatentTrait','SBM', 'AsPerMatrix'</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_adddots">addDots</code></td>
<td>
<p>Should dots be added to show observations. TRUE, FALSE or 'Size', to plot by interaction strength</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_title">title</code></td>
<td>
<p>A title. By default it will use the value of Matrix_to_plot</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_combine">Combine</code></td>
<td>
<p>How should multiple matrices be combined. Either '+' which averages them (default), or '*' which multiples</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_removetp">RemoveTP</code></td>
<td>
<p>Should true positives be set to NA in order to highlight differences in predictions. Default is FALSE</p>
</td></tr>
<tr><td><code id="PlotFit_+3A_guidesoff">GuidesOff</code></td>
<td>
<p>Should the legends be switched off. Defaults to TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the vignette for a more through description and examples.
</p>


<h3>Value</h3>

<p>A ggplot object, which by default will print to the device, but can be added to make further tweaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
data(Safariland, package = 'bipartite')
Predictions&lt;- PredictLinks(Safariland)
PlotFit(Predictions, Matrix_to_plot = 'SBM')

## End(Not run)




</code></pre>

<hr>
<h2 id='PlotRarefaction'>Plot Metric Response To Network Rarefaction</h2><span id='topic+PlotRarefaction'></span>

<h3>Description</h3>

<p>Used to plot the output from <code>RarefyNetwork()</code>. See vignette!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotRarefaction(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PlotRarefaction_+3A_df">df</code></td>
<td>
<p>A data frame produced by RarefyNetwork</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(Safariland, package = 'bipartite')
 X&lt;-RarefyNetwork(Safariland, n_per_level = 100)
 ComputeCI(X)

</code></pre>

<hr>
<h2 id='PredictLinks'>Generates a network list from a food web and fits all network models</h2><span id='topic+PredictLinks'></span>

<h3>Description</h3>

<p>First calls <code>CreateListObject</code> to convert a matrix suitable for the bipartite package into a list structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PredictLinks(web, RepeatModels = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PredictLinks_+3A_web">web</code></td>
<td>
<p>in format specified by the bipartite package. Rows = focal layer, columns = response layer</p>
</td></tr>
<tr><td><code id="PredictLinks_+3A_repeatmodels">RepeatModels</code></td>
<td>
<p>How many times to fit each model from different starting points. Uses best half (rounding up)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Then it calls <code>FitAllModels</code> to fit each of the missing link models in turn.
</p>


<h3>Value</h3>

<p>A network list including a large number of outputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(Safariland, package = 'bipartite')
PredictLinks(Safariland)

## End(Not run)






</code></pre>

<hr>
<h2 id='RarefyNetwork'>Recalculate Network Metrics With Rarefied Webs</h2><span id='topic+RarefyNetwork'></span>

<h3>Description</h3>

<p>Resamples empirical network observations at a range of sampling levels and calls networklevel()
function from bipartite package to calculate network metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RarefyNetwork(web, n_per_level = 1000, frac_sample_levels = seq(0.2, 1,
  l = 5), abs_sample_levels = NULL, metrics = "info",
  PARALLEL = FALSE, cores = 2, output = "df", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RarefyNetwork_+3A_web">web</code></td>
<td>
<p>A matrix format web, as for <code>bipartite</code></p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_n_per_level">n_per_level</code></td>
<td>
<p>How many samples to take per sample level. Default is 1000.</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_frac_sample_levels">frac_sample_levels</code></td>
<td>
<p>Sequence of fractions of original sample size to resample at.</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_abs_sample_levels">abs_sample_levels</code></td>
<td>
<p>If supplied, vector of absolute sample sizes to use to override  <code>frac_sample_levels</code>. Default = NULL</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_metrics">metrics</code></td>
<td>
<p>vector of metrics to calculate. Will be passed to  <code>index</code> of  <code>networklevel()</code>. Default = 'info'</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_parallel">PARALLEL</code></td>
<td>
<p>Logical. If TRUE, will use parallel package to speed up metric calculation. Default = FALSE</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_cores">cores</code></td>
<td>
<p>If using parallel, how man cores to use. Default = 2</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_output">output</code></td>
<td>
<p>String specifying output. If 'plot' will return a ggplot facetted by metric using  <code>PlotRarefaction()</code>. If
'CI' will return a data frame (using  <code>ComputeCI()</code> containing 5 columns: Metric, LowerCI, UpperCI, Mean, SampleSize. Otherwise will return a
data frame of the raw recalculated metrics, with a separate column for each metric, and the last column specifying the resample size.</p>
</td></tr>
<tr><td><code id="RarefyNetwork_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>networklevel</code>. e.g. empty.web=FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can return either a data frame of raw metrics, a ggplot or a data frame of 'confidence intervals'.
</p>
<p>These CI are calculated from the set of resamples by ordering the network values and taking the
value of the metric ranked at the 5th and 95th percentile. (this method is very similar to that
employed by Casas <em>et al.</em> 2018 <em>Assessing sampling sufficiency of network metrics using bootstrap</em>
Ecological Complexity 36:268-275.)
</p>
<p>Note that confidence intervals for many metrics, particularly qualitative ones, will be biased by
the issue of false-negatives. Resampling of observations will not introduce missing links.
</p>
<p>By default the size of resamples are taken to be proportional to the original sample size. Original sample size is
defined as the sum of the supplied web. If a specific set of sample sizes is wanted, use <code>abs_sample_levels</code>
</p>
<p>It is possible to extrapolate how increases sample size may lead to increased confidence in a metric too.
Set the sequence to <code>frac_sample_levels</code> to go beyond 1.
</p>


<h3>Value</h3>

<p>Either a dataframe or a ggplot object. See details.
</p>


<h3>See Also</h3>

<p><code><a href="bipartite.html#topic+networklevel">networklevel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Safariland, package = 'bipartite')
RarefyNetwork(Safariland, n_per_level = 100)
</code></pre>

<hr>
<h2 id='SortResponseCategory'>Adds a dataframe that defines each interaction as true positive, false negative or true negative</h2><span id='topic+SortResponseCategory'></span>

<h3>Description</h3>

<p>Adds a dataframe that defines each interaction as true positive, false negative or true negative
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SortResponseCategory(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SortResponseCategory_+3A_list">list</code></td>
<td>
<p>Network list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Network list object with ObsSuccess, a dataframe detailing all the interactions and whether they are True Positives, False Negative or True Negatives
</p>

<hr>
<h2 id='TestAllModels'>Test the models by AUC</h2><span id='topic+TestAllModels'></span>

<h3>Description</h3>

<p>The function assumes FitAllModels() has already been run. It is a wrapper for 'SortResponseCategory()' and 'TestAUC()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestAllModels(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestAllModels_+3A_list">list</code></td>
<td>
<p>A network list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the network list with added AUC data. Key values are 'AUC', a dataframe with the AUC of
each model and many combinations.
</p>

<hr>
<h2 id='TestAUC'>Test via AUC the predictive capacity of each model or combination of models</h2><span id='topic+TestAUC'></span>

<h3>Description</h3>

<p>Test via AUC the predictive capacity of each model or combination of models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestAUC(list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestAUC_+3A_list">list</code></td>
<td>
<p>Network List</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 'DataforAUC', a data frame with each interaction as a row and the predictions
of each model, and 'AUC', a data frame with the predictive capacity of all the models and many combinations
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
