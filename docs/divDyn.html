<!DOCTYPE html><html><head><title>Help for package divDyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {divDyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#affinity'><p>Environmental affinities of taxa</p></a></li>
<li><a href='#binstat'><p>Sampling statistics and diversity indices in every bin</p></a></li>
<li><a href='#categorize'><p>Mapping multiple entries to categories</p></a></li>
<li><a href='#cleansp'><p>Cleanse Species Name Vector</p></a></li>
<li><a href='#corals'><p>Fossil occurrences of scleractinian (stony) corals from the Paleobiology Database</p></a></li>
<li><a href='#divDyn'><p>Time series from metrics of diversity dynamics</p></a></li>
<li><a href='#fadlad'><p>FAD - LAD matrix from occurrence data</p></a></li>
<li><a href='#fill'><p>Filling of missing values in a vector, based on the marginal values of the gaps</p></a></li>
<li><a href='#georange'><p>Estimation of geographic ranges from occurrence data</p></a></li>
<li><a href='#indices'><p>Scalar indices of diversity</p></a></li>
<li><a href='#keys'><p>Keys to process stratigraphic, environmental and lithological information from the Paleobiology Database</p></a></li>
<li><a href='#matchtime'><p>Match the dates of a time-dependent variable with a predefined vector</p></a></li>
<li><a href='#modeltab'><p>Origination/extinction response table for statistical modelling.</p></a></li>
<li><a href='#omit'><p>Omission of taxa that have a poor occurrence record</p></a></li>
<li><a href='#parts'><p>Plot time series counts or proportions as polygons</p></a></li>
<li><a href='#ranges'><p>Plotting ranges and occurrence distributions through time</p></a></li>
<li><a href='#ratesplit'><p>Test of rate split (selectivity)</p></a></li>
<li><a href='#repmatch'><p>Replicate matching and merging</p></a></li>
<li><a href='#seqduplicated'><p>Determination and omission of consecutive duplicates in a vector.</p></a></li>
<li><a href='#shades'><p>Quantile plot of time series</p></a></li>
<li><a href='#singletons'><p>List of singleton taxa</p></a></li>
<li><a href='#slice'><p>Discretization of continuous time dimension - slicing</p></a></li>
<li><a href='#stages'><p>95 bin Phanerozoic time scale based on the stratigraphic stages of Gradstein et al. 2020.</p></a></li>
<li><a href='#stages2018'><p>95 bin Phanerozoic time scale based on the stratigraphic stages of Ogg et al. (2016) with updated dates in some intervals (2018).</p></a></li>
<li><a href='#stratkeys'><p>The FossilWorks-based lookup table for the stratigraphic assignments of collections in the Paleobiology Database</p></a></li>
<li><a href='#streaklog'><p>Utility functions for slicing gappy time series</p></a></li>
<li><a href='#subsample'><p>Subsampling wrapper function</p></a></li>
<li><a href='#subtrialCR'><p>Subsampling trial functions</p></a></li>
<li><a href='#sumstat'><p>Occurrence database summary</p></a></li>
<li><a href='#survivors'><p>Proportions of survivorship</p></a></li>
<li><a href='#tabinate'><p>Apply function to TAxon/BIN subset of occurrences and iterATE</p></a></li>
<li><a href='#tens'><p>The 10 million year resolution timescale of the Paleobiology Database</p></a></li>
<li><a href='#tsbars'><p>Function to plot a series a values with bars that have variable widths</p></a></li>
<li><a href='#tsplot'><p>Time series plotting using a custom time scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Diversity Dynamics using Fossil Sampling Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Author:</td>
<td>Adam T. Kocsis, John Alroy, Carl J. Reddin, Wolfgang Kiessling</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Adam T. Kocsis &lt;adam.t.kocsis@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to describe sampling and diversity dynamics of fossil occurrence datasets (e.g. from the Paleobiology Database). The package includes methods to calculate range- and occurrence-based metrics of taxonomic richness, extinction and origination rates, along with traditional sampling measures. A powerful subsampling tool is also included that implements frequently used sampling standardization methods in a multiple bin-framework. The plotting of time series and the occurrence data can be simplified by the functions incorporated in the package, as well as other calculations, such as environmental affinities and extinction selectivity testing. Details can be found in: Kocsis, A.T.; Reddin, C.J.; Alroy, J. and Kiessling, W. (2019) &lt;<a href="https://doi.org/10.1101%2F423780">doi:10.1101/423780</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-05</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/divDyn/divDyn/issues">https://github.com/divDyn/divDyn/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>false</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stats, graphics, grDevices, methods</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, vegan, icosa</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-05 14:22:34 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-05 14:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='affinity'>Environmental affinities of taxa</h2><span id='topic+affinity'></span>

<h3>Description</h3>

<p>This function will return the preferred environment of the taxa, given the distribution of occurrences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>affinity(
  x,
  tax,
  bin,
  env,
  coll = NULL,
  method = "binom",
  alpha = 1,
  reldat = NULL,
  na.rm = FALSE,
  bycoll = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="affinity_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> The occurrence dataset containing the taxa with unknown environmental affinities.</p>
</td></tr>
<tr><td><code id="affinity_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> The column name of taxon names.</p>
</td></tr>
<tr><td><code id="affinity_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> The column name of bin names.</p>
</td></tr>
<tr><td><code id="affinity_+3A_env">env</code></td>
<td>
<p><code>(character)</code> The environmental variable of the occurrences.</p>
</td></tr>
<tr><td><code id="affinity_+3A_coll">coll</code></td>
<td>
<p><code>(character)</code> The column name of collection identifiers (optional). If this is provided, then then the multiple entries of a taxon within the collections will be treated as 1.</p>
</td></tr>
<tr><td><code id="affinity_+3A_method">method</code></td>
<td>
<p><code>(character)</code> The method used for affinity calculations. Can be either <code>"binom"</code> or <code>"majority"</code>.</p>
</td></tr>
<tr><td><code id="affinity_+3A_alpha">alpha</code></td>
<td>
<p><code>(numeric)</code> The alpha value of the binomial tests. By default binomial testing is off (<code>alpha=1</code>) and the methods returns that environment as the preferred one, which has the highest likelihood (odds ratio).</p>
</td></tr>
<tr><td><code id="affinity_+3A_reldat">reldat</code></td>
<td>
<p><code>(data.frame)</code> Database with the same structure as <code>x</code>.  <code>x</code> is typically a subset of <code>reldat</code>. If given, the occurrence distribution of <code>reldat</code> is used 
as the null model of sampling. Defaults to <code>NULL</code>, which means that <code>x</code> itself will be used as <code>reldat</code>.</p>
</td></tr>
<tr><td><code id="affinity_+3A_na.rm">na.rm</code></td>
<td>
<p><code>(logical)</code> Should the <code>NA</code> entries in the relevant columns of <code>x</code> be omitted automatically?</p>
</td></tr>
<tr><td><code id="affinity_+3A_bycoll">bycoll</code></td>
<td>
<p><code>(logical)</code> If set to <code>TRUE</code>, the number of collections (or samples, in <code>coll</code>) will be used rather than the number of occurrences.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sampling patterns have an overprinting effect on the frequency of taxon occurrences in different environments. The environmental affinity (Foote, 2006; Kiessling and Aberhan, 2007; Kiessling and Kocsis, 2015) expresses whether the taxa are more likely to occur in an environment, given the sampling patterns of the dataset at hand. The function returns the likely preferred environment for each taxon as a vector. <code>NA</code> outputs indicate that the environmental affinity is equivocal based on the selected method.
</p>
<p><strong>The following methods are implemented:</strong>
</p>
<p><code>'majority'</code>: Environmental affinity will be assigned based on the number of occurrences of the taxon in the different environments, without taking sampling of the entire dataset into account. If the taxon has more occurrences in <em>environment 1</em>, the function will return <em>environment 1</em> as the preferred habitat. 
</p>
<p><code>'binom'</code>: The proportion of occurrences of a taxon in <em>environment 1</em> and <em>environment 2</em> will be compared to a null model, which is based on the distribution of all occurrences from the stratigraphic range of the taxon (in <code>x</code> or if provided, in <code>reldat</code>). Then a binomial test is run on with the numbers of the most likely preference (against all else). The <code>alpha</code> value indicates the significance of the binomial tests, setting <code>alpha</code> to <code>1</code> will effectively switch the testing off: if the ratio of occurrences for the taxon is different from the ratio observed in the dataset, an affinity will be assigned. This is the default method. If an environment is not sampled at all in the dataset to which the taxon's occurrences are compared to, the binomial method returns <code>NA</code> for the taxon's affinity. 
</p>
<p><strong>References</strong>
</p>
<p>Foote, M. (2006). Substrate affinity and diversity dynamics of Paleozoic marine animals. Paleobiology, 32(3), 345-366.
</p>
<p>Kiessling, W., &amp; Aberhan, M. (2007). Environmental determinants of marine benthic biodiversity dynamics through Triassic–Jurassic time. Paleobiology, 33(3), 414-434.
</p>
<p>Kiessling, W., &amp; Kocsis, Á. T. (2015). Biodiversity dynamics and environmental occupancy of fossil azooxanthellate and zooxanthellate scleractinian corals. Paleobiology, 41(3), 402-414.
</p>


<h3>Value</h3>

<p>A named vector, values corresponding to affinities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)
# omit values where no occurrence environment entry is present, or where unknown
  fossils&lt;-subset(corals, stg!=95)
  fossilEnv&lt;-subset(fossils, bath!="uk")
# calculate affinities
  aff&lt;-affinity(fossilEnv, env="bath", tax="genus", bin="stg", alpha=1)

</code></pre>

<hr>
<h2 id='binstat'>Sampling statistics and diversity indices in every bin</h2><span id='topic+binstat'></span>

<h3>Description</h3>

<p>This function will return the basic sampling summaries of a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binstat(
  x,
  tax = "genus",
  bin = "stg",
  coll = NULL,
  ref = NULL,
  noNAStart = FALSE,
  duplicates = NULL,
  xexp = NULL,
  indices = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binstat_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code>: The occurrence dataset.</p>
</td></tr>
<tr><td><code id="binstat_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code>: The column name of taxon names.</p>
</td></tr>
<tr><td><code id="binstat_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code>: The column name of bin names.</p>
</td></tr>
<tr><td><code id="binstat_+3A_coll">coll</code></td>
<td>
<p><code>(character)</code>: The column name of collection numbers. (optional)</p>
</td></tr>
<tr><td><code id="binstat_+3A_ref">ref</code></td>
<td>
<p><code>(character)</code>: The column name of reference numbers. (optional)</p>
</td></tr>
<tr><td><code id="binstat_+3A_nonastart">noNAStart</code></td>
<td>
<p>(logical) Useful when the dataset does not start from bin no. 1, but positive integer bin numbers are provided. Then <code>noNAStart=TRUE</code> will cut the first part of the resulting table, so the first row will contain the estimates for the lowest bin number. In case of positive integer bin identifiers, and if <code>noNAStart=FALSE</code>, the index of the row will be the bin number.</p>
</td></tr>
<tr><td><code id="binstat_+3A_duplicates">duplicates</code></td>
<td>
<p><code>(logical)</code>: The function will check whether there are duplicate occurrences (multiple species/genera). When set to <code>NULL</code>, nothing will happen, but the function will notify you if duplicates are present. If set to <code>TRUE</code>, the function will not do anything with these, if set to <code>FALSE</code>, the duplicates will be omitted.</p>
</td></tr>
<tr><td><code id="binstat_+3A_xexp">xexp</code></td>
<td>
<p>(<code>numeric</code>): Argument of the OxW subsampling type (<code><a href="#topic+subtrialOXW">subtrialOXW</a></code>).Setting this parameter to a valid numeric value will return the maximum quota for <code>xexp</code>.</p>
</td></tr>
<tr><td><code id="binstat_+3A_indices">indices</code></td>
<td>
<p>(<code>logical</code>): Setting this value to <code>TRUE</code> will calculate all indices implemented in (<code><a href="#topic+indices">indices</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Secondary function of the package that calculates a number of sampling related variables and diversity estimators for each bin. 
In contrast to the (<code><a href="#topic+divDyn">divDyn</a></code>) function, the bins are treated independently in this function.
The function also returns the maximum subsampling quota for OxW subsampling 
(<code><a href="#topic+subtrialOXW">subtrialOXW</a></code>) with a given <code>xexp</code> value.
</p>
<p>By setting <code>total</code> to <code>FALSE</code> (default), the following results are output:
</p>
<p><code>occs</code>: The number of occurrences in each time bin.
</p>
<p><code>colls</code>: The number of collections in each time bin.
</p>
<p><code>xQuota</code>: The maximum quota for OxW subsampling (<code><a href="#topic+subtrialOXW">subtrialOXW</a></code>) with the given <code>xexp</code> value. 
The number of occurrences in each collection is tabulated, and is raised to the power of <code>xexp</code>. 
The <code>xQuota</code> value is the sum of these values across all collections in a time slice.
</p>
<p><code>refs</code>: The number of references in each time bin.
</p>
<p><code>SIBs</code>: The number of Sampled-In-Bin taxa in each time bin.
</p>
<p><code>occ1</code>: The number of taxa in each time bin, that occur in only 1 collection.
</p>
<p><code>ref1</code>: The number of taxa in each time bin, that occur in only 1 reference.
</p>
<p><code>occ2</code>: The number of taxa in each time bin, that occur in exactly 2 collections.
</p>
<p><code>ref2</code>: The number of taxa in each time bin, that occur in exactly 2 references.
</p>
<p><code>u</code>: Good's u, coverage estimator based on the number of single-collection taxa (occ1).
</p>
<p><code>uPrime</code>: Good's u, coverage estimator based on the number of single-reference taxa (ref1).
</p>
<p><code>chao1occ</code>: Chao1 extrapolation estimator, based on the the number of single-collection and two-collection taxa (occ1).
</p>
<p><code>chao1ref</code>: Chao1 extrapolation estimator, based on the the number of single-reference and two-reference taxa (occ2).
</p>


<h3>Value</h3>

<p>A data.frame with rows corresponding to bin entries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)
# slice-specific sampling
basic &lt;- binstat(corals, tax="genus", bin="stg")

# subsampling diagnostic
 subStats &lt;- subsample(corals, method="cr", tax="genus", FUN=binstat, 
   bin="stg", q=100,noNAStart=FALSE)

# maximum quota with xexp
more &lt;- binstat(corals, tax="genus", bin="stg", coll="collection_no", xexp=1.4)

</code></pre>

<hr>
<h2 id='categorize'>Mapping multiple entries to categories</h2><span id='topic+categorize'></span>

<h3>Description</h3>

<p>This basic function replaces groups of values in a vector with single values with the help of a key object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>categorize(x, key, incbound = "lower")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="categorize_+3A_x">x</code></td>
<td>
<p><code>(vector)</code> Object containing the values to be replaced.</p>
</td></tr>
<tr><td><code id="categorize_+3A_key">key</code></td>
<td>
<p><code>(list)</code> A list of vectors. Each <code>vector</code> includes the possible elements that will be replaced in a group, the <code>names</code> of the <code>vector</code>s will be the replacement values. Also has to include an element named 'default' with a single value. (see examples)</p>
</td></tr>
<tr><td><code id="categorize_+3A_incbound">incbound</code></td>
<td>
<p><code>(character)</code> Either <code>"lower"</code> or <code>"higher"</code>. Interval identifiers will be treated with different interval rules. <code>"lower"</code> will treat the lowest entry as included, <code>"higher"</code> works the opposite. The argument will be renamed to 'include.lowest' to make the interface easier to remember.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Online datasets usually contain overly detailed information, as enterers intend to conserve as much data in the entry process, as possible. However, in analyses some values are treated to represent the same, less-detailed information, which is then used in further procedures. The <code>map</code> function allows users to do this type of multiple replacement using a specific object called a <code>'key'</code>. 
</p>
<p>A <code>key</code> is an informal class and is essentially a <code>list</code> of <code>vectors</code>. In the case of <code>character</code> vectors as <code>x</code>, each vector element in the <code>list</code> corresponds to a set of entries in <code>x</code>. These will be replaced by the name of the <code>vector</code> in the <code>list</code>, to indicate their assumed identity. 
</p>
<p>In the case of <code>numeric</code> <code>x</code> vectors, if the <code>list</code> elements of the <code>key</code>
are <code>numeric</code> vectors with 2 values, then this vector will be treated as an interval. The same value will be assigned to the entries that are in this interval (Example 2). If <code>x</code> contains values that form the boundary of an interval, than either only the one of the two boundary values can be considered to be in the interval (see the <code>incbound</code> argument to set which of the two).
The elements of <code>key</code> are looped through in sequence. If values of <code>x</code> occur in multiple elements of <code>key</code>, than the last one will be used (Example 3).
</p>
<p>Examples of this data type have been included (<code><a href="#topic+keys">keys</a></code>) to help process Paleobiology Database occurrences.
</p>


<h3>Value</h3>

<p>A vector with replacements.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
# x, as character
   set.seed(1000)
   toReplace &lt;- sample(letters[1:6], 15, replace=TRUE)
# a and b should mean 'first', c and d 'second' others: NA
   key&lt;-list(first=c("a", "b"), second=c("c", "d"), default=NA)
# do the replacement
  categorize(toReplace, key)

# Example 2 - numeric entries and mixed types
# basic vector to be grouped
  toReplace2&lt;-1:16

# replacement rules: 5,6,7,8,9 should be "more", 11 should be "eleven" the rest: "other"
  key2&lt;-list(default="other", more=c(5,10),eleven=11)
  categorize(toReplace2, key2)

# Example 3 - multiple occurrences of same values
# a and b should mean first, a and should mean 'second' others: NA
  key3&lt;-list(first=c("a", "b"), second=c("a", "d"), default=NA)
# do the replacement (all "a" entries will be replaced with "second")
  categorize(toReplace, key3)
   
</code></pre>

<hr>
<h2 id='cleansp'>Cleanse Species Name Vector</h2><span id='topic+cleansp'></span>

<h3>Description</h3>

<p>This function will take a vector of binomial names with various qualifiers of open nomenclatures, and removes them form the vector entries. Only the the genus and species names will remain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleansp(
  x,
  debug = FALSE,
  collapse = "_",
  subgenera = TRUE,
  misspells = TRUE,
  stems = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleansp_+3A_x">x</code></td>
<td>
<p><code>(character)</code>: the vector containing species names with qualifiers of open taxonomy.</p>
</td></tr>
<tr><td><code id="cleansp_+3A_debug">debug</code></td>
<td>
<p><code>(logical)</code>: <code>FALSE</code> will return the cleaned species name vector, <code>TRUE</code> returns a data table that allows one by one checking.</p>
</td></tr>
<tr><td><code id="cleansp_+3A_collapse">collapse</code></td>
<td>
<p><code>(character)</code>: This argument will be passed to the paste function's argument of the same name. The character value to be inserted between the genus and species names.</p>
</td></tr>
<tr><td><code id="cleansp_+3A_subgenera">subgenera</code></td>
<td>
<p><code>(logical)</code>: <code>FALSE</code> omits subgenus information (in parentheses) and will construct a unique binomen based on the genus and species names alone. <code>TRUE</code> (default) will promote the subgenus names and it will create a new binomen based on the subgenus rather than the genus name.</p>
</td></tr>
<tr><td><code id="cleansp_+3A_misspells">misspells</code></td>
<td>
<p><code>logical</code>: Resolution of common spelling mistakes, such as diphtongs and alternate spellings: 'ue' is replaced with 'u', 'ae' is replaced with 'e', 'll' with 'l', 'ss' with 's'and 'y' with 'i'.</p>
</td></tr>
<tr><td><code id="cleansp_+3A_stems">stems</code></td>
<td>
<p><code>(logical)</code>: Setting this to <code>TRUE</code> will omit the adjective declination suffices from the species names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This version will keep subgenera, and will not assign species to the base genus. The following qualifiers will be omitted:
<em>&quot;n.&quot;</em>, <em>&quot;sp.&quot;</em>, <em>&quot;?&quot;</em>, <em>&quot;gen.&quot;</em>, <em>&quot;aff.&quot;</em>, <em>&quot;cf.&quot;</em>, <em>&quot;ex gr.&quot;</em>, <em>&quot;subgen.&quot;</em>, <em>&quot;spp&quot;</em> and informal species designated with letters. Entries with <em>&quot;informal&quot;</em> and <em>&quot;indet.&quot;</em> in them will also be invalidated.
</p>


<h3>Value</h3>

<p>A data.frame or character vector.
</p>


<h3>Author(s)</h3>

<p>Adam T. Kocsis, Gwenn Antell. Adam T. Kocsis wrote the main body of the function, subroutines called by the <code>misspells</code> and <code>stems</code> are the modified work of Gwen Antell.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>examp &lt;- c("Genus cf. species", "Genus spp.", "Family indet.", 
  "Mygenus yourspecies", "Okgenus ? questionsp", 
  "Genus (cf. Subgenus) aff. species")
cleansp(examp) 
</code></pre>

<hr>
<h2 id='corals'>Fossil occurrences of scleractinian (stony) corals from the Paleobiology Database</h2><span id='topic+corals'></span>

<h3>Description</h3>

<p>Example dataset to illustrate the package's basic functionalities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(corals)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 29775 observations and 38 variables:
</p>

<dl>
<dt><code>genus</code></dt><dd><p>Genus names of the occurrences. Cross referenced with a compiled table, the simplified version of this can be found in the supplementary material of Kiessling and Kocsis (2015).</p>
</dd>
<dt><code>collection_no</code></dt><dd><p>The number of the collection of the occurrence in the PaleoDB.</p>
</dd>
<dt><code>family</code></dt><dd><p>Family name of the occurrence.</p>
</dd>
<dt><code>abund_value</code></dt><dd><p>Abundance value.</p>
</dd>
<dt><code>abund_unit</code></dt><dd><p>Unit of abundance values.</p>
</dd>
<dt><code>reference_no</code></dt><dd><p>The reference number of the occurrence in the PaleoDB.</p>
</dd>
<dt><code>life_habit</code></dt><dd><p>The lifestyle of the occurring taxon.</p>
</dd>
<dt><code>diet</code></dt><dd><p>The diet of the occurring taxon.</p>
</dd>
<dt><code>country</code></dt><dd><p>Country of occurrence.</p>
</dd>
<dt><code>geoplate</code></dt><dd><p>Plate id of the occurrence.</p>
</dd>
<dt><code>lat</code></dt><dd><p>Present day latitude of the occurrence.</p>
</dd>
<dt><code>lng</code></dt><dd><p>Present day longitude of the occurrence.</p>
</dd>
<dt><code>paleolat</code></dt><dd><p>Reconstructed paleolatitude of the occurrence.</p>
</dd>
<dt><code>paleolng</code></dt><dd><p>Reconstructed paleolongitude of the occurrence.</p>
</dd>
<dt><code>period</code></dt><dd><p>Period of origin.</p>
</dd>
<dt><code>epoch</code></dt><dd><p>Epoch of origin.</p>
</dd>
<dt><code>subepoch</code></dt><dd><p>Subepoch of origin.</p>
</dd>
<dt><code>stage</code></dt><dd><p>Geologic stage of the embedding rocks.</p>
</dd>
<dt><code>early_interval</code></dt><dd><p>Early interval name registered in the PaleoDB dynamic time scale.</p>
</dd>
<dt><code>late_interval</code></dt><dd><p>Late interval name registered in the PaleoDB dynamic time scale.</p>
</dd>
<dt><code>max_ma</code></dt><dd><p>Maximum estimated age based on the PaleoDB dynamic time scale.</p>
</dd>
<dt><code>min_ma</code></dt><dd><p>Minimum estimated age based on the PaleoDB dynamic time scale.</p>
</dd>
<dt><code>stg</code></dt><dd><p>Bin number in the stage-level timescale <code><a href="#topic+stages">stages</a></code>.</p>
</dd>
<dt><code>ten</code></dt><dd><p>Bin number in the PaleoDB 10 million year resolution timescale <code><a href="#topic+tens">tens</a></code>.</p>
</dd>
<dt><code>env</code></dt><dd><p>Environment of the occurrence: reefal <code>(r)</code>, non-reefal <code>(nr)</code> or unknown (<code>uk</code>), based on <code><a href="#topic+keys">keys</a></code>.</p>
</dd>
<dt><code>lith</code></dt><dd><p>Substrate of the occurrence: carbonate <code>(c)</code>, siliciclastic <code>(s)</code> or unknown (<code>uk</code>), based on <code><a href="#topic+keys">keys</a></code>.</p>
</dd>
<dt><code>latgroup</code></dt><dd><p>Latitude of the occurrence: tropical <code>(t)</code> or non-tropical <code>(nt)</code>.</p>
</dd>
<dt><code>bath</code></dt><dd><p>Inferred depth of the occurrence: deep <code>(deep)</code>, shallow <code>(shal)</code> or unknown (<code>uk</code>), based on <code><a href="#topic+keys">keys</a></code>.</p>
</dd>
<dt><code>gensp</code></dt><dd><p>The binomen of the occurrence.</p>
</dd>
<dt><code>ecology</code></dt><dd><p>Symbiotic status of the occurring coral: zooxanthellate <code>(z)</code> or azooxanthellate <code>(az</code>, including apozooxanthellates).</p>
</dd>
<dt><code>ecologyMostZ</code></dt><dd><p>Symbiotic status of the occurring coral, incorporating the uncertainty of inferred symbiotic status. This variable includes assignment with the maximum likely number of zooxanthellate genera.</p>
</dd>
<dt><code>ecologyMostAZ</code></dt><dd><p>Symbiotic status of the occurring coral, incorporating the uncertainty of inferred symbiotic status. This variable includes assignment with the maximum likely number of azooxanthellate genera.</p>
</dd>
<dt><code>growth</code></dt><dd><p>Growth type of the coral: <code>colonial</code> or <code>solitary</code>.</p>
</dd>
<dt><code>integration</code></dt><dd><p>Integration of corallites from the scale of 0 to 4. <code>solitary</code> corals are marked with 0s.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This particular dataset was used in a study by Kiessling and Kocsis (2015). All occurrences of Scleractinia were downloaded from the Paleobiology Database (PaleoDB, <a href="https://paleobiodb.org/">https://paleobiodb.org/</a>) on 23 September 2014, originally comprising 32420 occurrences. They were than cross-checked with data from Corallosphere (<a href="http://corallosphere.org">http://corallosphere.org</a>). See the article text for details.
</p>
<p>References
</p>
<p>Kiessling, W., &amp; Aberhan, M. (2007). Environmental determinants of marine benthic biodiversity dynamics through Triassic–Jurassic time. Paleobiology, 33(3), 414-434.
</p>


<h3>Source</h3>

<p><a href="https://paleobiodb.org/">https://paleobiodb.org/</a>
</p>

<hr>
<h2 id='divDyn'>Time series from metrics of diversity dynamics</h2><span id='topic+divDyn'></span>

<h3>Description</h3>

<p>This function calculates various metrics from occurrence datasets in the form of time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>divDyn(
  x,
  tax,
  bin = NULL,
  age = NULL,
  revtime = FALSE,
  breaks = NULL,
  coll = NULL,
  ref = NULL,
  om = NULL,
  noNAStart = FALSE,
  data.frame = TRUE,
  filterNA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="divDyn_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> Fossil occurrence table.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> Variable name of the occurring taxa (variable type: <code>factor</code> or <code>character</code> - such as <code>"genus"</code></p>
</td></tr>
<tr><td><code id="divDyn_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> Variable name of the discrete bin numbers of the occurrences. This variable should be <code>numeric</code>. Time flows from lower to higher values by default. Use <code>revtime</code> to reverse this order.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_age">age</code></td>
<td>
<p><code>(character)</code> Variable name of the ages of the occurrences that will be sliced with the <code>slice</code> function using the intervals provided in <code>breaks</code>. This variable should be <code>numeric</code>. Time flows from higher to lower values by default. Use <code>revtime</code> to reverse this order.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_revtime">revtime</code></td>
<td>
<p><code>(logical)</code> Argument for reversing the default direction of time. Setting this argument to <code>TRUE</code> will make time flow from higher to lower values when <code>bin</code> is used, and from lower to higher values, when <code>age</code> is given. CAUTION: Failing to set this argument properly can make originations become extinctions and vice versa!</p>
</td></tr>
<tr><td><code id="divDyn_+3A_breaks">breaks</code></td>
<td>
<p><code>(numeric)</code> If <code>NULL</code> (default) the used values in the <code>bin</code> variable will designate independent time slices that follow each other in succession. If a vector is provided, than the numeric entries in <code>bin</code> will be binned similarly to the <code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="base.html#topic+cut">cut</a></code> function. The order of elements in this vector is arbitrary.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_coll">coll</code></td>
<td>
<p><code>(character)</code> The variable name of the collection identifiers. (optional, only for use with the internal <code><a href="#topic+omit">omit</a></code> function)</p>
</td></tr>
<tr><td><code id="divDyn_+3A_ref">ref</code></td>
<td>
<p><code>(character)</code> The variable name of the reference identifiers. (optional, only for use with the internal <code><a href="#topic+omit">omit</a></code> function)</p>
</td></tr>
<tr><td><code id="divDyn_+3A_om">om</code></td>
<td>
<p><code>(character)</code> The <code>om</code> argument of the <code>omit()</code> function. If set to <code>NULL</code> (default), then no occurrences will be omitted before the execution of the function.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_nonastart">noNAStart</code></td>
<td>
<p>(logical) Useful when the entries in the <code>bin</code> variable do not start from bin no. 1, but positive integer bin numbers are provided. Then <code>noNAStart=TRUE</code> will cut the first part of the resulting table, so the first row will contain the estimates for the lowest bin number. In case of positive integer bin identifiers, and if <code>noNAStart=FALSE</code>, the index of the row will be the bin number.</p>
</td></tr>
<tr><td><code id="divDyn_+3A_data.frame">data.frame</code></td>
<td>
<p><code>(logical)</code> Should the output be a <code>data.frame</code> or a <code>matrix</code>?</p>
</td></tr>
<tr><td><code id="divDyn_+3A_filterna">filterNA</code></td>
<td>
<p><code>(logical)</code> The <code>filterNA</code> parameter of the <code><a href="#topic+omit">omit</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following variables are produced:
</p>
<p><code>bin</code>: Bin number, or the numeric identifier of the bin.
</p>
<p><code>tThrough</code>: Number of through-ranging taxa, taxa that have first occurrences before, and last occurrences after the focal bin.
</p>
<p><code>tOri</code>: Number of originating taxa, taxa that have first occurrences in the focal bin, and last occurrences after it.
</p>
<p><code>tExt</code>: Number of taxa getting extinct. These are taxa that have first occurrences before the focal bin, and last occurrences in it.
</p>
<p><code>tSing</code>: Number of stratigraphic singleton (single-interval) taxa, taxa that only occur in the focal bin.
</p>
<p><code>t2d</code>: Number of lower two timers (Alroy, 2008; 2014), taxa that are present in the <em>i</em>-1th and the ith bin (focal bin). 
</p>
<p><code>t2u</code>: Number of upper two timers (Alroy, 2008; 2014), taxa that are present in the <em>i</em>th (focal) and the <em>i</em>+1th bin. (Alroy, 2008; 2014)
</p>
<p><code>tGFu</code>: Number of upper gap-fillers (Alroy, 2014), taxa that occurr in bin <em>i</em>+2 and <em>i</em>-1, but were not found in <em>i</em>+1. (Alroy, 2014)
</p>
<p><code>tGFd</code>: Number of lower gap-fillers (Alroy, 2014), taxa that occurr in bin <em>i</em>-2 and <em>i</em>+1, but were not found in <em>i</em>-1. (Alroy, 2014)
</p>
<p><code>t3</code>: Number of three timer taxa (Alroy, 2008; 2014), present in bin <em>i</em>-1, <em>i</em>, and <em>i</em>+1. (Alroy, 2008; 2014)
</p>
<p><code>tPart</code>: Part timer taxa (Alroy, 2008; 2014), present in bin <em>i</em>-1,and <em>i</em>+1, but not in bin <em>i</em>. 
</p>
<p><code>extProp</code>: Proportional extinctions including single-interval taxa: <em>(tExt + tSing) / (tThrough + tOri + tExt + tSing)</em>.
</p>
<p><code>oriProp</code>: Proportional originations including single-interval taxa:  <em>(tOri + tSing) / (tThrough + tOri + tExt + tSing)</em>.
</p>
<p><code>extPC</code>: Per capita extinction rates of Foote (1999). <em>-log(tExt/(tExt + tThrough))</em>.  Values are not normalized with bin lengths. Similar equations were used by Alroy (1996) but without taking the logarithm.
</p>
<p><code>oriPC</code>: Per capita origination rates of Foote (1999). <em>-log(tOri/(tOri + tThrough))</em>. Values are not normalized with bin lengths. Similar equations were used by Alroy (1996) but without taking the logarithm.
</p>
<p><code>ext3t</code>: Three-timer extinction rates of Alroy (2008). <em>log(t2d/t3)</em>.
</p>
<p><code>ori3t</code>: Three-timer origination rates of Alroy (2008). <em>log(t2u/t3)</em>.
</p>
<p><code>extC3t</code>: Corrected three-timer extinction rates of Alroy (2008). <em>ext3t[i] + log(samp3t[i+1])</em>.
</p>
<p><code>oriC3t</code>: Corrected three-timer origination rates of Alroy (2008). <em>ori3t[i] + log(samp3t[i-1])</em>.
</p>
<p><code>divSIB</code>: Sampled-in-bin diversity (richness), the number of genera sampled in the focal bin.
</p>
<p><code>divCSIB</code>: Corrected sampled-in-bin diversity (richness). <em>divSIB/samp3t*totSamp3t</em>, where <em>totSamp3t</em> is total three-timer sampling completeness of the dataset (Alroy, 2008). 
</p>
<p><code>divBC</code>: Boundary-crosser diversity (richness), the number of taxa with ranges crossing the boundaries of the interval. <em>tExt + tOri + tThrough</em>.
</p>
<p><code>divRT</code>: Range-through diversity (richness), all taxa in the interval, based on the range-through assumption. <em>(tSing + tOri + tExt + tThrough)</em>.
</p>
<p><code>sampRange</code>: Range-based sampling probability, without observed range end-points (Foote), <em>(divSIB - tExt - tOri- t-Sing)/tThrough</em>
</p>
<p><code>samp3t</code>: Three-timer sampling completeness of Alroy (2008). <em>t3/(t3+tPart)</em>
</p>
<p><code>extGF</code>: Gap-filler extinction rates of Alroy(2014). <em>log((t2d + tPart)/(t3+tPart+tGFd))</em>
</p>
<p><code>oriGF</code>: Gap-filler origination rates of Alroy(2014). <em>log((t2u + tPart)/(t3+tPart+tGFd))</em>
</p>
<p><code>E2f3</code>: Second-for-third extinction propotions of Alroy (2015). As these metrics are based on an algorithmic approach, for the equations please refer to the Alroy (2015, p. 634, right column and Eq. 4)). See source code (<a href="https://github.com/divDyn/divDyn">https://github.com/divDyn/divDyn</a>) for the exact implementation, found in the <code>Metrics</code> function in the diversityDynamics.R file.
</p>
<p><code>O2f3</code>: Second-for-third origination propotions of Alroy (2015). Please see <code>E2f3</code>.
</p>
<p><code>ext2f3</code>: Second-for-third extinction rates (based on Alroy, 2015). Transformed to the usual rate form with <em>log(1/(1-E2f3))</em>.
</p>
<p><code>ori2f3</code>: Second-for-third origination rates (based on Alroy, 2015). Transformed to the usual rate form with <em>log(1/(1-O2f3))</em>.
</p>
<p><strong>References:</strong>
</p>
<p>Foote, M. (1999) Morphological Diversity In The Evolutionary Radiation Of Paleozoic and Post-Paleozoic Crinoids. Paleobiology 25, 1–115. doi:10.1017/S0094837300020236.
</p>
<p>Alroy, J. (2008) Dynamics of origination and extinction in the marine fossil record. Proceedings of the National Academy of Science 105, 11536-11542. doi: 10.1073/pnas.0802597105
</p>
<p>Alroy, J. (2014) Accurate and precise estimates of origination and extinction rates. Paleobiology 40, 374-397. doi: 10.1666/13036
</p>
<p>Alroy, J. (2015) A more precise speciation and extinction rate estimator. Paleobiology 41, 633-639. doi: 10.1017/pab.2015.26
</p>


<h3>Value</h3>

<p>A data.frame object, with every row corresponding to a time bin.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># import data
  data(corals)
  data(stages)

# calculate metrics of diversity dynamics
   dd &lt;- divDyn(corals, tax="genus", bin="stg")

# plotting
  tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
    ylab="range-through diversity (genera)", ylim=c(0,230))
  lines(stages$mid, dd$divRT, lwd=2)

 # with omission of single reference taxa  
   ddNoSing &lt;- divDyn(corals, tax="genus", bin="stg", om="ref", ref="reference_no")
   lines(stages$mid, ddNoSing$divRT, lwd=2, col="red")

 # using the estimated ages (less robust) - 10 million years
   # mean ages
   corals$me_ma &lt;- apply(corals[, c("max_ma", "min_ma")], 1, mean)
   # ages reverse the direction of time! set ages to TRUE in this case
   ddRadio10 &lt;- divDyn(corals, tax="genus", age="me_ma", 
	breaks=seq(250,0,-10))
   lines(ddRadio10$me_ma, ddRadio10$divRT, lwd=2, col="green")
      
 # legend
   legend("topleft", legend=c("all", "no single-ref. taxa", "all, estimated ages"), 
     col=c("black", "red", "green"), lwd=c(2,2,2), bg="white")
   

</code></pre>

<hr>
<h2 id='fadlad'>FAD - LAD matrix from occurrence data</h2><span id='topic+fadlad'></span>

<h3>Description</h3>

<p>Function to generate range data from an occurrence dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fadlad(
  x,
  tax,
  bin = NULL,
  age = NULL,
  revtime = FALSE,
  na.rm = TRUE,
  diffbin = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fadlad_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code>: Occurrence data.</p>
</td></tr>
<tr><td><code id="fadlad_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code>: Column name of taxon names.</p>
</td></tr>
<tr><td><code id="fadlad_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code>: Column name(s) of the discreet bin variable(s). If two column names are entered, then they will interpreted as minimum and maximum uncertainty (see examples) By default, time flows from lower to higher numbers. You can change this behavior by setting <code>revtime=FALSE</code>. Either a <code>bin</code> or <code>age</code> argument is mandatory.</p>
</td></tr>
<tr><td><code id="fadlad_+3A_age">age</code></td>
<td>
<p><code>(character)</code>: Column name(s) of the continuous age variable(s). If two column names are entered, then they will interpreted as the minimum and maximum age uncertainty. (see examples) By default, time flows from higher to lower numbers. You can change this behavior by setting <code>revtime=FALSE</code>. Either a <code>bin</code> or <code>age</code> argument is mandatory.</p>
</td></tr>
<tr><td><code id="fadlad_+3A_revtime">revtime</code></td>
<td>
<p><code>(logical)</code>: Should time be reversed?</p>
</td></tr>
<tr><td><code id="fadlad_+3A_na.rm">na.rm</code></td>
<td>
<p><code>(logical)</code>: Should taxa that have no valid FADs or LADs (due to <code>NA</code> entries) be removed from the output?</p>
</td></tr>
<tr><td><code id="fadlad_+3A_diffbin">diffbin</code></td>
<td>
<p><code>(logical)</code>: Difference-based duration for discreet time (only applicabble to cases when <code>bin</code> is provided). If set to <code>TRUE</code>, single-interval taxa will <code>0</code> durations. Setting this argument to <code>FALSE</code> will add code1 to the durations of all taxa.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function will output First and Last Appearance Dates of the taxa in the dataset. Keep in mind that incomplete sampling will influence these data and will make the ranges appear shrunken.
</p>
<p>The following variables are produced:
</p>
<p><code>row.names</code> attribute: The names of the taxa.
</p>
<p><code>FAD</code>: First appearance dates in time bin nmbers or ages.
</p>
<p><code>LAD</code>: Last appearance dates in time bin numbers or ages.
</p>
<p><code>duration</code>: The durations of taxa in bin numbers or ages.
</p>


<h3>Value</h3>

<p>A data.frame, with rows corresponding to <code>tax</code> entries.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)

# binned data
  flBinned &lt;- fadlad(corals, tax="genus", bin="stg")

# using basic bin lengths
  flDual &lt;- fadlad(corals, tax="genus", age=c("max_ma", "min_ma"))

# single age esimate 
  data(stages)
  corals$mid &lt;- stages$mid[corals$stg]
  flSingle &lt;- fadlad(corals, tax="genus", age="mid")


</code></pre>

<hr>
<h2 id='fill'>Filling of missing values in a vector, based on the marginal values of the gaps</h2><span id='topic+fill'></span>

<h3>Description</h3>

<p>The function will loop through a vector and will substitute <code>NA</code> values with the value it last encountered or replaced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fill(x, forward = TRUE, inc = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fill_+3A_x">x</code></td>
<td>
<p><code>(vector)</code>  Vector to be filled.</p>
</td></tr>
<tr><td><code id="fill_+3A_forward">forward</code></td>
<td>
<p><code>(logical)</code> Should the loop go forward or backward?</p>
</td></tr>
<tr><td><code id="fill_+3A_inc">inc</code></td>
<td>
<p><code>(numeric)</code> Only if <code>x</code> is <code>numeric</code>, the function will increase the substituted value by this amount (useful for filling in sequences).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>NA</code>s won't be substituted when they are the first values the loop encounters.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># forward, replace with previous
dummy&lt;- c(TRUE, FALSE, NA, TRUE, FALSE, NA)
fill(dummy)

# forward, replace with previous+1
dummy2 &lt;- c(1,NA, 3, 1, 2, NA, NA, 9, NA,3)
fill(dummy2, inc=1)

# backward, replace with previous in loop direction
fill(dummy2, inc=0, forward=FALSE)
</code></pre>

<hr>
<h2 id='georange'>Estimation of geographic ranges from occurrence data</h2><span id='topic+georange'></span>

<h3>Description</h3>

<p>Geographic range as a function of a set of coordinates or sample/site/cell membeships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>georange(x, lng = NULL, lat = NULL, loc = NULL, method = "co")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="georange_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> Occurrence table containing the coordinates/locality memberships as variables.</p>
</td></tr>
<tr><td><code id="georange_+3A_lng">lng</code></td>
<td>
<p>(<code>character</code>) The variable name of the longitudes, required for the <code>"co"</code>, <code>"mst"</code> and <code>"mgcd"</code> methods.</p>
</td></tr>
<tr><td><code id="georange_+3A_lat">lat</code></td>
<td>
<p>(<code>character</code>) The variable name of the latitudes, required for the <code>"co"</code>, <code>"mst"</code> and <code>"mgcd"</code> methods.</p>
</td></tr>
<tr><td><code id="georange_+3A_loc">loc</code></td>
<td>
<p>(<code>character</code>) The variable name of the locality entries: cells, site or samples, required for the <code>"lo"</code> method.</p>
</td></tr>
<tr><td><code id="georange_+3A_method">method</code></td>
<td>
<p>(<code>character</code>) Geographic range estimator method. Can take multiple entries (concatenating the results in a vector). The following methods are implemented: <code>"co"</code>: coordinate-based occupancy, the number of different coordinate pairs; <code>"lo"</code>: locality-based occupancy for sites, samples or geographic cells, number of different entries in a variable. <code>"mst"</code>, the total length of a minimum spanning tree of the point cloud, based on the great circle distances between points (requires the 'vegan' and 'icosa' packages). <code>"mgcd"</code>, maximum great-circle distance that can be measured in the point cloud (this version is limited to half the circumference of the equator, requires the 'icosa' package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple estimators of geographic ranges are implemented based on coordinates or cell identifiers. The function outputs a vector of the results based on the calculation methods specified in <code>methods</code>.
</p>


<h3>Value</h3>

<p>A numeric vector with geographic ranges (multiple methods).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)
# select a  taxon from a certain time slice
  bitax &lt;- corals[corals$stg==69 &amp; corals$genus=="Microsolena",]
  georange(bitax, lng="paleolng", lat="paleolat", method="co")

</code></pre>

<hr>
<h2 id='indices'>Scalar indices of diversity</h2><span id='topic+indices'></span>

<h3>Description</h3>

<p>This function includes some indices that characterize a species-abundance/occurrence distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indices(x, samp = NULL, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indices_+3A_x">x</code></td>
<td>
<p>either a <code>character</code> vector of occurrences or a table of counts (<code>matrix</code>).</p>
</td></tr>
<tr><td><code id="indices_+3A_samp">samp</code></td>
<td>
<p>(<code>vector</code>): Only applicable if <code>x</code> is vector of occurrence entries. The id of the sampling units. A necessary variable for SCOR.</p>
</td></tr>
<tr><td><code id="indices_+3A_method">method</code></td>
<td>
<p>(<code>character</code>): The type of metric that is to be calculated. The default value (<code>NULL</code>) will calculate all implemented metrics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This set is not complete and does not intend to supercede additional R packages (e.g. vegan). However, some metrics are presented here as they are not
implemented elsewhere or because they are invoked more frequently. The following entries can be added to the <code>method</code> argument of the function, which are
also named accordingly in the output table/vector.
</p>
<p><code>"richness"</code>: The number of sampled species. 
</p>
<p><code>"shannon"</code>: The Shannon entropy.
</p>
<p><code>dom</code>: The Berger-Parker dominance index, the proportion of occurrences in the time bin that belong to the most frequent taxon.
</p>
<p><code>"hill2"</code>: The second order Hill number (Jost, 2006; q=2), which will be calculated by default. You can specify additional Hill numbers with adding <code>"hillXX"</code> to the <code>method</code>
argument, such as <code>"hill3"</code> for (q=3). The first Hill number is defined as the exponentiad version of Shannon entropy (Eq. 3 in Jost, 2006). 
</p>
<p><code>"squares"</code>: The 'squares' richness estimator of J. Alroy (2018).
</p>
<p><code>"chao2"</code>: The Chao2 estimator for incidence-based data.
</p>
<p><code>"SCOR"</code>: The Sum Common Species Occurrence rate of Hannisdal et al. (2012). This method will only be calculated if the occurrence entries (vector)
a collection vector is provided (see examples).
</p>


<h3>Value</h3>

<p>A named numeric vector.
</p>


<h3>References</h3>

<p>Alroy, J. 2018. Limits to species richness in terrestrial communities. Ecology Letters.
</p>
<p>Hannisdal, B., Henderiks, J., &amp; Liow, L. H. (2012). Long-term evolutionary and ecological responses of calcifying phytoplankton to changes in atmospheric CO2. Global Change Biology, 18(12), 3504–3516. https://doi.org/10.1111/gcb.12007
</p>
<p>Jost, L. (2006). Entropy and diversity. Oikos, 113, 363–375. https://doi.org/10.1111/j.2006.0030-1299.14714.x
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the coral data
  data(corals)

# Pleistocene subset
  plei &lt;- corals[corals$stg==94,]

# calculate everything
  pleiIndex&lt;-indices(plei$genus, plei$coll)


</code></pre>

<hr>
<h2 id='keys'>Keys to process stratigraphic, environmental and lithological information from the Paleobiology Database</h2><span id='topic+keys'></span>

<h3>Description</h3>

<p>Lists of entries treated as indicators of similar characteristics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(keys)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> of 7 <code>list</code>s:
</p>

<dl>
<dt><code>tenInt</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>early_interval</code> and <code>late_interval</code> variables of PaleoDB downloads indicate the collections' positions in the dynamic time scale. These entries were linked to 10 million year-resolution time scale stored in <code><a href="#topic+tens">tens</a></code>. These links were compiled using a download from the FossilWorks website (<a href="http://www.fossilworks.org/">http://www.fossilworks.org/</a>), on 08 June, 2018. You can check the lookup table <code><a href="#topic+stratkeys">stratkeys</a></code> here. This is version 0.9.2</p>
</dd>
<dt><code>stgInt</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>early_interval</code> and <code>late_interval</code> variables of PaleoDB downloads indicate the collections' positions in the dynamic time scale. These entries were linked to stage-resolution time scale stored in <code><a href="#topic+stages">stages</a></code>. See <code>binInt</code> for version information.</p>
</dd></dl>
<p> These entries are reliable only in the Post-Ordovician!
</p>
<dl>
<dt><code>reefs</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>environment</code> field of the PaleoDB download indicate information regarding the likely reefal origin of carbonatic rocks. See the vignette ('§PhaneroCurve') on the exact use of these data. v0.9.</p>
</dd>
<dt><code>lith</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>lithology1</code> field of the PaleoDB download indicate information regarding the substrate of the embedding rocks. This key maps the entries to <code>siliciclastic</code>, <code>"carbonate"</code> or <code>"unknown"</code> substrates. v0.9.</p>
</dd>
<dt><code>lat</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>paleolat</code> field of the PaleoDB download indicate information regarding paleolatitude of the occurrences. This key maps the entries to <code>"tropical"</code> or <code>"non-tropical"</code> latitudes. v0.9.</p>
</dd>
<dt><code>grain</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>lithology1</code> field of the PaleoDB download indicate information regarding the grain sizes of the depositional environment. This key maps the entries to <code>"coarse"</code>, <code>"fine"</code> or <code>"unknown"</code> grain sizes. v0.9.</p>
</dd>
<dt><code>depenv</code></dt><dd><p>A <code>list</code> of <code>vector</code>s. Entries in the <code>environment</code> field of the PaleoDB download indicate information regarding the onshore-offshore nature of the depositional environment. This key maps the entries to <code>"onshore"</code>, <code>"offshore"</code> or <code>"unknown"</code> environment. v0.9.3</p>
</dd>
</dl>



<h3>Details</h3>

<p>Entries in the stratigraphic, lithological and environment fields of current Paleobiology Database downloads are too numerous to form the basis of analyses without transformations. 
This variable includes potential groupings of entries that represent similar characteristics. These objects can be used by the <code><a href="#topic+categorize">categorize</a></code> function to create new variables of stratigraphic, environmental and lithological information.
</p>


<h3>Source</h3>

<p>Stratigraphic assignments are based on the download of collection data from Fossilworks (<a href="http://www.fossilworks.org/">http://www.fossilworks.org/</a>) and the dynamic time scale of the Paleobiology Database, written by J. Alroy. The assignment of numeric values were done by A. Kocsis. Environmental variables were grouped by W. Kiessling.
</p>

<hr>
<h2 id='matchtime'>Match the dates of a time-dependent variable with a predefined vector</h2><span id='topic+matchtime'></span><span id='topic+matchtime+2Cnumeric-method'></span><span id='topic+matchtime+2Ccharacter-method'></span><span id='topic+matchtime+2Clist-method'></span>

<h3>Description</h3>

<p>The function takes a variable <code>x</code> (e.g. a vector or a list object), and reorders it to best match the dates provided in a vector <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchtime(x, y, ...)

## S4 method for signature 'numeric'
matchtime(x, y, index = FALSE, ...)

## S4 method for signature 'character'
matchtime(x, y, index = FALSE, ...)

## S4 method for signature 'list'
matchtime(x, y, index = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchtime_+3A_x">x</code></td>
<td>
<p>Object to be reordered to match <code>y</code>.</p>
</td></tr>
<tr><td><code id="matchtime_+3A_y">y</code></td>
<td>
<p>(<code>numeric</code>) The vector of dates (numeric values) to order to.</p>
</td></tr>
<tr><td><code id="matchtime_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to class-specific methods.</p>
</td></tr>
<tr><td><code id="matchtime_+3A_index">index</code></td>
<td>
<p>(<code>logical</code>) If this argument is <code>TRUE</code>, only the indices will be returned that refer to the new order, rather than the reordered <code>x</code> variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class as <code>x</code> or a <code>numeric</code> vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># original vector
orig &lt;- 1:10
# target values
targ &lt;- c(5.1,4.2, 3.4, 2.7, 2.3)
# how do the two series match the best?
matchtime(orig, targ)
</code></pre>

<hr>
<h2 id='modeltab'>Origination/extinction response table for statistical modelling.</h2><span id='topic+modeltab'></span>

<h3>Description</h3>

<p>This function takes an occurrence dataset and reformats it to a table that can be used as input for logistic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modeltab(
  x,
  tax,
  bin,
  taxvars = NULL,
  rt = FALSE,
  singletons = FALSE,
  probs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modeltab_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> Fossil occurrence data.frame.</p>
</td></tr>
<tr><td><code id="modeltab_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> Variable name of the occurring taxa (variable type: <code>factor</code> or <code>character</code> - such as <code>"genus"</code>)</p>
</td></tr>
<tr><td><code id="modeltab_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> Variable name of the bin numbers of the occurrences. This variable should be <code>numeric</code> and should increase as time passes by (use negative values for age estimates). The current version only supports discreet, non-negative integer interval numbers.</p>
</td></tr>
<tr><td><code id="modeltab_+3A_taxvars">taxvars</code></td>
<td>
<p><code>(character)</code> Taxon-specific column names of the variables that should be included in the output table. Only one entry/taxon is used, make sure that the data are clean.</p>
</td></tr>
<tr><td><code id="modeltab_+3A_rt">rt</code></td>
<td>
<p><code>(logical)</code> Should the range-through assumption be applied within the function? If set to <code>TRUE</code> then missing occurrences will be interpolated with <code>FALSE</code> values in both the <code>ext</code> and <code>ori</code> variables. .</p>
</td></tr>
<tr><td><code id="modeltab_+3A_singletons">singletons</code></td>
<td>
<p><code>(logical)</code> Should single-interval taxa be included from the final table? This is not recommended, as it is impossible to get a <code>FALSE</code> response for these taxa.</p>
</td></tr>
<tr><td><code id="modeltab_+3A_probs">probs</code></td>
<td>
<p><code>(logical)</code> When set to <code>NULL</code>, the response variable will be binary. When set to <code>"samp3t"</code> or <code>"sampRange"</code> the response results will be probabilities, based on the three-timer sampling completeness, or the range-based sampling completeness, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Every entry in the output table corresponds to one cell in the <code>bin</code>/<code>tax</code> matrix. This function omits duplicates and concatenates two <code>logical</code> vectors (response variables) to the occurrence dataset:  
The <code>ori</code> vector is <code>TRUE</code> in the interval when the taxon first appeared, and <code>FALSE</code> in all others. The <code>ext</code> vector is <code>TRUE</code> in the interval the taxon appeared for the last time, and <code>FALSE</code> in the rest.
</p>
<p>The true date of extinction and origination is unknown, therefore these events can only be expressed as probabilities. The argument <code>probs</code> allows the replacement of a binary response with two probability values, which are based on the apparent sampling patterns. For extinctions, when <code>probs</code> is set to <code>"samp3t"</code>, the response parameter for extinctions in the last bin of appearance is set to the three-timer sampling compelteness of the following bin. Assuming that the taxon'as range offset is not larger than a whole bin, if the taxon did not go extinct in the bin in which it appeared the last time, it is assumed to be going extinct in the following bin, and the remainder (1 -  sampling completeness) is assigned to that bin. The pattern is reversed for originations. For <code>probs="sampRange"</code>, the range-based completeness measures are applied in a similar fashion. For Phanerozoic-scale analyses, a whole bin difference between apparent event and the actual event is reasonable. See more in Reddin et al. 2021. Note that the response probabilities are set to missing values (<code>NA</code>s) when the probabilities cannot be calculated. The variable <code>ext</code> is also set to <code>NaN</code> for the early virtual extension of the range, and <code>ori</code> is treated the same for the late-extension. 
</p>
<p><strong>References:</strong>
</p>
<p>Reddin, C. J., Kocsis, Á. T., Aberhan, M., &amp; Kiessling, W. (2021). Victims of ancient hyperthermal events herald the fates of marine clades and traits under global warming. Global Change Biology, 27(4), 868–878. https://doi.org/10.1111/gcb.15434
</p>


<h3>Value</h3>

<p>A data.frame with binary response variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load necessary data
data(corals)
# simple table
modTab&lt;-modeltab(corals, bin="stg", tax="genus", taxvars=c("ecology", "family"))
# probabilities for extinction modeling
modTab2 &lt;- modeltab(corals, bin="stg", tax="genus", probs="samp3t")
# only extinction response (omit virtual origination extensions)
extTab &lt;- modTab2[!is.nan(modTab2$ext), ]
# only extinction response (omit virtual extinction extensions)
oriTab &lt;- modTab2[!is.nan(modTab2$ori), ]

</code></pre>

<hr>
<h2 id='omit'>Omission of taxa that have a poor occurrence record</h2><span id='topic+omit'></span>

<h3>Description</h3>

<p>Function to quickly omit single-collection and single-reference taxa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omit(
  x,
  om = "ref",
  tax = "genus",
  bin = "bin",
  coll = NULL,
  ref = NULL,
  filterNA = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="omit_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> Occurrence dataset, with <code>bin</code>, <code>tax</code> and <code>coll</code> as column names.</p>
</td></tr>
<tr><td><code id="omit_+3A_om">om</code></td>
<td>
<p><code>(character)</code> The type of omission. <code>"coll"</code> omits occurrences of taxa that occurr only in one collection. <code>"ref"</code> omits occurrences of taxa that were described only in one reference. <code>"binref"</code> will omit the set of single reference taxa that were described by more than one references, but appear in only one reference in a time bin.</p>
</td></tr>
<tr><td><code id="omit_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> The name of the taxon variable.</p>
</td></tr>
<tr><td><code id="omit_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> The name of the bin variable (has to be <code>numeric</code> for the function to run). For time series, this is the time slice variable.</p>
</td></tr>
<tr><td><code id="omit_+3A_coll">coll</code></td>
<td>
<p><code>(character)</code> The variable name of the collection identifiers.</p>
</td></tr>
<tr><td><code id="omit_+3A_ref">ref</code></td>
<td>
<p><code>(character)</code> The variable name of the reference identifiers (optional).</p>
</td></tr>
<tr><td><code id="omit_+3A_filterna">filterNA</code></td>
<td>
<p><code>(logical)</code> Additional entries can be added to influence the dataset that might not have reference or collection information (<code>NA</code> entries). These occurrences are treated as single-collection or single-reference taxa if the <code>na.rm</code> argument is set to <code>FALSE</code> (default). Setting this argument to <code>TRUE</code> will keep these entries. (see example)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a <code>logical</code> vector, with a value for each row. <code>TRUE</code> values indicate rows to be omitted, <code>FALSE</code> values indicate rows to be kept. The function is embedded in the <code><a href="#topic+divDyn">divDyn</a></code> function, but can be called independently.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># omit single-reference taxa
  data(corals)
  data(stages)
  toOmit &lt;- omit(corals, bin="stg", tax="genus", om="ref", ref="reference_no")
  x &lt;- corals[!toOmit,]

# within divDyn
  # plotting
  tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
    ylab="range-through diversity (genera)", ylim=c(0,230))
  # multiple ref/slice required
  ddNoSing &lt;- divDyn(corals, tax="genus", bin="stg", om="binref", ref="reference_no")
  lines(stages$mid, ddNoSing$divRT, lwd=2, col="red")

  # with the recent included (NA reference value)
  ddNoSingRec &lt;- divDyn(corals, tax="genus", bin="stg",
    om="binref", filterNA=TRUE,ref="reference_no")
  lines(stages$mid, ddNoSingRec$divRT, lwd=2, col="blue")
  
  # legend
  legend("topleft", legend=c("no single-ref. taxa", 
    "no single-ref. taxa,\n with recent"), 
    col=c("red", "blue"), lwd=c(2,2))
</code></pre>

<hr>
<h2 id='parts'>Plot time series counts or proportions as polygons</h2><span id='topic+parts'></span>

<h3>Description</h3>

<p>This function plots the changing shares of categories in association with an independent variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parts(
  x,
  b = NULL,
  ord = "up",
  prop = FALSE,
  plot = TRUE,
  col = NULL,
  xlim = NULL,
  border = NULL,
  ylim = c(0, 1),
  na.valid = FALSE,
  labs = TRUE,
  labs.args = NULL,
  vertical = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parts_+3A_x">x</code></td>
<td>
<p><code>(numeric)</code>: The independent variable through which the proportion is tracked. Identical entries are used to assess which values belong together to a set. Their values represent the x coordinate over the plot.</p>
</td></tr>
<tr><td><code id="parts_+3A_b">b</code></td>
<td>
<p>(<code>character</code> or <code>factor</code>): A single vector with the category designations. This vector will be segmented using the entries of <code>x</code>.</p>
</td></tr>
<tr><td><code id="parts_+3A_ord">ord</code></td>
<td>
<p><code>(character)</code>: The parameter of the variable order. Either <code>"up"</code> (increasing alphabetical order), <code>"down"</code> (decreasing alphabetical order) or the vector of categories in the desired order.</p>
</td></tr>
<tr><td><code id="parts_+3A_prop">prop</code></td>
<td>
<p><code>(logical)</code>: Should the diagram show proportions (<code>TRUE</code>) or counts (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="parts_+3A_plot">plot</code></td>
<td>
<p><code>(logical)</code>: If set to <code>TRUE</code>, then the function will plot the output. If set to <code>FALSE</code>, then a matrix with the relevant values will be returned. This output is similar to the output of <code><a href="base.html#topic+table">table</a></code>, but handles proportions instantly.</p>
</td></tr>
<tr><td><code id="parts_+3A_col">col</code></td>
<td>
<p><code>(character)</code>: The color of polygons, has to a be a vector with as many entries as there are categories in <code>b</code>. By default <code>(col=NULL)</code> this is grayscale.</p>
</td></tr>
<tr><td><code id="parts_+3A_xlim">xlim</code></td>
<td>
<p><code>(numeric)</code>: Two values, analogous to the <code>xlim</code> argument of <code><a href="graphics.html#topic+plot">plot</a></code>, and has to exceed the range of <code>x</code>. The polygons that represent non-zero values with the lowest and highest values of <code>x</code> will be extended to these <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code id="parts_+3A_border">border</code></td>
<td>
<p><code>(character)</code>: The a single color of the polygon borders. By default (<code>border=NA</code>), no borders are drawn.</p>
</td></tr>
<tr><td><code id="parts_+3A_ylim">ylim</code></td>
<td>
<p><code>(numeric)</code>: If <code>prop=TRUE</code>, then the argument controls the position of the proportions in the plotting area (useful to show proportions as a sub plot in a plot). If <code>prop=FALSE</code>, then the entire plotting area will be shifted by a single <code>ylim</code> value.</p>
</td></tr>
<tr><td><code id="parts_+3A_na.valid">na.valid</code></td>
<td>
<p><code>(logical)</code>: If <code>TRUE</code>, than the missing values will be treated as an independent category. Entries where <code>x</code> is <code>NA</code> will be omitted either way.</p>
</td></tr>
<tr><td><code id="parts_+3A_labs">labs</code></td>
<td>
<p><code>(logical)</code>: Should the category names be plotted?</p>
</td></tr>
<tr><td><code id="parts_+3A_labs.args">labs.args</code></td>
<td>
<p><code>(list)</code>: Arguments for the <code><a href="graphics.html#topic+text">text</a></code> function. If one entry for each argument is provided, then it will be applied to all labels. If the number of elements in an argument equals the number of categories to be plotted, then one to one assignment will be used. For example, for 4 categories in total, if the <code>labs.args</code> <code>list</code> contains a <code>col</code> vector element with 4 values, see examples).</p>
</td></tr>
<tr><td><code id="parts_+3A_vertical">vertical</code></td>
<td>
<p><code>(logical)</code>: Horizontal or vertical plotting? If <code>FALSE</code>, the independent variable will be horizontal, if <code>TRUE</code>, the count/proportion variable will be horizontal. In the latter case <code>xlim</code> and <code>ylim</code> has reversed roles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for displaying the changing proportions of a category as time progresses. Check out the examples for the most frequent implementations.
</p>
<p>To be added: missing portions are omitted in this version, but should be represented as gaps in the polygons.
</p>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# dummy examples 
  # independent variable
  slc&lt;-c(rep(1, 5), rep(2,7), rep(3,6))

  # the categories as they change
  v1&lt;-c("a", "a", "b", "c", "c") # 1
  v2&lt;-c("a", "b", "b", "b", "c", "d", "d") # 2
  v3&lt;-c("a", "a", "a", "c", "c", "d") #3
  va&lt;-c(v1, v2,v3)

  # basic function
    plot(NULL, NULL, ylim=c(0,1), xlim=c(0.5, 3.5))
    parts(slc, va, prop=TRUE)
 
  # vertical plot
    plot(NULL, NULL, xlim=c(0,1), ylim=c(0.5, 3.5))
    parts(slc, va, col=c("red" ,"blue", "green", "orange"), xlim=c(0.5,3.5), 
      labs=TRUE, prop=TRUE, vertical=TRUE)

  # intensive argumentation
    plot(NULL, NULL, ylim=c(0,10), xlim=c(0.5, 3.5))
    parts(slc, va, ord=c("b", "c", "d", "a"), col=c("red" ,"blue", "green", "orange"), 
	  xlim=c(0.5,3.5), labs=TRUE, prop=FALSE, 
	  labs.args=list(cex=1.3, col=c("black", "orange", "red", "blue")))

  # just the values
    parts(slc, va, prop=TRUE,plot=FALSE)
	
# real example
  # the proportion of coral occurrences through time in terms of bathymetry
  data(corals)
  data(stages)

  # time scale plot
  tsplot(stages, shading="series", boxes="sys", xlim=c(250,0), 
    ylab="proportion of occurrences", ylim=c(0,1))
  
  # plot of proportions	
  cols &lt;- c("#55555588","#88888888", "#BBBBBB88")
  types &lt;- c("uk", "shal", "deep")
  
  parts(x=stages$mid[corals$stg], b=corals$bath, 
   ord=types, col=cols, prop=TRUE,border=NA, labs=FALSE)
   
  # legend
  legend("left", inset=c(0.1,0), legend=c("unknown", "shallow", "deep"), fill=cols, 
    bg="white", cex=1.4) 

</code></pre>

<hr>
<h2 id='ranges'>Plotting ranges and occurrence distributions through time</h2><span id='topic+ranges'></span>

<h3>Description</h3>

<p>Visualization of occurrence data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranges(
  dat,
  bin = NULL,
  tax = NULL,
  xlim = NULL,
  ylim = c(0, 1),
  total = "",
  filt = "include",
  occs = FALSE,
  labs = FALSE,
  decreasing = TRUE,
  group = NULL,
  gap = 0,
  labels.args = NULL,
  ranges.args = NULL,
  occs.args = NULL,
  total.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranges_+3A_dat">dat</code></td>
<td>
<p><code>(data.frame)</code>: The occurrence dataset or the FAD-LAD dataset that is to be plotted. The FAD dataset must have numeric variables named <code>"FAD"</code> and <code>"LAD"</code>. Taxon ranges will be searched for in the <code>row.names</code> attribute of the table.</p>
</td></tr>
<tr><td><code id="ranges_+3A_bin">bin</code></td>
<td>
<p>(<code>character</code>): The column(s) containing the entries of the time dimension. Use one column name if you have one estimate for the occurrences and use two if you have a minimum and a maximum estimate. Reveresed axis (ages) are supported too.</p>
</td></tr>
<tr><td><code id="ranges_+3A_tax">tax</code></td>
<td>
<p>(<code>character</code>): The column containing the taxon entries.</p>
</td></tr>
<tr><td><code id="ranges_+3A_xlim">xlim</code></td>
<td>
<p>(<code>numeric</code>) :This argument is used for the subsetting of the taxa. Only those taxa are shown that have ranges within the interval (but ranges are displayed outside of it, if you do not want to plot anything within an interval, use the <code>clip</code> function)</p>
</td></tr>
<tr><td><code id="ranges_+3A_ylim">ylim</code></td>
<td>
<p>(<code>numeric</code>): Ranges will be distributed equally between the assigned ylim values. If set to NULL, than it will be based on the plotting area of the open device.</p>
</td></tr>
<tr><td><code id="ranges_+3A_total">total</code></td>
<td>
<p>(<code>character</code>): The name of the range group to be plotted. When multiple groups are used (see <code>group</code> argument), this is set by the <code>character</code> values in the column.</p>
</td></tr>
<tr><td><code id="ranges_+3A_filt">filt</code></td>
<td>
<p>(<code>character</code>): When xlim filters the taxa, how should they be filtered. <code>"include"</code> (default) will show all ranges that have parts within the <code>xlim</code> interval. <code>"orig"</code> will show only those taxa that originate within the interval.</p>
</td></tr>
<tr><td><code id="ranges_+3A_occs">occs</code></td>
<td>
<p>(<code>logical</code>): Should the occurrence data be plotted? If you entered two bin column names, than occurrences will be plotted with the ranges of the estimates (segments).</p>
</td></tr>
<tr><td><code id="ranges_+3A_labs">labs</code></td>
<td>
<p>(<code>character</code>): Should the taxon labels be plotted?</p>
</td></tr>
<tr><td><code id="ranges_+3A_decreasing">decreasing</code></td>
<td>
<p>(<code>logical</code>): This parameter sets whether the series of ranges should start from the top <code>decreasing=TRUE</code> or bottom of the plot <code>decreasing=FALSE</code>.</p>
</td></tr>
<tr><td><code id="ranges_+3A_group">group</code></td>
<td>
<p>(<code>character</code>): By default, all ranges in the plot are treated as parts of the same group. However, one subsetting variable can be named, by which the ranges will be grouped. This has to be a column name in the dataset (see examples).</p>
</td></tr>
<tr><td><code id="ranges_+3A_gap">gap</code></td>
<td>
<p>(<code>numeric</code>): Evaluated only when the <code>group</code> argument points to a valid column. The amount of space between the group-specific range charts, expressed as the proportion of the entire plotting area.</p>
</td></tr>
<tr><td><code id="ranges_+3A_labels.args">labels.args</code></td>
<td>
<p>(<code>list</code>): Arguments that will be passed to the <code><a href="graphics.html#topic+text">text</a></code> function that draws the labels of taxa. If valid grouping is present (see argument <code>group</code>), then vector entries will be distributed across the groups (see examples.)</p>
</td></tr>
<tr><td><code id="ranges_+3A_ranges.args">ranges.args</code></td>
<td>
<p>(<code>list</code>): Arguments that will be passed to the <code><a href="graphics.html#topic+segments">segments</a></code> function that draws ranges. If valid grouping is present (see argument <code>group</code>), then vector entries will be distributed across the groups (see examples.)</p>
</td></tr>
<tr><td><code id="ranges_+3A_occs.args">occs.args</code></td>
<td>
<p>(<code>list</code>): Arguments that will be passed to the <code><a href="graphics.html#topic+points">points</a></code> or <code><a href="graphics.html#topic+segments">segments</a></code> functions that draw the occurence points/lines. If you provided two <code>bin</code> columns, occurrence lines will be drawn instead of points. If valid grouping is present (see argument <code>group</code>), then vector entries will be distributed across the groups (see examples.)</p>
</td></tr>
<tr><td><code id="ranges_+3A_total.args">total.args</code></td>
<td>
<p>(<code>list</code>): Arguments that will be passed to the <code><a href="graphics.html#topic+text">text</a></code> function that draws the <code>total</code> label. If valid grouping is present (see argument <code>group</code>), then vector entries will be distributed across the groups (see examples.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will draw a visual representation of the occurrence dataset. The interpolated ranges will be drawn, as well as the occurrence points.
</p>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # import
 data(stages)
 data(corals)
 
 # all ranges - using the age uncertainties of the occurrences
 tsplot(stages, boxes="sys", xlim=c(250,0))
 ranges(corals, bin=c("max_ma", "min_ma"), tax="genus", occs=FALSE)

 # or use single estimates: assign age esimates to the occurrences
 corals$est&lt;-stages$mid[corals$stg]
 
 # all ranges (including the recent!!)
 tsplot(stages, boxes="sys", xlim=c(250,0))
 ranges(corals, bin="est", tax="genus", occs=FALSE)
 
 # closing on the Cretaceous, with occurrences
 tsplot(stages, boxes="series", xlim=c(145,65), shading="short")
 ranges(corals, bin="est", tax="genus", occs=TRUE, ranges.args=list(lwd=0.1))
 
 # z and az separately
 tsplot(stages, boxes="series", xlim=c(145,65), shading="short")
 ranges(corals, bin="est", tax="genus", occs=FALSE, group="ecology", 
   ranges.args=list(lwd=0.1))
 	
 # same, show only taxa that originate within the interval
 tsplot(stages, boxes="series", xlim=c(105,60), shading="short")
 ranges(corals, bin="est", tax="genus", occs=TRUE, group="ecology", filt="orig" ,
   labs=TRUE, labels.args=list(cex=0.5))
 
# same using the age uncertainties of the occurrence age estimates
tsplot(stages, boxes="series", xlim=c(105,60), shading="short")
ranges(corals, bin=c("max_ma", "min_ma"), tax="genus", occs=TRUE, group="ecology", filt="orig" , 
   labs=TRUE, labels.args=list(cex=0.5))
   
# fully customized/ annotated
tsplot(stages, boxes="series", xlim=c(105,60), shading="short")
ranges(
  corals, # dataset
  bin="est", # bin column
  tax="genus", # taxon column
  occs=TRUE, # occurrence points will be plotted
  group="growth", # separate ranges based on growth types
  filt="orig" , # show only taxa that originate in the interval
  ranges.args=list(
    lwd=1, # set range width to 1
	   col=c("darkgreen", "darkred") # set color of the ranges (by groups)
  ), 
  total.args=list(
    cex=2, # set the size of the group identifier lablels
    col=c("darkgreen", "darkred") # set the color of the group identifier labels
  ),
  occs.args=list(
   col=c("darkgreen", "darkred"),
   pch=3
 ),
  labs=TRUE, # taxon labels will be plotted
  labels.args=list(
    cex=0.4, # the sizes of the taxon labels
	col=c("darkgreen", "darkred") # set the color of the taxon labels by group
  )
) 
   

</code></pre>

<hr>
<h2 id='ratesplit'>Test of rate split (selectivity)</h2><span id='topic+ratesplit'></span>

<h3>Description</h3>

<p>This function will determine whether there are meaningful differences between the taxonomic rates in the individual time bins of two subsets of an occurrence database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratesplit(
  x,
  sel,
  tax = "genus",
  bin = "stg",
  rate = "pc",
  method = "AIC",
  AICc = TRUE,
  na.rm = TRUE,
  alpha = NULL,
  output = "simple"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratesplit_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code>: The fossil occurrence data.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_sel">sel</code></td>
<td>
<p><code>(character)</code>: Variable name to do the splitting of the dataset. Can have only two levels.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code>: Variable name of the occurring taxa (variable type: <code>factor</code> or <code>character</code>).</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code>: Variable name of the bin numbers of the particular occurrences (<code>numeric</code>). Bin numbers should be in ascending order,can contain <code>NA</code>s, it can start from a number other than 1 and must not start with 0.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_rate">rate</code></td>
<td>
<p><code>(character)</code>: The rate metric. Currently only the per capita rates of Foote (1999) are available (<code>rate="pc"</code>).</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_method">method</code></td>
<td>
<p><code>(character)</code>: Either <code>"AIC"</code>, <code>"binom"</code> or <code>"combine"</code>. The <code>"AIC"</code> method calculates the Akaike weights of the single and dual rate models. The <code>"binom"</code> method assumes a binomial error distribution of the counts that are necessary for the rate calculations. The <code>"combine"</code> method shows slices that pass both tests, the <code>"AIC"</code> being usually the stronger.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_aicc">AICc</code></td>
<td>
<p><code>(logical)</code>: Only applicable for the <code>"AIC"</code> method. Toggles whether the small sample corrected AIC (AICc) should be used instead of the regular one.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_na.rm">na.rm</code></td>
<td>
<p><code>(logical)</code>: Argument indicating whether the function should proceede when <code>NA</code>s are found in the <code>sel</code> column. Setting this argument to <code>TRUE</code> will proceede with the omission of these entries, while <code>FALSE</code> will coerce the function to output a single <code>NA</code> value.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_alpha">alpha</code></td>
<td>
<p><code>(numeric)</code>: Threshold to discriminate between meaningful and meaningless split. If <code>method="AIC"</code>, the value corresponds to the minimum weight value the dual model should have. By default it is <code>0.89</code>, which corresponds to the likelihood ratio of 8. If <code>method="binom"</code>, the value corresponds to the alpha value of the binomial test (default: 0.05). If <code>method="combine"</code> than two alpha values are required (1st for the AIC, 2nd for the binomial test). If alpha is <code>NULL</code>, than the default values will be used.</p>
</td></tr>
<tr><td><code id="ratesplit_+3A_output">output</code></td>
<td>
<p><code>(character)</code>: Either <code>"simple"</code> or <code>"full"</code>. <code>"simple"</code> returns the indices of the series where selectivity can be suggested. <code>"full"</code> returns a <code>matrix</code> of Akaike weights, or binomial probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Splitting an occurrence database to its subsets secreases the amount of information passed to the rate calculations and therefore the precision of the individual estimates. Therefore, our ability to tell apart two similar values decreases with the number of sampled taxa. In order to assess the subsets individually and compare them, it is advised to test whether the split into two subsets is meaningful, given the total data. Examples of this use can be found in Kiessling and Simpson (2011) and Kiessling and Kocsis (2015).
The meaningfulness of the split is dependent on the estimate accurracy and the magnitude of the difference. Two different methods are implemented: <code>binom</code> and <code>combine</code>.
</p>
<p><strong>References</strong>
</p>
<p>Foote, M. (1999) Morphological Diversity In The Evolutionary Radiation Of Paleozoic and Post-Paleozoic Crinoids. Paleobiology 25, 1–115. doi:10.1017/S0094837300020236.
</p>
<p>Kiessling, W., &amp; Simpson, C. (2011). On the potential for ocean acidification to be a general cause of ancient reef crises. Global Change Biology, 17(1), 56-67.
</p>
<p>Kiessling, W., &amp; Kocsis, A. T. (2015). Biodiversity dynamics and environmental occupancy of fossil azooxanthellate and zooxanthellate scleractinian corals. Paleobiology, 41(3), 402-414.
</p>


<h3>Value</h3>

<p>A list of two numeric vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example with the coral dataset of Kiessling and Kocsis (2015)
data(corals)
data(stages)

# split by ecology
  z&lt;-corals[corals$ecology=="z",]
  az&lt;-corals[corals$ecology=="az",]

# calculate diversity dynamics
ddZ&lt;-divDyn(z, tax="genus", bin="stg")
ddAZ&lt;-divDyn(az, tax="genus", bin="stg")

# origination rate plot
tsplot(stages, boxes="sys", shading="series", xlim=54:95, 
  ylab="raw per capita originations")
lines(stages$mid, ddZ$oriPC, lwd=2, lty=1, col="blue")
lines(stages$mid, ddAZ$oriPC, lwd=2, lty=2, col="red")
legend("topright", inset=c(0.1,0.1), legend=c("z", "az"), 
  lwd=2, lty=c(1,2), col=c("blue", "red"), bg="white")

# The ratesplit function
rs&lt;-ratesplit(rbind(z, az), sel="ecology", tax="genus", bin="stg")
rs

# display selectivity with points
# select the higher rates
selIntervals&lt;-cbind(ddZ$oriPC[rs$ori], ddAZ$oriPC[rs$ori])
groupSelector&lt;-apply(selIntervals, 1, function(w) w[1]&lt;w[2])
# draw the points
points(stages$mid[rs$ori[groupSelector]], ddAZ$oriPC[rs$ori[groupSelector]],
  pch=16, col="red", cex=2)
points(stages$mid[rs$ori[!groupSelector]], ddZ$oriPC[rs$ori[!groupSelector]],
  pch=16, col="blue", cex=2)


</code></pre>

<hr>
<h2 id='repmatch'>Replicate matching and merging</h2><span id='topic+repmatch'></span>

<h3>Description</h3>

<p>This pseudo-generic function iterates a function on the subelements of a list of objects that have the same class and matching dimensions/names and reorganizes the result to match the structure of the replicates or a prototype template.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repmatch(x, FUN = NULL, proto = NULL, direct = c("dim", "name"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repmatch_+3A_x">x</code></td>
<td>
<p>(<code>list</code>): A <code>list</code> of replicates.</p>
</td></tr>
<tr><td><code id="repmatch_+3A_fun">FUN</code></td>
<td>
<p>(<code>function</code>): A function to merge with and to be applied to the values of identical positions in different replicates. This function must have a single output value, <code>vectors</code> are not allowed. The default <code>NULL</code> option returns an element-wise reorganization of the data.</p>
</td></tr>
<tr><td><code id="repmatch_+3A_proto">proto</code></td>
<td>
<p>(<code>same as x[[1]]</code>): The prototype for matching/merging. The prototype is used as a check (<code>"dim"</code>) or a template (<code>"name"</code>) during the matching process, depending on the used directive (<code>direct</code> argument).  It is an object with the same class as the replicates, and have the same dimensions and/or overlapping names. If the <code>"name"</code> directive is used and a <code>prototype</code> is provided, the funtion will force the output to have the same structure as the prototype, by omitting unnecessary information and inserting missing values (<code>NAs</code>). The prototype is expected to be an object that has more or equal elements than the replicates, otherwise the call will result in a warning.</p>
</td></tr>
<tr><td><code id="repmatch_+3A_direct">direct</code></td>
<td>
<p>(<code>character</code>): Matching directive(s). Can either be dimension-based (<code>"dim"</code>) and/or name-based (<code>name</code>). Dimension-based directive matches the replicates if they have the same dimesions. The <code>"name"</code> directive requires named input (for <code>matrices</code> and <code>data.frames</code> <code>colnames</code> and <code>rownames</code> attributes). Replicates will be matched if the values have the same names. In case both directives are specified (default), dimension-based directive takes higher priority, if matching is unsuccessful with dimensions, names will be tried after.</p>
</td></tr>
<tr><td><code id="repmatch_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is designed to unify/merge objects that result from the same function applied to different source data (e.g. the results of <code>subsample()</code>). In its current form, the function supports <code>vectors</code> (including one-dimensional <code>tables</code> and <code>arrays</code>), <code>matrix</code> and <code>data.frame</code> objects.
</p>


<h3>Value</h3>

<p>If <code>FUN</code> is a <code>function</code>, the output is <code>vector</code> for <code>vector</code>-like replicates, <code>matrix</code> when <code>x</code> is a <code>list</code> of <code>matrix</code> objects, and <code>data.frame</code>s for <code>data.frame</code> replicates. In case <code>FUN=NULL</code>: if <code>x</code> is a list of <code>vectors</code>, the function will return a <code>matrix</code>; an <code>array</code> is returned, if <code>x</code> is a <code>list</code> of <code>matrix</code> class obejcts; if <code>x</code> is a list of <code>data.frame</code> objects, the function returns a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># basic example
vect &lt;- rnorm(100)
# make 50 replicates
repl &lt;- rep(list(vect), 50)
repmatch(repl, FUN=mean, direct="dim")

# named input
  # two vectors
    # a
    a&lt;- 1:10
    names(a) &lt;- letters[1:length(a)]
    a[c(3,5,8)] &lt;- NA
    a &lt;- a[!is.na(a)]
  
    #b
    b&lt;- 10:1
    names(b) &lt;- letters[length(b):1]
    b[c(1, 3,6, length(b))]&lt;- NA
    b &lt;- b[!is.na(b)]

  # list
  x2 &lt;- rep(c(list(a),list(b)), 3)

# simple match - falling through "dim" to "name" directive
repmatch(x2, FUN=NULL)

# prototyped
prot &lt;- 1:10
names(prot) &lt;-letters[1:10]

repmatch(x2, FUN=mean, proto=prot, na.rm=TRUE)
</code></pre>

<hr>
<h2 id='seqduplicated'>Determination and omission of consecutive duplicates in a vector.</h2><span id='topic+seqduplicated'></span><span id='topic+collapse'></span>

<h3>Description</h3>

<p><code>seqduplicated()</code> The function determines which elements of a vector are duplicates (similarly to <code><a href="base.html#topic+duplicated">duplicated</a></code>) in consecutive rows.
</p>
<p><code>collapse()</code> Omits duplicates similarly to <code><a href="base.html#topic+unique">unique</a></code>, but only in consecutive rows, so the sequence of state changes remains, but without duplicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seqduplicated(x, na.rm = FALSE, na.breaks = TRUE)

collapse(x, na.rm = FALSE, na.breaks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seqduplicated_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>): input object.</p>
</td></tr>
<tr><td><code id="seqduplicated_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>logical</code>): Are <code>NA</code> entries to be treated as duplicates (<code>TRUE</code>) or just like a normal value (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="seqduplicated_+3A_na.breaks">na.breaks</code></td>
<td>
<p>(<code>logical</code>): If <code>na.rm=TRUE</code> and the <code>NA</code> values are surrounded by the same values, should the streak be treated as broken? Running <code>seqduplicated(, na.rm=TRUE)</code> on <code>(2, 1,NA, 1)</code> while setting <code>na.breaks</code> to <code>TRUE</code> will return <code>(FALSE, FALSE, TRUE, FALSE)</code>, and with <code>TRUE</code> it will return <code>(FALSE, FALSE, TRUE, TRUE)</code>. The results with the same argumentation of <code>collapse()</code> will be <code>(2,1)</code> and <code>(2,1,1)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are essentially about checking whether a value in a vector at index is the same as the value at the previous index. This seamingly primitive task had to be rewritten with Rcpp for speed and the appropriate handling of <code>NA</code> values.
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  
# example vector
  examp &lt;- c(4,3,3,3,2,2,1,NA,3,3,1,NA,NA,5, NA, 5)

# seqduplicated()
  seqduplicated(examp)

  # contrast with 
  duplicated(examp)

  # with NA removal
  seqduplicated(examp, na.rm=TRUE)
 
# the same with collapse()
  collapse(examp)

  # contrast with 
  unique(examp)

  # with NA removal
  collapse(examp, na.rm=TRUE)

  # with NA removal, no breaking
  collapse(examp, na.rm=TRUE, na.breaks=FALSE)


</code></pre>

<hr>
<h2 id='shades'>Quantile plot of time series</h2><span id='topic+shades'></span>

<h3>Description</h3>

<p>This intermediate-level function will plot a time series with the quantiles shown with transparency values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shades(
  x,
  y,
  col = "black",
  res = 10,
  border = NA,
  interpolate = FALSE,
  method = "symmetric",
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shades_+3A_x">x</code></td>
<td>
<p><code>(numeric)</code>: The x coordinates.</p>
</td></tr>
<tr><td><code id="shades_+3A_y">y</code></td>
<td>
<p><code>(numeric matrix)</code>: The series of distributions to be plotted. Every row represents a distribution of values. The number of rows must equal to the length of <code>x</code>.</p>
</td></tr>
<tr><td><code id="shades_+3A_col">col</code></td>
<td>
<p><code>(character)</code>: The color of the quantiles, currently just a single color is allowed.</p>
</td></tr>
<tr><td><code id="shades_+3A_res">res</code></td>
<td>
<p><code>(numeric)</code>: If a single value is entered, than this argument represents the number of quantiles to be shown (coerced to 150, if higher is entered). If it is vector of values, it will be interpreted as the vector of quantiles to be shown. If <code>method="symmetric"</code>, only an odd number of quantiles are plotted.</p>
</td></tr>
<tr><td><code id="shades_+3A_border">border</code></td>
<td>
<p><code>(character)</code>: The color of the quantile lines. A single value, by default, no lines are drawn (<code>border=NA</code>).</p>
</td></tr>
<tr><td><code id="shades_+3A_interpolate">interpolate</code></td>
<td>
<p><code>(logical)</code>: In case the symmetric method is chosen, the series of quantile values can be interpolated with a LOESS function.</p>
</td></tr>
<tr><td><code id="shades_+3A_method">method</code></td>
<td>
<p><code>(character)</code>: The default <code>"symmetric"</code> method will plot the mid quantile range with highest opacity and the shades will be more translucent at the tails of the distributions. The <code>"decrease"</code> method will decrease the opacity with higher quantiles, which can make more sense for bottom-bounded distributions (e.g. exponential).</p>
</td></tr>
<tr><td><code id="shades_+3A_na.rm">na.rm</code></td>
<td>
<p><code>(logical)</code>: If set to <code>FALSE</code>, than rows that are missing from the dataset will be plotted as gaps in the shading. If set to <code>TRUE</code>, than these gaps will be skipped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some random values accross the Phanerozoic
data(stages)
tsplot(stages, boxes="sys", shading="series", ylim=c(-5,5), ylab=c("normal distributions"))
  randVar &lt;- t(sapply(1:95, FUN=function(x){rnorm(150, 0,1)}))
  shades(stages$mid, randVar, col="blue", res=10,method="symmetric")
  
# a bottom-bounded distribution (log normal)
tsplot(stages, boxes="sys", shading="series", ylim=c(0,30), ylab="log-normal distributions")
  randVar &lt;- t(sapply(1:95, FUN=function(x){rlnorm(150, 0,1)}))
  shades(stages$mid, randVar, col="blue", res=c(0,0.33, 0.66, 1),method="decrease")	 
</code></pre>

<hr>
<h2 id='singletons'>List of singleton taxa</h2><span id='topic+singletons'></span>

<h3>Description</h3>

<p>The function returns lists of taxa that occurr with only one particular entry in a given variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singletons(
  dat,
  tax = "clgen",
  var = NULL,
  bin = NULL,
  bybin = FALSE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singletons_+3A_dat">dat</code></td>
<td>
<p>(<code>data.frame</code>): Occurrence dataset, with <code>bin</code>, <code>tax</code> and <code>coll</code> as column names.</p>
</td></tr>
<tr><td><code id="singletons_+3A_tax">tax</code></td>
<td>
<p>(<code>character</code>): The name of the taxon variable.</p>
</td></tr>
<tr><td><code id="singletons_+3A_var">var</code></td>
<td>
<p>(<code>character</code>): The variable that is used to define singletons. Use the reference variable for single-reference taxa, and the collection variable for single-collection taxa, the bin identifier for single-interval taxa and so forth. If you set this to the default <code>NULL</code>, the function will return single-occurrence taxa.</p>
</td></tr>
<tr><td><code id="singletons_+3A_bin">bin</code></td>
<td>
<p>(<code>character</code>): Lists of taxa can be tabulated in every bin. Rows with <code>NA</code> entries in this column will be omitted.</p>
</td></tr>
<tr><td><code id="singletons_+3A_bybin">bybin</code></td>
<td>
<p>(<code>logical</code>): The type of the filtering process. Was it supposed to be applied to bin-specific subsets (<code>TRUE</code>), or the whole data (<code>FALSE</code>)? Setting this argument to <code>TRUE</code> will return a <code>list</code> class object, where every element of the list is a bin-specific <code>character</code> vector. This settig also removes all <code>NA</code> entries form <code>bin</code> variable.</p>
</td></tr>
<tr><td><code id="singletons_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>logical</code>): If <code>var</code> is not <code>NULL</code>, setting this argument to <code>TRUE</code> removes all rows where var is <code>NA</code>. Otherwise these will be returned as singletons.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Singletons are defined in number of ways in the literature. True singletons are species that are represented by only one specimen, but one can talk about
single-occurrence, single-interval, single-reference or single collection taxa as well. These can be returned with this function. 
</p>
<p>As the time bin has particular importance, it is possible to filter singleton taxa in the context of a single bin. These can be returned with the <code>bybin</code> argument, that constrains and iterates the filtering to every bin.
If this argument is set to <code>TRUE</code> and the variable in question is a references, than single-reference taxa will be taxa that occurred in only one reference within each bin - it does not necessarily mean that only one reference describes the taxon in the total database!
</p>


<h3>Value</h3>

<p>A vector of character entries in <code>tax</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
  data(corals)

# Example 1. single-occurrence taxa
  singOcc &lt;- singletons(corals, tax="genus", bin="stg")

# Example 2. output for every bin
  singOccBin &lt;- singletons(corals, tax="genus", bin="stg", bybin=TRUE)

# Example 3. single-interval taxa (all)
  singInt &lt;- singletons(corals, tax="genus", var="stg")

# Example 4. single interval taxa (for every bin)
  singIntBin &lt;- singletons(corals, tax="genus", var="stg", bin="stg", bybin=TRUE)

# Example 5. single reference taxa (total dataset)
  singRef &lt;- singletons(corals, tax="genus", var="reference_no")

#  Example 6. single reference taxa (see description for differences )
  singRefBin &lt;- singletons(corals, tax="genus", var="reference_no", bin="stg", bybin=TRUE)

</code></pre>

<hr>
<h2 id='slice'>Discretization of continuous time dimension - slicing</h2><span id='topic+slice'></span>

<h3>Description</h3>

<p>The function will slices time with a given set of boundaries and produce a time scale object if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice(x, breaks, offset = 0, ts = TRUE, revtime = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_+3A_x">x</code></td>
<td>
<p>(<code>numeric</code>) Vector of continouos age/time estimates.</p>
</td></tr>
<tr><td><code id="slice_+3A_breaks">breaks</code></td>
<td>
<p>(<code>numeric</code>) Vector of boundaries, the breaks argument of the <code><a href="base.html#topic+cut">cut</a></code> function</p>
</td></tr>
<tr><td><code id="slice_+3A_offset">offset</code></td>
<td>
<p>(<code>numeric</code>) Single  value. If desired the resulting integer bin numbers can be offset by some amount.</p>
</td></tr>
<tr><td><code id="slice_+3A_ts">ts</code></td>
<td>
<p>(<code>logical</code>) Should a time scale object be also produced when the function is run?</p>
</td></tr>
<tr><td><code id="slice_+3A_revtime">revtime</code></td>
<td>
<p>(<code>logical</code>) Should the time dimension be reversed? This argument is set to <code>TRUE</code> by default, meaning that the function will reverse the order of time: smaller values of <code>x</code> will be translated to higher values (<code>slc</code>) in the function output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Due to stratigraphic constraints, we can only process deep time data, when it is sliced to discrete bins. It is suggested that you do this separately for most of your analyses. This function is also used by the code<a href="#topic+divDyn">divDyn</a> function when <code>age</code> entries are provided.
</p>


<h3>Value</h3>

<p>Either of new entries and levels or time scale.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>y&lt;- runif(200, 0,100)
au &lt;- slice(y, breaks=seq(0, 100, 10))
withOut &lt;- slice(y, breaks=seq(0, 100, 10), ts=FALSE)
</code></pre>

<hr>
<h2 id='stages'>95 bin Phanerozoic time scale based on the stratigraphic stages of Gradstein et al. 2020.</h2><span id='topic+stages'></span>

<h3>Description</h3>

<p>Stage-level (age-level) timescale used in some analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stages)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 95 observations and 10 variables:
</p>

<dl>
<dt><code>sys</code></dt><dd><p>Abbreviations of geologic systems.</p>
</dd>
<dt><code>system</code></dt><dd><p>Geologic periods.</p>
</dd>
<dt><code>series</code></dt><dd><p>Geologic series.</p>
</dd>
<dt><code>stage</code></dt><dd><p>Names of geologic stages.</p>
</dd>
<dt><code>short</code></dt><dd><p>Abbreviations of geologic stages.</p>
</dd>
<dt><code>bottom</code></dt><dd><p>Numeric ages of the bottoms boundaries (earliest ages) of the bins.</p>
</dd>
<dt><code>mid</code></dt><dd><p>Numeric age midpoints of the bins, the averages of <code>bottom</code> and <code>top</code>.</p>
</dd>
<dt><code>top</code></dt><dd><p>Numeric ages of the tops (latest ages) of the bins.</p>
</dd>
<dt><code>dur</code></dt><dd><p>Numeric ages of the durations for the bins.</p>
</dd>
<dt><code>stg</code></dt><dd><p>Integer number identifiers of the bins.</p>
</dd>
<dt><code>systemCol</code></dt><dd><p>Hexadecimal color code of the systems.</p>
</dd>
<dt><code>seriesCol</code></dt><dd><p>Hexadecimal color code of the series.</p>
</dd>
<dt><code>col</code></dt><dd><p>Hexadecimal color code of the stages.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an example time scale object that can be used in the Phanerozoic-scale analyses. Example occurrence datasets related to the package use the variable <code>stg</code> when referring to this timescale. This version uses the longer Rhaetian option.
</p>


<h3>References</h3>

<p>Gradstein, F. M., Ogg, J. G., &amp; Schmitz, M. D. (2020). The geologic time scale 2020. Elsevier.
</p>


<h3>Source</h3>

<p>Based on Gradstein et al. (2020).
</p>

<hr>
<h2 id='stages2018'>95 bin Phanerozoic time scale based on the stratigraphic stages of Ogg et al. (2016) with updated dates in some intervals (2018).</h2><span id='topic+stages2018'></span>

<h3>Description</h3>

<p>Stage-level (age-level) timescale used in some analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stages2018)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 95 observations and 10 variables:
</p>

<dl>
<dt><code>sys</code></dt><dd><p>Abbreviations of geologic systems.</p>
</dd>
<dt><code>system</code></dt><dd><p>Geologic periods.</p>
</dd>
<dt><code>series</code></dt><dd><p>Geologic series.</p>
</dd>
<dt><code>stage</code></dt><dd><p>Names of geologic stages.</p>
</dd>
<dt><code>short</code></dt><dd><p>Abbreviations of geologic stages.</p>
</dd>
<dt><code>bottom</code></dt><dd><p>Numeric ages of the bottoms boundaries (earliest ages) of the bins.</p>
</dd>
<dt><code>mid</code></dt><dd><p>Numeric age midpoints of the bins, the averages of <code>bottom</code> and <code>top</code>.</p>
</dd>
<dt><code>top</code></dt><dd><p>Numeric ages of the tops (latest ages) of the bins.</p>
</dd>
<dt><code>dur</code></dt><dd><p>Numeric ages of the durations for the bins.</p>
</dd>
<dt><code>stg</code></dt><dd><p>Integer number identifiers of the bins.</p>
</dd>
<dt><code>systemCol</code></dt><dd><p>Hexadecimal color code of the systems.</p>
</dd>
<dt><code>seriesCol</code></dt><dd><p>Hexadecimal color code of the series.</p>
</dd>
<dt><code>col</code></dt><dd><p>Hexadecimal color code of the stages.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an example time scale object that can be used in the Phanerozoic-scale analyses. Example occurrence datasets related to the package use the variable <code>stg</code> when referring to this timescale.
This is the <code>stages</code> object used until divDyn version 0.8.1.
</p>


<h3>References</h3>

<p>Ogg, J. G., G. Ogg, and F. M. Gradstein. 2016. A concise geologic time scale: 2016. Elsevier.
</p>


<h3>Source</h3>

<p>Based on Ogg et al. (2016), compiled by Wolfgang Kiessling.
</p>

<hr>
<h2 id='stratkeys'>The FossilWorks-based lookup table for the stratigraphic assignments of collections in the Paleobiology Database</h2><span id='topic+stratkeys'></span>

<h3>Description</h3>

<p>Table including the user-chosen interval data and the stratigraphic units of the dynamic timescale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(stratkeys)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 761 observations of 8 variables:
</p>

<dl>
<dt><code>interval</code></dt><dd><p>The names of the registered intervals in the <code>early_interval</code>/<code>max_interval</code> and <code>late_interval</code>/<code>min_interval</code> columns.</p>
</dd>
<dt><code>period</code></dt><dd><p>The period containing the interval.</p>
</dd>
<dt><code>epoch</code></dt><dd><p>The epoch containing the interval.</p>
</dd>
<dt><code>X10_my_bin</code></dt><dd><p>The 10 million year time scale interval containing the interval.</p>
</dd>
<dt><code>ten</code></dt><dd><p>Numeric identifier of the 10 million year interval in the <code><a href="#topic+tens">tens</a></code> object.</p>
</dd>
<dt><code>stage</code></dt><dd><p>The stage containing the interval.</p>
</dd>	
<dt><code>stg</code></dt><dd><p>Numeric identifier of the interval in the stage-level time scale provided as <code><a href="#topic+stages">stages</a></code> object.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Since the separation of the FossilWorks (<a href="http://www.fossilworks.org/">http://www.fossilworks.org/</a>) portal from the Paleobiology Database (<a href="https://paleobiodb.org/">https://paleobiodb.org/</a>) the access to the stratigraphic information in the database have been problematic. This table includes groupings of 
<code>early_interval</code>/<code>max_interval</code> entries of the dynamic timescale that users can choose during collection entry. The table assigns these intervals to some corresponding stratigraphic units from different time scales.
These entries were distilled from those collections that only have a <code>max_interval</code> value. As there is a mismatch between the data Paleobiology Database and FossilWorks this list is not comprehensive and a couple entries are probably missing. For this reason, this dataset is expected to be updated in the future. 
</p>
<p>This particular version (v0.9.2) is based on a download of all collections in FossilWorks between the Ediacaran and the Holocene. The download took place on 22 June, 2018. The entries were transformed to <code><a href="#topic+keys">keys</a></code> to be used with the <code><a href="#topic+categorize">categorize</a></code> function. Some entries were corrected manually.
</p>


<h3>Source</h3>

<p><a href="http://www.fossilworks.org/">http://www.fossilworks.org/</a>
</p>

<hr>
<h2 id='streaklog'>Utility functions for slicing gappy time series</h2><span id='topic+streaklog'></span><span id='topic+whichmaxstreak'></span>

<h3>Description</h3>

<p>The function returns where the continuous streaks start and how long they are, which can be used for efficient and flexible subsetting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streaklog(x)

whichmaxstreak(x, which = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="streaklog_+3A_x">x</code></td>
<td>
<p>(<code>vector</code>) A vector with missing values.</p>
</td></tr>
<tr><td><code id="streaklog_+3A_which">which</code></td>
<td>
<p><code>(integer)</code> In case multiple streaks of the same length are found, which of them should be returned by the vector (integer).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output list of <code>streaklog</code> contains the following elements:
</p>
<p><code>starts</code>: the indices where the streaks start.
</p>
<p><code>streaks</code>: the lengths of the individual streaks (number of values).
</p>
<p><code>runs</code>: the number of streaks.
</p>
<p>The function whichmaxstreak() will return the indices of those values that are in the longest continuous streak.
</p>


<h3>Value</h3>

<p>A list (streaklog) or a numeric vector (whichmaxstreak).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a sequence of values
  b&lt;-40:1
# add some gaps
  b[c(1:4, 15, 19, 23:27)]  &lt;- NA
# the functions
  streaklog(b)
  whichmaxstreak(b)
</code></pre>

<hr>
<h2 id='subsample'>Subsampling wrapper function</h2><span id='topic+subsample'></span>

<h3>Description</h3>

<p>The function will take a function that has an occurrence dataset as an argument, and reruns it iteratively on the subsets of the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsample(
  x,
  q,
  tax = NULL,
  bin = NULL,
  FUN = divDyn,
  coll = NULL,
  iter = 50,
  type = "cr",
  keep = NULL,
  rem = NULL,
  duplicates = TRUE,
  output = "arit",
  useFailed = FALSE,
  FUN.args = NULL,
  na.rm = FALSE,
  counter = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsample_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>): Occurrence dataset, with <code>bin</code>, <code>tax</code> and <code>coll</code> as column names.</p>
</td></tr>
<tr><td><code id="subsample_+3A_q">q</code></td>
<td>
<p>(<code>numeric)</code>: Subsampling level argument (mandatory). Depends on the subsampling function, it is the number of occurrences for <code>"cr"</code>, and the number of desired occurrences to the power of <code>xexp</code> for O^x^W. It is also the quorum of the SQS method.</p>
</td></tr>
<tr><td><code id="subsample_+3A_tax">tax</code></td>
<td>
<p>(<code>character</code>): The name of the taxon variable.</p>
</td></tr>
<tr><td><code id="subsample_+3A_bin">bin</code></td>
<td>
<p>(<code>character</code>): The name of the subsetting variable (has to be integer). For time series, this is the time-slice variable. Rows with <code>NA</code> entries in this column will be omitted.</p>
</td></tr>
<tr><td><code id="subsample_+3A_fun">FUN</code></td>
<td>
<p>(<code>function</code>): The function to be iteratively executed on the results of the subsampling trials. If set to <code>NULL</code>, no function will be executed, and the subsampled datasets will be returned as a <code>list</code>. By default set to the <code><a href="#topic+divDyn">divDyn</a></code> function. The function must have an argument called <code>x</code>, that represents the dataset resulting from a subsampling trial (or the entire dataset). Arguments of the <code>subsample</code> function call will be searched for potential arguments of this function, which means that already provided variables (e.g. <code>bin</code> and <code>tax</code>) will also be used. You can also provide additional arguments (similarly to the <code><a href="base.html#topic+apply">apply</a></code> iterator). Functions that allow arguments to pass through (that have argument '...') are not allowed, as well as functions that have the same arguments as <code>subsample</code> but would require different values.</p>
</td></tr>
<tr><td><code id="subsample_+3A_coll">coll</code></td>
<td>
<p>(<code>character</code>): The variable name of the collection identifiers.</p>
</td></tr>
<tr><td><code id="subsample_+3A_iter">iter</code></td>
<td>
<p>(<code>numeric</code>): The number of iterations to be executed.</p>
</td></tr>
<tr><td><code id="subsample_+3A_type">type</code></td>
<td>
<p>(<code>character</code>): The type of subsampling to be implemented. By default this is classical rarefaction (<code>"cr"</code>). (<code>"oxw"</code>) stands for occurrence weighted by-list subsampling. If set to (<code>"sqs"</code>), the program will execute the shareholder quorum subsampling algorithm as it was suggested by Alroy (2010). Setting the argument to <code>"none"</code> will invoke no subsamling, but the applied function will be iterated on the trials, nevertheless.</p>
</td></tr>
<tr><td><code id="subsample_+3A_keep">keep</code></td>
<td>
<p>(<code>numeric</code>): The bins, which will not be subsampled but will be added to the subsampling trials. NIf the number of occurrences does not reach the subsampling quota, by default it will not be represented in the subsampling trials. You can force their inclusion with the <code>keep</code> argument separetely (for all, see the <code>useFailed</code> argument).</p>
</td></tr>
<tr><td><code id="subsample_+3A_rem">rem</code></td>
<td>
<p>(<code>numeric</code>): The bins, which will be removed from the dataset before the subsampling trials.</p>
</td></tr>
<tr><td><code id="subsample_+3A_duplicates">duplicates</code></td>
<td>
<p>(<code>logical</code> ): Toggles whether multiple entries from the same taxon (<code>"tax"</code>) and collection (<code>"coll"</code>) variables should be omitted. Useful for omitting occurrences of multiple species-level occurrences of the same genus. By default these are allowed through analyses (<code>duplicates=TRUE</code>), setting this to <code>FALSE</code> will require you to provide a collection variable. (<code>coll</code>)</p>
</td></tr>
<tr><td><code id="subsample_+3A_output">output</code></td>
<td>
<p>(<code>character</code>): If the function output are vectors or matrices, the <code>"arit"</code> and <code>"geom"</code> values will trigger simple averaging with arithmetic or geometric means. If the function output of a single trial is again a <code>vector</code> or a <code>matrix</code>, setting the output to <code>"dist"</code> will return the calculated results of every trial, organized in a <code>list</code> of independent variables (e.g. if the function output is value, the return will contain a single <code>vector</code>, if it is a <code>vector</code>, the output will be a list of <code>vector</code>s, if the function output is a <code>data.frame</code>, the output will be a <code>list</code> of <code>matrix</code> class objects). If <code>output="list"</code>, the structure of the original function output will be retained, and the results of the individual trials will be concatenated to a <code>list</code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_usefailed">useFailed</code></td>
<td>
<p>(<code>logical</code>): If the bin does not reach the subsampling quota, should the bin be used?</p>
</td></tr>
<tr><td><code id="subsample_+3A_fun.args">FUN.args</code></td>
<td>
<p>(<code>list</code>): Arguments passed to the applied function <code>FUN</code> but not used by the subsampling wrapper. Normally, the arguments of <code>FUN</code> can be added to the call of <code>subsample</code>, but in case you want to use different values for the same argument, then the arguments added here will be used for the call of <code>FUN</code>. For instance, if you want to call <code>subsample</code> with <code>bin=NULL</code>, but want to run <code>FUN=divDyn</code> with a valid <code>bin</code> column then you can add the column name here, e.g. <code>FUN.args=list(bin="stg")</code>.</p>
</td></tr>
<tr><td><code id="subsample_+3A_na.rm">na.rm</code></td>
<td>
<p>(<code>logical</code>): The function call includes more column names that might contain missing values. If this flag is set to <code>TRUE</code>, all rows will be dropped that have missig values in the specificed columns. This might lead to the exclusion of some data you do not want to exclude.</p>
</td></tr>
<tr><td><code id="subsample_+3A_counter">counter</code></td>
<td>
<p>(<code>logical</code>): Should the loop counting be visible?</p>
</td></tr>
<tr><td><code id="subsample_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code> and the type-specific subsampling functions: <code><a href="#topic+subtrialCR">subtrialCR</a></code>, <code><a href="#topic+subtrialOXW">subtrialOXW</a></code>, <code><a href="#topic+subtrialSQS">subtrialSQS</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>subsample</code> function implements the iterative framework of the sampling standardization procedure. 
The function 1. takes the dataset <code>x</code>, 2. runs function <code>FUN</code> on the dataset and creates a container for results of trials
3. runs one of the subsampling trial functions (e.g. <code><a href="#topic+subtrialCR">subtrialCR</a></code>) to get a subsampled 'trial dataset'
4. runs <code>FUN</code> on the trial dataset and
5. averages the results of the trials for a simple output of step 4. such as <code>vector</code>s, <code>matrices</code> and <code>data.frames</code>. For averaging, the <code>vectors</code> and <code>matrices</code> have to have the same output dimensions in the subsampling, as in the original object. For <code>data.frames</code>, the bin-specific information have to be in rows and the <code>bin</code> numbers have to be given in a variable <code>bin</code> in the output of <code>FUN</code>.
For a detailed treatment on what the function does, please see the vignette ('Handout to the R package 'divDyn' v0.5.0 for diversity dynamics from fossil occurrence data'). Currently the Classical Rarefaction (<code>"cr"</code>, Raup, 1975), the occurrence weighted by-list subsampling (<code>"oxw"</code>, Alroy et al., 2001) and the Shareholder Quorum Subsampling methods are implemented (<code>"sqs"</code>, Alroy, 2010).
</p>
<p><strong>References:</strong>
</p>
<p>Alroy, J., Marshall, C. R., Bambach, R. K., Bezusko, K., Foote, M., Fürsich, F. T., … Webber, A. (2001). Effects of sampling standardization on estimates of Phanerozoic marine diversification. Proceedings of the National Academy of Science, 98(11), 6261-6266.
</p>
<p>Alroy, J. (2010). The Shifting Balance of Diversity Among Major Marine Animal Groups. Science, 329, 1191-1194. https://doi.org/10.1126/science.1189910
</p>
<p>Raup, D. M. (1975). Taxonomic Diversity Estimation Using Rarefaction. Paleobiology, 1, 333-342. https: //doi.org/10.2307/2400135
</p>


<h3>Value</h3>

<p>Either a list of replicates or an object matching the class of <code>FUN</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(corals)
data(stages)
# Example 1-calculate metrics of diversity dynamics
  dd &lt;- divDyn(corals, tax="genus", bin="stg")
  rarefDD&lt;-subsample(corals,iter=30, q=50,
  tax="genus", bin="stg", output="dist", keep=95)
	
# plotting
  tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
  ylab="range-through diversity (genera)", ylim=c(0,230))
  lines(stages$mid, dd$divRT, lwd=2)
  shades(stages$mid, rarefDD$divRT, col="blue")
  legend("topleft", legend=c("raw","rarefaction"),
    col=c("black", "blue"), lwd=c(2,2), bg="white")
  

# Example 2-SIB diversity 
# draft a simple function to calculate SIB diversity
sib&lt;-function(x, bin, tax){
  calc&lt;-tapply(INDEX=x[,bin], X=x[,tax], function(y){
    length(levels(factor(y)))
  })
  return(calc[as.character(stages$stg)])
}
sibDiv&lt;-sib(corals, bin="stg", tax="genus")

# calculate it with subsampling
rarefSIB&lt;-subsample(corals,iter=25, q=50,
  tax="genus", bin="stg", output="arit", keep=95, FUN=sib)
rarefDD&lt;-subsample(corals,iter=25, q=50,
  tax="genus", bin="stg", output="arit", keep=95)

# plot
tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
  ylab="SIB diversity (genera)", ylim=c(0,230))

lines(stages$mid, rarefDD$divSIB, lwd=2, col="black")
lines(stages$mid, rarefSIB, lwd=2, col="blue")


# Example 3 - different subsampling types with default function (divDyn)
# compare different subsampling types
  # classical rarefaction
  cr&lt;-subsample(corals,iter=25, q=20,tax="genus", bin="stg", output="dist", keep=95)
  # by-list subsampling (unweighted) - 3 collections
  UW&lt;-subsample(corals,iter=25, q=3,tax="genus", bin="stg", coll="collection_no", 
    output="dist", keep=95, type="oxw", xexp=0)
  # occurrence weighted by list subsampling
  OW&lt;-subsample(corals,iter=25, q=20,tax="genus", bin="stg", coll="collection_no", 
    output="dist", keep=95, type="oxw", xexp=1)
 
  SQS&lt;-subsample(corals,iter=25, q=0.4,tax="genus", bin="stg", output="dist", keep=95, type="sqs")

# plot
  tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
  ylab="range-through diversity (genera)", ylim=c(0,100))
  shades(stages$mid, cr$divRT, col="red")
  shades(stages$mid, UW$divRT, col="blue")
  shades(stages$mid, OW$divRT, col="green")
  shades(stages$mid, SQS$divRT, col="cyan")
  
  legend("topleft", bg="white", legend=c("CR (20)", "UW (3)", "OW (20)", "SQS (0.4)"), 
    col=c("red", "blue", "green", "cyan"), lty=c(1,1,1,1), lwd=c(2,2,2,2))


</code></pre>

<hr>
<h2 id='subtrialCR'>Subsampling trial functions</h2><span id='topic+subtrialCR'></span><span id='topic+subtrialOXW'></span><span id='topic+subtrialSQS'></span>

<h3>Description</h3>

<p>These functions create one subsampling trial dataset with a desired subsampling method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subtrialCR(
  x,
  q,
  bin = NULL,
  unit = NULL,
  keep = NULL,
  useFailed = FALSE,
  showFailed = FALSE
)

subtrialOXW(
  x,
  q,
  bin = NULL,
  coll = NULL,
  xexp = 1,
  keep = NULL,
  useFailed = FALSE,
  showFailed = FALSE
)

subtrialSQS(
  x,
  tax,
  q,
  bin = NULL,
  coll = NULL,
  ref = NULL,
  singleton = "occ",
  excludeDominant = FALSE,
  largestColl = FALSE,
  fcorr = "good",
  byList = FALSE,
  keep = NULL,
  useFailed = FALSE,
  showFailed = FALSE,
  appr = "under"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subtrialCR_+3A_x">x</code></td>
<td>
<p>(<code>data.frame</code>): Occurrence dataset, with <code>bin</code>, <code>tax</code> and <code>coll</code> as column names.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_q">q</code></td>
<td>
<p>(<code>numeric)</code>: Subsampling level argument (mandatory). Depends on the subsampling function, it is the number of occurrences for <code>"cr"</code>, and the number of desired occurrences to the power of <code>xexp</code> for O^x^W. It is also the quorum of the SQS method.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_bin">bin</code></td>
<td>
<p>(<code>character</code>): The name of the subsetting variable (has to be integer). For time series, this is the time-slice variable. Rows with <code>NA</code> entries in this column will be omitted.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_unit">unit</code></td>
<td>
<p>(<code>character</code>): Argument of the CR subsampling type. The name of the variable that designates the subsampling units. In every bin, CR selects a certain number (quota) of entries from the dataset. By default (<code>unit=NULL</code>), the units will be the rows, and the <code>q</code> number of rows will be selected in each bin.
However, this can be a higher level category that has multiple entries in the each bin. If <code>unit</code> is a valid column of the dataset <code>x</code>, then CR will select <code>q</code> number entries in this variable, and will return all the corresponding rows.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_keep">keep</code></td>
<td>
<p>(<code>numeric</code>): The bins, which will not be subsampled but will be added to the subsampling trials. NIf the number of occurrences does not reach the subsampling quota, by default it will not be represented in the subsampling trials. You can force their inclusion with the <code>keep</code> argument separetely (for all, see the <code>useFailed</code> argument). Only applicable when <code>bin!=NULL</code>.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_usefailed">useFailed</code></td>
<td>
<p>(<code>logical</code>): If the bin does not reach the subsampling quota, should the bin be used? If <code>bin!=NULL</code> and <code>useFailed=TRUE</code> then only <code>TRUE</code> values will be output (indicating the use of the full dataset).</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_showfailed">showFailed</code></td>
<td>
<p>(<code>logical</code>): Toggles the output of the function. If set to <code>TRUE</code> the output will be a list, including both the default output (logical vector of rows) and the <code>numeric</code> vector of bins that did not have enough entries to reach the quota <code>q</code>. Only applicable when <code>bin!=NULL</code>.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_coll">coll</code></td>
<td>
<p>(<code>character</code>): The variable name of the collection identifiers.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_xexp">xexp</code></td>
<td>
<p>(<code>numeric</code>): Argument of the OxW type. The exponent of by-list subsampling, by default it is 1.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_tax">tax</code></td>
<td>
<p>(<code>character</code>): The name of the taxon variable.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_ref">ref</code></td>
<td>
<p>(<code>character</code>): The name of the reference variable, optional - depending on the subsampling method.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_singleton">singleton</code></td>
<td>
<p><code>(character)</code>: A parameter of SQS. Either <code>"ref"</code>, <code>"occ"</code> or <code>FALSE</code>. If set to <code>"occ"</code>, the coverage estimator (e.g. Good's u) will be calculated based on the number of single-occurrence taxa. 
If set to &quot;ref&quot; the number of occurrences belonging to single-reference taxa will be used instead. In case of the inexact algorithm, if set to <code>FALSE</code> then coverage corrections of frequencies will not be applied.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_excludedominant">excludeDominant</code></td>
<td>
<p><code>(logical)</code>: Argument of SQS. This parameter sets whether the dominant taxon should 
be excluded from all calculations involving frequencies (this is the second correction of Alroy, 2010).</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_largestcoll">largestColl</code></td>
<td>
<p><code>(logical)</code>: Parameter of SQS. This parameter sets whether the occurrences of taxa only ever
found in the most diverse collection should be excluded from the count of 
single-publication occurrences. (this is the third correction of Alroy, 2010) Note that <code>largestColl=TRUE</code> is dependent on <code>excludeDominant=TRUE</code>. Setting <code>excludeDominant</code> to <code>FALSE</code> will turn this correction off.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_fcorr">fcorr</code></td>
<td>
<p><code>(character)</code>: Parameter for the inexact method of SQS. either &quot;good&quot; or &quot;alroy&quot;. This argument changes the frequency correction procedure of the 
'inexact' version of SQS (Alroy 2010). As not all taxa are present in the samples, 
the sampled frequencies of taxa tend overestimate their frequencies in the sampling pool. 
In Alroy (2010) these are corrected using Good's u (&quot;good&quot;, default), in the later versions 
of SQS this metric is changed to a different method using single occurrence and double occurrence taxa (&quot;alroy&quot;).</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_bylist">byList</code></td>
<td>
<p>(<code>character</code>): A parameter of the <code>"inexact"</code> method of SQS. Sets whether occurrences should be subsampled with (<code>FALSE</code>) or without (<code>TRUE</code>) breaking the collection integrity.</p>
</td></tr>
<tr><td><code id="subtrialCR_+3A_appr">appr</code></td>
<td>
<p>(<code>character</code>): A parameter of the inexact method of SQS. Either &quot;over&quot; (default) or (&quot;under&quot;). The current 
version is not concerned with small fluctuations around the drawn subsampling quorum. 
Therefore, in the inexact algorithm, sampling is finished when the subset 
either is immediately below the quorum (<code>"under"</code>) or above it (<code>"over"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The essence of these functions are present within the subsampling wrapper function <code><a href="#topic+subsample">subsample</a></code>. Each function implements a certain subsampling type.
The return value of the funcfions by default is a <code>logical</code> vector indicating which rows of the original dataset should be present in the subsample. 
The inexact method for SQS is implemented here as it is computationally less demanding. 
</p>
<p><strong>References:</strong>
</p>
<p>Alroy, J., Marshall, C. R., Bambach, R. K., Bezusko, K., Foote, M., Fürsich, F. T., … Webber, A. (2001). Effects of sampling standardization on estimates of Phanerozoic marine diversification. Proceedings of the National Academy of Science, 98(11), 6261-6266.
</p>
<p>Alroy, J. (2010). The Shifting Balance of Diversity Among Major Marine Animal Groups. Science, 329, 1191-1194. https://doi.org/10.1126/science.1189910
</p>
<p>Raup, D. M. (1975). Taxonomic Diversity Estimation Using Rarefaction. Paleobiology, 1, 333-342. https: //doi.org/10.2307/2400135
</p>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#one classical rarefaction trial
  data(corals)
# return 5 references for each stage
  bRows&lt;-subtrialCR(corals, bin="stg", unit="reference_no", q=5)
  # control
  unCor&lt;-unique(corals[bRows,c("stg", "reference_no")])
  table(unCor$stg)

</code></pre>

<hr>
<h2 id='sumstat'>Occurrence database summary</h2><span id='topic+sumstat'></span>

<h3>Description</h3>

<p>The function calculates global statistics of the entire database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumstat(
  x,
  tax = "genus",
  bin = "stg",
  coll = NULL,
  ref = NULL,
  duplicates = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sumstat_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code>: The occurrence dataset.</p>
</td></tr>
<tr><td><code id="sumstat_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code>: The column name of taxon names.</p>
</td></tr>
<tr><td><code id="sumstat_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code>: The column name of bin names.</p>
</td></tr>
<tr><td><code id="sumstat_+3A_coll">coll</code></td>
<td>
<p><code>(character)</code>: The column name of collection numbers. (optional)</p>
</td></tr>
<tr><td><code id="sumstat_+3A_ref">ref</code></td>
<td>
<p><code>(character)</code>: The column name of reference numbers. (optional)</p>
</td></tr>
<tr><td><code id="sumstat_+3A_duplicates">duplicates</code></td>
<td>
<p><code>(logical)</code>: The function will check whether there are duplicate occurrences (multiple species/genera). When set to <code>NULL</code>, nothing will happen, but the function will notify you if duplicates are present. If set to <code>TRUE</code>, the function will not do anything with these, if set to <code>FALSE</code>, the duplicates will be omitted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns the following values.
</p>
<p><code>bins</code>: The total number of bins sampled. 
</p>
<p><code>occs</code>: The total number of sampled occurrences.
</p>
<p><code>colls</code>: The total number of sampled collections.
</p>
<p><code>refs</code>:  The total number of sampled references.
</p>
<p><code>taxa</code>:  The total number of sampled taxa.
</p>
<p><code>gappiness</code>: The proportion of sampling gaps in the ranges of the taxa (without the range-endpoints).
</p>


<h3>Value</h3>

<p>A named numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)
  sumstat(corals, tax="genus", bin="stg", coll="collection_no", ref="reference_no")
</code></pre>

<hr>
<h2 id='survivors'>Proportions of survivorship</h2><span id='topic+survivors'></span>

<h3>Description</h3>

<p>This function will calculate both forward and backward survivorship proportions from a given occurrence dataset or FAD-LAD matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survivors(
  x,
  tax = "genus",
  bin = "stg",
  method = "forward",
  noNAStart = FALSE,
  fl = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survivors_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> The data frame containing fossil occurrences.</p>
</td></tr>
<tr><td><code id="survivors_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> The variable  name of the occurring taxa (variable type: <code>factor</code> or <code>character</code>).</p>
</td></tr>
<tr><td><code id="survivors_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> The variable name of the time slice numbers of the particular occurrences (variable type: <code>numeric</code>). Bin numbers should be in ascending order,can contain <code>NA</code>s, it can start from a number other than 1 and must not start with 0.</p>
</td></tr>
<tr><td><code id="survivors_+3A_method">method</code></td>
<td>
<p><code>(character)</code> Either <code>"forward"</code> or <code>"backward"</code>.</p>
</td></tr>
<tr><td><code id="survivors_+3A_nonastart">noNAStart</code></td>
<td>
<p><code>(logical)</code> Useful when the dataset does not start from bin <code>1</code>. Then <code>noNAStart=TRUE</code> will cut the first part of the resulting table, 
so the first row will contain the estimates for the lowest bin number.</p>
</td></tr>
<tr><td><code id="survivors_+3A_fl">fl</code></td>
<td>
<p><code>(matrix</code> or <code>data.frame</code>). If so desired, the function can be run on an FAD-LAD dataset, output by the <code><a href="#topic+fadlad">fadlad</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Proportions of survivorship are great tools to visualize changes in the composition of a group over time (Raup, 1978). The curves show how a once coexisting set of taxa, called a cohort, loses its participants (forward survivorship) as time progress, or gains its elements as time is analyzed backwards.
Each value corresponds to a cohort in a bin (<em>a</em>) and one other bin (<em>b</em>). The value expresses what proportion of the analyzed cohort (present together in bin <em>a</em>) is present in bin <em>b</em>.
</p>
<p>References:
</p>
<p>Raup, D. M. (1978). Cohort analysis of generic survivorship. Paleobiology, 4(1), 1-15.
</p>


<h3>Value</h3>

<p>A numeric matrix of survivorship probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(corals)
surv&lt;-survivors(corals, tax="genus", bin="stg", method="forward")

# plot
data(stages)
tsplot(stages, shading="series", boxes="sys", xlim=c(260,0), 
  ylab="proportion of survivors present", ylim=c(0.01,1),plot.args=list(log="y"))
  
for(i in 1:ncol(surv)) lines(stages$mid, surv[,i])

</code></pre>

<hr>
<h2 id='tabinate'>Apply function to TAxon/BIN subset of occurrences and iterATE</h2><span id='topic+tabinate'></span>

<h3>Description</h3>

<p>The function takes another function and reruns it on every taxon- and/or bin-specific subsets of an occurrence dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tabinate(x, bin = NULL, tax = NULL, FUN = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tabinate_+3A_x">x</code></td>
<td>
<p><code>(data.frame)</code> Fossil occurrence table.</p>
</td></tr>
<tr><td><code id="tabinate_+3A_bin">bin</code></td>
<td>
<p><code>(character)</code> Variable name of the bin numbers of the occurrences. This variable should be <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="tabinate_+3A_tax">tax</code></td>
<td>
<p><code>(character)</code> Variable name of the occurring taxa (variable type: <code>factor</code> or <code>character</code> - such as <code>"genus"</code></p>
</td></tr>
<tr><td><code id="tabinate_+3A_fun">FUN</code></td>
<td>
<p>(<code>function</code>) The function applied to the subset of occurrences. The subset of occurence data will be passed to this function as <code>x</code>.</p>
</td></tr>
<tr><td><code id="tabinate_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main <code>tabinate</code> function acts as a wrapper for any type of function that requires a subset of the occurrence dataset that represents either one <code>bin</code> or one <code>tax</code> entry or both.
For example, the iterator can be used to calculate geographic ranges from occurrence coordinates (<code>georange</code>).
</p>
<p>The output structure of FUN should be independent from the input subset, or the function will return an error. 
Setting both <code>bin</code> If <code>bin=NULL</code> and codetax=NULL, will run <code>FUN</code> on the entire dataset (no effect). Providing either <code>bin</code> or <code>tax</code> and keeping the other <code>NULL</code> will iterate <code>FUN</code> for every <code>bin</code> or <code>tax</code> entry (whichever is presented).
The function returns a vector of values if the return value of <code>FUN</code> is a single value. In case it is a vector, the final output will be a matrix. 
When both <code>bin</code> and <code>tax</code> is presented, the function output will be a matrix (one output value for a taxon/bin subset) or an array (3d, when <code>FUN</code> returns a vector).  Setting <code>FUN</code> to <code>NULL</code> will return the occurrence dataset as <code>list</code>s.
</p>


<h3>Value</h3>

<p>The return object depends on the output of <code>FUN</code>, as well as the <code>bin</code> and <code>tax</code> input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> data(corals)

# the number of different coordinate pairs in every time slice
  tabinate(corals, bin="stg", FUN=georange, lat="paleolat", 
    lng="paleolng", method="co")
# geographic range (site occupancy) of every taxon in every bin
  tabinate(corals, bin="stg", tax="genus", FUN=georange, 
    lat="paleolat", lng="paleolng", method="co")

</code></pre>

<hr>
<h2 id='tens'>The 10 million year resolution timescale of the Paleobiology Database</h2><span id='topic+tens'></span>

<h3>Description</h3>

<p>Roughly 10 million year timescale used in some analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(tens)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 49 observations and 9 variables:
</p>

<dl>
<dt>X10</dt><dd><p>The name of the bin: Period and number.</p>
</dd>
<dt>ocean</dt><dd><p>The primary state of the oceans from the point of carbonate precipitation. <code>ar</code> indicates aragonitic, <code>cc</code> indicates calcitic conditions. Based on §</p>
</dd>
<dt>ocean2</dt><dd><p>§</p>
</dd>
<dt>climate</dt><dd><p>Primary climatic characteristic: <code>w</code> denotes warm, <code>c</code> denotes cold.</p>
</dd>
<dt><code>bottom</code></dt><dd><p>Numeric ages of the bottom boundaries (earliest ages) of the bins.</p>
</dd>
<dt><code>mid</code></dt><dd><p>Numeric ages midpoints of the bins, the averages of <code>bottom</code> and <code>top</code>.</p>
</dd>
<dt><code>top</code></dt><dd><p>Numeric ages of the tops (latest ages) of the bins.</p>
</dd>
<dt><code>dur</code></dt><dd><p>Numeric ages of the durations of the bins.</p>
</dd>
<dt><code>ten</code></dt><dd><p>Integer number identifiers of the bins. §correct to num!</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is an example time scale object that can be used in the Phanerozoic scale analyses. This time scale comprises 49 bins, roughly 10 million years of durations that result from the combination of certain standard stages.
</p>


<h3>Source</h3>

<p>Executive committee meeting (2015) of old Paleobiology Database. Additional variables were added by Wolfgang Kiessling.
</p>

<hr>
<h2 id='tsbars'>Function to plot a series a values with bars that have variable widths</h2><span id='topic+tsbars'></span>

<h3>Description</h3>

<p>Function to use bars for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsbars(x, y, width = "max", yref = 0, gap = 0, vertical = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsbars_+3A_x">x</code></td>
<td>
<p><code>(numeric)</code> Vector specifying where the centers of the bars should be on the x axis.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_y">y</code></td>
<td>
<p><code>(numeric)</code> Vector containing the heights of the bars.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_width">width</code></td>
<td>
<p><code>(numeric)</code> Vector containing the widths of the bars. Recycling is not supported, has to be either a single numeric value, or a numeric vector with the same length as <code>x</code> and <code>y</code>. Automatic width calculation is possible, the default <code>"max"</code> option sets the bar width even and equal to the the maximum width that can be used evenly witout causing overlaps. The option <code>"half"</code>, places the boundaries of the bars halfway between the points. This will make the bars' width asymmetrical around the <code>x</code> coordinates.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_yref">yref</code></td>
<td>
<p><code>(numeric)</code> Single numeric value in the y dimension indicating common base for the bars.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_gap">gap</code></td>
<td>
<p><code>(numeric)</code> The amount of gap there should be between the bars (in the unit of the plotting). Defaults to no gaps.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_vertical">vertical</code></td>
<td>
<p><code>(logical)</code> Switching this option to <code>FALSE</code> will reverse the x and y dimensions of the plot.</p>
</td></tr>
<tr><td><code id="tsbars_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="graphics.html#topic+rect">rect</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>People often present time series with connected points, although the visual depiction implies a certain process that describes how the values change between the points.
Instead of using simple scatter plots, Barplots can be used to describe series where a single value is the most descriptive of a discreet time bin. The <code>tsbars()</code> function
draws rectangles of different widths with the <code><a href="graphics.html#topic+rect">rect</a></code> function, to plot series in such a way.
</p>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># an occurrence-based example
# needed data
  data(stages)
  data(corals)
# calculate diversites
  dd &lt;-divDyn(corals, tax="genus", bin="stg")
# plot range-through diversities
  tsplot(stages, xlim=51:94, ylim=c(0,250), boxes="sys")
  tsbars(x=stages$mid, y=dd$divRT, width=stages$dur, gap=1, col=stages$col)

</code></pre>

<hr>
<h2 id='tsplot'>Time series plotting using a custom time scale</h2><span id='topic+tsplot'></span>

<h3>Description</h3>

<p>This function allows the user to quickly plot a time scale data table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsplot(
  tsdat,
  ylim = c(0, 1),
  xlim = NULL,
  prop = 0.05,
  gap = 0,
  bottom = "bottom",
  top = "top",
  xlab = "Age (Ma)",
  ylab = "",
  boxes = NULL,
  boxes.col = NULL,
  shading = NULL,
  shading.col = c("white", "gray80"),
  plot.args = NULL,
  boxes.args = NULL,
  labels = TRUE,
  labels.args = NULL,
  lplab = TRUE,
  rplab = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsplot_+3A_tsdat">tsdat</code></td>
<td>
<p><code>(data frame)</code>: The time scale data frame.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_ylim">ylim</code></td>
<td>
<p><code>(numeric)</code>: The vertical extent of the plot, analogous to the same argument of <code><a href="graphics.html#topic+plot">plot</a></code>. By default it is set to the <code>[0,1]</code> interval.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_xlim">xlim</code></td>
<td>
<p><code>(numeric)</code>: The horizontal extent of the plot, analogous to the same argument of <code><a href="graphics.html#topic+plot">plot</a></code>. By default it is set to plot the entire table. If a numeric vector with two values is supplied, it will be interpreted as the standard <code>xlim</code> argument and the plot will be displayed based on numerically constrained ages. If it is an integer vector with more than two values are plotted, the interval corresponding to the row indices of the table will be plotted.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_prop">prop</code></td>
<td>
<p><code>(numeric)</code>: Proportion of the vertical extent of the plot to display the the time scale at the bottom.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_gap">gap</code></td>
<td>
<p><code>(numeric)</code>: Proportion of the vertical extent of the plot that should be a gap betwen the time scale and the plot.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_bottom">bottom</code></td>
<td>
<p><code>(character)</code>: Column name of the table for the variable that contains the older ages of intervals.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_top">top</code></td>
<td>
<p><code>(character)</code>: Column name of the table for the variable that contains the earliest ages of intervals.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_xlab">xlab</code></td>
<td>
<p><code>(character)</code>: The label of the time axis.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_ylab">ylab</code></td>
<td>
<p><code>(character)</code>: The label of the data axis.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_boxes">boxes</code></td>
<td>
<p><code>(character)</code>: Column name indicating the names that should be plotted as boxes of the timescale.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_boxes.col">boxes.col</code></td>
<td>
<p><code>(character)</code>: Column name of the colour codes for the boxes. Each entry in this column has to correspond to an entry in the <code>boxes</code> column. It also overrides the <code>col</code> entries in the <code>boxes.args</code> argument.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_shading">shading</code></td>
<td>
<p><code>(character)</code>: Column name used for the shading. By default, no shading will be drawn (<code>shading = NULL</code>).</p>
</td></tr>
<tr><td><code id="tsplot_+3A_shading.col">shading.col</code></td>
<td>
<p><code>(character)</code>: Colors that will be used for the shading, if shading is set. It is either a single column of the <code>tsdat</code> object with color codes, or multiple color entries. The provided colors will be repeated as many times as necessary.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_plot.args">plot.args</code></td>
<td>
<p><code>(list)</code>: Arguments that will be passed to the main <code><a href="graphics.html#topic+plot">plot</a></code> function.  Can be useful for the suppression of axes, font change etc.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_boxes.args">boxes.args</code></td>
<td>
<p><code>(list)</code>: Arguments that will be passed to the <code><a href="graphics.html#topic+rect">rect</a></code> function that draws the rectangles of time intervals.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_labels">labels</code></td>
<td>
<p><code>(logical)</code>: Should the labels within the boxes be drawn? Setting this argumnet to <code>FALSE</code> will not call the <code><a href="graphics.html#topic+text">text</a></code> function that draws the labels.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_labels.args">labels.args</code></td>
<td>
<p><code>(list)</code>: Arguments that will be passed to the <code><a href="graphics.html#topic+text">text</a></code> function that draws the labels. Can be <code>list</code>s of <code>list</code>s if multiple series of &ldquo;boxes&ldquo; are used.</p>
</td></tr>
<tr><td><code id="tsplot_+3A_lplab">lplab</code></td>
<td>
<p><code>logical</code>: When the left boundary of the plot does not match with any of the boundaries of the time scale boxes (and <code>labels=TRUE</code>), should the label of the partially drawn box be plotted?</p>
</td></tr>
<tr><td><code id="tsplot_+3A_rplab">rplab</code></td>
<td>
<p><code>logical</code>: When the right boundary of the plot does not match with any of the boundaries of the time scale boxes (and <code>labels=TRUE</code>), should the label of the partially drawn box be plotted?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As most analysis use an individually compiled time scale object, in order to ensure compatibility between the analyzed and plotted values, the time scale table used for the analysis could be plotted rather than a standardized table. Two example tables have been included in the package (<code><a href="#topic+stages">stages</a></code> and <code><a href="#topic+tens">tens</a></code>) that can serve as templates.
</p>


<h3>Value</h3>

<p>The function has no return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stages) 
  tsplot(stages, boxes="sys", shading="series")
 # same with colours
  tsplot(stages, boxes="sys", shading="series", boxes.col="systemCol") 

# only the Mesozoic, custom axes
  tsplot(stages, boxes="system", shading="stage", xlim=52:81, 
    plot.args=list(axes=FALSE, main="Mesozoic"))
  axis(1, at=seq(250, 75, -25), labels=seq(250, 75, -25))
  axis(2)

# only the Triassic, use the supplied abbreviations
  tsplot(stages, boxes="short", shading="stage", xlim=c(250,199), 
    ylab="variable", labels.args=list(cex=1.5, col="blue"), 
    boxes.args=list(col="gray95"))

 # colourful plot with two levels of hierarchy
   tsplot(stages, boxes=c("short", "system"), shading="series",
     boxes.col=c("col", "systemCol"), xlim=c(52:69))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
