<!DOCTYPE html><html><head><title>Help for package Repliscope</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Repliscope}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calcTrep'><p>A function to calculate Trep values from a sync-seq experiment</p>
calcTrep function fits a Boltzman sigmoid function into relative copy number datapoints for every
genomic bin of the provided sync-seq merged dataframe. It then extracts time at which half of the
cells have this genomic bin replicated (Trep). The output of the function is a dataframe containing
Trep and TrepErr data for every genomic bin in a BED-like format.</a></li>
<li><a href='#compareRatios'><p>A function to compare two replication profiles</p></a></li>
<li><a href='#Dbf4myc'><p>Sequence read coverage ratios for S.cerevisiae Dbf4-9myc sample.</p></a></li>
<li><a href='#guide'><p>Guide dataframe for plotting smoothed sortSeq data</p></a></li>
<li><a href='#loadBed'><p>Load a BED formatted file.</p></a></li>
<li><a href='#makeGenome'><p>A helper function to create a gemome dataframe</p></a></li>
<li><a href='#makeLabels'><p>A helper function to create axis ticks and human readable labels.</p></a></li>
<li><a href='#makeRatio'><p>A function to calculate 'score' ratio between two bed dataframes</p>
makeRatio merges two supplied bed dataframes, calculates ratio of their &quot;score&quot; values
normalises the ratio by the 'score' sums.</a></li>
<li><a href='#MFAseq'><p>Replication profile for wild type DS2 H.volcanii</p></a></li>
<li><a href='#normaliseRatio'><p>A function to normalise ratio values from 'ratio' column of the provided dataframe</p>
to fit biologically-relevant scale. It scales values
either using supplied 'rFactor' value or automatically to best fit 1 to 2 scale
(the upper limit of the scale may be adjusted with the upperLimit parameter).
Normalisation factor used is stored in 'ratioFactor' column and also passed as the
dataframe comment. To extract it, use 'attributes(mergedBed)$comment'</a></li>
<li><a href='#plotBed'><p>A function to boxplot 'score' column of a BED dataframe,</p>
per unique chromosome name in the 'chrom' column. The resulting plot also highlights outliers
based on the inter quartile range (IQR). The genome wide median is plotted as a pink line through the boxplots.</a></li>
<li><a href='#plotCoverage'><p>A function to scatterplot 'score' column of a BED dataframe</p>
plotCoverage function plots values in the 'score' column of the supplied bed dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.</a></li>
<li><a href='#plotGenome'><p>plotGenome: plot replication profile.</p></a></li>
<li><a href='#plotRatio'><p>A function to plot a histogram of supplied ratio vector</p>
plotRatio plots histogram of values in a supplied vector using ggplot2 and
highlights interval between 1 and 2 in green.</a></li>
<li><a href='#plotTrep'><p>A function to scatterplot 'Trep' column of a Trep dataframe</p>
plotTrep function plots values in the 'Trep' column of the supplied dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.</a></li>
<li><a href='#rmChr'><p>A function to remove single chromosome data from a bed dataframe</p></a></li>
<li><a href='#rmOutliers'><p>A function to remove outliers from the &quot;score&quot; column of a supplied bed dataframe</p>
There are three methods: max, IQR and median. Max is used to remove 1 or more maximum
values; IQR uses interquartile range to detect outliers, while median method can be
used to remove data based on genome-wide median.</a></li>
<li><a href='#runGUI'><p>A function to launch Repliscope in interactive mode (Shiny app).</p></a></li>
<li><a href='#sacCer3'><p>S.cerevisiae genome information</p></a></li>
<li><a href='#smoothRatio'><p>A function to smooth ratio values using cubic smoothing spline</p>
smoothRatio function splits values from 'ratio' column by chromosome and based the supplied
'groupMin' and 'split' parameters and then applies smooth.spline() function from R stats package.
The supplied dataframe may contain multiple ratios, i.e. ratios produced using multiple replicating
samples and/or multiple non-replicating samples. This must be reflected in 'name.rep' and 'name.nonRep'
columns. In other words, different ratio dataframes may be merged using rbind() function before calling
smoothRatio() function.</a></li>
<li><a href='#sortSeq'><p>Replication profiles for wild type and Dbf4-9myc S.cerevisiae samples</p></a></li>
<li><a href='#syncSeq'><p>Replication profiles budding yeast arrest-release samples</p></a></li>
<li><a href='#TrepDF'><p>Trep data calculated from syncSeq[[&quot;data&quot;]]</p></a></li>
<li><a href='#trimRatio'><p>A function to remove outliers from the &quot;ratio&quot; column of a supplied ratio dataframe</p>
trimRatio is applied to the calculated ratio of read counts from a replicating to
a non-replicating samples.</a></li>
<li><a href='#W303'><p>Sequence read coverage ratios for wild type S.cerevisiae W303</p></a></li>
<li><a href='#W303_G2'><p>Sequence read coverage for wild type S.cerevisiae W303 non-replicating sample.</p></a></li>
<li><a href='#W303_S'><p>Sequence read coverage for wild type S.cerevisiae W303 replicating sample</p></a></li>
<li><a href='#W303norm'><p>Normalised sequence read coverage ratios for wild type S.cerevisiae W303</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Title:</td>
<td>Replication Timing Profiling using DNA Copy Number</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Dzmitry G Batrakou</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dzmitry G Batrakou &lt;d.batrakou@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Create, Plot and Compare Replication Timing Profiles. The method is described in Muller et al., (2014) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgkt878">doi:10.1093/nar/gkt878</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2, shiny</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, grDevices, colourpicker</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-13 07:03:36 UTC; dzmit</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-13 07:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calcTrep'>A function to calculate Trep values from a sync-seq experiment
calcTrep function fits a Boltzman sigmoid function into relative copy number datapoints for every
genomic bin of the provided sync-seq merged dataframe. It then extracts time at which half of the
cells have this genomic bin replicated (Trep). The output of the function is a dataframe containing
Trep and TrepErr data for every genomic bin in a BED-like format.</h2><span id='topic+calcTrep'></span>

<h3>Description</h3>

<p>A function to calculate Trep values from a sync-seq experiment
calcTrep function fits a Boltzman sigmoid function into relative copy number datapoints for every
genomic bin of the provided sync-seq merged dataframe. It then extracts time at which half of the
cells have this genomic bin replicated (Trep). The output of the function is a dataframe containing
Trep and TrepErr data for every genomic bin in a BED-like format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTrep(ratioDFs, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcTrep_+3A_ratiodfs">ratioDFs</code></td>
<td>
<p>A merged ratios dataframe containing sync-seq samples (dataframe).</p>
</td></tr>
<tr><td><code id="calcTrep_+3A_times">times</code></td>
<td>
<p>Time series data in the same order as in the ratioDFs (numeric vector).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>TrepDF &lt;- calcTrep(subset(syncSeq[["data"]],chrom=="chrI"),times=c(25,30,35,40,45,50,90))
</code></pre>

<hr>
<h2 id='compareRatios'>A function to compare two replication profiles</h2><span id='topic+compareRatios'></span>

<h3>Description</h3>

<p>compareRatios takes two ratio dataframes that were binned the same way and uses z-score
statistics to find p-values of their differences. The function outputs a combined dataframe containing
the two input ratio dataframes in a long format with added 'p.value' column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareRatios(ratio1, ratio2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareRatios_+3A_ratio1">ratio1</code></td>
<td>
<p>Ratio dataframe, or a string containing name of a ratio dataframe (dataframe or string).</p>
</td></tr>
<tr><td><code id="compareRatios_+3A_ratio2">ratio2</code></td>
<td>
<p>Ratio dataframe, or a string containing name of a ratio dataframe (dataframe or string).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ratioDFs &lt;- compareRatios(W303norm,Dbf4myc)
</code></pre>

<hr>
<h2 id='Dbf4myc'>Sequence read coverage ratios for S.cerevisiae Dbf4-9myc sample.</h2><span id='topic+Dbf4myc'></span>

<h3>Description</h3>

<p>Sequence read coverage ratios for Dbf4-9myc sample
(T9394 strain). The cells were stained with DNA dye and sorted
based on DNA content into S or G2/M phase fractions. Extracted
DNA was sequenced and mapped to sacCer3 genome. Unique reads
for replicating (S) and non-replicating (G2/M) samples were
calculated in 1 kb genomic bins. The ratio was created by
dividing 'score' values from replicating sample by non-
replicating sample 'score' values, adjusted by total number
of reads. The ratio values were further adjusted by multiplying
them by 1.402 to put the values onto biologically relevant
relative copy number scale from 1 to 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Dbf4myc)
</code></pre>


<h3>Format</h3>

<p>data frame with 11356 rows and 7 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name.rep</dt><dd><p>replicating sample name</p>
</dd>
<dt>name.nonRep</dt><dd><p>non-replicating sample name</p>
</dd>
<dt>ratio</dt><dd><p>ratio value in the current bin</p>
</dd>
<dt>ratioFactor</dt><dd><p>adjustment factor used for the current ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>S phase sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202404">SRA</a>;
G2 sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202403">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Dbf4myc)
</code></pre>

<hr>
<h2 id='guide'>Guide dataframe for plotting smoothed sortSeq data</h2><span id='topic+guide'></span>

<h3>Description</h3>

<p>Guide dataframe for plotting smoothed sortSeq data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(guide)
</code></pre>


<h3>Format</h3>

<p>Dataframe with 2 rows and 6 variables:
</p>

<dl>
<dt>order</dt><dd><p>Order to plot data in</p>
</dd>
<dt>name.rep</dt><dd><p>Name of replicating sample</p>
</dd>
<dt>name.nonRep</dt><dd><p>Name of non-replicating sample</p>
</dd>
<dt>raw</dt><dd><p>Should raw data be plotted?</p>
</dd>
<dt>smooth</dt><dd><p>Should smooth data be plotted?</p>
</dd>
<dt>color</dt><dd><p>Color to plot the profile in</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(guide)
</code></pre>

<hr>
<h2 id='loadBed'>Load a BED formatted file.</h2><span id='topic+loadBed'></span>

<h3>Description</h3>

<p>The function reads BED formatted files. The BED file format defined by UCSC: http://genome.ucsc.edu/FAQ/FAQformat.
First three columns (&quot;chrom&quot;, &quot;chromStart&quot;, &quot;chromEnd&quot;) are mandatory. The file fields may be separated by tabs,
spaces or commas. If the BED file contains a header, it will be ignored. If a genome mask dataframe is provided,
only data intersected with the mask will be retained. Resulting data is ordered by &quot;chromStart&quot; columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadBed(file, genome = NULL, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadBed_+3A_file">file</code></td>
<td>
<p>Path to the BED file (string, mandatory)</p>
</td></tr>
<tr><td><code id="loadBed_+3A_genome">genome</code></td>
<td>
<p>A mask dataframe to exclude data from the BED file (dataframe, optional).
The genome dataframe must contain &quot;chrom&quot; column and may further contain &quot;chromStart&quot; and &quot;chromEnd&quot; columns in this
order.</p>
</td></tr>
<tr><td><code id="loadBed_+3A_name">name</code></td>
<td>
<p>A string to replace the 'name' column of the loaded BED file with (string, optional).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>W303_G2 &lt;- loadBed(system.file("extdata/W303_G2.bed",package="Repliscope"), name='W303_G2')
W303_G2_chrI &lt;- loadBed(system.file("extdata/W303_G2.bed",package="Repliscope"),
                       name='W303_G2',genome=sacCer3[["genome"]])
</code></pre>

<hr>
<h2 id='makeGenome'>A helper function to create a gemome dataframe</h2><span id='topic+makeGenome'></span>

<h3>Description</h3>

<p>makeGenome is called by plotGenome() and plotCoverage() functions if a genome dataframe is not
provided. It creates a BED-like dataframe containing unique chromosome names, their start coordinates
(assumed 0), their ends (highest value in the corresponding 'chromEnd' of the BED dataframe) and 'midY'
column containing half the max value of the &quot;score&quot; or &quot;ratio&quot; columns per chromosome. This later
serves as y coordinate to add chromosome names. Axis name is passed via comment to the output dataframe.
Extract it with 'attributes(genome)$axisName'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGenome(DF, region = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeGenome_+3A_df">DF</code></td>
<td>
<p>A BED or ratio dataframe containing either 'score' or 'ratio' column (dataframe).</p>
</td></tr>
<tr><td><code id="makeGenome_+3A_region">region</code></td>
<td>
<p>String in the format 'chrI:1000-3000' (string, optional).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>genomeDF &lt;- makeGenome(W303_G2)
</code></pre>

<hr>
<h2 id='makeLabels'>A helper function to create axis ticks and human readable labels.</h2><span id='topic+makeLabels'></span>

<h3>Description</h3>

<p>makeLabels is called by plotGenome() and plotCoverage() functions. It creates a dataframe
containing two columns: 'ticks' and 'labels'. 'Ticks' contains axis ticks coordinates, 'labels'
will contain human readable lables for the ticks (using prefixes and optional units).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeLabels(theMin, theMax, unit = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeLabels_+3A_themin">theMin</code></td>
<td>
<p>Minimum value for the scale (double).</p>
</td></tr>
<tr><td><code id="makeLabels_+3A_themax">theMax</code></td>
<td>
<p>Maximum value for the scale (double).</p>
</td></tr>
<tr><td><code id="makeLabels_+3A_unit">unit</code></td>
<td>
<p>Unit to use for the labels (string, optional)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>labels &lt;- makeLabels(0,1200000,"b")
</code></pre>

<hr>
<h2 id='makeRatio'>A function to calculate 'score' ratio between two bed dataframes
makeRatio merges two supplied bed dataframes, calculates ratio of their &quot;score&quot; values
normalises the ratio by the 'score' sums.</h2><span id='topic+makeRatio'></span>

<h3>Description</h3>

<p>A function to calculate 'score' ratio between two bed dataframes
makeRatio merges two supplied bed dataframes, calculates ratio of their &quot;score&quot; values
normalises the ratio by the 'score' sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRatio(bedRep, bedNonRep)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeRatio_+3A_bedrep">bedRep</code></td>
<td>
<p>Bed dataframe containing read counts from a replicating sample (dataframe).
The bed dataframe must contain &quot;chrom&quot;,&quot;chromStart&quot;, &quot;chromEnd&quot; and &quot;score&quot; columns.</p>
</td></tr>
<tr><td><code id="makeRatio_+3A_bednonrep">bedNonRep</code></td>
<td>
<p>Bed dataframe containing read counts from a non-replicating sample (dataframe).
The bed dataframe must contain &quot;chrom&quot;,&quot;chromStart&quot;, &quot;chromEnd&quot; and &quot;score&quot; columns.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ratioDF &lt;- makeRatio(W303_S,W303_G2)
</code></pre>

<hr>
<h2 id='MFAseq'>Replication profile for wild type DS2 H.volcanii</h2><span id='topic+MFAseq'></span>

<h3>Description</h3>

<p>Replication profile for H.volcanii wild isolate DS2.
Genomic DNA for deep sequencing was isolated from 100 ml culture
in stationary phase (A650 &gt; 1, DS2_stat sample) or 1 litre in
exponential phase (A650 0.1, DS2_exp sample). Unique
reads for the two samples were calculated in 1 kb genomic bins
using ASM2568v1 genome assembly. The ratio was created by
dividing 'score' values from replicating sample by non-
replicating sample 'score' values, adjusted by total number
of reads. The ratio values were further adjusted by multiplying
them by 1.12 to put the values onto biologically relevant
relative copy number scale from 1 to 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MFAseq)
</code></pre>


<h3>Format</h3>

<p>data frame with 3887 rows and 7 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name.rep</dt><dd><p>replicating sample name</p>
</dd>
<dt>name.nonRep</dt><dd><p>non-replicating sample name</p>
</dd>
<dt>ratio</dt><dd><p>ratio value in the current bin</p>
</dd>
<dt>ratioFactor</dt><dd><p>adjustment factor used for the current ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>DS2_exp exponential phase sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202169">SRA</a>;
DS2_stat stationary sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202170">SRA</a>
</p>


<h3>References</h3>

<p>Hawkins et al. (2013) Nature 503(7477):544-547
(<a href="https://pubmed.ncbi.nlm.nih.gov/24185008">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MFAseq)
</code></pre>

<hr>
<h2 id='normaliseRatio'>A function to normalise ratio values from 'ratio' column of the provided dataframe
to fit biologically-relevant scale. It scales values
either using supplied 'rFactor' value or automatically to best fit 1 to 2 scale
(the upper limit of the scale may be adjusted with the upperLimit parameter).
Normalisation factor used is stored in 'ratioFactor' column and also passed as the
dataframe comment. To extract it, use 'attributes(mergedBed)$comment'</h2><span id='topic+normaliseRatio'></span><span id='topic+normalizeRatio'></span>

<h3>Description</h3>

<p>A function to normalise ratio values from 'ratio' column of the provided dataframe
to fit biologically-relevant scale. It scales values
either using supplied 'rFactor' value or automatically to best fit 1 to 2 scale
(the upper limit of the scale may be adjusted with the upperLimit parameter).
Normalisation factor used is stored in 'ratioFactor' column and also passed as the
dataframe comment. To extract it, use 'attributes(mergedBed)$comment'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normaliseRatio(ratioDF, rFactor = NULL, upperLimit = 2, replace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normaliseRatio_+3A_ratiodf">ratioDF</code></td>
<td>
<p>A ratio dataframe containing 'ratio' column (dataframe).</p>
</td></tr>
<tr><td><code id="normaliseRatio_+3A_rfactor">rFactor</code></td>
<td>
<p>Value to normalise by, related to replication progression (numeric, optional).</p>
</td></tr>
<tr><td><code id="normaliseRatio_+3A_upperlimit">upperLimit</code></td>
<td>
<p>Top value for the scale, defaults to 2 (numeric, optional, defaults).</p>
</td></tr>
<tr><td><code id="normaliseRatio_+3A_replace">replace</code></td>
<td>
<p>Should the existing 'ratio' values be overwritten or stored in a new column
(boolean, defaults to TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ratioDF &lt;- normaliseRatio(W303) ## scales to 1 to 2 range, replaces original values.
ratioDF &lt;- normaliseRatio(W303,rFactor=1.41,replace=FALSE)
# (multiplies score values by 1.41 and keeps the original values)
</code></pre>

<hr>
<h2 id='plotBed'>A function to boxplot 'score' column of a BED dataframe,
per unique chromosome name in the 'chrom' column. The resulting plot also highlights outliers
based on the inter quartile range (IQR). The genome wide median is plotted as a pink line through the boxplots.</h2><span id='topic+plotBed'></span>

<h3>Description</h3>

<p>A function to boxplot 'score' column of a BED dataframe,
per unique chromosome name in the 'chrom' column. The resulting plot also highlights outliers
based on the inter quartile range (IQR). The genome wide median is plotted as a pink line through the boxplots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBed(bed, plotting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBed_+3A_bed">bed</code></td>
<td>
<p>A dataframe containing 'score' and 'chrom' columns (dataframe).</p>
</td></tr>
<tr><td><code id="plotBed_+3A_plotting">plotting</code></td>
<td>
<p>Should the plot object be sent to the default device? (boolean, defaults to TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotBed(W303_S)
plotObject &lt;- plotBed(W303_G2,plotting=FALSE)
</code></pre>

<hr>
<h2 id='plotCoverage'>A function to scatterplot 'score' column of a BED dataframe
plotCoverage function plots values in the 'score' column of the supplied bed dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.</h2><span id='topic+plotCoverage'></span>

<h3>Description</h3>

<p>A function to scatterplot 'score' column of a BED dataframe
plotCoverage function plots values in the 'score' column of the supplied bed dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCoverage(bed, region = FALSE, plotting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCoverage_+3A_bed">bed</code></td>
<td>
<p>A dataframe containing 'score','chrom','chromStart' and 'chromEnd' columns (dataframe).</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_region">region</code></td>
<td>
<p>Only plot for the provided region in the format 'chrI:1000-3000' (string, optional).</p>
</td></tr>
<tr><td><code id="plotCoverage_+3A_plotting">plotting</code></td>
<td>
<p>Should the plot object be sent to the default device? (boolean, defaults to TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotCoverage(W303_G2)
plotObject &lt;- plotCoverage(W303_S,plotting=FALSE)
</code></pre>

<hr>
<h2 id='plotGenome'>plotGenome: plot replication profile.</h2><span id='topic+plotGenome'></span>

<h3>Description</h3>

<p>plotGenome plots scatterplot/barplot/polygon of 'score' and/or 'splineSmooth' columns values
by genomic coordinates, either for the whole genome or a region. It also allows annotation
with additional BED-formatted data. Ggplot2 package is used for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGenome(
  ratioDFs,
  geom = "geom_point",
  ylims = c(1, 2),
  plotting = TRUE,
  genome = NULL,
  region = FALSE,
  guide = NULL,
  lines = NULL,
  circles = NULL,
  rectangles = NULL,
  pointers = NULL,
  colourLines = "#00FF00",
  colourCircles = "#FFFFFF",
  colourRectangles = "#FF0000",
  colourPointers = "#FF7F00"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGenome_+3A_ratiodfs">ratioDFs</code></td>
<td>
<p>A ratio dataframe or combined ratios dataframe containing 'ratio' column (dataframe).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_geom">geom</code></td>
<td>
<p>ggplot2 geom to use for plotting: &quot;geom_point&quot;,&quot;geom_ribbon&quot; or &quot;geom_segment&quot; (string, defaults to &quot;geom_point&quot;).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_ylims">ylims</code></td>
<td>
<p>A vector of two values for y axis limits - first is lowest, second is highest (numeric vector, defaults to 1 and 2)</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_plotting">plotting</code></td>
<td>
<p>Should the plot object be sent to the default device? (boolean, defaults to TRUE).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_genome">genome</code></td>
<td>
<p>A mask dataframe to exclude data from the ratio dataframe (dataframe, optional).
The genome dataframe must contain &quot;chrom&quot;,&quot;chromStart&quot; and &quot;chromEnd&quot; columns.</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_region">region</code></td>
<td>
<p>Only plot for the provided region in the format 'chrI:1000-3000' (string, optional).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_guide">guide</code></td>
<td>
<p>A dataframe guiding the plotGenome function how to plot the data (dataframe, optional).
The guide dataframe must contain the following columns:
'order' (integer) - order to plot data in,
'name.rep' (character) - replicating sample name that matches the one in the ratioDFs dataframe,
'name.nonRep' (character) - non-replicating sample name that matches the one in the ratioDFs dataframe,
'raw' (logical) - should the raw raw data be plotted?
'smooth' (logical) - should the smoothed data be plotted?
'color'(character) - R color to plot the current sample with, both raw and smoothed data.</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_lines">lines</code></td>
<td>
<p>Additionally plot vertical lines from a BED formatted dataframe (dataframe, optional).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_circles">circles</code></td>
<td>
<p>Additionally plot circles on the chromosome line from a BED formatted dataframe (dataframe, optional).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_rectangles">rectangles</code></td>
<td>
<p>Additionally plot rectangles on the chromosome line from a BED formatted dataframe (dataframe, optional).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_pointers">pointers</code></td>
<td>
<p>Additionally plot downward pointing triangles from a BED formatted dataframe (dataframe, optional).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_colourlines">colourLines</code></td>
<td>
<p>Colour for 'lines' data (string, defaults to green).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_colourcircles">colourCircles</code></td>
<td>
<p>Colour for 'circles' data (string, defaults to white).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_colourrectangles">colourRectangles</code></td>
<td>
<p>Colour for 'rectangles' data (string, defaults to red).</p>
</td></tr>
<tr><td><code id="plotGenome_+3A_colourpointers">colourPointers</code></td>
<td>
<p>Colour for 'pointers' data (string, defaults to orange).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotGenome(sortSeq,geom="geom_ribbon",guide=guide,region="chrIX:250000-439885",
    lines=sacCer3[["cen"]],circles=sacCer3[["ori"]])
# plot data as polygon for the specified region of chromosome 9

plotGenome(syncSeq[["data"]],geom="geom_segment",guide=syncSeq[["guide"]],
    region="chrVII:0-1090944",genome=sacCer3[["genome"]],lines=sacCer3[["cen"]],
    circles=sacCer3[["ori"]],colourLines="black")

plotGenome(MFAseq,region='chr1:0-2848000')
# plot marker frequency analysis for H.volcanii isolate DS2
</code></pre>

<hr>
<h2 id='plotRatio'>A function to plot a histogram of supplied ratio vector
plotRatio plots histogram of values in a supplied vector using ggplot2 and
highlights interval between 1 and 2 in green.</h2><span id='topic+plotRatio'></span>

<h3>Description</h3>

<p>A function to plot a histogram of supplied ratio vector
plotRatio plots histogram of values in a supplied vector using ggplot2 and
highlights interval between 1 and 2 in green.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRatio(ratio, plotting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRatio_+3A_ratio">ratio</code></td>
<td>
<p>A numeric vector containing raw or smoothed ratio values (vector).</p>
</td></tr>
<tr><td><code id="plotRatio_+3A_plotting">plotting</code></td>
<td>
<p>Should the plot object be sent to the default device? (boolean, defaults to TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotRatio(W303$ratio)
plotObject &lt;- plotRatio(W303$ratio,plotting=FALSE)
</code></pre>

<hr>
<h2 id='plotTrep'>A function to scatterplot 'Trep' column of a Trep dataframe
plotTrep function plots values in the 'Trep' column of the supplied dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.</h2><span id='topic+plotTrep'></span>

<h3>Description</h3>

<p>A function to scatterplot 'Trep' column of a Trep dataframe
plotTrep function plots values in the 'Trep' column of the supplied dataframe as a function of
chromosome coordinates. The genome wide median is plotted as a pink line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTrep(TrepDF, region = FALSE, plotting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTrep_+3A_trepdf">TrepDF</code></td>
<td>
<p>A dataframe containing 'chrom','chromStart', 'chromEnd' and 'Trep' columns (dataframe).</p>
</td></tr>
<tr><td><code id="plotTrep_+3A_region">region</code></td>
<td>
<p>Only plot for the provided region in the format 'chrI:1000-3000' (string, optional).</p>
</td></tr>
<tr><td><code id="plotTrep_+3A_plotting">plotting</code></td>
<td>
<p>Should the plot object be sent to the default device? (boolean, defaults to TRUE).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>plotTrep(TrepDF,region="chrI")
</code></pre>

<hr>
<h2 id='rmChr'>A function to remove single chromosome data from a bed dataframe</h2><span id='topic+rmChr'></span>

<h3>Description</h3>

<p>A function to remove single chromosome data from a bed dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmChr(bed, chr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmChr_+3A_bed">bed</code></td>
<td>
<p>A bed dataframe containing 'chrom' column (dataframe, required).</p>
</td></tr>
<tr><td><code id="rmChr_+3A_chr">chr</code></td>
<td>
<p>Chromosome to remove (string, required).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bedDF &lt;- rmChr(W303_S,"chrM") ## removes mitochondria
</code></pre>

<hr>
<h2 id='rmOutliers'>A function to remove outliers from the &quot;score&quot; column of a supplied bed dataframe
There are three methods: max, IQR and median. Max is used to remove 1 or more maximum
values; IQR uses interquartile range to detect outliers, while median method can be
used to remove data based on genome-wide median.</h2><span id='topic+rmOutliers'></span>

<h3>Description</h3>

<p>A function to remove outliers from the &quot;score&quot; column of a supplied bed dataframe
There are three methods: max, IQR and median. Max is used to remove 1 or more maximum
values; IQR uses interquartile range to detect outliers, while median method can be
used to remove data based on genome-wide median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmOutliers(bed, method, n = 1, range = 3, loLim = 0.25, hiLim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmOutliers_+3A_bed">bed</code></td>
<td>
<p>A dataframe containing 'score' column (dataframe, required).</p>
</td></tr>
<tr><td><code id="rmOutliers_+3A_method">method</code></td>
<td>
<p>Method to detect outliers: &quot;max&quot;, &quot;IQR&quot; or &quot;median&quot; (string).</p>
</td></tr>
<tr><td><code id="rmOutliers_+3A_n">n</code></td>
<td>
<p>Number of max values to remove (integer,defaults to 1). Use with &quot;max&quot; method.</p>
</td></tr>
<tr><td><code id="rmOutliers_+3A_range">range</code></td>
<td>
<p>Number of IQR above the 3rd or below the 1st IQR to set the threshold (double, defaults to 3).
Use with &quot;IQR&quot; method.</p>
</td></tr>
<tr><td><code id="rmOutliers_+3A_lolim">loLim</code></td>
<td>
<p>Low limit for the median method (double, defaults to 0.25).</p>
</td></tr>
<tr><td><code id="rmOutliers_+3A_hilim">hiLim</code></td>
<td>
<p>High limit for the median method (double).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>bedDF &lt;- rmOutliers(W303_S,method="max",n=2) ## removes 2 rows of data containing 3 top values
bedDF &lt;- rmOutliers(W303_S,method="IQR",range=3) ## removes datapoints outside 3 x IQR above the 3rd
 # and below the 1st IQR.
bedDF &lt;- rmOutliers(W303_S,method="median",loLim=0.25,hiLim=2) # removes datapoints that are lower
 # than 0.25 x genome median or above 2 x genome median.
</code></pre>

<hr>
<h2 id='runGUI'>A function to launch Repliscope in interactive mode (Shiny app).</h2><span id='topic+runGUI'></span>

<h3>Description</h3>

<p>A function to launch Repliscope in interactive mode (Shiny app).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGUI()
</code></pre>

<hr>
<h2 id='sacCer3'>S.cerevisiae genome information</h2><span id='topic+sacCer3'></span>

<h3>Description</h3>

<p>sacCer3 meta information: chromosome sizes,
centromere and replication origin positions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sacCer3)
</code></pre>


<h3>Format</h3>

<p>List containing three dataframes
</p>

<dl>
<dt>genome</dt><dd><p>Chromosome information dataframe</p>
</dd>
<dt>cen</dt><dd><p>Centromere information dataframe</p>
</dd>
<dt>ori</dt><dd><p>Replication origin information dataframe</p>
</dd>
</dl>



<h3>Source</h3>

<p>Replication origin information: (<a href="http://cerevisiae.oridb.org/">OriDB</a>)
</p>


<h3>References</h3>

<p>Siow et al. (2011) NAR 40(Database issue):D682-6
(<a href="https://pubmed.ncbi.nlm.nih.gov/22121216">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sacCer3)
</code></pre>

<hr>
<h2 id='smoothRatio'>A function to smooth ratio values using cubic smoothing spline
smoothRatio function splits values from 'ratio' column by chromosome and based the supplied
'groupMin' and 'split' parameters and then applies smooth.spline() function from R stats package.
The supplied dataframe may contain multiple ratios, i.e. ratios produced using multiple replicating
samples and/or multiple non-replicating samples. This must be reflected in 'name.rep' and 'name.nonRep'
columns. In other words, different ratio dataframes may be merged using rbind() function before calling
smoothRatio() function.</h2><span id='topic+smoothRatio'></span>

<h3>Description</h3>

<p>A function to smooth ratio values using cubic smoothing spline
smoothRatio function splits values from 'ratio' column by chromosome and based the supplied
'groupMin' and 'split' parameters and then applies smooth.spline() function from R stats package.
The supplied dataframe may contain multiple ratios, i.e. ratios produced using multiple replicating
samples and/or multiple non-replicating samples. This must be reflected in 'name.rep' and 'name.nonRep'
columns. In other words, different ratio dataframes may be merged using rbind() function before calling
smoothRatio() function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothRatio(ratioDF, groupMin = 5, splitNum = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothRatio_+3A_ratiodf">ratioDF</code></td>
<td>
<p>A ratio dataframe or combined ratios dataframe containing 'ratio' column (dataframe).</p>
</td></tr>
<tr><td><code id="smoothRatio_+3A_groupmin">groupMin</code></td>
<td>
<p>Minimum number of values required to make a group (integer, defaults to 5).</p>
</td></tr>
<tr><td><code id="smoothRatio_+3A_splitnum">splitNum</code></td>
<td>
<p>Minimum number of adjacent bins with missing values to close current group (integer, defaults to 5).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ratioDF &lt;- smoothRatio(W303norm)
</code></pre>

<hr>
<h2 id='sortSeq'>Replication profiles for wild type and Dbf4-9myc S.cerevisiae samples</h2><span id='topic+sortSeq'></span>

<h3>Description</h3>

<p>Replication profiles for wild type and Dbf4-9myc samples
(T7107 and T9394 strains). The cells were stained with DNA dye
and sorted based on DNA content into S or G2/M phase fractions.
Extracted DNA was sequenced and mapped to sacCer3 genome. Unique
reads for replicating (S) and non-replicating (G2/M) samples were
calculated in 1 kb genomic bins. The ratio was created by
dividing 'score' values from replicating sample by non-
replicating sample 'score' values, adjusted by total number
of reads. The ratio values were further adjusted by multiplying
them by 1.41 and 1.402 for wild type and Dbf4-9myc samples,
respectively, to put the values onto biologically relevant
relative copy number scale from 1 to 2. The relative copy number
values were smoothed using cubic spline and compared using z
score statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sortSeq)
</code></pre>


<h3>Format</h3>

<p>data frame with 22696 rows and 10 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name.rep</dt><dd><p>replicating sample name</p>
</dd>
<dt>name.nonRep</dt><dd><p>non-replicating sample name</p>
</dd>
<dt>ratio</dt><dd><p>ratio value in the current bin</p>
</dd>
<dt>ratioFactor</dt><dd><p>adjustment factor used for the current ratio</p>
</dd>
<dt>group</dt><dd><p>Group number of the current bin</p>
</dd>
<dt>splineSmooth</dt><dd><p>Smoothed ratio value</p>
</dd>
<dt>p.value</dt><dd><p>Significance of ratio difference between Dbf4myc and W303 samples</p>
</dd>
</dl>



<h3>Source</h3>

<p>Dbf4myc S phase sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202404">SRA</a>;
Dbf4myc G2 sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX202403">SRA</a>;
W303 S sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204358">SRA</a>;
W303 G2 sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204357">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sortSeq)
</code></pre>

<hr>
<h2 id='syncSeq'>Replication profiles budding yeast arrest-release samples</h2><span id='topic+syncSeq'></span>

<h3>Description</h3>

<p>Replication profiles of wild type S. cerevisiae arrest-release samples
(AUY077 strain). The cells were arrested in G1 with alpha-factor
followed by release using pronase. The samples were collected
before the release (aFactor) and various time intervals after
the release (25min,30min,35min,40min,45min,50min and 90min)
Extracted DNA was sequenced and mapped to sacCer3 genome. Unique
reads for replicating (post-release) and non-replicating (aFactor)
samples were calculated in 1 kb genomic bins. The ratios were
created by dividing 'score' values from replicating samples by
non-replicating sample 'score' values, adjusted by total number
of reads. The ratio values were further adjusted based on bulk
genome replication (as determined by flow cytometry), to put the
values onto biologically relevant relative copy number scale from
1 to 2. The relative copy number values were smoothed using cubic
spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(syncSeq)
</code></pre>


<h3>Format</h3>

<p>List containing two data frames
</p>

<dl>
<dt>data</dt><dd><p>syncSeq replication profiles data. Columns:
<strong>chrom</strong> (short chromosome name),
<strong>chromStart</strong> (left chromosome coordinate),
<strong>chromEnd</strong> (right chromosome coordinate),
<strong>name.rep</strong> (replicating sample name),
<strong>name.nonRep</strong> (non-replicating sample name),
<strong>ratio</strong> (ratio value in the current bin),
<strong>ratioFactor</strong> (adjustment factor used for the current ratio),
<strong>group</strong> (Group number of the current bin),
<strong>splineSmooth</strong> (Smoothed ratio value)
</p>
</dd>
<dt>guide</dt><dd><p>Guide dataframe for plotting the syncSeq data
<strong>order</strong> (Order to plot data in),
<strong>name.rep</strong> (Name of replicating sample),
<strong>name.nonRep</strong> (Name of non-replicating sample),
<strong>raw</strong> (Should raw data be plotted?),
<strong>smooth</strong> (Should smooth data be plotted?),
<strong>color</strong> (Color to plot the profile in)
</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE48212">GEO</a>
</p>


<h3>References</h3>

<p>Müller et al. (2014) NAR 42(1):e3
(<a href="https://pubmed.ncbi.nlm.nih.gov/24089142">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(syncSeq)
</code></pre>

<hr>
<h2 id='TrepDF'>Trep data calculated from syncSeq[[&quot;data&quot;]]</h2><span id='topic+TrepDF'></span>

<h3>Description</h3>

<p>Trep is median replication time, expressed in minutes after release G1 arrest.
It is calculated from multiple relative copy number datapoints across timeseries
of a cell cycle experiment. For every genomic bin, a sigmoid function is fitted
and its midpoint is reported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TrepDF)
</code></pre>


<h3>Format</h3>

<p>data frame with 11341 rows and 5 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>Trep</dt><dd><p>calculated Trep value</p>
</dd>
<dt>TrepErr</dt><dd><p>error from sigmoid function fitting</p>
</dd>
</dl>



<h3>References</h3>

<p>Müller et al. (2014) NAR 42(1):e3
(<a href="https://pubmed.ncbi.nlm.nih.gov/24089142">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(TrepDF)
</code></pre>

<hr>
<h2 id='trimRatio'>A function to remove outliers from the &quot;ratio&quot; column of a supplied ratio dataframe
trimRatio is applied to the calculated ratio of read counts from a replicating to
a non-replicating samples.</h2><span id='topic+trimRatio'></span>

<h3>Description</h3>

<p>A function to remove outliers from the &quot;ratio&quot; column of a supplied ratio dataframe
trimRatio is applied to the calculated ratio of read counts from a replicating to
a non-replicating samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimRatio(ratioDF, loLim, hiLim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimRatio_+3A_ratiodf">ratioDF</code></td>
<td>
<p>A ratio dataframe containing 'ratio' column (dataframe, required).</p>
</td></tr>
<tr><td><code id="trimRatio_+3A_lolim">loLim</code></td>
<td>
<p>Low limit threshold (double, required).</p>
</td></tr>
<tr><td><code id="trimRatio_+3A_hilim">hiLim</code></td>
<td>
<p>High limit threshold (double, required).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>W303 &lt;- trimRatio(W303,0.5,1.5)
</code></pre>

<hr>
<h2 id='W303'>Sequence read coverage ratios for wild type S.cerevisiae W303</h2><span id='topic+W303'></span>

<h3>Description</h3>

<p>Sequence read coverage ratios for wild type sample
(T7107 strain). The cells were stained with DNA dye and sorted
based on DNA content into S or G2/M phase fractions. Extracted
DNA was sequenced and mapped to sacCer3 genome. Unique reads
for replicating (S) and non-replicating (G2/M) samples were
calculated in 1 kb genomic bins. The ratio was created by
dividing 'score' values from replicating sample by non-
replicating sample 'score' values, adjusted by total number
of reads.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(W303)
</code></pre>


<h3>Format</h3>

<p>data frame with 11350 rows and 7 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name.rep</dt><dd><p>replicating sample name</p>
</dd>
<dt>name.nonRep</dt><dd><p>non-replicating sample name</p>
</dd>
<dt>ratio</dt><dd><p>ratio value in the current bin</p>
</dd>
<dt>ratioFactor</dt><dd><p>adjustment factor used for the current ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>S phase sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204358">SRA</a>;
G2 sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204357">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(W303)
</code></pre>

<hr>
<h2 id='W303_G2'>Sequence read coverage for wild type S.cerevisiae W303 non-replicating sample.</h2><span id='topic+W303_G2'></span>

<h3>Description</h3>

<p>Sequence read coverage for wild type non-replicating sample
(T7107 strain). The cells were stained with DNA dye and sorted
based on DNA content into G2/M phase fraction. Extracted DNA
was sequenced and mapped to sacCer3 genome. Unique reads were
calculated in 1 kb genomic bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(W303_G2)
</code></pre>


<h3>Format</h3>

<p>data frame with 11350 rows and 5 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name</dt><dd><p>sample name</p>
</dd>
<dt>score</dt><dd><p>read number in current bin</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/sra/SRX204357">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(W303_G2)
</code></pre>

<hr>
<h2 id='W303_S'>Sequence read coverage for wild type S.cerevisiae W303 replicating sample</h2><span id='topic+W303_S'></span>

<h3>Description</h3>

<p>Sequence read coverage for wild type replicating sample
(T7107 strain). The cells were stained with DNA dye and sorted
based on DNA content into S phase fraction. Extracted DNA
was sequenced and mapped to sacCer3 genome. Unique reads were
calculated in 1 kb genomic bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(W303_S)
</code></pre>


<h3>Format</h3>

<p>data frame with 11820 rows and 5 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name</dt><dd><p>sample name</p>
</dd>
<dt>score</dt><dd><p>read number in current bin</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/sra/SRX204358">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(W303_S)
</code></pre>

<hr>
<h2 id='W303norm'>Normalised sequence read coverage ratios for wild type S.cerevisiae W303</h2><span id='topic+W303norm'></span>

<h3>Description</h3>

<p>Sequence read coverage ratios for wild type sample
(T7107 strain). The cells were stained with DNA dye and sorted
based on DNA content into S or G2/M phase fractions. Extracted
DNA was sequenced and mapped to sacCer3 genome. Unique reads
for replicating (S) and non-replicating (G2/M) samples were
calculated in 1 kb genomic bins. The ratio was created by
dividing 'score' values from replicating sample by non-
replicating sample 'score' values, adjusted by total number
of reads. The ratio values were further adjusted by multiplying
them by 1.41 to put the values onto biologically relevant
relative copy number scale from 1 to 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(W303norm)
</code></pre>


<h3>Format</h3>

<p>data frame with 11340 rows and 7 variables:
</p>

<dl>
<dt>chrom</dt><dd><p>short chromosome name</p>
</dd>
<dt>chromStart</dt><dd><p>left chromosome coordinate</p>
</dd>
<dt>chromEnd</dt><dd><p>right chromosome coordinate</p>
</dd>
<dt>name.rep</dt><dd><p>replicating sample name</p>
</dd>
<dt>name.nonRep</dt><dd><p>non-replicating sample name</p>
</dd>
<dt>ratio</dt><dd><p>ratio value in the current bin</p>
</dd>
<dt>ratioFactor</dt><dd><p>adjustment factor used for the current ratio</p>
</dd>
</dl>



<h3>Source</h3>

<p>S phase sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204358">SRA</a>;
G2 sample: <a href="https://www.ncbi.nlm.nih.gov/sra/SRX204357">SRA</a>
</p>


<h3>References</h3>

<p>Natsume et al. (2013) Mol Cell 50(5):661-74
(<a href="https://pubmed.ncbi.nlm.nih.gov/23746350">PubMed</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(W303norm)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
