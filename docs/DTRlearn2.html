<!DOCTYPE html><html><head><title>Help for package DTRlearn2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DTRlearn2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adhd'>
<p>A 2-stage SMART data of children with ADHD</p></a></li>
<li><a href='#owl'>
<p>Integrated Outcome-weighted Learning for Estimating Optimal DTRs</p></a></li>
<li><a href='#predict.owl'>
<p>Predict from a Fitted &quot;owl&quot; Object</p></a></li>
<li><a href='#predict.ql'>
<p>Predict from a Fitted &quot;ql&quot; Object</p></a></li>
<li><a href='#ql'>
<p>Q-learning for Estimating Optimal DTRs</p></a></li>
<li><a href='#sim_Kstage'>
<p>Simulate a K-stage Sequential Multiple Assignment Randomized Trial (SMART) data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Statistical Learning Methods for Optimizing Dynamic Treatment
Regimes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yuan Chen &lt;irene.yuan.chen@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>We provide a comprehensive software to estimate general K-stage DTRs from SMARTs with Q-learning and a variety of outcome-weighted learning methods. Penalizations are allowed for variable selection and model regularization. With the outcome-weighted learning scheme, different loss functions - SVM hinge loss, SVM ramp loss, binomial deviance loss, and L2 loss - are adopted to solve the weighted classification problem at each stage; augmentation in the outcomes is allowed to improve efficiency. The estimated DTR can be easily applied to a new sample for individualized treatment recommendations or DTR evaluation.</td>
</tr>
<tr>
<td>Depends:</td>
<td>kernlab,MASS,Matrix,foreach,glmnet, R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-22 15:21:20 UTC; YChen</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-04-22 15:52:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='adhd'>
A 2-stage SMART data of children with ADHD
</h2><span id='topic+adhd'></span>

<h3>Description</h3>

<p>We provide a two-stage sequential multiple assignment randomized trial (SMART) data of 150 children with ADHD mimicking a real world study. At the first stage, children were randomized to treatment of low-intensity behavioral modification (BMOD) or low-intensity methamphetamine (MED) with equal probability. At second stage, children were randomized to treatment of low-intensity BMOD + low-intensity MED, or high-intensity BMOD with equal probability. The primary outcome of study was children's school performance score ranging from 1 to 5 assessed at the end of the study for all participants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("adhd")</code></pre>


<h3>Format</h3>

<p>A data frame with 150 observations on the following 11 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>IDs of the 150 children</p>
</dd>
<dt><code>o11</code></dt><dd><p>baseline covariate coded as 0/1: diagnosed with ODD (oppositional defiant disorder) before the first-stage intervention</p>
</dd>
<dt><code>o12</code></dt><dd><p>baseline covariate: ADHD score at the end of the previous school year (ranging from 0 to 3, larger values for fewer ADHD symptoms)</p>
</dd>
<dt><code>o13</code></dt><dd><p>baseline covariate coded as 0/1: receiving medication during the previous school year</p>
</dd>
<dt><code>o14</code></dt><dd><p>baseline covariate coded as 0/1: race - white (coded 1) versus nonwhite (coded 0)</p>
</dd>
<dt><code>a1</code></dt><dd><p>first-stage intervention coded as -1/1: -1 for low-intensity methamphetamine (MEDS), 1 for low-intensity behavioral modification (BMOD)</p>
</dd>
<dt><code>r</code></dt><dd><p>first-stage response indicator coded as 0/1</p>
</dd>
<dt><code>o21</code></dt><dd><p>intermediate outcome: number of months until non-response (maximum: 8 months, NA for responders)</p>
</dd>
<dt><code>o22</code></dt><dd><p>intermediate outcome coded as 0/1: adherence to the first-stage intervention, 1 for high adherence</p>
</dd>
<dt><code>a2</code></dt><dd><p>second-stage intervention coded as -1/1: -1 for low-intensity BMOD + MEDS, 1 for high-intensity BMOD</p>
</dd>
<dt><code>y</code></dt><dd><p>primary outcome (continuous): school performance at the end of the school year (ranging from 1 to 5, higher values reflect better performance)</p>
</dd>
</dl>



<h3>References</h3>

<p>Pelham Jr, W. E., &amp; Fabiano, G. A. (2008). Evidence-based psychosocial treatments for attention-deficit/hyperactivity disorder. Journal of Clinical Child &amp; Adolescent Psychology, 37(1), 184-214.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adhd)
attach(adhd)
n = length(a1)
H1 = scale(cbind(o11, o12, o13, o14))
H2 = scale(cbind(H1, a1, H1*a1, r, o22, r*a1, o22*a1))
colnames(H2)[12] = "r*a1"
colnames(H2)[13] = "o22*a1"

fit_ql = ql(H=list(H1, H2), AA=list(a1,a2), RR=list(rep(0, n), y),
            pi=list(rep(0.5, n), rep(0.5,n)), K=2, m=3, lasso=TRUE)

c = 2^c(-3:3)
fit_owl = owl(H=list(H1, H2), AA=list(a1,a2), RR=list(rep(0, n), y),
              n=n, K=2, pi=list(rep(0.5, n), rep(0.5,n)), res.lasso = TRUE,
              loss="hinge", kernel="linear", augment=TRUE, c=c, m=3)


</code></pre>

<hr>
<h2 id='owl'>
Integrated Outcome-weighted Learning for Estimating Optimal DTRs
</h2><span id='topic+owl'></span>

<h3>Description</h3>

<p>This function implements a variety of outcome-weighted learning methods for estimating general K-stage DTRs. Different loss functions - SVM hinge loss, SVM ramp loss, binomial deviance loss, and L2 loss - can be adopted to solve the weighted classification problem at each stage. Augmentation in the outcomes is allowed to improve efficiency especially when there are multiple stages with a small sample size. Cross validation is conducted to choose the best tuning parameters if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>owl(H, AA, RR, n, K, pi='estimated', res.lasso=TRUE, loss='hinge', kernel='linear',
augment=FALSE, c=2^(-2:2), sigma=c(0.03,0.05,0.07), s=2.^(-2:2), m=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="owl_+3A_h">H</code></td>
<td>
<p>subject history information before treatment for the <code>K</code> stages. It can be a vector or a matrix when only baseline information is used in estimating the DTR; otherwise, it would be a list of length <code>K</code>. Please standardize all the variables in <code>H</code> to have mean 0 and standard deviation 1 before using <code>H</code> as the input. See details for how to construct H.</p>
</td></tr>
<tr><td><code id="owl_+3A_aa">AA</code></td>
<td>
<p>observed treatment assignments for all subjects at the <code>K</code> stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. </p>
</td></tr>
<tr><td><code id="owl_+3A_rr">RR</code></td>
<td>
<p>observed reward outcomes for all subjects at the <code>K</code> stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. </p>
</td></tr>
<tr><td><code id="owl_+3A_n">n</code></td>
<td>
<p>sample size, number of subjects in the dataset</p>
</td></tr>
<tr><td><code id="owl_+3A_k">K</code></td>
<td>
<p>number of stages</p>
</td></tr>
<tr><td><code id="owl_+3A_pi">pi</code></td>
<td>
<p>treatment assignment probabilities of the observed treatments for all subjects at the K stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. It can be a user specified input if the treatment assignment probabilities are known.  The default is <code>pi="estimated"</code>, that is we estimate the treatment assignment probabilities based on lasso-penalized logistic regressions with <code class="reqn">H_k</code> being the predictors at each stage k.</p>
</td></tr>
<tr><td><code id="owl_+3A_res.lasso">res.lasso</code></td>
<td>
<p>whether or not to use lasso penalty in the regression to take residuals for constructing the weights. The default is <code>res.lasso=TRUE</code>.</p>
</td></tr>
<tr><td><code id="owl_+3A_loss">loss</code></td>
<td>
<p>loss function for sovling the weighted classification problem at each stage. The options are <code>"hinge", "ramp", "logit", "logit.lasso", "l2", "l2.lasso"</code>. <code>"hinge"</code> and <code>"ramp"</code> are for the SVM hinge loss and SVM ramp loss. <code>"logit"</code> and <code>"logit.lasso"</code> are for the binomial deviance loss used in the logistic regression, where lasso penalty is applied under <code>"logit.lasso"</code>. <code>"l2"</code> and <code>"l2.lasso"</code> are for the L2 or square loss, where lasso penalty is applied under <code>"l2.lasso"</code>. The default is <code>loss="hinge"</code>. </p>
</td></tr>
<tr><td><code id="owl_+3A_kernel">kernel</code></td>
<td>
<p>kernel function to use under SVM hinge loss or SVM ramp loss. <code>"linear"</code> and <code>"rbf"</code> kernel are implemented under SVM hinge loss; <code>"linear"</code> kernel is implemented under SVM ramp loss. The default is <code>kernel="linear"</code>.</p>
</td></tr>
<tr><td><code id="owl_+3A_augment">augment</code></td>
<td>
<p>whether or not to use augmented outcomes at each stage. Augmentation is recommended when there are multiple stages and the sample size is small. The default is <code>augment=FALSE</code>.</p>
</td></tr>
<tr><td><code id="owl_+3A_c">c</code></td>
<td>
<p>a vector specifies the values of the regularization parameter C for tuning under SVM hinge loss or SVM ramp loss. The default is <code>c=2^(-2:2)</code>. In practice, a wider range of <code>c</code> can be specified based on the data. </p>
</td></tr>
<tr><td><code id="owl_+3A_sigma">sigma</code></td>
<td>
<p>a vector specifies the values of the positive parameter <code class="reqn">\sigma</code> in the RBF kernel for tuning under SVM hinge loss, i.e., when <code>loss="hinge"</code> and <code>kernel="rbf"</code>. The default is  <code>sigma=c(0.03,0.05,0.07)</code>. In practice, a wider range of <code>sigma</code> can be specified based on the data. </p>
</td></tr>
<tr><td><code id="owl_+3A_s">s</code></td>
<td>
<p>a vector specifies the values of the slope parameter in the SVM ramp loss for tuning, i.e., when <code>loss="ramp"</code> and <code>kernel="linear"</code>.
The default is <code>c=2^(-2:2)</code>. In practice, a wider range of <code>s</code> can be specified based on the data. </p>
</td></tr>
<tr><td><code id="owl_+3A_m">m</code></td>
<td>
<p>number of folds in the m-fold cross validation for choosing the tuning parameters <code>c</code>, <code>sigma</code> or <code>s</code>. It is also used for choosing the tuning parameter of the lasso penalty when <code>res.lasso=T</code>, <code>loss="logit.lasso"</code> or <code>loss="l2.lasso"</code> is specified. The default is <code>m=4</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A patient's history information prior to the treatment at stage k can be constructed recursively as <code class="reqn">H_k = (H_{k-1},  A_{k-1}, R_{k-1}, X_k)</code> with <code class="reqn">H_1=X_1</code>, where <code class="reqn">X_k</code> is subject-specific variables collected at stage k just prior to the treatment, <code class="reqn">A_k</code> is the treatment at stage <code class="reqn">k</code>, and <code class="reqn">R_k</code> is the outcome observed post the treatment at stage <code class="reqn">k</code>. Higher order or interaction terms can also be easily incorporated in <code class="reqn">H_k</code>, e.g., <code class="reqn">H_k = (H_{k-1}, A_{k-1}, R_{k-1}, X_k, H_{k-1}A_{k-1}, R_{k-1}A_{k-1},  X_kA_{k-1})</code>.
</p>


<h3>Value</h3>

<p>A list of results is returned as an object. It contains the following attributes:
</p>
<table>
<tr><td><code>stage1</code></td>
<td>
<p>a list of stage 1 results, ...</p>
</td></tr>
<tr><td><code>stageK</code></td>
<td>
<p>a list of stage K results</p>
</td></tr>
<tr><td><code>valuefun</code></td>
<td>
<p>overall empirical value function under the estimated DTR</p>
</td></tr>
<tr><td><code>benefit</code></td>
<td>
<p>overall empirical benefit function under the estimated DTR</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>treatment assignment probabilities of the observed treatments for each subject at the K stages. It is a list of K vectors. If <code>pi='estimated'</code> is specified as input, the estimated treatment assignment probabilities from lasso-penalized logistic regressions will be returned. </p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>object type corresponding to the specified <code>loss</code> and <code>kernel</code> </p>
</td></tr>
</table>
<p>In each stage's result, a list is returned which consists of
</p>
<table>
<tr><td><code>beta0</code></td>
<td>
<p>estimated coefficient of the intercept in the decision function</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>estimated coefficients of <code class="reqn">H_k</code> in the decision function. It's not returned with RBF kernel under SVM hinge loss.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>fitted decision function for each subject</p>
</td></tr>
<tr><td><code>probability</code></td>
<td>
<p>estimated probability that treatment 1 (vs. -1) is the optimal treatment for each subject in the sample. It's calculated by exp(fit)/(1 + exp(fit)).  </p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>the estimated optimal treatment for each subject</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p>the best regularization parameter C in SVM hinge loss or SVM ramp loss, chosen from the values specified in <code>c</code> via cross validation </p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the best parameter <code class="reqn">\sigma</code> in the RBF kernel, chosen from the values specified in <code>sigma</code> via cross validation </p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>the best slope parameter s in the ramp loss, chosen from the values specified in <code>s</code> via cross validation. </p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of iterations under SVM ramp loss</p>
</td></tr>
<tr><td><code>alpha1</code></td>
<td>
<p>the solution to the Lagrangian dual problem under SVM hinge loss or SVM ramp loss. It is used for constructing the decision function on the new sample. </p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the input H, returned only under SVM hinge loss with RBF kernel. It is used for constructing the RBF kernel on the new sample. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang
</p>
<p>Maintainer: Yuan Chen &lt;yc3281@columbia.edu&gt;&lt;irene.yuan.chen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Liu, Y., Wang, Y., Kosorok, M., Zhao, Y., &amp; Zeng, D. (2014). Robust hybrid learning for estimating personalized dynamic treatment regimens. arXiv preprint. arXiv, 1611.
</p>
<p>Liu, Y., Wang, Y., Kosorok, M., Zhao, Y., &amp; Zeng, D. (2018). Augmented Outcome-weighted Learning for Estimating Optimal Dynamic Treatment Regimens. Statistics in Medicine. In press.
</p>
<p>Zhao, Y., Zeng, D., Rush, A. J., &amp; Kosorok, M. R. (2012). Estimating individualized treatment rules using outcome weighted learning. Journal of the American Statistical Association, 107(499), 1106-1118.
</p>
<p>Zhao, Y. Q., Zeng, D., Laber, E. B., &amp; Kosorok, M. R. (2015). New statistical learning methods for estimating optimal dynamic treatment regimes. Journal of the American Statistical Association, 110(510), 583-598.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.owl">predict.owl</a></code>, <code><a href="#topic+sim_Kstage">sim_Kstage</a></code>, <code><a href="#topic+ql">ql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 2-stage training and test sets
n_train = 100
n_test = 500
n_cluster = 10
pinfo = 10
pnoise = 20

train = sim_Kstage(n_train, n_cluster, pinfo, pnoise, K=2)
H1_train = scale(train$X)
H2_train = scale(cbind(H1_train, train$A[[1]], H1_train * train$A[[1]]))
pi_train = list(rep(0.5, n_train), rep(0.5, n_train))

test = sim_Kstage(n_test, n_cluster, pinfo, pnoise, train$centroids, K=2)
H1_test = scale(test$X)
H2_test = scale(cbind(H1_test, test$A[[1]], H1_test * train$A[[1]]))
pi_test = list(rep(0.5, n_test), rep(0.5, n_test))

# estimate DTR with owl on the training sample
owl_train = owl(H=list(H1_train, H2_train), AA=train$A, RR=train$R, n=n_train, K=2, pi=pi_train,
    loss='hinge', augment=TRUE, m=3)
owl_train$stage1$beta
owl_train$stage1$treatment
owl_train$valuefun

# apply the estimated DTR to the test sample
owl_test = predict(owl_train, H=list(H1_test, H2_test), AA=test$A, RR=test$R, K=2, pi=pi_test)
owl_test$treatment
owl_test$valuefun
</code></pre>

<hr>
<h2 id='predict.owl'>
Predict from a Fitted &quot;owl&quot; Object
</h2><span id='topic+predict.owl'></span>

<h3>Description</h3>

<p>This function serves two purposes from a fitted &quot;owl&quot; object. It can recommend treatments for a new independent sample with partial or full subject features observed up to a certain stage. If subject feautures, treatment assignments and outcomes are fully observed in the new sample, this function can also evaluate the estimated DTR on this new sample, returning the empirical value function and benefit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'owl'
predict(object, H, AA=NULL, RR=NULL, K, pi=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.owl_+3A_object">object</code></td>
<td>
<p>fitted &quot;owl&quot; object</p>
</td></tr>
<tr><td><code id="predict.owl_+3A_h">H</code></td>
<td>
<p>subject history information before treatment at the <code>K</code> stages for all subjects in the new sample. It should be constructed the same way as the H in fitting the owl <code>object</code>. See <code><a href="#topic+owl">owl</a></code> for how to construct H. Partial history information is allowed - when first j (j&lt;=K) stages of H is specified, the first j stage treatments will be recommended.</p>
</td></tr>
<tr><td><code id="predict.owl_+3A_aa">AA</code></td>
<td>
<p>observed treatment assignments at the <code>K</code> stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. If not specified, treatments will be recommended for the new sample instead of DTR evaluation. The default is <code>AA=NULL</code>. </p>
</td></tr>
<tr><td><code id="predict.owl_+3A_rr">RR</code></td>
<td>
<p>observed outcomes at the <code>K</code> stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. If not specified, treatments will be recommended for the new sample instead of DTR evaluation. The default is <code>RR=NULL</code>. </p>
</td></tr>
<tr><td><code id="predict.owl_+3A_k">K</code></td>
<td>
<p>number of stages of <code>H</code> observed in the new sample</p>
</td></tr>
<tr><td><code id="predict.owl_+3A_pi">pi</code></td>
<td>
<p>treatment assignment probabilities of the observed treatments at the K stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. It can be unspecified if one is only interested in treatment recommendations for the new sample. If both <code>AA</code> and <code>RR</code> are specified while <code>pi</code> is not specified, we will estimate the treatment assignment probabilities based on lasso-penalized logistic regressions with predictors being <code class="reqn">H_k</code> at each stage k. The default is <code>pi=NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.owl_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>fit</code></td>
<td>
<p>fitted decision functions at the K stages for each subject in the new sample. It is a list of K vectors.</p>
</td></tr>
<tr><td><code>probability</code></td>
<td>
<p>estimated probability that treatment 1 (vs. -1) is the optimal treatment at each stage for each subject in the new sample. It's calculated by exp(fit)/(1 + exp(fit)). It is a list of K vectors.</p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>recommennded optimal treatments at the K stages for each subject in the new sample. It is a list of K vectors.</p>
</td></tr>
<tr><td><code>valuefun</code></td>
<td>
<p>overall empirical value function under the fitted DTR evaluated on the new sample. It is returned only when <code>AA</code> and <code>RR</code> are fully specified for the K stages.</p>
</td></tr>
<tr><td><code>benefit</code></td>
<td>
<p>overall empirical benefit function under the estimated DTR evaluated on the new sample. It is returned only when <code>AA</code> and <code>RR</code> are fully specified for the K stages.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>treatment assignment probabilities of the assigned treatments at the K stages for each subject in the new sample. If <code>pi</code> is not specified but <code>H</code> and <code>AA</code> are specified for the K stages, the estimated treatment assignment probabilities from lasso-penalized logistic regressions with <code class="reqn">H_k</code> being the predictors at each stage k will be returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang
</p>
<p>Maintainer: Yuan Chen &lt;yc3281@columbia.edu&gt;&lt;irene.yuan.chen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owl">owl</a></code>, <code><a href="#topic+sim_Kstage">sim_Kstage</a></code>, <code><a href="#topic+ql">ql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 2-stage training and test sets
n_train = 100
n_test = 500
n_cluster = 10
pinfo = 10
pnoise = 20

train = sim_Kstage(n_train, n_cluster, pinfo, pnoise, K=2)
H1_train = scale(train$X)
H2_train = scale(cbind(H1_train, train$A[[1]], H1_train * train$A[[1]]))
pi_train = list(rep(0.5, n_train), rep(0.5, n_train))

test = sim_Kstage(n_test, n_cluster, pinfo, pnoise, train$centroids, K=2)
H1_test = scale(test$X)
H2_test = scale(cbind(H1_test, test$A[[1]], H1_test * train$A[[1]]))
pi_test = list(rep(0.5, n_test), rep(0.5, n_test))

# estimate DTR with owl on the training sample
owl_train = owl(H=list(H1_train, H2_train), AA=train$A, RR=train$R, n=n_train, K=2,
    pi=pi_train, loss='hinge', augment=TRUE, m=3)

# evaluate the DTR when full information are observed on the new sample
owl_test = predict(owl_train, H=list(H1_test, H2_test), AA=test$A, RR=test$R, K=2)
owl_test$treatment
owl_test$valuefun
owl_test$pi

# recommned the first-stage treatments only
owl_test2 = predict(owl_train, H=H1_test, K=1)
owl_test$treatment

</code></pre>

<hr>
<h2 id='predict.ql'>
Predict from a Fitted &quot;ql&quot; Object
</h2><span id='topic+predict.ql'></span>

<h3>Description</h3>

<p>This function serves two purposes from a fitted &quot;ql&quot; object. It can recommend treatments for a new independent sample with partial or full subject features observed up to a certain stage. If subject features, treatment assignments and outcomes are fully observed in the new sample, this function can also evaluate the fitted DTR on this new sample, returning the empirical value function and benefit function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ql'
predict(object, H, AA=NULL, RR=NULL, K, pi=NULL, Qopt=FALSE, Qfit=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ql_+3A_object">object</code></td>
<td>
<p>fitted &quot;ql&quot; object</p>
</td></tr>
<tr><td><code id="predict.ql_+3A_h">H</code></td>
<td>
<p>subject history information before treatment at the <code>K</code> stages for all subjects in the new sample. It should be constructed the same way as the H in fitting the ql <code>object</code>. See <code><a href="#topic+ql">ql</a></code> for how to construct H. Partial history information is allowed - when first j (j&lt;=K) stages of H is specified, the first j stage treatments will be recommended.</p>
</td></tr>
<tr><td><code id="predict.ql_+3A_aa">AA</code></td>
<td>
<p>observed treatment assignments at the <code>K</code> stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. If not specified, treatments will be recommended for the new sample instead of DTR evaluation. The default is <code>AA=NULL</code>. </p>
</td></tr>
<tr><td><code id="predict.ql_+3A_rr">RR</code></td>
<td>
<p>observed outcomes at the <code>K</code> stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. If not specified, treatments will be recommended for the new sample instead of DTR evaluation. The default is <code>RR=NULL</code>. </p>
</td></tr>
<tr><td><code id="predict.ql_+3A_k">K</code></td>
<td>
<p>number of stages of <code>H</code> observed in the new sample</p>
</td></tr>
<tr><td><code id="predict.ql_+3A_pi">pi</code></td>
<td>
<p>treatment assignment probabilities of the observed treatments at the K stages for all subjects in the new sample. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. It can be unspecified if one is only interested in treatment recommendations for the new sample. If both <code>AA</code> and <code>RR</code> are specified while <code>pi</code> is not specified, we will estimate the treatment assignment probabilities based on lasso-penalized logistic regressions with predictors being <code class="reqn">H_k</code> at each stage k. The default is <code>pi=NULL</code>.</p>
</td></tr>
<tr><td><code id="predict.ql_+3A_qopt">Qopt</code></td>
<td>
<p>whether to output the predicted optimal Q-function. The default is <code>Qfun=FALSE</code>. </p>
</td></tr>
<tr><td><code id="predict.ql_+3A_qfit">Qfit</code></td>
<td>
<p>whether to output the estimated Q-function under the observed treatments. The default is <code>fitted=FALSE</code>. </p>
</td></tr>
<tr><td><code id="predict.ql_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>treatment</code></td>
<td>
<p>recommennded optimal treatments at the K stages for each subject in the new sample. It is a list of K vectors. If no tailoring variables are learned in the &quot;ql&quot; object, treatments will be assigned randomly with equal probability.</p>
</td></tr>
<tr><td><code>valuefun</code></td>
<td>
<p>overall empirical value function under the fitted DTR evaluated on the new sample. It is returned only when <code>AA</code> and <code>RR</code> are fully specified for the K stages.</p>
</td></tr>
<tr><td><code>benefit</code></td>
<td>
<p>overall empirical benefit function under the estimated DTR evaluated on the new sample. It is returned only when <code>AA</code> and <code>RR</code> are fully specified for the K stages.</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>treatment assignment probabilities of the assigned treatments at the K stages for each subject in the new sample. If <code>pi</code> is not specified but <code>H</code> and <code>AA</code> are specified for the K stages, the estimated treatment assignment probabilities from lasso-penalized logistic regressions with <code class="reqn">H_k</code> being the predictors at each stage k will be returned.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the predicted optimal Q-function if <code>Qfun=TRUE</code>.</p>
</td></tr>
<tr><td><code>fitted</code></td>
<td>
<p>the estimated Q-function under the observed treatment if <code>fitted=TRUE</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang
</p>
<p>Maintainer: Yuan Chen &lt;yc3281@columbia.edu&gt;&lt;irene.yuan.chen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ql">ql</a></code>, <code><a href="#topic+sim_Kstage">sim_Kstage</a></code>, <code><a href="#topic+owl">owl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 2-stage training and test sets
n_train = 100
n_test = 500
n_cluster = 10
pinfo = 10
pnoise = 20

train = sim_Kstage(n_train, n_cluster, pinfo, pnoise, K=2)
H1_train = scale(train$X)
H2_train = scale(cbind(H1_train, train$A[[1]], H1_train * train$A[[1]]))
pi_train = list(rep(0.5, n_train), rep(0.5, n_train))

test = sim_Kstage(n_test, n_cluster, pinfo, pnoise, train$centroids, K=2)
H1_test = scale(test$X)
H2_test = scale(cbind(H1_test, test$A[[1]], H1_test * train$A[[1]]))
pi_test = list(rep(0.5, n_test), rep(0.5, n_test))

# estimate DTR with ql on the training sample
ql_train = ql(H=list(H1_train, H2_train), AA=train$A, RR=train$R, K=2, pi=pi_train, m=3)

# evaluate the DTR when full information are observed on the new sample
ql_test = predict(ql_train, H=list(H1_test, H2_test), AA=test$A, RR=test$R, K=2)
ql_test$treatment
ql_test$valuefun
ql_test$pi

# recommned the first-stage treatments only
ql_test2 = predict(ql_train, H=H1_test, K=1)
ql_test2$treatment

</code></pre>

<hr>
<h2 id='ql'>
Q-learning for Estimating Optimal DTRs
</h2><span id='topic+ql'></span>

<h3>Description</h3>

<p>This function implements Q-learning for estimating general K-stage DTRs. Lasso penalty can be applied for variable selection at each stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ql(H, AA, RR, K, pi='estimated', lasso=TRUE, m=4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ql_+3A_h">H</code></td>
<td>
<p>subject history information before treatment for all subjects at the <code>K</code> stages. It can be a vector or a matrix when only baseline information is used in estimating the DTR; otherwise, it would be a list of length <code>K</code>. Please standardize all the variables in <code>H</code> to have mean 0 and standard deviation 1 before using <code>H</code> as the input. See details for how to construct H.</p>
</td></tr>
<tr><td><code id="ql_+3A_aa">AA</code></td>
<td>
<p>observed treatment assignments for all subjects at the <code>K</code> stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. </p>
</td></tr>
<tr><td><code id="ql_+3A_rr">RR</code></td>
<td>
<p>observed reward outcomes for all subjects at the <code>K</code> stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. </p>
</td></tr>
<tr><td><code id="ql_+3A_k">K</code></td>
<td>
<p>number of stages</p>
</td></tr>
<tr><td><code id="ql_+3A_pi">pi</code></td>
<td>
<p>treatment assignment probabilities of the observed treatments for all subjects at the K stages. It is a vector if <code>K=1</code>, or a list of <code>K</code> vectors corresponding to the <code>K</code> stages. It can be a user specified input if the treatment assignment probabilities are known.  The default is <code>pi="estimated"</code>, that is we estimate the treatment assignment probabilities based on lasso-penalized logistic regressions with <code class="reqn">H_k</code> being the predictors at each stage k.</p>
</td></tr>
<tr><td><code id="ql_+3A_lasso">lasso</code></td>
<td>
<p>specifies whether to add lasso penalty at each stage when fitting the model. The default is <code>lasso=TRUE</code>. </p>
</td></tr>
<tr><td><code id="ql_+3A_m">m</code></td>
<td>
<p>number of folds in the <code>m</code>-fold cross validation. It is used when <code>res.lasso=T</code> is specified. The default is <code>m=4</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>A patient's history information prior to the treatment at stage k can be constructed recursively as <code class="reqn">H_k = (H_{k-1},  A_{k-1}, R_{k-1}, X_k)</code> with <code class="reqn">H_1=X_1</code>, where <code class="reqn">X_k</code> is subject-specific variables collected at stage k just prior to the treatment, <code class="reqn">A_k</code> is the treatment at stage <code class="reqn">k</code>, and <code class="reqn">R_k</code> is the outcome observed post the treatment at stage <code class="reqn">k</code>. Higher order or interaction terms can also be easily incorporated in <code class="reqn">H_k</code>, e.g., <code class="reqn">H_k = (H_{k-1}, A_{k-1},R_{k-1}, X_k, H_{k-1}A_{k-1}, R_{k-1}A_{k-1},  X_kA_{k-1})</code>.
</p>


<h3>Value</h3>

<p>A list of results is returned as an object. It contains the following attributes:
</p>
<table>
<tr><td><code>stage1</code></td>
<td>
<p>a list of stage 1 results, ...</p>
</td></tr>
<tr><td><code>stageK</code></td>
<td>
<p>a list of stage K results</p>
</td></tr>
<tr><td><code>valuefun</code></td>
<td>
<p>overall empirical value function under the estimated DTR</p>
</td></tr>
<tr><td><code>benefit</code></td>
<td>
<p>overall empirical benefit function under the estimated DTR</p>
</td></tr>
<tr><td><code>pi</code></td>
<td>
<p>treatment assignment probabilities of the assigned treatments for each subject at the K stages. If <code>pi='estimated'</code> is specified as input, the estimated treatment assignment probabilities from lasso-penalized logistic regressions will be returned. </p>
</td></tr>
</table>
<p>In each stage's result, a list is returned which consists of
</p>
<table>
<tr><td><code>co</code></td>
<td>
<p>the estimated coefficients of <code class="reqn">(1, H, A, H*A)</code>, the variables in the model at this stage</p>
</td></tr>
<tr><td><code>treatment</code></td>
<td>
<p>the estimated optimal treatment at this stage for each subject in the sample. If no tailoring variables are selected under lasso penalty, treatment will be assigned randomly with equal probability.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>the estimated optimal outcome increment from this stage to the end (the estimated optimal Q-function at this stage) for each subject in the sample </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang
</p>
<p>Maintainer: Yuan Chen &lt;yc3281@columbia.edu&gt;&lt;irene.yuan.chen@gmail.com&gt;
</p>


<h3>References</h3>

<p>Watkins, C. J. C. H. (1989). Learning from delayed rewards (Doctoral dissertation, University of Cambridge).
</p>
<p>Qian, M., &amp; Murphy, S. A. (2011). Performance guarantees for individualized treatment rules. Annals of statistics, 39(2), 1180.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.ql">predict.ql</a></code>, <code><a href="#topic+sim_Kstage">sim_Kstage</a></code>, <code><a href="#topic+owl">owl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulate 2-stage training and test sets
n_train = 100
n_test = 500
n_cluster = 10
pinfo = 10
pnoise = 20

train = sim_Kstage(n_train, n_cluster, pinfo, pnoise, K=2)
H1_train = scale(train$X)
H2_train = scale(cbind(H1_train, train$A[[1]], H1_train * train$A[[1]]))
pi_train = list(rep(0.5, n_train), rep(0.5, n_train))

test = sim_Kstage(n_test, n_cluster, pinfo, pnoise, train$centroids, K=2)
H1_test = scale(test$X)
H2_test = scale(cbind(H1_test, test$A[[1]], H1_test * train$A[[1]]))
pi_test = list(rep(0.5, n_test), rep(0.5, n_test))

ql_train = ql(H=list(H1_train, H2_train), AA=train$A, RR=train$R, K=2, pi=pi_train, m=3)

ql_test = predict(ql_train, H=list(H1_test, H2_test), AA=test$A, RR=test$R, K=2, pi=pi_test)
</code></pre>

<hr>
<h2 id='sim_Kstage'>
Simulate a K-stage Sequential Multiple Assignment Randomized Trial (SMART) data
</h2><span id='topic+sim_Kstage'></span>

<h3>Description</h3>

<p>This function simulates a K-stage SMART data with <code>(pinfo + pnoise)</code> baseline variables from a multivariate Gaussian distribution. The <code>pinfo</code> variables have variance 1 and pairwise correlation 0.2; the <code>pnoise</code> variables have mean 0 and are uncorrelated with each other and with the <code>pinfo</code> variables.
</p>
<p>Subjects are from <code>n_cluster</code> latent groups with equal sizes, and these <code>n_cluster</code> groups are characterized by their differentiable means in the <code>pinfo</code> feature variables. Each latent group has its own optimal treatment sequence, where the optimal treatment for subjects in group g at stage k is generated as <code class="reqn"> A^* = 2( [ g/(2k -1) ]</code> mod 2) - 1. The assigned treatment group (1 or -1) for each subject at each stage is randomly generated with equal probability. The primary outcome is observed only at the end of the trial, which is generated as
<code class="reqn">R = \sum_{k=1}^{K} A_k A_k^* + N(0,1)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_Kstage (n, n_cluster, pinfo, pnoise, centroids=NULL, K)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_Kstage_+3A_n">n</code></td>
<td>
<p>sample size, should be a multiple of <code>n_cluster</code>.</p>
</td></tr>
<tr><td><code id="sim_Kstage_+3A_n_cluster">n_cluster</code></td>
<td>
<p>number of latent groups</p>
</td></tr>
<tr><td><code id="sim_Kstage_+3A_pinfo">pinfo</code></td>
<td>
<p>number of informative baseline variables</p>
</td></tr>
<tr><td><code id="sim_Kstage_+3A_pnoise">pnoise</code></td>
<td>
<p>number of non-informative baseline variables</p>
</td></tr>
<tr><td><code id="sim_Kstage_+3A_centroids">centroids</code></td>
<td>
<p>centroids of the <code>pinfo</code> variables for the <code>n_cluster</code> groups. It is a matrix of dimension <code>n_cluster</code> by <code>pinfo</code>. It's used as the means of the multivariate Gaussians to generate the <code>pinfo</code> variables for the <code>n_cluster</code> groups. For a training set, do not assign centroids, the centroids are generated randomly from N(0,5) by the function. For a test set, one should assign the same set of centroids as the training set.</p>
</td></tr>
<tr><td><code id="sim_Kstage_+3A_k">K</code></td>
<td>
<p>number of stages.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>X</code></td>
<td>
<p>baseline variables. It is a matrix of dimension <code>n</code> by <code>(pinfo + pnoise)</code>.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>treatment assigments for the K-stages. It is a list of K vectors.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>outcomes of the K-stages. It is a list of K vectors. In this simulation setting, no intermediate outcomes are observed, so the first K-1 vectors are vectors of 0.</p>
</td></tr>
<tr><td><code>optA</code></td>
<td>
<p>optimal treatments for the K-stages. It is a list of K vectors.</p>
</td></tr>
<tr><td><code>centroids</code></td>
<td>
<p>centroids of the <code>pinfo</code> variables for the <code>n_cluster</code> groups. It is a matrix of dimension <code>n_cluster</code> by <code>pinfo</code>. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yuan Chen, Ying Liu, Donglin Zeng, Yuanjia Wang
</p>
<p>Maintainer: Yuan Chen &lt;yc3281@columbia.edu&gt;&lt;irene.yuan.chen@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+owl">owl</a></code>, <code><a href="#topic+ql">ql</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_train = 100
n_test = 500
n_cluster = 10
pinfo = 10
pnoise = 20

# simulate a 2-stage training set
train = sim_Kstage(n_train, n_cluster, pinfo, pnoise, K=2)

# simulate an independent 2-stage test set with the same centroids of the training set
test = sim_Kstage(n_test, n_cluster, pinfo, pnoise, train$centroids, K=2)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
