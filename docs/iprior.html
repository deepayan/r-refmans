<!DOCTYPE html><html><head><title>Help for package iprior</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {iprior}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#iprior-package'><p><code>iprior</code>: Regression using priors with Fisher information covariance</p>
kernels.</a></li>
<li><a href='#Accessors'><p>Accessor functions for <code>ipriorMod</code> objects.</p></a></li>
<li><a href='#as.time'><p>Convert <code>difftime</code> class into <code>time</code> class</p></a></li>
<li><a href='#check_theta'><p>Check the structure of the hyperparameters of an I-prior model</p></a></li>
<li><a href='#decimal_place'><p>Cut a numeric vector to a certain number of decimal places</p></a></li>
<li><a href='#eigenCpp'><p>Eigen decomposition of a matrix in C++.</p></a></li>
<li><a href='#fastSquare'><p>Multiplying a symmetric matrix by itself in C++.</p></a></li>
<li><a href='#fastVDiag'><p>Computing a quadratic matrix form in C++.</p></a></li>
<li><a href='#gen_multilevel'><p>Generate simulated data for multilevel models</p></a></li>
<li><a href='#gen_smooth'><p>Generate simulated data for smoothing models</p></a></li>
<li><a href='#gg_colour_hue'><p>Emulate <code>ggplot2</code> default colour palette</p></a></li>
<li><a href='#hsb'><p>High school and beyond dataset</p></a></li>
<li><a href='#hsbsmall'><p>High school and beyond dataset</p></a></li>
<li><a href='#iprior'><p>Fit an I-prior regression model</p></a></li>
<li><a href='#iprior_cv'><p>Perform a cross-validation experiment with the iprior function</p></a></li>
<li><a href='#is.iprior_x'><p>Test <code>iprior</code> objects</p></a></li>
<li><a href='#is.kern_x'><p>Test kernel attributes</p></a></li>
<li><a href='#kernel'><p>Reproducing kernels for the I-prior package</p></a></li>
<li><a href='#kernL'><p>Load the kernel matrices for I-prior models</p></a></li>
<li><a href='#logLik.ipriorMod'><p>Obtain the log-likelihood and deviance of an I-prior model</p></a></li>
<li><a href='#plot.ipriorMod'><p>Plots for I-prior models</p></a></li>
<li><a href='#pollution'><p>Air pollution and mortality</p></a></li>
<li><a href='#predict'><p>Obtain predicted values from <code>ipriorMod</code> objects</p></a></li>
<li><a href='#sigma'><p>Obtain the standard deviation of the residuals 'sigma'</p></a></li>
<li><a href='#summary.ipriorMod'><p>Print and summary method for I-prior models</p></a></li>
<li><a href='#tecator.cv'><p>Results of I-prior cross-validation experiment on Tecator data set</p></a></li>
<li><a href='#update.ipriorMod'><p>Update an I-prior model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Regression Modelling using I-Priors</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.4</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides methods to perform and analyse I-prior regression models.
    Estimation is done either via direct optimisation of the log-likelihood or 
    an EM algorithm.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/haziqj/iprior">https://github.com/haziqj/iprior</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/haziqj/iprior/issues">https://github.com/haziqj/iprior/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3.0)</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>doSNOW, foreach, ggplot2, mvtnorm, Rcpp (&ge; 0.12.5), reshape2,
scales</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>caret, knitr, MASS, R.rsp, rmarkdown, testthat</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-01 19:48:52 UTC; haziqj</td>
</tr>
<tr>
<td>Author:</td>
<td>Haziq Jamil [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Haziq Jamil &lt;haziq.jamil@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-01 23:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='iprior-package'><code>iprior</code>: Regression using priors with Fisher information covariance
kernels.</h2><span id='topic+iprior-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The <code>iprior</code> package provides methods to perform and analyse I-prior
regression models. Estimation is done either via direct optimisation of the
log-likelihood or an EM algorithm.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Haziq Jamil
</p>
<p>Contributors: </p>
<ul>
<li><p>Wicher Bergsma</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Haziq Jamil <a href="mailto:haziq.jamil@gmail.com">haziq.jamil@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="https://phd.haziqj.ml/">https://phd.haziqj.ml/</a>
</p>

<hr>
<h2 id='Accessors'>Accessor functions for <code>ipriorMod</code> objects.</h2><span id='topic+Accessors'></span><span id='topic+get_intercept'></span><span id='topic+get_y'></span><span id='topic+get_size'></span><span id='topic+get_hyp'></span><span id='topic+get_lambda'></span><span id='topic+get_psi'></span><span id='topic+get_lengthscale'></span><span id='topic+get_hurst'></span><span id='topic+get_offset'></span><span id='topic+get_degree'></span><span id='topic+get_se'></span><span id='topic+get_kernels'></span><span id='topic+get_kern_matrix'></span><span id='topic+get_prederror'></span><span id='topic+get_estl'></span><span id='topic+get_method'></span><span id='topic+get_convergence'></span><span id='topic+get_niter'></span><span id='topic+get_time'></span><span id='topic+get_theta'></span>

<h3>Description</h3>

<p>Accessor functions for <code>ipriorMod</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_intercept(object)

get_y(object)

get_size(object, units = "kB", standard = "SI")

get_hyp(object)

get_lambda(object)

get_psi(object)

get_lengthscale(object)

get_hurst(object)

get_offset(object)

get_degree(object)

get_se(object)

get_kernels(object)

get_kern_matrix(object, theta = NULL, newdata)

get_prederror(object, error.type = c("RMSE", "MSE"))

get_estl(object)

get_method(object)

get_convergence(object)

get_niter(object)

get_time(object)

get_theta(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Accessors_+3A_object">object</code></td>
<td>
<p>An <code>ipriorMod</code> object.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_units">units</code></td>
<td>
<p>Units for object size.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_standard">standard</code></td>
<td>
<p>Standard for object size.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_theta">theta</code></td>
<td>
<p>(Optional) Value of hyperparameters to evaluate the kernel
matrix.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_newdata">newdata</code></td>
<td>
<p>(Optional) If not supplied, then a square, symmetric kernel
matrix is returned using the data as input points. Otherwise, the kernel
matrix is evaluated with respect to this set of data as well. It must be a
list of vectors/matrices with similar dimensions to the original data.</p>
</td></tr>
<tr><td><code id="Accessors_+3A_error.type">error.type</code></td>
<td>
<p>(Optional) Report the mean squared error of prediction
(<code>"MSE"</code>), or the root mean squared error of prediction
(<code>"RMSE"</code>)</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>get_intercept()</code>: Obtain the intercept.
</p>
</li>
<li> <p><code>get_y()</code>: Obtain the response variables.
</p>
</li>
<li> <p><code>get_size()</code>: Obtain the object size of the I-prior model.
</p>
</li>
<li> <p><code>get_hyp()</code>: Obtain the hyerparameters of the model (both estimated and fixed ones).
</p>
</li>
<li> <p><code>get_lambda()</code>: Obtain the scale parameters used.
</p>
</li>
<li> <p><code>get_psi()</code>: Obtain the error precision.
</p>
</li>
<li> <p><code>get_lengthscale()</code>: Obtain the lengthscale for the SE kernels used.
</p>
</li>
<li> <p><code>get_hurst()</code>: Obtain the Hurst coefficient of the fBm kernels used.
</p>
</li>
<li> <p><code>get_offset()</code>: Obtain the offset parameters for the polynomial kernels used.
</p>
</li>
<li> <p><code>get_degree()</code>: Obtain the degree of the polynomial kernels used.
</p>
</li>
<li> <p><code>get_se()</code>: Obtain the standard errors of the estimated hyperparameters.
</p>
</li>
<li> <p><code>get_kernels()</code>: Obtain the kernels used.
</p>
</li>
<li> <p><code>get_kern_matrix()</code>: Obtain the kernel matrix of the I-prior model.
</p>
</li>
<li> <p><code>get_prederror()</code>: Obtain the training mean squared error.
</p>
</li>
<li> <p><code>get_estl()</code>: Obtain information on which hyperparameters were
estimated and which were fixed.
</p>
</li>
<li> <p><code>get_method()</code>: Obtain the estimation method used.
</p>
</li>
<li> <p><code>get_convergence()</code>: Obtain the convergence information.
</p>
</li>
<li> <p><code>get_niter()</code>: Obtain the number of iterations performed.
</p>
</li>
<li> <p><code>get_time()</code>: Obtain the time taken to complete the estimation
procedure.
</p>
</li>
<li> <p><code>get_theta()</code>: Extract the theta value at convergence. Note that this
is on an unrestricted scale (see the vignette for details).
</p>
</li></ul>

<hr>
<h2 id='as.time'>Convert <code>difftime</code> class into <code>time</code> class</h2><span id='topic+as.time'></span>

<h3>Description</h3>

<p>Convert <code>difftime</code> class into <code>time</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.time(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.time_+3A_x">x</code></td>
<td>
<p>A <code>difftime</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>time</code> object which contains the time difference and units.
</p>

<hr>
<h2 id='check_theta'>Check the structure of the hyperparameters of an I-prior model</h2><span id='topic+check_theta'></span>

<h3>Description</h3>

<p>Check the structure of the hyperparameters of an I-prior model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_theta(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_theta_+3A_object">object</code></td>
<td>
<p>An <code>ipriorMod</code> object or an <code>ipriorKernel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A printout of the structure of the hyperparameters.
</p>

<hr>
<h2 id='decimal_place'>Cut a numeric vector to a certain number of decimal places</h2><span id='topic+decimal_place'></span><span id='topic+dec_plac'></span>

<h3>Description</h3>

<p>Cut a numeric vector to a certain number of decimal places
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimal_place(x, k = 2)

dec_plac(x, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimal_place_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="decimal_place_+3A_k">k</code></td>
<td>
<p>The number of decimal places.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the correct number of decimal places.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>decimal_place(pi, 3)
decimal_place(c(exp(1), pi, sqrt(2)), 4)

</code></pre>

<hr>
<h2 id='eigenCpp'>Eigen decomposition of a matrix in C++.</h2><span id='topic+eigenCpp'></span>

<h3>Description</h3>

<p>Returns the eigenvalues and eigenvectors of a matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigenCpp(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eigenCpp_+3A_x">X</code></td>
<td>
<p>A symmetric, positive-definite matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fast implementation of eigen for symmetric, positive-definite
matrices. This helps speed up the I-prior EM algorithm.
</p>

<hr>
<h2 id='fastSquare'>Multiplying a symmetric matrix by itself in C++.</h2><span id='topic+fastSquare'></span>

<h3>Description</h3>

<p>Returns the square of a symmetric matrix X.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastSquare(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastSquare_+3A_x">X</code></td>
<td>
<p>A symmetric matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fast implementation of X^2 for symmetric matrices. This helps
speed up the I-prior EM algorithm.
</p>

<hr>
<h2 id='fastVDiag'>Computing a quadratic matrix form in C++.</h2><span id='topic+fastVDiag'></span>

<h3>Description</h3>

<p>Returns XdiagyXT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastVDiag(X, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastVDiag_+3A_x">X</code></td>
<td>
<p>A symmetric, square matrix of dimension <code>n</code> by <code>n</code></p>
</td></tr>
<tr><td><code id="fastVDiag_+3A_y">y</code></td>
<td>
<p>A vector of length <code>n</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A fast implementation of XdiagyXT. This helps speed up
the I-prior EM algorithm.
</p>

<hr>
<h2 id='gen_multilevel'>Generate simulated data for multilevel models</h2><span id='topic+gen_multilevel'></span>

<h3>Description</h3>

<p>Generate simulated data for multilevel models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_multilevel(
  n = 25,
  m = 6,
  sigma_e = 2,
  sigma_u0 = 2,
  sigma_u1 = 2,
  sigma_u01 = -2,
  beta0 = 0,
  beta1 = 2,
  x.jitter = 0.5,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_multilevel_+3A_n">n</code></td>
<td>
<p>Sample size. Input either a single number for a balanced data set,
or a vector of length <code>m</code> indicating the sample size in each group.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_m">m</code></td>
<td>
<p>Number of groups/levels.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_sigma_e">sigma_e</code></td>
<td>
<p>The standard deviation of the errors.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_sigma_u0">sigma_u0</code></td>
<td>
<p>The standard deviation of the random intercept.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_sigma_u1">sigma_u1</code></td>
<td>
<p>The standard deviation of the random slopes.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_sigma_u01">sigma_u01</code></td>
<td>
<p>The covariance of between the random intercept and the
random slope.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_beta0">beta0</code></td>
<td>
<p>The mean of the random intercept.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_beta1">beta1</code></td>
<td>
<p>The mean of the random slope.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_x.jitter">x.jitter</code></td>
<td>
<p>A small amount of jitter is added to the <code>X</code> variables
generated from a normal distribution with mean zero and standard deviation
equal to <code>x.jitter</code>.</p>
</td></tr>
<tr><td><code id="gen_multilevel_+3A_seed">seed</code></td>
<td>
<p>(Optional) Random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the response variable <code>y</code>, the
unidimensional explanatory variables <code>X</code>, and the levels/groups
(factors).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_multilevel()

</code></pre>

<hr>
<h2 id='gen_smooth'>Generate simulated data for smoothing models</h2><span id='topic+gen_smooth'></span>

<h3>Description</h3>

<p>Generate simulated data for smoothing models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_smooth(n = 150, xlim = c(0.2, 4.6), x.jitter = 0.65, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_smooth_+3A_n">n</code></td>
<td>
<p>Sample size.</p>
</td></tr>
<tr><td><code id="gen_smooth_+3A_xlim">xlim</code></td>
<td>
<p>Limits of the <code>X</code> variables to generate from.</p>
</td></tr>
<tr><td><code id="gen_smooth_+3A_x.jitter">x.jitter</code></td>
<td>
<p>A small amount of jitter is added to the <code>X</code> variables
generated from a normal distribution with mean zero and standard deviation
equal to <code>x.jitter</code>.</p>
</td></tr>
<tr><td><code id="gen_smooth_+3A_seed">seed</code></td>
<td>
<p>(Optional) Random seed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing the response variable <code>y</code> and
unidimensional explanatory variable <code>X</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gen_smooth(10)

</code></pre>

<hr>
<h2 id='gg_colour_hue'>Emulate <code>ggplot2</code> default colour palette</h2><span id='topic+gg_colour_hue'></span><span id='topic+gg_color_hue'></span><span id='topic+gg_col_hue'></span><span id='topic+ipriorColPal'></span><span id='topic+ggColPal'></span>

<h3>Description</h3>

<p>Emulate <code>ggplot2</code> default colour palette. <code>ipriorColPal</code> and
<code>ggColPal</code> are DEPRECATED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_colour_hue(x, h = c(0, 360) + 15, c = 100, l = 65)

gg_color_hue(x, h = c(0, 360) + 15, c = 100, l = 65)

gg_col_hue(x, h = c(0, 360) + 15, c = 100, l = 65)

ipriorColPal(x)

ggColPal(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_colour_hue_+3A_x">x</code></td>
<td>
<p>The number of colours required.</p>
</td></tr>
<tr><td><code id="gg_colour_hue_+3A_h">h</code></td>
<td>
<p>Range of hues to use, in [0, 360].</p>
</td></tr>
<tr><td><code id="gg_colour_hue_+3A_c">c</code></td>
<td>
<p>Chroma (intensity of colour), maximum value varies depending on
combination of hue and luminance.</p>
</td></tr>
<tr><td><code id="gg_colour_hue_+3A_l">l</code></td>
<td>
<p>Luminance (lightness), in [0, 100].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the default colour scale for categorical variables in <code>ggplot2</code>.
It maps each level to an evenly spaced hue on the colour wheel. It does not
generate colour-blind safe palettes.
</p>
<p><code>ipriorColPal()</code> used to provide the colour palette for the
<code>iprior</code> package, but this has been changed <code>ggplot2</code>'s colour
palette instead.
</p>

<hr>
<h2 id='hsb'>High school and beyond dataset</h2><span id='topic+hsb'></span>

<h3>Description</h3>

<p>A national longitudinal survey of of students from public and private high
schools in the United States, with information such as students' cognitive
and non-cognitive skills, high school experiences, work experiences and
future plans collected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsb
</code></pre>


<h3>Format</h3>

<p>A data frame of 7185 observations on 3 variables. </p>

<dl>
<dt><code>mathach</code></dt><dd><p>Math achievement.</p>
</dd> <dt><code>ses</code></dt><dd><p>Socio-Economic
status.</p>
</dd> <dt><code>schoolid</code></dt><dd><p>Categorical variable indicating the school
the student went to. Treated as <code><a href="base.html#topic+factor">factor</a></code>.</p>
</dd> </dl>



<h3>Source</h3>

<p><a href="http://www.icpsr.umich.edu/icpsrweb/ICPSR/studies/7896">High
School and Beyond, 1980: A Longitudinal Survey of Students in the United
States (ICPSR 7896)</a>
</p>


<h3>References</h3>

<p>Rabe-Hesketh, S., &amp; Skrondal, A. (2008). <em>Multilevel and
longitudinal modeling using Stata</em>. STATA press.
</p>
<p>Raudenbush, S. W. (2004). <em>HLM 6: Hierarchical linear and
nonlinear modeling</em>. Scientific Software International.
</p>
<p>Raudenbush, S. W., &amp; Bryk, A. S. (2002). <em>Hierarchical
linear models: Applications and data analysis methods</em> (Vol. 1). Sage.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hsb)
str(hsb)
</code></pre>

<hr>
<h2 id='hsbsmall'>High school and beyond dataset</h2><span id='topic+hsbsmall'></span>

<h3>Description</h3>

<p>Smaller subset of <code>hsb</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsbsmall
</code></pre>


<h3>Format</h3>

<p>A data frame of 661 observations on 3 variables. </p>

<dl>
<dt><code>mathach</code></dt><dd><p>Math achievement.</p>
</dd> <dt><code>ses</code></dt><dd><p>Socio-Economic
status.</p>
</dd> <dt><code>schoolid</code></dt><dd><p>Categorical variable indicating the school
the student went to. Treated as <code>factor</code>.</p>
</dd> </dl>



<h3>Details</h3>

<p>A random subset of size 16 out of the original 160 groups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(hsbsmall)
str(hsbsmall)
</code></pre>

<hr>
<h2 id='iprior'>Fit an I-prior regression model</h2><span id='topic+iprior'></span><span id='topic+iprior.default'></span><span id='topic+iprior.formula'></span><span id='topic+iprior.ipriorKernel'></span><span id='topic+iprior.ipriorMod'></span>

<h3>Description</h3>

<p>A function to perform regression using I-priors. The I-prior model parameters
may be estimated in a number of ways: direct minimisation of the marginal
deviance, EM algorithm, fixed hyperparameters, or using a Nystrom kernel
approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
iprior(
  y,
  ...,
  kernel = "linear",
  method = "direct",
  control = list(),
  interactions = NULL,
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL,
  model = list(),
  train.samp,
  test.samp,
  intercept
)

## S3 method for class 'formula'
iprior(
  formula,
  data,
  kernel = "linear",
  one.lam = FALSE,
  method = "direct",
  control = list(),
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL,
  model = list(),
  train.samp,
  test.samp,
  intercept,
  ...
)

## S3 method for class 'ipriorKernel'
iprior(object, method = "direct", control = list(), ...)

## S3 method for class 'ipriorMod'
iprior(object, method = NULL, control = list(), iter.update = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iprior_+3A_y">y</code></td>
<td>
<p>Vector of response variables</p>
</td></tr>
<tr><td><code id="iprior_+3A_...">...</code></td>
<td>
<p>Only used when fitting using non-formula, enter the variables
(vectors or matrices) separated by commas.</p>
</td></tr>
<tr><td><code id="iprior_+3A_kernel">kernel</code></td>
<td>
<p>Character vector indicating the type of kernel for the
variables. Available choices are: </p>
 <ul>
<li><p><code>"linear"</code> -
(default) for the linear kernel </p>
</li>
<li><p><code>"canonical"</code> - alternative
name for <code>"linear"</code> </p>
</li>
<li><p><code>"fbm"</code>, <code>"fbm,0.5"</code> - for the
fBm kernel with Hurst coefficient 0.5 (default) </p>
</li>
<li><p><code>"se"</code>,
<code>"se,1"</code> - for the SE kernel with lengthscale 1 (default)
</p>
</li>
<li><p><code>"poly"</code>, <code>"poly2"</code>, <code>"poly2,0"</code> - for the polynomial
kernel of degree 2 with offset 0 (default) </p>
</li>
<li><p><code>"pearson" - for the
Pearson kernel</code></p>
</li></ul>
<p> The <code>kernel</code> argument can also be a vector of length
equal to the number of variables, therefore it is possible to specify
different kernels for each variables. Note that factor type variables are
assigned the Pearson kernel by default, and that non-factor types can be
forced to use the Pearson kernel (not recommended).</p>
</td></tr>
<tr><td><code id="iprior_+3A_method">method</code></td>
<td>
<p>The estimation method. One of: </p>
 <ul>
<li><p><code>"direct"</code>
- for the direct minimisation of the marginal deviance using
<code>optim()</code>'s L-BFGS method </p>
</li>
<li><p><code>"em"</code> - for the EM algorithm
</p>
</li>
<li><p><code>"mixed"</code> - combination of the direct and EM methods
</p>
</li>
<li><p><code>"fixed"</code> - for just obtaining the posterior regression function
with fixed hyperparameters (default method when setting <code>fixed.hyp =
TRUE</code>) </p>
</li>
<li><p><code>"canonical"</code> - an efficient estimation method which
takes advantage of the structure of the linear kernel </p>
</li></ul>
</td></tr>
<tr><td><code id="iprior_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control options for the estimation
procedure: </p>
 <dl>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations
for the quasi-Newton optimisation or the EM algorithm. Defaults to
<code>100</code>.</p>
</dd> <dt><code>em.maxit</code></dt><dd><p>For <code>method = "mixed"</code>, the number
of EM steps before switching to direct optimisation. Defaults to <code>5</code>.</p>
</dd>
<dt><code>stop.crit</code></dt><dd><p>The stopping criterion for the EM and L-BFGS
algorithm, which is the difference in successive log-likelihood values.
Defaults to <code>1e-8</code>.</p>
</dd> <dt><code>theta0</code></dt><dd><p>The initial values for the
hyperparameters. Defaults to random starting values.</p>
</dd>
<dt><code>report</code></dt><dd><p>The interval of reporting for the <code>optim()</code>
function.</p>
</dd> <dt><code>restarts</code></dt><dd><p>The number of random restarts to perform.
Defaults to <code>0</code>. It's also possible to set it to <code>TRUE</code>, in which
case the number of random restarts is set to the total number of available
cores.</p>
</dd> <dt><code>no.cores</code></dt><dd><p>The number of cores in which to do random
restarts. Defaults to the total number of available cores.</p>
</dd>
<dt><code>omega</code></dt><dd><p>The overrelaxation parameter for the EM algorithm - a
value between 0 and 1.</p>
</dd></dl>
</td></tr>
<tr><td><code id="iprior_+3A_interactions">interactions</code></td>
<td>
<p>Character vector to specify the interaction terms. When
using formulas, this is specified automatically, so is not required. Syntax
is <code>"a:b"</code> to indicate variable <code>a</code> interacts with variable
<code>b</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_est.lambda">est.lambda</code></td>
<td>
<p>Logical. Estimate the scale parameters? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_est.hurst">est.hurst</code></td>
<td>
<p>Logical. Estimate the Hurst coefficients for fBm kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_est.lengthscale">est.lengthscale</code></td>
<td>
<p>Logical. Estimate the lengthscales for SE kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_est.offset">est.offset</code></td>
<td>
<p>Logical. Estimate the offsets for polynomial kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_est.psi">est.psi</code></td>
<td>
<p>Logical. Estimate the error precision? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_fixed.hyp">fixed.hyp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then no hyperparameters are
estimated, i.e. all of the above <code>est.x</code> are set to <code>FALSE</code>, and
vice versa. If <code>NULL</code> (default) then all of the <code>est.x</code> defaults
are respected.</p>
</td></tr>
<tr><td><code id="iprior_+3A_lambda">lambda</code></td>
<td>
<p>Initial/Default scale parameters. Relevant especially if
<code>est.lambda = FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_psi">psi</code></td>
<td>
<p>Initial/Default value for error precision. Relevant especially if
<code>est.psi = FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_nystrom">nystrom</code></td>
<td>
<p>Either logical or an integer indicating the number of Nystrom
samples to take. Defaults to <code>FALSE</code>. If <code>TRUE</code>, then
approximately 10% of the sample size is used for the Nystrom
approximation.</p>
</td></tr>
<tr><td><code id="iprior_+3A_nys.seed">nys.seed</code></td>
<td>
<p>The random seed for the Nystrom sampling. Defaults to
<code>NULL</code>, which means the random seed is not fixed.</p>
</td></tr>
<tr><td><code id="iprior_+3A_model">model</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="iprior_+3A_train.samp">train.samp</code></td>
<td>
<p>(Optional) A vector indicating which of the data points
should be used for training, and the remaining used for testing.</p>
</td></tr>
<tr><td><code id="iprior_+3A_test.samp">test.samp</code></td>
<td>
<p>(Optional) Similar to <code>train.samp</code>, but on test samples
instead.</p>
</td></tr>
<tr><td><code id="iprior_+3A_intercept">intercept</code></td>
<td>
<p>Optional intercept term.</p>
</td></tr>
<tr><td><code id="iprior_+3A_formula">formula</code></td>
<td>
<p>The formula to fit when using formula interface.</p>
</td></tr>
<tr><td><code id="iprior_+3A_data">data</code></td>
<td>
<p>Data frame containing variables when using formula interface.</p>
</td></tr>
<tr><td><code id="iprior_+3A_one.lam">one.lam</code></td>
<td>
<p>Logical. When using formula input, this is a convenient way of
letting the function know to treat all variables as a single variable (i.e.
shared scale parameter). Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_+3A_object">object</code></td>
<td>
<p>An <code>ipriorKernel</code> or <code>ipriorMod</code> object.</p>
</td></tr>
<tr><td><code id="iprior_+3A_iter.update">iter.update</code></td>
<td>
<p>The number of iterations to perform when calling the
function on an <code>ipriorMod</code> object. Defaults to <code>100</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>iprior()</code> function is able to take formula based input and
non-formula. When not using formula, the syntax is as per the default S3
method. That is, the response variable is the vector <code>y</code>, and any
explanatory variables should follow this, and separated by commas.
</p>
<p>As described <a href="#topic+kernL">here</a>, the model can be loaded first into an
<code>ipriorKernel</code> object, and then passed to the <code>iprior()</code> function
to perform the estimation.
</p>


<h3>Value</h3>

<p>An <code>ipriorMod</code> object. Several accessor functions have been
written to obtain pertinent things from the <code>ipriorMod</code> object. The
<code>print()</code> and <code>summary()</code> methods display the relevant model
information.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>iprior(ipriorKernel)</code>: Takes in object of type <code>ipriorKernel</code>, a loaded and
prepared I-prior model, and proceeds to estimate it.
</p>
</li>
<li> <p><code>iprior(ipriorMod)</code>: Re-run or continue running the EM algorithm from last
attained parameter values in object <code>ipriorMod</code>.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="stats.html#topic+optim">optim</a>, <a href="#topic+update.ipriorMod">update</a>,
<a href="#topic+check_theta">check_theta</a>, print, summary, plot, coef, sigma,
fitted, predict, logLik, deviance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Formula based input
(mod.stackf &lt;- iprior(stack.loss ~ Air.Flow + Water.Temp + Acid.Conc.,
                      data = stackloss))
mod.toothf &lt;- iprior(len ~ supp * dose, data = ToothGrowth)
summary(mod.toothf)

# Non-formula based input
mod.stacknf &lt;- iprior(y = stackloss$stack.loss,
                      Air.Flow = stackloss$Air.Flow,
                      Water.Temp = stackloss$Water.Temp,
                      Acid.Conc. = stackloss$Acid.Conc.)
mod.toothnf &lt;- iprior(y = ToothGrowth$len, ToothGrowth$supp, ToothGrowth$dose,
                      interactions = "1:2")

# Formula based model option one.lam = TRUE
# Sets a single scale parameter for all variables
modf &lt;- iprior(stack.loss ~ ., data = stackloss, one.lam = TRUE)
modnf &lt;- iprior(y = stackloss$stack.loss, X = stackloss[1:3])
all.equal(coef(modnf), coef(modnf))  # both models are equivalent

# Fit models using different kernels
dat &lt;- gen_smooth(n = 100)
mod &lt;- iprior(y ~ X, dat, kernel = "fbm")  # Hurst = 0.5 (default)
mod &lt;- iprior(y ~ X, dat, kernel = "poly3")  # polynomial degree 3

# Fit models using various estimation methods
mod1 &lt;- iprior(y ~ X, dat)
mod2 &lt;- iprior(y ~ X, dat, method = "em")
mod3 &lt;- iprior(y ~ X, dat, method = "canonical")
mod4 &lt;- iprior(y ~ X, dat, method = "mixed")
mod5 &lt;- iprior(y ~ X, dat, method = "fixed", lambda = coef(mod1)[1],
               psi = coef(mod1)[2])
c(logLik(mod1), logLik(mod2), logLik(mod3), logLik(mod4),
  logLik(mod5))

## Not run: 

# For large data sets, it is worth trying the Nystrom method
mod &lt;- iprior(y ~ X, gen_smooth(5000), kernel = "se", nystrom = 50,
              est.lengthscale = TRUE)  # a bit slow
plot_fitted(mod, ci = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='iprior_cv'>Perform a cross-validation experiment with the iprior function</h2><span id='topic+iprior_cv'></span><span id='topic+iprior_cv.default'></span><span id='topic+iprior_cv.formula'></span>

<h3>Description</h3>

<p>A convenience function to perform a k-fold cross-validation experiment and
obtain mean squared error of prediction. Most of the arguments are similar to
<code>iprior()</code> and <code>kernL()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
iprior_cv(
  y,
  ...,
  folds = 2,
  par.cv = TRUE,
  kernel = "linear",
  method = "direct",
  control = list(),
  interactions = NULL,
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL
)

## S3 method for class 'formula'
iprior_cv(
  formula,
  data,
  folds = 2,
  one.lam = FALSE,
  par.cv = TRUE,
  kernel = "linear",
  method = "direct",
  control = list(),
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iprior_cv_+3A_y">y</code></td>
<td>
<p>Vector of response variables</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_...">...</code></td>
<td>
<p>Only used when fitting using non-formula, enter the variables
(vectors or matrices) separated by commas.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_folds">folds</code></td>
<td>
<p>The number of cross-validation folds. Set equal to sample size
or <code>Inf</code> to perform leave-one-out cross-validation.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_par.cv">par.cv</code></td>
<td>
<p>Logical. Multithreading to fit the models? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_kernel">kernel</code></td>
<td>
<p>Character vector indicating the type of kernel for the
variables. Available choices are: </p>
 <ul>
<li><p><code>"linear"</code> -
(default) for the linear kernel </p>
</li>
<li><p><code>"canonical"</code> - alternative
name for <code>"linear"</code> </p>
</li>
<li><p><code>"fbm"</code>, <code>"fbm,0.5"</code> - for the
fBm kernel with Hurst coefficient 0.5 (default) </p>
</li>
<li><p><code>"se"</code>,
<code>"se,1"</code> - for the SE kernel with lengthscale 1 (default)
</p>
</li>
<li><p><code>"poly"</code>, <code>"poly2"</code>, <code>"poly2,0"</code> - for the polynomial
kernel of degree 2 with offset 0 (default) </p>
</li>
<li><p><code>"pearson" - for the
Pearson kernel</code></p>
</li></ul>
<p> The <code>kernel</code> argument can also be a vector of length
equal to the number of variables, therefore it is possible to specify
different kernels for each variables. Note that factor type variables are
assigned the Pearson kernel by default, and that non-factor types can be
forced to use the Pearson kernel (not recommended).</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_method">method</code></td>
<td>
<p>The estimation method. One of: </p>
 <ul>
<li><p><code>"direct"</code>
- for the direct minimisation of the marginal deviance using
<code>optim()</code>'s L-BFGS method </p>
</li>
<li><p><code>"em"</code> - for the EM algorithm
</p>
</li>
<li><p><code>"mixed"</code> - combination of the direct and EM methods
</p>
</li>
<li><p><code>"fixed"</code> - for just obtaining the posterior regression function
with fixed hyperparameters (default method when setting <code>fixed.hyp =
TRUE</code>) </p>
</li>
<li><p><code>"canonical"</code> - an efficient estimation method which
takes advantage of the structure of the linear kernel </p>
</li></ul>
</td></tr>
<tr><td><code id="iprior_cv_+3A_control">control</code></td>
<td>
<p>(Optional) A list of control options for the estimation
procedure: </p>
 <dl>
<dt><code>maxit</code></dt><dd><p>The maximum number of iterations
for the quasi-Newton optimisation or the EM algorithm. Defaults to
<code>100</code>.</p>
</dd> <dt><code>em.maxit</code></dt><dd><p>For <code>method = "mixed"</code>, the number
of EM steps before switching to direct optimisation. Defaults to <code>5</code>.</p>
</dd>
<dt><code>stop.crit</code></dt><dd><p>The stopping criterion for the EM and L-BFGS
algorithm, which is the difference in successive log-likelihood values.
Defaults to <code>1e-8</code>.</p>
</dd> <dt><code>theta0</code></dt><dd><p>The initial values for the
hyperparameters. Defaults to random starting values.</p>
</dd>
<dt><code>report</code></dt><dd><p>The interval of reporting for the <code>optim()</code>
function.</p>
</dd> <dt><code>restarts</code></dt><dd><p>The number of random restarts to perform.
Defaults to <code>0</code>. It's also possible to set it to <code>TRUE</code>, in which
case the number of random restarts is set to the total number of available
cores.</p>
</dd> <dt><code>no.cores</code></dt><dd><p>The number of cores in which to do random
restarts. Defaults to the total number of available cores.</p>
</dd>
<dt><code>omega</code></dt><dd><p>The overrelaxation parameter for the EM algorithm - a
value between 0 and 1.</p>
</dd></dl>
</td></tr>
<tr><td><code id="iprior_cv_+3A_interactions">interactions</code></td>
<td>
<p>Character vector to specify the interaction terms. When
using formulas, this is specified automatically, so is not required. Syntax
is <code>"a:b"</code> to indicate variable <code>a</code> interacts with variable
<code>b</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_est.lambda">est.lambda</code></td>
<td>
<p>Logical. Estimate the scale parameters? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_est.hurst">est.hurst</code></td>
<td>
<p>Logical. Estimate the Hurst coefficients for fBm kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_est.lengthscale">est.lengthscale</code></td>
<td>
<p>Logical. Estimate the lengthscales for SE kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_est.offset">est.offset</code></td>
<td>
<p>Logical. Estimate the offsets for polynomial kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_est.psi">est.psi</code></td>
<td>
<p>Logical. Estimate the error precision? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_fixed.hyp">fixed.hyp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then no hyperparameters are
estimated, i.e. all of the above <code>est.x</code> are set to <code>FALSE</code>, and
vice versa. If <code>NULL</code> (default) then all of the <code>est.x</code> defaults
are respected.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_lambda">lambda</code></td>
<td>
<p>Initial/Default scale parameters. Relevant especially if
<code>est.lambda = FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_psi">psi</code></td>
<td>
<p>Initial/Default value for error precision. Relevant especially if
<code>est.psi = FALSE</code>.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_nystrom">nystrom</code></td>
<td>
<p>Either logical or an integer indicating the number of Nystrom
samples to take. Defaults to <code>FALSE</code>. If <code>TRUE</code>, then
approximately 10% of the sample size is used for the Nystrom
approximation.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_nys.seed">nys.seed</code></td>
<td>
<p>The random seed for the Nystrom sampling. Defaults to
<code>NULL</code>, which means the random seed is not fixed.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_formula">formula</code></td>
<td>
<p>The formula to fit when using formula interface.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_data">data</code></td>
<td>
<p>Data frame containing variables when using formula interface.</p>
</td></tr>
<tr><td><code id="iprior_cv_+3A_one.lam">one.lam</code></td>
<td>
<p>Logical. When using formula input, this is a convenient way of
letting the function know to treat all variables as a single variable (i.e.
shared scale parameter). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a multicore loop to fit the folds by default, set <code>par.cv = FALSE</code>
to not use multithreading.
</p>


<h3>Value</h3>

<p>An <code>iprior_xv</code> object containing a data frame of the
cross-validated values such as the log-likelihood, training MSE and test
MSE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# 5-fold CV experiment
(mod.cv &lt;- iprior_cv(y ~ X, gen_smooth(100), kernel = "se", folds = 5))

# LOOCV experiment
(mod.cv &lt;- iprior_cv(y ~ X, gen_smooth(100), kernel = "se", folds = Inf))

# Can also get root MSE
print(mod.cv, "RMSE")

## End(Not run)

</code></pre>

<hr>
<h2 id='is.iprior_x'>Test <code>iprior</code> objects</h2><span id='topic+is.iprior_x'></span><span id='topic+is.ipriorMod'></span><span id='topic+is.ipriorKernel'></span><span id='topic+is.nystrom'></span>

<h3>Description</h3>

<p>Test whether an object is an <code>ipriorMod</code>, <code>ipriorKernel</code>, or either
object with Nystrom method enabled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.ipriorMod(x)

is.ipriorKernel(x)

is.nystrom(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.iprior_x_+3A_x">x</code></td>
<td>
<p>An <code>ipriorMod</code> or <code>ipriorKernel</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='is.kern_x'>Test kernel attributes</h2><span id='topic+is.kern_x'></span><span id='topic+is.kern_linear'></span><span id='topic+is.kern_canonical'></span><span id='topic+is.kern_fbm'></span><span id='topic+is.kern_pearson'></span><span id='topic+is.kern_se'></span><span id='topic+is.kern_poly'></span>

<h3>Description</h3>

<p>Test whether an object uses a specific type of kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.kern_linear(x)

is.kern_canonical(x)

is.kern_fbm(x)

is.kern_pearson(x)

is.kern_se(x)

is.kern_poly(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.kern_x_+3A_x">x</code></td>
<td>
<p>An <code>ipriorMod</code> object, <code>ipriorKernel</code> object, a kernel
matrix generated from one of the <code>kern_x()</code> functions, or even simply
just a character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical.
</p>

<hr>
<h2 id='kernel'>Reproducing kernels for the I-prior package</h2><span id='topic+kernel'></span><span id='topic+kernels'></span><span id='topic+kern_canonical'></span><span id='topic+kern_linear'></span><span id='topic+kern_pearson'></span><span id='topic+kern_fbm'></span><span id='topic+kern_se'></span><span id='topic+kern_poly'></span>

<h3>Description</h3>

<p>The kernel functions used in this package are: </p>
 <ul>
<li><p>The
(canonical) linear kernel </p>
</li>
<li><p>The fractional Brownian motion (fBm) kernel
with Hurst index <code class="reqn">\gamma</code> </p>
</li>
<li><p>The Pearson kernel </p>
</li>
<li><p>The (scaled)
<code class="reqn">d</code>-degree polynomial kernel with offset <code class="reqn">c</code> </p>
</li>
<li><p>The squared
exponential (SE) kernel with lengthscale <code class="reqn">l</code> </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>kern_canonical(x, y = NULL, centre = TRUE)

kern_linear(x, y = NULL, centre = TRUE)

kern_pearson(x, y = NULL)

kern_fbm(x, y = NULL, gamma = 0.5, centre = TRUE)

kern_se(x, y = NULL, l = 1, centre = FALSE)

kern_poly(x, y = NULL, c = 0, d = 2, lam.poly = 1, centre = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_x">x</code></td>
<td>
<p>A vector, matrix or data frame.</p>
</td></tr>
<tr><td><code id="kernel_+3A_y">y</code></td>
<td>
<p>(Optional) vector, matrix or data frame. <code>x</code> and <code>y</code> must
have identical column sizes.</p>
</td></tr>
<tr><td><code id="kernel_+3A_centre">centre</code></td>
<td>
<p>Logical. Whether to centre the data (default) or not.</p>
</td></tr>
<tr><td><code id="kernel_+3A_gamma">gamma</code></td>
<td>
<p>The Hurst coefficient for the fBm kernel.</p>
</td></tr>
<tr><td><code id="kernel_+3A_l">l</code></td>
<td>
<p>The lengthscale for the SE kernel.</p>
</td></tr>
<tr><td><code id="kernel_+3A_c">c</code></td>
<td>
<p>The offset for the polynomial kernel. This is a value greater than
zero.</p>
</td></tr>
<tr><td><code id="kernel_+3A_d">d</code></td>
<td>
<p>The degree for the polynomial kernel. This is an integer value
greater than oe equal to two.</p>
</td></tr>
<tr><td><code id="kernel_+3A_lam.poly">lam.poly</code></td>
<td>
<p>The scale parameter for the polynomial kernel.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pearson kernel is used for nominal-type variables, and thus
<code><a href="base.html#topic+factor">factor</a></code>-type variables are treated with the Pearson kernel
automatically when fitting I-prior models. The other kernels are for
continuous variables, and each emits different properties of functions.
</p>
<p>The linear kernel is used for &quot;straight-line&quot; functions. In addition, if
squared, cubic, or higher order terms are to be modelled, then the polynomial
kernel is suitable for this purpose. For smoothing models, the fBm kernel is
preferred, although the SE kernel may be used as well.
</p>


<h3>Value</h3>

<p>A matrix whose <code>[i, j]</code> entries are given by <code class="reqn">h(\code{x[i]},
  \code{y[j]})</code>, with <code>h</code> being the appropriate kernel function. The
matrix has dimensions <code>m</code> by <code>n</code> according to the lengths of
<code>y</code> and <code>x</code> respectively. When a single argument <code>x</code> is
supplied, then <code>y</code> is taken to be equal to <code>x</code>, and a symmetric
<code>n</code> by <code>n</code> matrix is returned.
</p>
<p>The matrix has a <code>"kernel"</code> attribute indicating which type of kernel
function was called.
</p>


<h3>References</h3>

<p><a href="https://phd.haziqj.ml/intro/">https://phd.haziqj.ml/intro/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kern_linear(1:3)
kern_fbm(1:5, 1:3, gamma = 0.7)

</code></pre>

<hr>
<h2 id='kernL'>Load the kernel matrices for I-prior models</h2><span id='topic+kernL'></span><span id='topic+kernL.formula'></span>

<h3>Description</h3>

<p>Load the kernel matrices for I-prior models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernL(
  y,
  ...,
  kernel = "linear",
  interactions = NULL,
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL,
  model = list(),
  train.samp,
  test.samp,
  intercept
)

## S3 method for class 'formula'
kernL(
  formula,
  data,
  kernel = "linear",
  one.lam = FALSE,
  est.lambda = TRUE,
  est.hurst = FALSE,
  est.lengthscale = FALSE,
  est.offset = FALSE,
  est.psi = TRUE,
  fixed.hyp = NULL,
  lambda = 1,
  psi = 1,
  nystrom = FALSE,
  nys.seed = NULL,
  model = list(),
  train.samp,
  test.samp,
  intercept,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernL_+3A_y">y</code></td>
<td>
<p>Vector of response variables</p>
</td></tr>
<tr><td><code id="kernL_+3A_...">...</code></td>
<td>
<p>Only used when fitting using non-formula, enter the variables
(vectors or matrices) separated by commas.</p>
</td></tr>
<tr><td><code id="kernL_+3A_kernel">kernel</code></td>
<td>
<p>Character vector indicating the type of kernel for the
variables. Available choices are: </p>
 <ul>
<li><p><code>"linear"</code> -
(default) for the linear kernel </p>
</li>
<li><p><code>"canonical"</code> - alternative
name for <code>"linear"</code> </p>
</li>
<li><p><code>"fbm"</code>, <code>"fbm,0.5"</code> - for the
fBm kernel with Hurst coefficient 0.5 (default) </p>
</li>
<li><p><code>"se"</code>,
<code>"se,1"</code> - for the SE kernel with lengthscale 1 (default)
</p>
</li>
<li><p><code>"poly"</code>, <code>"poly2"</code>, <code>"poly2,0"</code> - for the polynomial
kernel of degree 2 with offset 0 (default) </p>
</li>
<li><p><code>"pearson" - for the
Pearson kernel</code></p>
</li></ul>
<p> The <code>kernel</code> argument can also be a vector of length
equal to the number of variables, therefore it is possible to specify
different kernels for each variables. Note that factor type variables are
assigned the Pearson kernel by default, and that non-factor types can be
forced to use the Pearson kernel (not recommended).</p>
</td></tr>
<tr><td><code id="kernL_+3A_interactions">interactions</code></td>
<td>
<p>Character vector to specify the interaction terms. When
using formulas, this is specified automatically, so is not required. Syntax
is <code>"a:b"</code> to indicate variable <code>a</code> interacts with variable
<code>b</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_est.lambda">est.lambda</code></td>
<td>
<p>Logical. Estimate the scale parameters? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_est.hurst">est.hurst</code></td>
<td>
<p>Logical. Estimate the Hurst coefficients for fBm kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_est.lengthscale">est.lengthscale</code></td>
<td>
<p>Logical. Estimate the lengthscales for SE kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_est.offset">est.offset</code></td>
<td>
<p>Logical. Estimate the offsets for polynomial kernels?
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_est.psi">est.psi</code></td>
<td>
<p>Logical. Estimate the error precision? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_fixed.hyp">fixed.hyp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then no hyperparameters are
estimated, i.e. all of the above <code>est.x</code> are set to <code>FALSE</code>, and
vice versa. If <code>NULL</code> (default) then all of the <code>est.x</code> defaults
are respected.</p>
</td></tr>
<tr><td><code id="kernL_+3A_lambda">lambda</code></td>
<td>
<p>Initial/Default scale parameters. Relevant especially if
<code>est.lambda = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_psi">psi</code></td>
<td>
<p>Initial/Default value for error precision. Relevant especially if
<code>est.psi = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernL_+3A_nystrom">nystrom</code></td>
<td>
<p>Either logical or an integer indicating the number of Nystrom
samples to take. Defaults to <code>FALSE</code>. If <code>TRUE</code>, then
approximately 10% of the sample size is used for the Nystrom
approximation.</p>
</td></tr>
<tr><td><code id="kernL_+3A_nys.seed">nys.seed</code></td>
<td>
<p>The random seed for the Nystrom sampling. Defaults to
<code>NULL</code>, which means the random seed is not fixed.</p>
</td></tr>
<tr><td><code id="kernL_+3A_model">model</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="kernL_+3A_train.samp">train.samp</code></td>
<td>
<p>(Optional) A vector indicating which of the data points
should be used for training, and the remaining used for testing.</p>
</td></tr>
<tr><td><code id="kernL_+3A_test.samp">test.samp</code></td>
<td>
<p>(Optional) Similar to <code>train.samp</code>, but on test samples
instead.</p>
</td></tr>
<tr><td><code id="kernL_+3A_intercept">intercept</code></td>
<td>
<p>(Optional) Intercept for response variables.</p>
</td></tr>
<tr><td><code id="kernL_+3A_formula">formula</code></td>
<td>
<p>The formula to fit when using formula interface.</p>
</td></tr>
<tr><td><code id="kernL_+3A_data">data</code></td>
<td>
<p>Data frame containing variables when using formula interface.</p>
</td></tr>
<tr><td><code id="kernL_+3A_one.lam">one.lam</code></td>
<td>
<p>Logical. When using formula input, this is a convenient way of
letting the function know to treat all variables as a single variable (i.e.
shared scale parameter). Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ipriorKernel</code> object which contains the relevant material to
be passed to the <code>iprior</code> function for model fitting.
</p>


<h3>See Also</h3>

<p><a href="#topic+iprior">iprior</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
str(ToothGrowth)
(mod &lt;- kernL(y = ToothGrowth$len,
               supp = ToothGrowth$supp,
               dose = ToothGrowth$dose,
               interactions = "1:2"))
kernL(len ~ supp * dose, data = ToothGrowth)  # equivalent formula call

# Choosing different kernels
str(stackloss)
kernL(stack.loss ~ ., stackloss, kernel = "fbm")  # all fBm kernels
kernL(stack.loss ~ ., stackloss, kernel = "FBm")  # cApS dOn't MatTeR
kernL(stack.loss ~ ., stackloss,
       kernel = c("linear", "se", "poly3"))  # different kernels

# Sometimes the print output is too long, can use str() options here
print(mod, strict.width = "cut", width = 30)

</code></pre>

<hr>
<h2 id='logLik.ipriorMod'>Obtain the log-likelihood and deviance of an I-prior model</h2><span id='topic+logLik.ipriorMod'></span><span id='topic+deviance.ipriorMod'></span><span id='topic+logLik.ipriorKernel'></span><span id='topic+deviance.ipriorKernel'></span>

<h3>Description</h3>

<p>This function calculates the log-likelihood value or deviance (twice the
negative log-likelihood) for I-prior models. It works for both
<code>ipriorMod</code> and <code>ipriorKernel</code> class objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
logLik(object, theta = NULL, ...)

## S3 method for class 'ipriorMod'
deviance(object, theta = NULL, ...)

## S3 method for class 'ipriorKernel'
logLik(object, theta = NULL, ...)

## S3 method for class 'ipriorKernel'
deviance(object, theta = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.ipriorMod_+3A_object">object</code></td>
<td>
<p>An object of class <code>ipriorMod</code> or <code>ipriorKernel</code>.</p>
</td></tr>
<tr><td><code id="logLik.ipriorMod_+3A_theta">theta</code></td>
<td>
<p>(Optional) Evaluates the log-likelihood at <code>theta</code>.</p>
</td></tr>
<tr><td><code id="logLik.ipriorMod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>ipriorKernel</code> objects, the log-likelihood or deviance is calculated
at the default parameter values: scale parameters and error precision are
equal to one, while hyperparameters of the kernels (e.g. Hurst index,
lengthscale, etc.) are the default values (see <a href="#topic+kernel">here</a> for
details) or ones that has been specified. For <code>ipriorMod</code> objects, the
log-likelihood or deviance is calculated at the last obtained value from the
estimation method.
</p>
<p>For both types of objects, it is possible to supply parameter values at which
to calculate the log-likelihood/deviance. This makes estimating an I-prior
model more flexible, by first loading the variables into an
<code>ipriorKernel</code> object, and then using an optimiser such as
<code><a href="stats.html#topic+optim">optim</a></code>. Parameters have been transformed so that they can
be optimised unconstrained.
</p>


<h3>See Also</h3>

<p><a href="#topic+check_theta">check_theta</a>.
</p>

<hr>
<h2 id='plot.ipriorMod'>Plots for I-prior models</h2><span id='topic+plot.ipriorMod'></span><span id='topic+plot_resid'></span><span id='topic+plot_fitted_multilevel'></span><span id='topic+plot_fitted'></span><span id='topic+plot_iter'></span><span id='topic+plot_ppc'></span>

<h3>Description</h3>

<p>There are three types of plots that are currently written in the package:
</p>
 <dl>
<dt><code>plot_fitted</code></dt><dd><p>Plot the fitted regression line with
credibility bands.</p>
</dd> <dt><code>plot_predict</code></dt><dd><p>Plot residuals against fitted
values.</p>
</dd> <dt><code>plot_iter</code></dt><dd><p>Plot the progression of the log-likelihood
value over time.</p>
</dd> </dl>
<p> The S3 method <code>plot</code> for class <code>ipriorMod</code>
currently returns <code>plot_fitted</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
plot(x, ...)

plot_resid(x)

plot_fitted_multilevel(
  x,
  X.var = 1,
  grp.var = 1,
  facet = c(2, 3),
  cred.bands = TRUE,
  show.legend = TRUE,
  show.points = TRUE,
  x.lab = NULL,
  y.lab = NULL,
  grp.lab = NULL,
  extrapolate = FALSE
)

plot_fitted(x, X.var = 1, cred.bands = TRUE, size = 1, linetype = "solid")

plot_iter(x, niter.plot = NULL, lab.pos = c("up", "down"))

plot_ppc(x, draws = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ipriorMod_+3A_x">x</code></td>
<td>
<p>An <code>ipriorMod</code> object.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_x.var">X.var</code></td>
<td>
<p>The index of the X variable to plot.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_grp.var">grp.var</code></td>
<td>
<p>Index of the grouping variable for multilevel plots.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_facet">facet</code></td>
<td>
<p>The index of the X variable in which to facet. This is a vector
of maximum length 2.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_cred.bands">cred.bands</code></td>
<td>
<p>Logical. Plot the confidence intervals? Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_show.legend">show.legend</code></td>
<td>
<p>Logical. Show legend?</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_show.points">show.points</code></td>
<td>
<p>Logical. Show data points?</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_x.lab">x.lab</code></td>
<td>
<p>(Optional) X axis label.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_y.lab">y.lab</code></td>
<td>
<p>(Optional) Y axis label.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_grp.lab">grp.lab</code></td>
<td>
<p>(Optional) The name for the groups, which is also the legend
title.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_extrapolate">extrapolate</code></td>
<td>
<p>Logical. Extend the fitted regression line to fill the
plot?</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_size">size</code></td>
<td>
<p>Size of the fitted line</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_linetype">linetype</code></td>
<td>
<p>Type of the fitted line</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_niter.plot">niter.plot</code></td>
<td>
<p>(Optional) Vector of length at most two, indicating the
start and end points of the iterations to plot.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_lab.pos">lab.pos</code></td>
<td>
<p>Adjust the position of the log-likelihood label.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_draws">draws</code></td>
<td>
<p>Number of draws for posterior predictive check.</p>
</td></tr>
<tr><td><code id="plot.ipriorMod_+3A_grp">grp</code></td>
<td>
<p>The index of the groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See ggplot2 documentation for the plotting parameters.
</p>

<hr>
<h2 id='pollution'>Air pollution and mortality</h2><span id='topic+pollution'></span>

<h3>Description</h3>

<p>Data on the relation between weather, socioeconomic, and air pollution
variables and mortality rates in 60 Standard Metropolitan Statistical Areas
(SMSAs) of the USA, for the years 1959-1961.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pollution
</code></pre>


<h3>Format</h3>

<p>A data frame of 16 observations on 16 variables.
</p>

<dl>
<dt><code>Mortality</code></dt><dd><p>Total age-adjusted mortality rate per 100,000.</p>
</dd>
<dt><code>Rain</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Humid</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>JanTemp</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>JulTemp</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Over65</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Popn</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Educ</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Hous</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Dens</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>NonW</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>WhiteCol</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>Poor</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>HC</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>NOx</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
<dt><code>SO2</code></dt><dd><p>Mean annual precipitation in inches.</p>
</dd>
</dl>



<h3>References</h3>

<p>McDonald, G. C. and Schwing, R. C. (1973). Instabilities of
regression estimates relating air pollution to mortality.
<em>Technometrics</em>, 15(3):463-481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pollution)
str(pollution)
</code></pre>

<hr>
<h2 id='predict'>Obtain predicted values from <code>ipriorMod</code> objects</h2><span id='topic+predict'></span><span id='topic+fitted.ipriorMod'></span><span id='topic+predict.ipriorMod'></span><span id='topic+print.ipriorPredict'></span>

<h3>Description</h3>

<p>Obtain predicted values from <code>ipriorMod</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
fitted(object, intervals = FALSE, alpha = 0.05, ...)

## S3 method for class 'ipriorMod'
predict(
  object,
  newdata = list(),
  y.test = NULL,
  intervals = FALSE,
  alpha = 0.05,
  ...
)

## S3 method for class 'ipriorPredict'
print(x, rows = 10, dp = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code>, <code id="predict_+3A_x">x</code></td>
<td>
<p>An <code>ipriorMod</code> object.</p>
</td></tr>
<tr><td><code id="predict_+3A_intervals">intervals</code></td>
<td>
<p>Logical. Calculate the credibility intervals for the fitted
values. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="predict_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the credibility intervals. This is a
number between 0 and 1.</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>Either a data frame when using formula method, or a list of
vectors/matrices if using default method. Either way, the new data must be
structurally similar to the original data used to fit the model.</p>
</td></tr>
<tr><td><code id="predict_+3A_y.test">y.test</code></td>
<td>
<p>(Optional) Test data, in order to compute test error rates.</p>
</td></tr>
<tr><td><code id="predict_+3A_rows">rows</code></td>
<td>
<p>(Optional) The number of values/rows to display.</p>
</td></tr>
<tr><td><code id="predict_+3A_dp">dp</code></td>
<td>
<p>(Optional) Decimal places for the values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>ipriorPredict</code> containing the fitted values,
residuals (observed minus fitted), the training mean squared error, and the
lower and upper intervals (if called).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- gen_smooth(20)
mod &lt;- iprior(y ~ ., dat, kernel = "se")
fitted(mod)
fitted(mod, intervals = TRUE)
predict(mod, gen_smooth(5))

with(dat, mod &lt;&lt;- iprior(y, X, kernel = "poly"))
newdat &lt;- gen_smooth(30)
mod.pred &lt;- predict(mod, list(newdat$X), y.test = newdat$y, intervals = TRUE)
str(mod.pred)
print(mod.pred, row = 5)

</code></pre>

<hr>
<h2 id='sigma'>Obtain the standard deviation of the residuals 'sigma'</h2><span id='topic+sigma'></span><span id='topic+sigma.ipriorMod'></span>

<h3>Description</h3>

<p>Extract the standard deviation of the residuals. For I-prior models, this is
<code>sigma = 1 / sqrt(psi)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
sigma(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sigma_+3A_object">object</code></td>
<td>
<p>An object of class <code>ipriorMod</code>.</p>
</td></tr>
<tr><td><code id="sigma_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.ipriorMod'>Print and summary method for I-prior models</h2><span id='topic+summary.ipriorMod'></span><span id='topic+print.ipriorMod'></span>

<h3>Description</h3>

<p>Print and summary method for I-prior models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
print(x, digits = 5, ...)

## S3 method for class 'ipriorMod'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ipriorMod_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places for the printed coefficients.</p>
</td></tr>
<tr><td><code id="summary.ipriorMod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="summary.ipriorMod_+3A_object">object</code>, <code id="summary.ipriorMod_+3A_x">x</code></td>
<td>
<p>An <code>ipriorMod</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='tecator.cv'>Results of I-prior cross-validation experiment on Tecator data set</h2><span id='topic+tecator.cv'></span>

<h3>Description</h3>

<p>Results of I-prior cross-validation experiment on Tecator data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tecator.cv
</code></pre>


<h3>Format</h3>

<p>Results from iprior_cv cross validation experiment. This is a list of
seven, with each component bearing the results for the linear, quadratic,
cubic, fBm-0.5, fBm-MLE and SE I-prior models. The seventh is a summarised
table of the results.
</p>


<h3>Details</h3>

<p>For the fBm and SE kernels, it seems numerical issues arise when using a
direct optimisation approach. Terminating the algorithm early (say using a
relaxed stopping criterion) seems to help.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Results from the six experiments
print(tecator.cv[[1]], "RMSE")
print(tecator.cv[[2]], "RMSE")
print(tecator.cv[[3]], "RMSE")
print(tecator.cv[[4]], "RMSE")
print(tecator.cv[[5]], "RMSE")
print(tecator.cv[[6]], "RMSE")

# Summary of results
print(tecator.cv[[7]])

## Not run: 

# Prepare data set
data(tecator, package = "caret")
endpoints &lt;- as.data.frame(endpoints)
colnames(endpoints) &lt;- c("water", "fat", "protein")
absorp &lt;- -t(diff(t(absorp)))  # this takes first differences using diff()
fat &lt;- endpoints$fat

# Here is the code to replicate the results
mod1.cv &lt;- iprior_cv(fat, absorp, folds = Inf)
mod2.cv &lt;- iprior_cv(fat, absorp, folds = Inf, kernel = "poly2",
                     est.offset = TRUE)
mod3.cv &lt;- iprior_cv(fat, absorp, folds = Inf, kernel = "poly3",
                     est.offset = TRUE)
mod4.cv &lt;- iprior_cv(fat, absorp, method = "em", folds = Inf, kernel = "fbm",
                     control = list(stop.crit = 1e-2))
mod5.cv &lt;- iprior_cv(fat, absorp, folds = Inf, kernel = "fbm",
                     est.hurst = TRUE, control = list(stop.crit = 1e-2))
mod6.cv &lt;- iprior_cv(fat, absorp, folds = Inf, kernel = "se",
                     est.lengthscale = TRUE, control = list(stop.crit = 1e-2))

tecator_res_cv &lt;- function(mod) {
  res &lt;- as.numeric(apply(mod$res[, -1], 2, mean))  # Calculate RMSE
  c("Training RMSE" = res[1], "Test RMSE" = res[2])
}

tecator_tab_cv &lt;- function() {
  tab &lt;- t(sapply(list(mod1.cv, mod2.cv, mod3.cv, mod4.cv, mod5.cv, mod6.cv),
                  tecator_res_cv))
  rownames(tab) &lt;- c("Linear", "Quadratic", "Cubic", "fBm-0.5", "fBm-MLE",
                     "SE-MLE")
  tab
}

tecator.cv &lt;- list(
  "linear"   = mod1.cv,
  "qudratic" = mod2.cv,
  "cubic"    = mod3.cv,
  "fbm-0.5"  = mod4.cv,
  "fbm-MLE"  = mod5.cv,
  "SE"       = mod6.cv,
  "summary"  = tecator_tab_cv()
)

## End(Not run)


</code></pre>

<hr>
<h2 id='update.ipriorMod'>Update an I-prior model</h2><span id='topic+update.ipriorMod'></span>

<h3>Description</h3>

<p>Update an I-prior model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipriorMod'
update(object, method = NULL, control = list(), iter.update = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.ipriorMod_+3A_object">object</code></td>
<td>
<p>An <code>ipriorMod</code> object.</p>
</td></tr>
<tr><td><code id="update.ipriorMod_+3A_method">method</code></td>
<td>
<p>An optional method. See <a href="#topic+iprior">here</a> for details.</p>
</td></tr>
<tr><td><code id="update.ipriorMod_+3A_control">control</code></td>
<td>
<p>An optional list of controls for the estimation procedure. See
<a href="#topic+iprior">here</a> for details.</p>
</td></tr>
<tr><td><code id="update.ipriorMod_+3A_iter.update">iter.update</code></td>
<td>
<p>The number of additional iterations to update the I-prior
model.</p>
</td></tr>
<tr><td><code id="update.ipriorMod_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
