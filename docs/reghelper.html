<!DOCTYPE html><html><head><title>Help for package reghelper</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reghelper}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#reghelper-package'><p>reghelper: A package to help with running regression analyses.</p></a></li>
<li><a href='#beta'><p>Standardized coefficients of a model.</p></a></li>
<li><a href='#build_model'><p>Incremental block modelling.</p></a></li>
<li><a href='#build_model_q'><p>Incremental block modelling.</p></a></li>
<li><a href='#cell_means'><p>Estimated values of a linear model.</p></a></li>
<li><a href='#cell_means_q'><p>Estimated values of a linear model.</p></a></li>
<li><a href='#graph_model'><p>Graph interactions for fitted models.</p></a></li>
<li><a href='#graph_model_q'><p>Graph interactions for fitted models.</p></a></li>
<li><a href='#ICC'><p>Intra-class correlation.</p></a></li>
<li><a href='#print.simple_slopes'><p>Print simple slopes.</p></a></li>
<li><a href='#sig_regions'><p>Regions of significance for an interaction.</p></a></li>
<li><a href='#simple_slopes'><p>Simple slopes of an interaction.</p></a></li>
<li><a href='#summary.block_lm'><p>Summary functions for build_model block regression models.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Helper Functions for Regression Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-02</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions used to automate commonly used methods in
    regression analysis. This includes plotting interactions, and calculating
    simple slopes, standardized coefficients, regions of significance
    (Johnson &amp; Neyman, 1936; cf. Spiller et al., 2012), etc. See the reghelper
    documentation for more information, documentation, and examples.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jeff-hughes/reghelper">https://github.com/jeff-hughes/reghelper</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeff-hughes/reghelper/issues">https://github.com/jeff-hughes/reghelper/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 1.0.0), rlang, stats, nlme, lme4, MASS, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 0.8.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-02 23:13:01 UTC; jeff</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Hughes [aut, cre],
  David Beiner [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey Hughes &lt;jeff.hughes@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-02 23:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='reghelper-package'>reghelper: A package to help with running regression analyses.</h2><span id='topic+reghelper'></span><span id='topic+reghelper-package'></span>

<h3>Description</h3>

<p>The reghelper package offers numerous functions to make some aspects of
regression models (and similar types of modelling) simpler.
</p>


<h3>Details</h3>

<p>The following methods are currently implemented:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+beta">beta</a></code> </td><td style="text-align: left;"> Calculates standardized beta coefficients.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+build_model">build_model</a></code> </td><td style="text-align: left;"> Allows variables to be added to a series of
  regression models sequentially.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+ICC">ICC</a></code> </td><td style="text-align: left;"> Calculates the intra-class correlation for a
  multi-level model.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+cell_means">cell_means</a></code> </td><td style="text-align: left;"> Calculate the estimated means for a fitted
  model.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+graph_model">graph_model</a></code> </td><td style="text-align: left;"> Easily graph interactions at +/- 1 SD (uses
  ggplot2 package).</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+simple_slopes">simple_slopes</a></code> </td><td style="text-align: left;"> Easily calculate the simple effects of an
  interaction.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code><a href="#topic+sig_regions">sig_regions</a></code> </td><td style="text-align: left;"> Calculate the Johnson-Neyman regions of
  significance for an interaction.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jeffrey Hughes <a href="mailto:jeff.hughes@gmail.com">jeff.hughes@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> David Beiner <a href="mailto:beiner.reghelper@gmail.com">beiner.reghelper@gmail.com</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jeff-hughes/reghelper">https://github.com/jeff-hughes/reghelper</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jeff-hughes/reghelper/issues">https://github.com/jeff-hughes/reghelper/issues</a>
</p>
</li></ul>


<hr>
<h2 id='beta'>Standardized coefficients of a model.</h2><span id='topic+beta'></span><span id='topic+beta.lm'></span><span id='topic+beta.aov'></span><span id='topic+beta.glm'></span>

<h3>Description</h3>

<p><code>beta</code> returns the summary of a linear model where all variables have
been standardized. It takes a regression model and standardizes the variables,
in order to produce standardized (i.e., beta) coefficients rather than
unstandardized (i.e., B) coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta(model, ...)

## S3 method for class 'lm'
beta(model, x = TRUE, y = TRUE, skip = NULL, ...)

## S3 method for class 'aov'
beta(model, x = TRUE, y = TRUE, skip = NULL, ...)

## S3 method for class 'glm'
beta(model, x = TRUE, y = FALSE, skip = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'glm', or 'aov'.</p>
</td></tr>
<tr><td><code id="beta_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
<tr><td><code id="beta_+3A_x">x</code></td>
<td>
<p>Logical. Whether or not to standardize predictor variables.</p>
</td></tr>
<tr><td><code id="beta_+3A_y">y</code></td>
<td>
<p>Logical. Whether or not to standardize criterion variables.</p>
</td></tr>
<tr><td><code id="beta_+3A_skip">skip</code></td>
<td>
<p>A string vector indicating any variables you do <em>not</em> wish
to be standardized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike similar functions, this function properly calculates standardized
estimates for interaction terms (by first standardizing each of the predictor
variables separately, rather than using the standard deviation of the
interaction term itself).
</p>


<h3>Value</h3>

<p>Returns the summary of a regression model, with the output showing 
the standardized coefficients, standard error, t-values, and p-values for
each predictor. The exact form of the values returned depends on the class
of regression model used.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>beta(lm)</code>: Standardized coefficients for a linear model.
</p>
</li>
<li> <p><code>beta(aov)</code>: Standardized coefficients for ANOVA.
</p>
</li>
<li> <p><code>beta(glm)</code>: Standardized coefficients for a generalized linear model.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># iris data, showing use with lm()
model1 &lt;- lm(Sepal.Length ~ Petal.Length + Petal.Width, iris)
beta(model1)  # all three variables standardized

model2 &lt;- lm(Sepal.Width ~ Petal.Width + Species, iris)
beta(model2, skip='Species')  # all variables except Species standardized

# mtcars data, showing use with glm()
model1 &lt;- glm(vs ~ wt + hp, data=mtcars, family='binomial')
beta(model1)  # wt and hp standardized, vs is not by default
</code></pre>

<hr>
<h2 id='build_model'>Incremental block modelling.</h2><span id='topic+build_model'></span>

<h3>Description</h3>

<p><code>build_model</code> allows you to incrementally add terms to a linear
regression model. Given a list of names of variables at each step, this
function will run a series of models, adding the terms for each block
incrementally to &quot;build up&quot; to a final model including all the terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_model(dv, ..., data = NULL, opts = NULL, model = "lm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_model_+3A_dv">dv</code></td>
<td>
<p>The variable name to be used as the dependent variable.</p>
</td></tr>
<tr><td><code id="build_model_+3A_...">...</code></td>
<td>
<p>Pass through variable names (or interaction terms) to add for each
block. To add one term to a block, just pass it through directly; to
add multiple terms, pass it through in a vector or list. Blocks will be
added in the order they are passed to the function, and variables from
previous blocks will be included with each subsequent block, so they do not
need to be repeated.</p>
</td></tr>
<tr><td><code id="build_model_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model. If
not found in <code>data</code>, the variables are taken from the environment from
which the function is called.</p>
</td></tr>
<tr><td><code id="build_model_+3A_opts">opts</code></td>
<td>
<p>List of arguments to be passed to the model function.</p>
</td></tr>
<tr><td><code id="build_model_+3A_model">model</code></td>
<td>
<p>The type of model to use; supports 'lm', 'aov', and 'glm'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note:</strong> Cases with missing data are dropped based on the <em>final</em>
model that includes all the relevant terms. This ensures that all the models
are tested on the same number of cases.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>formulas</code> </td><td style="text-align: left;"> A list of the regression formulas used for each block.
  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>models</code> </td><td style="text-align: left;"> A list of all regression models.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'># 2 blocks: Petal.Length; Petal.Length + Petal.Width
model1 &lt;- build_model(Sepal.Length, Petal.Length, Petal.Width, data=iris, model='lm')
summary(model1)
coef(model1)

# 2 blocks: Species; Species + Petal.Length + Petal.Width + Petal.Length:Petal.Width
model2 &lt;- build_model(Sepal.Length, Species, c(Petal.Length * Petal.Width), data=iris, model='lm')
summary(model2)
coef(model2)
</code></pre>

<hr>
<h2 id='build_model_q'>Incremental block modelling.</h2><span id='topic+build_model_q'></span>

<h3>Description</h3>

<p><code>build_model_q</code> allows you to incrementally add terms to a linear
regression model. Given a list of names of variables at each step, this
function will run a series of models, adding the terms for each block
incrementally to &quot;build up&quot; to a final model including all the terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build_model_q(dv, blocks = NULL, data = NULL, opts = NULL, model = "lm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build_model_q_+3A_dv">dv</code></td>
<td>
<p>String of the variable name to be used as the dependent variable.</p>
</td></tr>
<tr><td><code id="build_model_q_+3A_blocks">blocks</code></td>
<td>
<p>List of variable names (or interaction terms) to add for each
block. Each list element should be a single string with terms for that
block. Variables from previous blocks will be included with each subsequent
block, so they do not need to be repeated.</p>
</td></tr>
<tr><td><code id="build_model_q_+3A_data">data</code></td>
<td>
<p>An optional data frame containing the variables in the model. If
not found in <code>data</code>, the variables are taken from the environment from
which the function is called.</p>
</td></tr>
<tr><td><code id="build_model_q_+3A_opts">opts</code></td>
<td>
<p>List of arguments to be passed to the model function.</p>
</td></tr>
<tr><td><code id="build_model_q_+3A_model">model</code></td>
<td>
<p>The type of model to use; supports 'lm', 'aov', and 'glm'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that in most cases it is easier to use <code><a href="#topic+build_model">build_model</a></code> and
pass variable names in directly instead of strings of variable names.
<code>build_model_q</code> uses standard evaluation in cases where such evaluation
is easier.
</p>
<p><strong>Note:</strong> Cases with missing data are dropped based on the <em>final</em>
model that includes all the relevant terms. This ensures that all the models
are tested on the same number of cases.
</p>


<h3>Value</h3>

<p>A named list with the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>formulas</code> </td><td style="text-align: left;"> A list of the regression formulas used for each block.
  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>models</code> </td><td style="text-align: left;"> A list of all regression models.</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+build_model">build_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 blocks: Petal.Length; Petal.Length + Petal.Width
model1 &lt;- build_model_q('Sepal.Length', list('Petal.Length + Petal.Width'),
    data=iris, model='lm')
summary(model1)
coef(model1)

# 2 blocks: Species; Species + Petal.Length + Petal.Width + Petal.Length:Petal.Width
model2 &lt;- build_model_q('Sepal.Length', list('Species', 'Species + Petal.Length * Petal.Width'),
    data=iris, model='lm')
summary(model2)
coef(model2)
</code></pre>

<hr>
<h2 id='cell_means'>Estimated values of a linear model.</h2><span id='topic+cell_means'></span><span id='topic+cell_means.lm'></span><span id='topic+cell_means.aov'></span><span id='topic+cell_means.glm'></span>

<h3>Description</h3>

<p><code>cell_means</code> calculates the predicted values at specific points, given
a fitted regression model (linear, generalized, or ANOVA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_means(model, ...)

## S3 method for class 'lm'
cell_means(model, ..., levels = NULL)

## S3 method for class 'aov'
cell_means(model, ..., levels = NULL)

## S3 method for class 'glm'
cell_means(model, ..., levels = NULL, type = c("link", "response"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_means_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'aov', or 'glm'.</p>
</td></tr>
<tr><td><code id="cell_means_+3A_...">...</code></td>
<td>
<p>Pass through variable names to add them to the table.</p>
</td></tr>
<tr><td><code id="cell_means_+3A_levels">levels</code></td>
<td>
<p>A list with element names corresponding to some or all of the
variables in the model. Each list element should be a vector with the names
of factor levels (for categorical variables) or numeric points (for
continuous variables) at which to test that variable.</p>
</td></tr>
<tr><td><code id="cell_means_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default 'link' is on the
scale of the linear predictors; the alternative 'response' is on the scale
of the response variable. For more information, see
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function will provide means at -1 SD, the mean, and +1 SD
for continuous variables, and at each level of categorical variables. This
can be overridden with the <code>levels</code> parameter.
</p>
<p>If there are additional covariates in the model other than what are selected
in the function call, these variables will be set to their respective means.
In the case of a categorical covariate, the results will be averaged across
all its levels.
</p>


<h3>Value</h3>

<p>A data frame with a row for each predicted value. The first few
columns identify the level at which each variable in your model was set.
After columns for each variable, the data frame has columns for the
predicted value, the standard error of the predicted mean, and the 95%
confidence interval.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>cell_means(lm)</code>: Estimated values for a linear model.
</p>
</li>
<li> <p><code>cell_means(aov)</code>: Estimated means for ANOVA.
</p>
</li>
<li> <p><code>cell_means(glm)</code>: Estimated values for a generalized linear model.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># iris data
model &lt;- lm(Sepal.Length ~ Petal.Length + Petal.Width, iris)
summary(model)
cell_means(model, Petal.Length)
</code></pre>

<hr>
<h2 id='cell_means_q'>Estimated values of a linear model.</h2><span id='topic+cell_means_q'></span><span id='topic+cell_means_q.lm'></span><span id='topic+cell_means_q.aov'></span><span id='topic+cell_means_q.glm'></span>

<h3>Description</h3>

<p><code>cell_means_q</code> calculates the predicted values at specific points,
given a fitted regression model (linear, generalized, or ANOVA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cell_means_q(model, ...)

## S3 method for class 'lm'
cell_means_q(model, vars = NULL, levels = NULL, ...)

## S3 method for class 'aov'
cell_means_q(model, vars = NULL, levels = NULL, ...)

## S3 method for class 'glm'
cell_means_q(
  model,
  vars = NULL,
  levels = NULL,
  type = c("link", "response"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cell_means_q_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'aov', or 'glm'.</p>
</td></tr>
<tr><td><code id="cell_means_q_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
<tr><td><code id="cell_means_q_+3A_vars">vars</code></td>
<td>
<p>A vector or list with variable names to be added to the table.</p>
</td></tr>
<tr><td><code id="cell_means_q_+3A_levels">levels</code></td>
<td>
<p>A list with element names corresponding to some or all of the
variables in the model. Each list element should be a vector with the names
of factor levels (for categorical variables) or numeric points (for
continuous variables) at which to test that variable.</p>
</td></tr>
<tr><td><code id="cell_means_q_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default 'link' is on the
scale of the linear predictors; the alternative 'response' is on the scale
of the response variable. For more information, see
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, this function will provide means at -1 SD, the mean, and +1 SD
for continuous variables, and at each level of categorical variables. This
can be overridden with the <code>levels</code> parameter.
</p>
<p>If there are additional covariates in the model other than what are selected
in the function call, these variables will be set to their respective means.
In the case of a categorical covariate, the results will be averaged across
all its levels.
</p>
<p>Note that in most cases it is easier to use <code><a href="#topic+cell_means">cell_means</a></code> and
pass variable names in directly instead of strings of variable names.
<code>cell_means_q</code> uses standard evaluation in cases where such evaluation
is easier.
</p>


<h3>Value</h3>

<p>A data frame with a row for each predicted value. The first few
columns identify the level at which each variable in your model was set.
After columns for each variable, the data frame has columns for the
predicted value, the standard error of the predicted mean, and the 95%
confidence interval.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>cell_means_q(lm)</code>: Estimated values for a linear model.
</p>
</li>
<li> <p><code>cell_means_q(aov)</code>: Estimated means for ANOVA.
</p>
</li>
<li> <p><code>cell_means_q(glm)</code>: Estimated values for a generalized linear model.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+cell_means">cell_means</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># iris data
model &lt;- lm(Sepal.Length ~ Petal.Length + Petal.Width, iris)
summary(model)
cell_means_q(model, 'Petal.Length')
</code></pre>

<hr>
<h2 id='graph_model'>Graph interactions for fitted models.</h2><span id='topic+graph_model'></span><span id='topic+graph_model.lm'></span><span id='topic+graph_model.aov'></span><span id='topic+graph_model.glm'></span><span id='topic+graph_model.lme'></span><span id='topic+graph_model.merMod'></span>

<h3>Description</h3>

<p><code>graph_model</code> provides an easy way to graph interactions in fitted
models (linear, generalized linear, hierarchical linear, or ANOVA). Selected
variables will be graphed at +/- 1 SD (if continuous) or at each level of the
factor (if categorical).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_model(model, ...)

## S3 method for class 'lm'
graph_model(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'aov'
graph_model(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'glm'
graph_model(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  type = c("link", "response"),
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'lme'
graph_model(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'merMod'
graph_model(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_model_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'aov', 'glm', 'lme', or
'merMod'.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_y">y</code></td>
<td>
<p>The variable to be plotted on the y-axis. This variable is required
for the graph.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_x">x</code></td>
<td>
<p>The variable to be plotted on the x-axis. This variable is required
for the graph.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_lines">lines</code></td>
<td>
<p>The variable to be plotted using separate lines (optional).</p>
</td></tr>
<tr><td><code id="graph_model_+3A_split">split</code></td>
<td>
<p>The variable to be split among separate graphs (optional).</p>
</td></tr>
<tr><td><code id="graph_model_+3A_errorbars">errorbars</code></td>
<td>
<p>A string indicating what kind of error bars to show.
Acceptable values are &quot;CI&quot; (95% confidence intervals), &quot;SE&quot; (+/-1 standard
error of the predicted means), or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_ymin">ymin</code></td>
<td>
<p>Number indicating the minimum value for the y-axis scale. Default
NULL value will adjust position to the lowest y value.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_ymax">ymax</code></td>
<td>
<p>Number indicating the maximum value for the y-axis scale. Default
NULL value will adjust position to the highest y value.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_labels">labels</code></td>
<td>
<p>A named list with strings for the various plot labels: 'title'
will set the graph title, 'y' sets the y-axis label, 'x' sets the x-axis
label, 'lines' sets the legend label, and 'split' sets the label for the 
facet. If any label is not set, the names of the variables will be used.
Setting a label explicitly to NA will set a label with an empty string.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_bargraph">bargraph</code></td>
<td>
<p>Logical. TRUE will draw a bar graph of the results; FALSE
will draw a line graph of the results.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_draw.legend">draw.legend</code></td>
<td>
<p>Logical. Whether or not to draw legend on the graph.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_dodge">dodge</code></td>
<td>
<p>A numeric value indicating the amount each point on the graph
should be shifted left or right, which can help for readability when points
are close together. Default value is 0, with .1 or .2 probably sufficient
in most cases.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_exp">exp</code></td>
<td>
<p>Logical. If TRUE, the exponential function <code>exp()</code> will be
used to transform the y-axis (i.e., e to the power of y). Useful for
logistic regressions or for converting log-transformed y-values to their
original units.</p>
</td></tr>
<tr><td><code id="graph_model_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default 'link' is on the
scale of the linear predictors; the alternative 'response' is on the scale
of the response variable. For more information, see
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are additional covariates in the model other than what is indicated
to be graphed by the function, these variables will be plotted at their
respective means. In the case of a categorical covariate, the results will be
averaged across all its levels.
</p>


<h3>Value</h3>

<p>A ggplot2 graph of the plotted variables in the model.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>graph_model(lm)</code>: Graphing linear models.
</p>
</li>
<li> <p><code>graph_model(aov)</code>: Graphing ANOVA.
</p>
</li>
<li> <p><code>graph_model(glm)</code>: Graphing generalized linear models.
</p>
</li>
<li> <p><code>graph_model(lme)</code>: Graphing hierarchical linear models (nlme).
</p>
</li>
<li> <p><code>graph_model(merMod)</code>: Graphing hierarchical linear models (lme4).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># iris data
model &lt;- lm(Sepal.Width ~ Sepal.Length * Species, data=iris)
graph_model(model, y=Sepal.Width, x=Sepal.Length, lines=Species)

# Orthodont data
if (require(nlme, quietly=TRUE)) {
    model &lt;- lme(distance ~ age * Sex, data=Orthodont, random=~1|Subject)
    graph_model(model, y=distance, x=age, lines=Sex)
}

# Arabidopsis data
if (require(lme4, quietly=TRUE)) {
    model &lt;- lmer(total.fruits ~ nutrient * amd + rack + (1|gen), data=Arabidopsis)
    graph_model(model, y=total.fruits, x=nutrient, lines=amd)
}
</code></pre>

<hr>
<h2 id='graph_model_q'>Graph interactions for fitted models.</h2><span id='topic+graph_model_q'></span><span id='topic+graph_model_q.lm'></span><span id='topic+graph_model_q.aov'></span><span id='topic+graph_model_q.glm'></span><span id='topic+graph_model_q.lme'></span><span id='topic+graph_model_q.merMod'></span>

<h3>Description</h3>

<p><code>graph_model_q</code> provides an easy way to graph interactions in fitted
models (linear, generalized linear, hierarchical linear, or ANOVA). Selected
variables will be graphed at +/- 1 SD (if continuous) or at each level of the
factor (if categorical).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_model_q(model, ...)

## S3 method for class 'lm'
graph_model_q(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'aov'
graph_model_q(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'glm'
graph_model_q(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  type = c("link", "response"),
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'lme'
graph_model_q(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'merMod'
graph_model_q(
  model,
  y,
  x,
  lines = NULL,
  split = NULL,
  errorbars = c("CI", "SE", "none"),
  ymin = NULL,
  ymax = NULL,
  labels = NULL,
  bargraph = FALSE,
  draw.legend = TRUE,
  dodge = 0,
  exp = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_model_q_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'aov', 'glm', 'lme', or
'merMod'.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_y">y</code></td>
<td>
<p>The variable to be plotted on the y-axis. This variable is required
for the graph.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_x">x</code></td>
<td>
<p>The variable to be plotted on the x-axis. This variable is required
for the graph.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_lines">lines</code></td>
<td>
<p>The variable to be plotted using separate lines (optional).</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_split">split</code></td>
<td>
<p>The variable to be split among separate graphs (optional).</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_errorbars">errorbars</code></td>
<td>
<p>A string indicating what kind of error bars to show.
Acceptable values are &quot;CI&quot; (95% confidence intervals), &quot;SE&quot; (+/-1 standard
error of the predicted means), or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_ymin">ymin</code></td>
<td>
<p>Number indicating the minimum value for the y-axis scale. Default
NULL value will adjust position to the lowest y value.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_ymax">ymax</code></td>
<td>
<p>Number indicating the maximum value for the y-axis scale. Default
NULL value will adjust position to the highest y value.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_labels">labels</code></td>
<td>
<p>A named list with strings for the various plot labels: 'title'
will set the graph title, 'y' sets the y-axis label, 'x' sets the x-axis
label, 'lines' sets the legend label, and 'split' sets the label for the 
facet. If any label is not set, the names of the variables will be used.
Setting a label explicitly to NA will set a label with an empty string.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_bargraph">bargraph</code></td>
<td>
<p>Logical. TRUE will draw a bar graph of the results; FALSE
will draw a line graph of the results.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_draw.legend">draw.legend</code></td>
<td>
<p>Logical. Whether or not to draw legend on the graph.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_dodge">dodge</code></td>
<td>
<p>A numeric value indicating the amount each point on the graph
should be shifted left or right, which can help for readability when points
are close together. Default value is 0, with .1 or .2 probably sufficient
in most cases.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_exp">exp</code></td>
<td>
<p>Logical. If TRUE, the exponential function <code>exp()</code> will be
used to transform the y-axis (i.e., e to the power of y). Useful for
logistic regressions or for converting log-transformed y-values to their
original units.</p>
</td></tr>
<tr><td><code id="graph_model_q_+3A_type">type</code></td>
<td>
<p>The type of prediction required. The default 'link' is on the
scale of the linear predictors; the alternative 'response' is on the scale
of the response variable. For more information, see
<code><a href="stats.html#topic+predict.glm">predict.glm</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are additional covariates in the model other than what is indicated
to be graphed by the function, these variables will be plotted at their
respective means. In the case of a categorical covariate, the results will be
averaged across all its levels.
</p>
<p>Note that in most cases it is easier to use <code><a href="#topic+graph_model">graph_model</a></code> and
pass variable names in directly instead of strings of variable names.
<code>graph_model_q</code> uses standard evaluation in cases where such
evaluation is easier.
</p>


<h3>Value</h3>

<p>A ggplot2 graph of the plotted variables in the model.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>graph_model_q(lm)</code>: Graphing linear models.
</p>
</li>
<li> <p><code>graph_model_q(aov)</code>: Graphing ANOVA.
</p>
</li>
<li> <p><code>graph_model_q(glm)</code>: Graphing generalized linear models.
</p>
</li>
<li> <p><code>graph_model_q(lme)</code>: Graphing hierarchical linear models (nlme).
</p>
</li>
<li> <p><code>graph_model_q(merMod)</code>: Graphing hierarchical linear models (lme4).
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+graph_model">graph_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># iris data
model &lt;- lm(Sepal.Width ~ Sepal.Length * Species, data=iris)
graph_model_q(model, y='Sepal.Width', x='Sepal.Length', lines='Species')

# Orthodont data
if (require(nlme, quietly=TRUE)) {
    model &lt;- lme(distance ~ age * Sex, data=Orthodont, random=~1|Subject)
    graph_model_q(model, y='distance', x='age', lines='Sex')
}

# Arabidopsis data
if (require(lme4, quietly=TRUE)) {
    model &lt;- lmer(total.fruits ~ nutrient * amd + rack + (1|gen), data=Arabidopsis)
    graph_model_q(model, y='total.fruits', x='nutrient', lines='amd')
}
</code></pre>

<hr>
<h2 id='ICC'>Intra-class correlation.</h2><span id='topic+ICC'></span><span id='topic+ICC.lme'></span><span id='topic+ICC.merMod'></span>

<h3>Description</h3>

<p><code>ICC</code> calculates the intra-class correlation (ICC) from a fitted
hierarchical linear model using the 'nlme' or 'lme4' packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICC(model, ...)

## S3 method for class 'lme'
ICC(model, ...)

## S3 method for class 'merMod'
ICC(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICC_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lme' (nlme) or 'merMod' (lme4;
linear, generalized, or nonlinear).</p>
</td></tr>
<tr><td><code id="ICC_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ICC is the proportion of variance that is between-person variance. For
more information, see
<a href="http://davidakenny.net/papers/k&amp;h/MLM_R.pdf">Hoyt &amp; Kenny (2013)</a>.
</p>


<h3>Value</h3>

<p>The intra-class correlation of the model.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>ICC(lme)</code>: Intra-class correlation for lme (nlme).
</p>
</li>
<li> <p><code>ICC(merMod)</code>: Intra-class correlation for lmer (lme4).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># iris data, showing use with lme()
if (require(nlme, quietly=TRUE)) {
    model &lt;- lme(Sepal.Width ~ 1, random=~1|Species, data=iris)
    ICC(model)  # .49 of variance is between-subjects
}

# iris data, showing use with lmer()
if (require(lme4, quietly=TRUE)) {
    model &lt;- lmer(Sepal.Width ~ 1 + (1|Species), data=iris)
    ICC(model)  # .49 of variance is between-subjects
}
</code></pre>

<hr>
<h2 id='print.simple_slopes'>Print simple slopes.</h2><span id='topic+print.simple_slopes'></span>

<h3>Description</h3>

<p><code>print</code> method for class &quot;<code>simple_slopes</code>&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'simple_slopes'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.simple_slopes_+3A_x">x</code></td>
<td>
<p>An object of class &quot;<code>simple_slopes</code>&quot;, usually, a result
of a call to <code><a href="#topic+simple_slopes">simple_slopes</a></code>.</p>
</td></tr>
<tr><td><code id="print.simple_slopes_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="print.simple_slopes_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.</p>
</td></tr>
<tr><td><code id="print.simple_slopes_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+simple_slopes">simple_slopes</a></code>
</p>

<hr>
<h2 id='sig_regions'>Regions of significance for an interaction.</h2><span id='topic+sig_regions'></span><span id='topic+sig_regions.lm'></span><span id='topic+sig_regions.glm'></span>

<h3>Description</h3>

<p><code>sig_regions</code> calculates the Johnson-Neyman (J-N) regions of
significance for an interaction &ndash; the points at which the simple effect of
the categorical predictor changes from non-significant to significant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sig_regions(model, ...)

## S3 method for class 'lm'
sig_regions(model, alpha = 0.05, precision = 4, ...)

## S3 method for class 'glm'
sig_regions(model, alpha = 0.05, precision = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sig_regions_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm' or 'glm' with one two-way
interaction including one categorical predictor and one continuous variable.</p>
</td></tr>
<tr><td><code id="sig_regions_+3A_...">...</code></td>
<td>
<p>Not currently implemented; used to ensure consistency with S3 generic.</p>
</td></tr>
<tr><td><code id="sig_regions_+3A_alpha">alpha</code></td>
<td>
<p>The level at which to test for significance. Default value is
.05.</p>
</td></tr>
<tr><td><code id="sig_regions_+3A_precision">precision</code></td>
<td>
<p>The number of decimal places to which to round the alpha
level (e.g., precision=5 would look for regions of significance at .05000).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a linear or generalized linear model with one two-way
interaction, where one of the predictors in the interaction is categorical
(factor) and the other is continuous. For other types of interaction terms,
use the <code><a href="#topic+simple_slopes">simple_slopes</a></code> function instead.
</p>
<p>For more information about regions of significance, see
<a href="https://www.ssrn.com/abstract=2208103">Spiller, Fitzsimons, Lynch, &amp;
McClelland (2012)</a>.
</p>


<h3>Value</h3>

<p>A named vector with a 'lower' and an 'upper' J-N point. If one or
more of the J-N points fall outside the range of your predictor, the
function will return NA for that point. If your interaction is not
significant, both J-N points will be NA.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>sig_regions(lm)</code>: Johnson-Neyman points for linear models.
</p>
</li>
<li> <p><code>sig_regions(glm)</code>: Johnson-Neyman points for generalized linear models.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+simple_slopes">simple_slopes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mtcars data
mtcars$am &lt;- factor(mtcars$am)  # make 'am' categorical
model &lt;- lm(mpg ~ wt * am, data=mtcars)
summary(model)  # significant interaction
sig_regions(model)
</code></pre>

<hr>
<h2 id='simple_slopes'>Simple slopes of an interaction.</h2><span id='topic+simple_slopes'></span><span id='topic+simple_slopes.lm'></span><span id='topic+simple_slopes.glm'></span><span id='topic+simple_slopes.lme'></span><span id='topic+simple_slopes.merMod'></span>

<h3>Description</h3>

<p><code>simple_slopes</code> calculates all the simple effects of an interaction
in a fitted model (linear, generalized linear, hierarchical linear, or ANOVA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_slopes(model, ...)

## S3 method for class 'lm'
simple_slopes(model, levels = NULL, confint = FALSE, ci.width = 0.95, ...)

## S3 method for class 'glm'
simple_slopes(model, levels = NULL, confint = FALSE, ci.width = 0.95, ...)

## S3 method for class 'lme'
simple_slopes(model, levels = NULL, confint = FALSE, ci.width = 0.95, ...)

## S3 method for class 'merMod'
simple_slopes(
  model,
  levels = NULL,
  confint = FALSE,
  ci.width = 0.95,
  confint.method = c("Wald", "profile", "boot"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_slopes_+3A_model">model</code></td>
<td>
<p>A fitted linear model of type 'lm', 'glm', 'aov', 'lme' (nlme),
or 'merMod' (lme4), with at least one interaction term.</p>
</td></tr>
<tr><td><code id="simple_slopes_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed on to the 'confint' method, if
'confint' is TRUE.</p>
</td></tr>
<tr><td><code id="simple_slopes_+3A_levels">levels</code></td>
<td>
<p>A list with element names corresponding to some or all of the
variables in the model. Each list element should be a vector with the names
of factor levels (for categorical variables) or numeric values (for
continuous variables) at which to test that variable. <strong>Note:</strong> If you
do not include 'sstest' as one of these levels, the function will not test
the simple effects for that variable.</p>
</td></tr>
<tr><td><code id="simple_slopes_+3A_confint">confint</code></td>
<td>
<p>Whether or not to include confidence intervals for each estimate.</p>
</td></tr>
<tr><td><code id="simple_slopes_+3A_ci.width">ci.width</code></td>
<td>
<p>If 'confint' is TRUE, this represents the width of the
confidence intervals to calculate, as a proportion from 0 to 1.</p>
</td></tr>
<tr><td><code id="simple_slopes_+3A_confint.method">confint.method</code></td>
<td>
<p>For 'merMod' models only, specifies what method to use
for computing the confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model includes interactions at different levels (e.g., three two-way
interactions and one three-way interaction), the function will test the
simple effects of the highest-order interaction. If there are multiple
interactions in the highest order, it will test the first one in the model.
If you wish to test simple effects for a different interaction, simply switch
the order in the formula.
</p>
<p>By default, this function will provide slopes at -1 SD, the mean, and +1 SD
for continuous variables, and at each level of categorical variables. This
can be overridden with the <code>levels</code> parameter.
</p>
<p>If a categorical variable with more than two levels is being tested, you may
see multiple rows for that test. One row will be shown for each contrast for
that variable; the name of the contrast is identified in parentheses after 
the 'sstest' label.
</p>


<h3>Value</h3>

<p>A data frame with a row for each simple effect. The first few columns
identify the level at which each variable in your model was set for that
test. A 'sstest' value in a particular column indicates that the simple
slope for this variable was being tested. After columns for each variable,
the data frame has columns for the slope of the test variable, the standard
error, t-value, p-value, and degrees of freedom for the model. For 'merMod'
models, the degrees of freedom and p-values will not appear, as these are
not calculated by the lme4 package.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>simple_slopes(lm)</code>: Simple slopes for linear models.
</p>
</li>
<li> <p><code>simple_slopes(glm)</code>: Simple slopes for generalized linear models.
</p>
</li>
<li> <p><code>simple_slopes(lme)</code>: Simple slopes for hierarchical linear models (nlme).
</p>
</li>
<li> <p><code>simple_slopes(merMod)</code>: Simple slopes for hierarchical linear models (lme4).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># linear model
mtcars$am &lt;- factor(mtcars$am)  # make 'am' categorical
model &lt;- lm(mpg ~ wt * am, data=mtcars)
summary(model)  # significant interaction
simple_slopes(model)
simple_slopes(model,
    levels=list(wt=c(2, 3, 4, 'sstest'), am=c(0, 1, 'sstest')))  # test at specific levels

# generalized linear model
model &lt;- glm(vs ~ gear * wt, data=mtcars, family='binomial')
summary(model)  # marginal interaction
simple_slopes(model)
simple_slopes(model,
    levels=list(gear=c(2, 3, 4, 'sstest'), wt=c(2, 3, 'sstest')))  # test at specific levels

# hierarchical linear model (nlme)
if (require(nlme, quietly=TRUE)) {
    model &lt;- lme(Sepal.Width ~ Sepal.Length * Petal.Length, random=~1|Species, data=iris)
    summary(model)  # significant interaction
    simple_slopes(model)
    simple_slopes(model,
        levels=list(Sepal.Length=c(4, 5, 6, 'sstest'),
        Petal.Length=c(2, 3, 'sstest')))  # test at specific levels
}

# hierarchical linear model (lme4)
if (require(lme4, quietly=TRUE)) {
    model &lt;- lmer(Sepal.Width ~ Sepal.Length * Petal.Length + (1|Species), data=iris)
    summary(model)
    simple_slopes(model)
    simple_slopes(model,
        levels=list(Sepal.Length=c(4, 5, 6, 'sstest'),
        Petal.Length=c(2, 3, 'sstest')))  # test at specific levels
}
</code></pre>

<hr>
<h2 id='summary.block_lm'>Summary functions for build_model block regression models.</h2><span id='topic+summary.block_lm'></span><span id='topic+print.block_lm_summary'></span><span id='topic+coef.block_lm'></span><span id='topic+residuals.block_lm'></span><span id='topic+fitted.block_lm'></span><span id='topic+summary.block_aov'></span><span id='topic+print.block_aov_summary'></span><span id='topic+coef.block_aov'></span><span id='topic+residuals.block_aov'></span><span id='topic+fitted.block_aov'></span><span id='topic+summary.block_glm'></span><span id='topic+print.block_glm_summary'></span><span id='topic+coef.block_glm'></span><span id='topic+residuals.block_glm'></span><span id='topic+fitted.block_glm'></span><span id='topic+block_model_summ'></span>

<h3>Description</h3>

<p>These functions offer useful methods for objects created by the
<code>build_model</code> function: <code>block_lm</code>, <code>block_aov</code>, and
<code>block_glm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'block_lm'
summary(object, ...)

## S3 method for class 'block_lm_summary'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'block_lm'
coef(object, num = NULL, ...)

## S3 method for class 'block_lm'
residuals(object, num = NULL, ...)

## S3 method for class 'block_lm'
fitted(object, num = NULL, ...)

## S3 method for class 'block_aov'
summary(object, ...)

## S3 method for class 'block_aov_summary'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'block_aov'
coef(object, num = NULL, ...)

## S3 method for class 'block_aov'
residuals(object, num = NULL, ...)

## S3 method for class 'block_aov'
fitted(object, num = NULL, ...)

## S3 method for class 'block_glm'
summary(object, ...)

## S3 method for class 'block_glm_summary'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  signif.stars = getOption("show.signif.stars"),
  ...
)

## S3 method for class 'block_glm'
coef(object, num = NULL, ...)

## S3 method for class 'block_glm'
residuals(object, num = NULL, ...)

## S3 method for class 'block_glm'
fitted(object, num = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.block_lm_+3A_object">object</code></td>
<td>
<p>An object of class <code>block_lm</code>, <code>block_aov</code>, or
<code>block_glm</code>, usually, a result of a call to <code><a href="#topic+build_model">build_model</a></code>.</p>
</td></tr>
<tr><td><code id="summary.block_lm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.block_lm_+3A_x">x</code></td>
<td>
<p>An object of class <code>block_lm_summary</code>, <code>block_aov_summary</code>,
or <code>block_glm_summary</code>, usually, a result of a call to
the corresponding <code>summary</code> function (e.g., <code>summary.block_lm</code>).</p>
</td></tr>
<tr><td><code id="summary.block_lm_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits to use when printing.</p>
</td></tr>
<tr><td><code id="summary.block_lm_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Logical. If <code>TRUE</code>, 'significance stars' are printed
for each coefficient.</p>
</td></tr>
<tr><td><code id="summary.block_lm_+3A_num">num</code></td>
<td>
<p>Numeric vector with the index of model(s) from which to return the
requested output. If NULL, will return output from all blocks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> function computes and returns a named list of
summary statistics of the fitted linear models given in <code>object</code>. The
list has the following elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <code>formulas</code> </td><td style="text-align: left;"> A list of the regression formulas used for each block.
  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>residuals</code> </td><td style="text-align: left;"> A matrix with quantiles of the residuals for each
  model.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>coefficients</code> </td><td style="text-align: left;"> A list with a matrix of coefficients for each
  model, as well as the standard error, t-statistic, and p-value.</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>overall</code> </td><td style="text-align: left;"> A data frame with information about the overall models,
  including the multiple R-squared value; adjusted R-squared; F-statistic,
  degrees of freedom, and p-value for each overall model; and the delta
  R-squared (change in R-squared) and its associated F-statistic and p-value.
  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The other functions listed here provide convenient access to the individual
components of this summary.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 blocks: Petal.Length; Petal.Length + Petal.Width
model1 &lt;- build_model(Sepal.Length, Petal.Length, Petal.Width, data=iris, model='lm')
summary(model1)
coef(model1)  # returns coefficients from both blocks 1 and 2

# 2 blocks: Species; Species + Petal.Length + Petal.Width + Petal.Length:Petal.Width
model2 &lt;- build_model(Sepal.Length, Species, c(Petal.Length * Petal.Width), data=iris, model='lm')
summary(model2)
coef(model2, num=2)  # returns coefficients from second block only
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
