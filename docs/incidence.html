<!DOCTYPE html><html><head><title>Help for package incidence</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {incidence}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.incidence'><p>Conversion of incidence objects</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap incidence time series</p></a></li>
<li><a href='#cumulate'><p>Compute cumulative 'incidence'</p></a></li>
<li><a href='#dim.incidence'><p>Access various elements of an incidence object</p></a></li>
<li><a href='#estimate_peak'><p>Estimate the peak date of an incidence curve using bootstrap</p></a></li>
<li><a href='#find_peak'><p>Find the peak date of an incidence curve</p></a></li>
<li><a href='#fit'><p>Fit exponential models to incidence data</p></a></li>
<li><a href='#get_counts'><p>Get counts from an incidence object</p></a></li>
<li><a href='#get_dates'><p>Retrieve dates from an incidence object</p></a></li>
<li><a href='#get_fit'><p>Accessors for <code>incidence_fit</code> objects</p></a></li>
<li><a href='#group_names'><p>extract and set group names</p></a></li>
<li><a href='#incidence'><p>Compute incidence of events from a vector of dates.</p></a></li>
<li><a href='#incidence_pal1'><p>Color palettes used in incidence</p></a></li>
<li><a href='#plot.incidence'><p>Plot function for incidence objects</p></a></li>
<li><a href='#pool'><p>Pool 'incidence' across groups</p></a></li>
<li><a href='#subset.incidence'><p>Subsetting 'incidence' objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Compute, Handle, Plot and Model Incidence of Dated Events</td>
</tr>
<tr>
<td>Version:</td>
<td>1.7.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions and classes to compute, handle and visualise
  incidence from dated events for a defined time interval. Dates can be provided
  in various standard formats. The class 'incidence' is used to store computed
  incidence and can be easily manipulated, subsetted, and plotted. In addition,
  log-linear models can be fitted to 'incidence' objects using 'fit'. This
  package is part of the RECON (<a href="https://www.repidemicsconsortium.org/">https://www.repidemicsconsortium.org/</a>) toolkit
  for outbreak analysis.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.repidemicsconsortium.org/incidence/">https://www.repidemicsconsortium.org/incidence/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/reconhub/incidence/issues">https://github.com/reconhub/incidence/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 3.3.2), aweek (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>magrittr, outbreaks, testthat, vdiffr, knitr, rmarkdown,
scales, cowplot</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/runiverse/noindex:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-31 09:49:25 UTC; tim</td>
</tr>
<tr>
<td>Author:</td>
<td>Thibaut Jombart [aut],
  Zhian N. Kamvar <a href="https://orcid.org/0000-0003-1458-7108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Rich FitzJohn [aut],
  Tim Taylor <a href="https://orcid.org/0000-0002-8587-7113"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [cre],
  Jun Cai <a href="https://orcid.org/0000-0001-9495-1226"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Sangeeta Bhatia [ctb],
  Jakob Schumacher [ctb],
  Juliet R.C. Pulliam
    <a href="https://orcid.org/0000-0003-3314-8223"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tim Taylor &lt;tim.taylor@hiddenelephants.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-31 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.incidence'>Conversion of incidence objects</h2><span id='topic+as.data.frame.incidence'></span><span id='topic+as.incidence'></span><span id='topic+as.incidence.matrix'></span><span id='topic+as.incidence.data.frame'></span><span id='topic+as.incidence.numeric'></span>

<h3>Description</h3>

<p>These functions convert <code>incidence</code> objects into other classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence'
as.data.frame(x, ..., long = FALSE)

as.incidence(x, ...)

## S3 method for class 'matrix'
as.incidence(
  x,
  dates = NULL,
  interval = NULL,
  standard = TRUE,
  isoweeks = standard,
  ...
)

## S3 method for class 'data.frame'
as.incidence(x, dates = NULL, interval = NULL, isoweeks = TRUE, ...)

## S3 method for class 'numeric'
as.incidence(x, dates = NULL, interval = NULL, isoweeks = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.incidence_+3A_x">x</code></td>
<td>
<p>An <code>incidence</code> object, or an object to be converted as
<code>incidence</code> (see details).</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other functions (no used).</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_long">long</code></td>
<td>
<p>A logical indicating if the output data.frame should be 'long', i.e. where a single
column containing 'groups' is added in case of data computed on several groups.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_dates">dates</code></td>
<td>
<p>A vector of dates, each corresponding to the (inclusive) lower
limit of the bins.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_interval">interval</code></td>
<td>
<p>An integer indicating the time interval used in the
computation of the incidence. If NULL, it will be determined from the first
time interval between provided dates. If only one date is provided, it will
trigger an error.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_standard">standard</code></td>
<td>
<p>A logical indicating whether standardised dates should be
used. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.incidence_+3A_isoweeks">isoweeks</code></td>
<td>
<p>Deprecated. Use standard.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conversion to <code>incidence</code> objects should only be done when the
original dates are not available. In such case, the argument <code>x</code>
should be a matrix corresponding to the <code style="white-space: pre;">&#8288;$counts&#8288;</code> element of an
<code>incidence</code> object, i.e. giving counts with time intervals in rows and
named groups in columns. In the absence of groups, a single unnamed columns
should be given. <code>data.frame</code> and vectors will be coerced to a matrix.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>, Rich Fitzjohn
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence' objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create fake data
data &lt;- c(0,1,1,2,1,3,4,5,5,5,5,4,4,26,6,7,9)
sex &lt;- sample(c("m","f"), length(data), replace=TRUE)

## get incidence per group (sex)
i &lt;- incidence(data, groups = sex)
i
plot(i)

## convert to data.frame
as.data.frame(i)

## same, 'long format'
as.data.frame(i, long = TRUE)



## conversion from a matrix of counts to an incidence object
i$counts
new_i &lt;- as.incidence(i$counts, i$dates)
new_i
all.equal(i, new_i)

</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrap incidence time series</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>This function can be used to bootstrap <code>incidence</code> objects. Bootstrapping is
done by sampling with replacement the original input dates. See <code>details</code> for
more information on how this is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(x, randomise_groups = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>An <code>incidence</code> object.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_randomise_groups">randomise_groups</code></td>
<td>
<p>A <code>logical</code> indicating whether groups should be
randomised as well in the resampling procedure; respective group sizes will
be preserved, but this can be used to remove any group-specific temporal
dynamics. If <code>FALSE</code> (default), data are resampled within groups.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As original data are not stored in <code>incidence</code> objects, the
bootstrapping is achieved by multinomial sampling of date bins weighted by
their relative incidence.
</p>


<h3>Value</h3>

<p>An <code>incidence</code> object.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+find_peak">find_peak</a> to use estimate peak date using bootstrap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks) &amp;&amp; require(ggplot2)) { withAutoprint({
  i &lt;- incidence(fluH7N9_china_2013$date_of_onset)
  i
  plot(i)

  ## one simple bootstrap
  x &lt;- bootstrap(i)
  x
  plot(x)

})}

</code></pre>

<hr>
<h2 id='cumulate'>Compute cumulative 'incidence'</h2><span id='topic+cumulate'></span><span id='topic+cumulate.default'></span><span id='topic+cumulate.incidence'></span>

<h3>Description</h3>

<p><code>cumulate</code> is an S3 generic to compute cumulative numbers, with methods
for different types of objects:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumulate(x)

## Default S3 method:
cumulate(x)

## S3 method for class 'incidence'
cumulate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumulate_+3A_x">x</code></td>
<td>
<p>An incidence object.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> default method is a wrapper for <code>cumsum</code>
</p>
</li>
<li> <p><code>incidence</code> objects: computes cumulative incidence over time
</p>
</li>
<li> <p><code>projections</code> objects: same, for <code>projections</code> objects,
implemented in the similarly named package; see <code>?cumulate.projections</code>
for more information, after loading the package
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence'
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- as.integer(c(0,1,2,2,3,5,7))
group &lt;- factor(c(1, 2, 3, 3, 3, 3, 1))
i &lt;- incidence(dat, groups = group)
i
plot(i)

i_cum &lt;- cumulate(i)
i_cum
plot(i_cum)

</code></pre>

<hr>
<h2 id='dim.incidence'>Access various elements of an incidence object</h2><span id='topic+dim.incidence'></span><span id='topic+get_interval'></span><span id='topic+get_interval.default'></span><span id='topic+get_interval.incidence'></span><span id='topic+get_n'></span><span id='topic+get_n.default'></span><span id='topic+get_n.incidence'></span><span id='topic+get_timespan'></span><span id='topic+get_timespan.default'></span><span id='topic+get_timespan.incidence'></span>

<h3>Description</h3>

<p>Access various elements of an incidence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence'
dim(x)

get_interval(x, ...)

## Default S3 method:
get_interval(x, ...)

## S3 method for class 'incidence'
get_interval(x, integer = TRUE, ...)

get_n(x)

## Default S3 method:
get_n(x)

## S3 method for class 'incidence'
get_n(x)

get_timespan(x)

## Default S3 method:
get_timespan(x)

## S3 method for class 'incidence'
get_timespan(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.incidence_+3A_x">x</code></td>
<td>
<p>an <a href="#topic+incidence">incidence</a> object.</p>
</td></tr>
<tr><td><code id="dim.incidence_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="dim.incidence_+3A_integer">integer</code></td>
<td>
<p>When <code>TRUE</code> (default), the interval will be converted to an
integer vector if it is stored as a character in the incidence object.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li> <p><code>dim()</code> the dimensions in the number of bins and number of groups
</p>
</li></ul>


<ul>
<li> <p><code>get_interval()</code> if <code>integer = TRUE</code>: an integer vector, otherwise: the
value stored in <code>x$interval</code>
</p>
</li></ul>


<ul>
<li> <p><code>get_n()</code> The total number of cases stored in the object
</p>
</li></ul>


<ul>
<li> <p><code>get_timespan()</code>: an <code>integer</code> denoting the timespan represented by the
incidence object.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+get_counts">get_counts()</a></code> to access the matrix of counts
</p>
</li>
<li> <p><code><a href="#topic+get_dates">get_dates()</a></code> to access the dates on the right, left, and center of the
interval.
</p>
</li>
<li> <p><code><a href="#topic+group_names">group_names()</a></code> to access and possibly re-name the groups
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
dat &lt;- as.Date(Sys.Date()) + sample(-3:50, 100, replace = TRUE)
x &lt;- incidence(dat, interval = "month")

# the value stored in the interval element
get_interval(x)

# the numeric value of the interval in days
get_interval(x, integer = FALSE)

# the number of observations in the object
get_n(x)

# the length of time represented
get_timespan(x)

# the number of groups
ncol(x)

# the number of bins (intervals)
nrow(x)
</code></pre>

<hr>
<h2 id='estimate_peak'>Estimate the peak date of an incidence curve using bootstrap</h2><span id='topic+estimate_peak'></span>

<h3>Description</h3>

<p>This function can be used to estimate the peak of an epidemic curve stored as
<code>incidence</code>, using bootstrap. See <a href="#topic+bootstrap">bootstrap</a> for more information
on the resampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_peak(x, n = 100, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_peak_+3A_x">x</code></td>
<td>
<p>An <code>incidence</code> object.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_n">n</code></td>
<td>
<p>The number of bootstrap datasets to be generated; defaults to 100.</p>
</td></tr>
<tr><td><code id="estimate_peak_+3A_alpha">alpha</code></td>
<td>
<p>The type 1 error chosen for the confidence interval; defaults to
0.05.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input dates are resampled with replacement to form bootstrapped
datasets; the peak is reported for each, resulting in a distribution of
peak times. When there are ties for peak incidence, only the first date is
reported.
</p>
<p>Note that the bootstrapping approach used for estimating the peak time makes
the following assumptions:
</p>

<ul>
<li><p> the total number of event is known (no uncertainty on total incidence)
</p>
</li>
<li><p> dates with no events (zero incidence) will never be in bootstrapped datasets
</p>
</li>
<li><p> the reporting is assumed to be constant over time, i.e. every case is
equally likely to be reported
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing the following items:
</p>

<ul>
<li> <p><code>observed</code>: the peak incidence of the original dataset
</p>
</li>
<li> <p><code>estimated</code>: the mean peak time of the bootstrap datasets
</p>
</li>
<li> <p><code>ci</code>: the confidence interval based on bootstrap datasets
</p>
</li>
<li> <p><code>peaks</code>: the peak times of the bootstrap datasets
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>, with inputs on
caveats from Michael HÃ¶hle.
</p>


<h3>See Also</h3>

<p><a href="#topic+bootstrap">bootstrap</a> for the bootstrapping underlying this
approach and <a href="#topic+find_peak">find_peak</a> to find the peak in a single
<code>incidence</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks) &amp;&amp; require(ggplot2)) { withAutoprint({
  i &lt;- incidence(fluH7N9_china_2013$date_of_onset)
  i
  plot(i)

  ## one simple bootstrap
  x &lt;- bootstrap(i)
  x
  plot(x)

  ## find 95% CI for peak time using bootstrap
  peak_data &lt;- estimate_peak(i)
  peak_data
  summary(peak_data$peaks)

  ## show confidence interval
  plot(i) + geom_vline(xintercept = peak_data$ci, col = "red", lty = 2)

  ## show the distribution of bootstrapped peaks
  df &lt;- data.frame(peak = peak_data$peaks)
  plot(i) + geom_density(data = df,
                         aes(x = peak, y = 10 * ..scaled..),
                         alpha = .2, fill = "red", color = "red")

})}

</code></pre>

<hr>
<h2 id='find_peak'>Find the peak date of an incidence curve</h2><span id='topic+find_peak'></span>

<h3>Description</h3>

<p>This function can be used to find the peak of an epidemic curve stored as an
<code>incidence</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_peak(x, pool = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_peak_+3A_x">x</code></td>
<td>
<p>An <code>incidence</code> object.</p>
</td></tr>
<tr><td><code id="find_peak_+3A_pool">pool</code></td>
<td>
<p>If <code>TRUE</code> (default), any groups will be pooled before finding
a peak. If <code>FALSE</code>, separate peaks will be found for each group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The date of the (first) highest incidence in the data.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>, Zhian N. Kamvar
<a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_peak">estimate_peak()</a></code> for bootstrap estimates of the peak time
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks) &amp;&amp; require(ggplot2)) { withAutoprint({
  i &lt;- incidence(fluH7N9_china_2013$date_of_onset)
  i
  plot(i)

  ## one simple bootstrap
  x &lt;- bootstrap(i)
  x
  plot(x)

  ## find 95% CI for peak time using bootstrap
  find_peak(i)


  ## show confidence interval
  plot(i) + geom_vline(xintercept = find_peak(i), col = "red", lty = 2)

})}

</code></pre>

<hr>
<h2 id='fit'>Fit exponential models to incidence data</h2><span id='topic+fit'></span><span id='topic+fit_optim_split'></span><span id='topic+print.incidence_fit'></span><span id='topic+print.incidence_fit_list'></span>

<h3>Description</h3>

<p>The function <code>fit</code> fits two exponential models to incidence data, of the
form: <code class="reqn">log(y) = r * t + b</code> <br /> where 'y' is the incidence, 't' is time
(in days), 'r' is the growth rate, and 'b' is the origin. The function <code>fit</code>
will fit one model by default, but will fit two models on either side of a
splitting date (typically the peak of the epidemic) if the argument <code>split</code>
is provided. When groups are present, these are included in the model as main
effects and interactions with dates. The function <code>fit_optim_split()</code> can be
used to find the optimal 'splitting' date, defined as the one for which the
best average R2 of the two models is obtained. Plotting can be done using
<code>plot</code>, or added to an existing incidence plot by the piping-friendly
function <code>add_incidence_fit()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit(x, split = NULL, level = 0.95, quiet = FALSE)

fit_optim_split(
  x,
  window = x$timespan/4,
  plot = TRUE,
  quiet = TRUE,
  separate_split = TRUE
)

## S3 method for class 'incidence_fit'
print(x, ...)

## S3 method for class 'incidence_fit_list'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_+3A_x">x</code></td>
<td>
<p>An incidence object, generated by the function
<code><a href="#topic+incidence">incidence()</a></code>. For the plotting function, an <code>incidence_fit</code>
object.</p>
</td></tr>
<tr><td><code id="fit_+3A_split">split</code></td>
<td>
<p>An optional time point identifying the separation between the
two models. If NULL, a single model is fitted. If provided, two models would
be fitted on the time periods on either side of the split.</p>
</td></tr>
<tr><td><code id="fit_+3A_level">level</code></td>
<td>
<p>The confidence interval to be used for predictions; defaults to
95%.</p>
</td></tr>
<tr><td><code id="fit_+3A_quiet">quiet</code></td>
<td>
<p>A logical indicating if warnings from <code>fit</code> should be
hidden; FALSE by default. Warnings typically indicate some zero incidence,
which are removed before performing the log-linear regression.</p>
</td></tr>
<tr><td><code id="fit_+3A_window">window</code></td>
<td>
<p>The size, in days, of the time window either side of the
split.</p>
</td></tr>
<tr><td><code id="fit_+3A_plot">plot</code></td>
<td>
<p>A logical indicating whether a plot should be added to the
output (<code>TRUE</code>, default), showing the mean R2 for various splits.</p>
</td></tr>
<tr><td><code id="fit_+3A_separate_split">separate_split</code></td>
<td>
<p>If groups are present, should separate split dates be
determined for each group? Defaults to <code>TRUE</code>, in which separate split dates
and thus, separate models will be constructed for each group. When <code>FALSE</code>,
the split date will be determined from the pooled data and modelled with the
groups as main effects and interactions with date.</p>
</td></tr>
<tr><td><code id="fit_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>fit()</code>, a list with the class <code>incidence_fit</code> (for a
single model), or a list containing two <code>incidence_fit</code> objects (when
fitting two models). <code>incidence_fit</code> objects contain:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$model&#8288;</code>: the fitted linear model
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$info&#8288;</code>: a list containing various information extracted from the model
(detailed further)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$origin&#8288;</code>: the date corresponding to day '0'
</p>
</li></ul>

<p>The <code style="white-space: pre;">&#8288;$info&#8288;</code> item is a list containing:
</p>

<ul>
<li> <p><code>r</code>: the growth rate
</p>
</li>
<li> <p><code>r.conf</code>: the confidence interval of 'r'
</p>
</li>
<li> <p><code>pred</code>: a <code>data.frame</code> containing predictions of the model,
including the true dates (<code>dates</code>), their numeric version used in the
model (<code>dates.x</code>), the predicted value (<code>fit</code>), and the lower
(<code>lwr</code>) and upper (<code>upr</code>) bounds of the associated confidence
interval.
</p>
</li>
<li> <p><code>doubling</code>: the predicted doubling time in days; exists only if 'r' is
positive
</p>
</li>
<li> <p><code>doubling.conf</code>: the confidence interval of the doubling time
</p>
</li>
<li> <p><code>halving</code>: the predicted halving time in days; exists only if 'r' is
negative
</p>
</li>
<li> <p><code>halving.conf</code>: the confidence interval of the halving time
</p>
</li></ul>

<p>For <code>fit_optim_split</code>, a list containing:
</p>

<ul>
<li> <p><code>df</code>: a <code>data.frame</code> of dates that were used in the optimization
procedure, and the corresponding average R2 of the resulting models.
</p>
</li>
<li> <p><code>split</code>: the optimal splitting date
</p>
</li>
<li> <p><code>fit</code>: an <code>incidence_fit_list</code> object containing the fit for each split.
If the <code>separate_split = TRUE</code>, then the <code>incidence_fit_list</code> object will
contain these splits nested within each group. All of the <code>incidence_fit</code>
objects can be retrieved with <code><a href="#topic+get_fit">get_fit()</a></code>.
</p>
</li>
<li> <p><code>plot</code>: a plot showing the content of <code>df</code> (ggplot2 object)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>, Zhian N. Kamvar
<a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a>.
</p>


<h3>See Also</h3>

<p>the <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence'
objects. The <code><a href="#topic+get_fit">get_fit()</a></code> function to flatten <code>incidence_fit_list</code> objects to
a list of <code>incidence_fit</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks)) { withAutoprint({
 dat &lt;- ebola_sim$linelist$date_of_onset

 ## EXAMPLE WITH A SINGLE MODEL

 ## compute weekly incidence
 i.7 &lt;- incidence(dat, interval=7)
 plot(i.7)
 plot(i.7[1:20])

 ## fit a model on the first 20 weeks
 f &lt;- fit(i.7[1:20])
 f
 names(f)
 head(get_info(f, "pred"))

 ## plot model alone (not recommended)
 plot(f)

 ## plot data and model (recommended)
 plot(i.7, fit = f)
 plot(i.7[1:25], fit = f)

## piping versions
if (require(magrittr)) { withAutoprint({
  plot(i.7) %&gt;% add_incidence_fit(f)


  ## EXAMPLE WITH 2 PHASES
  ## specifying the peak manually
  f2 &lt;- fit(i.7, split = as.Date("2014-10-15"))
  f2
  plot(i.7) %&gt;% add_incidence_fit(f2)

  ## finding the best 'peak' date
  f3 &lt;- fit_optim_split(i.7)
  f3
  plot(i.7) %&gt;% add_incidence_fit(f3$fit)
})}

})}

</code></pre>

<hr>
<h2 id='get_counts'>Get counts from an incidence object</h2><span id='topic+get_counts'></span><span id='topic+get_counts.incidence'></span>

<h3>Description</h3>

<p>Get counts from an incidence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_counts(x, groups = NULL)

## S3 method for class 'incidence'
get_counts(x, groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_counts_+3A_x">x</code></td>
<td>
<p>an <code>incidence</code> object.</p>
</td></tr>
<tr><td><code id="get_counts_+3A_groups">groups</code></td>
<td>
<p>if there are groups, use this to specify a group or groups to
subset. Defaults to <code>NULL</code> indicating that all groups are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of counts where each row represents a date bin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) { withAutoprint({
  dat  &lt;- ebola_sim$linelist$date_of_onset
  gend &lt;- ebola_sim$linelist$gender
  i    &lt;- incidence(dat, interval = "week", groups = gend)
  
  ## Use with an object and no arguments gives the counts matrix
  head(get_counts(i))

  ## Specifying a position or group name will return a matrix subset to that
  ## group
  head(get_counts(i, 1L))
  head(get_counts(i, "f"))

  ## Specifying multiple groups allows you to rearrange columns
  head(get_counts(i, c("m", "f")))

  ## If you want a vector, you can use drop
  drop(get_counts(i, "f"))
})}
</code></pre>

<hr>
<h2 id='get_dates'>Retrieve dates from an incidence object</h2><span id='topic+get_dates'></span><span id='topic+get_dates.default'></span><span id='topic+get_dates.incidence'></span>

<h3>Description</h3>

<p>Retrieve dates from an incidence object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dates(x, ...)

## Default S3 method:
get_dates(x, ...)

## S3 method for class 'incidence'
get_dates(x, position = "left", count_days = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dates_+3A_x">x</code></td>
<td>
<p>an <a href="#topic+incidence">incidence</a> object</p>
</td></tr>
<tr><td><code id="get_dates_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
<tr><td><code id="get_dates_+3A_position">position</code></td>
<td>
<p>One of &quot;left&quot;, &quot;center&quot;, &quot;middle&quot;, or &quot;right&quot; specifying what
side of the bin the date should be drawn from.</p>
</td></tr>
<tr><td><code id="get_dates_+3A_count_days">count_days</code></td>
<td>
<p>If <code>TRUE</code>, the result will be represented as the number of
days from the first date.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of dates or numerics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(999)
dat &lt;- as.Date(Sys.Date()) + sample(-3:50, 100, replace = TRUE)
x &lt;- incidence(dat, interval = "month")
get_dates(x)
get_dates(x, position = "middle")
set.seed(999)
dat &lt;- as.Date(Sys.Date()) + sample(-3:50, 100, replace = TRUE)
x &lt;- incidence(dat, interval = "month")
get_dates(x)
get_dates(x, "center")
get_dates(x, "right")

# Return dates by number of days from the first date
get_dates(x, count_days = TRUE)
get_dates(incidence(-5:5), count_days = TRUE)
</code></pre>

<hr>
<h2 id='get_fit'>Accessors for <code>incidence_fit</code> objects</h2><span id='topic+get_fit'></span><span id='topic+get_fit.incidence_fit'></span><span id='topic+get_fit.incidence_fit_list'></span><span id='topic+get_info'></span><span id='topic+get_info.incidence_fit'></span><span id='topic+get_info.incidence_fit_list'></span>

<h3>Description</h3>

<p>Accessors for <code>incidence_fit</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fit(x)

## S3 method for class 'incidence_fit'
get_fit(x)

## S3 method for class 'incidence_fit_list'
get_fit(x)

get_info(x, what = "r", ...)

## S3 method for class 'incidence_fit'
get_info(x, what = "r", ...)

## S3 method for class 'incidence_fit_list'
get_info(x, what = "r", groups = NULL, na.rm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fit_+3A_x">x</code></td>
<td>
<p>an <code>incidence_fit</code> or <code>incidence_fit_list</code>
object.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_what">what</code></td>
<td>
<p>the name of the item in the &quot;info&quot; element of the <code>incidence_fit</code>
object.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_...">...</code></td>
<td>
<p>currently unused.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_groups">groups</code></td>
<td>
<p>if <code>what = "pred"</code> and <code>x</code> is an <code>incidence_fit_list</code> object,
then this indicates what part of the nesting hierarchy becomes the column
named &quot;groups&quot;. Defaults to <code>NULL</code>, indicating that no groups column will
be added/modified.</p>
</td></tr>
<tr><td><code id="get_fit_+3A_na.rm">na.rm</code></td>
<td>
<p>when <code>TRUE</code> (default), missing values will be excluded from the
results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of <code>incidence_fit</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks)) { withAutoprint({

 dat &lt;- ebola_sim$linelist$date_of_onset

 ## EXAMPLE WITH A SINGLE MODEL

 ## compute weekly incidence
 sex &lt;- ebola_sim$linelist$gender
 i.sex &lt;- incidence(dat, interval = 7, group = sex)
 
 ## Compute the optimal split for each group separately
 fits  &lt;- fit_optim_split(i.sex, separate_split = TRUE)

 ## `fits` contains an `incidence_fit_list` object
 fits$fit
 
 ## Grab the list of `incidence_fit` objects
 get_fit(fits$fit)
 
 ## Get the predictions for all groups
 get_info(fits$fit, "pred", groups = 1)
 
 ## Get the predictions, but set `groups` to "before" and "after"
 get_info(fits$fit, "pred", groups = 2)
 
 ## Get the reproduction number
 get_info(fits$fit, "r")

 ## Get the doubling confidence interval
 get_info(fits$fit, "doubling.conf")

 ## Get the halving confidence interval
 get_info(fits$fit, "halving.conf")
})}
</code></pre>

<hr>
<h2 id='group_names'>extract and set group names</h2><span id='topic+group_names'></span><span id='topic+group_names+3C-'></span><span id='topic+group_names.default'></span><span id='topic+group_names+3C-.default'></span><span id='topic++60group_names+3C-+60.default'></span><span id='topic+group_names.incidence'></span><span id='topic+group_names+3C-.incidence'></span>

<h3>Description</h3>

<p>extract and set group names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>group_names(x, value)

group_names(x) &lt;- value

## Default S3 method:
group_names(x, value)

## Default S3 replacement method:
group_names(x) &lt;- value

## S3 method for class 'incidence'
group_names(x, value = NULL)

## S3 replacement method for class 'incidence'
group_names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="group_names_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+incidence">incidence()</a></code> object.</p>
</td></tr>
<tr><td><code id="group_names_+3A_value">value</code></td>
<td>
<p>character vector used to rename groups</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This accessor will return a
</p>


<h3>Value</h3>

<p>an integer indicating the number of groups present in the incidence
object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>i &lt;- incidence(dates = sample(10, 100, replace = TRUE), 
               interval = 1L,
               groups = sample(letters[1:3], 100, replace = TRUE))
i
group_names(i)

# change the names of the groups
group_names(i) &lt;- c("Group 1", "Group 2", "Group 3")
i

# example if there are mistakes in the original data, e.g. 
# something is misspelled
set.seed(50)
grps &lt;- sample(c("child", "adult", "adlut"), 100, replace = TRUE, prob = c(0.45, 0.45, 0.05))
i &lt;- incidence(dates = sample(10, 100, replace = TRUE), 
               interval = 1L,
               groups = grps)
colSums(get_counts(i))

# If you change the name of the mis-spelled group, it will be merged with the
# correctly-spelled group
gname &lt;- group_names(i)
gname[gname == "adlut"] &lt;- "adult"
# without side-effects
print(ii &lt;- group_names(i, gname))
colSums(get_counts(i))  # original still has three groups
colSums(get_counts(ii))
# with side-effects
group_names(i) &lt;- gname
colSums(get_counts(i))
</code></pre>

<hr>
<h2 id='incidence'>Compute incidence of events from a vector of dates.</h2><span id='topic+incidence'></span><span id='topic+incidence.default'></span><span id='topic+incidence.Date'></span><span id='topic+incidence.character'></span><span id='topic+incidence.integer'></span><span id='topic+incidence.numeric'></span><span id='topic+incidence.POSIXt'></span><span id='topic+print.incidence'></span>

<h3>Description</h3>

<p>This function computes incidence based on dates of events provided in
various formats. A fixed interval, provided as numbers of days, is used to
define time intervals. Counts within an interval always include the first
date, after which they are labeled, and exclude the second. For instance,
intervals labeled as 0, 3, 6, ... mean that the first bin includes days 0, 1
and 2, the second interval includes 3, 4 and 5 etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence(dates, interval = 1L, ...)

## Default S3 method:
incidence(dates, interval = 1L, ...)

## S3 method for class 'Date'
incidence(
  dates,
  interval = 1L,
  standard = TRUE,
  groups = NULL,
  na_as_group = TRUE,
  first_date = NULL,
  last_date = NULL,
  ...
)

## S3 method for class 'character'
incidence(
  dates,
  interval = 1L,
  standard = TRUE,
  groups = NULL,
  na_as_group = TRUE,
  first_date = NULL,
  last_date = NULL,
  ...
)

## S3 method for class 'integer'
incidence(
  dates,
  interval = 1L,
  groups = NULL,
  na_as_group = TRUE,
  first_date = NULL,
  last_date = NULL,
  ...
)

## S3 method for class 'numeric'
incidence(
  dates,
  interval = 1L,
  groups = NULL,
  na_as_group = TRUE,
  first_date = NULL,
  last_date = NULL,
  ...
)

## S3 method for class 'POSIXt'
incidence(
  dates,
  interval = 1L,
  standard = TRUE,
  groups = NULL,
  na_as_group = TRUE,
  first_date = NULL,
  last_date = NULL,
  ...
)

## S3 method for class 'incidence'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence_+3A_dates">dates</code></td>
<td>
<p>A vector of dates, which can be provided as objects of the
class: integer, numeric, Date, POSIXct, POSIXlt, and character. (See Note
about <code>numeric</code> and <code>character</code> formats)</p>
</td></tr>
<tr><td><code id="incidence_+3A_interval">interval</code></td>
<td>
<p>An integer or character indicating the (fixed) size of the
time interval used for computing the incidence; defaults to 1 day. This can
also be a text string that corresponds to a valid date interval: day, week,
month, quarter, or year. (See Note).</p>
</td></tr>
<tr><td><code id="incidence_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to other methods (none are used).</p>
</td></tr>
<tr><td><code id="incidence_+3A_standard">standard</code></td>
<td>
<p>(Only applicable to Date objects) When <code>TRUE</code> (default) and the
<code>interval</code> one of &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot;, or &quot;year&quot;, then this will
cause the bins for the counts to start at the beginning of the interval
(See Note).</p>
</td></tr>
<tr><td><code id="incidence_+3A_groups">groups</code></td>
<td>
<p>An optional factor defining groups of observations for which
incidence should be computed separately.</p>
</td></tr>
<tr><td><code id="incidence_+3A_na_as_group">na_as_group</code></td>
<td>
<p>A logical value indicating if missing group (NA) should be
treated as a separate group.</p>
</td></tr>
<tr><td><code id="incidence_+3A_first_date">first_date</code>, <code id="incidence_+3A_last_date">last_date</code></td>
<td>
<p>optional first/last dates to be used in the
epicurve. When these are <code>NULL</code> (default), the dates from the first/last
dates are taken from the observations. If these dates are provided, the
observations will be trimmed to the range of [first_date, last_date].</p>
</td></tr>
<tr><td><code id="incidence_+3A_x">x</code></td>
<td>
<p>An 'incidence' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details about the <code style="white-space: pre;">&#8288;incidence class&#8288;</code>, see the dedicated
vignette:<br /> <code>vignette("incidence_class", package = "incidence")</code>
</p>


<h3>Value</h3>

<p>An list with the class <code>incidence</code>, which contains the
following items:
</p>

<ul>
<li> <p><strong>dates</strong>: The dates marking the left side of the bins used for counting
events. When <code>standard = TRUE</code> and the interval represents weeks, months,
quarters, or years, the first date will represent the first standard date
(See Interval specification, below).
</p>
</li>
<li> <p><strong>counts</strong>: A matrix of incidence counts, which one column per group (and
a single column if no groups were used).
</p>
</li>
<li> <p><strong>timespan</strong>: The length of the period for which incidence is computed, in
days.
</p>
</li>
<li> <p><strong>interval</strong>: The bin size. If it's an integer, it represents the number
of days between each bin. It can also be a character, e.g. &quot;2 weeks&quot; or
&quot;6 months&quot;.
</p>
</li>
<li> <p><strong>n</strong>: The total number of cases.
</p>
</li>
<li> <p><strong>weeks</strong>: Dates in week format (YYYY-Www), where YYYY corresponds to the
year of the given week and ww represents the numeric week of the year.
This will be a produced from the function <code><a href="aweek.html#topic+date2week">aweek::date2week()</a></code>. Note that
these will have a special <code>"week_start"</code> attribute indicating which day of
the ISO week the week starts on (see Weeks, below).
</p>
</li>
<li> <p><strong>isoweeks</strong>: ISO 8601 week format YYYY-Www, which is returned only when
ISO week-based weekly incidence is computed.
</p>
</li></ul>



<h3>Note</h3>



<h4>Input data (<code>dates</code>)</h4>


<ul>
<li> <p><strong>Decimal (numeric) dates</strong>: will be truncated with a warning
</p>
</li>
<li> <p><strong>Character dates</strong> should be in the unambiguous <code>yyyy-mm-dd</code> (ISO 8601)
format. Any other format will trigger an error.
</p>
</li></ul>




<h4>Interval specification (<code>interval</code>)</h4>

<p>If <code>interval</code> is a valid character (e.g. &quot;week&quot; or &quot;1 month&quot;), then
the bin will start at the beginning of the interval just before the first
observation by default. For example, if the first case was recorded on
Wednesday, 2018-05-09:
</p>

<ul>
<li><p> &quot;week&quot;    : first day of the week (i.e. Monday, 2018-05-07) (defaults to ISO weeks, see &quot;Week intervals&quot;, below)
</p>
</li>
<li><p> &quot;month&quot;   : first day of the month (i.e. 2018-05-01)
</p>
</li>
<li><p> &quot;quarter&quot; : first day of the quarter (i.e. 2018-04-01)
</p>
</li>
<li><p> &quot;year&quot;    : first day of the calendar year (i.e. 2018-01-01)
</p>
</li></ul>

<p>These default intervals can be overridden with <code>standard = FALSE</code>, which
sets the interval to begin at the first observed case.
</p>



<h4>Week intervals</h4>

<p>As of <em>incidence</em> version 1.7.0, it is possible to construct standardized
incidence objects standardized to any day of the week thanks to the
<code><a href="aweek.html#topic+date2week">aweek::date2week()</a></code> function from the <span class="pkg">aweek</span> package. The default
state is to use ISO 8601 definition of weeks, which start on Monday. You can
specify the day of the week an incidence object should be standardised to by
using the pattern &quot;{n} {W} weeks&quot; where &quot;{W}&quot; represents the weekday in an
English or current locale and &quot;{n}&quot; represents the duration, but this can be
ommitted.  Below are examples of specifying weeks starting on different days
assuming we had data that started on 2016-09-05, which is ISO week 36 of
2016:
</p>

<ul>
<li><p> interval = &quot;2 monday weeks&quot; (Monday 2016-09-05)
</p>
</li>
<li><p> interval = &quot;1 tue week&quot; (Tuesday 2016-08-30)
</p>
</li>
<li><p> interval = &quot;1 Wed week&quot; (Wednesday 2016-08-31)
</p>
</li>
<li><p> interval = &quot;1 Thursday week&quot; (Thursday 2016-09-01)
</p>
</li>
<li><p> interval = &quot;1 F week&quot; (Friday 2016-09-02)
</p>
</li>
<li><p> interval = &quot;1 Saturday week&quot; (Saturday 2016-09-03)
</p>
</li>
<li><p> interval = &quot;Sunday week&quot; (Sunday 2016-09-04)
</p>
</li></ul>

<p>It's also possible to use something like &quot;3 weeks: Saturday&quot;; In addition,
there are keywords reserved for specific days of the week:
</p>

<ul>
<li><p> interval = &quot;week&quot;, standard = TRUE (Default, Monday)
</p>
</li>
<li><p> interval = &quot;ISOweek&quot;  (Monday)
</p>
</li>
<li><p> interval = &quot;EPIweek&quot;  (Sunday)
</p>
</li>
<li><p> interval = &quot;MMWRweek&quot; (Sunday)
</p>
</li></ul>

<p>The &quot;EPIweek&quot; specification is not strictly reserved for CDC epiweeks, but
can be prefixed (or posfixed) by a day of the week: &quot;1 epiweek: Saturday&quot;.
</p>



<h4>The <code>first_date</code> argument</h4>

<p>Previous versions of <em>incidence</em> had the <code>first_date</code> argument override
<code>standard = TRUE</code>. It has been changed as of <em>incidence</em> version 1.6.0 to
be more consistent with the behavior when <code>first_date = NULL</code>. This, however
may be a change in behaviour, so a warning is now issued once and only once
if <code>first_date</code> is specified, but <code>standard</code> is not. To never see this
warning, use <code>options(incidence.warn.first_date = FALSE)</code>.
</p>

<p>The intervals for &quot;month&quot;, &quot;quarter&quot;, and &quot;year&quot; will necessarily vary in the
number of days they encompass and warnings will be generated when the first
date falls outside of a calendar date that is easily represented across the
interval.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart, Rich Fitzjohn, Zhian Kamvar
</p>


<h3>See Also</h3>

<p>The main other functions of the package include:
</p>

<ul>
<li> <p><code><a href="#topic+plot.incidence">plot.incidence()</a></code>: Plot epicurves from an incidence object.
</p>
</li>
<li> <p><code><a href="#topic+fit">fit()</a></code>: Fit log-linear model to computed incidence.
</p>
</li>
<li> <p><code><a href="#topic+fit_optim_split">fit_optim_split()</a></code>: Find the optimal peak of the epidemic
and fits log-linear models on either side of the peak.
</p>
</li>
<li> <p><code><a href="base.html#topic+subset">subset()</a></code>: Handling of <code>incidence</code>
objects.
</p>
</li>
<li> <p><code><a href="#topic+pool">pool()</a></code>: Sum incidence over groups.
</p>
</li>
<li> <p><code><a href="#topic+as.data.frame.incidence">as.data.frame.incidence()</a></code>: Convert an <code>incidence</code> object to a
<code>data.frame</code>.
</p>
</li></ul>

<p>The following vignettes are also available:
</p>

<ul>
<li> <p><code>overview</code>: Provides an overview of the package's features.
</p>
</li>
<li> <p><code>customize_plot</code>: Provides some tips on finer plot customization.
</p>
</li>
<li> <p><code>incidence_class</code>: Details the content of the <code>incidence</code>
class.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## toy example
incidence(c(1, 5, 8, 3, 7, 2, 4, 6, 9, 2))
incidence(c(1, 5, 8, 3, 7, 2, 4, 6, 9, 2), 2)

## example using simulated dataset
if(require(outbreaks)) { withAutoprint({
  onset &lt;- outbreaks::ebola_sim$linelist$date_of_onset

  ## daily incidence
  inc &lt;- incidence(onset)
  inc
  plot(inc)

  ## weekly incidence
  inc.week &lt;- incidence(onset, interval = 7, standard = FALSE)
  inc.week
  plot(inc.week)
  plot(inc.week, border = "white") # with visible border

  # Starting on Monday
  inc.isoweek &lt;- incidence(onset, interval = "isoweek")
  inc.isoweek

  # Starting on Sunday
  inc.epiweek &lt;- incidence(onset, interval = "epiweek")
  inc.epiweek

  # Starting on Saturday
  inc.epiweek &lt;- incidence(onset, interval = "saturday epiweek")
  inc.epiweek

  ## use group information
  sex &lt;- outbreaks::ebola_sim$linelist$gender
  inc.week.gender &lt;- incidence(onset, interval = 7,
                               groups = sex, standard = FALSE)
  inc.week.gender
  head(inc.week.gender$counts)
  plot(inc.week.gender, border = "grey90")
  inc.satweek.gender &lt;- incidence(onset, interval = "2 epiweeks: saturday",
                                  groups = sex)
  inc.satweek.gender
  plot(inc.satweek.gender, border = "grey90")

})}

# Use of first_date
d &lt;- Sys.Date() + sample(-3:10, 10, replace = TRUE)

# `standard` specified, no warning
di &lt;- incidence(d, interval = "week", first_date = Sys.Date() - 10, standard = TRUE)

# warning issued if `standard` not specified
di &lt;- incidence(d, interval = "week", first_date = Sys.Date() - 10)

# second instance: no warning issued
di &lt;- incidence(d, interval = "week", first_date = Sys.Date() - 10)


</code></pre>

<hr>
<h2 id='incidence_pal1'>Color palettes used in incidence</h2><span id='topic+incidence_pal1'></span><span id='topic+palettes'></span><span id='topic+incidence_pal1_light'></span><span id='topic+incidence_pal1_dark'></span>

<h3>Description</h3>

<p>These functions are color palettes used in incidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence_pal1(n)

incidence_pal1_light(n)

incidence_pal1_dark(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence_pal1_+3A_n">n</code></td>
<td>
<p>a number of colors</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(1:4, cex=8, pch=20, col = incidence_pal1(4),
     main = "palette: incidence_pal1")
plot(1:100, cex=8, pch=20, col = incidence_pal1(100),
     main ="palette: incidence_pal1")
plot(1:100, cex=8, pch=20, col = incidence_pal1_light(100),
     main="palette: incidence_pal1_light")
plot(1:100, cex=8, pch=20, col = incidence_pal1_dark(100),
     main="palette: incidence_pal1_dark")

</code></pre>

<hr>
<h2 id='plot.incidence'>Plot function for incidence objects</h2><span id='topic+plot.incidence'></span><span id='topic+add_incidence_fit'></span><span id='topic+plot.incidence_fit'></span><span id='topic+plot.incidence_fit_list'></span><span id='topic+scale_x_incidence'></span><span id='topic+make_breaks'></span>

<h3>Description</h3>

<p>This function is used to visualise the output of the <code><a href="#topic+incidence">incidence()</a></code>
function using the package <code>ggplot2</code>. #'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence'
plot(
  x,
  ...,
  fit = NULL,
  stack = is.null(fit),
  color = "black",
  border = NA,
  col_pal = incidence_pal1,
  alpha = 0.7,
  xlab = "",
  ylab = NULL,
  labels_week = !is.null(x$weeks),
  labels_iso = !is.null(x$isoweeks),
  show_cases = FALSE,
  n_breaks = 6
)

add_incidence_fit(p, x, col_pal = incidence_pal1)

## S3 method for class 'incidence_fit'
plot(x, ...)

## S3 method for class 'incidence_fit_list'
plot(x, ...)

scale_x_incidence(x, n_breaks = 6, labels_week = TRUE, ...)

make_breaks(x, n_breaks = 6L, labels_week = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.incidence_+3A_x">x</code></td>
<td>
<p>An incidence object, generated by the function
<code><a href="#topic+incidence">incidence()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_date()</a></code>,
<code><a href="ggplot2.html#topic+scale_date">ggplot2::scale_x_datetime()</a></code>, or <code><a href="ggplot2.html#topic+scale_continuous">ggplot2::scale_x_continuous()</a></code>, depending
on how the <code style="white-space: pre;">&#8288;$date&#8288;</code> element is stored in the incidence object.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_fit">fit</code></td>
<td>
<p>An 'incidence_fit' object as returned by <code><a href="#topic+fit">fit()</a></code>.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_stack">stack</code></td>
<td>
<p>A logical indicating if bars of multiple groups should be
stacked, or displayed side-by-side.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_color">color</code></td>
<td>
<p>The color to be used for the filling of the bars; NA for
invisible bars; defaults to &quot;black&quot;.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_border">border</code></td>
<td>
<p>The color to be used for the borders of the bars; NA for
invisible borders; defaults to NA.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_col_pal">col_pal</code></td>
<td>
<p>The color palette to be used for the groups; defaults to
<code>incidence_pal1</code>. See <code><a href="#topic+incidence_pal1">incidence_pal1()</a></code> for other palettes implemented in
incidence.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for color transparency, with 1 being fully
opaque and 0 fully transparent; defaults to 0.7.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_xlab">xlab</code></td>
<td>
<p>The label to be used for the x-axis; empty by default.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_ylab">ylab</code></td>
<td>
<p>The label to be used for the y-axis; by default, a label will be
generated automatically according to the time interval used in incidence
computation.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_labels_week">labels_week</code></td>
<td>
<p>a logical value indicating whether labels x axis tick
marks are in week format YYYY-Www when plotting weekly incidence; defaults to
TRUE.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_labels_iso">labels_iso</code></td>
<td>
<p>(deprecated) This has been superceded by <code>labels_iso</code>.
Previously:a logical value indicating whether labels x axis tick marks are
in ISO 8601 week format yyyy-Www when plotting ISO week-based weekly
incidence; defaults to be TRUE.</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_show_cases">show_cases</code></td>
<td>
<p>if <code>TRUE</code> (default: <code>FALSE</code>), then each observation will be
colored by a border. The border defaults to a white border unless specified
otherwise. This is normally used outbreaks with a small number of cases.
Note: this can only be used if <code>stack = TRUE</code></p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_n_breaks">n_breaks</code></td>
<td>
<p>the ideal number of breaks to be used for the x-axis
labeling</p>
</td></tr>
<tr><td><code id="plot.incidence_+3A_p">p</code></td>
<td>
<p>An existing incidence plot.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>plot()</code> will visualise an incidence object using <code>ggplot2</code>
</p>
</li>
<li> <p><code>make_breaks()</code> calculates breaks from an incidence object that always
align with the bins and start on the first observed incidence.
</p>
</li>
<li> <p><code>scale_x_incidence()</code> produces and appropriate <code>ggplot2</code> scale based on
an incidence object.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>plot()</code> a <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> object.
</p>
</li>
<li> <p><code>make_breaks()</code> a two-element list. The &quot;breaks&quot; element will contain the
evenly-spaced breaks as either dates or numbers and the &quot;labels&quot; element
will contain either a vector of weeks OR a <code><a href="ggplot2.html#topic+waiver">ggplot2::waiver()</a></code> object.
</p>
</li>
<li> <p><code>scale_x_incidence()</code> a <span class="pkg">ggplot2</span> &quot;ScaleContinuous&quot; object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
Zhian N. Kamvar <a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence'
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(outbreaks) &amp;&amp; require(ggplot2)) { withAutoprint({
  onset &lt;- outbreaks::ebola_sim$linelist$date_of_onset

  ## daily incidence
  inc &lt;- incidence(onset)
  inc
  plot(inc)

  ## weekly incidence
  inc.week &lt;- incidence(onset, interval = 7)
  inc.week
  plot(inc.week) # default to label x axis tick marks with isoweeks
  plot(inc.week, labels_week = FALSE) # label x axis tick marks with dates
  plot(inc.week, border = "white") # with visible border

  ## use group information
  sex &lt;- outbreaks::ebola_sim$linelist$gender
  inc.week.gender &lt;- incidence(onset, interval = "1 epiweek", groups = sex)
  plot(inc.week.gender)
  plot(inc.week.gender, labels_week = FALSE)

  ## show individual cases at the beginning of the epidemic
  inc.week.8 &lt;- subset(inc.week.gender, to = "2014-06-01")
  p &lt;- plot(inc.week.8, show_cases = TRUE, border = "black")
  p

  ## update the range of the scale
  lim &lt;- c(min(get_dates(inc.week.8)) - 7*5, 
           aweek::week2date("2014-W50", "Sunday"))
  lim
  p + scale_x_incidence(inc.week.gender, limits = lim)

  ## customize plot with ggplot2
  plot(inc.week.8, show_cases = TRUE, border = "black") +
    theme_classic(base_size = 16) +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) 

  ## adding fit
  fit &lt;- fit_optim_split(inc.week.gender)$fit
  plot(inc.week.gender, fit = fit)
  plot(inc.week.gender, fit = fit, labels_week = FALSE)

})}

</code></pre>

<hr>
<h2 id='pool'>Pool 'incidence' across groups</h2><span id='topic+pool'></span>

<h3>Description</h3>

<p>This function pools incidence across all groups of an <code>incidence</code>
object. The resulting <code><a href="#topic+incidence">incidence()</a></code> object will contains counts
summed over all groups present in the input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pool_+3A_x">x</code></td>
<td>
<p>An 'incidence' object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence'
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- as.integer(c(0,1,2,2,3,5,7))
group &lt;- factor(c(1, 2, 3, 3, 3, 3, 1))
i &lt;- incidence(dat, groups = group)
i
i$counts

## pool all groups
pool(i)
pool(i)$counts

## pool only groups 1 and 3
pool(i[,c(1,3)])
pool(i[,c(1,3)])$counts

</code></pre>

<hr>
<h2 id='subset.incidence'>Subsetting 'incidence' objects</h2><span id='topic+subset.incidence'></span><span id='topic++22subset.incidence+22'></span><span id='topic++22+5B.incidence+22'></span><span id='topic++5B.incidence'></span>

<h3>Description</h3>

<p>Two functions can be used to subset incidence objects.  The function
<code>subset</code> permits to retain dates within a specified range and,
optionally, specific groups. The operator &quot;[&quot; can be used as for matrices,
using the syntax <code>x[i,j]</code> where 'i' is a subset of dates, and 'j' is a
subset of groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence'
subset(x, ..., from = min(x$dates), to = max(x$dates), groups = TRUE)

## S3 method for class 'incidence'
x[i, j]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.incidence_+3A_x">x</code></td>
<td>
<p>An incidence object, generated by the function
<code><a href="#topic+incidence">incidence()</a></code>.</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_...">...</code></td>
<td>
<p>Further arguments passed to other methods (not used).</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_from">from</code></td>
<td>
<p>The starting date; data strictly before this date are discarded.</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_to">to</code></td>
<td>
<p>The ending date; data strictly after this date are discarded.</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_groups">groups</code></td>
<td>
<p>(optional) The groups to retained, indicated as subsets of the
columns of x$counts.</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_i">i</code></td>
<td>
<p>a subset of dates to retain</p>
</td></tr>
<tr><td><code id="subset.incidence_+3A_j">j</code></td>
<td>
<p>a subset of groups to retain</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+incidence">incidence()</a></code> function to generate the 'incidence'
objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example using simulated dataset
if(require(outbreaks)) { withAutoprint({
  onset &lt;- ebola_sim$linelist$date_of_onset

  ## weekly incidence
  inc &lt;- incidence(onset, interval = 7)
  inc
  inc[1:10] # first 10 weeks
  plot(inc[1:10])
  inc[-c(11:15)] # remove weeks 11-15
  plot(inc[-c(11:15)])
})}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
