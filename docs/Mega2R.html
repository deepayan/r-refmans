<!DOCTYPE html><html><head><title>Help for package Mega2R</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Mega2R}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Mega2R-package'><p>Mega2R: Accessing and Processing a 'Mega2' Genetic Database</p></a></li>
<li><a href='#applyFnToGenes'><p>apply a function to the genotypes (markers) in each gene transcript and/or base pair range</p></a></li>
<li><a href='#applyFnToMarkers'><p>apply a function to the genotypes from a set of markers</p></a></li>
<li><a href='#applyFnToRanges'><p>apply a function to all the genotypes for markers found in several specified ranges</p></a></li>
<li><a href='#clean_mega2rtutorial_data'><p>remove tutorial data</p></a></li>
<li><a href='#computeDosage'><p>computeDosage function</p></a></li>
<li><a href='#dbmega2_import'><p>read Mega2 SQLite database into R</p></a></li>
<li><a href='#dmpPed'><p>generate the .ped, .fam and .map files of PLINK PED representation of a gwaa.data-class object</p></a></li>
<li><a href='#DOfamSKATRC'><p>DofamSKATRC call back function</p></a></li>
<li><a href='#DOpedgene'><p>pedgene call back function</p></a></li>
<li><a href='#DOSKAT'><p>SKAT call back function</p></a></li>
<li><a href='#dump_mega2rtutorial_data'><p>dump tutorial data</p></a></li>
<li><a href='#getAlleles'><p>pull allele pairs</p></a></li>
<li><a href='#getgenotype_person'><p>return the genotypes for all markers of a given person</p></a></li>
<li><a href='#getgenotypes'><p>fetch genotype character matrix for specified markers</p></a></li>
<li><a href='#getgenotypes_R'><p>fetch genotype matrix for specified markers (assemble by rows)</p></a></li>
<li><a href='#getgenotypesdos'><p>fetch dosage integer matrix for specified markers</p></a></li>
<li><a href='#getgenotypesgenabel'><p>process the genotype matrix for specified markers and return the corresponding GenABEL genotype matrix</p></a></li>
<li><a href='#getgenotypesraw'><p>fetch genotype integer matrix for specified markers</p></a></li>
<li><a href='#init_famSKATRC'><p>load Mega2 SQLite database and perform initialization for famSKATRC usage</p></a></li>
<li><a href='#init_pedgene'><p>load Mega2 SQLite database and perform initialization for pedgene usage</p></a></li>
<li><a href='#init_SKAT'><p>load Mega2 SQLite database and perform initialization for SKAT usage</p></a></li>
<li><a href='#Mega2ENVGenABEL'><p>generate gwaa.data-class object</p></a></li>
<li><a href='#Mega2famSKATRC'><p>execute the CRAN famSKAT_RC function on a subset of the gene transcripts</p></a></li>
<li><a href='#Mega2gdsfmt'><p>transcode mega2 to gdsfmt/SNP_ARRAY</p></a></li>
<li><a href='#Mega2GenABEL'><p>generate gwaa.data-class object from a <b>Mega2R</b> database</p></a></li>
<li><a href='#Mega2GenABELClean'><p>delete temporary PLINK tped files processed by GenABEL</p></a></li>
<li><a href='#Mega2GenABELtst'><p>compare two gwaa.data-class objects</p></a></li>
<li><a href='#Mega2pedgene'><p>Execute the pedgene function on a transcript ranges</p></a></li>
<li><a href='#Mega2R-TBLS'><p>Mega2R SQLite3 tables</p></a></li>
<li><a href='#Mega2R-TBLSFilter'><p>Mega2R SQLite3 table filter</p></a></li>
<li><a href='#Mega2RVersion'><p>Mega2R version</p></a></li>
<li><a href='#Mega2SKAT'><p>execute the CRAN SKAT function on a subset of the gene transcripts</p></a></li>
<li><a href='#Mega2VCF'><p>generate a VCF file set for a collection of markers</p></a></li>
<li><a href='#mk_markers_with_skip'><p>make the derived &quot;markers&quot; data frame and store it in the environment.</p></a></li>
<li><a href='#mk_unified_genotype_table'><p>concatenate separate genotype vectors for each chromosome to one extended vector containing all the chromosomes</p>
and store it in the environment.</a></li>
<li><a href='#mkAlleles'><p>generate allele pairs in with MAJ(or) allele first</p></a></li>
<li><a href='#mkfam'><p>assemble pedigree information into a data frame</p></a></li>
<li><a href='#mkGenABELcoding'><p>generate GenABEL coding vector</p></a></li>
<li><a href='#mkGenABELgenotype'><p>generate GenABEL compressed genotype matrix</p></a></li>
<li><a href='#mkGenABELphenotype'><p>generate required PLINK (.phe) file</p></a></li>
<li><a href='#mkGenABELtfam'><p>generate required fam family for PLINK TPED (.tfam) file</p></a></li>
<li><a href='#mkGenABELtped'><p>generate a PLINK TPED file for GenABEL</p></a></li>
<li><a href='#mkMarkers'><p>create &quot;markers&quot; data frame</p></a></li>
<li><a href='#mkphenotype'><p>generate a phenotype data frame</p></a></li>
<li><a href='#mkVCFfam'><p>generate required VCF family (.fam) file</p></a></li>
<li><a href='#mkVCFfreq'><p>generate required VCF frequency (.freq) file</p></a></li>
<li><a href='#mkVCFhdr'><p>generate required VCF header</p></a></li>
<li><a href='#mkVCFmap'><p>generate required Mega2 map (.map) file</p></a></li>
<li><a href='#mkVCFpen'><p>generate required Mega2 penetrance (.pen) file</p></a></li>
<li><a href='#mkVCFphe'><p>generate required PLINK (.phe) file</p></a></li>
<li><a href='#read.Mega2DB'><p>load Mega2 database and initialize family data frame and markers data frame</p></a></li>
<li><a href='#resetMega2ENV'><p>return an initialized environment</p></a></li>
<li><a href='#setAnnotations'><p>set default name of transcription database and name of database mapping gene name to entrez gene id</p></a></li>
<li><a href='#setfam'><p>replace the pedigree data frame</p></a></li>
<li><a href='#setRanges'><p>set default range data: chromosome and start/end base pair</p></a></li>
<li><a href='#showMapNames'><p>show the association between mapno and mapname</p></a></li>
<li><a href='#showMega2ENV'><p>show Mega2R environment, viz. data frames and related info.</p></a></li>
<li><a href='#showPhenoNames'><p>show the association between index no and phenotype</p></a></li>
<li><a href='#uniqueFamMember'><p>regenerate fam data frame with unique values in member column</p></a></li>
<li><a href='#where_mega2rtutorial_data'><p>show directory of tutorial data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-21</td>
</tr>
<tr>
<td>Title:</td>
<td>Accessing and Processing a 'Mega2' Genetic Database</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses as input genetic data that have been reformatted and
     stored in a 'SQLite' database; this database is initially created
     by the standalone 'mega2' C++ program (available freely from
     <a href="https://watson.hgen.pitt.edu/register/">https://watson.hgen.pitt.edu/register/</a>). Loads and manipulates
     data frames containing genotype, phenotype, and family
     information from the input 'SQLite' database, and decompresses
     needed subsets of the genotype data, on the fly, in a memory
     efficient manner.  We have also created several more functions
     that illustrate how to use the data frames as well as perform
     useful tasks: these permit one to run the 'pedgene' package to
     carry out gene-based association tests on family data using
     selected marker subsets, to run the 'SKAT' package to carry out
     gene-based association tests using selected marker subsets, to
     run the 'famSKATRC' package to carry out gene-based association
     tests on families (optionally) and with rare or common variants
     using selected marker subsets, to output the 'Mega2R' data as a
     VCF file and related files (for phenotype and family data), and
     to convert the data frames into CoreArray Genomic Data Structure
     (GDS) format.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://watson.hgen.pitt.edu/mega2/mega2r/">https://watson.hgen.pitt.edu/mega2/mega2r/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://groups.google.com/forum/#!forum/mega2-users">https://groups.google.com/forum/#!forum/mega2-users</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), SKAT, pedgene, gdsfmt</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>biocViews:</td>
<td>Genetics</td>
</tr>
<tr>
<td>Imports:</td>
<td>AnnotationDbi, DBI, GenomeInfoDb, RSQLite, methods, famSKATRC,
kinship2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, formatR, TxDb.Hsapiens.UCSC.hg19.knownGene,
org.Hs.eg.db</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-21 21:47:27 UTC; dweeks</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert V. Baron [aut],
  Daniel E. Weeks [aut, cre],
  University of Pittsburgh [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel E. Weeks &lt;weeks@pitt.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-21 22:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='Mega2R-package'>Mega2R: Accessing and Processing a 'Mega2' Genetic Database</h2><span id='topic+Mega2R'></span><span id='topic+Mega2R-package'></span>

<h3>Description</h3>

<p>Uses as input genetic data that have been reformatted and stored in a 'SQLite' database; this database is initially created by the standalone 'mega2' C++ program (available freely from <a href="https://watson.hgen.pitt.edu/register/">https://watson.hgen.pitt.edu/register/</a>). Loads and manipulates data frames containing genotype, phenotype, and family information from the input 'SQLite' database, and decompresses needed subsets of the genotype data, on the fly, in a memory efficient manner. We have also created several more functions that illustrate how to use the data frames as well as perform useful tasks: these permit one to run the 'pedgene' package to carry out gene-based association tests on family data using selected marker subsets, to run the 'SKAT' package to carry out gene-based association tests using selected marker subsets, to run the 'famSKATRC' package to carry out gene-based association tests on families (optionally) and with rare or common variants using selected marker subsets, to output the 'Mega2R' data as a VCF file and related files (for phenotype and family data), and to convert the data frames into CoreArray Genomic Data Structure (GDS) format.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Daniel E. Weeks <a href="mailto:weeks@pitt.edu">weeks@pitt.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Robert V. Baron <a href="mailto:rvb5@pitt.edu">rvb5@pitt.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p>  University of Pittsburgh [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://watson.hgen.pitt.edu/mega2/mega2r/">https://watson.hgen.pitt.edu/mega2/mega2r/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://groups.google.com/forum/#!forum/mega2-users">https://groups.google.com/forum/#!forum/mega2-users</a>
</p>
</li></ul>


<hr>
<h2 id='applyFnToGenes'>apply a function to the genotypes (markers) in each gene transcript and/or base pair range</h2><span id='topic+applyFnToGenes'></span>

<h3>Description</h3>

<p>This function generates base pair ranges from its input arguments.
Each range specifies a chromosome, a start
base pair and end base pair.  Typically, a range could be a gene transcript, though
it could be a whole chromosome, or a run of base pairs on a chromosome.  Once the
ranges are generated, <code>applyFnToRanges</code> is called to find all the
rows (i.e. markers) from the <em>markers</em> data frame that fall in each range.  For these
markers, a matrix of the genotypes is generated.  Finally, the <code>op</code> function is called for
each range with the arguments: markers, range, and 'environment'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyFnToGenes(op           = function (markers, range, envir) {},
               genes_arg    = NULL,
               ranges_arg   = matrix(ncol = 3, nrow = 0),
               chrs_arg     = vector("integer", 0),
               markers_arg  = vector("character", 0),
               type_arg     = "TX",
               fuzz_arg     = 0,
               envir        = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyFnToGenes_+3A_op">op</code></td>
<td>
<p>Is a function of three arguments.  It will be called repeatedly by
<code>applyFnToGenes</code> in a try/catch context.  The arguments are:
</p>

<dl>
<dt>markers</dt><dd><p>Marker data for each marker selected.  A marker is a data frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding marker genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>

</dd>
<dt>range</dt><dd><p>An indicator of which range argument these markers correspond to.</p>
</dd>
<dt>envir</dt><dd><p>An 'environment' holding Mega2R data frames and state data.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_genes_arg">genes_arg</code></td>
<td>
<p>a character vector of gene names.
All the transcripts identified with the specified gene in BioConductor Annotation,<br />
<b>TxDb.Hsapiens.UCSC.hg19.knownGene</b>, are selected.  This produces multiple &quot;range&quot;
elements containing chromosome, start base pair, end base pair.  (If the gene name is &quot;*&quot;,
all the transcript will be selected.) Note: BioCoductor Annotation
<b>org.Hs.eg.db</b> is used to convert from gene name to ENTREZ gene id.</p>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_ranges_arg">ranges_arg</code></td>
<td>
<p>an integer matrix of three columns.  The columns define a range:
a chromosome number, a start base pair value, and an end base pair value.</p>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_chrs_arg">chrs_arg</code></td>
<td>
<p>an integer vector of chromosome numbers.  All of the base pairs on each
chromosomes will be selected as a single range.</p>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding marker genotype data in the<br />
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_type_arg">type_arg</code></td>
<td>
<p>a character vector of length 1 that contains <b>&quot;TX&quot;</b> or does not.  If it is
<b>&quot;TX&quot;</b>, which is the default, the <b>TX</b> fields of BioConductor Annotation,<br />
<b>TxDb.Hsapiens.UCSC.hg19.knownGene</b> are used to define the base pair ranges and chromosome.
Otherwise, the <b>CDS</b> fields are used.</p>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_fuzz_arg">fuzz_arg</code></td>
<td>
<p>is an integer vector of length one or two.  The first argument is used to reduce
the start base pair selected from each transcript and the second to increase the end base pair
position.  (If only one value is present, it is used for both adjustments.)  Note: The values
can be positive or negative.</p>
</td></tr>
<tr><td><code id="applyFnToGenes_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>If you want subsequent calls to <code>op</code> to share information, data can be placed in
a data frame that is added to the 'environment'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  db = system.file("exdata", "seqsimm.db", package="Mega2R")
  ENV = read.Mega2DB(db)

  show = function(m, r, e) {
      print(r)
      print(m)
      print(head(getgenotypes(m, envir = e)))
  }

   # apply function "show" to all transcripts on genes ELL2 and CARD15

    # donttestcheck: time
    applyFnToGenes(show, genes_arg = c("CEP104"))


   # apply function "show" to all genotypes on chromosomes 11 for two base
   # pair ranges
   applyFnToGenes(show, ranges_arg = matrix(c(1, 5000000, 10000000,
                  1, 10000000, 15000000), ncol = 3, nrow = 2, byrow = TRUE))

   # apply function "show" to all genotypes for first marker in each chromosome
   applyFnToGenes(show, markers_arg = ENV$markers[! duplicated(ENV$markers$chromosome), 3])

   # apply function "show" to all genotypes on chromosomes 24 and 26
   applyFnToGenes(show, chrs_arg=c(24, 26))


</code></pre>

<hr>
<h2 id='applyFnToMarkers'>apply a function to the genotypes from a set of markers</h2><span id='topic+applyFnToMarkers'></span>

<h3>Description</h3>

<p>A matrix of the genotypes for all the specified markers is generated.  Then, the call back function, <code>op</code>,
is called with the markers, NULL (for the range), and the 'environment'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyFnToMarkers(op      = function (markers, range, envir) {},
                markers_arg,
                envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyFnToMarkers_+3A_op">op</code></td>
<td>
<p>Is a function of three arguments.  It will be called once by
<code>applyFnToMarkers</code> in a try/catch context.  The arguments are:
</p>

<dl>
<dt>markers</dt><dd><p>Marker data for each marker in <strong>geno</strong>.  A marker is a data frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding marker genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>

</dd>
<dt>range</dt><dd><p>NULL: to indicate no explicit range was specified.</p>
</dd>
<dt>envir</dt><dd><p>An 'environment' holding Mega2R data frames and state data.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="applyFnToMarkers_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding marker genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="applyFnToMarkers_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  db = system.file("exdata", "seqsimm.db", package="Mega2R")
  ENV = read.Mega2DB(db)
  show = function(m, r, e) {
      print(r)
      print(m)
      print(head(getgenotypes(m, envir = e)))
  }

   # apply function "show" to all genotypes &gt; 5,000,000 bp
   applyFnToMarkers(show, ENV$markers[ENV$markers$position &gt; 5000000,])


</code></pre>

<hr>
<h2 id='applyFnToRanges'>apply a function to all the genotypes for markers found in several specified ranges</h2><span id='topic+applyFnToRanges'></span>

<h3>Description</h3>

<p>First, for each range, determine the markers that fall between the start and end
base pair of the range.  Then, for each set of
markers generate a matrix of the genotypes of those markers.  Finally, the <code>op</code> function is called for
each range with the arguments: markers, range, and 'environment'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>applyFnToRanges(op          = function (markers, range, envir) {},
                ranges_arg  = NULL,
                indices_arg = NULL,
                fuzz_arg    = 0,
                envir       = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="applyFnToRanges_+3A_op">op</code></td>
<td>
<p>Is a function of three arguments.  It will be called repeatedly by
<code>applyFnToRanges</code> in a try/catch context.  The arguments are:
</p>

<dl>
<dt>markers</dt><dd><p>Marker data for each marker in <strong>geno</strong>.  A marker is a data frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding marker genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>

</dd>
<dt>range</dt><dd><p>An indicator of which range argument of <code>applyFnToRanges</code> these markers correspond to.</p>
</dd>
<dt>envir</dt><dd><p>An 'environment' holding Mega2R data frames and state data.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="applyFnToRanges_+3A_ranges_arg">ranges_arg</code></td>
<td>
<p>is a data frame that contains at least 4 observations: a name, a chromosome, a
start base pair position and an end base pair position.</p>
</td></tr>
<tr><td><code id="applyFnToRanges_+3A_indices_arg">indices_arg</code></td>
<td>
<p>is a vector of 3 integers that specify the location of chromosome, start base
pair column and end base pair column of the ranges_arg data frame. An optional fourth integer
indicates the column containing the name of the ranges.</p>
</td></tr>
<tr><td><code id="applyFnToRanges_+3A_fuzz_arg">fuzz_arg</code></td>
<td>
<p>is an integer vector of length one or two.  The first argument is used to reduce
the start base pair selected from each range and the second to increase the end base pair
position.  (If only one value is present, it is used for both changes.) Note: The values
can be positive or negative.</p>
</td></tr>
<tr><td><code id="applyFnToRanges_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>If the <em>ranges_arg</em> and <em>indices_arg</em> are NULL or missing, then the default ranges that have been set by <code>setRanges</code>
are used.  If <code>setRanges</code> has not been called, a default set of the ranges is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  db = system.file("exdata", "seqsimm.db", package="Mega2R")
  ENV = read.Mega2DB(db)

  show = function(m, r, e) {
      print(r)
      print(m)
      print(head(getgenotypesraw(m, envir = e)))
  }

   # apply function "show" to all genotypes on chromosomes 1 for two base pair
   # ranges
   applyFnToRanges(show,
                   ranges_arg =
                   matrix(c(1, 2244000, 2245000,
                            1, 3762500, 3765000),
                           ncol = 3, nrow = 2, byrow = TRUE),
                   indices_arg = 1:3)

   # apply function "show" to all genotypes on chromosomes 1 for two base pair
   # ranges
   applyFnToRanges(show,
                   ranges_arg =
                   matrix(c(1, 2240000, 2245000, "range1",
                            1, 3760000, 3765000, "range2"),
                           ncol = 4, nrow = 2, byrow = TRUE),
                   indices_arg = 1:4)

</code></pre>

<hr>
<h2 id='clean_mega2rtutorial_data'>remove tutorial data</h2><span id='topic+clean_mega2rtutorial_data'></span>

<h3>Description</h3>

<p>This function removes the Mega2R tutorial (inst/exdata) data that was
copied to the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_mega2rtutorial_data(dir = file.path(tempdir(), "Mega2Rtutorial"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_mega2rtutorial_data_+3A_dir">dir</code></td>
<td>
<p>The directory to remove the tutorial data to.  By default, this is
tempdir()/Mega2Rtutorial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clean_mega2rtutorial_data()

</code></pre>

<hr>
<h2 id='computeDosage'>computeDosage function</h2><span id='topic+computeDosage'></span>

<h3>Description</h3>

<p>Convert the genotypesraw() allele patterns of 0x10001, 0x10002 (or 0x20001), 0x20002, 0
to the numbers 0, 1, 2, 9 for each marker. (Reverse, the order iff allele &quot;1&quot; has the
minor allele frequency.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeDosage(markers_arg, range_arg, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeDosage_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="computeDosage_+3A_range_arg">range_arg</code></td>
<td>
<p>one row of a ranges_arg.  The latter is a data frame of at least three
integer columns.  The columns indicate a range:
a chromosome number, a start base pair value, and an end base pair value.</p>
</td></tr>
<tr><td><code id="computeDosage_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals especially the
phenotype_table, <code>phe</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of samples X markers for all the markers that have nonzero changes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DOfamSKATRC">DOfamSKATRC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_famSKATRC(db, verbose = TRUE)
dimDosage = function(m, r, e) {print(dim(computeDosage(m, r, e)))}
applyFnToRanges(dimDosage, ENV$refRanges[50:60, ], ENV$refIndices, envir=ENV)
# This will use return dosage matrices for the markers in the ranges 50 - 60,
# but is basically ignores the results.

</code></pre>

<hr>
<h2 id='dbmega2_import'>read Mega2 SQLite database into R</h2><span id='topic+dbmega2_import'></span>

<h3>Description</h3>

<p>Read the fields of SQLite data base tables that are required for Mega2R into
data frames.
These data frames are stored in an 'environment' which is returned.
This function also adds some state data, extra data frames, and computed data frames
to the 'environment'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbmega2_import(dbname,
               bpPosMap = NULL,
               verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbmega2_import_+3A_dbname">dbname</code></td>
<td>
<p>file path to SQLite database.</p>
</td></tr>
<tr><td><code id="dbmega2_import_+3A_bpposmap">bpPosMap</code></td>
<td>
<p>index that specifies which map in the map_table should be used for
marker chromosome/position.  If it is NULL, the internal variable
<em>base_pair_position_index</em> is used instead.
<code>showMapNames()</code> shows the association between map name and map number.</p>
</td></tr>
<tr><td><code id="dbmega2_import_+3A_verbose">verbose</code></td>
<td>
<p>print out statistics on the name/size of each table read and show column headers.
Also, save the verbose value for use by other Mega2R functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>envir an environment that contains all the data frames made from the SQLite database.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = dbmega2_import(db, verbose = TRUE)

ENV = dbmega2_import(db)
</code></pre>

<hr>
<h2 id='dmpPed'>generate the .ped, .fam and .map files of PLINK PED representation of a gwaa.data-class object</h2><span id='topic+dmpPed'></span>

<h3>Description</h3>

<p>Use provided gwaa.data-class object and create a PLINK .ped file, PLINK .map file
and a PLINK .phe (phenotypes) file.  By default, <b>srdta</b> (a sample from GenABEL)
is used for the gwaa.data-class object.  The files are generated with a prefix of
<em>srdta</em> unless a pfx argument is provided.
NOTE: These PLINK files may be used by the Mega2 executable to produce a database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmpPed(gwaa_ = srdta, pfx, default = "bt")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmpPed_+3A_gwaa_">gwaa_</code></td>
<td>
<p>name of gwaa.data-class object used as input</p>
</td></tr>
<tr><td><code id="dmpPed_+3A_pfx">pfx</code></td>
<td>
<p>prefix for PLINK .ped/.map/.phe file names</p>
</td></tr>
<tr><td><code id="dmpPed_+3A_default">default</code></td>
<td>
<p>name of phenotype used for the 6th column of .ped file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dmpPed()
or
dmpPed(mygwaa, "name", "cc")

## End(Not run)
</code></pre>

<hr>
<h2 id='DOfamSKATRC'>DofamSKATRC call back function</h2><span id='topic+DOfamSKATRC'></span>

<h3>Description</h3>

<p>Convert the genotypesraw() allele patterns of 0x10001, 0x10002 (or 0x20001), 0x20002, 0
to the numbers 0, 1, 2, 9 for each marker. (Reverse, the order iff allele &quot;1&quot; has the
minor allele frequency.)  Ignore markers that have no variants.
Finally, invoke <code>famSKAT_RC</code> with the converted genotype matrix.
Save information about the range and the p.value calculated by <code>famSKAT_RC</code>
in <em>envir$famSKATRC_results</em>.
If you want to change the argument values to this function they should be changed instead
when calling the <code>Mega2famSKATRC</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOfamSKATRC(
  markers_arg,
  range_arg,
  envir,
  pheno = 3,
  id = NULL,
  covariates = NULL,
  sqrtweights_c = NULL,
  sqrtweights_r = NULL,
  binomialimpute = TRUE,
  acc = 1e-06,
  maf = 0.05,
  phi = c(0, 0.2, 0.5, 0.9)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DOfamSKATRC_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_range_arg">range_arg</code></td>
<td>
<p>one row of a ranges_arg.  The latter is a data frame of at least three
integer columns.  The columns indicate a range:
a chromosome number, a start base pair value, and an end base pair value.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals especially the
phenotype_table, <code>phe</code>.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_pheno">pheno</code></td>
<td>
<p>is an index into the phenotypes_table to select the phenotype.  Missing phenotypes
are represented by NA.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_id">id</code></td>
<td>
<p>a vector of individuals to be included in the test, a subset of the family members.
If NULL is given, all members will be used.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_covariates">covariates</code></td>
<td>
<p>a matrix of covariates for the phenotype.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_sqrtweights_c">sqrtweights_c</code></td>
<td>
<p>weight function for common variants, if NULL use weight set in init_famSKAT</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_sqrtweights_r">sqrtweights_r</code></td>
<td>
<p>weight function for rare variants, if NULL use weight set in init_famSKAT.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_binomialimpute">binomialimpute</code></td>
<td>
<p>if TRUE, impute missing genotypes using a binomial distribution.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_acc">acc</code></td>
<td>
<p>accuracy used in Davies approximation.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_maf">maf</code></td>
<td>
<p>threshold used to separate rare from common variants.</p>
</td></tr>
<tr><td><code id="DOfamSKATRC_+3A_phi">phi</code></td>
<td>
<p>a vector of ratios ratios; each indicates the contribution of rare variants.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This function accumulates output in the data frame, <em>envir$famSKATRC_results</em>.  It will
print out the lines as they are generated if <em>envir$verbose</em> is TRUE.  It does not write
the data frame to a file.  You must save the data frame.
You also must initialize the data frame when necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_famSKATRC">init_famSKATRC</a></code>, <code><a href="#topic+Mega2famSKATRC">Mega2famSKATRC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_famSKATRC(db, verbose = TRUE)
ENV$famSKATRC_results = ENV$famSKATRC_results[0, ]
Mega2famSKATRC(gs=1:1, envir=ENV, pheno=3)
# this sets one of the many arguments for DOfamSKATRC
# but basically prepares the ENV for the direct use of DOfamSKATRC (below).


# donttestcheck: try this below instead if there is time
 Mega2famSKATRC(genes=c("CEP104"), envir=ENV, pheno=3 )


# DOfamSKATRC is called within Mega2famSKATRC. init_famSKATRC and Mega2famSKATRC need to be
# called to set up the environment for famSKAT_RC to run.  BUT, you should ignore DOfamSKATRC
# and use Mega2famSKATRC instead.
#
applyFnToRanges(DOfamSKATRC, ENV$refRanges[50:60, ], ENV$refIndices, envir=ENV)
# this will use all the default argument values for DOfamSKATRC

</code></pre>

<hr>
<h2 id='DOpedgene'>pedgene call back function</h2><span id='topic+DOpedgene'></span>

<h3>Description</h3>

<p>First, ignore call backs that have less than two markers.  Second, convert the genotypesraw()
patterns of 0x10001, 0x10002 (or 0x20001), 0x20002, 0 from the genotype matrix
to the numbers 0, 1, 2, 0 for each marker. (Reverse, the order iff allele &quot;1&quot; has the
minor allele frequency.)  Next, prepend the pedigree and person columns of the family data
to this modified genotype matrix.  Finally, invoke <code>pedgene</code> with the family data and
genotype matrix for several different weights.  Save the kernel and burden, value and p-value for each
measurement in <em>envir$pedgene_results</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOpedgene(markers_arg, range_arg, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DOpedgene_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="DOpedgene_+3A_range_arg">range_arg</code></td>
<td>
<p>one row of a ranges_arg.  The latter is a data frame of at least three
integer columns.  The columns indicate a range:
a chromosome number, a start base pair value, and an end base pair value.</p>
</td></tr>
<tr><td><code id="DOpedgene_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This function appends output to the data frame, <em>envir$pedgene_results</em>.  It will
print out the lines as they are generated if <em>envir$verbose</em> is TRUE. The data frame
<em>envir$pedgene_results</em> is initialized by <em>init_pedgene</em>, and is appended to
each time <em>DOpedgene</em> is run.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_pedgene">init_pedgene</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_pedgene(db)
ENV$verbose = TRUE
applyFnToRanges(DOpedgene, ENV$refRanges[50:60,], ENV$refIndices)


# donttestcheck: try this below if there is time
applyFnToGenes(DOpedgene, genes_arg = c("CEP104"))


</code></pre>

<hr>
<h2 id='DOSKAT'>SKAT call back function</h2><span id='topic+DOSKAT'></span>

<h3>Description</h3>

<p>Convert the genotypesraw() allele patterns of 0x10001, 0x10002 (or 0x20001), 0x20002, 0
to the numbers 0, 1, 2, 9 for each marker. (Reverse, the order iff allele &quot;1&quot; has the
minor allele frequency.)  Ignore markers that have no variants (unless allMarkers is TRUE).
Finally, invoke <code>SKAT</code> with the converted genotype matrix, Null model saved in envir$obj,
and any additionally supplied arguments.
Save information about the range and the p.value calculated by <code>SKAT</code>
in <em>envir$SKAT_results</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DOSKAT(markers_arg, range_arg, envir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DOSKAT_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="DOSKAT_+3A_range_arg">range_arg</code></td>
<td>
<p>one row of a ranges_arg.  The latter is a data frame of at least three
integer columns.  The columns indicate a range:
a chromosome number, a start base pair value, and an end base pair value.</p>
</td></tr>
<tr><td><code id="DOSKAT_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
<tr><td><code id="DOSKAT_+3A_...">...</code></td>
<td>
<p>extra arguments for SKAT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This function accumulates output in the data frame, <em>envir$SKAT_results</em>.  It will
print out the lines as they are generated if <em>envir$verbose</em> is TRUE.  It does not write
the data frame to a file.  You must save the data frame.
You also must initialize the data frame when necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_SKAT">init_SKAT</a></code>, <code><a href="#topic+Mega2SKAT">Mega2SKAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_SKAT(db, verbose = TRUE, allMarkers = FALSE)
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, "D", gs=1:1)


# donttestcheck: try this below instead if there is time
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, "D", kernel = "linear.weighted", 
          weights.beta = c(0.5, 0.5), genes=c("CEP104") )


# DOSKAT is called internally to Mega2SKAT. init_SKAT and Mega2SKAT need to be
# called to set up the environment for DOSKAT to run.  You should ignore DOSKAT
# and use Mega2SKAT instead
#
applyFnToRanges(DOSKAT, ENV$refRanges[50:60, ], ENV$refIndices)

</code></pre>

<hr>
<h2 id='dump_mega2rtutorial_data'>dump tutorial data</h2><span id='topic+dump_mega2rtutorial_data'></span>

<h3>Description</h3>

<p>This function retrieves data stored in the Mega2rtutorial (inst/exdata).  It
dumps them in the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dump_mega2rtutorial_data(dir = file.path(tempdir(), "Mega2Rtutorial"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dump_mega2rtutorial_data_+3A_dir">dir</code></td>
<td>
<p>The directory to store the tutorial data to.  By default, this is
tempdir()/Mega2Rtutorial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dump_mega2rtutorial_data()

</code></pre>

<hr>
<h2 id='getAlleles'>pull allele pairs</h2><span id='topic+getAlleles'></span>

<h3>Description</h3>

<p>get alleles in order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getAlleles(markers = NULL, separator = "/", envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getAlleles_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="getAlleles_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string vector of alleles with separator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
getAlleles(envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='getgenotype_person'>return the genotypes for all markers of a given person</h2><span id='topic+getgenotype_person'></span>

<h3>Description</h3>

<p>for selected person, expand genotype bit vector to an integer vector with
one integer per marker.  Then convert the integer vector to genotypes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotype_person(perid = 1, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotype_person_+3A_perid">perid</code></td>
<td>
<p>person/sample identifier</p>
</td></tr>
<tr><td><code id="getgenotype_person_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# genotypes for all markers for n'th person in genotype table
getgenotype_person(1)

# genotypes for all markers for range of persons in genotype table
getgenotype_person(m:n)

## End(Not run)
</code></pre>

<hr>
<h2 id='getgenotypes'>fetch genotype character matrix for specified markers</h2><span id='topic+getgenotypes'></span>

<h3>Description</h3>

<p>This function calls a C++ function that does all the heavy lifting.  It passes the arguments
necessary for the C++ function: some from the caller's arguments and some from data frames
that are in the &quot;global&quot; environment, <b>envir</b>.  From the markers_arg argument, it fetches
the locus_index and the index in the <em>unified_genotype_table</em>. It also passes the allele
nucleotide separator argument.
From the &quot;global&quot; environment, <b>envir</b>, it gets a bit vector of compressed genotype information,
the alleles for each marker, and some bookkeeping related data.
Note: This function also contains a dispatch/switch on the type of compression in the genotype
vector.  A different C++ function is called when there is compression versus when there is no
compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotypes(markers_arg, sepstr = "", envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotypes_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getgenotypes_+3A_sepstr">sepstr</code></td>
<td>
<p>separator string inserted between the alleles (default is none).  When present, this
is typically a space, a tab or &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="getgenotypes_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>unified_genotype_table</em> contains one raw vector for each person.  In the vector
there are two bits for each genotype.  This function creates an output matrix by fixing
the marker and collecting genotype information for each person and then repeating for
all the needed markers.  (Currently, this appears slightly faster than a scan
which is fixes the person and iterates over markers.)
</p>


<h3>Value</h3>

<p>a matrix of genotypes represented as two allele pairs.  The matrix has one column for each
marker in <em>markers_arg</em> argument.  There is one row for each person in the family
(<em>fam</em>) table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

getgenotypes(ENV$markers)

</code></pre>

<hr>
<h2 id='getgenotypes_R'>fetch genotype matrix for specified markers (assemble by rows)</h2><span id='topic+getgenotypes_R'></span>

<h3>Description</h3>

<p>This function calls the C++ function that does all the heavy lifting.  It passes the
locus_index and the locus_offset in the <em>unified_genotype_table</em> from the
<em>markers_arg</em> argument.  It also gathers other data.frames that are in the &quot;global&quot;
<b>ENV</b> environment. One frame contains a bit vector of compressed genotype information,
another contains the alleles for each marker, and finally there are some bookkeeping related
data.  Note this function is for Testing only and is not exported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotypes_R(markers_arg, sepstr = "", envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotypes_R_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getgenotypes_R_+3A_sepstr">sepstr</code></td>
<td>
<p>separator string for alleles (default is none)</p>
</td></tr>
<tr><td><code id="getgenotypes_R_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>unified_genotype_table</em> contains one raw vector for each person.  In the vector
there are two bits for each genotype.  This function creates an output matrix by selecting
from each row all the needed markers and then repeating for each person.
</p>


<h3>Value</h3>

<p>a matrix of genotypes represented as a nucleotide pair.  There is one column for each
marker in <em>markers_arg</em> argument.  There is one row for each person in the family
(<em>fam</em>) table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# genotypes for all persons in markers data.frame argument
getgenotypes_R(ENV$markers)

# genotypes for all persons in chromosome n
getgenotypes_R(ENV$markers[ENV$markers$chromosome == n,])

## End(Not run)
</code></pre>

<hr>
<h2 id='getgenotypesdos'>fetch dosage integer matrix for specified markers</h2><span id='topic+getgenotypesdos'></span>

<h3>Description</h3>

<p>This function calls a C++ function that does all the heavy lifting.  It passes the arguments
necessary for the C++ function: some from the caller's arguments and some from data frames
that are in the &quot;global&quot; environment, <b>envir</b>.  From its markers_arg argument, it gets
the locus_index and the index in the <em>unified_genotype_table</em>.
From the &quot;global&quot; environment, <b>envir</b>, it gets a bit vector of compressed genotype information,
and some bookkeeping related data.
Note: This function also contains a dispatch/switch on the type of compression in the genotype
vector.  A different C++ function is called when there is compression versus when there is no
compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotypesdos(markers_arg, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotypesdos_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getgenotypesdos_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>unified_genotype_table</em> contains one raw vector for each person.  In the vector,
there are two bits for each genotype.  This function creates an output matrix by fixing
the marker and collecting genotype information for each person and then repeating for
all the specified markers.
</p>


<h3>Value</h3>

<p>a list of 3 values, named &quot;ncol&quot;, &quot;zero&quot;, &quot;geno&quot;.
</p>

<dl>
<dt>geno</dt><dd><p>is a matrix of dosages as integers.  The value 0 is given to the Major allele
value, 1 is given to the heterozygote value, and 2 is given to the Minor allele.
In the matrix, there is usually one column for each  marker in the <em>markers_arg</em> argument.
But if there would be only the one allele 0 or 2 in the column, the column is ignorednot present.
There is one row for each person in the family (<em>fam</em>) table.</p>
</dd>
<dt>ncol</dt><dd><p>Is the count of the actual number of columns in the geno matrix.</p>
</dd>
<dt>zero</dt><dd><p>Is a vector with one entry per marker.  The value will be 0 if the marker is
not in the geno matrix.  Otherwise the value is the column number in the geno matrix where
the marker data appears.</p>
</dd></dl>



<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

getgenotypesdos(ENV$markers[ENV$markers$chromosome == 1,])

</code></pre>

<hr>
<h2 id='getgenotypesgenabel'>process the genotype matrix for specified markers and return the corresponding GenABEL genotype matrix</h2><span id='topic+getgenotypesgenabel'></span>

<h3>Description</h3>

<p>This function calls a C++ function that does all the heavy lifting.  It passes the arguments
necessary for the C++ function: some from the caller's arguments and some from data frames
that are in the &quot;global&quot; environment, <b>envir</b>.  From its markers_arg argument, it gets
the locus_index and the index in the <em>unified_genotype_table</em>.
From the &quot;global&quot; environment, <b>envir</b>, it gets a bit vector of compressed genotype information,
allele information, and some bookkeeping related data.
Note: This function also contains a dispatch/switch on the type of compression in the genotype
vector.  A different C++ function is called when there is compression versus when there is no
compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotypesgenabel(markers_arg, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotypesgenabel_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getgenotypesgenabel_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads the genotype data in Mega2 compressed format and converts it to the GenABEL
compressed format.
The <em>unified_genotype_table</em> contains one raw vector for each person.  In the vector,
there are two bits for each genotype;  each byte has the data for 4 markers.  In GenABEL,
there is one raw vector per marker, and each byte has the data for 4 persons.  The C++
function does the conversion as well as adjusts the bits' contents.  For example, in GenABEL
the genotype represented by bits == 0, is what Mega2 represents with 2.
Doing the conversion in C++ is 10 - 20 times faster than converting the Mega2 data to
PLINK .tped files and then having GenABEL read in and process/convert those files.
</p>


<h3>Value</h3>

<p>the GenABEL gwaa.data-class object component that contains the genotype data.
</p>


<h3>Note</h3>

<p>This function is called from <code>Mega2ENVGenABEL</code>; it is not intended to be called
by the programmer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

aa = getgenotypesgenabel(ENV$markers[ENV$markers$chromosome == 1,])

aa

</code></pre>

<hr>
<h2 id='getgenotypesraw'>fetch genotype integer matrix for specified markers</h2><span id='topic+getgenotypesraw'></span>

<h3>Description</h3>

<p>This function calls a C++ function that does all the heavy lifting.  It passes the arguments
necessary for the C++ function: some from the caller's arguments and some from data frames
that are in the &quot;global&quot; environment, <b>envir</b>.  From its markers_arg argument, it gets
the locus_index and the index in the <em>unified_genotype_table</em>.
From the &quot;global&quot; environment, <b>envir</b>, it gets a bit vector of compressed genotype information,
and some bookkeeping related data.
Note: This function also contains a dispatch/switch on the type of compression in the genotype
vector.  A different C++ function is called when there is compression versus when there is no
compression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgenotypesraw(markers_arg, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgenotypesraw_+3A_markers_arg">markers_arg</code></td>
<td>
<p>a data.frame with the following 5 observations:
</p>

<dl>
<dt>locus_link</dt><dd><p>is the ordinal ranking of this marker among all loci</p>
</dd>
<dt>locus_link_fill</dt><dd><p>is the position of corresponding genotype data in the
<em>unified_genotype_table</em></p>
</dd>
<dt>MarkerName</dt><dd><p>is the text name of the marker</p>
</dd>
<dt>chromosome</dt><dd><p>is the integer chromosome number</p>
</dd>
<dt>position</dt><dd><p>is the integer base pair position of marker</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getgenotypesraw_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>unified_genotype_table</em> contains one raw vector for each person.  In the vector,
there are two bits for each genotype.  This function creates an output matrix by fixing
the marker and collecting genotype information for each person and then repeating for
all the needed markers.
</p>


<h3>Value</h3>

<p>a matrix of genotypes represented as integers.  Each 32 bit integer represents contains
two allele values: the high 16 bits contains the index of allele1 and the low 16 bits contains
the index of allele2.  In the matrix, there is one column for each
marker in the <em>markers_arg</em> argument.  There is one row for each person in the family
(<em>fam</em>) table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

# two ints in upper/lower half integer representing allele # for all persons in chromosome 1
getgenotypesraw(ENV$markers[ENV$markers$chromosome == 1,])

</code></pre>

<hr>
<h2 id='init_famSKATRC'>load Mega2 SQLite database and perform initialization for famSKATRC usage</h2><span id='topic+init_famSKATRC'></span>

<h3>Description</h3>

<p>This populates the <b>R</b> data frames with the specified <b>Mega2</b> SQLite database.  It initializes
the fam(ily) table and makes sure the person entries are unique.  Finally, it generates a kinship matrix
from the family data.  It also stores a weighting for the common and rare variant that may be used
later if NULL is specified as a weight in <em>Mega2famSKATRC</em>.  The common weighting is the function
<em>dbeta</em>(maf, 1, 25).  The rare weighting is the function <em>dbeta</em>(maf, 0.5, 0.5).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_famSKATRC(db = NULL, verbose = FALSE, ALPHA = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_famSKATRC_+3A_db">db</code></td>
<td>
<p>specifies the path of a <b>Mega2</b> SQLite database containing study data.</p>
</td></tr>
<tr><td><code id="init_famSKATRC_+3A_verbose">verbose</code></td>
<td>
<p>TRUE indicates that diagnostic printouts should be enabled.
This value is saved in the returned environment.</p>
</td></tr>
<tr><td><code id="init_famSKATRC_+3A_alpha">ALPHA</code></td>
<td>
<p>TRUE indicates that two runs of famSKAT_RC  should be enabled.
One with ALPHA numeric ID's and one with numeric IDs ... this is temporary.
The default is FALSE.</p>
</td></tr>
<tr><td><code id="init_famSKATRC_+3A_...">...</code></td>
<td>
<p>fed to <em>dbmega2_import()</em>; should be bpPosMap= to select from the maps of
base pairs, if the default is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;environment&quot; containing data frames from an SQLite database and some computed values.
</p>


<h3>Note</h3>

<p><em>init_famSKATRC</em> creates a new data frame, <em>envir$phe</em>, containing phenotype observations.
In addition, it initializes a matrix to aid
in translating a genotype allele matrix to a genotype count matrix.
</p>
<p>It also initializes the data frame <em>envir$famSKATRC_results</em> to zero rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mega2famSKATRC">Mega2famSKATRC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_famSKATRC(db, verbose = FALSE)
ls(ENV)

</code></pre>

<hr>
<h2 id='init_pedgene'>load Mega2 SQLite database and perform initialization for pedgene usage</h2><span id='topic+init_pedgene'></span>

<h3>Description</h3>

<p>This populates the <b>R</b> data frames from the specified <b>Mega2</b> SQLite database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_pedgene(db = NULL, verbose = FALSE, traitname = "default", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_pedgene_+3A_db">db</code></td>
<td>
<p>specifies the path of a <b>Mega2</b> SQLite database containing study data.</p>
</td></tr>
<tr><td><code id="init_pedgene_+3A_verbose">verbose</code></td>
<td>
<p>TRUE indicates that diagnostic printouts should be enabled.
This value is saved in the returned environment.</p>
</td></tr>
<tr><td><code id="init_pedgene_+3A_traitname">traitname</code></td>
<td>
<p>Name of the affection status trait to use to set the case/control status; default value = &quot;default&quot;.</p>
</td></tr>
<tr><td><code id="init_pedgene_+3A_...">...</code></td>
<td>
<p>fed to <em>dbmega2_import()</em>; should be bpPosMap= to select from the maps of
base pairs, if the default is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;environment&quot; containing data frames from an SQLite database and some computed values.
</p>


<h3>Note</h3>

<p><em>init_pedgene</em> calculates schaidPed and pedPer that are used later in the <em>Dopedgene</em> calculation.
In addition, it initializes a matrix to aid
in translating a genotype allele matrix to a genotype count matrix.
</p>
<p>It also initializes the dataframe <em>envir$pedgene_results</em> to zero rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DOpedgene">DOpedgene</a></code>, <code><a href="#topic+Mega2pedgene">Mega2pedgene</a></code>, <code><a href="#topic+mkfam">mkfam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_pedgene(db, traitname = "default")
ls(ENV)

</code></pre>

<hr>
<h2 id='init_SKAT'>load Mega2 SQLite database and perform initialization for SKAT usage</h2><span id='topic+init_SKAT'></span>

<h3>Description</h3>

<p>This populates the <b>R</b> data frames from the specified <b>Mega2</b> SQLite database.  It then
prunes the samples to only include members that have a definite case or control
status.  Undefined samples are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_SKAT(db = NULL, verbose = FALSE, allMarkers = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_SKAT_+3A_db">db</code></td>
<td>
<p>specifies the path of a <b>Mega2</b> SQLite database containing study data.</p>
</td></tr>
<tr><td><code id="init_SKAT_+3A_verbose">verbose</code></td>
<td>
<p>TRUE indicates that diagnostic printouts should be enabled.
This value is saved in the returned environment.</p>
</td></tr>
<tr><td><code id="init_SKAT_+3A_allmarkers">allMarkers</code></td>
<td>
<p>TRUE means use all markers in a given transcript even if there is no
variation.  FALSE means ignore markers that show no variation; this is the default.</p>
</td></tr>
<tr><td><code id="init_SKAT_+3A_...">...</code></td>
<td>
<p>fed to <em>dbmega2_import()</em>; should be bpPosMap= to select from the maps of
base pairs, if the default is not desired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>&quot;environment&quot; containing data frames from an SQLite database and some computed values.
</p>


<h3>Note</h3>

<p><em>init_SKAT</em> creats a data frame, <em>envir$phe</em>, of phenotype observations.
In addition, it initializes a matrix to aid
in translating a genotype allele matrix to a genotype count matrix.
</p>
<p>It also initializes the data frame <em>envir$SKAT_results</em> to zero rows.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Mega2SKAT">Mega2SKAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_SKAT(db, verbose = FALSE, allMarkers = FALSE)
ls(ENV)

</code></pre>

<hr>
<h2 id='Mega2ENVGenABEL'>generate gwaa.data-class object</h2><span id='topic+Mega2ENVGenABEL'></span>

<h3>Description</h3>

<p>create a gwaa.data-class object from the data frames in a Mega2 environment.  This
function is a front end that eventually calls a C++ Rcpp function that reads
the genotype data in Mega2 compressed format and converts it to the GenABEL
compressed format.  The results of <code>Mega2ENVGenABEL</code> are/should be the same
as <code>Mega2GenABEL</code>, but the calculation is much faster, typically a factor of 10 to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2ENVGenABEL(
  markers = NULL,
  force = TRUE,
  makemap = FALSE,
  sort = TRUE,
  envir = ENV
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2ENVGenABEL_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="Mega2ENVGenABEL_+3A_force">force</code></td>
<td>
<p>pass value to gwaa conversion function</p>
</td></tr>
<tr><td><code id="Mega2ENVGenABEL_+3A_makemap">makemap</code></td>
<td>
<p>pass value to gwaa conversion function</p>
</td></tr>
<tr><td><code id="Mega2ENVGenABEL_+3A_sort">sort</code></td>
<td>
<p>pass value to gwaa conversion function</p>
</td></tr>
<tr><td><code id="Mega2ENVGenABEL_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gwaa.data-class object created from Mega2R database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require("GenABEL")
db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
gwaa = Mega2ENVGenABEL(markers=ENV$markers[1:10,])

str(gwaa)
head(summary(gwaa))

## End(Not run)

</code></pre>

<hr>
<h2 id='Mega2famSKATRC'>execute the CRAN famSKAT_RC function on a subset of the gene transcripts</h2><span id='topic+Mega2famSKATRC'></span>

<h3>Description</h3>

<p>If the <em>gene</em> argument is NULL, execute the famSKAT_RC function on the first <em>gs</em>
gene transcripts (default is gs = 1:100).
Update the <em>envir$famSKATRC_results</em> data frame with the results.
Otherwise, <em>gene</em> is a string vector of genes to process.  The special value '*' stands
for all the known genes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2famSKATRC(gs = 1:100, genes = NULL, envir = ENV, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2famSKATRC_+3A_gs">gs</code></td>
<td>
<p>a subrange of the default transcripts (refRanges) over which to calculate
the <em>DOfamSKATRC</em> function.</p>
</td></tr>
<tr><td><code id="Mega2famSKATRC_+3A_genes">genes</code></td>
<td>
<p>a list of genes over which to calculate the <em>DOfamSKATRC</em> function.
The value, &quot;*&quot;, means use all the transcripts in the selected Bioconductor database.
If genes is NULL, the gs range of the internal <em>refRanges</em> will be used.</p>
</td></tr>
<tr><td><code id="Mega2famSKATRC_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals.</p>
</td></tr>
<tr><td><code id="Mega2famSKATRC_+3A_...">...</code></td>
<td>
<p>extra arguments that are acceptable to famSKAT_RC.  These are listed with the
<code><a href="#topic+DOfamSKATRC">DOfamSKATRC</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data frame with the results is stored in the environment and named <em>famSKATRC_results</em>,
viz. envir$famSKATRC_results
</p>


<h3>Note</h3>

<p>A helper function
<code>SKAT3arg</code> is defined for the 3 argument callback function which in turn calls
<code>DOfamSKATRC</code> with the appropriate arguments (including those specific to the
<code>Mega2famSKATRC</code> function).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_famSKATRC">init_famSKATRC</a></code>, <code><a href="#topic+DOfamSKATRC">DOfamSKATRC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_famSKATRC(db, verbose = FALSE)
ENV$verbose = FALSE
ENV$famSKATRC_results = ENV$famSKATRC_results[0, ]
Mega2famSKATRC(gs=50:60, envir=ENV, pheno=3)


# donttestcheck: try this below if there is time
 Mega2famSKATRC(genes=c("CEP104"), envir=ENV, pheno=3 )


ENV$famSKATRC_results

</code></pre>

<hr>
<h2 id='Mega2gdsfmt'>transcode mega2 to gdsfmt/SNP_ARRAY</h2><span id='topic+Mega2gdsfmt'></span>

<h3>Description</h3>

<p>Reads the data frames in &quot;envir&quot; and builds a GDSFMT COREARRAY file from them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2gdsfmt(
  filename = "test.gds",
  markers = NULL,
  snp.order = FALSE,
  SeqArray = FALSE,
  envir = ENV
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2gdsfmt_+3A_filename">filename</code></td>
<td>
<p>gdsfmt file to create</p>
</td></tr>
<tr><td><code id="Mega2gdsfmt_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="Mega2gdsfmt_+3A_snp.order">snp.order</code></td>
<td>
<p>TRUE indicates that the &quot;genotype&quot; data matrix has SNP as the first index
which changes more quickly than subsequent indices.  FALSE indicates that SAMPLE is the
the first index.</p>
</td></tr>
<tr><td><code id="Mega2gdsfmt_+3A_seqarray">SeqArray</code></td>
<td>
<p>TRUE uses SeqArray labels for the gdsfmt vector elements.  FALSE it uses labels
shown in SNPRelate</p>
</td></tr>
<tr><td><code id="Mega2gdsfmt_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>writes the &quot;filename&quot; file containing the CoreArray data.  Then returns an internal
pointer, class .gds, to the file data.
</p>


<h3>See Also</h3>

<p><code>gdsfmt</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
gdsfmtfile = file.path(where_mega2rtutorial_data(), "test.gds")
append_genotype_a = TRUE
append_genotype_b = append_genotype_c = FALSE
gn = Mega2gdsfmt(gdsfmtfile, envir=ENV)
gn

</code></pre>

<hr>
<h2 id='Mega2GenABEL'>generate gwaa.data-class object from a <b>Mega2R</b> database</h2><span id='topic+Mega2GenABEL'></span>

<h3>Description</h3>

<p>Call the <em>Mega2R</em> functions to: create a .tped file, a .tfam file and a .phe file.
Then call the GenABEL functions to process these files: the .tped and the .tfam
file are processed by <code>convert.snp.tped</code> to produce a tped.raw file.  The latter
is combined with a .phe (phenotype) file by <code>load.gwaa.data</code> to create a gwaa.data-class
object in memory.  All these files are deleted when the exits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2GenABEL(markers = NULL, mapno = 0, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2GenABEL_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="Mega2GenABEL_+3A_mapno">mapno</code></td>
<td>
<p>specify which map index to use for physical distances</p>
</td></tr>
<tr><td><code id="Mega2GenABEL_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gwaa.data-class object generated from the Mega2R database
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require("GenABEL")
db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
seqsimgwaa = Mega2GenABEL(markers=ENV$markers[1:10,])

str(seqsimgwaa)
head(summary(seqsimgwaa))

## End(Not run)

</code></pre>

<hr>
<h2 id='Mega2GenABELClean'>delete temporary PLINK tped files processed by GenABEL</h2><span id='topic+Mega2GenABELClean'></span>

<h3>Description</h3>

<p>Delete the PLINK .tped files:  a .tped file, a .tfam file and a .phe file and
the GenABEL tped.raw file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2GenABELClean()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

Mega2GenABELClean()

## End(Not run)
</code></pre>

<hr>
<h2 id='Mega2GenABELtst'>compare two gwaa.data-class objects</h2><span id='topic+Mega2GenABELtst'></span>

<h3>Description</h3>

<p>Verify by fields, all the fields in two gwaa.data-class objects.
Show more detailed marker information iff the coding values are different.  (When comparing
two gwaa.data-class objects, one native and one created via <b>Mega2R</b> sometimes
when an allele frequency is .5 for both alleles, the allele order 1/2 vs 2/1 can not be
currently be determined.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2GenABELtst(mega_ = mega, gwaa_ = srdta, full = TRUE, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2GenABELtst_+3A_mega_">mega_</code></td>
<td>
<p>name of first gwaa.data-class object</p>
</td></tr>
<tr><td><code id="Mega2GenABELtst_+3A_gwaa_">gwaa_</code></td>
<td>
<p>name of second gwaa.data-class object</p>
</td></tr>
<tr><td><code id="Mega2GenABELtst_+3A_full">full</code></td>
<td>
<p>if TRUE convert genotypes to text as.character(gwaa_@gtdata)<br /> and as.character(mega_@gtdata).
Then standardize the order for heterozygous alleles and finally compare.
This step is optional because it can be rather slow.</p>
</td></tr>
<tr><td><code id="Mega2GenABELtst_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db = system.file("exdata", "seqsimm.db", package="Mega2R")
require("GenABEL")
ENV = read.Mega2DB(db)

y = Mega2ENVGenABEL()
Mega2GenABELtst(y, y, full = FALSE)

## End(Not run)

## Not run: 
# donttestcheck: if you have more time, try ...
x = Mega2GenABEL()
Mega2GenABELtst(x, y, full = FALSE)

## End(Not run)

</code></pre>

<hr>
<h2 id='Mega2pedgene'>Execute the pedgene function on a transcript ranges</h2><span id='topic+Mega2pedgene'></span>

<h3>Description</h3>

<p>Execute the pedgene function on the first <em>gs</em> default gene transcript ranges (gs = 1:100).
Update the <em>envir$pedgene_results</em> data frame with the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2pedgene(gs = 1:100, genes = NULL, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2pedgene_+3A_gs">gs</code></td>
<td>
<p>a subrange of the default transcript ranges over which to calculate the <em>Dopedgene</em> function.</p>
</td></tr>
<tr><td><code id="Mega2pedgene_+3A_genes">genes</code></td>
<td>
<p>a list of genes over which to calculate the <em>DOpedgene</em> function.
The value, &quot;*&quot;, means use all the transcripts in the selected Bioconductor database.
If genes is NULL, the gs range of the internal <em>refRanges</em> will be used.</p>
</td></tr>
<tr><td><code id="Mega2pedgene_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
the data frame with the results is stored in the environment and named <em>pedgene_results</em>,
viz. envir$pedgene_results
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_pedgene">init_pedgene</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_pedgene(db)
ENV$verbose = TRUE
Mega2pedgene(gs = 50:60)

</code></pre>

<hr>
<h2 id='Mega2R-TBLS'>Mega2R SQLite3 tables</h2><span id='topic+Mega2R-TBLS'></span><span id='topic+TBLS'></span>

<h3>Description</h3>

<p>This character vector indicates the names of the Mega2 SQLite3 database tables
to load.  (Not all of the existing tables are loaded.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TBLS
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 15.
</p>


<h3>Author(s)</h3>

<p>Robert V Baron
</p>

<hr>
<h2 id='Mega2R-TBLSFilter'>Mega2R SQLite3 table filter</h2><span id='topic+Mega2R-TBLSFilter'></span><span id='topic+TBLSFilter'></span>

<h3>Description</h3>

<p>This list contains named values.  The name corresponds to an SQLite database table.
The value is a character string of column names from the &quot;named&quot; table that should be fetched.  A table
is in this list, if not all the database table columns are needed.  The columns for each table are separated
by commas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TBLSFilter
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 7.
</p>


<h3>Note</h3>

<p>For the data base tables not in this list, all columns are stored in the corresponding data frame.
</p>


<h3>Author(s)</h3>

<p>Robert V Baron
</p>

<hr>
<h2 id='Mega2RVersion'>Mega2R version</h2><span id='topic+Mega2RVersion'></span>

<h3>Description</h3>

<p>This string indicates the current release of Mega2R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2RVersion
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 1.
</p>


<h3>Author(s)</h3>

<p>Robert V Baron
</p>

<hr>
<h2 id='Mega2SKAT'>execute the CRAN SKAT function on a subset of the gene transcripts</h2><span id='topic+Mega2SKAT'></span>

<h3>Description</h3>

<p>Execute the SKAT function on the first <em>gs</em> default gene transcripts (gs = 1:100).
Update the <em>envir$SKAT_results</em> data frame with the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2SKAT(f, ty, gs = 1:100, genes = NULL, skat = SKAT::SKAT, envir = ENV, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2SKAT_+3A_f">f</code></td>
<td>
<p>SKAT_Null_Model formula.  If this is non NULL, envir$obj is initialized by calling
SKAT_Null_Model(f, out_type = ty).  If you need to specify additional arguments to the Model
viz. (data, Adjustment, n.Resampling, type.Resampling)
or need to use a different model viz. SKAT_NULL_emmaX, <br /> SKAT_Null_Model_ChrX
set the formula to NULL, then before Mega2SKAT is called, build the model you need and
assign it to ENV$obj.</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_ty">ty</code></td>
<td>
<p>type of phenotype C/D = Continuous/Binary 5 (internal type 1/2)</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_gs">gs</code></td>
<td>
<p>a subrange of the default transcripts (refRanges) over which to calculate
the <em>DOSKAT</em> function.</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_genes">genes</code></td>
<td>
<p>a list of genes over which to calculate the <em>DOSKAT</em> function.
The value, &quot;*&quot;, means use all the transcripts in the selected Bioconductor database.
If genes is NULL, the gs range of the internal <em>refRanges</em> will be used.</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_skat">skat</code></td>
<td>
<p>alternate SKAT function, viz. SKATBinary, SKAT_CommonRare.  If it is also
necessary is to pass additional arguments to the SKAT function, they may be added to the end
of the Mega2SKAT function and will be passed.  See examples</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
<tr><td><code id="Mega2SKAT_+3A_...">...</code></td>
<td>
<p>extra arguments for SKAT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
the data frame with the results is stored in the environment and named <em>SKAT_results</em>,
viz. envir$SKAT_results
</p>


<h3>Note</h3>

<p>The <code>SKAT_Null_Model</code> is called if the formula, f, is not NULL.  A helper function
<code>SKAT3arg</code> is defined for the 3 argument callback function which in turn calls
<code>DOSKAT</code> with the appropriate arguments (including those additional to the
<code>Mega2SKAT</code> function).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+init_SKAT">init_SKAT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = init_SKAT(db, verbose = FALSE, allMarkers = FALSE)
ENV$verbose = FALSE
ENV$SKAT_results = ENV$SKAT_results[0, ]
Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, "D", kernel = "linear.weighted", 
          weights.beta = c(0.5, 0.5), gs=50:60 )


# donttestcheck: try this below if there is time
 Mega2SKAT(ENV$phe[, 3] - 1 ~ 1, "D", kernel = "linear.weighted", 
           weights.beta = c(0.5, 0.5), genes=c("CEP104") )


ENV$SKAT_results

</code></pre>

<hr>
<h2 id='Mega2VCF'>generate a VCF file set for a collection of markers</h2><span id='topic+Mega2VCF'></span>

<h3>Description</h3>

<p>Generate a VCF file from the specified Mega2 SQLite database.  The file is named <em>&quot;prefix&quot;.vcf</em>
If the markers argument is.null(), the entire <b>envir$markers</b> set is used, otherwise markers argument MUST
be rows of the markers (<b>envir$markers</b>) data frame.
In addition,
several other files are generated to hold additional database information: <em>&quot;prefix&quot;.fam</em>, <em>&quot;prefix&quot;.freq</em>, <em>&quot;prefix&quot;.map</em>,
<em>&quot;prefix&quot;.phe</em>, and <em>&quot;prefix&quot;.pen</em>, which contain the pedigree, allele frequency, marker genetic and
physical map position, member phenotype and phenotype penetrance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mega2VCF(
  prefix,
  markers = NULL,
  mapno = 0,
  alleleOrder = "default",
  envir = ENV
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mega2VCF_+3A_prefix">prefix</code></td>
<td>
<p>prefix of output files including the VCF file (see Description section above). This prefix can include a path.</p>
</td></tr>
<tr><td><code id="Mega2VCF_+3A_markers">markers</code></td>
<td>
<p>markers selected to be in the VCF output file</p>
</td></tr>
<tr><td><code id="Mega2VCF_+3A_mapno">mapno</code></td>
<td>
<p>specify which map index to use for genetic distances.  The function <code>showMapNames()</code>
will print out the internal map numbers corresponding to all the maps in the Mega2 database.</p>
</td></tr>
<tr><td><code id="Mega2VCF_+3A_alleleorder">alleleOrder</code></td>
<td>
<p>how to order alleles in VCF file.
'default' is Mega2order, 'minor' is minor allele freq first, 'major' is major allele freq
first, and 'name' is ascending ascii character order of allele name.</p>
</td></tr>
<tr><td><code id="Mega2VCF_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p>This code in this package illustrates how to extract the various kinds of data in the
Mega2 data frames to use for further processing.  Some of the data internal representations
are a bit quirky but the code &quot;explains&quot; it all.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
vcfdir = file.path(where_mega2rtutorial_data(), "vcfr")
if (!dir.exists(vcfdir)) dir.create(vcfdir)
vcffile = file.path(where_mega2rtutorial_data(), "vcfr", "vcf.01")
Mega2VCF(vcffile, ENV$markers[ENV$markers$chromosome == 1, ][1:10,], envir = ENV)
list.files(vcfdir)

</code></pre>

<hr>
<h2 id='mk_markers_with_skip'>make the derived &quot;markers&quot; data frame and store it in the environment.</h2><span id='topic+mk_markers_with_skip'></span>

<h3>Description</h3>

<p>Create the markers data frame as a subset of the markers_table data frame.  It contains 5
observations: </p>

<dl>
<dt>locus_link:</dt><dd><p>locus offset of this marker</p>
</dd>
<dt>locus_link_fill:</dt><dd><p>locus offset plus an accumulating fudge factor that jumps
with each new chromosome because the count of markers per chromosome is force to be
a multiple of 4.  (This value corresponds to the offset of the marker in the
<code>unified_genotype_table</code>.)</p>
</dd>
<dt>MarkerName:</dt><dd><p>name of this marker</p>
</dd>
<dt>chromosome:</dt><dd><p>chromosome number of this marker</p>
</dd>
<dt>position:</dt><dd><p>base pair position of this marker (selected by bpPosMap[below])</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>mk_markers_with_skip(bpPosMap = 1, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_markers_with_skip_+3A_bpposmap">bpPosMap</code></td>
<td>
<p>An integer that indicates the map (index) to use to fetch the
chromosome/position fields from the map_table data frame to merge with the marker_table.</p>
</td></tr>
<tr><td><code id="mk_markers_with_skip_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mk_markers_with_skip(1)

## End(Not run)
</code></pre>

<hr>
<h2 id='mk_unified_genotype_table'>concatenate separate genotype vectors for each chromosome to one extended vector containing all the chromosomes
and store it in the environment.</h2><span id='topic+mk_unified_genotype_table'></span>

<h3>Description</h3>

<p>The genotype_table data frame contains for each person a separate record for each chromosome.
Concatenate all the separate records for each person in chromosome order and make a data frame of these vectors.
Note:  Genotype vectors are &quot;raw&quot; (byte) vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mk_unified_genotype_table(envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mk_unified_genotype_table_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='mkAlleles'>generate allele pairs in with MAJ(or) allele first</h2><span id='topic+mkAlleles'></span>

<h3>Description</h3>

<p>The genotypes are ordered so the allele with the greater frequency appears first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkAlleles(markers = NULL, separator = "/", envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkAlleles_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="mkAlleles_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkAlleles(envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkfam'>assemble pedigree information into a data frame</h2><span id='topic+mkfam'></span>

<h3>Description</h3>

<p>Generate a data frame with a row for each person.  The observations are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>pedigree</strong> </td><td style="text-align: left;"> family pedigree name</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>person</strong> </td><td style="text-align: left;"> person name</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>father</strong> </td><td style="text-align: left;"> father of person</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>mother</strong> </td><td style="text-align: left;"> mother of person</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>sex</strong> </td><td style="text-align: left;"> sex of person</td>
</tr>
<tr>
 <td style="text-align: left;">
<strong>trait</strong> </td><td style="text-align: left;"> value of case/control phenotype for person
</td>
</tr>

</table>



<h3>Usage</h3>

<pre><code class='language-R'>mkfam(brkloop = FALSE, traitname = "default", envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkfam_+3A_brkloop">brkloop</code></td>
<td>
<p>I haven't needed to set this TRUE yet.  Maybe never will.
If loops are broken, a person will be replaced by a dopple ganger in the same family with a
different father/mother.  The number of persons per family will be different when there
are broken loops.  Also, the person_link numbers will be different for all the persons after
the first loop is broken.</p>
</td></tr>
<tr><td><code id="mkfam_+3A_traitname">traitname</code></td>
<td>
<p>Name of the trait to use as case/control value; by default, &quot;default&quot;</p>
</td></tr>
<tr><td><code id="mkfam_+3A_envir">envir</code></td>
<td>
<p>An 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
that is described above
</p>


<h3>Note</h3>

<p>The columns of this data frame come by selecting the values after merging the data frames: <em>pedigree_table</em>, <em>person_table</em>, and <em>trait_table</em>.
</p>
<p>Also, the father and mother columns from <em>person_table</em> are translated from the row index in the
<em>person_table</em> to the corresponding name.
</p>
<p>This function stores the data frame in the 'environment' and also returns it.
The function <code>setfam()</code> stores the data frame
into the 'environment' and adjusts the <em>genotype_table</em> and the <em>phenotype_table</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

fam = mkfam()

fam

</code></pre>

<hr>
<h2 id='mkGenABELcoding'>generate GenABEL coding vector</h2><span id='topic+mkGenABELcoding'></span>

<h3>Description</h3>

<p>Each element of the coding vector is the index of the corresponding genotype in the GenABEL:::alleleID.codes() array.
The genotypes are ordered so the allele with the greater frequency appears first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkGenABELcoding(markers = NULL, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkGenABELcoding_+3A_markers">markers</code></td>
<td>
<p>data frame of markers to be processed</p>
</td></tr>
<tr><td><code id="mkGenABELcoding_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkGenABELcoding(envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkGenABELgenotype'>generate GenABEL compressed genotype matrix</h2><span id='topic+mkGenABELgenotype'></span>

<h3>Description</h3>

<p>The matrix is (# of samples / 4 ) x (# of markers).  (# of samples is rounded to a multiple of 4.
Each byte stores data for 4 samples; a byte has 4 - 2 bit encodings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkGenABELgenotype(markers = NULL, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkGenABELgenotype_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkGenABELgenotype(envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkGenABELphenotype'>generate required PLINK (.phe) file</h2><span id='topic+mkGenABELphenotype'></span>

<h3>Description</h3>

<p>Generate the .phe (PLINK phenotype) file needed by GenAbel.  The person
must match that specified in the .tfam file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkGenABELphenotype(envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkGenABELphenotype_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>out phenotype data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
mkGenABELphenotype(ENV)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkGenABELtfam'>generate required fam family for PLINK TPED (.tfam) file</h2><span id='topic+mkGenABELtfam'></span>

<h3>Description</h3>

<p>Generate the six column .tfam file used with the .tped file.  Note: Only the person id
column appears to be used by GenABEL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkGenABELtfam(prefix, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkGenABELtfam_+3A_prefix">prefix</code></td>
<td>
<p>prefix for generated file name</p>
</td></tr>
<tr><td><code id="mkGenABELtfam_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
mkGenABELtfam("foo", ENV)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkGenABELtped'>generate a PLINK TPED file for GenABEL</h2><span id='topic+mkGenABELtped'></span>

<h3>Description</h3>

<p>Generate a PLINK TPED file from the specified Mega2 SQLite database.  The file is named &quot;prefix&quot;.tped
If the markers argument is.null(), the entire envir$markers set is include; otherwise the markers argument MUST
be a subset of the envir$markers data.frame &ndash; same columns, but fewer rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkGenABELtped(prefix, markers = NULL, mapno = 0, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkGenABELtped_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .tped file name</p>
</td></tr>
<tr><td><code id="mkGenABELtped_+3A_markers">markers</code></td>
<td>
<p>markers selected to be in output file</p>
</td></tr>
<tr><td><code id="mkGenABELtped_+3A_mapno">mapno</code></td>
<td>
<p>specify which map index to use for genetic distances</p>
</td></tr>
<tr><td><code id="mkGenABELtped_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
mkGenABELtped("foo", NULL, 0, ENV)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkMarkers'>create &quot;markers&quot; data frame</h2><span id='topic+mkMarkers'></span>

<h3>Description</h3>

<p>Create the markers data frame.  It contains 5
observations: </p>

<dl>
<dt>locus_link:</dt><dd><p>locus offset of this marker</p>
</dd>
<dt>locus_link_fill:</dt><dd><p>locus offset plus an accumulating fudge factor that jumps
with each new chromosome because the count of markers per chromosome is force to be
a multiple of 4.  (This value corresponds to the offset of the marker in the
<code>unified_genotype_table</code>.)</p>
</dd>
<dt>MarkerName:</dt><dd><p>name of the marker</p>
</dd>
<dt>chromosome:</dt><dd><p>chromosome number of the marker</p>
</dd>
<dt>position:</dt><dd><p>base pair position of the marker (selected by bpPosMap[below])</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>mkMarkers(bpPosMap = 1, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkMarkers_+3A_bpposmap">bpPosMap</code></td>
<td>
<p>An integer that indicates the map (index) to use to merge the
chromosome/position fields from the map_table data frame to the marker_table data frame.
See showMapNames() for the string name to index mapping.</p>
</td></tr>
<tr><td><code id="mkMarkers_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Select a map (index) from the map_table to merge with the select marker_table
data frame to make the marker data frame.  See showMapNames() for the string name to index mapping.
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db, verbose = FALSE)

mkMarkers(1)

ENV$markers

</code></pre>

<hr>
<h2 id='mkphenotype'>generate a phenotype data frame</h2><span id='topic+mkphenotype'></span>

<h3>Description</h3>

<p>Convert data in phenotype_table to a data frame of columns that are phenotypes.
The columns may be affection status or quantitative values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkphenotype(envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkphenotype_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>is a data frame with FID column, then IID column, and then
an additional column for each phenotype.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
out = mkphenotype()

out
</code></pre>

<hr>
<h2 id='mkVCFfam'>generate required VCF family (.fam) file</h2><span id='topic+mkVCFfam'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFfam(prefix, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFfam_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .fam file (family pedigree)</p>
</td></tr>
<tr><td><code id="mkVCFfam_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFfam(prefix, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkVCFfreq'>generate required VCF frequency (.freq) file</h2><span id='topic+mkVCFfreq'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFfreq(prefix, markers, recode = FALSE, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFfreq_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .freq file (frequency)</p>
</td></tr>
<tr><td><code id="mkVCFfreq_+3A_markers">markers</code></td>
<td>
<p>data.frame of markers being processed</p>
</td></tr>
<tr><td><code id="mkVCFfreq_+3A_recode">recode</code></td>
<td>
<p>use 1/2 instead of two given alleles (eg. A/C)</p>
</td></tr>
<tr><td><code id="mkVCFfreq_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFfreq(prefix, NULL, FALSE, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkVCFhdr'>generate required VCF header</h2><span id='topic+mkVCFhdr'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFhdr(prefix, markers, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFhdr_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .vcf file</p>
</td></tr>
<tr><td><code id="mkVCFhdr_+3A_markers">markers</code></td>
<td>
<p>data.frame of markers being processed</p>
</td></tr>
<tr><td><code id="mkVCFhdr_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFhdr(prefix, NULL, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkVCFmap'>generate required Mega2 map (.map) file</h2><span id='topic+mkVCFmap'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFmap(prefix, markers, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFmap_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .map file</p>
</td></tr>
<tr><td><code id="mkVCFmap_+3A_markers">markers</code></td>
<td>
<p>data.frame of markers being processed</p>
</td></tr>
<tr><td><code id="mkVCFmap_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFmap(prefix, NULL, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkVCFpen'>generate required Mega2 penetrance (.pen) file</h2><span id='topic+mkVCFpen'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFpen(prefix, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFpen_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .pen file (penetrance)</p>
</td></tr>
<tr><td><code id="mkVCFpen_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFpen(prefix, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='mkVCFphe'>generate required PLINK (.phe) file</h2><span id='topic+mkVCFphe'></span>

<h3>Description</h3>

<p>Generate the initial boiler plate VCF, then generate ##INFO entries for each entry tag.
Finally, generate the ##contig entries for each chromosome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkVCFphe(prefix, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkVCFphe_+3A_prefix">prefix</code></td>
<td>
<p>prefix for .phe file (phenotype)</p>
</td></tr>
<tr><td><code id="mkVCFphe_+3A_envir">envir</code></td>
<td>
<p>&quot;environment&quot; containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mkVCFphe(prefix, envir)

## End(Not run)
</code></pre>

<hr>
<h2 id='read.Mega2DB'>load Mega2 database and initialize family data frame and markers data frame</h2><span id='topic+read.Mega2DB'></span>

<h3>Description</h3>

<p>Call <code>dbmega2_import()</code> with the specified database and create an 'environment', with the
SQLite table data loaded into data frames.
Also run <code>mkfam()</code> to create the pedigree data frame <em>fam</em> and then store it with <code>setfam()</code>.
<code>setfam()</code> modifies the <em>unified_genotype_table</em> (and <em>phenotype_table</em>) to match the family members
that remain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.Mega2DB(db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.Mega2DB_+3A_db">db</code></td>
<td>
<p>specify SQLite database to load</p>
</td></tr>
<tr><td><code id="read.Mega2DB_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code>dbmega2_import</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an 'environment' that contains all the data frames created from the SQLite database.
</p>


<h3>Note</h3>

<p>By default, <code>mkfam</code> will remove one of each
person that was replicated to break loops in the pedigree, see <code>mkfam</code> for details.
If you want to leave loops broken, the code is available, but you will have to write your own
version of read.Mega2DB with a different invokation of <code>mkfam()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db, verbose = TRUE)

</code></pre>

<hr>
<h2 id='resetMega2ENV'>return an initialized environment</h2><span id='topic+resetMega2ENV'></span>

<h3>Description</h3>

<p>Mega2 uses an environment to store the data frames when it reads an SQLite database.
The environment is also used to store metadata.
The function first runs the garbage collector (&quot;gc&quot;), then allocates an empty environment
and finally loads some default data into it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resetMega2ENV()
</code></pre>


<h3>Value</h3>

<p>an environment that contains a few initial tables read from the Mega2R package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
resetMega2ENV()

## End(Not run)
</code></pre>

<hr>
<h2 id='setAnnotations'>set default name of transcription database and name of database mapping gene name to entrez gene id</h2><span id='topic+setAnnotations'></span>

<h3>Description</h3>

<p>This function takes two string parameters:
one to specify entrez gene ids to transcripts,
the other to map gene names to entrez gene id's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAnnotations(txdb, entrezGene, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setAnnotations_+3A_txdb">txdb</code></td>
<td>
<p>name of Bioconductor transcription database.</p>
</td></tr>
<tr><td><code id="setAnnotations_+3A_entrezgene">entrezGene</code></td>
<td>
<p>name of Bioconductor mapping of gene name or gene alias to entrez gene id</p>
</td></tr>
<tr><td><code id="setAnnotations_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Note</h3>

<p><b>Mega2R</b> will take care to load the necessary databases, but you will have to
install them from Bioconductor.  This is explained at length in the package Vignette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

setAnnotations("TxDb.Hsapiens.UCSC.hg19.knownGene", "org.Hs.eg.db")

ENV$txdb
ENV$entrezGene

</code></pre>

<hr>
<h2 id='setfam'>replace the pedigree data frame</h2><span id='topic+setfam'></span>

<h3>Description</h3>

<p>You should first modify the <em>fam</em> data frame to filter the members you need to remove.
(For example, you might  want to delete members that have an unknown case/control status.)
This function takes a new data frame of pedigree information and replaces the <em>fam</em>
data frame in the 'environment' with it.  Additionally,
changing <em>fam</em> data frame will filter the genotypes data frame to only contain persons
matching those in the <em>fam</em> data frame.  <code>setfam</code> also filters for the phenotype data
records.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setfam(fam, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setfam_+3A_fam">fam</code></td>
<td>
<p>data frame of family information filtered from <em>fam</em>
data frame (generated by <code>mkfam</code>).</p>
</td></tr>
<tr><td><code id="setfam_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

fam = mkfam()
# remove founders
fam = fam[ !( (fam[ , 5] == fam[ , 6]) &amp; (fam[ , 5] == 0)), ]
setfam(fam)

ENV$fam
</code></pre>

<hr>
<h2 id='setRanges'>set default range data: chromosome and start/end base pair</h2><span id='topic+setRanges'></span>

<h3>Description</h3>

<p>This function sets the default list of ranges used by <code>applyFnToRanges</code>.  <code>applyFnToRanges</code>
examines each range and the set of markers that fall within the range will be
processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRanges(ranges, indices, envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setRanges_+3A_ranges">ranges</code></td>
<td>
<p>a data frame that contains at least 4 observations: a name, a chromosome, a start
base pair position and an end base pair position.</p>
</td></tr>
<tr><td><code id="setRanges_+3A_indices">indices</code></td>
<td>
<p>a vector of 3 or 4 integers that specify the chromosome column, start base pair,
column and end base pair column of range data frame and lastly the name column.  If the vector
only contains 3 integers, a name will be generated from the three range elements and it will be
appended to the ranges and the last range column will be added to the indices.</p>
</td></tr>
<tr><td><code id="setRanges_+3A_envir">envir</code></td>
<td>
<p>an 'environment' that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

ranges = matrix(c(1, 2240000, 2245000,
                  1, 2245000, 2250000,
                  1, 3760000, 3761000,
                  1, 3761000, 3762000,
                  1, 3762000, 3763000,
                  1, 3763000, 3764000,
                  1, 3764000, 3765000,
                  1, 3765000, 3763760,
                  1, 3763760, 3767000,
                  1, 3767000, 3768000,
                  1, 3768000, 3769000,
                  1, 3769000, 3770000),
                 ncol = 3, nrow = 12, byrow = TRUE)

setRanges(ranges, 1:3)

ENV$refRanges

ranges = matrix(c(1, 2240000, 2245000,
                  1, 2245000, 2250000,
                  1, 3760000, 3761000,
                  1, 3761000, 3762000,
                  1, 3762000, 3763000,
                  1, 3763000, 3764000,
                  1, 3764000, 3765000,
                  1, 3765000, 3763760,
                  1, 3763760, 3767000,
                  1, 3767000, 3768000,
                  1, 3768000, 3769000,
                  1, 3769000, 3770000),
                 ncol = 3, nrow = 12, byrow = TRUE)
ranges = data.frame(ranges)
ranges$name = LETTERS[1:12]
names(ranges) = c("chr", "start", "end", "name")

setRanges(ranges, 1:4)

ENV$refRanges
</code></pre>

<hr>
<h2 id='showMapNames'>show the association between mapno and mapname</h2><span id='topic+showMapNames'></span>

<h3>Description</h3>

<p>Mega2R allows several different physical and genetic maps to be stored and used to select
positions.  This function shows the association between map number and map name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showMapNames(envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showMapNames_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

showMapNames()

</code></pre>

<hr>
<h2 id='showMega2ENV'>show Mega2R environment, viz. data frames and related info.</h2><span id='topic+showMega2ENV'></span>

<h3>Description</h3>

<p>Mega2R uses an environment to store the data frames when it reads SQLite database tables.
This function shows the data frames and their sizes; it also
shows the count of samples and markers in the database.
Note: It is not necessary to provide an argument, if the environment is named <em>ENV</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showMega2ENV(envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showMega2ENV_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

showMega2ENV()

</code></pre>

<hr>
<h2 id='showPhenoNames'>show the association between index no and phenotype</h2><span id='topic+showPhenoNames'></span>

<h3>Description</h3>

<p>Mega2R stores several phenotypes, both affective and quantitative. This function displays the
mapping between phenotype (name), index, and the phenotype type (affection or quantitative).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showPhenoNames(envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showPhenoNames_+3A_envir">envir</code></td>
<td>
<p>an environment that contains all the data frames created from the SQLite database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)

showPhenoNames()

</code></pre>

<hr>
<h2 id='uniqueFamMember'>regenerate fam data frame with unique values in member column</h2><span id='topic+uniqueFamMember'></span>

<h3>Description</h3>

<p>Reads the fam data frame in &quot;envir&quot; and returns a new one with unique entries in the member
column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniqueFamMember(envir = ENV)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniqueFamMember_+3A_envir">envir</code></td>
<td>
<p>'environment' containing SQLite database and other globals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with columns the same as the &quot;fam&quot; data frame but with the member column
containing unique entries
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkfam">mkfam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>db = system.file("exdata", "seqsimm.db", package="Mega2R")
ENV = read.Mega2DB(db)
setfam(uniqueFamMember(envir = ENV))

</code></pre>

<hr>
<h2 id='where_mega2rtutorial_data'>show directory of tutorial data</h2><span id='topic+where_mega2rtutorial_data'></span>

<h3>Description</h3>

<p>This function shows the directory the Mega2Rtutorial (inst/exdata) was copied to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>where_mega2rtutorial_data(dir = file.path(tempdir(), "Mega2Rtutorial"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="where_mega2rtutorial_data_+3A_dir">dir</code></td>
<td>
<p>The directory to store the tutorial data to.  By default, this is
tempdir()/Mega2Rtutorial</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dir tutorial to hold vignette
</p>


<h3>Examples</h3>

<pre><code class='language-R'>directory = where_mega2rtutorial_data()

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
