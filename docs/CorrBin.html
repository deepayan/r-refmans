<!DOCTYPE html><html lang="en"><head><title>Help for package CorrBin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CorrBin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CorrBin-package'><p>Nonparametrics for Correlated Binary and Multinomial Data</p></a></li>
<li><a href='#CBData'><p>Create a &lsquo;CBdata&rsquo; object from a data frame.</p></a></li>
<li><a href='#CMData'><p>Create a &lsquo;CMdata&rsquo; object from a data frame.</p></a></li>
<li><a href='#dehp'><p>Developmental toxicology study of DEHP in mice</p></a></li>
<li><a href='#egde'><p>EGDE data</p></a></li>
<li><a href='#Extract'><p>Extract from a CBData or CMData object</p></a></li>
<li><a href='#GEE.trend.test'><p>GEE-based trend test</p></a></li>
<li><a href='#jointprobs'><p>Estimate joint event probabilities for multinomial data</p></a></li>
<li><a href='#mc.est.CMData'><p>Distribution of the number of responses assuming marginal compatibility.</p></a></li>
<li><a href='#mc.test.chisq.CMData'><p>Test the assumption of marginal compatibility</p></a></li>
<li><a href='#mChoose'><p>Internal CorrBin objects</p></a></li>
<li><a href='#multi.corr'><p>Extract correlation coefficients from joint probability arrays</p></a></li>
<li><a href='#multinom.gen'><p>Functions for generating multinomial outcomes</p></a></li>
<li><a href='#NOSTASOT'><p>Finding the NOSTASOT dose</p></a></li>
<li><a href='#pdf'><p>Parametric distributions for correlated binary data</p></a></li>
<li><a href='#ran.CBData'><p>Generate random correlated binary data</p></a></li>
<li><a href='#ran.CMData'><p>Generate a random CMData object</p></a></li>
<li><a href='#read.CBData'><p>Read data from external file into a CBData object</p></a></li>
<li><a href='#read.CMData'><p>Read data from external file into a CMData object</p></a></li>
<li><a href='#RS.trend.test'><p>Rao-Scott trend test</p></a></li>
<li><a href='#shelltox'><p>Shell Toxicology data</p></a></li>
<li><a href='#SO.LRT'><p>Likelihood-ratio test statistic</p></a></li>
<li><a href='#SO.mc.est'><p>Order-restricted MLE assuming marginal compatibility</p></a></li>
<li><a href='#SO.trend.test'><p>Likelihood ratio test of stochastic ordering</p></a></li>
<li><a href='#soControl'><p>Control values for order-constrained fit</p></a></li>
<li><a href='#trend.test'><p>Test for increasing trend with correlated binary data</p></a></li>
<li><a href='#uniprobs'><p>Extract univariate marginal probabilities from joint probability arrays</p></a></li>
<li><a href='#unwrap.CBData'><p>Unwrap a clustered object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Nonparametrics with Clustered Binary and Multinomial Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-28</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 2.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, combinat, dirmult, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geepack, lattice</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements non-parametric analyses for clustered
    binary and multinomial data. The elements of the cluster are assumed
    exchangeable, and identical joint distribution (also known as marginal
    compatibility, or reproducibility) is assumed for clusters of different
    sizes. A trend test based on stochastic ordering is implemented. 
    Szabo A, George EO. (2010) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasp077">doi:10.1093/biomet/asp077</a>&gt;;
    George EO, Cheon K, Yuan Y, Szabo A (2016) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasw009">doi:10.1093/biomet/asw009</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-30 14:52:20 UTC; aszabo</td>
</tr>
<tr>
<td>Author:</td>
<td>Aniko Szabo [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aniko Szabo &lt;aszabo@mcw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-30 15:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='CorrBin-package'>Nonparametrics for Correlated Binary and Multinomial Data</h2><span id='topic+CorrBin-package'></span><span id='topic+CorrBin'></span>

<h3>Description</h3>

<p>This package implements nonparametric methods for analyzing exchangeable
binary and multinomial data with variable cluster sizes with emphasis on trend testing. The
input should specify the treatment group, cluster-size, and the number of
responses (i.e. the number of cluster elements with the outcome of interest)
for each cluster.
</p>


<h3>Details</h3>

 <ul>
<li><p> The <code><a href="#topic+CBData">CBData</a>/<a href="#topic+CMData">CMData</a></code> and <code><a href="#topic+read.CBData">read.CBData</a>/<a href="#topic+read.CMData">read.CMData</a></code>
functions create a &lsquo;CBData&rsquo; or &lsquo;CMData&rsquo; object used by the analysis functions.  
</p>
</li>
<li> <p><code><a href="#topic+ran.CBData">ran.CBData</a></code> and <code><a href="#topic+ran.CMData">ran.CMData</a></code> can be used to generate random 
binary or multinomial data using a variety of distributions.  
</p>
</li>
<li> <p><code><a href="#topic+mc.test.chisq">mc.test.chisq</a></code> tests the assumption of marginal compatibility
underlying all the methods, while <code><a href="#topic+mc.est">mc.est</a></code> estimates the
distribution of the number of responses under marginal compatibility.  
</p>
</li>
<li><p> Finally, <code><a href="#topic+trend.test">trend.test</a></code> performs three different tests for trend
along the treatment groups for binomial data. </p>
</li></ul>



<h3>Author(s)</h3>

<p>Aniko Szabo
</p>
<p>Maintainer: Aniko Szabo &lt;aszabo@mcw.edu&gt;
</p>


<h3>References</h3>

<p>Szabo A, George EO. (2009) On the Use of Stochastic Ordering to
Test for Trend with Clustered Binary Data. <em>Biometrika</em>
</p>
<p>Stefanescu, C. &amp; Turnbull, B. W. (2003) Likelihood inference for exchangeable
binary data with varying cluster sizes. <em>Biometrics</em>, 59, 18-24
</p>
<p>Pang, Z. &amp; Kuk, A. (2007) Test of marginal compatibility and smoothing
methods for exchangeable binary data with unequal cluster sizes.
<em>Biometrics</em>, 63, 218-227
</p>

<hr>
<h2 id='CBData'>Create a &lsquo;CBdata&rsquo; object from a data frame.</h2><span id='topic+CBData'></span>

<h3>Description</h3>

<p>The <code>CBData</code> function creates an object of class <dfn>CBData</dfn> that is
used in further analyses. It identifies the variables that define treatment
group, clustersize and the number of responses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CBData(x, trt, clustersize, nresp, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CBData_+3A_x">x</code></td>
<td>
<p>a data frame with one row representing a cluster or potentially a
set of clusters of the same size and number of responses</p>
</td></tr>
<tr><td><code id="CBData_+3A_trt">trt</code></td>
<td>
<p>the name of the variable that defines treatment group</p>
</td></tr>
<tr><td><code id="CBData_+3A_clustersize">clustersize</code></td>
<td>
<p>the name of the variable that defines cluster size</p>
</td></tr>
<tr><td><code id="CBData_+3A_nresp">nresp</code></td>
<td>
<p>the name of the variable that defines the number of responses in
the cluster</p>
</td></tr>
<tr><td><code id="CBData_+3A_freq">freq</code></td>
<td>
<p>the name of the variable that defines the number of clusters
represented by the data row. If <code>NULL</code>, then each row is assumed to
correspond to one cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row representing all the clusters with the
same trt/size/number of responses, and standardized variable names:
</p>
<table role = "presentation">
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>NResp</code></td>
<td>
<p>numeric, the number of responses</p>
</td></tr>
<tr><td><code>Freq</code></td>
<td>
<p>numeric, number of clusters with the same values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.CBData">read.CBData</a></code> for creating a <code>CBData</code> object
directly from a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
sh &lt;- CBData(shelltox, trt="Trt", clustersize="ClusterSize", nresp="NResp")
str(sh)

</code></pre>

<hr>
<h2 id='CMData'>Create a &lsquo;CMdata&rsquo; object from a data frame.</h2><span id='topic+CMData'></span>

<h3>Description</h3>

<p>The <code>CMData</code> function creates an object of class <dfn>CMData</dfn> that is
used in further analyses. It identifies the variables that define treatment
group, clustersize and the number of responses for each outcome type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CMData(x, trt, nresp, clustersize = NULL, freq = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CMData_+3A_x">x</code></td>
<td>
<p>a data frame with one row representing a cluster or potentially a
set of clusters of the same size and number of responses for each outcome</p>
</td></tr>
<tr><td><code id="CMData_+3A_trt">trt</code></td>
<td>
<p>the name of the variable that defines treatment group</p>
</td></tr>
<tr><td><code id="CMData_+3A_nresp">nresp</code></td>
<td>
<p>either a character vector with the names or a numeric vector with indices
of the variables that define the number of responses in
the cluster for each outcome type. If <code>clustersize</code> is <code>NULL</code>, then it will be
calculated assuming that the <code>nresp</code> vector contains all the possible outcomes.
If <code>clustersize</code> is given, then an additional category is created for the excess cluster members.</p>
</td></tr>
<tr><td><code id="CMData_+3A_clustersize">clustersize</code></td>
<td>
<p>the name or index of the variable that defines cluster size, or <code>NULL</code>. If <code>NULL</code>,
its value will be calculated by adding the counts from the <code>nresp</code> variables. If defined,
an additional response type will be created for the excess cluster members.</p>
</td></tr>
<tr><td><code id="CMData_+3A_freq">freq</code></td>
<td>
<p>the name or index of the variable that defines the number of clusters
represented by the data row. If <code>NULL</code>, then each row is assumed to
correspond to one cluster.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with each row representing all the clusters with the
same trt/size/number of responses, and standardized variable names:
</p>
<table role = "presentation">
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>NResp.1--NResp.K+1</code></td>
<td>
<p>numeric, the number of responses for each of the K+1 outcome types</p>
</td></tr>
<tr><td><code>Freq</code></td>
<td>
<p>numeric, number of clusters with the same values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+read.CMData">read.CMData</a></code> for creating a <code>CMData</code> object
directly from a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dehp)
dehp &lt;- CMData(dehp, trt="Trt", nresp=c("NResp.1","NResp.2","NResp.3"))
str(dehp)

</code></pre>

<hr>
<h2 id='dehp'>Developmental toxicology study of DEHP in mice</h2><span id='topic+dehp'></span>

<h3>Description</h3>

<p>This data set is based on a National Toxicology Program study on diethylhexyl phthalate, DEHP.
Pregnant CD-1 mice were randomly assigned to receive 0, 250, 500, 1000, or 1500 ppm of DEHP in their feed
during gestational days 0-17. The uterine contents of the mice were examined for toxicity endpoints prior to
normal delivery. The possible outcomes are 1) malformation, 2) death or resorption, 3) no adverse event.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dehp)</code></pre>


<h3>Format</h3>

<p>  A 'CMData' object, that is a data frame  with the following variables
</p>

<table>
<tr>
 <td style="text-align: left;">
    Trt          </td><td style="text-align: left;"> factor giving treatment group</td>
</tr>
<tr>
 <td style="text-align: left;">
    ClusterSize  </td><td style="text-align: left;"> the size of the litter</td>
</tr>
<tr>
 <td style="text-align: left;">
    NResp.1        </td><td style="text-align: left;"> the number of fetuses with a type 1 outcome (malformation) </td>
</tr>
<tr>
 <td style="text-align: left;">
    NResp.2        </td><td style="text-align: left;"> the number of fetuses with a type 2 outcome (death or resorption) </td>
</tr>
<tr>
 <td style="text-align: left;">
    NResp.3        </td><td style="text-align: left;"> the number of fetuses with a type 3 outcome (normal) </td>
</tr>
<tr>
 <td style="text-align: left;">
    Freq         </td><td style="text-align: left;"> the number of litters with the given ClusterSize/NResp.1-NResp.3 combination</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>


<h3>Source</h3>

<p>National Toxicology Program, NTP Study TER84064.</p>


<h3>References</h3>

<p>Tyl, R. W., Price, C. J., Marr, M. C., and Kimmel, C. A. (1988). Developmental toxicity evaluation of dietary
di(2-ethylhexy)phthalate in Fischer 344 rats and CD-1 mice. <em>Fundamental and Applied Toxicology</em>
10, 395-412.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dehp)
library(lattice)
pl &lt;- xyplot(NResp.1/ClusterSize + NResp.2/ClusterSize + NResp.3/ClusterSize ~ Trt, 
        data=dehp, outer=TRUE, type=c("p","a"), jitter.x=TRUE)
pl$condlevels[[1]] &lt;- c("Malformed", "Dead", "Normal")
print(pl)
</code></pre>

<hr>
<h2 id='egde'>EGDE data</h2><span id='topic+egde'></span>

<h3>Description</h3>

<p>The data set is based on a developmental toxicity experiment on the effect of ethylene glycol 
diethyl ether (EGDE) on fetal development of New Zealand white rabbits.
In the study, four groups of pregnant does
were randomly assigned to dose levels $0, 25, 50$, and $100$
milligrams per kilogram body weight of EGDE. For each litter
and at each dose level, the adverse response used is the combined
number of fetal malformation and fetal death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(egde)</code></pre>


<h3>Format</h3>

<p>A 'CBData' object, that is a data frame  with the following variables
</p>

<table>
<tr>
 <td style="text-align: left;">
    Trt          </td><td style="text-align: left;"> factor giving treatment group</td>
</tr>
<tr>
 <td style="text-align: left;">
    ClusterSize  </td><td style="text-align: left;"> the size of the litter</td>
</tr>
<tr>
 <td style="text-align: left;">
    NResp        </td><td style="text-align: left;"> the number of affected fetuses</td>
</tr>
<tr>
 <td style="text-align: left;">
    Freq         </td><td style="text-align: left;"> the number of litters with the given ClusterSize/NResp combination</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Krewski, D., Zhu, Y., and Fung, K. (1995). Statistical analysis of overdispersed multinomial data from 
developmental toxicity studies. In <em>Statistics in Toxicology</em>, Ed. B. Morgan, pp.\ 151&ndash;179.  New York: Oxford University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(egde)
  stripchart(I(NResp/ClusterSize)~Trt, cex=sqrt(egde$Freq), data=egde, pch=1, 
             method="jitter", vertical=TRUE, ylab="Proportion affected")
</code></pre>

<hr>
<h2 id='Extract'>Extract from a CBData or CMData object</h2><span id='topic+Extract'></span><span id='topic++5B.CBData'></span><span id='topic++5B.CMData'></span>

<h3>Description</h3>

<p>The extracting syntax works as for <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>, and in general the returned object is not a <code>CBData</code> or <code>CMData</code> object.
However if the columns are not modified, then the result is still a <code>CBData</code> or <code>CMData</code> object  with appropriate attributes  preserved, 
and the unused levels of treatment groups dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBData'
x[i, j, drop]

## S3 method for class 'CMData'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract_+3A_x">x</code></td>
<td>
<p><code>CMData</code> object.</p>
</td></tr>
<tr><td><code id="Extract_+3A_i">i</code></td>
<td>
<p>numeric, row index of extracted values</p>
</td></tr>
<tr><td><code id="Extract_+3A_j">j</code></td>
<td>
<p>numeric, column index of extracted values</p>
</td></tr>
<tr><td><code id="Extract_+3A_drop">drop</code></td>
<td>
<p>logical. If TRUE the result is coerced to the lowest possible dimension. 
The default is the same as for <code><a href="base.html#topic++5B.data.frame">[.data.frame</a></code>: to drop if only one column is left, but not to drop if only one row is left.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>CBData</code> or <code>CMData</code> object
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code>CBData</code>, <code><a href="#topic+CMData">CMData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
str(shelltox[1:5,])
str(shelltox[1:5, 2:4])

data(dehp)
str(dehp[1:5,])
str(dehp[1:5, 2:4])
</code></pre>

<hr>
<h2 id='GEE.trend.test'>GEE-based trend test</h2><span id='topic+GEE.trend.test'></span>

<h3>Description</h3>

<p><code>GEE.trend.test</code> implements a GEE based test for linear increasing trend
for correlated binary data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEE.trend.test(cbdata, scale.method = c("fixed", "trend", "all"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GEE.trend.test_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object</p>
</td></tr>
<tr><td><code id="GEE.trend.test_+3A_scale.method">scale.method</code></td>
<td>
<p>character string specifying the assumption about the
change in the overdispersion (scale) parameter across the treatment groups:
&quot;fixed&quot; - constant scale parameter (default); &quot;trend&quot; - linear trend for the
log of the scale parameter; &quot;all&quot; - separate scale parameter for each group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual work is performed by the <code><a href="geepack.html#topic+geese">geese</a></code> function of
the <code>geepack</code> library, which is required for this feature to work.
This function only provides a convenient wrapper
to obtain the results in the same format as <code><a href="#topic+RS.trend.test">RS.trend.test</a></code> and
<code><a href="#topic+SO.trend.test">SO.trend.test</a></code>.
</p>
<p>The implementation aims for testing for <em>increasing</em> trend, and a
one-sided p-value is reported. The test statistic is asymptotically normally
distributed, and a two-sided p-value can be easily computed if needed.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>numeric, the value of the test statistic</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>numeric, asymptotic one-sided p-value of the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RS.trend.test">RS.trend.test</a></code>, <code><a href="#topic+SO.trend.test">SO.trend.test</a></code> for
alternative tests; <code><a href="#topic+CBData">CBData</a></code> for constructing a CBData object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
if (require(geepack)){
 GEE.trend.test(shelltox, "trend")
}
</code></pre>

<hr>
<h2 id='jointprobs'>Estimate joint event probabilities for multinomial data</h2><span id='topic+jointprobs'></span>

<h3>Description</h3>

<p>An exchangeable multinomial distribution with <code class="reqn">K+1</code> categories <code class="reqn">O_1,\ldots,O_{K+1}</code>, can be
parameterized by the joint probabilities of events
</p>
<p style="text-align: center;"><code class="reqn">\tau_{r_1,\ldots,r_{K}|n} = P\big[X_1=\cdots=X_{r_1}=O_1,\ldots, X_{\sum_{i=1}^{K-1}r_i+1} =\cdots=X_{\sum_{i=1}^{K}r_i}=O_K\big] </code>
</p>

<p>where <code class="reqn">r_i \geq 0</code> and <code class="reqn">r_1+\cdots +r_K\leq n</code>.
The <code>jointprobs</code> function estimates these probabilities under various settings. 
Note that when some of the <code class="reqn">r_i</code>'s equal zero, then no restriction on the number of outcomes of the 
corresponding type are imposed, so the resulting probabilities are marginal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jointprobs(cmdata, type = c("averaged", "cluster", "mc"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jointprobs_+3A_cmdata">cmdata</code></td>
<td>
<p>a <code>CMData</code> object</p>
</td></tr>
<tr><td><code id="jointprobs_+3A_type">type</code></td>
<td>
<p>character string describing the desired type of estimate:
</p>

<dl>
<dt>&quot;averaged&quot;</dt><dd><p> - averaged over the observed cluster-size distribution within each treatment</p>
</dd>
<dt>&quot;cluster&quot;</dt><dd><p> - separately for each cluster size within each treatment</p>
</dd>
<dt>&quot;mc&quot;</dt><dd><p> - assuming marginal compatibility, ie that <code class="reqn">\tau</code> does not depend on the cluster-size</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with an array of estimates for each treatment. For a multinomial distribution with
<code class="reqn">K+1</code> categories the arrays will have either <code class="reqn">K+1</code> or <code class="reqn">K</code> dimensions, depending on whether 
cluster-size specific estimates (<code>type="cluster"</code>) or pooled estimates 
(<code>type="averaged"</code> or <code>type="mc"</code>) are requested. For the cluster-size specific estimates 
the first dimension is the cluster-size. Each additional dimension is a possible outcome.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc.est">mc.est</a></code> for estimating the distribution under marginal compatibility,
<code><a href="#topic+uniprobs">uniprobs</a></code> and <code><a href="#topic+multi.corr">multi.corr</a></code> for extracting the univariate marginal event
probabilities, and the within-multinomial correlations from the joint probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dehp)
# averaged over cluster-sizes
tau.ave &lt;- jointprobs(dehp, type="ave")
# averaged P(X1=X2=O1, X3=O2) in the 1500 dose group
tau.ave[["1500"]]["2","1"]  # there are two type-1, and one type-2 outcome

#plot P(X1=O1) - the marginal probability of a type-1 event over cluster-sizes
tau &lt;- jointprobs(dehp, type="cluster")
ests &lt;- as.data.frame(lapply(tau, function(x)x[,"1","0"]))
matplot(ests, type="b")
</code></pre>

<hr>
<h2 id='mc.est.CMData'>Distribution of the number of responses assuming marginal compatibility.</h2><span id='topic+mc.est.CMData'></span><span id='topic+mc.est.CBData'></span><span id='topic+mc.est'></span>

<h3>Description</h3>

<p>The <code>mc.est</code> function estimates the distribution of the number of
responses in a cluster under the assumption of marginal compatibility:
information from all cluster sizes is pooled. The estimation is performed
independently for each treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CMData'
mc.est(object, eps = 1e-06, ...)

## S3 method for class 'CBData'
mc.est(object, ...)

mc.est(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc.est.CMData_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> or <code><a href="#topic+CMData">CMData</a></code> object</p>
</td></tr>
<tr><td><code id="mc.est.CMData_+3A_eps">eps</code></td>
<td>
<p>numeric; EM iterations proceed until the sum of squared changes fall below <code>eps</code></p>
</td></tr>
<tr><td><code id="mc.est.CMData_+3A_...">...</code></td>
<td>
<p>other potential arguments; not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EM algorithm given by Stefanescu and Turnbull (2003) is used for the binary data.
</p>


<h3>Value</h3>

<p>For <code>CMData</code>: A data frame giving the estimated pdf for each treatment and
clustersize.  The probabilities add up to 1
for each <code>Trt</code>/<code>ClusterSize</code> combination. It has the following columns:
</p>
<table role = "presentation">
<tr><td><code>Prob</code></td>
<td>
<p>numeric, the probability of <code>NResp</code> responses in a
cluster of size <code>ClusterSize</code> in group <code>Trt</code></p>
</td></tr>
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>NResp.1 - NResp.K</code></td>
<td>
<p>numeric, the number of responses of each type</p>
</td></tr>
</table>
<p>For <code>CBData</code>: A data frame giving the estimated pdf for each treatment and
clustersize.  The probabilities add up to 1
for each <code>Trt</code>/<code>ClusterSize</code> combination. It has the following columns:
</p>
<table role = "presentation">
<tr><td><code>Prob</code></td>
<td>
<p>numeric, the probability of <code>NResp</code> responses in a
cluster of size <code>ClusterSize</code> in group <code>Trt</code></p>
</td></tr>
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>NResp</code></td>
<td>
<p>numeric, the number of responses</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For multinomial data, the implementation is currently written in R, so it is not very fast.
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>References</h3>

<p>George EO, Cheon K, Yuan Y, Szabo A (2016)  On Exchangeable Multinomial Distributions. #'<em>Biometrika</em> 103(2), 397-408.
</p>
<p>Stefanescu, C. &amp; Turnbull, B. W. (2003) Likelihood inference for
exchangeable binary data with varying cluster sizes.  <em>Biometrics</em>, 59,
18-24
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dehp)
dehp.mc &lt;- mc.est(subset(dehp, Trt=="0"))
subset(dehp.mc, ClusterSize==2)

data(shelltox)
sh.mc &lt;- mc.est(shelltox)

if (require(lattice)){
xyplot(Prob~NResp|factor(ClusterSize), groups=Trt, data=sh.mc, subset=ClusterSize&gt;0, 
   type="l", as.table=TRUE, auto.key=list(columns=4, lines=TRUE, points=FALSE),
   xlab="Number of responses", ylab="Probability P(R=r|N=n)")
}
</code></pre>

<hr>
<h2 id='mc.test.chisq.CMData'>Test the assumption of marginal compatibility</h2><span id='topic+mc.test.chisq.CMData'></span><span id='topic+mc.test.chisq.CBData'></span><span id='topic+mc.test.chisq'></span>

<h3>Description</h3>

<p><code>mc.test.chisq</code> tests whether the assumption of marginal compatibility is
violated in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CMData'
mc.test.chisq(object, ...)

## S3 method for class 'CBData'
mc.test.chisq(object, ...)

mc.test.chisq(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mc.test.chisq.CMData_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> or <code><a href="#topic+CMData">CMData</a></code> object</p>
</td></tr>
<tr><td><code id="mc.test.chisq.CMData_+3A_...">...</code></td>
<td>
<p>other potential arguments; not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The assumption of marginal compatibility (AKA reproducibility or interpretability) implies that
the marginal probability of response does not depend on clustersize.
Stefanescu and Turnbull (2003), and Pang and Kuk (2007) developed a
Cochran-Armitage type test for trend in the marginal probability of success
as a function of the clustersize. <code>mc.test.chisq</code> implements a
generalization of that test extending it to multiple treatment groups.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>overall.chi</code></td>
<td>
<p>the test statistic; sum of the statistics for each
group</p>
</td></tr>
<tr><td><code>overall.p</code></td>
<td>
<p>p-value of the test</p>
</td></tr>
<tr><td><code>individual</code></td>
<td>
<p>a list of the results of the test applied to each
group separately: </p>
 <ul>
<li><p> chi.sq the test statistic for the group
</p>
</li>
<li><p> p p-value for the group</p>
</li></ul>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>References</h3>

<p>Stefanescu, C. &amp; Turnbull, B. W. (2003) Likelihood inference for
exchangeable binary data with varying cluster sizes. <em>Biometrics</em>, 59,
18-24
</p>
<p>Pang, Z. &amp; Kuk, A. (2007) Test of marginal compatibility and smoothing
methods for exchangeable binary data with unequal cluster sizes.
<em>Biometrics</em>, 63, 218-227
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc.est">mc.est</a></code> for estimating the distribution under marginal
compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dehp)
mc.test.chisq(dehp)


data(shelltox)
mc.test.chisq(shelltox)

</code></pre>

<hr>
<h2 id='mChoose'>Internal CorrBin objects</h2><span id='topic+mChoose'></span><span id='topic+Marginals'></span><span id='topic+mc.estraw'></span><span id='topic+mc.estraw.CMData'></span><span id='topic+tau.from.pi'></span><span id='topic+p.from.tau'></span><span id='topic+corr.from.tau'></span><span id='topic+corr.from.pi'></span><span id='topic+mChooseTable'></span><span id='topic+DownUpMatrix'></span><span id='topic+.required'></span>

<h3>Description</h3>

<p>Internal CorrBin objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mChoose(n, rvec, log = FALSE)

Marginals(theta)

mc.estraw(object, ...)

## S3 method for class 'CMData'
mc.estraw(object, eps = 1e-06, ...)

tau.from.pi(pimat)

p.from.tau(taumat)

corr.from.tau(taumat)

corr.from.pi(pimat)

mChooseTable(n, k, log = FALSE)

DownUpMatrix(size, ntrt, turn)
</code></pre>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='multi.corr'>Extract correlation coefficients from joint probability arrays</h2><span id='topic+multi.corr'></span>

<h3>Description</h3>

<p>Calculates the within- and between-outcome correlation coefficients for exchangeable correlated
multinomial data based on joint probability estimates calculated by the <code><a href="#topic+jointprobs">jointprobs</a></code>
function. These determine the variance inflation due the cluster structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi.corr(jp, type = attr(jp, "type"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multi.corr_+3A_jp">jp</code></td>
<td>
<p>the output of <code><a href="#topic+jointprobs">jointprobs</a></code> - a list of joint probability arrays by treatment</p>
</td></tr>
<tr><td><code id="multi.corr_+3A_type">type</code></td>
<td>
<p>one of c(&quot;averaged&quot;,&quot;cluster&quot;,&quot;mc&quot;) - the type of joint probability. By default,
the <code>type</code> attribute of <code>jp</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code class="reqn">R_i</code> and <code class="reqn">R_j</code> is the number of events of type <code class="reqn">i</code> and <code class="reqn">j</code>, respectively, in a cluster of
size <code class="reqn">n</code>, then
</p>
<p style="text-align: center;"><code class="reqn">Var(R_i)= n p_i (1-p_i)(1 + (n-1)\phi_{ii})</code>
</p>

<p style="text-align: center;"><code class="reqn">Cov(R_i,R_j)= -n p_i p_j (1 + (n-1)\phi_{ij})</code>
</p>

<p>where <code class="reqn">p_i</code> and <code class="reqn">p_j</code> are the marginal event probabilities and <code class="reqn">\phi_{ij}</code> are the correlation
coefficients computed by <code>multi.corr</code>.
</p>


<h3>Value</h3>

<p>a list of estimated correlation matrices by treatment group. If cluster-size specific 
estimates were requested (<code>(type="cluster")</code>), then each list elements are a list of
these matrices for each cluster size.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointprobs">jointprobs</a></code> for calculating the joint probability arrays
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dehp)
tau &lt;- jointprobs(dehp, type="averaged")
multi.corr(tau)

</code></pre>

<hr>
<h2 id='multinom.gen'>Functions for generating multinomial outcomes</h2><span id='topic+multinom.gen'></span><span id='topic+mg.Resample'></span><span id='topic+mg.DirMult'></span><span id='topic+mg.LogitNorm'></span><span id='topic+mg.MixMult'></span>

<h3>Description</h3>

<p>These are built-in functions to be used by <code><a href="#topic+ran.CMData">ran.CMData</a></code> for generating
random multinomial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mg.Resample(n, clustersizes, param)

mg.DirMult(n, clustersizes, param)

mg.LogitNorm(n, clustersizes, param)

mg.MixMult(n, clustersizes, param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multinom.gen_+3A_n">n</code></td>
<td>
<p>number of independent clusters to generate</p>
</td></tr>
<tr><td><code id="multinom.gen_+3A_clustersizes">clustersizes</code></td>
<td>
<p>an integer vector specifying the sizes of the clusters</p>
</td></tr>
<tr><td><code id="multinom.gen_+3A_param">param</code></td>
<td>
<p>a list of parameters for each specific generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <b>mg.Resample</b>: the <code>param</code> list should be <code>list(param=...)</code>, in which
the CMData object to be resampled is passed.
</p>
<p>For <b>mg.DirMult</b>: the <code>param</code> list should be <code>list(shape=...)</code>, in which
the parameter vector of the Dirichlet distribution is passed 
(see <a href="dirmult.html#topic+rdirichlet">rdirichlet</a>).
</p>
<p>For <b>mg.LogitNorm</b>: the <code>param</code> list should be <code>list(mu=...,sigma=...)</code>, 
in which the mean vector and covariance matrix of the underlying Normal distribution 
are passed. If <code>sigma</code> is NULL (or missing), then an identity matrix is assumed.
They should have <em>K-1</em> dimensions for a <em>K</em>-variate multinomial.
</p>
<p>For <b>mg.MixMult</b>: the <code>param</code> list should be <code>list(q=...,m=...)</code>, 
in which the vector of mixture probabilities <code>q</code> and the matrix <code>m</code>
of logit-transformed means of each component are passed.
For a <em>K</em>-variate multinomial, the matrix <code>m</code> should have <em>K-1</em> columns
and <code>length(q)</code> rows.
</p>

<hr>
<h2 id='NOSTASOT'>Finding the NOSTASOT dose</h2><span id='topic+NOSTASOT'></span>

<h3>Description</h3>

<p>The NOSTASOT dose is the No-Statistical-Significance-Of-Trend dose &ndash; the
largest dose at which no trend in the rate of response has been observed. It
is often used to determine a safe dosage level for a potentially toxic
compound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NOSTASOT(
  cbdata,
  test = c("RS", "GEE", "GEEtrend", "GEEall", "SO"),
  exact = test == "SO",
  R = 100,
  sig.level = 0.05,
  control = soControl()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NOSTASOT_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object</p>
</td></tr>
<tr><td><code id="NOSTASOT_+3A_test">test</code></td>
<td>
<p>character string defining the desired test statistic. See
<code><a href="#topic+trend.test">trend.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="NOSTASOT_+3A_exact">exact</code></td>
<td>
<p>logical, should an exact permutation test be performed. See
<code><a href="#topic+trend.test">trend.test</a></code> for details.</p>
</td></tr>
<tr><td><code id="NOSTASOT_+3A_r">R</code></td>
<td>
<p>integer, number of permutations for the exact test</p>
</td></tr>
<tr><td><code id="NOSTASOT_+3A_sig.level">sig.level</code></td>
<td>
<p>numeric between 0 and 1, significance level of the test</p>
</td></tr>
<tr><td><code id="NOSTASOT_+3A_control">control</code></td>
<td>
<p>an optional list of control settings for the stochastic order
(&quot;SO&quot;) test, usually a call to <code><a href="#topic+soControl">soControl</a></code>.  See there for the
names of the settable control values and their effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A series of hypotheses about the presence of an increasing trend overall,
with all but the last group, all but the last two groups, etc.  are tested.
Since this set of hypotheses forms a closed family, one can test these
hypotheses in a step-down manner with the same <code>sig.level</code> type I error
rate at each step and still control the family-wise error rate.
</p>
<p>The NOSTASOT dose is the largest dose at which the trend is not statistically
significant. If the trend test is not significant with all the groups
included, the largest dose is the NOSTASOT dose. If the testing sequence goes
down all the way to two groups, and a significant trend is still detected,
the lowest dose is the NOSTASOT dose. This assumes that the lowest dose is a
control group, and this convention might not be meaningful otherwise.
</p>


<h3>Value</h3>

<p>a list with two components
</p>
<table role = "presentation">
<tr><td><code>NOSTASOT</code></td>
<td>
<p>character string identifying the NOSTASOT dose.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>numeric vector of the p-values of the tests actually performed.</p>
</td></tr>
</table>
<p>The last element corresponds to all doses included, and will not be missing.
p-values for tests that were not actually performed due to the procedure
stopping are set to NA.
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>References</h3>

<p>Tukey, J. W.; Ciminera, J. L. &amp; Heyse, J. F. (1985) Testing the
statistical certainty of a response to increasing doses of a drug.
<em>Biometrics</em> 41, 295-301.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+trend.test">trend.test</a></code> for details about the available trend
tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
NOSTASOT(shelltox, test="RS")

</code></pre>

<hr>
<h2 id='pdf'>Parametric distributions for correlated binary data</h2><span id='topic+pdf'></span><span id='topic+betabin.pdf'></span><span id='topic+qpower.pdf'></span>

<h3>Description</h3>

<p><code>qpower.pdf</code> and <code>betabin.pdf</code> calculate the probability
distribution function for the number of responses in a cluster of the q-power
and beta-binomial distributions, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betabin.pdf(p, rho, n)

qpower.pdf(p, rho, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pdf_+3A_p">p</code></td>
<td>
<p>numeric, the probability of success.</p>
</td></tr>
<tr><td><code id="pdf_+3A_rho">rho</code></td>
<td>
<p>numeric between 0 and 1 inclusive, the within-cluster correlation.</p>
</td></tr>
<tr><td><code id="pdf_+3A_n">n</code></td>
<td>
<p>integer, cluster size.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pdf of the q-power distribution is </p>
<p style="text-align: center;"><code class="reqn">P(X=x) =
{{n}\choose{x}}\sum_{k=0}^x (-1)^k{{x}\choose{k}}q^{(n-x+k)^\gamma},</code>
</p>
 <p><code class="reqn">x=0,\ldots,n</code>, where
<code class="reqn">q=1-p</code>, and the intra-cluster correlation </p>
<p style="text-align: center;"><code class="reqn">\rho =
\frac{q^{2^\gamma}-q^2}{q(1-q)}.</code>
</p>

<p>The pdf of the beta-binomial distribution is </p>
<p style="text-align: center;"><code class="reqn">P(X=x) = {{n}\choose{x}}
\frac{B(\alpha+x, n+\beta-x)}{B(\alpha,\beta)},</code>
</p>
 <p><code class="reqn">x=0,\ldots,n</code>, where <code class="reqn">\alpha=
p\frac{1-\rho}{\rho}</code>, and <code class="reqn">\alpha=
(1-p)\frac{1-\rho}{\rho}</code>.
</p>


<h3>Value</h3>

<p>a numeric vector of length <code class="reqn">n+1</code> giving the value of <code class="reqn">P(X=x)</code>
for <code class="reqn">x=0,\ldots,n</code>.
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>References</h3>

<p>Kuk, A. A (2004) Litter-based approach to risk assessment in
developmental toxicity studies via a power family of completely monotone
functions <em>Applied Statistics</em>, 52, 51-61.
</p>
<p>Williams, D. A. (1975) The Analysis of Binary Responses from Toxicological
Experiments Involving Reproduction and Teratogenicity <em>Biometrics</em>, 31,
949-952.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ran.CBData">ran.CBData</a></code> for generating an entire dataset using
these functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#the distributions have quite different shapes
#with q-power assigning more weight to the "all affected" event than other distributions
plot(0:10, betabin.pdf(0.3, 0.4, 10), type="o", ylim=c(0,0.34), 
  ylab="Density", xlab="Number of responses out of 10")
lines(0:10, qpower.pdf(0.3, 0.4, 10), type="o", col="red")

</code></pre>

<hr>
<h2 id='ran.CBData'>Generate random correlated binary data</h2><span id='topic+ran.CBData'></span>

<h3>Description</h3>

<p><code>ran.mc.CBData</code> generates a random <code><a href="#topic+CBData">CBData</a></code> object from a
given two-parameter distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ran.CBData(
  sample.sizes,
  p.gen.fun = function(g) 0.3,
  rho.gen.fun = function(g) 0.2,
  pdf.fun = qpower.pdf
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ran.CBData_+3A_sample.sizes">sample.sizes</code></td>
<td>
<p>a dataset with variables Trt, ClusterSize and Freq giving
the number of clusters to be generated for each Trt/ClusterSize combination.</p>
</td></tr>
<tr><td><code id="ran.CBData_+3A_p.gen.fun">p.gen.fun</code></td>
<td>
<p>a function of one parameter that generates the value of the
first parameter of <code>pdf.fun</code> (<em>p</em>) given the group number.</p>
</td></tr>
<tr><td><code id="ran.CBData_+3A_rho.gen.fun">rho.gen.fun</code></td>
<td>
<p>a function of one parameter that generates the value of
the second parameter of <code>pdf.fun</code> (<em>rho</em>) given the group number.</p>
</td></tr>
<tr><td><code id="ran.CBData_+3A_pdf.fun">pdf.fun</code></td>
<td>
<p>a function of three parameters (<em>p, rho, n</em>) giving the
PDF of the number of responses in a cluster given the two parameters
(<em>p, rho</em>), and the cluster size (<em>n</em>). Functions implementing two
common distributions: the beta-binomial (<code><a href="#topic+betabin.pdf">betabin.pdf</a></code>) and
q-power (<code><a href="#topic+qpower.pdf">qpower.pdf</a></code>) are provided in the package.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><dfn>p.gen.fun</dfn> and <dfn>rho.gen.fun</dfn> are functions that generate the
parameter values for each treatment group; <dfn>pdf.fun</dfn> is a function
generating the pdf of the number of responses given the two parameters
<dfn>p</dfn> and <dfn>rho</dfn>, and the cluster size <dfn>n</dfn>.
</p>
<p><code>p.gen.fun</code> and <code>rho.gen.fun</code> expect the parameter value of 1 to
represent the first group, 2 - the second group, etc.
</p>


<h3>Value</h3>

<p>a CBData object with randomly generated number of responses with
sample sizes specified in the call.
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betabin.pdf">betabin.pdf</a></code> and <code><a href="#topic+qpower.pdf">qpower.pdf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(3486)
ss &lt;- expand.grid(Trt=0:3, ClusterSize=5, Freq=4)
#Trt is converted to a factor
rd &lt;- ran.CBData(ss, p.gen.fun=function(g)0.2+0.1*g)
rd

</code></pre>

<hr>
<h2 id='ran.CMData'>Generate a random CMData object</h2><span id='topic+ran.CMData'></span>

<h3>Description</h3>

<p>Generates random exchangeably correlated multinomial data based on a parametric
distribution or using resampling. The Dirichlet-Multinomial, Logistic-Normal multinomial,
and discrete mixture multinomial parametric distributions are implemented.
All observations will be assigned to the same treatment group, and there is no
guarantee of a specific order of the observations in the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ran.CMData(n, ncat, clustersize.gen, distribution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ran.CMData_+3A_n">n</code></td>
<td>
<p>number of independent clusters to generate</p>
</td></tr>
<tr><td><code id="ran.CMData_+3A_ncat">ncat</code></td>
<td>
<p>number of response categories</p>
</td></tr>
<tr><td><code id="ran.CMData_+3A_clustersize.gen">clustersize.gen</code></td>
<td>
<p>either an integer vector specifying the sizes of the clusters, 
which will be recycled to achieve the target number of clusters <code>n</code>; or
a function with one parameter that returns an integer vector of cluster sizes when
the target number of clusters n is passed to it as a parameter</p>
</td></tr>
<tr><td><code id="ran.CMData_+3A_distribution">distribution</code></td>
<td>
<p>a list with two components: &quot;multinom.gen&quot; and &quot;param&quot; that specifies
the generation process for each cluster. The &quot;multinom.gen&quot; component should be a function
of three parameters: number of clusters, vector of cluster sizes, and parameter list, that
a matrix of response counts where each row is a cluster and each column is the number of
responses of a given type. The &quot;param&quot; component should specify the list of parameters
needed by the multinom.gen function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>CMData</code> object with randomly generated number of responses with
sample sizes specified in the call
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CMData">CMData</a></code> for details about <code>CMData</code> objects; <code><a href="#topic+multinom.gen">multinom.gen</a></code> for built-in generating functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Resample from the dehp dataset
data(dehp)
ran.dehp &lt;- ran.CMData(20, 3, 10, list(multinom.gen=mg.Resample, param=list(data=dehp)))

# Dirichlet-Multinomial distribution with two treatment groups and random cluster sizes
binom.cs &lt;- function(n){rbinom(n, p=0.3, size=10)+1}
dm1 &lt;- ran.CMData(15, 4, binom.cs, 
                  list(multinom.gen=mg.DirMult, param=list(shape=c(2,3,2,1))))
dm2 &lt;- ran.CMData(15, 4, binom.cs, 
                  list(multinom.gen=mg.DirMult, param=list(shape=c(1,1,4,1))))
ran.dm &lt;- rbind(dm1, dm2)

# Logit-Normal multinomial distribution
ran.ln &lt;- ran.CMData(13, 3, 3, 
                     list(multinom.gen=mg.LogitNorm,
                          param=list(mu=c(-1, 1), sigma=matrix(c(1,0.8,0.8,2), nr=2))))

# Mixture of two multinomial distributions
unif.cs &lt;- function(n){sample(5:9, size=n, replace=TRUE)}
ran.mm &lt;- ran.CMData(6, 3, unif.cs, 
                     list(multinom.gen=mg.MixMult,
                          param=list(q=c(0.8,0.2), m=rbind(c(-1,0), c(0,2)))))
</code></pre>

<hr>
<h2 id='read.CBData'>Read data from external file into a CBData object</h2><span id='topic+read.CBData'></span>

<h3>Description</h3>

<p>A convenience function to read data from specially structured file directly
into a <code>CBData</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.CBData(file, with.freq = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.CBData_+3A_file">file</code></td>
<td>
<p>name of file with data. The first column should contain the
treatment group, the second the size of the cluster, the third the number of
responses in the cluster. Optionally, a fourth column could give the number
of times the given combination occurs in the data.</p>
</td></tr>
<tr><td><code id="read.CBData_+3A_with.freq">with.freq</code></td>
<td>
<p>logical indicator of whether a frequency variable is present
in the file</p>
</td></tr>
<tr><td><code id="read.CBData_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="utils.html#topic+read.table">read.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>CBData</code> object
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CBData">CBData</a></code>
</p>

<hr>
<h2 id='read.CMData'>Read data from external file into a CMData object</h2><span id='topic+read.CMData'></span>

<h3>Description</h3>

<p>A convenience function to read data from specially structured file directly
into a <code>CMData</code> object. There are two basic data format options:  either the counts of responses of all categories are given (and the
cluster size is the sum of these counts), or  the total cluster size is given with the counts of all but one category.
The first column should always give the treatment group, then either the counts for each category (first option, chosen by setting 
<code>with.clustersize = FALSE</code>), or the size of the cluster followed by the counts for all but one category (second option,
chosen by setting <code>with.clustersize = TRUE</code>). Optionally, a last column could
give the number of times the given combination occurs in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.CMData(file, with.clustersize = TRUE, with.freq = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.CMData_+3A_file">file</code></td>
<td>
<p>name of file with data. The data in the file should be structured as described above.</p>
</td></tr>
<tr><td><code id="read.CMData_+3A_with.clustersize">with.clustersize</code></td>
<td>
<p>logical indicator of whether a cluster size variable is present
in the file</p>
</td></tr>
<tr><td><code id="read.CMData_+3A_with.freq">with.freq</code></td>
<td>
<p>logical indicator of whether a frequency variable is present
in the file</p>
</td></tr>
<tr><td><code id="read.CMData_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="utils.html#topic+read.table">read.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>CMData</code> object
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CMData">CMData</a></code>
</p>

<hr>
<h2 id='RS.trend.test'>Rao-Scott trend test</h2><span id='topic+RS.trend.test'></span>

<h3>Description</h3>

<p><code>RS.trend.test</code> implements the Rao-Scott adjusted Cochran-Armitage test
for linear increasing trend with correlated data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RS.trend.test(cbdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RS.trend.test_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is based on calculating a <dfn>design effect</dfn> for each cluster by
dividing the observed variability by the one expected under independence. The
number of responses and the cluster size are then divided by the design
effect, and a Cochran-Armitage type test statistic is computed based on these
adjusted values.
</p>
<p>The implementation aims for testing for <em>increasing</em> trend, and a
one-sided p-value is reported. The test statistic is asymptotically normally
distributed, and a two-sided p-value can be easily computed if needed.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>numeric, the value of the test statistic</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>numeric, asymptotic one-sided p-value of the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>References</h3>

<p>Rao, J. N. K. &amp; Scott, A. J. A (1992) Simple Method for the
Analysis of Clustered Data <em>Biometrics</em>, 48, 577-586.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SO.trend.test">SO.trend.test</a></code>, <code><a href="#topic+GEE.trend.test">GEE.trend.test</a></code> for
alternative tests; <code><a href="#topic+CBData">CBData</a></code> for constructing a CBData object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
RS.trend.test(shelltox)

</code></pre>

<hr>
<h2 id='shelltox'>Shell Toxicology data</h2><span id='topic+shelltox'></span>

<h3>Description</h3>

<p>This is a classical developmental toxicology data set. Pregnant banded Dutch rabbits
were treated with one of four levels of a chemical. The actual doses are not known,
instead the groups are designated as Control, Low, Medium, and High. Before term the
animals were sacrificed, and the total number of fetuses, as well as the number affected
by the treatment was recorded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(shelltox)</code></pre>


<h3>Format</h3>

<p>A 'CBData' object, that is a data frame  with the following variables
</p>

<table>
<tr>
 <td style="text-align: left;">
    Trt          </td><td style="text-align: left;"> factor giving treatment group</td>
</tr>
<tr>
 <td style="text-align: left;">
    ClusterSize  </td><td style="text-align: left;"> the size of the litter</td>
</tr>
<tr>
 <td style="text-align: left;">
    NResp        </td><td style="text-align: left;"> the number of affected fetuses</td>
</tr>
<tr>
 <td style="text-align: left;">
    Freq         </td><td style="text-align: left;"> the number of litters with the given ClusterSize/NResp combination</td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Source</h3>

<p>Paul, S. R. (1982) Analysis of proportions of affected foetuses in teratological experiments. <em>Biometrics</em>, 38, 361-370.  
</p>
<p>This data set has been analyzed (and listed) in numerous papers, including
</p>
<p>Rao, J. N. K. &amp; Scott, A. J. (1992) A Simple Method for the Analysis of Clustered Data. <em>Biometrics</em>, 48, 577-586.
</p>
<p>George, E. O. &amp; Kodell, R. L. (1996) Tests of Independence, Treatment Heterogeneity, and Dose-Related Trend With Exchangeable Binary Data.
<em>Journal of the American Statistical Association</em>, 91, 1602-1610.
</p>
<p>Lee, S. (2003) Analysis of the Binary Littermate Data in the One-Way Layout. <em>Biometrical Journal</em>, 45, 195-206.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(shelltox)
  stripchart(I(NResp/ClusterSize)~Trt, cex=sqrt(shelltox$Freq), data=shelltox, pch=1, 
             method="jitter", vertical=TRUE, ylab="Proportion affected")
</code></pre>

<hr>
<h2 id='SO.LRT'>Likelihood-ratio test statistic</h2><span id='topic+SO.LRT'></span>

<h3>Description</h3>

<p><code>SO.LRT</code> computes the likelihood ratio test statistic for stochastic
ordering against equality assuming marginal compatibility for both
alternatives. Note that this statistic does not have a
<code class="reqn">\chi^2</code> distribution, so the p-value computation is not
straightforward. The <code><a href="#topic+SO.trend.test">SO.trend.test</a></code> function implements a
permutation-based evaluation of the p-value for the likelihood-ratio test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SO.LRT(cbdata, control = soControl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SO.LRT_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code>CBData</code> object</p>
</td></tr>
<tr><td><code id="SO.LRT_+3A_control">control</code></td>
<td>
<p>an optional list of control settings, usually a call to
<code><a href="#topic+soControl">soControl</a></code>.  See there for the names of the settable control
values and their effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the likelihood ratio test statistic is returned with two
attributes:
</p>
<table role = "presentation">
<tr><td><code>ll0</code></td>
<td>
<p>the log-likelihood under <code class="reqn">H_0</code> (equality)</p>
</td></tr>
<tr><td><code>ll1</code></td>
<td>
<p>the log-likelihood under <code class="reqn">H_a</code> (stochastic order)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SO.trend.test">SO.trend.test</a></code>, <code><a href="#topic+soControl">soControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
LRT &lt;- SO.LRT(shelltox, control=soControl(max.iter = 100, max.directions = 50))
LRT

</code></pre>

<hr>
<h2 id='SO.mc.est'>Order-restricted MLE assuming marginal compatibility</h2><span id='topic+SO.mc.est'></span>

<h3>Description</h3>

<p><code>SO.mc.est</code> computes the nonparametric maximum likelihood estimate of
the distribution of the number of responses in a cluster <code class="reqn">P(R=r|n)</code> under
a stochastic ordering constraint. Umbrella ordering can be specified using
the <code>turn</code> parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SO.mc.est(cbdata, turn = 1, control = soControl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SO.mc.est_+3A_cbdata">cbdata</code></td>
<td>
<p>an object of class <code><a href="#topic+CBData">CBData</a></code>.</p>
</td></tr>
<tr><td><code id="SO.mc.est_+3A_turn">turn</code></td>
<td>
<p>integer specifying the peak of the umbrella ordering (see
Details). The default corresponds to a non-decreasing order.</p>
</td></tr>
<tr><td><code id="SO.mc.est_+3A_control">control</code></td>
<td>
<p>an optional list of control settings, usually a call to
<code><a href="#topic+soControl">soControl</a></code>.  See there for the names of the settable control
values and their effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two different algorithms: EM and ISDM are implemented. In general, ISDM (the
default) should be faster, though its performance depends on the tuning
parameter <code>max.directions</code>: values that are too low or too high slow the
algorithm down.
</p>
<p><code>SO.mc.est</code> allows extension to an umbrella ordering: <code class="reqn">D_1 \geq^{st}
\cdots \geq^{st} D_k \leq^{st} \cdots \leq^{st} D_n</code> by specifying the value of <code class="reqn">k</code> as the <code>turn</code>
parameter. This is an experimental feature, and at this point none of the
other functions can handle umbrella orderings.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<p>Components <code>Q</code> and <code>D</code> are unlikely to be needed by the user.
</p>
<table role = "presentation">
<tr><td><code>MLest</code></td>
<td>
<p>data frame with the maximum likelihood estimates of
<code class="reqn">P(R_i=r|n)</code></p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p>numeric matrix; estimated weights for the mixing distribution</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>numeric matrix; directional derivative of the log-likelihood</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>the achieved value of the log-likelihood</p>
</td></tr>
<tr><td><code>converge</code></td>
<td>
<p>a 2-element vector with the achieved relative error and
the performed number of iterations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>References</h3>

<p>Szabo A, George EO. (2010) On the Use of Stochastic Ordering to
Test for Trend with Clustered Binary Data. <em>Biometrika</em> 97(1), 95-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+soControl">soControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 data(shelltox)
 ml &lt;- SO.mc.est(shelltox, control=soControl(eps=0.01, method="ISDM"))
 attr(ml, "converge")
 
 require(lattice)
 panel.cumsum &lt;- function(x,y,...){
   x.ord &lt;- order(x)
   panel.xyplot(x[x.ord], cumsum(y[x.ord]), ...)}

 xyplot(Prob~NResp|factor(ClusterSize), groups=Trt, data=ml, type="s",
      panel=panel.superpose, panel.groups=panel.cumsum,
      as.table=TRUE, auto.key=list(columns=4, lines=TRUE, points=FALSE),
      xlab="Number of responses", ylab="Cumulative Probability R(R&gt;=r|N=n)",
      ylim=c(0,1.1), main="Stochastically ordered estimates\n with marginal compatibility")

</code></pre>

<hr>
<h2 id='SO.trend.test'>Likelihood ratio test of stochastic ordering</h2><span id='topic+SO.trend.test'></span>

<h3>Description</h3>

<p>Performs a likelihood ratio test of stochastic ordering versus equality using
permutations to estimate the null-distribution and the p-value.  If only the
value of the test statistic is needed, use <code><a href="#topic+SO.LRT">SO.LRT</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SO.trend.test(cbdata, R = 100, control = soControl())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SO.trend.test_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object.</p>
</td></tr>
<tr><td><code id="SO.trend.test_+3A_r">R</code></td>
<td>
<p>an integer &ndash; the number of random permutations for estimating the
null distribution.</p>
</td></tr>
<tr><td><code id="SO.trend.test_+3A_control">control</code></td>
<td>
<p>an optional list of control settings, usually a call to
<code><a href="#topic+soControl">soControl</a></code>.  See there for the names of the settable control
values and their effect.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is valid only under the assumption that the cluster-size
distribution does not depend on group. During the estimation of the
null-distribution the group assignments of the clusters are permuted keeping
the group sizes constant; the within-group distribution of the cluster-sizes
will vary randomly during the permutation test.
</p>
<p>The default value of <code>R</code> is probably too low for the final data
analysis, and should be increased.
</p>


<h3>Value</h3>

<p>A list with the following components
</p>
<table role = "presentation">
<tr><td><code>LRT</code></td>
<td>
<p>the value of the likelihood ratio test statistic. It has two
attributes: <code>ll0</code> and <code>ll1</code> - the values of the log-likelihood
under <code class="reqn">H_0</code> and <code class="reqn">H_a</code> respectively.</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>the estimated one-sided p-value.</p>
</td></tr>
<tr><td><code>boot.res</code></td>
<td>
<p>an object of class &quot;boot&quot; with the detailed results of
the permutations.  See <code><a href="boot.html#topic+boot">boot</a></code> for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>References</h3>

<p>Szabo A, George EO. (2010) On the Use of Stochastic Ordering to
Test for Trend with Clustered Binary Data. <em>Biometrika</em> 97(1), 95-108.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SO.LRT">SO.LRT</a></code> for calculating only the test statistic,
<code><a href="#topic+soControl">soControl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(shelltox)
set.seed(45742)
sh.test &lt;- SO.trend.test(shelltox, R=10, control=soControl(eps=0.1, max.directions=25)) 
sh.test

#a plot of the resampled LRT values
#would look better with a reasonable value of R
null.vals &lt;- sh.test$boot.res$t[,1]
hist(null.vals, breaks=10,  freq=FALSE, xlab="Test statistic", ylab="Density", 
     main="Simulated null-distribution", xlim=range(c(0,20,null.vals)))
points(sh.test$LRT, 0, pch="*",col="red", cex=3)


</code></pre>

<hr>
<h2 id='soControl'>Control values for order-constrained fit</h2><span id='topic+soControl'></span>

<h3>Description</h3>

<p>The values supplied in the function call replace the defaults and a list with
all possible arguments is returned.  The returned list is used as the control
argument to the <code><a href="#topic+mc.est">mc.est</a></code>, <code><a href="#topic+SO.LRT">SO.LRT</a></code>, and
<code><a href="#topic+SO.trend.test">SO.trend.test</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soControl(
  method = c("ISDM", "EM"),
  eps = 0.005,
  max.iter = 5000,
  max.directions = 0,
  start = ifelse(method == "ISDM", "H0", "uniform"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="soControl_+3A_method">method</code></td>
<td>
<p>a string specifying the maximization method</p>
</td></tr>
<tr><td><code id="soControl_+3A_eps">eps</code></td>
<td>
<p>a numeric value giving the maximum absolute error in the
log-likelihood</p>
</td></tr>
<tr><td><code id="soControl_+3A_max.iter">max.iter</code></td>
<td>
<p>an integer specifying the maximal number of iterations</p>
</td></tr>
<tr><td><code id="soControl_+3A_max.directions">max.directions</code></td>
<td>
<p>an integer giving the maximal number of directions
considered at one step of the ISDM method.  If zero or negative, it is set to
the number of non-empty cells. A value of 1 corresponds to the VDM algorithm.</p>
</td></tr>
<tr><td><code id="soControl_+3A_start">start</code></td>
<td>
<p>a string specifying the starting setup of the mixing
distribution; &quot;H0&quot; puts weight only on constant vectors (corresponding to the
null hypothesis of no change), &quot;uniform&quot; puts equal weight on all elements.
Only a &quot;uniform&quot; start can be used for the &quot;EM&quot; algorithm.</p>
</td></tr>
<tr><td><code id="soControl_+3A_verbose">verbose</code></td>
<td>
<p>a logical value; if TRUE details of the optimization are
shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with components for each of the possible arguments.
</p>


<h3>Author(s)</h3>

<p>Aniko Szabo aszabo@mcw.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mc.est">mc.est</a></code>, <code><a href="#topic+SO.LRT">SO.LRT</a></code>,
<code><a href="#topic+SO.trend.test">SO.trend.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# decrease the maximum number iterations and
# request the "EM" algorithm
soControl(method="EM", max.iter=100)

</code></pre>

<hr>
<h2 id='trend.test'>Test for increasing trend with correlated binary data</h2><span id='topic+trend.test'></span>

<h3>Description</h3>

<p>The <code>trend.test</code> function provides a common interface to the trend tests
implemented in this package: <code><a href="#topic+SO.trend.test">SO.trend.test</a></code>,
<code><a href="#topic+RS.trend.test">RS.trend.test</a></code>, and <code><a href="#topic+GEE.trend.test">GEE.trend.test</a></code>. The details of
each test can be found on their help page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trend.test(
  cbdata,
  test = c("RS", "GEE", "GEEtrend", "GEEall", "SO"),
  exact = test == "SO",
  R = 100,
  control = soControl()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trend.test_+3A_cbdata">cbdata</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object</p>
</td></tr>
<tr><td><code id="trend.test_+3A_test">test</code></td>
<td>
<p>character string defining the desired test statistic. &quot;RS&quot;
performs the Rao-Scott test (<code><a href="#topic+RS.trend.test">RS.trend.test</a></code>), &quot;SO&quot; performs the
stochastic ordering test (<code><a href="#topic+SO.trend.test">SO.trend.test</a></code>), &quot;GEE&quot;, &quot;GEEtrend&quot;,
&quot;GEEall&quot; perform the GEE-based test (<code><a href="#topic+GEE.trend.test">GEE.trend.test</a></code>) with
constant, linearly modeled, and freely varying scale parameters,
respectively.</p>
</td></tr>
<tr><td><code id="trend.test_+3A_exact">exact</code></td>
<td>
<p>logical, should an exact permutation test be performed. Only an
exact test can be performed for &quot;SO&quot;. The default is to use the asymptotic
p-values except for &quot;SO&quot;.</p>
</td></tr>
<tr><td><code id="trend.test_+3A_r">R</code></td>
<td>
<p>integer, number of permutations for the exact test</p>
</td></tr>
<tr><td><code id="trend.test_+3A_control">control</code></td>
<td>
<p>an optional list of control settings for the stochastic order
(&quot;SO&quot;) test, usually a call to <code><a href="#topic+soControl">soControl</a></code>.  See there for the
names of the settable control values and their effect.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two components and an optional &quot;boot&quot; attribute that
contains the detailed results of the permutation test as an object of class
<code><a href="boot.html#topic+boot">boot</a></code> if an exact test was performed.
</p>
<table role = "presentation">
<tr><td><code>statistic</code></td>
<td>
<p>numeric, the value of the test statistic</p>
</td></tr>
<tr><td><code>p.val</code></td>
<td>
<p>numeric, asymptotic one-sided p-value of the test</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo, aszabo@mcw.edu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SO.trend.test">SO.trend.test</a></code>, <code><a href="#topic+RS.trend.test">RS.trend.test</a></code>, and
<code><a href="#topic+GEE.trend.test">GEE.trend.test</a></code> for details about the available tests.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(shelltox)
trend.test(shelltox, test="RS")
set.seed(5724)
#R=50 is too low to get a good estimate of the p-value
trend.test(shelltox, test="RS", R=50, exact=TRUE)

</code></pre>

<hr>
<h2 id='uniprobs'>Extract univariate marginal probabilities from joint probability arrays</h2><span id='topic+uniprobs'></span>

<h3>Description</h3>

<p>Calculates the marginal probability of each event type for exchangeable correlated multinomial
data based on joint probability estimates calculated by the <code><a href="#topic+jointprobs">jointprobs</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniprobs(jp, type = attr(jp, "type"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniprobs_+3A_jp">jp</code></td>
<td>
<p>the output of <code><a href="#topic+jointprobs">jointprobs</a></code> - a list of joint probability arrays by treatment</p>
</td></tr>
<tr><td><code id="uniprobs_+3A_type">type</code></td>
<td>
<p>one of c(&quot;averaged&quot;,&quot;cluster&quot;,&quot;mc&quot;) - the type of joint probability. By default,
the <code>type</code> attribute of <code>jp</code> is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of estimated probability of each outcome by treatment group. The elements are either
matrices or vectors depending on whether cluster-size specific estimates were requested 
(<code>type="cluster"</code>) or not.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jointprobs">jointprobs</a></code> for calculating the joint probability arrays
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dehp)
tau &lt;- jointprobs(dehp, type="averaged")
uniprobs(tau)

#separately for each cluster size
tau2 &lt;- jointprobs(dehp, type="cluster")
uniprobs(tau2)
</code></pre>

<hr>
<h2 id='unwrap.CBData'>Unwrap a clustered object</h2><span id='topic+unwrap.CBData'></span><span id='topic+unwrap.CMData'></span><span id='topic+unwrap'></span>

<h3>Description</h3>

<p><code>unwrap</code> is a utility function that reformats a CBData or CMData object so
that each row is one observation (instead of one or more clusters). A new
&lsquo;ID&rsquo; variable is added to indicate clusters. This form can be useful for
setting up the data for a different package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBData'
unwrap(object, ...)

## S3 method for class 'CMData'
unwrap(object, ...)

unwrap(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unwrap.CBData_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+CBData">CBData</a></code> object</p>
</td></tr>
<tr><td><code id="unwrap.CBData_+3A_...">...</code></td>
<td>
<p>other potential arguments; not currently used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>unwrap.CMData</code>: a data frame with one row for each cluster element (having a multinomial
outcome) with the following standardized column names
</p>
<table role = "presentation">
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>factor, each level representing a different cluster</p>
</td></tr>
<tr><td><code>Resp</code></td>
<td>
<p>numeric with integer values giving the response type of the cluster
element</p>
</td></tr>
</table>
<p>For <code>unwrap.CBData</code>: a data frame with one row for each cluster element (having a binary
outcome) with the following standardized column names
</p>
<table role = "presentation">
<tr><td><code>Trt</code></td>
<td>
<p>factor, the treatment group</p>
</td></tr>
<tr><td><code>ClusterSize</code></td>
<td>
<p>numeric, the cluster size</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>factor, each level representing a different cluster</p>
</td></tr>
<tr><td><code>Resp</code></td>
<td>
<p>numeric with 0/1 values, giving the response of the cluster
element</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aniko Szabo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dehp)
dehp.long &lt;- unwrap(dehp)
head(dehp.long)


data(shelltox)
ush &lt;- unwrap(shelltox)
head(ush)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
