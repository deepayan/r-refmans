<!DOCTYPE html><html><head><title>Help for package lava</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lava}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lava-package'><p>Estimation and simulation of latent variable models</p></a></li>
<li><a href='#%++%'><p>Concatenation operator</p></a></li>
<li><a href='#%ni%'><p>Matching operator (x not in y) oposed to the <code>%in%</code>-operator (x in y)</p></a></li>
<li><a href='#addvar'><p>Add variable to (model) object</p></a></li>
<li><a href='#backdoor'><p>Backdoor criterion</p></a></li>
<li><a href='#baptize'><p>Label elements of object</p></a></li>
<li><a href='#binomial.rd'><p>Define constant risk difference or relative risk association for binary exposure</p></a></li>
<li><a href='#blockdiag'><p>Combine matrices to block diagonal structure</p></a></li>
<li><a href='#bmd'><p>Longitudinal Bone Mineral Density Data (Wide format)</p></a></li>
<li><a href='#bmidata'><p>Data</p></a></li>
<li><a href='#bootstrap'><p>Generic bootstrap method</p></a></li>
<li><a href='#bootstrap.lvm'><p>Calculate bootstrap estimates of a lvm object</p></a></li>
<li><a href='#brisa'><p>Simulated data</p></a></li>
<li><a href='#By'><p>Apply a Function to a Data Frame Split by Factors</p></a></li>
<li><a href='#calcium'><p>Longitudinal Bone Mineral Density Data</p></a></li>
<li><a href='#cancel'><p>Generic cancel method</p></a></li>
<li><a href='#children'><p>Extract children or parent elements of object</p></a></li>
<li><a href='#click'><p>Identify points on plot</p></a></li>
<li><a href='#closed.testing'><p>Closed testing procedure</p></a></li>
<li><a href='#Col'><p>Generate a transparent RGB color</p></a></li>
<li><a href='#colorbar'><p>Add color-bar to plot</p></a></li>
<li><a href='#Combine'><p>Report estimates across different models</p></a></li>
<li><a href='#commutation'><p>Finds the unique commutation matrix</p></a></li>
<li><a href='#compare'><p>Statistical tests</p></a></li>
<li><a href='#complik'><p>Composite Likelihood for probit latent variable models</p></a></li>
<li><a href='#confband'><p>Add Confidence limits bar to plot</p></a></li>
<li><a href='#confint.lvmfit'><p>Calculate confidence limits for parameters</p></a></li>
<li><a href='#confpred'><p>Conformal prediction</p></a></li>
<li><a href='#constrain&lt;-'><p>Add non-linear constraints to latent variable model</p></a></li>
<li><a href='#contr'><p>Create contrast matrix</p></a></li>
<li><a href='#correlation'><p>Generic method for extracting correlation coefficients of model object</p></a></li>
<li><a href='#covariance'><p>Add covariance structure to Latent Variable Model</p></a></li>
<li><a href='#csplit'><p>Split data into folds</p></a></li>
<li><a href='#curly'><p>Adds curly brackets to plot</p></a></li>
<li><a href='#devcoords'><p>Returns device-coordinates and plot-region</p></a></li>
<li><a href='#diagtest'><p>Calculate diagnostic tests for 2x2 table</p></a></li>
<li><a href='#dsep.lvm'><p>Check d-separation criterion</p></a></li>
<li><a href='#equivalence'><p>Identify candidates of equivalent models</p></a></li>
<li><a href='#estimate.array'><p>Estimate parameters and influence function.</p></a></li>
<li><a href='#estimate.default'><p>Estimation of functional of parameters</p></a></li>
<li><a href='#estimate.lvm'><p>Estimation of parameters in a Latent Variable Model (lvm)</p></a></li>
<li><a href='#eventTime'><p>Add an observed event time outcome to a latent variable model.</p></a></li>
<li><a href='#Expand'><p>Create a Data Frame from All Combinations of Factors</p></a></li>
<li><a href='#fplot'><p>fplot</p></a></li>
<li><a href='#getMplus'><p>Read Mplus output</p></a></li>
<li><a href='#getSAS'><p>Read SAS output</p></a></li>
<li><a href='#gof'><p>Extract model summaries and GOF statistics for model object</p></a></li>
<li><a href='#Graph'><p>Extract graph</p></a></li>
<li><a href='#Grep'><p>Finds elements in vector or column-names in data.frame/matrix</p></a></li>
<li><a href='#hubble'><p>Hubble data</p></a></li>
<li><a href='#hubble2'><p>Hubble data</p></a></li>
<li><a href='#IC'><p>Extract i.i.d. decomposition (influence function) from model object</p></a></li>
<li><a href='#iid'><p>Extract i.i.d. decomposition from model object</p></a></li>
<li><a href='#images'><p>Organize several image calls (for visualizing categorical data)</p></a></li>
<li><a href='#indoorenv'><p>Data</p></a></li>
<li><a href='#intercept'><p>Fix mean parameters in 'lvm'-object</p></a></li>
<li><a href='#intervention.lvm'><p>Define intervention</p></a></li>
<li><a href='#ksmooth2'><p>Plot/estimate surface</p></a></li>
<li><a href='#labels&lt;-'><p>Define labels of graph</p></a></li>
<li><a href='#lava.options'><p>Set global options for <code>lava</code></p></a></li>
<li><a href='#lvm'><p>Initialize new latent variable model</p></a></li>
<li><a href='#makemissing'><p>Create random missing data</p></a></li>
<li><a href='#measurement.error'><p>Two-stage (non-linear) measurement error</p></a></li>
<li><a href='#Missing'><p>Missing value generator</p></a></li>
<li><a href='#missingdata'><p>Missing data example</p></a></li>
<li><a href='#mixture'><p>Estimate mixture latent variable model.</p></a></li>
<li><a href='#Model'><p>Extract model</p></a></li>
<li><a href='#modelsearch'><p>Model searching</p></a></li>
<li><a href='#multinomial'><p>Estimate probabilities in contingency table</p></a></li>
<li><a href='#mvnmix'><p>Estimate mixture latent variable model</p></a></li>
<li><a href='#NA2x'><p>Convert to/from NA</p></a></li>
<li><a href='#nldata'><p>Example data (nonlinear model)</p></a></li>
<li><a href='#NR'><p>Newton-Raphson method</p></a></li>
<li><a href='#nsem'><p>Example SEM data (nonlinear)</p></a></li>
<li><a href='#ordinal&lt;-'><p>Define variables as ordinal</p></a></li>
<li><a href='#ordreg'><p>Univariate cumulative link regression models</p></a></li>
<li><a href='#parpos'><p>Generic method for finding indeces of model parameters</p></a></li>
<li><a href='#partialcor'><p>Calculate partial correlations</p></a></li>
<li><a href='#path'><p>Extract pathways in model graph</p></a></li>
<li><a href='#pcor'><p>Polychoric correlation</p></a></li>
<li><a href='#PD'><p>Dose response calculation for binomial regression models</p></a></li>
<li><a href='#pdfconvert'><p>Convert pdf to raster format</p></a></li>
<li><a href='#plot.estimate'><p>Plot method for 'estimate' objects</p></a></li>
<li><a href='#plot.lvm'><p>Plot path diagram</p></a></li>
<li><a href='#plot.sim'><p>Plot method for simulation 'sim' objects</p></a></li>
<li><a href='#plotConf'><p>Plot regression lines</p></a></li>
<li><a href='#predict.lvm'><p>Prediction in structural equation models</p></a></li>
<li><a href='#predictlvm'><p>Predict function for latent variable models</p></a></li>
<li><a href='#Print'><p>Generic print method</p></a></li>
<li><a href='#Range.lvm'><p>Define range constraints of parameters</p></a></li>
<li><a href='#rbind.Surv'><p>Appending <code>Surv</code> objects</p></a></li>
<li><a href='#regression&lt;-'><p>Add regression association to latent variable model</p></a></li>
<li><a href='#revdiag'><p>Create/extract 'reverse'-diagonal matrix or off-diagonal elements</p></a></li>
<li><a href='#rmvar'><p>Remove variables from (model) object.</p></a></li>
<li><a href='#rotate2'><p>Performs a rotation in the plane</p></a></li>
<li><a href='#scheffe'><p>Calculate simultaneous confidence limits by Scheffe's method</p></a></li>
<li><a href='#semdata'><p>Example SEM data</p></a></li>
<li><a href='#serotonin'><p>Serotonin data</p></a></li>
<li><a href='#serotonin2'><p>Data</p></a></li>
<li><a href='#sim'><p>Simulate model</p></a></li>
<li><a href='#sim.default'><p>Monte Carlo simulation</p></a></li>
<li><a href='#spaghetti'><p>Spaghetti plot</p></a></li>
<li><a href='#stack.estimate'><p>Stack estimating equations</p></a></li>
<li><a href='#startvalues'><p>For internal use</p></a></li>
<li><a href='#subset.lvm'><p>Extract subset of latent variable model</p></a></li>
<li><a href='#summary.sim'><p>Summary method for 'sim' objects</p></a></li>
<li><a href='#timedep'><p>Time-dependent parameters</p></a></li>
<li><a href='#toformula'><p>Converts strings to formula</p></a></li>
<li><a href='#tr'><p>Trace operator</p></a></li>
<li><a href='#trim'><p>Trim string of (leading/trailing/all) white spaces</p></a></li>
<li><a href='#twindata'><p>Twin menarche data</p></a></li>
<li><a href='#twostage'><p>Two-stage estimator</p></a></li>
<li><a href='#twostage.lvmfit'><p>Two-stage estimator (non-linear SEM)</p></a></li>
<li><a href='#twostageCV'><p>Cross-validated two-stage estimator</p></a></li>
<li><a href='#vars'><p>Extract variable names from latent variable model</p></a></li>
<li><a href='#vec'><p>vec operator</p></a></li>
<li><a href='#wait'><p>Wait for user input (keyboard or mouse)</p></a></li>
<li><a href='#wkm'><p>Weighted K-means</p></a></li>
<li><a href='#wrapvec'><p>Wrap vector</p></a></li>
<li><a href='#zibreg'><p>Regression model for binomial data with unkown group of immortals</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Variable Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus K. Holst [aut, cre],
  Brice Ozenne [ctb],
  Thomas Gerds [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus K. Holst &lt;klaus@holst.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A general implementation of Structural Equation Models
	with latent variables (MLE, 2SLS, and composite likelihood
	estimators) with both continuous, censored, and ordinal
	outcomes (Holst and Budtz-Joergensen (2013) &lt;<a href="https://doi.org/10.1007%2Fs00180-012-0344-y">doi:10.1007/s00180-012-0344-y</a>&gt;).
	Mixture latent variable models and non-linear latent variable models
	(Holst and Budtz-Joergensen (2020) &lt;<a href="https://doi.org/10.1093%2Fbiostatistics%2Fkxy082">doi:10.1093/biostatistics/kxy082</a>&gt;).
	The package also provides methods for graph exploration (d-separation,
	back-door criterion), simulation of general non-linear latent variable
	models, and estimation of influence functions for a broad range of
	statistical models.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kkholst.github.io/lava/">https://kkholst.github.io/lava/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kkholst/lava/issues">https://github.com/kkholst/lava/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, future.apply, graphics, grDevices, methods, numDeriv,
progressr, stats, survival, SQUAREM, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth, Rgraphviz, data.table, ellipse, fields, geepack,
graph, knitr, rmarkdown, igraph (&ge; 0.6), lavaSearch2, lme4 (&ge;
1.1.35.1), MASS, Matrix (&ge; 1.6.3), mets (&ge; 1.1), nlme,
optimx, polycor, quantreg, rgl, targeted (&ge; 0.4), testthat (&ge;
0.11), visNetwork</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 09:41:13 UTC; kkzh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='lava-package'>Estimation and simulation of latent variable models</h2><span id='topic+lava-package'></span><span id='topic+lava'></span>

<h3>Description</h3>

<p>A general implementation of Structural Equation Models wth latent variables
(MLE, 2SLS, and composite likelihood estimators) with both continuous,
censored, and ordinal outcomes (Holst and Budtz-Joergensen (2013)
&lt;doi:10.1007/s00180-012-0344-y&gt;). Mixture latent variable models and
non-linear latent variable models (Holst and Budtz-Joergensen (2020)
&lt;doi:10.1093/biostatistics/kxy082&gt;). The package also provides methods for
graph exploration (d-separation, back-door criterion), simulation of general
non-linear latent variable models, and estimation of influence functions for
a broad range of statistical models.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst Maintainer: &lt;klaus@holst.it&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lava()

</code></pre>

<hr>
<h2 id='+25+2B+2B+25'>Concatenation operator</h2><span id='topic++25+2B+2B+25'></span>

<h3>Description</h3>

<p>For matrices a block-diagonal matrix is created. For all other
data types he operator is a wrapper of <code>paste</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %++% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B2B+2B2B+2B25_+3A_x">x</code></td>
<td>
<p>First object</p>
</td></tr>
<tr><td><code id="+2B25+2B2B+2B2B+2B25_+3A_y">y</code></td>
<td>
<p>Second object of same class</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Concatenation operator
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>blockdiag</code>, <code><a href="base.html#topic+paste">paste</a></code>, <code><a href="base.html#topic+cat">cat</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Block diagonal
matrix(rnorm(25),5)%++%matrix(rnorm(25),5)
## String concatenation
"Hello "%++%" World"
## Function composition
f &lt;- log %++% exp
f(2)
</code></pre>

<hr>
<h2 id='+25ni+25'>Matching operator (x not in y) oposed to the <code>%in%</code>-operator (x in y)</h2><span id='topic++25ni+25'></span><span id='topic++25in.open+25'></span><span id='topic++25in.closed+25'></span>

<h3>Description</h3>

<p>Matching operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %ni% y
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25ni+2B25_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="+2B25ni+2B25_+3A_y">y</code></td>
<td>
<p>vector of same type as <code>x</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
1:10 %ni% c(1,5,10)

</code></pre>

<hr>
<h2 id='addvar'>Add variable to (model) object</h2><span id='topic+addvar'></span><span id='topic+addvar+3C-'></span>

<h3>Description</h3>

<p>Generic method for adding variables to model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addvar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addvar_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="addvar_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='backdoor'>Backdoor criterion</h2><span id='topic+backdoor'></span>

<h3>Description</h3>

<p>Check backdoor criterion of a lvm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backdoor(object, f, cond, ..., return.graph = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backdoor_+3A_object">object</code></td>
<td>
<p>lvm object</p>
</td></tr>
<tr><td><code id="backdoor_+3A_f">f</code></td>
<td>
<p>formula. Conditioning, z, set can be given as y~x|z</p>
</td></tr>
<tr><td><code id="backdoor_+3A_cond">cond</code></td>
<td>
<p>Vector of variables to conditon on</p>
</td></tr>
<tr><td><code id="backdoor_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="backdoor_+3A_return.graph">return.graph</code></td>
<td>
<p>Return moral ancestral graph with z and effects from x removed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y~c2,c2~c1,x~c1,m1~x,y~m1, v1~c3, x~c3,v1~y,
         x~z1, z2~z1, z2~z3, y~z3+z2+g1+g2+g3)
ll &lt;- backdoor(m, y~x)
backdoor(m, y~x|c1+z1+g1)
</code></pre>

<hr>
<h2 id='baptize'>Label elements of object</h2><span id='topic+baptize'></span>

<h3>Description</h3>

<p>Generic method for labeling elements of an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baptize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="baptize_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="baptize_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='binomial.rd'>Define constant risk difference or relative risk association for binary exposure</h2><span id='topic+binomial.rd'></span><span id='topic+binomial.rr'></span>

<h3>Description</h3>

<p>Set up model as defined in Richardson, Robins and Wang (2017).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomial.rd(
  x,
  response,
  exposure,
  target.model,
  nuisance.model,
  exposure.model = binomial.lvm(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomial.rd_+3A_x">x</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_response">response</code></td>
<td>
<p>response variable (character or formula)</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_exposure">exposure</code></td>
<td>
<p>exposure variable (character or formula)</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_target.model">target.model</code></td>
<td>
<p>variable defining the linear predictor for the target model</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_nuisance.model">nuisance.model</code></td>
<td>
<p>variable defining the linear predictor for the nuisance model</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_exposure.model">exposure.model</code></td>
<td>
<p>model for exposure (default binomial logit link)</p>
</td></tr>
<tr><td><code id="binomial.rd_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>

<hr>
<h2 id='blockdiag'>Combine matrices to block diagonal structure</h2><span id='topic+blockdiag'></span>

<h3>Description</h3>

<p>Combine matrices to block diagonal structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blockdiag(x, ..., pad = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blockdiag_+3A_x">x</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="blockdiag_+3A_...">...</code></td>
<td>
<p>Additional matrices</p>
</td></tr>
<tr><td><code id="blockdiag_+3A_pad">pad</code></td>
<td>
<p>Vyalue outside block-diagonal</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- diag(3)+1
blockdiag(A,A,A,pad=NA)
</code></pre>

<hr>
<h2 id='bmd'>Longitudinal Bone Mineral Density Data (Wide format)</h2><span id='topic+bmd'></span>

<h3>Description</h3>

<p>Bone Mineral Density Data consisting of 112 girls randomized to receive
calcium og placebo. Longitudinal measurements of bone mineral density
(g/cm^2) measured approximately every 6th month in 3 years.
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Vonesh &amp; Chinchilli (1997), Table 5.4.1 on page 228.
</p>


<h3>See Also</h3>

<p>calcium
</p>

<hr>
<h2 id='bmidata'>Data</h2><span id='topic+bmidata'></span>

<h3>Description</h3>

<p>Description
</p>


<h3>Format</h3>

<p>data.frame
</p>

<hr>
<h2 id='bootstrap'>Generic bootstrap method</h2><span id='topic+bootstrap'></span>

<h3>Description</h3>

<p>Generic method for calculating bootstrap statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>bootstrap.lvm</code> <code>bootstrap.lvmfit</code>
</p>

<hr>
<h2 id='bootstrap.lvm'>Calculate bootstrap estimates of a lvm object</h2><span id='topic+bootstrap.lvm'></span><span id='topic+bootstrap.lvmfit'></span>

<h3>Description</h3>

<p>Draws non-parametric bootstrap samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
bootstrap(x,R=100,data,fun=NULL,control=list(),
                          p, parametric=FALSE, bollenstine=FALSE,
                          constraints=TRUE,sd=FALSE, mc.cores,
                          future.args=list(future.seed=TRUE),
                          ...)

## S3 method for class 'lvmfit'
bootstrap(x,R=100,data=model.frame(x),
                             control=list(start=coef(x)),
                             p=coef(x), parametric=FALSE, bollenstine=FALSE,
                             estimator=x$estimator,weights=Weights(x),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap.lvm_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_r">R</code></td>
<td>
<p>Number of bootstrap samples</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_data">data</code></td>
<td>
<p>The data to resample from</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_fun">fun</code></td>
<td>
<p>Optional function of the (bootstrapped) model-fit defining the
statistic of interest</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_control">control</code></td>
<td>
<p>Options to the optimization routine</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_p">p</code></td>
<td>
<p>Parameter vector of the null model for the parametric bootstrap</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_parametric">parametric</code></td>
<td>
<p>If TRUE a parametric bootstrap is calculated. If FALSE a
non-parametric (row-sampling) bootstrap is computed.</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_bollenstine">bollenstine</code></td>
<td>
<p>Bollen-Stine transformation (non-parametric bootstrap) for bootstrap hypothesis testing.</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_constraints">constraints</code></td>
<td>
<p>Logical indicating whether non-linear parameter
constraints should be included in the bootstrap procedure</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_sd">sd</code></td>
<td>
<p>Logical indicating whether standard error estimates should be
included in the bootstrap procedure</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Optional number of cores for parallel computing. If omitted future.apply will be used (see future::plan)</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_future.args">future.args</code></td>
<td>
<p>arguments to future.apply::future_lapply</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments, e.g. choice of estimator.</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_estimator">estimator</code></td>
<td>
<p>String definining estimator, e.g. 'gaussian' (see
<code>estimator</code>)</p>
</td></tr>
<tr><td><code id="bootstrap.lvm_+3A_weights">weights</code></td>
<td>
<p>Optional weights matrix used by <code>estimator</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bootstrap.lvm</code> object.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+confint.lvmfit">confint.lvmfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y~x)
d &lt;- sim(m,100)
e &lt;- estimate(lvm(y~x), data=d)
 ## Reduce Ex.Timings
B &lt;- bootstrap(e,R=50,mc.cores=1)
B

</code></pre>

<hr>
<h2 id='brisa'>Simulated data</h2><span id='topic+brisa'></span>

<h3>Description</h3>

<p>Simulated data
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='By'>Apply a Function to a Data Frame Split by Factors</h2><span id='topic+By'></span>

<h3>Description</h3>

<p>Apply a Function to a Data Frame Split by Factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>By(x, INDICES, FUN, COLUMNS, array = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="By_+3A_x">x</code></td>
<td>
<p>Data frame</p>
</td></tr>
<tr><td><code id="By_+3A_indices">INDICES</code></td>
<td>
<p>Indices (vector or list of indices, vector of column names, or formula of column names)</p>
</td></tr>
<tr><td><code id="By_+3A_fun">FUN</code></td>
<td>
<p>A function to be applied to data frame subsets of 'data'.</p>
</td></tr>
<tr><td><code id="By_+3A_columns">COLUMNS</code></td>
<td>
<p>(Optional) subset of columns of x to work on</p>
</td></tr>
<tr><td><code id="By_+3A_array">array</code></td>
<td>
<p>if TRUE an array/matrix is always returned</p>
</td></tr>
<tr><td><code id="By_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower-level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper of the 'by' function
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>By(datasets::CO2,~Treatment+Type,colMeans,~conc)
By(datasets::CO2,~Treatment+Type,colMeans,~conc+uptake)
</code></pre>

<hr>
<h2 id='calcium'>Longitudinal Bone Mineral Density Data</h2><span id='topic+calcium'></span>

<h3>Description</h3>

<p>Bone Mineral Density Data consisting of 112 girls randomized to receive
calcium og placebo. Longitudinal measurements of bone mineral density
(g/cm^2) measured approximately every 6th month in 3 years.
</p>


<h3>Format</h3>

<p>A data.frame containing 560 (incomplete) observations. The 'person'
column defines the individual girls of the study with measurements at
visiting times 'visit', and age in years 'age' at the time of visit. The
bone mineral density variable is 'bmd' (g/cm^2).
</p>


<h3>Source</h3>

<p>Vonesh &amp; Chinchilli (1997), Table 5.4.1 on page 228.
</p>

<hr>
<h2 id='cancel'>Generic cancel method</h2><span id='topic+cancel'></span><span id='topic+cancel+3C-'></span>

<h3>Description</h3>

<p>Generic cancel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cancel(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cancel_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="cancel_+3A_...">...</code></td>
<td>
<p>Additioal arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='children'>Extract children or parent elements of object</h2><span id='topic+children'></span><span id='topic+parents'></span><span id='topic+ancestors'></span><span id='topic+descendants'></span><span id='topic+roots'></span><span id='topic+sinks'></span><span id='topic+adjMat'></span><span id='topic+edgeList'></span>

<h3>Description</h3>

<p>Generic method for memberships from object (e.g. a graph)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>children(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="children_+3A_object">object</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="children_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='click'>Identify points on plot</h2><span id='topic+click'></span><span id='topic+idplot'></span><span id='topic+click.default'></span><span id='topic+colsel'></span>

<h3>Description</h3>

<p>Extension of the <code>identify</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
click(x, y=NULL, label=TRUE, n=length(x), pch=19, col="orange", cex=3, ...)
idplot(x, y ,..., id=list(), return.data=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="click_+3A_x">x</code></td>
<td>
<p>X coordinates</p>
</td></tr>
<tr><td><code id="click_+3A_...">...</code></td>
<td>
<p>Additional arguments parsed to <code>plot</code> function</p>
</td></tr>
<tr><td><code id="click_+3A_y">y</code></td>
<td>
<p>Y coordinates</p>
</td></tr>
<tr><td><code id="click_+3A_label">label</code></td>
<td>
<p>Should labels be added?</p>
</td></tr>
<tr><td><code id="click_+3A_n">n</code></td>
<td>
<p>Max number of inputs to expect</p>
</td></tr>
<tr><td><code id="click_+3A_pch">pch</code></td>
<td>
<p>Symbol</p>
</td></tr>
<tr><td><code id="click_+3A_col">col</code></td>
<td>
<p>Colour</p>
</td></tr>
<tr><td><code id="click_+3A_cex">cex</code></td>
<td>
<p>Size</p>
</td></tr>
<tr><td><code id="click_+3A_id">id</code></td>
<td>
<p>List of arguments parsed to <code>click</code> function</p>
</td></tr>
<tr><td><code id="click_+3A_return.data">return.data</code></td>
<td>
<p>Boolean indicating if selected points should be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the usual 'X11' device the identification process is
terminated by pressing any mouse button other than the first. For
the 'quartz' device the process is terminated by pressing either
the pop-up menu equivalent (usually second mouse button or
'Ctrl'-click) or the 'ESC' key.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idplot">idplot</a></code>, <code>identify</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
    n &lt;- 10; x &lt;- seq(n); y &lt;- runif(n)
    plot(y ~ x); click(x,y)

    data(iris)
    l &lt;- lm(Sepal.Length ~ Sepal.Width*Species,iris)
    res &lt;- plotConf(l,var2="Species")## ylim=c(6,8), xlim=c(2.5,3.3))
    with(res, click(x,y))

    with(iris, idplot(Sepal.Length,Petal.Length))
}
</code></pre>

<hr>
<h2 id='closed.testing'>Closed testing procedure</h2><span id='topic+closed.testing'></span><span id='topic+p.correct'></span>

<h3>Description</h3>

<p>Closed testing procedure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closed.testing(
  object,
  idx = seq_along(coef(object)),
  null,
  return.all = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closed.testing_+3A_object">object</code></td>
<td>
<p>estimate object</p>
</td></tr>
<tr><td><code id="closed.testing_+3A_idx">idx</code></td>
<td>
<p>Index of parameters to adjust for multiple testing</p>
</td></tr>
<tr><td><code id="closed.testing_+3A_null">null</code></td>
<td>
<p>Null hypothesis value</p>
</td></tr>
<tr><td><code id="closed.testing_+3A_return.all">return.all</code></td>
<td>
<p>If TRUE details on all intersection hypotheses are returned</p>
</td></tr>
<tr><td><code id="closed.testing_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm()
regression(m, c(y1,y2,y3,y4,y5,y6,y7)~x) &lt;- c(0,0.25,0,0.25,0.25,0,0)
regression(m, to=endogenous(m), from="u") &lt;- 1
variance(m,endogenous(m)) &lt;- 1
set.seed(2)
d &lt;- sim(m,200)
l1 &lt;- lm(y1~x,d)
l2 &lt;- lm(y2~x,d)
l3 &lt;- lm(y3~x,d)
l4 &lt;- lm(y4~x,d)
l5 &lt;- lm(y5~x,d)
l6 &lt;- lm(y6~x,d)
l7 &lt;- lm(y7~x,d)

(a &lt;- merge(l1,l2,l3,l4,l5,l6,l7,subset=2))
if (requireNamespace("mets",quietly=TRUE)) {
   p.correct(a)
}
as.vector(closed.testing(a))

</code></pre>

<hr>
<h2 id='Col'>Generate a transparent RGB color</h2><span id='topic+Col'></span>

<h3>Description</h3>

<p>This function transforms a standard color (e.g. &quot;red&quot;) into an
transparent RGB-color (i.e. alpha-blend&lt;1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Col(col, alpha = 0.2, locate = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Col_+3A_col">col</code></td>
<td>
<p>Color (numeric or character)</p>
</td></tr>
<tr><td><code id="Col_+3A_alpha">alpha</code></td>
<td>
<p>Degree of transparency (0,1)</p>
</td></tr>
<tr><td><code id="Col_+3A_locate">locate</code></td>
<td>
<p>Choose colour (with mouse)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This only works for certain graphics devices (Cairo-X11 (x11 as of R&gt;=2.7), quartz, pdf, ...).
</p>


<h3>Value</h3>

<p>A character vector with elements of 7 or 9 characters, '#'
followed by the red, blue, green and optionally alpha values in
hexadecimal (after rescaling to '0 ... 255').
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(runif(1000),cex=runif(1000,0,4),col=Col(c("darkblue","orange"),0.5),pch=16)
</code></pre>

<hr>
<h2 id='colorbar'>Add color-bar to plot</h2><span id='topic+colorbar'></span>

<h3>Description</h3>

<p>Add color-bar to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorbar(
  clut = Col(rev(rainbow(11, start = 0, end = 0.69)), alpha),
  x.range = c(-0.5, 0.5),
  y.range = c(-0.1, 0.1),
  values = seq(clut),
  digits = 2,
  label.offset,
  srt = 45,
  cex = 0.5,
  border = NA,
  alpha = 0.5,
  position = 1,
  direction = c("horizontal", "vertical"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorbar_+3A_clut">clut</code></td>
<td>
<p>Color look-up table</p>
</td></tr>
<tr><td><code id="colorbar_+3A_x.range">x.range</code></td>
<td>
<p>x range</p>
</td></tr>
<tr><td><code id="colorbar_+3A_y.range">y.range</code></td>
<td>
<p>y range</p>
</td></tr>
<tr><td><code id="colorbar_+3A_values">values</code></td>
<td>
<p>label values</p>
</td></tr>
<tr><td><code id="colorbar_+3A_digits">digits</code></td>
<td>
<p>number of digits</p>
</td></tr>
<tr><td><code id="colorbar_+3A_label.offset">label.offset</code></td>
<td>
<p>label offset</p>
</td></tr>
<tr><td><code id="colorbar_+3A_srt">srt</code></td>
<td>
<p>rotation of labels</p>
</td></tr>
<tr><td><code id="colorbar_+3A_cex">cex</code></td>
<td>
<p>text size</p>
</td></tr>
<tr><td><code id="colorbar_+3A_border">border</code></td>
<td>
<p>border of color bar rectangles</p>
</td></tr>
<tr><td><code id="colorbar_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (transparency) level 0-1</p>
</td></tr>
<tr><td><code id="colorbar_+3A_position">position</code></td>
<td>
<p>Label position left/bottom (1) or top/right (2) or no text (0)</p>
</td></tr>
<tr><td><code id="colorbar_+3A_direction">direction</code></td>
<td>
<p>horizontal or vertical color bars</p>
</td></tr>
<tr><td><code id="colorbar_+3A_...">...</code></td>
<td>
<p>additional low level arguments (i.e. parsed to <code>text</code>)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plotNeuro(x,roi=R,mm=-18,range=5)
colorbar(clut=Col(rev(rainbow(11,start=0,end=0.69)),0.5),
         x=c(-40,40),y.range=c(84,90),values=c(-5:5))

colorbar(clut=Col(rev(rainbow(11,start=0,end=0.69)),0.5),
         x=c(-10,10),y.range=c(-100,50),values=c(-5:5),
         direction="vertical",border=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='Combine'>Report estimates across different models</h2><span id='topic+Combine'></span>

<h3>Description</h3>

<p>Report estimates across different models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Combine(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Combine_+3A_x">x</code></td>
<td>
<p>list of model objects</p>
</td></tr>
<tr><td><code id="Combine_+3A_...">...</code></td>
<td>
<p>additional arguments to lower-level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(serotonin)
m1 &lt;- lm(cau ~ age*gene1 + age*gene2,data=serotonin)
m2 &lt;- lm(cau ~ age + gene1,data=serotonin)
m3 &lt;- lm(cau ~ age*gene2,data=serotonin)

Combine(list(A=m1,B=m2,C=m3),fun=function(x)
     c("_____"="",R2=" "%++%format(summary(x)$r.squared,digits=2)))
</code></pre>

<hr>
<h2 id='commutation'>Finds the unique commutation matrix</h2><span id='topic+commutation'></span>

<h3>Description</h3>

<p>Finds the unique commutation matrix K:
<code class="reqn">K vec(A) = vec(A^t)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commutation(m, n = m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="commutation_+3A_m">m</code></td>
<td>
<p>rows</p>
</td></tr>
<tr><td><code id="commutation_+3A_n">n</code></td>
<td>
<p>columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='compare'>Statistical tests</h2><span id='topic+compare'></span>

<h3>Description</h3>

<p>Performs Likelihood-ratio, Wald and score tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_object">object</code></td>
<td>
<p><code>lvmfit</code>-object</p>
</td></tr>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>Additional arguments to low-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of test-statistics and p-values
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelsearch">modelsearch</a></code>, <code><a href="#topic+equivalence">equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm();
regression(m) &lt;- c(y1,y2,y3) ~ eta; latent(m) &lt;- ~eta
regression(m) &lt;- eta ~ x
m2 &lt;- regression(m, c(y3,eta) ~ x)
set.seed(1)
d &lt;- sim(m,1000)
e &lt;- estimate(m,d)
e2 &lt;- estimate(m2,d)

compare(e)

compare(e,e2) ## LRT, H0: y3&lt;-x=0
compare(e,scoretest=y3~x) ## Score-test, H0: y3~x=0
compare(e2,par=c("y3~x")) ## Wald-test, H0: y3~x=0

B &lt;- diag(2); colnames(B) &lt;- c("y2~eta","y3~eta")
compare(e2,contrast=B,null=c(1,1))

B &lt;- rep(0,length(coef(e2))); B[1:3] &lt;- 1
compare(e2,contrast=B)

compare(e,scoretest=list(y3~x,y2~x))
</code></pre>

<hr>
<h2 id='complik'>Composite Likelihood for probit latent variable models</h2><span id='topic+complik'></span>

<h3>Description</h3>

<p>Estimate parameters in a probit latent variable model via a composite
likelihood decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complik(
  x,
  data,
  k = 2,
  type = c("all", "nearest"),
  pairlist,
  messages = 0,
  estimator = "normal",
  quick = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complik_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="complik_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="complik_+3A_k">k</code></td>
<td>
<p>Size of composite groups</p>
</td></tr>
<tr><td><code id="complik_+3A_type">type</code></td>
<td>
<p>Determines number of groups. With <code>type="nearest"</code> (default)
only neighboring items will be grouped, e.g. for <code>k=2</code>
(y1,y2),(y2,y3),... With <code>type="all"</code> all combinations of size <code>k</code>
are included</p>
</td></tr>
<tr><td><code id="complik_+3A_pairlist">pairlist</code></td>
<td>
<p>A list of indices specifying the composite groups. Optional
argument which overrides <code>k</code> and <code>type</code> but gives complete
flexibility in the specification of the composite likelihood</p>
</td></tr>
<tr><td><code id="complik_+3A_messages">messages</code></td>
<td>
<p>Control amount of messages printed</p>
</td></tr>
<tr><td><code id="complik_+3A_estimator">estimator</code></td>
<td>
<p>Model (pseudo-likelihood) to use for the pairs/groups</p>
</td></tr>
<tr><td><code id="complik_+3A_quick">quick</code></td>
<td>
<p>If TRUE the parameter estimates are calculated but all additional
information such as standard errors are skipped</p>
</td></tr>
<tr><td><code id="complik_+3A_...">...</code></td>
<td>
<p>Additional arguments parsed on to lower-level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>estimate.complik</code> inheriting methods from <code>lvm</code>
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p>estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(c(y1,y2,y3)~b*x+1*u[0],latent=~u)
ordinal(m,K=2) &lt;- ~y1+y2+y3
d &lt;- sim(m,50,seed=1)
if (requireNamespace("mets", quietly=TRUE)) {
   e1 &lt;- complik(m,d,control=list(trace=1),type="all")
}
</code></pre>

<hr>
<h2 id='confband'>Add Confidence limits bar to plot</h2><span id='topic+confband'></span><span id='topic+forestplot'></span><span id='topic+plot_region'></span>

<h3>Description</h3>

<p>Add Confidence limits bar to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confband(
  x,
  lower,
  upper,
  center = NULL,
  line = TRUE,
  delta = 0.07,
  centermark = 0.03,
  pch,
  blank = TRUE,
  vert = TRUE,
  polygon = FALSE,
  step = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confband_+3A_x">x</code></td>
<td>
<p>Position (x-coordinate if vert=TRUE, y-coordinate otherwise)</p>
</td></tr>
<tr><td><code id="confband_+3A_lower">lower</code></td>
<td>
<p>Lower limit (if NULL no limits is added, and only the
center is drawn (if not NULL))</p>
</td></tr>
<tr><td><code id="confband_+3A_upper">upper</code></td>
<td>
<p>Upper limit</p>
</td></tr>
<tr><td><code id="confband_+3A_center">center</code></td>
<td>
<p>Center point</p>
</td></tr>
<tr><td><code id="confband_+3A_line">line</code></td>
<td>
<p>If FALSE do not add line between upper and lower bound</p>
</td></tr>
<tr><td><code id="confband_+3A_delta">delta</code></td>
<td>
<p>Length of limit bars</p>
</td></tr>
<tr><td><code id="confband_+3A_centermark">centermark</code></td>
<td>
<p>Length of center bar</p>
</td></tr>
<tr><td><code id="confband_+3A_pch">pch</code></td>
<td>
<p>Center symbol (if missing a line is drawn)</p>
</td></tr>
<tr><td><code id="confband_+3A_blank">blank</code></td>
<td>
<p>If TRUE a white ball is plotted before the center is
added to the plot</p>
</td></tr>
<tr><td><code id="confband_+3A_vert">vert</code></td>
<td>
<p>If TRUE a vertical bar is plotted. Otherwise a horizontal
bar is used</p>
</td></tr>
<tr><td><code id="confband_+3A_polygon">polygon</code></td>
<td>
<p>If TRUE polygons are added between 'lower' and 'upper'.</p>
</td></tr>
<tr><td><code id="confband_+3A_step">step</code></td>
<td>
<p>Type of polygon (step-function or piecewise linear)</p>
</td></tr>
<tr><td><code id="confband_+3A_...">...</code></td>
<td>
<p>Additional low level arguments (e.g. col, lwd, lty,...)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>confband</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0,0,type="n",xlab="",ylab="")
confband(0.5,-0.5,0.5,0,col="darkblue")
confband(0.8,-0.5,0.5,0,col="darkred",vert=FALSE,pch=1,cex=1.5)

set.seed(1)
K &lt;- 20
est &lt;- rnorm(K)
se &lt;- runif(K,0.2,0.4)
x &lt;- cbind(est,est-2*se,est+2*se,runif(K,0.5,2))
x[c(3:4,10:12),] &lt;- NA
rownames(x) &lt;- unlist(lapply(letters[seq(K)],function(x) paste(rep(x,4),collapse="")))
rownames(x)[which(is.na(est))] &lt;- ""
signif &lt;- sign(x[,2])==sign(x[,3])
forestplot(x,text.right=FALSE)
forestplot(x[,-4],sep=c(2,15),col=signif+1,box1=TRUE,delta=0.2,pch=16,cex=1.5)
forestplot(x,vert=TRUE,text=FALSE)
forestplot(x,vert=TRUE,text=FALSE,pch=NA)
##forestplot(x,vert=TRUE,text.vert=FALSE)
##forestplot(val,vert=TRUE,add=TRUE)

z &lt;- seq(10)
zu &lt;- c(z[-1],10)
plot(z,type="n")
confband(z,zu,rep(0,length(z)),col=Col("darkblue"),polygon=TRUE,step=TRUE)
confband(z,zu,zu-2,col=Col("darkred"),polygon=TRUE,step=TRUE)

z &lt;- seq(0,1,length.out=100)
plot(z,z,type="n")
confband(z,z,z^2,polygon="TRUE",col=Col("darkblue"))

set.seed(1)
k &lt;- 10
x &lt;- seq(k)
est &lt;- rnorm(k)
sd &lt;- runif(k)
val &lt;- cbind(x,est,est-sd,est+sd)
par(mfrow=c(1,2))
plot(0,type="n",xlim=c(0,k+1),ylim=range(val[,-1]),axes=FALSE,xlab="",ylab="")
axis(2)
confband(val[,1],val[,3],val[,4],val[,2],pch=16,cex=2)
plot(0,type="n",ylim=c(0,k+1),xlim=range(val[,-1]),axes=FALSE,xlab="",ylab="")
axis(1)
confband(val[,1],val[,3],val[,4],val[,2],pch=16,cex=2,vert=FALSE)

x &lt;- seq(0, 3, length.out=20)
y &lt;- cos(x)
yl &lt;- y - 1
yu &lt;- y + 1
plot_region(x, y, yl, yu)
plot_region(x, y, yl, yu, type='s', col="darkblue", add=TRUE)

</code></pre>

<hr>
<h2 id='confint.lvmfit'>Calculate confidence limits for parameters</h2><span id='topic+confint.lvmfit'></span><span id='topic+confint.multigroupfit'></span>

<h3>Description</h3>

<p>Calculate Wald og Likelihood based (profile likelihood) confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvmfit'
confint(
  object,
  parm = seq_len(length(coef(object))),
  level = 0.95,
  profile = FALSE,
  curve = FALSE,
  n = 20,
  interval = NULL,
  lower = TRUE,
  upper = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.lvmfit_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_parm">parm</code></td>
<td>
<p>Index of which parameters to calculate confidence limits for.</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_level">level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_profile">profile</code></td>
<td>
<p>Logical expression defining whether to calculate confidence
limits via the profile log likelihood</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_curve">curve</code></td>
<td>
<p>if FALSE and profile is TRUE, confidence limits are
returned. Otherwise, the profile curve is returned.</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_n">n</code></td>
<td>
<p>Number of points to evaluate profile log-likelihood in
over the interval defined by <code>interval</code></p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_interval">interval</code></td>
<td>
<p>Interval over which the profiling is done</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_lower">lower</code></td>
<td>
<p>If FALSE the lower limit will not be estimated (profile intervals only)</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_upper">upper</code></td>
<td>
<p>If FALSE the upper limit will not be estimated (profile intervals only)</p>
</td></tr>
<tr><td><code id="confint.lvmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates either Wald confidence limits: </p>
<p style="text-align: center;"><code class="reqn">\hat{\theta} \pm
z_{\alpha/2}*\hat\sigma_{\hat\theta}</code>
</p>
<p> or profile likelihood confidence
limits, defined as the set of value <code class="reqn">\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">logLik(\hat\theta_{\tau},\tau)-logLik(\hat\theta)&lt; q_{\alpha}/2</code>
</p>

<p>where <code class="reqn">q_{\alpha}</code> is the <code class="reqn">\alpha</code> fractile of the <code class="reqn">\chi^2_1</code>
distribution, and <code class="reqn">\hat\theta_{\tau}</code> are obtained by maximizing the
log-likelihood with tau being fixed.
</p>


<h3>Value</h3>

<p>A 2xp matrix with columns of lower and upper confidence limits
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bootstrap">bootstrap</a>{lvm}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(y~x)
d &lt;- sim(m,100)
e &lt;- estimate(lvm(y~x), d)
confint(e,3,profile=TRUE)
confint(e,3)
 ## Reduce Ex.timings
B &lt;- bootstrap(e,R=50)
B

</code></pre>

<hr>
<h2 id='confpred'>Conformal prediction</h2><span id='topic+confpred'></span>

<h3>Description</h3>

<p>Conformal predicions using locally weighted conformal inference with a split-conformal algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confpred(object, data, newdata = data, alpha = 0.05, mad, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confpred_+3A_object">object</code></td>
<td>
<p>Model object (lm, glm or similar with predict method) or formula (lm)</p>
</td></tr>
<tr><td><code id="confpred_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="confpred_+3A_newdata">newdata</code></td>
<td>
<p>New data.frame to make predictions for</p>
</td></tr>
<tr><td><code id="confpred_+3A_alpha">alpha</code></td>
<td>
<p>Level of prediction interval</p>
</td></tr>
<tr><td><code id="confpred_+3A_mad">mad</code></td>
<td>
<p>Conditional model (formula) for the MAD (locally-weighted CP)</p>
</td></tr>
<tr><td><code id="confpred_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with fitted (fit), lower (lwr) and upper (upr) predictions bands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
n &lt;- 200
x &lt;- seq(0,6,length.out=n)
delta &lt;- 3
ss &lt;- exp(-1+1.5*cos((x-delta)))
ee &lt;- rnorm(n,sd=ss)
y &lt;- (x-delta)+3*cos(x+4.5-delta)+ee
d &lt;- data.frame(y=y,x=x)

newd &lt;- data.frame(x=seq(0,6,length.out=50))
cc &lt;- confpred(lm(y~splines::ns(x,knots=c(1,3,5)),data=d), data=d, newdata=newd)
if (interactive()) {
plot(y~x,pch=16,col=lava::Col("black"),ylim=c(-10,10),xlab="X",ylab="Y")
with(cc,
     lava::confband(newd$x,lwr,upr,fit,
        lwd=3,polygon=TRUE,col=Col("blue"),border=FALSE))
}
</code></pre>

<hr>
<h2 id='constrain+26lt+3B-'>Add non-linear constraints to latent variable model</h2><span id='topic+constrain+3C-'></span><span id='topic+constrain'></span><span id='topic+constrain.default'></span><span id='topic+constrain+3C-.multigroup'></span><span id='topic+constrain+3C-.default'></span><span id='topic+constraints'></span><span id='topic+parameter+3C-'></span>

<h3>Description</h3>

<p>Add non-linear constraints to latent variable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 replacement method:
constrain(x,par,args,endogenous=TRUE,...) &lt;- value

## S3 replacement method for class 'multigroup'
constrain(x,par,k=1,...) &lt;- value

constraints(object,data=model.frame(object),vcov=object$vcov,level=0.95,
                        p=pars.default(object),k,idx,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Real function taking args as a vector argument</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_par">par</code></td>
<td>
<p>Name of new parameter. Alternatively a formula with lhs
specifying the new parameter and the rhs defining the names of the
parameters or variable names defining the new parameter (overruling the
<code>args</code> argument).</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_args">args</code></td>
<td>
<p>Vector of variables names or parameter names that are used in
defining <code>par</code></p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_endogenous">endogenous</code></td>
<td>
<p>TRUE if variable is endogenous (sink node)</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_k">k</code></td>
<td>
<p>For multigroup models this argument specifies which group to
add/extract the constraint</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_data">data</code></td>
<td>
<p>Data-row from which possible non-linear constraints should be
calculated</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_vcov">vcov</code></td>
<td>
<p>Variance matrix of parameter estimates</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_level">level</code></td>
<td>
<p>Level of confidence limits</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_p">p</code></td>
<td>
<p>Parameter vector</p>
</td></tr>
<tr><td><code id="constrain+2B26lt+2B3B-_+3A_idx">idx</code></td>
<td>
<p>Index indicating which constraints to extract</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Add non-linear parameter constraints as well as non-linear associations
between covariates and latent or observed variables in the model (non-linear
regression).
</p>
<p>As an example we will specify the follow multiple regression model:
</p>
<p style="text-align: center;"><code class="reqn">E(Y|X_1,X_2) = \alpha + \beta_1 X_1 + \beta_2 X_2</code>
</p>
 <p style="text-align: center;"><code class="reqn">V(Y|X_1,X_2)
= v</code>
</p>

<p>which is defined (with the appropiate parameter labels) as
</p>
<p><code>m &lt;- lvm(y ~ f(x,beta1) + f(x,beta2))</code>
</p>
<p><code>intercept(m) &lt;- y ~ f(alpha)</code>
</p>
<p><code>covariance(m) &lt;- y ~ f(v)</code>
</p>
<p>The somewhat strained parameter constraint </p>
<p style="text-align: center;"><code class="reqn"> v =
\frac{(beta1-beta2)^2}{alpha}</code>
</p>

<p>can then specified as
</p>
<p><code>constrain(m,v ~ beta1 + beta2 + alpha) &lt;- function(x)
(x[1]-x[2])^2/x[3] </code>
</p>
<p>A subset of the arguments <code>args</code> can be covariates in the model,
allowing the specification of non-linear regression models.  As an example
the non-linear regression model </p>
<p style="text-align: center;"><code class="reqn"> E(Y\mid X) = \nu + \Phi(\alpha +
\beta X)</code>
</p>
<p> where <code class="reqn">\Phi</code> denotes the standard normal cumulative
distribution function, can be defined as
</p>
<p><code>m &lt;- lvm(y ~ f(x,0)) # No linear effect of x</code>
</p>
<p>Next we add three new parameters using the <code>parameter</code> assigment
function:
</p>
<p><code>parameter(m) &lt;- ~nu+alpha+beta</code>
</p>
<p>The intercept of <code class="reqn">Y</code> is defined as <code>mu</code>
</p>
<p><code>intercept(m) &lt;- y ~ f(mu)</code>
</p>
<p>And finally the newly added intercept parameter <code>mu</code> is defined as the
appropiate non-linear function of <code class="reqn">\alpha</code>, <code class="reqn">\nu</code> and <code class="reqn">\beta</code>:
</p>
<p><code>constrain(m, mu ~ x + alpha + nu) &lt;- function(x)
pnorm(x[1]*x[2])+x[3]</code>
</p>
<p>The <code>constraints</code> function can be used to show the estimated non-linear
parameter constraints of an estimated model object (<code>lvmfit</code> or
<code>multigroupfit</code>). Calling <code>constrain</code> with no additional arguments
beyound <code>x</code> will return a list of the functions and parameter names
defining the non-linear restrictions.
</p>
<p>The gradient function can optionally be added as an attribute <code>grad</code> to
the return value of the function defined by <code>value</code>. In this case the
analytical derivatives will be calculated via the chain rule when evaluating
the corresponding score function of the log-likelihood. If the gradient
attribute is omitted the chain rule will be applied on a numeric
approximation of the gradient.
</p>


<h3>Value</h3>

<p>A <code>lvm</code> object.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regression">regression</a></code>, <code><a href="#topic+intercept">intercept</a></code>,
<code><a href="#topic+covariance">covariance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################
### Non-linear parameter constraints 1
##############################
m &lt;- lvm(y ~ f(x1,gamma)+f(x2,beta))
covariance(m) &lt;- y ~ f(v)
d &lt;- sim(m,100)
m1 &lt;- m; constrain(m1,beta ~ v) &lt;- function(x) x^2
## Define slope of x2 to be the square of the residual variance of y
## Estimate both restricted and unrestricted model
e &lt;- estimate(m,d,control=list(method="NR"))
e1 &lt;- estimate(m1,d)
p1 &lt;- coef(e1)
p1 &lt;- c(p1[1:2],p1[3]^2,p1[3])
## Likelihood of unrestricted model evaluated in MLE of restricted model
logLik(e,p1)
## Likelihood of restricted model (MLE)
logLik(e1)

##############################
### Non-linear regression
##############################

## Simulate data
m &lt;- lvm(c(y1,y2)~f(x,0)+f(eta,1))
latent(m) &lt;- ~eta
covariance(m,~y1+y2) &lt;- "v"
intercept(m,~y1+y2) &lt;- "mu"
covariance(m,~eta) &lt;- "zeta"
intercept(m,~eta) &lt;- 0
set.seed(1)
d &lt;- sim(m,100,p=c(v=0.01,zeta=0.01))[,manifest(m)]
d &lt;- transform(d,
               y1=y1+2*pnorm(2*x),
               y2=y2+2*pnorm(2*x))

## Specify model and estimate parameters
constrain(m, mu ~ x + alpha + nu + gamma) &lt;- function(x) x[4]*pnorm(x[3]+x[1]*x[2])
 ## Reduce Ex.Timings
e &lt;- estimate(m,d,control=list(trace=1,constrain=TRUE))
constraints(e,data=d)
## Plot model-fit
plot(y1~x,d,pch=16); points(y2~x,d,pch=16,col="gray")
x0 &lt;- seq(-4,4,length.out=100)
lines(x0,coef(e)["nu"] + coef(e)["gamma"]*pnorm(coef(e)["alpha"]*x0))


##############################
### Multigroup model
##############################
### Define two models
m1 &lt;- lvm(y ~ f(x,beta)+f(z,beta2))
m2 &lt;- lvm(y ~ f(x,psi) + z)
### And simulate data from them
d1 &lt;- sim(m1,500)
d2 &lt;- sim(m2,500)
### Add 'non'-linear parameter constraint
constrain(m2,psi ~ beta2) &lt;- function(x) x
## Add parameter beta2 to model 2, now beta2 exists in both models
parameter(m2) &lt;- ~ beta2
ee &lt;- estimate(list(m1,m2),list(d1,d2),control=list(method="NR"))
summary(ee)

m3 &lt;- lvm(y ~ f(x,beta)+f(z,beta2))
m4 &lt;- lvm(y ~ f(x,beta2) + z)
e2 &lt;- estimate(list(m3,m4),list(d1,d2),control=list(method="NR"))
e2
</code></pre>

<hr>
<h2 id='contr'>Create contrast matrix</h2><span id='topic+contr'></span><span id='topic+parsedesign'></span><span id='topic+pairwise.diff'></span>

<h3>Description</h3>

<p>Create contrast matrix typically for use with 'estimate' (Wald tests).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr(p, n, diff = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr_+3A_p">p</code></td>
<td>
<p>index of non-zero entries (see example)</p>
</td></tr>
<tr><td><code id="contr_+3A_n">n</code></td>
<td>
<p>Total number of parameters (if omitted the max number in p will be used)</p>
</td></tr>
<tr><td><code id="contr_+3A_diff">diff</code></td>
<td>
<p>If FALSE all non-zero entries are +1, otherwise the second non-zero element in each row will be -1.</p>
</td></tr>
<tr><td><code id="contr_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>contr(2,n=5)
contr(as.list(2:4),n=5)
contr(list(1,2,4),n=5)
contr(c(2,3,4),n=5)
contr(list(c(1,3),c(2,4)),n=5)
contr(list(c(1,3),c(2,4),5))

parsedesign(c("aa","b","c"),"?","?",diff=c(FALSE,TRUE))

## All pairs comparisons:
pdiff &lt;- function(n) lava::contr(lapply(seq(n-1), \(x) seq(x, n)))
pdiff(4)
</code></pre>

<hr>
<h2 id='correlation'>Generic method for extracting correlation coefficients of model object</h2><span id='topic+correlation'></span>

<h3>Description</h3>

<p>Generic correlation method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlation(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlation_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="correlation_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='covariance'>Add covariance structure to Latent Variable Model</h2><span id='topic+covariance'></span><span id='topic+covariance+3C-'></span><span id='topic+covariance.lvm'></span><span id='topic+covariance+3C-.lvm'></span><span id='topic+covfix+3C-'></span><span id='topic+covfix'></span><span id='topic+covfix+3C-.lvm'></span><span id='topic+covfix.lvm'></span><span id='topic+variance'></span><span id='topic+variance+3C-'></span><span id='topic+variance.lvm'></span><span id='topic+variance+3C-.lvm'></span>

<h3>Description</h3>

<p>Define covariances between residual terms in a <code>lvm</code>-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'lvm'
covariance(object, var1=NULL, var2=NULL, constrain=FALSE, pairwise=FALSE,...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covariance_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="covariance_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="covariance_+3A_var1">var1</code></td>
<td>
<p>Vector of variables names (or formula)</p>
</td></tr>
<tr><td><code id="covariance_+3A_var2">var2</code></td>
<td>
<p>Vector of variables names (or formula) defining pairwise
covariance between <code>var1</code> and <code>var2</code>)</p>
</td></tr>
<tr><td><code id="covariance_+3A_constrain">constrain</code></td>
<td>
<p>Define non-linear parameter constraints to ensure positive definite structure</p>
</td></tr>
<tr><td><code id="covariance_+3A_pairwise">pairwise</code></td>
<td>
<p>If TRUE and <code>var2</code> is omitted then pairwise correlation is added between all variables in <code>var1</code></p>
</td></tr>
<tr><td><code id="covariance_+3A_value">value</code></td>
<td>
<p>List of parameter values or (if <code>var1</code> is unspecified)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>covariance</code> function is used to specify correlation structure
between residual terms of a latent variable model, using a formula syntax.
</p>
<p>For instance, a multivariate model with three response variables,
</p>
<p style="text-align: center;"><code class="reqn">Y_1 = \mu_1 + \epsilon_1</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_2 = \mu_2 + \epsilon_2</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_3 = \mu_3 + \epsilon_3</code>
</p>

<p>can be specified as
</p>
<p><code>m &lt;- lvm(~y1+y2+y3)</code>
</p>
<p>Pr. default the two variables are assumed to be independent. To add a
covariance parameter <code class="reqn">r = cov(\epsilon_1,\epsilon_2)</code>, we execute the
following code
</p>
<p><code>covariance(m) &lt;- y1 ~ f(y2,r)</code>
</p>
<p>The special function <code>f</code> and its second argument could be omitted thus
assigning an unique parameter the covariance between <code>y1</code> and
<code>y2</code>.
</p>
<p>Similarily the marginal variance of the two response variables can be fixed
to be identical (<code class="reqn">var(Y_i)=v</code>) via
</p>
<p><code>covariance(m) &lt;- c(y1,y2,y3) ~ f(v)</code>
</p>
<p>To specify a completely unstructured covariance structure, we can call
</p>
<p><code>covariance(m) &lt;- ~y1+y2+y3</code>
</p>
<p>All the parameter values of the linear constraints can be given as the right
handside expression of the assigment function <code>covariance&lt;-</code> if the
first (and possibly second) argument is defined as well. E.g:
</p>
<p><code>covariance(m,y1~y1+y2) &lt;- list("a1","b1")</code>
</p>
<p><code>covariance(m,~y2+y3) &lt;- list("a2",2)</code>
</p>
<p>Defines
</p>
<p style="text-align: center;"><code class="reqn">var(\epsilon_1) = a1</code>
</p>

<p style="text-align: center;"><code class="reqn">var(\epsilon_2) = a2</code>
</p>

<p style="text-align: center;"><code class="reqn">var(\epsilon_3) = 2</code>
</p>

<p style="text-align: center;"><code class="reqn">cov(\epsilon_1,\epsilon_2) = b1</code>
</p>

<p>Parameter constraints can be cleared by fixing the relevant parameters to
<code>NA</code> (see also the <code>regression</code> method).
</p>
<p>The function <code>covariance</code> (called without additional arguments) can be
used to inspect the covariance constraints of a <code>lvm</code>-object.
</p>


<h3>Value</h3>

<p>A <code>lvm</code>-object
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regression+3C-">regression&lt;-</a></code>, <code><a href="#topic+intercept+3C-">intercept&lt;-</a></code>,
<code><a href="#topic+constrain+3C-">constrain&lt;-</a></code> <code><a href="#topic+parameter+3C-">parameter&lt;-</a></code>, <code><a href="#topic+latent+3C-">latent&lt;-</a></code>,
<code><a href="#topic+cancel+3C-">cancel&lt;-</a></code>, <code><a href="#topic+kill+3C-">kill&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm()
### Define covariance between residuals terms of y1 and y2
covariance(m) &lt;- y1~y2
covariance(m) &lt;- c(y1,y2)~f(v) ## Same marginal variance
covariance(m) ## Examine covariance structure


</code></pre>

<hr>
<h2 id='csplit'>Split data into folds</h2><span id='topic+csplit'></span><span id='topic+foldr'></span>

<h3>Description</h3>

<p>Split data into folds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csplit(x, p = NULL, replace = FALSE, return.index = FALSE, k = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csplit_+3A_x">x</code></td>
<td>
<p>Data or integer (size)</p>
</td></tr>
<tr><td><code id="csplit_+3A_p">p</code></td>
<td>
<p>Number of folds, or if a number between 0 and 1 is given two folds of size p and (1-p) will be returned</p>
</td></tr>
<tr><td><code id="csplit_+3A_replace">replace</code></td>
<td>
<p>With or with-out replacement</p>
</td></tr>
<tr><td><code id="csplit_+3A_return.index">return.index</code></td>
<td>
<p>If TRUE index of folds are returned otherwise the actual data splits are returned (default)</p>
</td></tr>
<tr><td><code id="csplit_+3A_k">k</code></td>
<td>
<p>(Optional, only used when p=NULL) number of folds without shuffling</p>
</td></tr>
<tr><td><code id="csplit_+3A_...">...</code></td>
<td>
<p>additional arguments to lower-level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foldr(5,2,rep=2)
csplit(10,3)
csplit(iris[1:10,]) ## Split in two sets 1:(n/2) and (n/2+1):n
csplit(iris[1:10,],0.5)
</code></pre>

<hr>
<h2 id='curly'>Adds curly brackets to plot</h2><span id='topic+curly'></span>

<h3>Description</h3>

<p>Adds curly brackets to plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curly(
  x,
  y,
  len = 1,
  theta = 0,
  wid,
  shape = 1,
  col = 1,
  lwd = 1,
  lty = 1,
  grid = FALSE,
  npoints = 50,
  text = NULL,
  offset = c(0.05, 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curly_+3A_x">x</code></td>
<td>
<p>center of the x axis of the curly brackets (or start end coordinates (x1,x2))</p>
</td></tr>
<tr><td><code id="curly_+3A_y">y</code></td>
<td>
<p>center of the y axis of the curly brackets (or start end coordinates (y1,y2))</p>
</td></tr>
<tr><td><code id="curly_+3A_len">len</code></td>
<td>
<p>Length of the curly brackets</p>
</td></tr>
<tr><td><code id="curly_+3A_theta">theta</code></td>
<td>
<p>angle (in radians) of the curly brackets orientation</p>
</td></tr>
<tr><td><code id="curly_+3A_wid">wid</code></td>
<td>
<p>Width of the curly brackets</p>
</td></tr>
<tr><td><code id="curly_+3A_shape">shape</code></td>
<td>
<p>shape (curvature)</p>
</td></tr>
<tr><td><code id="curly_+3A_col">col</code></td>
<td>
<p>color (passed to lines/grid.lines)</p>
</td></tr>
<tr><td><code id="curly_+3A_lwd">lwd</code></td>
<td>
<p>line width (passed to lines/grid.lines)</p>
</td></tr>
<tr><td><code id="curly_+3A_lty">lty</code></td>
<td>
<p>line type (passed to lines/grid.lines)</p>
</td></tr>
<tr><td><code id="curly_+3A_grid">grid</code></td>
<td>
<p>If TRUE use grid graphics (compatability with ggplot2)</p>
</td></tr>
<tr><td><code id="curly_+3A_npoints">npoints</code></td>
<td>
<p>Number of points used in curves</p>
</td></tr>
<tr><td><code id="curly_+3A_text">text</code></td>
<td>
<p>Label</p>
</td></tr>
<tr><td><code id="curly_+3A_offset">offset</code></td>
<td>
<p>Label offset (x,y)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
plot(0,0,type="n",axes=FALSE,xlab="",ylab="")
curly(x=c(1,0),y=c(0,1),lwd=2,text="a")
curly(x=c(1,0),y=c(0,1),lwd=2,text="b",theta=pi)
curly(x=-0.5,y=0,shape=1,theta=pi,text="c")
curly(x=0,y=0,shape=1,theta=0,text="d")
curly(x=0.5,y=0,len=0.2,theta=pi/2,col="blue",lty=2)
curly(x=0.5,y=-0.5,len=0.2,theta=-pi/2,col="red",shape=1e3,text="e")
}
</code></pre>

<hr>
<h2 id='devcoords'>Returns device-coordinates and plot-region</h2><span id='topic+devcoords'></span>

<h3>Description</h3>

<p>Returns device-coordinates and plot-region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>devcoords()
</code></pre>


<h3>Value</h3>

<p>A <code>list</code> with elements
</p>
<table>
<tr><td><code>dev.x1</code></td>
<td>
<p>Device: Left x-coordinate</p>
</td></tr>
<tr><td><code>dev.x2</code></td>
<td>
<p>Device: Right x-coordinate</p>
</td></tr>
<tr><td><code>dev.y1</code></td>
<td>
<p>Device Bottom y-coordinate</p>
</td></tr>
<tr><td><code>dev.y2</code></td>
<td>
<p>Device Top y-coordinate</p>
</td></tr>
<tr><td><code>fig.x1</code></td>
<td>
<p>Plot: Left x-coordinate</p>
</td></tr>
<tr><td><code>fig.x2</code></td>
<td>
<p>Plot: Right x-coordinate</p>
</td></tr>
<tr><td><code>fig.y1</code></td>
<td>
<p>Plot: Bottom y-coordinate</p>
</td></tr>
<tr><td><code>fig.y2</code></td>
<td>
<p>Plot: Top y-coordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='diagtest'>Calculate diagnostic tests for 2x2 table</h2><span id='topic+diagtest'></span><span id='topic+odds'></span><span id='topic+riskcomp'></span><span id='topic+OR'></span><span id='topic+Ratio'></span><span id='topic+Diff'></span>

<h3>Description</h3>

<p>Calculate prevalence, sensitivity, specificity, and positive and
negative predictive values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagtest(
  table,
  positive = 2,
  exact = FALSE,
  p0 = NA,
  confint = c("logit", "arcsin", "pseudoscore", "exact"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagtest_+3A_table">table</code></td>
<td>
<p>Table or (matrix/data.frame with two columns)</p>
</td></tr>
<tr><td><code id="diagtest_+3A_positive">positive</code></td>
<td>
<p>Switch reference</p>
</td></tr>
<tr><td><code id="diagtest_+3A_exact">exact</code></td>
<td>
<p>If TRUE exact binomial proportions CI/test will be used</p>
</td></tr>
<tr><td><code id="diagtest_+3A_p0">p0</code></td>
<td>
<p>Optional null hypothesis (test prevalenc, sensitivity, ...)</p>
</td></tr>
<tr><td><code id="diagtest_+3A_confint">confint</code></td>
<td>
<p>Type of confidence limits</p>
</td></tr>
<tr><td><code id="diagtest_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Table should be in the format with outcome in columns and
test in rows.  Data.frame should be with test in the first
column and outcome in the second column.
</p>


<h3>Author(s)</h3>

<p>Klaus Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- as.table(matrix(c(42,12,
                       35,28),ncol=2,byrow=TRUE,
                     dimnames=list(rater=c("no","yes"),gold=c("no","yes"))))
diagtest(M,exact=TRUE)
</code></pre>

<hr>
<h2 id='dsep.lvm'>Check d-separation criterion</h2><span id='topic+dsep.lvm'></span><span id='topic+dsep'></span>

<h3>Description</h3>

<p>Check for conditional independence (d-separation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
dsep(object, x, cond = NULL, return.graph = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsep.lvm_+3A_object">object</code></td>
<td>
<p>lvm object</p>
</td></tr>
<tr><td><code id="dsep.lvm_+3A_x">x</code></td>
<td>
<p>Variables for which to check for conditional independence</p>
</td></tr>
<tr><td><code id="dsep.lvm_+3A_cond">cond</code></td>
<td>
<p>Conditioning set</p>
</td></tr>
<tr><td><code id="dsep.lvm_+3A_return.graph">return.graph</code></td>
<td>
<p>If TRUE the moralized ancestral graph with the
conditioning set removed is returned</p>
</td></tr>
<tr><td><code id="dsep.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument 'x' can be given as a formula, e.g.  x~y|z+v
or ~x+y|z+v With everything on the rhs of the bar defining the
variables on which to condition on.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(x5 ~ x4+x3, x4~x3+x1, x3~x2, x2~x1)
if (interactive()) {
plot(m,layoutType='neato')
}
dsep(m,x5~x1|x2+x4)
dsep(m,x5~x1|x3+x4)
dsep(m,~x1+x2+x3|x4)

</code></pre>

<hr>
<h2 id='equivalence'>Identify candidates of equivalent models</h2><span id='topic+equivalence'></span>

<h3>Description</h3>

<p>Identifies candidates of equivalent models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalence(x, rel, tol = 0.001, k = 1, omitrel = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalence_+3A_x">x</code></td>
<td>
<p><code>lvmfit</code>-object</p>
</td></tr>
<tr><td><code id="equivalence_+3A_rel">rel</code></td>
<td>
<p>Formula or character-vector specifying two variables to omit from
the model and subsequently search for possible equivalent models</p>
</td></tr>
<tr><td><code id="equivalence_+3A_tol">tol</code></td>
<td>
<p>Define two models as empirical equivalent if the absolute
difference in score test is less than <code>tol</code></p>
</td></tr>
<tr><td><code id="equivalence_+3A_k">k</code></td>
<td>
<p>Number of parameters to test simultaneously. For <code>equivalence</code>
the number of additional associations to be added instead of <code>rel</code>.</p>
</td></tr>
<tr><td><code id="equivalence_+3A_omitrel">omitrel</code></td>
<td>
<p>if <code>k</code> greater than 1, this boolean defines wether to
omit candidates containing <code>rel</code> from the output</p>
</td></tr>
<tr><td><code id="equivalence_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the lower-level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare">compare</a></code>, <code><a href="#topic+modelsearch">modelsearch</a></code>
</p>

<hr>
<h2 id='estimate.array'>Estimate parameters and influence function.</h2><span id='topic+estimate.array'></span><span id='topic+estimate.data.frame'></span>

<h3>Description</h3>

<p>Estimate parameters for the sample mean, variance, and quantiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'array'
estimate(x, type = "mean", probs = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.array_+3A_x">x</code></td>
<td>
<p>numeric matrix</p>
</td></tr>
<tr><td><code id="estimate.array_+3A_type">type</code></td>
<td>
<p>target parameter (&quot;mean&quot;, &quot;variance&quot;, &quot;quantile&quot;)</p>
</td></tr>
<tr><td><code id="estimate.array_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities (for type=&quot;quantile&quot;)</p>
</td></tr>
<tr><td><code id="estimate.array_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions (i.e., stats::density.default when type=&quot;quantile&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='estimate.default'>Estimation of functional of parameters</h2><span id='topic+estimate.default'></span><span id='topic+estimate'></span><span id='topic+estimate.estimate'></span><span id='topic+merge.estimate'></span><span id='topic+estimate.mlm'></span>

<h3>Description</h3>

<p>Estimation of functional of parameters.
Wald tests, robust standard errors, cluster robust standard errors,
LRT (when <code>f</code> is not a function)...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
estimate(
  x = NULL,
  f = NULL,
  ...,
  data,
  id,
  iddata,
  stack = TRUE,
  average = FALSE,
  subset,
  score.deriv,
  level = 0.95,
  IC = robust,
  type = c("robust", "df", "mbn"),
  keep,
  use,
  regex = FALSE,
  ignore.case = FALSE,
  contrast,
  null,
  vcov,
  coef,
  robust = TRUE,
  df = NULL,
  print = NULL,
  labels,
  label.width,
  only.coef = FALSE,
  back.transform = NULL,
  folds = 0,
  cluster,
  R = 0,
  null.sim
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.default_+3A_x">x</code></td>
<td>
<p>model object (<code>glm</code>, <code>lvmfit</code>, ...)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_f">f</code></td>
<td>
<p>transformation of model parameters and (optionally) data, or contrast matrix (or vector)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_data">data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="estimate.default_+3A_id">id</code></td>
<td>
<p>(optional) id-variable corresponding to ic decomposition of model parameters.</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_iddata">iddata</code></td>
<td>
<p>(optional) id-variable for 'data'</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_stack">stack</code></td>
<td>
<p>if TRUE (default)  the i.i.d. decomposition is automatically stacked according to 'id'</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_average">average</code></td>
<td>
<p>if TRUE averages are calculated</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_subset">subset</code></td>
<td>
<p>(optional) subset of data.frame on which to condition (logical expression or variable name)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_score.deriv">score.deriv</code></td>
<td>
<p>(optional) derivative of mean score function</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_level">level</code></td>
<td>
<p>level of confidence limits</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_ic">IC</code></td>
<td>
<p>if TRUE (default) the influence function decompositions are also returned (extract with <code>IC</code> method)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_type">type</code></td>
<td>
<p>type of small-sample correction</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_keep">keep</code></td>
<td>
<p>(optional) index of parameters to keep from final result</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_use">use</code></td>
<td>
<p>(optional) index of parameters to use in calculations</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_regex">regex</code></td>
<td>
<p>If TRUE use regular expression (perl compatible) for keep,use arguments</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Ignore case-sensitiveness in regular expression</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_contrast">contrast</code></td>
<td>
<p>(optional) Contrast matrix for final Wald test</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_null">null</code></td>
<td>
<p>(optional) null hypothesis to test</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_vcov">vcov</code></td>
<td>
<p>(optional) covariance matrix of parameter estimates (e.g. Wald-test)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_coef">coef</code></td>
<td>
<p>(optional) parameter coefficient</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_robust">robust</code></td>
<td>
<p>if TRUE robust standard errors are calculated. If
FALSE p-values for linear models are calculated from t-distribution</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_df">df</code></td>
<td>
<p>degrees of freedom (default obtained from 'df.residual')</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_print">print</code></td>
<td>
<p>(optional) print function</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_labels">labels</code></td>
<td>
<p>(optional) names of coefficients</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_label.width">label.width</code></td>
<td>
<p>(optional) max width of labels</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_only.coef">only.coef</code></td>
<td>
<p>if TRUE only the coefficient matrix is return</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_back.transform">back.transform</code></td>
<td>
<p>(optional) transform of parameters and confidence intervals</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_folds">folds</code></td>
<td>
<p>(optional) aggregate influence functions (divide and conquer)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_cluster">cluster</code></td>
<td>
<p>(obsolete) alias for 'id'.</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_r">R</code></td>
<td>
<p>Number of simulations (simulated p-values)</p>
</td></tr>
<tr><td><code id="estimate.default_+3A_null.sim">null.sim</code></td>
<td>
<p>Mean under the null for simulations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>influence function decomposition of estimator <code class="reqn">\widehat{\theta}</code> based on
data <code class="reqn">Z_1,\ldots,Z_n</code>:
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{n}(\widehat{\theta}-\theta) = \frac{1}{\sqrt{n}}\sum_{i=1}^n IC(Z_i; P) + o_p(1)</code>
</p>

<p>can be extracted with the <code>IC</code> method.
</p>


<h3>See Also</h3>

<p>estimate.array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulation from logistic regression model
m &lt;- lvm(y~x+z);
distribution(m,y~x) &lt;- binomial.lvm("logit")
d &lt;- sim(m,1000)
g &lt;- glm(y~z+x,data=d,family=binomial())
g0 &lt;- glm(y~1,data=d,family=binomial())

## LRT
estimate(g,g0)

## Plain estimates (robust standard errors)
estimate(g)

## Testing contrasts
estimate(g,null=0)
estimate(g,rbind(c(1,1,0),c(1,0,2)))
estimate(g,rbind(c(1,1,0),c(1,0,2)),null=c(1,2))
estimate(g,2:3) ## same as cbind(0,1,-1)
estimate(g,as.list(2:3)) ## same as rbind(c(0,1,0),c(0,0,1))
## Alternative syntax
estimate(g,"z","z"-"x",2*"z"-3*"x")
estimate(g,z,z-x,2*z-3*x)
estimate(g,"?")  ## Wildcards
estimate(g,"*Int*","z")
estimate(g,"1","2"-"3",null=c(0,1))
estimate(g,2,3)

## Usual (non-robust) confidence intervals
estimate(g,robust=FALSE)

## Transformations
estimate(g,function(p) p[1]+p[2])

## Multiple parameters
e &lt;- estimate(g,function(p) c(p[1]+p[2],p[1]*p[2]))
e
vcov(e)

## Label new parameters
estimate(g,function(p) list("a1"=p[1]+p[2],"b1"=p[1]*p[2]))
##'
## Multiple group
m &lt;- lvm(y~x)
m &lt;- baptize(m)
d2 &lt;- d1 &lt;- sim(m,50,seed=1)
e &lt;- estimate(list(m,m),list(d1,d2))
estimate(e) ## Wrong
ee &lt;- estimate(e, id=rep(seq(nrow(d1)), 2)) ## Clustered
ee
estimate(lm(y~x,d1))

## Marginalize
f &lt;- function(p,data)
  list(p0=lava:::expit(p["(Intercept)"] + p["z"]*data[,"z"]),
       p1=lava:::expit(p["(Intercept)"] + p["x"] + p["z"]*data[,"z"]))
e &lt;- estimate(g, f, average=TRUE)
e
estimate(e,diff)
estimate(e,cbind(1,1))

## Clusters and subset (conditional marginal effects)
d$id &lt;- rep(seq(nrow(d)/4),each=4)
estimate(g,function(p,data)
         list(p0=lava:::expit(p[1] + p["z"]*data[,"z"])),
         subset=d$z&gt;0, id=d$id, average=TRUE)

## More examples with clusters:
m &lt;- lvm(c(y1,y2,y3)~u+x)
d &lt;- sim(m,10)
l1 &lt;- glm(y1~x,data=d)
l2 &lt;- glm(y2~x,data=d)
l3 &lt;- glm(y3~x,data=d)

## Some random id-numbers
id1 &lt;- c(1,1,4,1,3,1,2,3,4,5)
id2 &lt;- c(1,2,3,4,5,6,7,8,1,1)
id3 &lt;- seq(10)

## Un-stacked and stacked i.i.d. decomposition
IC(estimate(l1,id=id1,stack=FALSE))
IC(estimate(l1,id=id1))

## Combined i.i.d. decomposition
e1 &lt;- estimate(l1,id=id1)
e2 &lt;- estimate(l2,id=id2)
e3 &lt;- estimate(l3,id=id3)
(a2 &lt;- merge(e1,e2,e3))

## If all models were estimated on the same data we could use the
## syntax:
## Reduce(merge,estimate(list(l1,l2,l3)))

## Same:
IC(a1 &lt;- merge(l1,l2,l3,id=list(id1,id2,id3)))

IC(merge(l1,l2,l3,id=TRUE)) # one-to-one (same clusters)
IC(merge(l1,l2,l3,id=FALSE)) # independence


## Monte Carlo approach, simple trend test example

m &lt;- categorical(lvm(),~x,K=5)
regression(m,additive=TRUE) &lt;- y~x
d &lt;- simulate(m,100,seed=1,'y~x'=0.1)
l &lt;- lm(y~-1+factor(x),data=d)

f &lt;- function(x) coef(lm(x~seq_along(x)))[2]
null &lt;- rep(mean(coef(l)),length(coef(l))) ## just need to make sure we simulate under H0: slope=0
estimate(l,f,R=1e2,null.sim=null)

estimate(l,f)
</code></pre>

<hr>
<h2 id='estimate.lvm'>Estimation of parameters in a Latent Variable Model (lvm)</h2><span id='topic+estimate.lvm'></span>

<h3>Description</h3>

<p>Estimate parameters. MLE, IV or user-defined estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
estimate(
  x,
  data = parent.frame(),
  estimator = NULL,
  control = list(),
  missing = FALSE,
  weights,
  weightsname,
  data2,
  id,
  fix,
  index = !quick,
  graph = FALSE,
  messages = lava.options()$messages,
  quick = FALSE,
  method,
  param,
  cluster,
  p,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate.lvm_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_data">data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_estimator">estimator</code></td>
<td>
<p>String defining the estimator (see details below)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_control">control</code></td>
<td>
<p>control/optimization parameters (see details below)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_missing">missing</code></td>
<td>
<p>Logical variable indiciating how to treat missing data.
Setting to FALSE leads to complete case analysis. In the other case
likelihood based inference is obtained by integrating out the missing data
under assumption the assumption that data is missing at random (MAR).</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_weights">weights</code></td>
<td>
<p>Optional weights to used by the chosen estimator.</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_weightsname">weightsname</code></td>
<td>
<p>Weights names (variable names of the model) in case
<code>weights</code> was given as a vector of column names of <code>data</code></p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_data2">data2</code></td>
<td>
<p>Optional additional dataset used by the chosen
estimator.</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_id">id</code></td>
<td>
<p>Vector (or name of column in <code>data</code>) that identifies
correlated groups of observations in the data leading to variance estimates
based on a sandwich estimator</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_fix">fix</code></td>
<td>
<p>Logical variable indicating whether parameter restriction
automatically should be imposed (e.g. intercepts of latent variables set to
0 and at least one regression parameter of each measurement model fixed to
ensure identifiability.)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_index">index</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_graph">graph</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_messages">messages</code></td>
<td>
<p>Control how much information should be
printed during estimation (0: none)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_quick">quick</code></td>
<td>
<p>If TRUE the parameter estimates are calculated but all
additional information such as standard errors are skipped</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_method">method</code></td>
<td>
<p>Optimization method</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_param">param</code></td>
<td>
<p>set parametrization (see <code>help(lava.options)</code>)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_cluster">cluster</code></td>
<td>
<p>Obsolete. Alias for 'id'.</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_p">p</code></td>
<td>
<p>Evaluate model in parameter 'p' (no optimization)</p>
</td></tr>
<tr><td><code id="estimate.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to lower-level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A list of parameters controlling the estimation and optimization procedures
is parsed via the <code>control</code> argument. By default Maximum Likelihood is
used assuming multivariate normal distributed measurement errors. A list
with one or more of the following elements is expected:
</p>

<dl>
<dt>start:</dt><dd><p>Starting value. The order of the parameters can be shown by
calling <code>coef</code> (with <code>mean=TRUE</code>) on the <code>lvm</code>-object or with
<code>plot(..., labels=TRUE)</code>. Note that this requires a check that it is
actual the model being estimated, as <code>estimate</code> might add additional
restriction to the model, e.g. through the <code>fix</code> and <code>exo.fix</code>
arguments. The <code>lvm</code>-object of a fitted model can be extracted with the
<code>Model</code>-function.</p>
</dd>
<dt>starterfun:</dt><dd><p>Starter-function with syntax
<code>function(lvm, S, mu)</code>.  Three builtin functions are available:
<code>startvalues</code>, <code>startvalues0</code>, <code>startvalues1</code>, ...</p>
</dd>
<dt>estimator:</dt><dd><p> String defining which estimator to use (Defaults to
&ldquo;<code>gaussian</code>&rdquo;)</p>
</dd>
<dt>meanstructure</dt><dd><p>Logical variable indicating
whether to fit model with meanstructure.</p>
</dd>
<dt>method:</dt><dd><p> String pointing to
alternative optimizer (e.g. <code>optim</code> to use simulated annealing).</p>
</dd>
<dt>control:</dt><dd><p> Parameters passed to the optimizer (default
<code>stats::nlminb</code>).</p>
</dd>
<dt>tol:</dt><dd><p> Tolerance of optimization constraints on lower limit of
variance parameters.  </p>
</dd> </dl>



<h3>Value</h3>

<p>A <code>lvmfit</code>-object.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p>estimate.default score, information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- read.table(header=TRUE,
text="x1 x2 x3
 0.0 -0.5 -2.5
-0.5 -2.0  0.0
 1.0  1.5  1.0
 0.0  0.5  0.0
-2.5 -1.5 -1.0")
e &lt;- estimate(lvm(c(x1,x2,x3)~u),dd)

## Simulation example
m &lt;- lvm(list(y~v1+v2+v3+v4,c(v1,v2,v3,v4)~x))
covariance(m) &lt;- v1~v2+v3+v4
dd &lt;- sim(m,10000) ## Simulate 10000 observations from model
e &lt;- estimate(m, dd) ## Estimate parameters
e

## Using just sufficient statistics
n &lt;- nrow(dd)
e0 &lt;- estimate(m,data=list(S=cov(dd)*(n-1)/n,mu=colMeans(dd),n=n))
rm(dd)

## Multiple group analysis
m &lt;- lvm()
regression(m) &lt;- c(y1,y2,y3)~u
regression(m) &lt;- u~x
d1 &lt;- sim(m,100,p=c("u,u"=1,"u~x"=1))
d2 &lt;- sim(m,100,p=c("u,u"=2,"u~x"=-1))

mm &lt;- baptize(m)
regression(mm,u~x) &lt;- NA
covariance(mm,~u) &lt;- NA
intercept(mm,~u) &lt;- NA
ee &lt;- estimate(list(mm,mm),list(d1,d2))

## Missing data
d0 &lt;- makemissing(d1,cols=1:2)
e0 &lt;- estimate(m,d0,missing=TRUE)
e0
</code></pre>

<hr>
<h2 id='eventTime'>Add an observed event time outcome to a latent variable model.</h2><span id='topic+eventTime'></span><span id='topic+eventTime+3C-'></span>

<h3>Description</h3>

<p>For example, if the model 'm' includes latent event time variables
are called 'T1' and 'T2' and 'C' is the end of follow-up (right censored),
then one can specify
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventTime(object, formula, eventName = "status", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eventTime_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="eventTime_+3A_formula">formula</code></td>
<td>
<p>Formula (see details)</p>
</td></tr>
<tr><td><code id="eventTime_+3A_eventname">eventName</code></td>
<td>
<p>Event names</p>
</td></tr>
<tr><td><code id="eventTime_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower levels functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eventTime(object=m,formula=ObsTime~min(T1=a,T2=b,C=0,"ObsEvent"))</code>
</p>
<p>when data are simulated from the model
one gets 2 new columns:
</p>
<p>- &quot;ObsTime&quot;: the smallest of T1, T2 and C
- &quot;ObsEvent&quot;: 'a' if T1 is smallest, 'b' if T2 is smallest and '0' if C is smallest
</p>
<p>Note that &quot;ObsEvent&quot; and &quot;ObsTime&quot; are names specified by the user.
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds, Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Right censored survival data without covariates
m0 &lt;- lvm()
distribution(m0,"eventtime") &lt;- coxWeibull.lvm(scale=1/100,shape=2)
distribution(m0,"censtime") &lt;- coxExponential.lvm(rate=1/10)
m0 &lt;- eventTime(m0,time~min(eventtime=1,censtime=0),"status")
sim(m0,10)

# Alternative specification of the right censored survival outcome
## eventTime(m,"Status") &lt;- ~min(eventtime=1,censtime=0)

# Cox regression:
# lava implements two different parametrizations of the same
# Weibull regression model. The first specifies
# the effects of covariates as proportional hazard ratios
# and works as follows:
m &lt;- lvm()
distribution(m,"eventtime") &lt;- coxWeibull.lvm(scale=1/100,shape=2)
distribution(m,"censtime") &lt;- coxWeibull.lvm(scale=1/100,shape=2)
m &lt;- eventTime(m,time~min(eventtime=1,censtime=0),"status")
distribution(m,"sex") &lt;- binomial.lvm(p=0.4)
distribution(m,"sbp") &lt;- normal.lvm(mean=120,sd=20)
regression(m,from="sex",to="eventtime") &lt;- 0.4
regression(m,from="sbp",to="eventtime") &lt;- -0.01
sim(m,6)
# The parameters can be recovered using a Cox regression
# routine or a Weibull regression model. E.g.,
## Not run: 
    set.seed(18)
    d &lt;- sim(m,1000)
    library(survival)
    coxph(Surv(time,status)~sex+sbp,data=d)

    sr &lt;- survreg(Surv(time,status)~sex+sbp,data=d)
    library(SurvRegCensCov)
    ConvertWeibull(sr)


## End(Not run)

# The second parametrization is an accelerated failure time
# regression model and uses the function weibull.lvm instead
# of coxWeibull.lvm to specify the event time distributions.
# Here is an example:

ma &lt;- lvm()
distribution(ma,"eventtime") &lt;- weibull.lvm(scale=3,shape=1/0.7)
distribution(ma,"censtime") &lt;- weibull.lvm(scale=2,shape=1/0.7)
ma &lt;- eventTime(ma,time~min(eventtime=1,censtime=0),"status")
distribution(ma,"sex") &lt;- binomial.lvm(p=0.4)
distribution(ma,"sbp") &lt;- normal.lvm(mean=120,sd=20)
regression(ma,from="sex",to="eventtime") &lt;- 0.7
regression(ma,from="sbp",to="eventtime") &lt;- -0.008
set.seed(17)
sim(ma,6)
# The regression coefficients of the AFT model
# can be tranformed into log(hazard ratios):
#  coef.coxWeibull = - coef.weibull / shape.weibull
## Not run: 
    set.seed(17)
    da &lt;- sim(ma,1000)
    library(survival)
    fa &lt;- coxph(Surv(time,status)~sex+sbp,data=da)
    coef(fa)
    c(0.7,-0.008)/0.7

## End(Not run)


# The following are equivalent parametrizations
# which produce exactly the same random numbers:

model.aft &lt;- lvm()
distribution(model.aft,"eventtime") &lt;- weibull.lvm(intercept=-log(1/100)/2,sigma=1/2)
distribution(model.aft,"censtime") &lt;- weibull.lvm(intercept=-log(1/100)/2,sigma=1/2)
sim(model.aft,6,seed=17)

model.aft &lt;- lvm()
distribution(model.aft,"eventtime") &lt;- weibull.lvm(scale=100^(1/2), shape=2)
distribution(model.aft,"censtime") &lt;- weibull.lvm(scale=100^(1/2), shape=2)
sim(model.aft,6,seed=17)

model.cox &lt;- lvm()
distribution(model.cox,"eventtime") &lt;- coxWeibull.lvm(scale=1/100,shape=2)
distribution(model.cox,"censtime") &lt;- coxWeibull.lvm(scale=1/100,shape=2)
sim(model.cox,6,seed=17)

# The minimum of multiple latent times one of them still
# being a censoring time, yield
# right censored competing risks data

mc &lt;- lvm()
distribution(mc,~X2) &lt;- binomial.lvm()
regression(mc) &lt;- T1~f(X1,-.5)+f(X2,0.3)
regression(mc) &lt;- T2~f(X2,0.6)
distribution(mc,~T1) &lt;- coxWeibull.lvm(scale=1/100)
distribution(mc,~T2) &lt;- coxWeibull.lvm(scale=1/100)
distribution(mc,~C) &lt;- coxWeibull.lvm(scale=1/100)
mc &lt;- eventTime(mc,time~min(T1=1,T2=2,C=0),"event")
sim(mc,6)


</code></pre>

<hr>
<h2 id='Expand'>Create a Data Frame from All Combinations of Factors</h2><span id='topic+Expand'></span>

<h3>Description</h3>

<p>Create a Data Frame from All Combinations of Factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Expand(`_data`, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Expand_+3A__data">_data</code></td>
<td>
<p>Data.frame</p>
</td></tr>
<tr><td><code id="Expand_+3A_...">...</code></td>
<td>
<p>vectors, factors or a list containing these</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple wrapper of the 'expand.grid' function.  If x is a table
then a data frame is returned with one row pr individual
observation.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dd &lt;- Expand(iris, Sepal.Length=2:8, Species=c("virginica","setosa"))
summary(dd)

T &lt;- with(warpbreaks, table(wool, tension))
Expand(T)
</code></pre>

<hr>
<h2 id='fplot'>fplot</h2><span id='topic+fplot'></span>

<h3>Description</h3>

<p>Faster plot via RGL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fplot(
  x,
  y,
  z = NULL,
  xlab,
  ylab,
  ...,
  z.col = topo.colors(64),
  data = parent.frame(),
  add = FALSE,
  aspect = c(1, 1),
  zoom = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fplot_+3A_x">x</code></td>
<td>
<p>X variable</p>
</td></tr>
<tr><td><code id="fplot_+3A_y">y</code></td>
<td>
<p>Y variable</p>
</td></tr>
<tr><td><code id="fplot_+3A_z">z</code></td>
<td>
<p>Z variable (optional)</p>
</td></tr>
<tr><td><code id="fplot_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="fplot_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="fplot_+3A_...">...</code></td>
<td>
<p>additional arggument to lower-level plot functions</p>
</td></tr>
<tr><td><code id="fplot_+3A_z.col">z.col</code></td>
<td>
<p>color (use argument alpha to set transparency)</p>
</td></tr>
<tr><td><code id="fplot_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="fplot_+3A_add">add</code></td>
<td>
<p>if TRUE use current active device</p>
</td></tr>
<tr><td><code id="fplot_+3A_aspect">aspect</code></td>
<td>
<p>aspect ratio</p>
</td></tr>
<tr><td><code id="fplot_+3A_zoom">zoom</code></td>
<td>
<p>zoom level</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
data(iris)
fplot(Sepal.Length ~ Petal.Length+Species, data=iris, size=2, type="s")
}
</code></pre>

<hr>
<h2 id='getMplus'>Read Mplus output</h2><span id='topic+getMplus'></span>

<h3>Description</h3>

<p>Read Mplus output files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMplus(infile = "template.out", coef = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMplus_+3A_infile">infile</code></td>
<td>
<p>Mplus output file</p>
</td></tr>
<tr><td><code id="getMplus_+3A_coef">coef</code></td>
<td>
<p>Coefficients only</p>
</td></tr>
<tr><td><code id="getMplus_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p>getSAS
</p>

<hr>
<h2 id='getSAS'>Read SAS output</h2><span id='topic+getSAS'></span>

<h3>Description</h3>

<p>Run SAS code like in the following:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSAS(infile, entry = "Parameter Estimates", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSAS_+3A_infile">infile</code></td>
<td>
<p>file (csv file generated by ODS)</p>
</td></tr>
<tr><td><code id="getSAS_+3A_entry">entry</code></td>
<td>
<p>Name of entry to capture</p>
</td></tr>
<tr><td><code id="getSAS_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ODS CSVALL BODY=&quot;myest.csv&quot;;
proc nlmixed data=aj qpoints=2 dampstep=0.5;
...
run;
ODS CSVALL Close;
</p>
<p>and read results into R with:
</p>
<p><code>getsas("myest.csv","Parameter Estimates")</code>
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p>getMplus
</p>

<hr>
<h2 id='gof'>Extract model summaries and GOF statistics for model object</h2><span id='topic+gof'></span><span id='topic+gof.lvmfit'></span><span id='topic+moments'></span><span id='topic+moments.lvm'></span><span id='topic+information'></span><span id='topic+information.lvmfit'></span><span id='topic+score'></span><span id='topic+score.lvmfit'></span><span id='topic+logLik.lvmfit'></span>

<h3>Description</h3>

<p>Calculates various GOF statistics for model object including global
chi-squared test statistic and AIC. Extract model-specific mean and variance
structure, residuals and various predicitions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, ...)

## S3 method for class 'lvmfit'
gof(object, chisq=FALSE, level=0.90, rmsea.threshold=0.05,all=FALSE,...)

moments(x,...)

## S3 method for class 'lvm'
moments(x, p, debug=FALSE, conditional=FALSE, data=NULL, latent=FALSE, ...)

## S3 method for class 'lvmfit'
logLik(object, p=coef(object),
                      data=model.frame(object),
                      model=object$estimator,
                      weights=Weights(object),
                      data2=object$data$data2,
                          ...)

## S3 method for class 'lvmfit'
score(x, data=model.frame(x), p=pars(x), model=x$estimator,
                   weights=Weights(x), data2=x$data$data2, ...)

## S3 method for class 'lvmfit'
information(x,p=pars(x),n=x$data$n,data=model.frame(x),
                   model=x$estimator,weights=Weights(x), data2=x$data$data2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="gof_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="gof_+3A_p">p</code></td>
<td>
<p>Parameter vector used to calculate statistics</p>
</td></tr>
<tr><td><code id="gof_+3A_data">data</code></td>
<td>
<p>Data.frame to use</p>
</td></tr>
<tr><td><code id="gof_+3A_latent">latent</code></td>
<td>
<p>If TRUE predictions of latent variables are included in output</p>
</td></tr>
<tr><td><code id="gof_+3A_data2">data2</code></td>
<td>
<p>Optional second data.frame (only for censored observations)</p>
</td></tr>
<tr><td><code id="gof_+3A_weights">weights</code></td>
<td>
<p>Optional weight matrix</p>
</td></tr>
<tr><td><code id="gof_+3A_n">n</code></td>
<td>
<p>Number of observations</p>
</td></tr>
<tr><td><code id="gof_+3A_conditional">conditional</code></td>
<td>
<p>If TRUE the conditional moments given the covariates are
calculated. Otherwise the joint moments are calculated</p>
</td></tr>
<tr><td><code id="gof_+3A_model">model</code></td>
<td>
<p>String defining estimator, e.g. &quot;gaussian&quot; (see
<code>estimate</code>)</p>
</td></tr>
<tr><td><code id="gof_+3A_debug">debug</code></td>
<td>
<p>Debugging only</p>
</td></tr>
<tr><td><code id="gof_+3A_chisq">chisq</code></td>
<td>
<p>Boolean indicating whether to calculate chi-squared
goodness-of-fit (always TRUE for estimator='gaussian')</p>
</td></tr>
<tr><td><code id="gof_+3A_level">level</code></td>
<td>
<p>Level of confidence limits for RMSEA</p>
</td></tr>
<tr><td><code id="gof_+3A_rmsea.threshold">rmsea.threshold</code></td>
<td>
<p>Which probability to calculate, Pr(RMSEA&lt;rmsea.treshold)</p>
</td></tr>
<tr><td><code id="gof_+3A_all">all</code></td>
<td>
<p>Calculate all (ad hoc) FIT indices: TLI, CFI, NFI, SRMR, ...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>htest</code>-object.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(list(y~v1+v2+v3+v4,c(v1,v2,v3,v4)~x))
set.seed(1)
dd &lt;- sim(m,1000)
e &lt;- estimate(m, dd)
gof(e,all=TRUE,rmsea.threshold=0.05,level=0.9)


set.seed(1)
m &lt;- lvm(list(c(y1,y2,y3)~u,y1~x)); latent(m) &lt;- ~u
regression(m,c(y2,y3)~u) &lt;- "b"
d &lt;- sim(m,1000)
e &lt;- estimate(m,d)
rsq(e)
##'
rr &lt;- rsq(e,TRUE)
rr
estimate(rr,contrast=rbind(c(1,-1,0),c(1,0,-1),c(0,1,-1)))

</code></pre>

<hr>
<h2 id='Graph'>Extract graph</h2><span id='topic+Graph'></span><span id='topic+Graph+3C-'></span>

<h3>Description</h3>

<p>Extract or replace graph object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Graph(x, ...)

Graph(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Graph_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="Graph_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="Graph_+3A_value">value</code></td>
<td>
<p>New <code>graphNEL</code> object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Model">Model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(y~x)
Graph(m)

</code></pre>

<hr>
<h2 id='Grep'>Finds elements in vector or column-names in data.frame/matrix</h2><span id='topic+Grep'></span>

<h3>Description</h3>

<p>Pattern matching in a vector or column names of a data.frame or matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Grep(x, pattern, subset = TRUE, ignore.case = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Grep_+3A_x">x</code></td>
<td>
<p>vector, matrix or data.frame.</p>
</td></tr>
<tr><td><code id="Grep_+3A_pattern">pattern</code></td>
<td>
<p>regular expression to search for</p>
</td></tr>
<tr><td><code id="Grep_+3A_subset">subset</code></td>
<td>
<p>If TRUE returns subset of data.frame/matrix otherwise just the matching column names</p>
</td></tr>
<tr><td><code id="Grep_+3A_ignore.case">ignore.case</code></td>
<td>
<p>Default ignore case</p>
</td></tr>
<tr><td><code id="Grep_+3A_...">...</code></td>
<td>
<p>Additional arguments to 'grep'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with 2 columns with the indices in the first and the
matching names in the second.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+grep">grep</a></code>, and <code><a href="base.html#topic+agrep">agrep</a></code> for approximate string
matching,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
head(Grep(iris,"(len)|(sp)"))
</code></pre>

<hr>
<h2 id='hubble'>Hubble data</h2><span id='topic+hubble'></span>

<h3>Description</h3>

<p>Velocity (v) and distance (D) measures of 36 Type Ia super-novae from the Hubble
Space Telescope
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Freedman, W. L., et al. 2001, AstroPhysicalJournal, 553, 47.
</p>

<hr>
<h2 id='hubble2'>Hubble data</h2><span id='topic+hubble2'></span>

<h3>Description</h3>

<p>Hubble data
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>See Also</h3>

<p>hubble
</p>

<hr>
<h2 id='IC'>Extract i.i.d. decomposition (influence function) from model object</h2><span id='topic+IC'></span><span id='topic+IC.default'></span><span id='topic+var_ic'></span>

<h3>Description</h3>

<p>Extract i.i.d. decomposition (influence function) from model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IC(x,...)

## Default S3 method:
IC(x, bread, id=NULL, folds=0, maxsize=(folds&gt;0)*1e6,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IC_+3A_x">x</code></td>
<td>
<p>model object</p>
</td></tr>
<tr><td><code id="IC_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="IC_+3A_id">id</code></td>
<td>
<p>(optional) id/cluster variable</p>
</td></tr>
<tr><td><code id="IC_+3A_bread">bread</code></td>
<td>
<p>(optional) Inverse of derivative of mean score function</p>
</td></tr>
<tr><td><code id="IC_+3A_folds">folds</code></td>
<td>
<p>(optional) Calculate aggregated iid decomposition (0:=disabled)</p>
</td></tr>
<tr><td><code id="IC_+3A_maxsize">maxsize</code></td>
<td>
<p>(optional) Data is split in groups of size up to 'maxsize' (0:=disabled)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y~x+z)
distribution(m, ~y+z) &lt;- binomial.lvm("logit")
d &lt;- sim(m,1e3)
g &lt;- glm(y~x+z,data=d,family=binomial)
var_ic(IC(g))

</code></pre>

<hr>
<h2 id='iid'>Extract i.i.d. decomposition from model object</h2><span id='topic+iid'></span>

<h3>Description</h3>

<p>This function extracts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iid(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iid_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="iid_+3A_...">...</code></td>
<td>
<p>Additional arguments (see the man-page of the IC method)</p>
</td></tr>
</table>

<hr>
<h2 id='images'>Organize several image calls (for visualizing categorical data)</h2><span id='topic+images'></span>

<h3>Description</h3>

<p>Visualize categorical by group variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>images(
  x,
  group,
  ncol = 2,
  byrow = TRUE,
  colorbar = 1,
  colorbar.space = 0.1,
  label.offset = 0.02,
  order = TRUE,
  colorbar.border = 0,
  main,
  rowcol = FALSE,
  plotfun = NULL,
  axis1,
  axis2,
  mar,
  col = list(c("#EFF3FF", "#BDD7E7", "#6BAED6", "#2171B5"), c("#FEE5D9", "#FCAE91",
    "#FB6A4A", "#CB181D"), c("#EDF8E9", "#BAE4B3", "#74C476", "#238B45"), c("#FEEDDE",
    "#FDBE85", "#FD8D3C", "#D94701")),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="images_+3A_x">x</code></td>
<td>
<p>data.frame or matrix</p>
</td></tr>
<tr><td><code id="images_+3A_group">group</code></td>
<td>
<p>group variable</p>
</td></tr>
<tr><td><code id="images_+3A_ncol">ncol</code></td>
<td>
<p>number of columns in layout</p>
</td></tr>
<tr><td><code id="images_+3A_byrow">byrow</code></td>
<td>
<p>organize by row if TRUE</p>
</td></tr>
<tr><td><code id="images_+3A_colorbar">colorbar</code></td>
<td>
<p>Add color bar</p>
</td></tr>
<tr><td><code id="images_+3A_colorbar.space">colorbar.space</code></td>
<td>
<p>Space around color bar</p>
</td></tr>
<tr><td><code id="images_+3A_label.offset">label.offset</code></td>
<td>
<p>label offset</p>
</td></tr>
<tr><td><code id="images_+3A_order">order</code></td>
<td>
<p>order</p>
</td></tr>
<tr><td><code id="images_+3A_colorbar.border">colorbar.border</code></td>
<td>
<p>Add border around color bar</p>
</td></tr>
<tr><td><code id="images_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="images_+3A_rowcol">rowcol</code></td>
<td>
<p>switch rows and columns</p>
</td></tr>
<tr><td><code id="images_+3A_plotfun">plotfun</code></td>
<td>
<p>Alternative plot function (instead of 'image')</p>
</td></tr>
<tr><td><code id="images_+3A_axis1">axis1</code></td>
<td>
<p>Axis 1</p>
</td></tr>
<tr><td><code id="images_+3A_axis2">axis2</code></td>
<td>
<p>Axis 2</p>
</td></tr>
<tr><td><code id="images_+3A_mar">mar</code></td>
<td>
<p>Margins</p>
</td></tr>
<tr><td><code id="images_+3A_col">col</code></td>
<td>
<p>Colours</p>
</td></tr>
<tr><td><code id="images_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level graphics functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(rbinom(400,3,0.5),20)
group &lt;- rep(1:4,each=5)
images(X,colorbar=0,zlim=c(0,3))
images(X,group=group,zlim=c(0,3))
## Not run: 
images(X,group=group,col=list(RColorBrewer::brewer.pal(4,"Purples"),
                               RColorBrewer::brewer.pal(4,"Greys"),
                               RColorBrewer::brewer.pal(4,"YlGn"),
                               RColorBrewer::brewer.pal(4,"PuBuGn")),colorbar=2,zlim=c(0,3))

## End(Not run)
images(list(X,X,X,X),group=group,zlim=c(0,3))
images(list(X,X,X,X),ncol=1,group=group,zlim=c(0,3))
images(list(X,X),group,axis2=c(FALSE,FALSE),axis1=c(FALSE,FALSE),
      mar=list(c(0,0,0,0),c(0,0,0,0)),yaxs="i",xaxs="i",zlim=c(0,3))
</code></pre>

<hr>
<h2 id='indoorenv'>Data</h2><span id='topic+indoorenv'></span>

<h3>Description</h3>

<p>Description
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='intercept'>Fix mean parameters in 'lvm'-object</h2><span id='topic+intercept'></span><span id='topic+intercept+3C-'></span><span id='topic+intercept.lvm'></span><span id='topic+intercept+3C-.lvm'></span><span id='topic+intfix'></span><span id='topic+intfix+3C-'></span><span id='topic+intfix.lvm'></span><span id='topic+intfix+3C-.lvm'></span>

<h3>Description</h3>

<p>Define linear constraints on intercept parameters in a <code>lvm</code>-object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 replacement method for class 'lvm'
intercept(object, vars, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intercept_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="intercept_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
<tr><td><code id="intercept_+3A_vars">vars</code></td>
<td>
<p>character vector of variable names</p>
</td></tr>
<tr><td><code id="intercept_+3A_value">value</code></td>
<td>
<p>Vector (or list) of parameter values or labels (numeric or
character) or a formula defining the linear constraints (see also the
<code>regression</code> or <code>covariance</code> methods).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>intercept</code> function is used to specify linear constraints on the
intercept parameters of a latent variable model. As an example we look at
the multivariate regression model
</p>
<p style="text-align: center;"><code class="reqn"> E(Y_1|X) = \alpha_1 + \beta_1 X</code>
</p>
 <p style="text-align: center;"><code class="reqn"> E(Y_2|X) = \alpha_2 + \beta_2
X</code>
</p>

<p>defined by the call
</p>
<p><code>m &lt;- lvm(c(y1,y2) ~ x)</code>
</p>
<p>To fix <code class="reqn">\alpha_1=\alpha_2</code> we call
</p>
<p><code>intercept(m) &lt;- c(y1,y2) ~ f(mu)</code>
</p>
<p>Fixed parameters can be reset by fixing them to <code>NA</code>.  For instance to
free the parameter restriction of <code class="reqn">Y_1</code> and at the same time fixing
<code class="reqn">\alpha_2=2</code>, we call
</p>
<p><code>intercept(m, ~y1+y2) &lt;- list(NA,2)</code>
</p>
<p>Calling <code>intercept</code> with no additional arguments will return the
current intercept restrictions of the <code>lvm</code>-object.
</p>


<h3>Value</h3>

<p>A <code>lvm</code>-object
</p>


<h3>Note</h3>

<p>Variables will be added to the model if not already present.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+covariance+3C-">covariance&lt;-</a></code>, <code><a href="#topic+regression+3C-">regression&lt;-</a></code>,
<code><a href="#topic+constrain+3C-">constrain&lt;-</a></code>, <code><a href="#topic+parameter+3C-">parameter&lt;-</a></code>,
<code><a href="#topic+latent+3C-">latent&lt;-</a></code>, <code><a href="#topic+cancel+3C-">cancel&lt;-</a></code>, <code><a href="#topic+kill+3C-">kill&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## A multivariate model
m &lt;- lvm(c(y1,y2) ~ f(x1,beta)+x2)
regression(m) &lt;- y3 ~ f(x1,beta)
intercept(m) &lt;- y1 ~ f(mu)
intercept(m, ~y2+y3) &lt;- list(2,"mu")
intercept(m) ## Examine intercepts of model (NA translates to free/unique paramete##r)


</code></pre>

<hr>
<h2 id='intervention.lvm'>Define intervention</h2><span id='topic+intervention.lvm'></span><span id='topic+intervention+3C-'></span><span id='topic+intervention'></span><span id='topic+intervention+3C-.lvm'></span>

<h3>Description</h3>

<p>Define intervention in a 'lvm' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
intervention(object, to, value, dist = none.lvm(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intervention.lvm_+3A_object">object</code></td>
<td>
<p>lvm object</p>
</td></tr>
<tr><td><code id="intervention.lvm_+3A_to">to</code></td>
<td>
<p>String defining variable or formula</p>
</td></tr>
<tr><td><code id="intervention.lvm_+3A_value">value</code></td>
<td>
<p>function defining intervention</p>
</td></tr>
<tr><td><code id="intervention.lvm_+3A_dist">dist</code></td>
<td>
<p>Distribution</p>
</td></tr>
<tr><td><code id="intervention.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>regression lvm sim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y ~ a + x, a ~ x)
distribution(m, ~a+y) &lt;- binomial.lvm()
mm &lt;- intervention(m, "a", value=3)
sim(mm, 10)
mm &lt;- intervention(m, a~x, function(x) (x&gt;0)*1)
sim(mm, 10)
</code></pre>

<hr>
<h2 id='ksmooth2'>Plot/estimate surface</h2><span id='topic+ksmooth2'></span><span id='topic+surface'></span>

<h3>Description</h3>

<p>Plot/estimate surface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksmooth2(
  x,
  data,
  h = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = "",
  gridsize = rep(51L, 2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksmooth2_+3A_x">x</code></td>
<td>
<p>formula or data</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_h">h</code></td>
<td>
<p>bandwidth</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_xlab">xlab</code></td>
<td>
<p>X label</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_ylab">ylab</code></td>
<td>
<p>Y label</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_zlab">zlab</code></td>
<td>
<p>Z label</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_gridsize">gridsize</code></td>
<td>
<p>grid size of kernel smoother</p>
</td></tr>
<tr><td><code id="ksmooth2_+3A_...">...</code></td>
<td>
<p>Additional arguments to graphics routine (persp3d or persp)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ksmooth2(rmvn0(1e4,sigma=diag(2)*.5+.5),c(-3.5,3.5),h=1,
        rgl=FALSE,theta=30)

if (interactive()) {
    ksmooth2(rmvn0(1e4,sigma=diag(2)*.5+.5),c(-3.5,3.5),h=1)
    ksmooth2(function(x,y) x^2+y^2, c(-20,20))
    ksmooth2(function(x,y) x^2+y^2, xlim=c(-5,5), ylim=c(0,10))

    f &lt;- function(x,y) 1-sqrt(x^2+y^2)
    surface(f,xlim=c(-1,1),alpha=0.9,aspect=c(1,1,0.75))
    surface(f,xlim=c(-1,1),clut=heat.colors(128))
    ##play3d(spin3d(axis=c(0,0,1), rpm=8), duration=5)
}

if (interactive()) {
    surface(function(x) dmvn0(x,sigma=diag(2)),c(-3,3),lit=FALSE,smooth=FALSE,box=FALSE,alpha=0.8)
    surface(function(x) dmvn0(x,sigma=diag(2)),c(-3,3),box=FALSE,specular="black")##'
}

if (!inherits(try(find.package("fields"),silent=TRUE),"try-error")) {
    f &lt;- function(x,y) 1-sqrt(x^2+y^2)
    ksmooth2(f,c(-1,1),rgl=FALSE,image=fields::image.plot)
}
</code></pre>

<hr>
<h2 id='labels+26lt+3B-'>Define labels of graph</h2><span id='topic+labels+3C-'></span><span id='topic+labels'></span><span id='topic+labels+3C-.default'></span><span id='topic+labels.lvm'></span><span id='topic+labels.lvmfit'></span><span id='topic+labels.graphNEL'></span><span id='topic+edgelabels'></span><span id='topic+edgelabels+3C-'></span><span id='topic+edgelabels+3C-.lvm'></span><span id='topic+nodecolor'></span><span id='topic+nodecolor+3C-'></span><span id='topic+nodecolor+3C-.default'></span>

<h3>Description</h3>

<p>Alters labels of nodes and edges in the graph of a latent variable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 replacement method:
labels(object, ...) &lt;- value
## S3 replacement method for class 'lvm'
edgelabels(object, to, ...) &lt;- value
## Default S3 replacement method:
nodecolor(object, var=vars(object),
border, labcol, shape, lwd, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Additional arguments (<code>lwd</code>, <code>cex</code>, <code>col</code>,
<code>labcol</code>), <code>border</code>.</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>node label/edge label/color</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_to">to</code></td>
<td>
<p>Formula specifying outcomes and predictors defining relevant
edges.</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_var">var</code></td>
<td>
<p>Formula or character vector specifying the nodes/variables to
alter.</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_border">border</code></td>
<td>
<p>Colors of borders</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_labcol">labcol</code></td>
<td>
<p>Text label colors</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_shape">shape</code></td>
<td>
<p>Shape of node</p>
</td></tr>
<tr><td><code id="labels+2B26lt+2B3B-_+3A_lwd">lwd</code></td>
<td>
<p>Line width of border</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(c(y,v)~x+z)
regression(m) &lt;- c(v,x)~z
labels(m) &lt;- c(y=expression(psi), z=expression(zeta))
nodecolor(m,~y+z+x,border=c("white","white","black"),
          labcol="white", lwd=c(1,1,5),
          lty=c(1,2)) &lt;-  c("orange","indianred","lightgreen")
edgelabels(m,y~z+x, cex=c(2,1.5), col=c("orange","black"),labcol="darkblue",
           arrowhead=c("tee","dot"),
           lwd=c(3,1)) &lt;- expression(phi,rho)
edgelabels(m,c(v,x)~z, labcol="red", cex=0.8,arrowhead="none") &lt;- 2
if (interactive()) {
    plot(m,addstyle=FALSE)
}

m &lt;- lvm(y~x)
labels(m) &lt;- list(x="multiple\nlines")
if (interactive()) {
op &lt;- par(mfrow=c(1,2))
plot(m,plain=TRUE)
plot(m)
par(op)

d &lt;- sim(m,100)
e &lt;- estimate(m,d)
plot(e,type="sd")
}
</code></pre>

<hr>
<h2 id='lava.options'>Set global options for <code>lava</code></h2><span id='topic+lava.options'></span>

<h3>Description</h3>

<p>Extract and set global parameters of <code>lava</code>. In particular optimization
parameters for the <code>estimate</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lava.options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lava.options_+3A_...">...</code></td>
<td>
<p>Arguments</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>param</code>: 'relative' (factor loading and variance of one
endogenous variables in each measurement model are fixed to one), 'absolute'
(mean and variance of latent variables are set to 0 and 1, respectively),
'hybrid' (intercept of latent variables is fixed to 0, and factor loading of
at least one endogenous variable in each measurement model is fixed to 1),
'none' (no constraints are added)
</p>
</li>
<li> <p><code>layout</code>: One of 'dot','fdp','circo','twopi','neato','osage'
</p>
</li>
<li> <p><code>messages</code>: Set to 0 to disable various output messages
</p>
</li>
<li><p> ...  </p>
</li></ul>

<p>see <code>control</code> parameter of the <code>estimate</code> function.
</p>


<h3>Value</h3>

<p><code>list</code> of parameters
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
lava.options(iter.max=100,messages=0)

## End(Not run)

</code></pre>

<hr>
<h2 id='lvm'>Initialize new latent variable model</h2><span id='topic+lvm'></span><span id='topic+print.lvm'></span><span id='topic+summary.lvm'></span>

<h3>Description</h3>

<p>Function that constructs a new latent variable model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvm(x = NULL, ..., latent = NULL, messages = lava.options()$messages)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lvm_+3A_x">x</code></td>
<td>
<p>Vector of variable names. Optional but gives control of the
sequence of appearance of the variables. The argument can be given as a
character vector or formula, e.g. <code>~y1+y2</code> is equivalent to
<code>c("y1","y2")</code>. Alternatively the argument can be a formula specifying
a linear model.</p>
</td></tr>
<tr><td><code id="lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="lvm_+3A_latent">latent</code></td>
<td>
<p>(optional) Latent variables</p>
</td></tr>
<tr><td><code id="lvm_+3A_messages">messages</code></td>
<td>
<p>Controls what messages are printed (0: none)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>lvm</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regression">regression</a></code>, <code><a href="#topic+covariance">covariance</a></code>,
<code><a href="#topic+intercept">intercept</a></code>, ...
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm() # Empty model
m1 &lt;- lvm(y~x) # Simple linear regression
m2 &lt;- lvm(~y1+y2) # Model with two independent variables (argument)
m3 &lt;- lvm(list(c(y1,y2,y3)~u,u~x+z)) # SEM with three items

</code></pre>

<hr>
<h2 id='makemissing'>Create random missing data</h2><span id='topic+makemissing'></span>

<h3>Description</h3>

<p>Generates missing entries in data.frame/matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makemissing(
  data,
  p = 0.2,
  cols = seq_len(ncol(data)),
  rowwise = FALSE,
  nafun = function(x) x,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makemissing_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="makemissing_+3A_p">p</code></td>
<td>
<p>Fraction of missing data in each column</p>
</td></tr>
<tr><td><code id="makemissing_+3A_cols">cols</code></td>
<td>
<p>Which columns (name or index) to alter</p>
</td></tr>
<tr><td><code id="makemissing_+3A_rowwise">rowwise</code></td>
<td>
<p>Should missing occur row-wise (either none or all selected columns are missing)</p>
</td></tr>
<tr><td><code id="makemissing_+3A_nafun">nafun</code></td>
<td>
<p>(Optional) function to be applied on data.frame before return (e.g. <code>na.omit</code> to return complete-cases only)</p>
</td></tr>
<tr><td><code id="makemissing_+3A_seed">seed</code></td>
<td>
<p>Random seed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='measurement.error'>Two-stage (non-linear) measurement error</h2><span id='topic+measurement.error'></span>

<h3>Description</h3>

<p>Two-stage measurement error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measurement.error(
  model1,
  formula,
  data = parent.frame(),
  predictfun = function(mu, var, data, ...) mu[, 1]^2 + var[1],
  id1,
  id2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurement.error_+3A_model1">model1</code></td>
<td>
<p>Stage 1 model</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_formula">formula</code></td>
<td>
<p>Formula specifying observed covariates in stage 2 model</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_predictfun">predictfun</code></td>
<td>
<p>Predictions to be used in stage 2</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_id1">id1</code></td>
<td>
<p>Optional id-vector of stage 1</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_id2">id2</code></td>
<td>
<p>Optional id-vector of stage 2</p>
</td></tr>
<tr><td><code id="measurement.error_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>stack.estimate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(c(y1,y2,y3)~u,c(y3,y4,y5)~v,u~~v,c(u,v)~x)
transform(m,u2~u) &lt;- function(x) x^2
transform(m,uv~u+v) &lt;- prod
regression(m) &lt;- z~u2+u+v+uv+x
set.seed(1)
d &lt;- sim(m,1000,p=c("u,u"=1))

## Stage 1
m1 &lt;- lvm(c(y1[0:s],y2[0:s],y3[0:s])~1*u,c(y3[0:s],y4[0:s],y5[0:s])~1*v,u~b*x,u~~v)
latent(m1) &lt;- ~u+v
e1 &lt;- estimate(m1,d)

pp &lt;- function(mu,var,data,...) {
    cbind(u=mu[,"u"],u2=mu[,"u"]^2+var["u","u"],v=mu[,"v"],uv=mu[,"u"]*mu[,"v"]+var["u","v"])
}
(e &lt;- measurement.error(e1, z~1+x, data=d, predictfun=pp))

## uu &lt;- seq(-1,1,length.out=100)
## pp &lt;- estimate(e,function(p,...) p["(Intercept)"]+p["u"]*uu+p["u2"]*uu^2)$coefmat
if (interactive()) {
    plot(e,intercept=TRUE,line=0)

    f &lt;- function(p) p[1]+p["u"]*u+p["u2"]*u^2
    u &lt;- seq(-1,1,length.out=100)
    plot(e, f, data=data.frame(u), ylim=c(-.5,2.5))
}
</code></pre>

<hr>
<h2 id='Missing'>Missing value generator</h2><span id='topic+Missing'></span><span id='topic+Missing+2C'></span><span id='topic+Missing+3C-'></span>

<h3>Description</h3>

<p>Missing value generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Missing(object, formula, Rformula, missing.name, suffix = "0", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Missing_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="Missing_+3A_formula">formula</code></td>
<td>
<p>The right hand side specifies the name of a latent
variable which is not always observed. The left hand side
specifies the name of a new variable which is equal to the latent
variable but has missing values.  If given as a string then this
is used as the name of the latent (full-data) name, and the
observed data name is 'missing.data'</p>
</td></tr>
<tr><td><code id="Missing_+3A_rformula">Rformula</code></td>
<td>
<p>Missing data mechanism with left hand side
specifying the name of the observed data indicator (may also just
be given as a character instead of a formula)</p>
</td></tr>
<tr><td><code id="Missing_+3A_missing.name">missing.name</code></td>
<td>
<p>Name of observed data variable (only used if
'formula' was given as a character specifying the name of the
full-data variable)</p>
</td></tr>
<tr><td><code id="Missing_+3A_suffix">suffix</code></td>
<td>
<p>If missing.name is missing, then the name of the
oberved data variable will be the name of the full-data variable +
the suffix</p>
</td></tr>
<tr><td><code id="Missing_+3A_...">...</code></td>
<td>
<p>Passed to binomial.lvm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function adds a binary variable to a given <code>lvm</code> model
and also a variable which is equal to the original variable where
the binary variable is equal to zero
</p>


<h3>Value</h3>

<p>lvm object
</p>


<h3>Author(s)</h3>

<p>Thomas A. Gerds &lt;tag@biostat.ku.dk&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(lava)
set.seed(17)
m &lt;- lvm(y0~x01+x02+x03)
m &lt;- Missing(m,formula=x1~x01,Rformula=R1~0.3*x02+-0.7*x01,p=0.4)
sim(m,10)


m &lt;- lvm(y~1)
m &lt;- Missing(m,"y","r")
## same as
## m &lt;- Missing(m,y~1,r~1)
sim(m,10)

## same as
m &lt;- lvm(y~1)
Missing(m,"y") &lt;- r~x
sim(m,10)

m &lt;- lvm(y~1)
m &lt;- Missing(m,"y","r",suffix=".")
## same as
## m &lt;- Missing(m,"y","r",missing.name="y.")
## same as
## m &lt;- Missing(m,y.~y,"r")
sim(m,10)

</code></pre>

<hr>
<h2 id='missingdata'>Missing data example</h2><span id='topic+missingdata'></span>

<h3>Description</h3>

<p>Simulated data generated from model
</p>
<p style="text-align: center;"><code class="reqn">E(Y_i\mid X) = X, \quad cov(Y_1,Y_2\mid X)=0.5</code>
</p>



<h3>Format</h3>

<p>list of data.frames
</p>


<h3>Details</h3>

<p>The list contains four data sets
1) Complete data
2) MCAR
3) MAR
4) MNAR (missing mechanism depends on variable V correlated with Y1,Y2)
</p>


<h3>Source</h3>

<p>Simulated
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(missingdata)
e0 &lt;- estimate(lvm(c(y1,y2)~b*x,y1~~y2),missingdata[[1]]) ## No missing
e1 &lt;- estimate(lvm(c(y1,y2)~b*x,y1~~y2),missingdata[[2]]) ## CC (MCAR)
e2 &lt;- estimate(lvm(c(y1,y2)~b*x,y1~~y2),missingdata[[2]],missing=TRUE) ## MCAR
e3 &lt;- estimate(lvm(c(y1,y2)~b*x,y1~~y2),missingdata[[3]]) ## CC (MAR)
e4 &lt;- estimate(lvm(c(y1,y2)~b*x,y1~~y2),missingdata[[3]],missing=TRUE) ## MAR
</code></pre>

<hr>
<h2 id='mixture'>Estimate mixture latent variable model.</h2><span id='topic+mixture'></span>

<h3>Description</h3>

<p>Estimate mixture latent variable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mixture(
  x,
  data,
  k = length(x),
  control = list(),
  vcov = "observed",
  names = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mixture_+3A_x">x</code></td>
<td>
<p>List of <code>lvm</code> objects. If only a single <code>lvm</code> object is
given, then a <code>k</code>-mixture of this model is fitted (free parameters
varying between mixture components).</p>
</td></tr>
<tr><td><code id="mixture_+3A_data">data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="mixture_+3A_k">k</code></td>
<td>
<p>Number of mixture components</p>
</td></tr>
<tr><td><code id="mixture_+3A_control">control</code></td>
<td>
<p>Optimization parameters (see details)
#type Type of EM algorithm (standard, classification, stochastic)</p>
</td></tr>
<tr><td><code id="mixture_+3A_vcov">vcov</code></td>
<td>
<p>of asymptotic covariance matrix (NULL to omit)</p>
</td></tr>
<tr><td><code id="mixture_+3A_names">names</code></td>
<td>
<p>If TRUE returns the names of the parameters (for defining starting values)</p>
</td></tr>
<tr><td><code id="mixture_+3A_...">...</code></td>
<td>
<p>Additional arguments parsed to lower-level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate parameters in a mixture of latent variable models via the EM
algorithm.
</p>
<p>The performance of the EM algorithm can be tuned via the <code>control</code>
argument, a list where a subset of the following members can be altered:
</p>
 <dl>
<dt>start</dt><dd><p>Optional starting values</p>
</dd> <dt>nstart</dt><dd><p>Evaluate
<code>nstart</code> different starting values and run the EM-algorithm on the
parameters with largest likelihood</p>
</dd> <dt>tol</dt><dd><p>Convergence tolerance of the
EM-algorithm.  The algorithm is stopped when the absolute change in
likelihood and parameter (2-norm) between successive iterations is less than
<code>tol</code></p>
</dd> <dt>iter.max</dt><dd><p>Maximum number of iterations of the
EM-algorithm</p>
</dd> <dt>gamma</dt><dd><p>Scale-down (i.e. number between 0 and 1) of the
step-size of the Newton-Raphson algorithm in the M-step</p>
</dd> <dt>trace</dt><dd><p>Trace
information on the EM-algorithm is printed on every <code>trace</code>th
iteration</p>
</dd> </dl>

<p>Note that the algorithm can be aborted any time (C-c) and still be saved
(via on.exit call).
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>mvnmix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

m0 &lt;- lvm(list(y~x+z,x~z))
distribution(m0,~z) &lt;- binomial.lvm()
d &lt;- sim(m0,2000,p=c("y~z"=2,"y~x"=1),seed=1)

## unmeasured confounder example
m &lt;- baptize(lvm(y~x, x~1));
intercept(m,~x+y) &lt;- NA

if (requireNamespace('mets', quietly=TRUE)) {
  set.seed(42)
  M &lt;- mixture(m,k=2,data=d,control=list(trace=1,tol=1e-6))
  summary(M)
  lm(y~x,d)
  estimate(M,"y~x")
  ## True slope := 1
}


</code></pre>

<hr>
<h2 id='Model'>Extract model</h2><span id='topic+Model'></span><span id='topic+Model+3C-'></span>

<h3>Description</h3>

<p>Extract or replace model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Model(x, ...)

Model(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Model_+3A_x">x</code></td>
<td>
<p>Fitted model</p>
</td></tr>
<tr><td><code id="Model_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="Model_+3A_value">value</code></td>
<td>
<p>New model object (e.g. <code>lvm</code> or <code>multigroup</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a model object (e.g. <code>lvm</code> or <code>multigroup</code>)
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Graph">Graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(y~x)
e &lt;- estimate(m, sim(m,100))
Model(e)

</code></pre>

<hr>
<h2 id='modelsearch'>Model searching</h2><span id='topic+modelsearch'></span>

<h3>Description</h3>

<p>Performs Wald or score tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelsearch(x, k = 1, dir = "forward", type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelsearch_+3A_x">x</code></td>
<td>
<p><code>lvmfit</code>-object</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_k">k</code></td>
<td>
<p>Number of parameters to test simultaneously. For <code>equivalence</code>
the number of additional associations to be added instead of <code>rel</code>.</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_dir">dir</code></td>
<td>
<p>Direction to do model search. &quot;forward&quot; := add
associations/arrows to model/graph (score tests), &quot;backward&quot; := remove
associations/arrows from model/graph (wald test)</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_type">type</code></td>
<td>
<p>If equal to 'correlation' only consider score tests for covariance parameters. If equal to 'regression' go through direct effects only  (default 'all' is to do both)</p>
</td></tr>
<tr><td><code id="modelsearch_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of test-statistics and p-values
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compare">compare</a></code>, <code><a href="#topic+equivalence">equivalence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm();
regression(m) &lt;- c(y1,y2,y3) ~ eta; latent(m) &lt;- ~eta
regression(m) &lt;- eta ~ x
m0 &lt;- m; regression(m0) &lt;- y2 ~ x
dd &lt;- sim(m0,100)[,manifest(m0)]
e &lt;- estimate(m,dd);
modelsearch(e,messages=0)
modelsearch(e,messages=0,type="cor")
</code></pre>

<hr>
<h2 id='multinomial'>Estimate probabilities in contingency table</h2><span id='topic+multinomial'></span><span id='topic+kappa.multinomial'></span><span id='topic+kappa.table'></span><span id='topic+gkgamma'></span>

<h3>Description</h3>

<p>Estimate probabilities in contingency table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial(
  x,
  data = parent.frame(),
  marginal = FALSE,
  transform,
  vcov = TRUE,
  IC = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomial_+3A_x">x</code></td>
<td>
<p>Formula (or matrix or data.frame with observations, 1 or 2 columns)</p>
</td></tr>
<tr><td><code id="multinomial_+3A_data">data</code></td>
<td>
<p>Optional data.frame</p>
</td></tr>
<tr><td><code id="multinomial_+3A_marginal">marginal</code></td>
<td>
<p>If TRUE the marginals are estimated</p>
</td></tr>
<tr><td><code id="multinomial_+3A_transform">transform</code></td>
<td>
<p>Optional transformation of parameters (e.g., logit)</p>
</td></tr>
<tr><td><code id="multinomial_+3A_vcov">vcov</code></td>
<td>
<p>Calculate asymptotic variance (default TRUE)</p>
</td></tr>
<tr><td><code id="multinomial_+3A_ic">IC</code></td>
<td>
<p>Return ic decomposition (default TRUE)</p>
</td></tr>
<tr><td><code id="multinomial_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower-level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
breaks &lt;- c(-Inf,-1,0,Inf)
m &lt;- lvm(); covariance(m,pairwise=TRUE) &lt;- ~y1+y2+y3+y4
d &lt;- transform(sim(m,5e2),
              z1=cut(y1,breaks=breaks),
              z2=cut(y2,breaks=breaks),
              z3=cut(y3,breaks=breaks),
              z4=cut(y4,breaks=breaks))

multinomial(d[,5])
(a1 &lt;- multinomial(d[,5:6]))
(K1 &lt;- kappa(a1)) ## Cohen's kappa

K2 &lt;- kappa(d[,7:8])
## Testing difference K1-K2:
estimate(merge(K1,K2,id=TRUE),diff)

estimate(merge(K1,K2,id=FALSE),diff) ## Wrong std.err ignoring dependence
sqrt(vcov(K1)+vcov(K2))

## Average of the two kappas:
estimate(merge(K1,K2,id=TRUE),function(x) mean(x))
estimate(merge(K1,K2,id=FALSE),function(x) mean(x)) ## Independence
##'
## Goodman-Kruskal's gamma
m2 &lt;- lvm(); covariance(m2) &lt;- y1~y2
breaks1 &lt;- c(-Inf,-1,0,Inf)
breaks2 &lt;- c(-Inf,0,Inf)
d2 &lt;- transform(sim(m2,5e2),
              z1=cut(y1,breaks=breaks1),
              z2=cut(y2,breaks=breaks2))

(g1 &lt;- gkgamma(d2[,3:4]))
## same as
## Not run: 
gkgamma(table(d2[,3:4]))
gkgamma(multinomial(d2[,3:4]))

## End(Not run)

##partial gamma
d2$x &lt;- rbinom(nrow(d2),2,0.5)
gkgamma(z1~z2|x,data=d2)
</code></pre>

<hr>
<h2 id='mvnmix'>Estimate mixture latent variable model</h2><span id='topic+mvnmix'></span>

<h3>Description</h3>

<p>Estimate mixture latent variable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnmix(
  data,
  k = 2,
  theta,
  steps = 500,
  tol = 1e-16,
  lambda = 0,
  mu = NULL,
  silent = TRUE,
  extra = FALSE,
  n.start = 1,
  init = "kmpp",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvnmix_+3A_data">data</code></td>
<td>
<p><code>data.frame</code></p>
</td></tr>
<tr><td><code id="mvnmix_+3A_k">k</code></td>
<td>
<p>Number of mixture components</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_theta">theta</code></td>
<td>
<p>Optional starting values</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_steps">steps</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_tol">tol</code></td>
<td>
<p>Convergence tolerance of EM algorithm</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_lambda">lambda</code></td>
<td>
<p>Regularisation parameter. Added to diagonal of covariance matrix (to avoid
singularities)</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_mu">mu</code></td>
<td>
<p>Initial centres (if unspecified random centres will be chosen)</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_silent">silent</code></td>
<td>
<p>Turn on/off output messages</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_extra">extra</code></td>
<td>
<p>Extra debug information</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_n.start">n.start</code></td>
<td>
<p>Number of restarts</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_init">init</code></td>
<td>
<p>Function to choose initial centres</p>
</td></tr>
<tr><td><code id="mvnmix_+3A_...">...</code></td>
<td>
<p>Additional arguments parsed to lower-level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimate parameters in a mixture of latent variable models via the EM
algorithm.
</p>


<h3>Value</h3>

<p>A <code>mixture</code> object
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>mixture</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(faithful)
set.seed(1)
M1 &lt;- mvnmix(faithful[,"waiting",drop=FALSE],k=2)
M2 &lt;- mvnmix(faithful,k=2)
if (interactive()) {
    par(mfrow=c(2,1))
    plot(M1,col=c("orange","blue"),ylim=c(0,0.05))
    plot(M2,col=c("orange","blue"))
}

</code></pre>

<hr>
<h2 id='NA2x'>Convert to/from NA</h2><span id='topic+NA2x'></span><span id='topic+x2NA'></span>

<h3>Description</h3>

<p>Convert vector to/from NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NA2x(s, x = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NA2x_+3A_s">s</code></td>
<td>
<p>The input vector (of arbitrary class)</p>
</td></tr>
<tr><td><code id="NA2x_+3A_x">x</code></td>
<td>
<p>The elements to transform into <code>NA</code> resp. what to transform
<code>NA</code> into.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with same dimension and class as <code>s</code>.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##' 
x2NA(1:10, 1:5)
NA2x(x2NA(c(1:10),5),5)##'
</code></pre>

<hr>
<h2 id='nldata'>Example data (nonlinear model)</h2><span id='topic+nldata'></span>

<h3>Description</h3>

<p>Example data (nonlinear model)
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='NR'>Newton-Raphson method</h2><span id='topic+NR'></span>

<h3>Description</h3>

<p>Newton-Raphson method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NR(
  start,
  objective = NULL,
  gradient = NULL,
  hessian = NULL,
  control,
  args = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NR_+3A_start">start</code></td>
<td>
<p>Starting value</p>
</td></tr>
<tr><td><code id="NR_+3A_objective">objective</code></td>
<td>
<p>Optional objective function (used for selecting step length)</p>
</td></tr>
<tr><td><code id="NR_+3A_gradient">gradient</code></td>
<td>
<p>gradient</p>
</td></tr>
<tr><td><code id="NR_+3A_hessian">hessian</code></td>
<td>
<p>hessian (if NULL a numerical derivative is used)</p>
</td></tr>
<tr><td><code id="NR_+3A_control">control</code></td>
<td>
<p>optimization arguments (see details)</p>
</td></tr>
<tr><td><code id="NR_+3A_args">args</code></td>
<td>
<p>Optional list of arguments parsed to objective, gradient and hessian</p>
</td></tr>
<tr><td><code id="NR_+3A_...">...</code></td>
<td>
<p>additional arguments parsed to lower level functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>control</code> should be a list with one or more of the following components:
</p>

<ul>
<li><p>trace integer for which output is printed each 'trace'th iteration
</p>
</li>
<li><p>iter.max number of iterations
</p>
</li>
<li><p>stepsize: Step size (default 1)
</p>
</li>
<li><p>nstepsize: Increase stepsize every nstepsize iteration (from stepsize to 1)
</p>
</li>
<li><p>tol: Convergence criterion (gradient)
</p>
</li>
<li><p>epsilon: threshold used in pseudo-inverse
</p>
</li>
<li><p>backtrack: In each iteration reduce stepsize unless solution is improved according to criterion (gradient, armijo, curvature, wolfe)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Objective function with gradient and hessian as attributes
f &lt;- function(z) {
   x &lt;- z[1]; y &lt;- z[2]
   val &lt;- x^2 + x*y^2 + x + y
   structure(val, gradient=c(2*x+y^2+1, 2*y*x+1),
             hessian=rbind(c(2,2*y),c(2*y,2*x)))
}
NR(c(0,0),f)

# Parsing arguments to the function and
g &lt;- function(x,y) (x*y+1)^2
NR(0, gradient=g, args=list(y=2), control=list(trace=1,tol=1e-20))


</code></pre>

<hr>
<h2 id='nsem'>Example SEM data (nonlinear)</h2><span id='topic+nsem'></span>

<h3>Description</h3>

<p>Simulated data
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='ordinal+26lt+3B-'>Define variables as ordinal</h2><span id='topic+ordinal+3C-'></span><span id='topic+ordinal'></span>

<h3>Description</h3>

<p>Define variables as ordinal in latent variable model object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordinal+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>Object</p>
</td></tr>
<tr><td><code id="ordinal+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="ordinal+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>variable (formula or character vector)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("mets")) {
m &lt;- lvm(y + z ~ x + 1*u[0], latent=~u)
ordinal(m, K=3) &lt;- ~y+z
d &lt;- sim(m, 100, seed=1)
e &lt;- estimate(m, d)
}

</code></pre>

<hr>
<h2 id='ordreg'>Univariate cumulative link regression models</h2><span id='topic+ordreg'></span>

<h3>Description</h3>

<p>Ordinal regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordreg(
  formula,
  data = parent.frame(),
  offset,
  family = stats::binomial("probit"),
  start,
  fast = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ordreg_+3A_formula">formula</code></td>
<td>
<p>formula</p>
</td></tr>
<tr><td><code id="ordreg_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="ordreg_+3A_offset">offset</code></td>
<td>
<p>offset</p>
</td></tr>
<tr><td><code id="ordreg_+3A_family">family</code></td>
<td>
<p>family (default proportional odds)</p>
</td></tr>
<tr><td><code id="ordreg_+3A_start">start</code></td>
<td>
<p>optional starting values</p>
</td></tr>
<tr><td><code id="ordreg_+3A_fast">fast</code></td>
<td>
<p>If TRUE standard errors etc. will not be calculated</p>
</td></tr>
<tr><td><code id="ordreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y~x)
ordinal(m,K=3) &lt;- ~y
d &lt;- sim(m,100)
e &lt;- ordreg(y~x,d)
</code></pre>

<hr>
<h2 id='parpos'>Generic method for finding indeces of model parameters</h2><span id='topic+parpos'></span>

<h3>Description</h3>

<p>Generic method for finding indeces of model parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parpos(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parpos_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="parpos_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='partialcor'>Calculate partial correlations</h2><span id='topic+partialcor'></span>

<h3>Description</h3>

<p>Calculate partial correlation coefficients and confidence limits via Fishers
z-transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialcor(formula, data, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialcor_+3A_formula">formula</code></td>
<td>
<p>formula speciying the covariates and optionally the outcomes
to calculate partial correlation for</p>
</td></tr>
<tr><td><code id="partialcor_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="partialcor_+3A_level">level</code></td>
<td>
<p>Level of confidence limits</p>
</td></tr>
<tr><td><code id="partialcor_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A coefficient matrix
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(c(y1,y2,y3)~x1+x2)
covariance(m) &lt;- c(y1,y2,y3)~y1+y2+y3
d &lt;- sim(m,500)
partialcor(~x1+x2,d)

</code></pre>

<hr>
<h2 id='path'>Extract pathways in model graph</h2><span id='topic+path'></span><span id='topic+effects'></span><span id='topic+path.lvm'></span><span id='topic+effects.lvmfit'></span><span id='topic+totaleffects'></span>

<h3>Description</h3>

<p>Extract all possible paths from one variable to another connected component
in a latent variable model. In an estimated model the effect size is
decomposed into direct, indirect and total effects including approximate
standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
 path(object, to = NULL, from, all=FALSE, ...)
## S3 method for class 'lvmfit'
 effects(object, to, from, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_object">object</code></td>
<td>
<p>Model object (<code>lvm</code>)</p>
</td></tr>
<tr><td><code id="path_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="path_+3A_to">to</code></td>
<td>
<p>Outcome variable (string). Alternatively a formula specifying
response and predictor in which case the argument <code>from</code> is ignored.</p>
</td></tr>
<tr><td><code id="path_+3A_from">from</code></td>
<td>
<p>Response variable (string), not necessarily directly affected by
<code>to</code>.</p>
</td></tr>
<tr><td><code id="path_+3A_all">all</code></td>
<td>
<p>If TRUE all simple paths (in undirected graph) is returned
on/off.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>object</code> is of class <code>lvmfit</code> a list with the following
elements is returned </p>
<table>
<tr><td><code>idx</code></td>
<td>
<p> A list where each element defines a
possible pathway via a integer vector indicating the index of the visited
nodes. </p>
</td></tr> <tr><td><code>V</code></td>
<td>
<p> A List of covariance matrices for each path. </p>
</td></tr>
<tr><td><code>coef</code></td>
<td>
<p>A list of parameters estimates for each path</p>
</td></tr> <tr><td><code>path</code></td>
<td>
<p>A
list where each element defines a possible pathway via a character vector
naming the visited nodes in order.  </p>
</td></tr> <tr><td><code>edges</code></td>
<td>
<p>Description of 'comp2'</p>
</td></tr>
</table>
<p>If <code>object</code> is of class <code>lvm</code> only the <code>path</code> element will be
returned.
</p>
<p>The <code>effects</code> method returns an object of class <code>effects</code>.
</p>


<h3>Note</h3>

<p>For a <code>lvmfit</code>-object the parameters estimates and their
corresponding covariance matrix are also returned.  The
<code>effects</code>-function additionally calculates the total and indirect
effects with approximate standard errors
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>children</code>, <code>parents</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(c(y1,y2,y3)~eta)
regression(m) &lt;- y2~x1
latent(m) &lt;- ~eta
regression(m) &lt;- eta~x1+x2
d &lt;- sim(m,500)
e &lt;- estimate(m,d)

path(Model(e),y2~x1)
parents(Model(e), ~y2)
children(Model(e), ~x2)
children(Model(e), ~x2+eta)
effects(e,y2~x1)
## All simple paths (undirected)
path(m,y1~x1,all=TRUE)

</code></pre>

<hr>
<h2 id='pcor'>Polychoric correlation</h2><span id='topic+pcor'></span>

<h3>Description</h3>

<p>Maximum likelhood estimates of polychoric correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcor(x, y, X, start, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcor_+3A_x">x</code></td>
<td>
<p>Variable 1</p>
</td></tr>
<tr><td><code id="pcor_+3A_y">y</code></td>
<td>
<p>Variable 2</p>
</td></tr>
<tr><td><code id="pcor_+3A_x">X</code></td>
<td>
<p>Optional covariates</p>
</td></tr>
<tr><td><code id="pcor_+3A_start">start</code></td>
<td>
<p>Optional starting values</p>
</td></tr>
<tr><td><code id="pcor_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>

<hr>
<h2 id='PD'>Dose response calculation for binomial regression models</h2><span id='topic+PD'></span>

<h3>Description</h3>

<p>Dose response calculation for binomial regression models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PD(
  model,
  intercept = 1,
  slope = 2,
  prob = NULL,
  x,
  level = 0.5,
  ci.level = 0.95,
  vcov,
  family,
  EB = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PD_+3A_model">model</code></td>
<td>
<p>Model object or vector of parameter estimates</p>
</td></tr>
<tr><td><code id="PD_+3A_intercept">intercept</code></td>
<td>
<p>Index of intercept parameters</p>
</td></tr>
<tr><td><code id="PD_+3A_slope">slope</code></td>
<td>
<p>Index of intercept parameters</p>
</td></tr>
<tr><td><code id="PD_+3A_prob">prob</code></td>
<td>
<p>Index of mixture parameters (only relevant for
<code>zibreg</code> models)</p>
</td></tr>
<tr><td><code id="PD_+3A_x">x</code></td>
<td>
<p>Optional weights
length(x)=length(intercept)+length(slope)+length(prob)</p>
</td></tr>
<tr><td><code id="PD_+3A_level">level</code></td>
<td>
<p>Probability at which level to calculate dose</p>
</td></tr>
<tr><td><code id="PD_+3A_ci.level">ci.level</code></td>
<td>
<p>Level of confidence limits</p>
</td></tr>
<tr><td><code id="PD_+3A_vcov">vcov</code></td>
<td>
<p>Optional estimate of variance matrix of parameter
estimates</p>
</td></tr>
<tr><td><code id="PD_+3A_family">family</code></td>
<td>
<p>Optional distributional family argument</p>
</td></tr>
<tr><td><code id="PD_+3A_eb">EB</code></td>
<td>
<p>Optional ratio of treatment effect and adverse effects
used to find optimal dose (regret-function argument)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='pdfconvert'>Convert pdf to raster format</h2><span id='topic+pdfconvert'></span>

<h3>Description</h3>

<p>Convert PDF file to print quality png (default 300 dpi)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdfconvert(
  files,
  dpi = 300,
  resolution = 1024,
  gs,
  gsopt,
  resize,
  format = "png",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdfconvert_+3A_files">files</code></td>
<td>
<p>Vector of (pdf-)filenames to process</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_dpi">dpi</code></td>
<td>
<p>DPI</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_resolution">resolution</code></td>
<td>
<p>Resolution of raster image file</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_gs">gs</code></td>
<td>
<p>Optional ghostscript command</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_gsopt">gsopt</code></td>
<td>
<p>Optional ghostscript arguments</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_resize">resize</code></td>
<td>
<p>Optional resize arguments (mogrify)</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_format">format</code></td>
<td>
<p>Raster format (e.g. png, jpg, tif, ...)</p>
</td></tr>
<tr><td><code id="pdfconvert_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Access to ghostscript program 'gs' is needed
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>dev.copy2pdf</code>, <code>printdev</code>
</p>

<hr>
<h2 id='plot.estimate'>Plot method for 'estimate' objects</h2><span id='topic+plot.estimate'></span>

<h3>Description</h3>

<p>Plot method for 'estimate' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate'
plot(
  x,
  f,
  idx,
  intercept = FALSE,
  data,
  confint = TRUE,
  type = "l",
  xlab = "x",
  ylab = "f(x)",
  col = 1,
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.estimate_+3A_x">x</code></td>
<td>
<p>estimate object</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_f">f</code></td>
<td>
<p>function of parameter coefficients and data parsed on to 'estimate'.
If omitted a forest-plot will be produced.</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_idx">idx</code></td>
<td>
<p>Index of parameters (default all)</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_intercept">intercept</code></td>
<td>
<p>include intercept in forest-plot</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_confint">confint</code></td>
<td>
<p>Add confidence limits</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_type">type</code></td>
<td>
<p>plot type ('l')</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_add">add</code></td>
<td>
<p>add plot to current device</p>
</td></tr>
<tr><td><code id="plot.estimate_+3A_...">...</code></td>
<td>
<p>additional arguments to lower-level functions</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lvm'>Plot path diagram</h2><span id='topic+plot.lvm'></span><span id='topic+plot.lvmfit'></span>

<h3>Description</h3>

<p>Plot the path diagram of a SEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
plot(
  x,
  diag = FALSE,
  cor = TRUE,
  labels = FALSE,
  intercept = FALSE,
  addcolor = TRUE,
  plain = FALSE,
  cex,
  fontsize1 = 10,
  noplot = FALSE,
  graph = list(rankdir = "BT"),
  attrs = list(graph = graph),
  unexpr = FALSE,
  addstyle = TRUE,
  plot.engine = lava.options()$plot.engine,
  init = TRUE,
  layout = lava.options()$layout,
  edgecolor = lava.options()$edgecolor,
  graph.proc = lava.options()$graph.proc,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lvm_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_diag">diag</code></td>
<td>
<p>Logical argument indicating whether to visualize
variance parameters (i.e. diagonal of variance matrix)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_cor">cor</code></td>
<td>
<p>Logical argument indicating whether to visualize
correlation parameters</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_labels">labels</code></td>
<td>
<p>Logical argument indiciating whether to add labels
to plot (Unnamed parameters will be labeled p1,p2,...)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_intercept">intercept</code></td>
<td>
<p>Logical argument indiciating whether to add
intercept labels</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_addcolor">addcolor</code></td>
<td>
<p>Logical argument indiciating whether to add colors
to plot (overrides <code>nodecolor</code> calls)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_plain">plain</code></td>
<td>
<p>if TRUE strip plot of colors and boxes</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_cex">cex</code></td>
<td>
<p>Fontsize of node labels</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_fontsize1">fontsize1</code></td>
<td>
<p>Fontsize of edge labels</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_noplot">noplot</code></td>
<td>
<p>if TRUE then return <code>graphNEL</code> object only</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_graph">graph</code></td>
<td>
<p>Graph attributes (Rgraphviz)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_attrs">attrs</code></td>
<td>
<p>Attributes (Rgraphviz)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_unexpr">unexpr</code></td>
<td>
<p>if TRUE remove expressions from labels</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_addstyle">addstyle</code></td>
<td>
<p>Logical argument indicating whether additional
style should automatically be added to the plot (e.g. dashed
lines to double-headed arrows)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_plot.engine">plot.engine</code></td>
<td>
<p>default 'Rgraphviz' if available, otherwise
visNetwork,igraph</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_init">init</code></td>
<td>
<p>Reinitialize graph (for internal use)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_layout">layout</code></td>
<td>
<p>Graph layout (see Rgraphviz or igraph manual)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_edgecolor">edgecolor</code></td>
<td>
<p>if TRUE plot style with colored edges</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_graph.proc">graph.proc</code></td>
<td>
<p>Function that post-process the graph object
(default: subscripts are automatically added to labels of the
nodes)</p>
</td></tr>
<tr><td><code id="plot.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level
functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
m &lt;- lvm(c(y1,y2) ~ eta)
regression(m) &lt;- eta ~ z+x2
regression(m) &lt;- c(eta,z) ~ x1
latent(m) &lt;- ~eta
labels(m) &lt;- c(y1=expression(y[scriptscriptstyle(1)]),
y2=expression(y[scriptscriptstyle(2)]),
x1=expression(x[scriptscriptstyle(1)]),
x2=expression(x[scriptscriptstyle(2)]),
eta=expression(eta))
edgelabels(m, eta ~ z+x1+x2, cex=2, lwd=3,
           col=c("orange","lightblue","lightblue")) &lt;- expression(rho,phi,psi)
nodecolor(m, vars(m), border="white", labcol="darkblue") &lt;- NA
nodecolor(m, ~y1+y2+z, labcol=c("white","white","black")) &lt;- NA
plot(m,cex=1.5)

d &lt;- sim(m,100)
e &lt;- estimate(m,d)
plot(e)

m &lt;- lvm(c(y1,y2) ~ eta)
regression(m) &lt;- eta ~ z+x2
regression(m) &lt;- c(eta,z) ~ x1
latent(m) &lt;- ~eta
plot(lava:::beautify(m,edgecol=FALSE))
}
</code></pre>

<hr>
<h2 id='plot.sim'>Plot method for simulation 'sim' objects</h2><span id='topic+plot.sim'></span><span id='topic+density.sim'></span>

<h3>Description</h3>

<p>Density and scatter plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
plot(
  x,
  estimate,
  se = NULL,
  true = NULL,
  names = NULL,
  auto.layout = TRUE,
  byrow = FALSE,
  type = "p",
  ask = grDevices::dev.interactive(),
  col = c("gray60", "orange", "darkblue", "seagreen", "darkred"),
  pch = 16,
  cex = 0.5,
  lty = 1,
  lwd = 0.3,
  legend,
  legendpos = "topleft",
  cex.legend = 0.8,
  plot.type = c("multiple", "single"),
  polygon = TRUE,
  density = 0,
  angle = -45,
  cex.axis = 0.8,
  alpha = 0.2,
  main,
  cex.main = 1,
  equal = FALSE,
  delta = 1.15,
  ylim = NULL,
  xlim = NULL,
  ylab = "",
  xlab = "",
  rug = FALSE,
  rug.alpha = 0.5,
  line.col = scatter.col,
  line.lwd = 1,
  line.lty = 1,
  line.alpha = 1,
  scatter.ylab = "Estimate",
  scatter.ylim = NULL,
  scatter.xlim = NULL,
  scatter.alpha = 0.5,
  scatter.col = col,
  border = col,
  true.lty = 2,
  true.col = "gray70",
  true.lwd = 1.2,
  density.plot = TRUE,
  scatter.plot = FALSE,
  running.mean = scatter.plot,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sim_+3A_x">x</code></td>
<td>
<p>sim object</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_estimate">estimate</code></td>
<td>
<p>columns with estimates</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_se">se</code></td>
<td>
<p>columns with standard error estimates</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_true">true</code></td>
<td>
<p>(optional) vector of true parameter values</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_names">names</code></td>
<td>
<p>(optional) names of estimates</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_auto.layout">auto.layout</code></td>
<td>
<p>Auto layout (default TRUE)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_byrow">byrow</code></td>
<td>
<p>Add new plots to layout by row</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_type">type</code></td>
<td>
<p>plot type</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_ask">ask</code></td>
<td>
<p>if TRUE user is asked for input, before a new figure is drawn</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_col">col</code></td>
<td>
<p>colour (for each estimate)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_pch">pch</code></td>
<td>
<p>plot symbol</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_cex">cex</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_legend">legend</code></td>
<td>
<p>legend</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_legendpos">legendpos</code></td>
<td>
<p>legend position</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_cex.legend">cex.legend</code></td>
<td>
<p>size of legend text</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_plot.type">plot.type</code></td>
<td>
<p>'single' or 'multiple' (default)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_polygon">polygon</code></td>
<td>
<p>if TRUE fill the density estimates with colour</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_density">density</code></td>
<td>
<p>if non-zero add shading lines to polygon</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_angle">angle</code></td>
<td>
<p>shading lines angle of polygon</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Font size on axis</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_alpha">alpha</code></td>
<td>
<p>Semi-transparent level (1: non-transparent, 0: full)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_main">main</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_cex.main">cex.main</code></td>
<td>
<p>Size of title font</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_equal">equal</code></td>
<td>
<p>Same x-axis and y-axis for all plots</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_delta">delta</code></td>
<td>
<p>Controls the amount of space around axis limits</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_ylim">ylim</code></td>
<td>
<p>y-axis limits</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_xlim">xlim</code></td>
<td>
<p>x-axis limits</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_ylab">ylab</code></td>
<td>
<p>y axis label</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_xlab">xlab</code></td>
<td>
<p>x axis label</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_rug">rug</code></td>
<td>
<p>if TRUE add rug representation of data to x-axis</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_rug.alpha">rug.alpha</code></td>
<td>
<p>rug semi-transparency level</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_line.col">line.col</code></td>
<td>
<p>line colour (running mean, only for scatter plots)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_line.lwd">line.lwd</code></td>
<td>
<p>line width (running mean, only for scatter plots)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_line.lty">line.lty</code></td>
<td>
<p>line type (running mean, only for scatter plots)</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_line.alpha">line.alpha</code></td>
<td>
<p>line transparency</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.ylab">scatter.ylab</code></td>
<td>
<p>y label for density plots</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.ylim">scatter.ylim</code></td>
<td>
<p>y-axis limits for density plots</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.xlim">scatter.xlim</code></td>
<td>
<p>x-axis limits for density plots</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.alpha">scatter.alpha</code></td>
<td>
<p>semi-transparency of scatter plot</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.col">scatter.col</code></td>
<td>
<p>scatter plot colour</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_border">border</code></td>
<td>
<p>border colour of density estimates</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_true.lty">true.lty</code></td>
<td>
<p>true parameter estimate line type</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_true.col">true.col</code></td>
<td>
<p>true parameter colour</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_true.lwd">true.lwd</code></td>
<td>
<p>true parameter line width</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_density.plot">density.plot</code></td>
<td>
<p>if TRUE add density plot</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_scatter.plot">scatter.plot</code></td>
<td>
<p>if TRUE add scatter plot</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_running.mean">running.mean</code></td>
<td>
<p>if TRUE add running average estimate to scatter plot</p>
</td></tr>
<tr><td><code id="plot.sim_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000
val &lt;- cbind(est1=rnorm(n,sd=1),est2=rnorm(n,sd=0.2),est3=rnorm(n,1,sd=0.5),
             sd1=runif(n,0.8,1.2),sd2=runif(n,0.1,0.3),sd3=runif(n,0.25,0.75))

plot.sim(val,estimate=c(1,2),true=c(0,0),se=c(4,5),equal=TRUE,scatter.plot=TRUE)
plot.sim(val,estimate=c(1,3),true=c(0,1),se=c(4,6),xlim=c(-3,3),
	scatter.ylim=c(-3,3),scatter.plot=TRUE)
plot.sim(val,estimate=c(1,2),true=c(0,0),se=c(4,5),equal=TRUE,
	plot.type="single",scatter.plot=TRUE)
plot.sim(val,estimate=c(1),se=c(4,5,6),plot.type="single",scatter.plot=TRUE)
plot.sim(val,estimate=c(1,2,3),equal=TRUE,scatter.plot=TRUE)
plot.sim(val,estimate=c(1,2,3),equal=TRUE,byrow=TRUE,scatter.plot=TRUE)
plot.sim(val,estimate=c(1,2,3),plot.type="single",scatter.plot=TRUE)
plot.sim(val,estimate=1,se=c(3,4,5),plot.type="single",scatter.plot=TRUE)

density.sim(val,estimate=c(1,2,3),density=c(0,10,10), lwd=2, angle=c(0,45,-45),cex.legend=1.3)
</code></pre>

<hr>
<h2 id='plotConf'>Plot regression lines</h2><span id='topic+plotConf'></span>

<h3>Description</h3>

<p>Plot regression line (with interactions) and partial residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotConf(
  model,
  var1 = NULL,
  var2 = NULL,
  data = NULL,
  ci.lty = 0,
  ci = TRUE,
  level = 0.95,
  pch = 16,
  lty = 1,
  lwd = 2,
  npoints = 100,
  xlim,
  col = NULL,
  colpt,
  alpha = 0.5,
  cex = 1,
  delta = 0.07,
  centermark = 0.03,
  jitter = 0.2,
  cidiff = FALSE,
  mean = TRUE,
  legend = ifelse(is.null(var1), FALSE, "topright"),
  trans = function(x) {
     x
 },
  partres = inherits(model, "lm"),
  partse = FALSE,
  labels,
  vcov,
  predictfun,
  plot = TRUE,
  new = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotConf_+3A_model">model</code></td>
<td>
<p>Model object (e.g. <code>lm</code>)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_var1">var1</code></td>
<td>
<p>predictor (Continuous or factor)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_var2">var2</code></td>
<td>
<p>Factor that interacts with <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_data">data</code></td>
<td>
<p>data.frame to use for prediction (model.frame is used as default)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_ci.lty">ci.lty</code></td>
<td>
<p>Line type for confidence limits</p>
</td></tr>
<tr><td><code id="plotConf_+3A_ci">ci</code></td>
<td>
<p>Boolean indicating wether to draw pointwise 95% confidence limits</p>
</td></tr>
<tr><td><code id="plotConf_+3A_level">level</code></td>
<td>
<p>Level of confidence limits (default 95%)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_pch">pch</code></td>
<td>
<p>Point type for partial residuals</p>
</td></tr>
<tr><td><code id="plotConf_+3A_lty">lty</code></td>
<td>
<p>Line type for estimated regression lines</p>
</td></tr>
<tr><td><code id="plotConf_+3A_lwd">lwd</code></td>
<td>
<p>Line width for regression lines</p>
</td></tr>
<tr><td><code id="plotConf_+3A_npoints">npoints</code></td>
<td>
<p>Number of points used to plot curves</p>
</td></tr>
<tr><td><code id="plotConf_+3A_xlim">xlim</code></td>
<td>
<p>Range of x axis</p>
</td></tr>
<tr><td><code id="plotConf_+3A_col">col</code></td>
<td>
<p>Color (for each level in <code>var2</code>)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_colpt">colpt</code></td>
<td>
<p>Color of partial residual points</p>
</td></tr>
<tr><td><code id="plotConf_+3A_alpha">alpha</code></td>
<td>
<p>Alpha level</p>
</td></tr>
<tr><td><code id="plotConf_+3A_cex">cex</code></td>
<td>
<p>Point size</p>
</td></tr>
<tr><td><code id="plotConf_+3A_delta">delta</code></td>
<td>
<p>For categorical <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_centermark">centermark</code></td>
<td>
<p>For categorical <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_jitter">jitter</code></td>
<td>
<p>For categorical <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_cidiff">cidiff</code></td>
<td>
<p>For categorical <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_mean">mean</code></td>
<td>
<p>For categorical <code>var1</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_legend">legend</code></td>
<td>
<p>Boolean (add legend)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_trans">trans</code></td>
<td>
<p>Transform estimates (e.g. exponential)</p>
</td></tr>
<tr><td><code id="plotConf_+3A_partres">partres</code></td>
<td>
<p>Boolean indicating whether to plot partial residuals</p>
</td></tr>
<tr><td><code id="plotConf_+3A_partse">partse</code></td>
<td>
<p>.</p>
</td></tr>
<tr><td><code id="plotConf_+3A_labels">labels</code></td>
<td>
<p>Optional labels of <code>var2</code></p>
</td></tr>
<tr><td><code id="plotConf_+3A_vcov">vcov</code></td>
<td>
<p>Optional variance estimates</p>
</td></tr>
<tr><td><code id="plotConf_+3A_predictfun">predictfun</code></td>
<td>
<p>Optional predict-function used to calculate confidence limits and predictions</p>
</td></tr>
<tr><td><code id="plotConf_+3A_plot">plot</code></td>
<td>
<p>If FALSE return only predictions and confidence bands</p>
</td></tr>
<tr><td><code id="plotConf_+3A_new">new</code></td>
<td>
<p>If FALSE add to current plot</p>
</td></tr>
<tr><td><code id="plotConf_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with following members:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Variable on the x-axis (<code>var1</code>)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Variable on the y-axis (partial residuals)</p>
</td></tr>
<tr><td><code>predict</code></td>
<td>
<p>Matrix with confidence limits and predicted values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>termplot</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 100
x0 &lt;- rnorm(n)
x1 &lt;- seq(-3,3, length.out=n)
x2 &lt;- factor(rep(c(1,2),each=n/2), labels=c("A","B"))
y &lt;- 5 + 2*x0 + 0.5*x1 + -1*(x2=="B")*x1 + 0.5*(x2=="B") + rnorm(n, sd=0.25)
dd &lt;- data.frame(y=y, x1=x1, x2=x2)
lm0 &lt;- lm(y ~ x0 + x1*x2, dd)
plotConf(lm0, var1="x1", var2="x2")
abline(a=5,b=0.5,col="red")
abline(a=5.5,b=-0.5,col="red")
### points(5+0.5*x1 -1*(x2=="B")*x1 + 0.5*(x2=="B") ~ x1, cex=2)

data(iris)
l &lt;- lm(Sepal.Length ~ Sepal.Width*Species,iris)
plotConf(l,var2="Species")
plotConf(l,var1="Sepal.Width",var2="Species")

## Not run: 
## lme4 model
dd$Id &lt;- rbinom(n, size = 3, prob = 0.3)
lmer0 &lt;- lme4::lmer(y ~ x0 + x1*x2 + (1|Id), dd)
plotConf(lmer0, var1="x1", var2="x2")

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.lvm'>Prediction in structural equation models</h2><span id='topic+predict.lvm'></span><span id='topic+predict.lvmfit'></span>

<h3>Description</h3>

<p>Prediction in structural equation models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
predict(
  object,
  x = NULL,
  y = NULL,
  residual = FALSE,
  p,
  data,
  path = FALSE,
  quick = is.null(x) &amp; !(residual | path),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.lvm_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_x">x</code></td>
<td>
<p>optional list of (endogenous) variables to condition on</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_y">y</code></td>
<td>
<p>optional subset of variables to predict</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_residual">residual</code></td>
<td>
<p>If true the residuals are predicted</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_p">p</code></td>
<td>
<p>Parameter vector</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_data">data</code></td>
<td>
<p>Data to use in prediction</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_path">path</code></td>
<td>
<p>Path prediction</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_quick">quick</code></td>
<td>
<p>If TRUE the conditional mean and variance given covariates are returned (and all other calculations skipped)</p>
</td></tr>
<tr><td><code id="predict.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>predictlvm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(list(c(y1,y2,y3)~u,u~x)); latent(m) &lt;- ~u
d &lt;- sim(m,100)
e &lt;- estimate(m,d)

## Conditional mean (and variance as attribute) given covariates
r &lt;- predict(e)
## Best linear unbiased predictor (BLUP)
r &lt;- predict(e,vars(e))
##  Conditional mean of y3 giving covariates and y1,y2
r &lt;- predict(e,y3~y1+y2)
##  Conditional mean  gives covariates and y1
r &lt;- predict(e,~y1)
##  Predicted residuals (conditional on all observed variables)
r &lt;- predict(e,vars(e),residual=TRUE)

</code></pre>

<hr>
<h2 id='predictlvm'>Predict function for latent variable models</h2><span id='topic+predictlvm'></span>

<h3>Description</h3>

<p>Predictions of conditinoal mean and variance and calculation of
jacobian with respect to parameter vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictlvm(object, formula, p = coef(object), data = model.frame(object), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictlvm_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="predictlvm_+3A_formula">formula</code></td>
<td>
<p>Formula specifying which variables to predict and which to condition on</p>
</td></tr>
<tr><td><code id="predictlvm_+3A_p">p</code></td>
<td>
<p>Parameter vector</p>
</td></tr>
<tr><td><code id="predictlvm_+3A_data">data</code></td>
<td>
<p>Data.frame</p>
</td></tr>
<tr><td><code id="predictlvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>predict.lvm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(c(x1,x2,x3)~u1,u1~z,
         c(y1,y2,y3)~u2,u2~u1+z)
latent(m) &lt;- ~u1+u2
d &lt;- simulate(m,10,"u2,u2"=2,"u1,u1"=0.5,seed=123)
e &lt;- estimate(m,d)

## Conditional mean given covariates
predictlvm(e,c(x1,x2)~1)$mean
## Conditional variance of u1,y1 given x1,x2
predictlvm(e,c(u1,y1)~x1+x2)$var
</code></pre>

<hr>
<h2 id='Print'>Generic print method</h2><span id='topic+Print'></span>

<h3>Description</h3>

<p>Nicer print method for tabular data. Falls back to standard print method for
all other data types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Print(x, n = 5, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Print_+3A_x">x</code></td>
<td>
<p>object to print</p>
</td></tr>
<tr><td><code id="Print_+3A_n">n</code></td>
<td>
<p>number of rows to show from top and bottom of tabular data</p>
</td></tr>
<tr><td><code id="Print_+3A_digits">digits</code></td>
<td>
<p>precision</p>
</td></tr>
<tr><td><code id="Print_+3A_...">...</code></td>
<td>
<p>additional arguments to print method</p>
</td></tr>
</table>

<hr>
<h2 id='Range.lvm'>Define range constraints of parameters</h2><span id='topic+Range.lvm'></span>

<h3>Description</h3>

<p>Define range constraints of parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Range.lvm(a = 0, b = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Range.lvm_+3A_a">a</code></td>
<td>
<p>Lower bound</p>
</td></tr>
<tr><td><code id="Range.lvm_+3A_b">b</code></td>
<td>
<p>Upper bound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='rbind.Surv'>Appending <code>Surv</code> objects</h2><span id='topic+rbind.Surv'></span>

<h3>Description</h3>

<p><code>rbind</code> method for <code>Surv</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Surv'
rbind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind.Surv_+3A_...">...</code></td>
<td>
<p><code>Surv</code> objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>Surv</code> object
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- yl &lt;- yr &lt;- rnorm(10)
yl[1:5] &lt;- NA; yr[6:10] &lt;- NA
S1 &lt;- survival::Surv(yl,yr,type="interval2")
S2 &lt;- survival::Surv(y,y&gt;0,type="right")
S3 &lt;- survival::Surv(y,y&lt;0,type="left")

rbind(S1,S1)
rbind(S2,S2)
rbind(S3,S3)

</code></pre>

<hr>
<h2 id='regression+26lt+3B-'>Add regression association to latent variable model</h2><span id='topic+regression+3C-'></span><span id='topic+regression'></span><span id='topic+regression+3C-.lvm'></span><span id='topic+regression.lvm'></span><span id='topic+regfix'></span><span id='topic+regfix+3C-'></span><span id='topic+regfix.lvm'></span><span id='topic+regfix+3C-.lvm'></span>

<h3>Description</h3>

<p>Define regression association between variables in a <code>lvm</code>-object and
define linear constraints between model equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
regression(object = lvm(), to, from, fn = NA,
messages = lava.options()$messages, additive=TRUE, y, x, value, ...)
## S3 replacement method for class 'lvm'
regression(object, to=NULL, quick=FALSE, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_object">object</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>A formula specifying the linear constraints or if
<code>to=NULL</code> a <code>list</code> of parameter values.</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_to">to</code></td>
<td>
<p>Character vector of outcome(s) or formula object.</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_from">from</code></td>
<td>
<p>Character vector of predictor(s).</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_fn">fn</code></td>
<td>
<p>Real function defining the functional form of predictors (for
simulation only).</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_messages">messages</code></td>
<td>
<p>Controls which messages are turned on/off (0: all off)</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_additive">additive</code></td>
<td>
<p>If FALSE and predictor is categorical a non-additive effect is assumed</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_y">y</code></td>
<td>
<p>Alias for 'to'</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>Alias for 'from'</p>
</td></tr>
<tr><td><code id="regression+2B26lt+2B3B-_+3A_quick">quick</code></td>
<td>
<p>Faster implementation without parameter constraints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>regression</code> function is used to specify linear associations
between variables of a latent variable model, and offers formula syntax
resembling the model specification of e.g. <code>lm</code>.
</p>
<p>For instance, to add the following linear regression model, to the
<code>lvm</code>-object, <code>m</code>:
</p>
<p style="text-align: center;"><code class="reqn"> E(Y|X_1,X_2) = \beta_1 X_1 + \beta_2 X_2</code>
</p>

<p>We can write
</p>
<p><code>regression(m) &lt;- y ~ x1 + x2</code>
</p>
<p>Multivariate models can be specified by successive calls with
<code>regression</code>, but multivariate formulas are also supported, e.g.
</p>
<p><code>regression(m) &lt;- c(y1,y2) ~ x1 + x2</code>
</p>
<p>defines
</p>
<p style="text-align: center;"><code class="reqn"> E(Y_i|X_1,X_2) = \beta_{1i} X_1 + \beta_{2i} X_2 </code>
</p>

<p>The special function, <code>f</code>, can be used in the model specification to
specify linear constraints. E.g. to fix <code class="reqn">\beta_1=\beta_2</code>
, we could write
</p>
<p><code>regression(m) &lt;- y ~ f(x1,beta) + f(x2,beta)</code>
</p>
<p>The second argument of <code>f</code> can also be a number (e.g. defining an
offset) or be set to <code>NA</code> in order to clear any previously defined
linear constraints.
</p>
<p>Alternatively, a more straight forward notation can be used:
</p>
<p><code>regression(m) &lt;- y ~ beta*x1 + beta*x2</code>
</p>
<p>All the parameter values of the linear constraints can be given as the right
handside expression of the assigment function <code>regression&lt;-</code> (or
<code>regfix&lt;-</code>) if the first (and possibly second) argument is defined as
well. E.g:
</p>
<p><code>regression(m,y1~x1+x2) &lt;- list("a1","b1")</code>
</p>
<p>defines <code class="reqn">E(Y_1|X_1,X_2) = a1 X_1 + b1 X_2</code>. The rhs argument can be a
mixture of character and numeric values (and NA's to remove constraints).
</p>
<p>The function <code>regression</code> (called without additional arguments) can be
used to inspect the linear constraints of a <code>lvm</code>-object.
</p>


<h3>Value</h3>

<p>A <code>lvm</code>-object
</p>


<h3>Note</h3>

<p>Variables will be added to the model if not already present.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+intercept+3C-">intercept&lt;-</a></code>, <code><a href="#topic+covariance+3C-">covariance&lt;-</a></code>,
<code><a href="#topic+constrain+3C-">constrain&lt;-</a></code>, <code><a href="#topic+parameter+3C-">parameter&lt;-</a></code>,
<code><a href="#topic+latent+3C-">latent&lt;-</a></code>, <code><a href="#topic+cancel+3C-">cancel&lt;-</a></code>, <code><a href="#topic+kill+3C-">kill&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm() ## Initialize empty lvm-object
### E(y1|z,v) = beta1*z + beta2*v
regression(m) &lt;- y1 ~ z + v
### E(y2|x,z,v) = beta*x + beta*z + 2*v + beta3*u
regression(m) &lt;- y2 ~ f(x,beta) + f(z,beta)  + f(v,2) + u
### Clear restriction on association between y and
### fix slope coefficient of u to beta
regression(m, y2 ~ v+u) &lt;- list(NA,"beta")

regression(m) ## Examine current linear parameter constraints

## ## A multivariate model, E(yi|x1,x2) = beta[1i]*x1 + beta[2i]*x2:
m2 &lt;- lvm(c(y1,y2) ~ x1+x2)

</code></pre>

<hr>
<h2 id='revdiag'>Create/extract 'reverse'-diagonal matrix or off-diagonal elements</h2><span id='topic+revdiag'></span><span id='topic+revdiag+3C-'></span><span id='topic+offdiag'></span><span id='topic+offdiag+3C-'></span>

<h3>Description</h3>

<p>Create/extract 'reverse'-diagonal matrix or off-diagonal elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>revdiag(x,...)
offdiag(x,type=0,...)

revdiag(x,...) &lt;- value
offdiag(x,type=0,...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="revdiag_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="revdiag_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="revdiag_+3A_value">value</code></td>
<td>
<p>For the assignment function the values to put in the diagonal</p>
</td></tr>
<tr><td><code id="revdiag_+3A_type">type</code></td>
<td>
<p>0: upper and lower triangular, 1: upper triangular, 2: lower triangular, 3: upper triangular + diagonal, 4: lower triangular + diagonal</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='rmvar'>Remove variables from (model) object.</h2><span id='topic+rmvar'></span><span id='topic+rmvar+3C-'></span><span id='topic+kill'></span><span id='topic+kill+3C-'></span>

<h3>Description</h3>

<p>Generic method for removing elements of object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvar(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvar_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="rmvar_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
<tr><td><code id="rmvar_+3A_value">value</code></td>
<td>
<p>Vector of variables or formula specifying which nodes to
remove</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code>cancel</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm()
addvar(m) &lt;- ~y1+y2+x
covariance(m) &lt;- y1~y2
regression(m) &lt;- c(y1,y2) ~ x
### Cancel the covariance between the residuals of y1 and y2
cancel(m) &lt;- y1~y2
### Remove y2 from the model
rmvar(m) &lt;- ~y2

</code></pre>

<hr>
<h2 id='rotate2'>Performs a rotation in the plane</h2><span id='topic+rotate2'></span><span id='topic+rot2D'></span><span id='topic+rot3D'></span>

<h3>Description</h3>

<p>Performs a rotation in the plane
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotate2(x, theta = pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotate2_+3A_x">x</code></td>
<td>
<p>Matrix to be rotated (2 times n)</p>
</td></tr>
<tr><td><code id="rotate2_+3A_theta">theta</code></td>
<td>
<p>Rotation in radians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the same dimension as <code>x</code>
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rotate2(cbind(c(1,2),c(2,1)))
</code></pre>

<hr>
<h2 id='scheffe'>Calculate simultaneous confidence limits by Scheffe's method</h2><span id='topic+scheffe'></span>

<h3>Description</h3>

<p>Function to compute the Scheffe corrected confidence
interval for the regression line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scheffe(model, newdata = model.frame(model), level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scheffe_+3A_model">model</code></td>
<td>
<p>Linear model</p>
</td></tr>
<tr><td><code id="scheffe_+3A_newdata">newdata</code></td>
<td>
<p>new data frame</p>
</td></tr>
<tr><td><code id="scheffe_+3A_level">level</code></td>
<td>
<p>confidence level (0.95)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
d &lt;- data.frame(y=rnorm(length(x),x),x=x)
l &lt;- lm(y~x,d)
plot(y~x,d)
abline(l)
d0 &lt;- data.frame(x=seq(-5,5,length.out=100))
d1 &lt;- cbind(d0,predict(l,newdata=d0,interval="confidence"))
d2 &lt;- cbind(d0,scheffe(l,d0))
lines(lwr~x,d1,lty=2,col="red")
lines(upr~x,d1,lty=2,col="red")
lines(lwr~x,d2,lty=2,col="blue")
lines(upr~x,d2,lty=2,col="blue")
</code></pre>

<hr>
<h2 id='semdata'>Example SEM data</h2><span id='topic+semdata'></span>

<h3>Description</h3>

<p>Simulated data
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='serotonin'>Serotonin data</h2><span id='topic+serotonin'></span>

<h3>Description</h3>

<p>This simulated data mimics a PET imaging study where the 5-HT2A
receptor and serotonin transporter (SERT) binding potential has
been quantified into 8 different regions. The 5-HT2A
cortical regions are considered high-binding regions
measurements.  These measurements can be regarded as proxy measures of
the extra-cellular levels of serotonin in the brain
</p>

<table>
<tr>
 <td style="text-align: right;">
        day    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Scan day of the year </td>
</tr>
<tr>
 <td style="text-align: right;">
        age    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Age at baseline scan </td>
</tr>
<tr>
 <td style="text-align: right;">
        mem    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Memory performance score </td>
</tr>
<tr>
 <td style="text-align: right;">
        depr   </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Depression (mild) status 500 days after baseline </td>
</tr>
<tr>
 <td style="text-align: right;">
        gene1  </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Gene marker 1 (HTR2A) </td>
</tr>
<tr>
 <td style="text-align: right;">
        gene2  </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Gene marker 2 (HTTTLPR) </td>
</tr>
<tr>
 <td style="text-align: right;">
        cau </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> SERT binding, Caudate Nucleus </td>
</tr>
<tr>
 <td style="text-align: right;">
        th  </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> SERT binding, Thalamus </td>
</tr>
<tr>
 <td style="text-align: right;">
        put </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> SERT binding, Putamen </td>
</tr>
<tr>
 <td style="text-align: right;">
        mid </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> SERT binding, Midbrain </td>
</tr>
<tr>
 <td style="text-align: right;">
        aci </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> 5-HT2A binding, Anterior cingulate gyrus </td>
</tr>
<tr>
 <td style="text-align: right;">
        pci  </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> 5-HT2A binding, Posterior cingulate gyrus </td>
</tr>
<tr>
 <td style="text-align: right;">
        sfc </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> 5-HT2A binding, Superior frontal cortex </td>
</tr>
<tr>
 <td style="text-align: right;">
        par </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> 5-HT2A binding, Parietal cortex </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='serotonin2'>Data</h2><span id='topic+serotonin2'></span>

<h3>Description</h3>

<p>Description
</p>


<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>


<h3>See Also</h3>

<p>serotonin
</p>

<hr>
<h2 id='sim'>Simulate model</h2><span id='topic+sim'></span><span id='topic+sim.lvmfit'></span><span id='topic+sim.lvm'></span><span id='topic+simulate.lvmfit'></span><span id='topic+simulate.lvm'></span><span id='topic+transform+3C-'></span><span id='topic+transform+3C-.lvm'></span><span id='topic+transform.lvm'></span><span id='topic+functional'></span><span id='topic+functional+3C-'></span><span id='topic+functional.lvm'></span><span id='topic+functional+3C-.lvm'></span><span id='topic+distribution'></span><span id='topic+distribution+3C-'></span><span id='topic+distribution.lvm'></span><span id='topic+distribution+3C-.lvm'></span><span id='topic+heavytail'></span><span id='topic+heavytail+3C-'></span><span id='topic+weibull.lvm'></span><span id='topic+binomial.lvm'></span><span id='topic+poisson.lvm'></span><span id='topic+uniform.lvm'></span><span id='topic+multinomial.lvm'></span><span id='topic+beta.lvm'></span><span id='topic+normal.lvm'></span><span id='topic+mvn.lvm'></span><span id='topic+lognormal.lvm'></span><span id='topic+gaussian.lvm'></span><span id='topic+GM2.lvm'></span><span id='topic+GM3.lvm'></span><span id='topic+probit.lvm'></span><span id='topic+logit.lvm'></span><span id='topic+pareto.lvm'></span><span id='topic+student.lvm'></span><span id='topic+chisq.lvm'></span><span id='topic+coxGompertz.lvm'></span><span id='topic+coxWeibull.lvm'></span><span id='topic+coxExponential.lvm'></span><span id='topic+aalenExponential.lvm'></span><span id='topic+Gamma.lvm'></span><span id='topic+gamma.lvm'></span><span id='topic+loggamma.lvm'></span><span id='topic+categorical'></span><span id='topic+categorical+3C-'></span><span id='topic+threshold.lvm'></span><span id='topic+ones.lvm'></span><span id='topic+Binary.lvm'></span><span id='topic+binary.lvm'></span><span id='topic+Sequence.lvm'></span><span id='topic+none.lvm'></span><span id='topic+constant.lvm'></span><span id='topic+id.lvm'></span>

<h3>Description</h3>

<p>Simulate data from a general SEM model including non-linear effects and
general link and distribution of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
sim(x, n = NULL, p = NULL, normal = FALSE, cond = FALSE,
sigma = 1, rho = 0.5, X = NULL, unlink=FALSE, latent=TRUE,
use.labels = TRUE, seed=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_+3A_x">x</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="sim_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="sim_+3A_n">n</code></td>
<td>
<p>Number of simulated values/individuals</p>
</td></tr>
<tr><td><code id="sim_+3A_p">p</code></td>
<td>
<p>Parameter value (optional)</p>
</td></tr>
<tr><td><code id="sim_+3A_normal">normal</code></td>
<td>
<p>Logical indicating whether to simulate data from a
multivariate normal distribution conditional on exogenous variables hence
ignoring functional/distribution definition</p>
</td></tr>
<tr><td><code id="sim_+3A_cond">cond</code></td>
<td>
<p>for internal use</p>
</td></tr>
<tr><td><code id="sim_+3A_sigma">sigma</code></td>
<td>
<p>Default residual variance (1)</p>
</td></tr>
<tr><td><code id="sim_+3A_rho">rho</code></td>
<td>
<p>Default covariance parameter (0.5)</p>
</td></tr>
<tr><td><code id="sim_+3A_x">X</code></td>
<td>
<p>Optional matrix of fixed values of variables (manipulation)</p>
</td></tr>
<tr><td><code id="sim_+3A_unlink">unlink</code></td>
<td>
<p>Return Inverse link transformed data</p>
</td></tr>
<tr><td><code id="sim_+3A_latent">latent</code></td>
<td>
<p>Include latent variables (default TRUE)</p>
</td></tr>
<tr><td><code id="sim_+3A_use.labels">use.labels</code></td>
<td>
<p>convert categorical variables to factors before applying transformation</p>
</td></tr>
<tr><td><code id="sim_+3A_seed">seed</code></td>
<td>
<p>Random seed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################
## Logistic regression
##################################################
m &lt;- lvm(y~x+z)
regression(m) &lt;- x~z
distribution(m,~y+z) &lt;- binomial.lvm("logit")
d &lt;- sim(m,1e3)
head(d)

e &lt;- estimate(m,d,estimator="glm")
e
## Simulate a few observation from estimated model
sim(e,n=5)

##################################################
## Poisson
##################################################
distribution(m,~y) &lt;- poisson.lvm()
d &lt;- sim(m,1e4,p=c(y=-1,"y~x"=2,z=1))
head(d)
estimate(m,d,estimator="glm")
mean(d$z); lava:::expit(1)

summary(lm(y~x,sim(lvm(y[1:2]~4*x),1e3)))

##################################################
### Gamma distribution
##################################################
m &lt;- lvm(y~x)
distribution(m,~y+x) &lt;- list(Gamma.lvm(shape=2),binomial.lvm())
intercept(m,~y) &lt;- 0.5
d &lt;- sim(m,1e4)
summary(g &lt;- glm(y~x,family=Gamma(),data=d))
## Not run: MASS::gamma.shape(g)

args(lava::Gamma.lvm)
distribution(m,~y) &lt;- Gamma.lvm(shape=2,log=TRUE)
sim(m,10,p=c(y=0.5))[,"y"]

##################################################
### Beta
##################################################
m &lt;- lvm()
distribution(m,~y) &lt;- beta.lvm(alpha=2,beta=1)
var(sim(m,100,"y,y"=2))
distribution(m,~y) &lt;- beta.lvm(alpha=2,beta=1,scale=FALSE)
var(sim(m,100))

##################################################
### Transform
##################################################
m &lt;- lvm()
transform(m,xz~x+z) &lt;- function(x) x[1]*(x[2]&gt;0)
regression(m) &lt;- y~x+z+xz
d &lt;- sim(m,1e3)
summary(lm(y~x+z + x*I(z&gt;0),d))

##################################################
### Non-random variables
##################################################
m &lt;- lvm()
distribution(m,~x+z+v+w) &lt;- list(Sequence.lvm(0,5),## Seq. 0 to 5 by 1/n
                               Binary.lvm(),       ## Vector of ones
                               Binary.lvm(0.5),    ##  0.5n 0, 0.5n 1
                               Binary.lvm(interval=list(c(0.3,0.5),c(0.8,1))))
sim(m,10)

##################################################
### Cox model
### piecewise constant hazard
################################################
m &lt;- lvm(t~x)
rates &lt;- c(1,0.5); cuts &lt;- c(0,5)
## Constant rate: 1 in [0,5), 0.5 in [5,Inf)
distribution(m,~t) &lt;- coxExponential.lvm(rate=rates,timecut=cuts)

## Not run: 
    d &lt;- sim(m,2e4,p=c("t~x"=0.1)); d$status &lt;- TRUE
    plot(timereg::aalen(survival::Surv(t,status)~x,data=d,
                        resample.iid=0,robust=0),spec=1)
    L &lt;- approxfun(c(cuts,max(d$t)),f=1,
                   cumsum(c(0,rates*diff(c(cuts,max(d$t))))),
                   method="linear")
    curve(L,0,100,add=TRUE,col="blue")

## End(Not run)

##################################################
### Cox model
### piecewise constant hazard, gamma frailty
##################################################
m &lt;- lvm(y~x+z)
rates &lt;- c(0.3,0.5); cuts &lt;- c(0,5)
distribution(m,~y+z) &lt;- list(coxExponential.lvm(rate=rates,timecut=cuts),
                             loggamma.lvm(rate=1,shape=1))
## Not run: 
    d &lt;- sim(m,2e4,p=c("y~x"=0,"y~z"=0)); d$status &lt;- TRUE
    plot(timereg::aalen(survival::Surv(y,status)~x,data=d,
                        resample.iid=0,robust=0),spec=1)
    L &lt;- approxfun(c(cuts,max(d$y)),f=1,
                   cumsum(c(0,rates*diff(c(cuts,max(d$y))))),
                   method="linear")
    curve(L,0,100,add=TRUE,col="blue")

## End(Not run)
## Equivalent via transform (here with Aalens additive hazard model)
m &lt;- lvm(y~x)
distribution(m,~y) &lt;- aalenExponential.lvm(rate=rates,timecut=cuts)
distribution(m,~z) &lt;- Gamma.lvm(rate=1,shape=1)
transform(m,t~y+z) &lt;- prod
sim(m,10)
## Shared frailty
m &lt;- lvm(c(t1,t2)~x+z)
rates &lt;- c(1,0.5); cuts &lt;- c(0,5)
distribution(m,~y) &lt;- aalenExponential.lvm(rate=rates,timecut=cuts)
distribution(m,~z) &lt;- loggamma.lvm(rate=1,shape=1)
## Not run: 
mets::fast.reshape(sim(m,100),varying="t")

## End(Not run)

##################################################
### General multivariate distributions
##################################################
## Not run: 
m &lt;- lvm()
distribution(m,~y1+y2,oratio=4) &lt;- VGAM::rbiplackcop
ksmooth2(sim(m,1e4),rgl=FALSE,theta=-20,phi=25)

m &lt;- lvm()
distribution(m,~z1+z2,"or1") &lt;- VGAM::rbiplackcop
distribution(m,~y1+y2,"or2") &lt;- VGAM::rbiplackcop
sim(m,10,p=c(or1=0.1,or2=4))

## End(Not run)

m &lt;- lvm()
distribution(m,~y1+y2+y3,TRUE) &lt;- function(n,...) rmvn0(n,sigma=diag(3)+1)
var(sim(m,100))

## Syntax also useful for univariate generators, e.g.
m &lt;- lvm(y~x+z)
distribution(m,~y,TRUE) &lt;- function(n) rnorm(n,mean=1000)
sim(m,5)
distribution(m,~y,"m1",0) &lt;- rnorm
sim(m,5)
sim(m,5,p=c(m1=100))

##################################################
### Regression design in other parameters
##################################################
## Variance heterogeneity
m &lt;- lvm(y~x)
distribution(m,~y) &lt;- function(n,mean,x) rnorm(n,mean,exp(x)^.5)
if (interactive()) plot(y~x,sim(m,1e3))
## Alternaively, calculate the standard error directly
addvar(m) &lt;- ~sd ## If 'sd' should be part of the resulting data.frame
constrain(m,sd~x) &lt;- function(x) exp(x)^.5
distribution(m,~y) &lt;- function(n,mean,sd) rnorm(n,mean,sd)
if (interactive()) plot(y~x,sim(m,1e3))

## Regression on variance parameter
m &lt;- lvm()
regression(m) &lt;- y~x
regression(m) &lt;- v~x
##distribution(m,~v) &lt;- 0 # No stochastic term
## Alternative:
## regression(m) &lt;- v[NA:0]~x
distribution(m,~y) &lt;- function(n,mean,v) rnorm(n,mean,exp(v)^.5)
if (interactive()) plot(y~x,sim(m,1e3))

## Regression on shape parameter in Weibull model
m &lt;- lvm()
regression(m) &lt;- y ~ z+v
regression(m) &lt;- s ~ exp(0.6*x-0.5*z)
distribution(m,~x+z) &lt;- binomial.lvm()
distribution(m,~cens) &lt;- coxWeibull.lvm(scale=1)
distribution(m,~y) &lt;- coxWeibull.lvm(scale=0.1,shape=~s)
eventTime(m) &lt;- time ~ min(y=1,cens=0)

if (interactive()) {
    d &lt;- sim(m,1e3)
    require(survival)
    (cc &lt;- coxph(Surv(time,status)~v+strata(x,z),data=d))
    plot(survfit(cc) ,col=1:4,mark.time=FALSE)
}

##################################################
### Categorical predictor
##################################################
m &lt;- lvm()
## categorical(m,K=3) &lt;- "v"
categorical(m,labels=c("A","B","C")) &lt;- "v"

regression(m,additive=FALSE) &lt;- y~v
## Not run: 
plot(y~v,sim(m,1000,p=c("y~v:2"=3)))

## End(Not run)

m &lt;- lvm()
categorical(m,labels=c("A","B","C"),p=c(0.5,0.3)) &lt;- "v"
regression(m,additive=FALSE,beta=c(0,2,-1)) &lt;- y~v
## equivalent to:
## regression(m,y~v,additive=FALSE) &lt;- c(0,2,-1)
regression(m,additive=FALSE,beta=c(0,4,-1)) &lt;- z~v
table(sim(m,1e4)$v)
glm(y~v, data=sim(m,1e4))
glm(y~v, data=sim(m,1e4,p=c("y~v:1"=3)))

transform(m,v2~v) &lt;- function(x) x=='A'
sim(m,10)

##################################################
### Pre-calculate object
##################################################
m &lt;- lvm(y~x)
m2 &lt;- sim(m,'y~x'=2)
sim(m,10,'y~x'=2)
sim(m2,10) ## Faster
</code></pre>

<hr>
<h2 id='sim.default'>Monte Carlo simulation</h2><span id='topic+sim.default'></span><span id='topic+as.sim'></span>

<h3>Description</h3>

<p>Applies a function repeatedly for a specified number of replications or over
a list/data.frame with plot and summary methods for summarizing the Monte
Carlo experiment. Can be parallelized via the future package (use the
future::plan function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
sim(
  x = NULL,
  R = 100,
  f = NULL,
  colnames = NULL,
  seed = NULL,
  args = list(),
  iter = FALSE,
  mc.cores,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim.default_+3A_x">x</code></td>
<td>
<p>function or 'sim' object</p>
</td></tr>
<tr><td><code id="sim.default_+3A_r">R</code></td>
<td>
<p>Number of replications or data.frame with parameters</p>
</td></tr>
<tr><td><code id="sim.default_+3A_f">f</code></td>
<td>
<p>Optional function (i.e., if x is a matrix)</p>
</td></tr>
<tr><td><code id="sim.default_+3A_colnames">colnames</code></td>
<td>
<p>Optional column names</p>
</td></tr>
<tr><td><code id="sim.default_+3A_seed">seed</code></td>
<td>
<p>(optional) Seed (needed with cl=TRUE)</p>
</td></tr>
<tr><td><code id="sim.default_+3A_args">args</code></td>
<td>
<p>(optional) list of named arguments passed to (mc)mapply</p>
</td></tr>
<tr><td><code id="sim.default_+3A_iter">iter</code></td>
<td>
<p>If TRUE the iteration number is passed as first argument to
(mc)mapply</p>
</td></tr>
<tr><td><code id="sim.default_+3A_mc.cores">mc.cores</code></td>
<td>
<p>Optional number of cores. Will use parallel::mcmapply instead of future</p>
</td></tr>
<tr><td><code id="sim.default_+3A_...">...</code></td>
<td>
<p>Additional arguments to future.apply::future_mapply</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To parallelize the calculation use the future::plan function (e.g.,
future::plan(multisession()) to distribute the calculations over the R
replications on all available cores). The output is controlled via the
progressr package (e.g., progressr::handlers(global=TRUE) to enable
progress information).
</p>


<h3>See Also</h3>

<p>summary.sim plot.sim print.sim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(y~x+e)
distribution(m,~y) &lt;- 0
distribution(m,~x) &lt;- uniform.lvm(a=-1.1,b=1.1)
transform(m,e~x) &lt;- function(x) (1*x^4)*rnorm(length(x),sd=1)

onerun &lt;- function(iter=NULL,...,n=2e3,b0=1,idx=2) {
    d &lt;- sim(m,n,p=c("y~x"=b0))
    l &lt;- lm(y~x,d)
    res &lt;- c(coef(summary(l))[idx,1:2],
             confint(l)[idx,],
             estimate(l,only.coef=TRUE)[idx,2:4])
    names(res) &lt;- c("Estimate","Model.se","Model.lo","Model.hi",
                    "Sandwich.se","Sandwich.lo","Sandwich.hi")
    res
}
val &lt;- sim(onerun,R=10,b0=1)
val

val &lt;- sim(val,R=40,b0=1) ## append results
summary(val,estimate=c(1,1),confint=c(3,4,6,7),true=c(1,1))

summary(val,estimate=c(1,1),se=c(2,5),names=c("Model","Sandwich"))
summary(val,estimate=c(1,1),se=c(2,5),true=c(1,1),names=c("Model","Sandwich"),confint=TRUE)

if (interactive()) {
    plot(val,estimate=1,c(2,5),true=1,names=c("Model","Sandwich"),polygon=FALSE)
    plot(val,estimate=c(1,1),se=c(2,5),main=NULL,
         true=c(1,1),names=c("Model","Sandwich"),
         line.lwd=1,col=c("gray20","gray60"),
         rug=FALSE)
    plot(val,estimate=c(1,1),se=c(2,5),true=c(1,1),
         names=c("Model","Sandwich"))
}

f &lt;- function(a=1, b=1) {
  rep(a*b, 5)
}
R &lt;- Expand(a=1:3, b=1:3)
sim(f, R)
sim(function(a,b) f(a,b), 3, args=c(a=5,b=5))
sim(function(iter=1,a=5,b=5) iter*f(a,b), iter=TRUE, R=5)
</code></pre>

<hr>
<h2 id='spaghetti'>Spaghetti plot</h2><span id='topic+spaghetti'></span>

<h3>Description</h3>

<p>Spaghetti plot for longitudinal data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spaghetti(
  formula,
  data = NULL,
  id = "id",
  group = NULL,
  type = "o",
  lty = 1,
  pch = NA,
  col = 1:10,
  alpha = 0.3,
  lwd = 1,
  level = 0.95,
  trend.formula = formula,
  tau = NULL,
  trend.lty = 1,
  trend.join = TRUE,
  trend.delta = 0.2,
  trend = !is.null(tau),
  trend.col = col,
  trend.alpha = 0.2,
  trend.lwd = 3,
  trend.jitter = 0,
  legend = NULL,
  by = NULL,
  xlab = "Time",
  ylab = "",
  add = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spaghetti_+3A_formula">formula</code></td>
<td>
<p>Formula (response ~ time)</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_id">id</code></td>
<td>
<p>Id variable</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_group">group</code></td>
<td>
<p>group variable</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_type">type</code></td>
<td>
<p>Type (line 'l', stair 's', ...)</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_lty">lty</code></td>
<td>
<p>Line type</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_pch">pch</code></td>
<td>
<p>Colour</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_col">col</code></td>
<td>
<p>Colour</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_alpha">alpha</code></td>
<td>
<p>transparency (0-1)</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_lwd">lwd</code></td>
<td>
<p>Line width</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_level">level</code></td>
<td>
<p>Confidence level</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.formula">trend.formula</code></td>
<td>
<p>Formula for trendline</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_tau">tau</code></td>
<td>
<p>Quantile to estimate (trend)</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.lty">trend.lty</code></td>
<td>
<p>Trend line type</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.join">trend.join</code></td>
<td>
<p>Trend polygon</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.delta">trend.delta</code></td>
<td>
<p>Length of limit bars</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend">trend</code></td>
<td>
<p>Add trend line</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.col">trend.col</code></td>
<td>
<p>Colour of trend line</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.alpha">trend.alpha</code></td>
<td>
<p>Transparency</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.lwd">trend.lwd</code></td>
<td>
<p>Trend line width</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_trend.jitter">trend.jitter</code></td>
<td>
<p>Jitter amount</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_legend">legend</code></td>
<td>
<p>Legend</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_by">by</code></td>
<td>
<p>make separate plot for each level in 'by' (formula, name of column, or vector)</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_xlab">xlab</code></td>
<td>
<p>Label of X-axis</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_ylab">ylab</code></td>
<td>
<p>Label of Y-axis</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_add">add</code></td>
<td>
<p>Add to existing device</p>
</td></tr>
<tr><td><code id="spaghetti_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level arguments</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive() &amp; requireNamespace("mets")) {
K &lt;- 5
y &lt;- "y"%++%seq(K)
m &lt;- lvm()
regression(m,y=y,x=~u) &lt;- 1
regression(m,y=y,x=~s) &lt;- seq(K)-1
regression(m,y=y,x=~x) &lt;- "b"
N &lt;- 50
d &lt;- sim(m,N); d$z &lt;- rbinom(N,1,0.5)
dd &lt;- mets::fast.reshape(d); dd$num &lt;- dd$num+3
spaghetti(y~num,dd,id="id",lty=1,col=Col(1,.4),
          trend.formula=~factor(num),trend=TRUE,trend.col="darkblue")
dd$num &lt;- dd$num+rnorm(nrow(dd),sd=0.5) ## Unbalance
spaghetti(y~num,dd,id="id",lty=1,col=Col(1,.4),
          trend=TRUE,trend.col="darkblue")
spaghetti(y~num,dd,id="id",lty=1,col=Col(1,.4),
           trend.formula=~num+I(num^2),trend=TRUE,trend.col="darkblue")
}
</code></pre>

<hr>
<h2 id='stack.estimate'>Stack estimating equations</h2><span id='topic+stack.estimate'></span>

<h3>Description</h3>

<p>Stack estimating equations (two-stage estimator)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate'
stack(
  x,
  model2,
  D1u,
  inv.D2u,
  propensity,
  dpropensity,
  U,
  keep1 = FALSE,
  propensity.arg,
  estimate.arg,
  na.action = na.pass,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack.estimate_+3A_x">x</code></td>
<td>
<p>Model 1</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_model2">model2</code></td>
<td>
<p>Model 2</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_d1u">D1u</code></td>
<td>
<p>Derivative of score of model 2 w.r.t. parameter vector of model 1</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_inv.d2u">inv.D2u</code></td>
<td>
<p>Inverse of deri</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_propensity">propensity</code></td>
<td>
<p>propensity score (vector or function)</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_dpropensity">dpropensity</code></td>
<td>
<p>derivative of propensity score wrt parameters of model 1</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_u">U</code></td>
<td>
<p>Optional score function (model 2) as function of all parameters</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_keep1">keep1</code></td>
<td>
<p>If FALSE only parameters of model 2 is returned</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_propensity.arg">propensity.arg</code></td>
<td>
<p>Arguments to propensity function</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_estimate.arg">estimate.arg</code></td>
<td>
<p>Arguments to 'estimate'</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_na.action">na.action</code></td>
<td>
<p>Method for dealing with missing data in propensity score</p>
</td></tr>
<tr><td><code id="stack.estimate_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(z0~x)
Missing(m, z ~ z0) &lt;- r~x
distribution(m,~x) &lt;- binomial.lvm()
p &lt;- c(r=-1,'r~x'=0.5,'z0~x'=2)
beta &lt;- p[3]/2
d &lt;- sim(m,500,p=p,seed=1)
m1 &lt;- estimate(r~x,data=d,family=binomial)
d$w &lt;- d$r/predict(m1,type="response")
m2 &lt;- estimate(z~1, weights=w, data=d)
(e &lt;- stack(m1,m2,propensity=TRUE))
</code></pre>

<hr>
<h2 id='startvalues'>For internal use</h2><span id='topic+startvalues'></span><span id='topic+startvalues0'></span><span id='topic+startvalues1'></span><span id='topic+startvalues2'></span><span id='topic+startvalues3'></span><span id='topic+starter.multigroup'></span><span id='topic+addattr'></span><span id='topic+modelPar'></span><span id='topic+modelVar'></span><span id='topic+matrices'></span><span id='topic+pars'></span><span id='topic+pars.lvm'></span><span id='topic+pars.lvmfit'></span><span id='topic+pars.glm'></span><span id='topic+score.glm'></span><span id='topic+procdata.lvmfit'></span><span id='topic+reorderdata'></span><span id='topic+graph2lvm'></span><span id='topic+igraph.lvm'></span><span id='topic+subgraph'></span><span id='topic+finalize'></span><span id='topic+index.lvm'></span><span id='topic+index.lvmfit'></span><span id='topic+index'></span><span id='topic+reindex'></span><span id='topic+index+3C-'></span><span id='topic+rmvn0'></span><span id='topic+dmvn0'></span><span id='topic+logit'></span><span id='topic+expit'></span><span id='topic+tigol'></span><span id='topic+randomslope'></span><span id='topic+randomslope+3C-'></span><span id='topic+lisrel'></span><span id='topic+variances'></span><span id='topic+offdiags'></span><span id='topic+describecoef'></span><span id='topic+parlabels'></span><span id='topic+rsq'></span><span id='topic+stdcoef'></span><span id='topic+CoefMat'></span><span id='topic+CoefMat.multigroupfit'></span><span id='topic+deriv'></span><span id='topic+updatelvm'></span><span id='topic+checkmultigroup'></span><span id='topic+profci'></span><span id='topic+estimate.MAR'></span><span id='topic+missingModel'></span><span id='topic+Inverse'></span><span id='topic+Identical'></span><span id='topic+gaussian_logLik.lvm'></span><span id='topic+addhook'></span><span id='topic+gethook'></span><span id='topic+multigroup'></span><span id='topic+Weights'></span><span id='topic+fixsome'></span><span id='topic+parfix'></span><span id='topic+parfix+3C-'></span><span id='topic+merge'></span><span id='topic+IV'></span><span id='topic+parameter'></span><span id='topic+Specials'></span><span id='topic+procformula'></span><span id='topic+getoutcome'></span><span id='topic+decomp.specials'></span><span id='topic+na.pass0'></span>

<h3>Description</h3>

<p>For internal use
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='subset.lvm'>Extract subset of latent variable model</h2><span id='topic+subset.lvm'></span><span id='topic+measurement'></span>

<h3>Description</h3>

<p>Extract measurement models or user-specified subset of model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvm'
subset(x, vars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.lvm_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object.</p>
</td></tr>
<tr><td><code id="subset.lvm_+3A_vars">vars</code></td>
<td>
<p>Character vector or formula specifying variables to include in
subset.</p>
</td></tr>
<tr><td><code id="subset.lvm_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>lvm</code>-object.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- lvm(c(y1,y2)~x1+x2)
subset(m,~y1+x1)

</code></pre>

<hr>
<h2 id='summary.sim'>Summary method for 'sim' objects</h2><span id='topic+summary.sim'></span>

<h3>Description</h3>

<p>Summary method for 'sim' objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sim'
summary(
  object,
  estimate = NULL,
  se = NULL,
  confint = !is.null(se) &amp;&amp; !is.null(true),
  true = NULL,
  fun,
  names = NULL,
  unique.names = TRUE,
  minimal = FALSE,
  level = 0.95,
  quantiles = c(0, 0.025, 0.5, 0.975, 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sim_+3A_object">object</code></td>
<td>
<p>sim object</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_estimate">estimate</code></td>
<td>
<p>(optional) columns with estimates</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_se">se</code></td>
<td>
<p>(optional) columns with standard error estimates</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_confint">confint</code></td>
<td>
<p>(optional) list of pairs of columns with confidence limits</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_true">true</code></td>
<td>
<p>(optional) vector of true parameter values</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_fun">fun</code></td>
<td>
<p>(optional) summary function</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_names">names</code></td>
<td>
<p>(optional) names of estimates</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_unique.names">unique.names</code></td>
<td>
<p>if TRUE, unique.names will be applied to column names</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_minimal">minimal</code></td>
<td>
<p>if TRUE, minimal summary will be returned</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_level">level</code></td>
<td>
<p>confidence level (0.95)</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles (0,0.025,0.5,0.975,1)</p>
</td></tr>
<tr><td><code id="summary.sim_+3A_...">...</code></td>
<td>
<p>additional levels to lower-level functions</p>
</td></tr>
</table>

<hr>
<h2 id='timedep'>Time-dependent parameters</h2><span id='topic+timedep'></span><span id='topic+timedep+3C-'></span>

<h3>Description</h3>

<p>Add time-varying covariate effects to model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timedep(object, formula, rate, timecut, type = "coxExponential.lvm", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timedep_+3A_object">object</code></td>
<td>
<p>Model</p>
</td></tr>
<tr><td><code id="timedep_+3A_formula">formula</code></td>
<td>
<p>Formula with rhs specifying time-varying covariates</p>
</td></tr>
<tr><td><code id="timedep_+3A_rate">rate</code></td>
<td>
<p>Optional rate parameters. If given as a vector this
parameter is interpreted as the raw (baseline-)rates within each
time interval defined by <code>timecut</code>.  If given as a matrix the
parameters are interpreted as log-rates (and log-rate-ratios for
the time-varying covariates defined in the formula).</p>
</td></tr>
<tr><td><code id="timedep_+3A_timecut">timecut</code></td>
<td>
<p>Time intervals</p>
</td></tr>
<tr><td><code id="timedep_+3A_type">type</code></td>
<td>
<p>Type of model (default piecewise constant intensity)</p>
</td></tr>
<tr><td><code id="timedep_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Piecewise constant hazard
m &lt;- lvm(y~1)
m &lt;- timedep(m,y~1,timecut=c(0,5),rate=c(0.5,0.3))

## Not run: 
d &lt;- sim(m,1e4); d$status &lt;- TRUE
dd &lt;- mets::lifetable(Surv(y,status)~1,data=d,breaks=c(0,5,10));
exp(coef(glm(events ~ offset(log(atrisk)) + -1 + interval, dd, family=poisson)))

## End(Not run)


## Piecewise constant hazard and time-varying effect of z1
m &lt;- lvm(y~1)
distribution(m,~z1) &lt;- Binary.lvm(0.5)
R &lt;- log(cbind(c(0.2,0.7,0.9),c(0.5,0.3,0.3)))
m &lt;- timedep(m,y~z1,timecut=c(0,3,5),rate=R)

## Not run: 
d &lt;- sim(m,1e4); d$status &lt;- TRUE
dd &lt;- mets::lifetable(Surv(y,status)~z1,data=d,breaks=c(0,3,5,Inf));
exp(coef(glm(events ~ offset(log(atrisk)) + -1 + interval+z1:interval, dd, family=poisson)))

## End(Not run)



## Explicit simulation of time-varying effects
m &lt;- lvm(y~1)
distribution(m,~z1) &lt;- Binary.lvm(0.5)
distribution(m,~z2) &lt;- binomial.lvm(p=0.5)
#variance(m,~m1+m2) &lt;- 0
#regression(m,m1[m1:0] ~ z1) &lt;- log(0.5)
#regression(m,m2[m2:0] ~ z1) &lt;- log(0.3)
regression(m,m1 ~ z1,variance=0) &lt;- log(0.5)
regression(m,m2 ~ z1,variance=0) &lt;- log(0.3)
intercept(m,~m1+m2) &lt;- c(-0.5,0)
m &lt;- timedep(m,y~m1+m2,timecut=c(0,5))

## Not run: 
d &lt;- sim(m,1e5); d$status &lt;- TRUE
dd &lt;- mets::lifetable(Surv(y,status)~z1,data=d,breaks=c(0,5,Inf))
exp(coef(glm(events ~ offset(log(atrisk)) + -1 + interval + interval:z1, dd, family=poisson)))

## End(Not run)
</code></pre>

<hr>
<h2 id='toformula'>Converts strings to formula</h2><span id='topic+toformula'></span>

<h3>Description</h3>

<p>Converts a vector of predictors and a vector of responses (characters) i#nto
a formula expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toformula(y = ".", x = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toformula_+3A_y">y</code></td>
<td>
<p>vector of predictors</p>
</td></tr>
<tr><td><code id="toformula_+3A_x">x</code></td>
<td>
<p>vector of responses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>formula</code>
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+as.formula">as.formula</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
toformula(c("age","gender"), "weight")

</code></pre>

<hr>
<h2 id='tr'>Trace operator</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Calculates the trace of a square matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_x">x</code></td>
<td>
<p>Square numeric matrix</p>
</td></tr>
<tr><td><code id="tr_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numeric</code>
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+crossprod">crossprod</a></code>, <code><a href="base.html#topic+tcrossprod">tcrossprod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tr(diag(1:5))
</code></pre>

<hr>
<h2 id='trim'>Trim string of (leading/trailing/all) white spaces</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>Trim string of (leading/trailing/all) white spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x, all = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>String</p>
</td></tr>
<tr><td><code id="trim_+3A_all">all</code></td>
<td>
<p>Trim all whitespaces?</p>
</td></tr>
<tr><td><code id="trim_+3A_...">...</code></td>
<td>
<p>additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='twindata'>Twin menarche data</h2><span id='topic+twindata'></span>

<h3>Description</h3>

<p>Simulated data
</p>

<table>
<tr>
 <td style="text-align: right;">
        id    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Twin-pair id </td>
</tr>
<tr>
 <td style="text-align: right;">
        zyg    </td><td style="text-align: left;"> character </td><td style="text-align: left;"> Zygosity (MZ or DZ) </td>
</tr>
<tr>
 <td style="text-align: right;">
        twinnum    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Twin number (1 or 2) </td>
</tr>
<tr>
 <td style="text-align: right;">
        agemena    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Age at menarche (or censoring) </td>
</tr>
<tr>
 <td style="text-align: right;">
        status    </td><td style="text-align: left;"> logical </td><td style="text-align: left;"> Censoring status (observed:=T,censored:=F) </td>
</tr>
<tr>
 <td style="text-align: right;">
        bw    </td><td style="text-align: left;"> numeric  </td><td style="text-align: left;"> Birth weight </td>
</tr>
<tr>
 <td style="text-align: right;">
        msmoke    </td><td style="text-align: left;"> numeric </td><td style="text-align: left;"> Did mother smoke? (yes:=1,no:=0) </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Format</h3>

<p>data.frame
</p>


<h3>Source</h3>

<p>Simulated
</p>

<hr>
<h2 id='twostage'>Two-stage estimator</h2><span id='topic+twostage'></span>

<h3>Description</h3>

<p>Generic function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twostage(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twostage_+3A_object">object</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="twostage_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>twostage.lvm twostage.lvmfit twostage.lvm.mixture twostage.estimate
</p>

<hr>
<h2 id='twostage.lvmfit'>Two-stage estimator (non-linear SEM)</h2><span id='topic+twostage.lvmfit'></span><span id='topic+twostage.lvm'></span><span id='topic+twostage.lvm.mixture'></span><span id='topic+twostage.estimate'></span><span id='topic+nonlinear'></span><span id='topic+nonlinear+3C-'></span>

<h3>Description</h3>

<p>Two-stage estimator for non-linear structural equation models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lvmfit'
twostage(
  object,
  model2,
  data = NULL,
  predict.fun = NULL,
  id1 = NULL,
  id2 = NULL,
  all = FALSE,
  formula = NULL,
  std.err = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twostage.lvmfit_+3A_object">object</code></td>
<td>
<p>Stage 1 measurement model</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_model2">model2</code></td>
<td>
<p>Stage 2 SEM</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_predict.fun">predict.fun</code></td>
<td>
<p>Prediction of latent variable</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_id1">id1</code></td>
<td>
<p>Optional id-variable (stage 1 model)</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_id2">id2</code></td>
<td>
<p>Optional id-variable (stage 2 model)</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_all">all</code></td>
<td>
<p>If TRUE return additional output (naive estimates)</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_formula">formula</code></td>
<td>
<p>optional formula specifying non-linear relation</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_std.err">std.err</code></td>
<td>
<p>If FALSE calculations of standard errors will be skipped</p>
</td></tr>
<tr><td><code id="twostage.lvmfit_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- lvm(c(x1,x2,x3)~f1,f1~z,
         c(y1,y2,y3)~f2,f2~f1+z)
latent(m) &lt;- ~f1+f2
d &lt;- simulate(m,100,p=c("f2,f2"=2,"f1,f1"=0.5),seed=1)

## Full MLE
ee &lt;- estimate(m,d)

## Manual two-stage
## Not run: 
m1 &lt;- lvm(c(x1,x2,x3)~f1,f1~z); latent(m1) &lt;- ~f1
e1 &lt;- estimate(m1,d)
pp1 &lt;- predict(e1,f1~x1+x2+x3)

d$u1 &lt;- pp1[,]
d$u2 &lt;- pp1[,]^2+attr(pp1,"cond.var")[1]
m2 &lt;- lvm(c(y1,y2,y3)~eta,c(y1,eta)~u1+u2+z); latent(m2) &lt;- ~eta
e2 &lt;- estimate(m2,d)

## End(Not run)

## Two-stage
m1 &lt;- lvm(c(x1,x2,x3)~f1,f1~z); latent(m1) &lt;- ~f1
m2 &lt;- lvm(c(y1,y2,y3)~eta,c(y1,eta)~u1+u2+z); latent(m2) &lt;- ~eta
pred &lt;- function(mu,var,data,...)
    cbind("u1"=mu[,1],"u2"=mu[,1]^2+var[1])
(mm &lt;- twostage(m1,model2=m2,data=d,predict.fun=pred))

if (interactive()) {
    pf &lt;- function(p) p["eta"]+p["eta~u1"]*u + p["eta~u2"]*u^2
    plot(mm,f=pf,data=data.frame(u=seq(-2,2,length.out=100)),lwd=2)
}

 ## Reduce test timing
## Splines
f &lt;- function(x) cos(2*x)+x+-0.25*x^2
m &lt;- lvm(x1+x2+x3~eta1, y1+y2+y3~eta2, latent=~eta1+eta2)
functional(m, eta2~eta1) &lt;- f
d &lt;- sim(m,500,seed=1,latent=TRUE)
m1 &lt;- lvm(x1+x2+x3~eta1,latent=~eta1)
m2 &lt;- lvm(y1+y2+y3~eta2,latent=~eta2)
mm &lt;- twostage(m1,m2,formula=eta2~eta1,type="spline")
if (interactive()) plot(mm)

nonlinear(m2,type="quadratic") &lt;- eta2~eta1
a &lt;- twostage(m1,m2,data=d)
if (interactive()) plot(a)

kn &lt;- c(-1,0,1)
nonlinear(m2,type="spline",knots=kn) &lt;- eta2~eta1
a &lt;- twostage(m1,m2,data=d)
x &lt;- seq(-3,3,by=0.1)
y &lt;- predict(a, newdata=data.frame(eta1=x))

if (interactive()) {
  plot(eta2~eta1, data=d)
  lines(x,y, col="red", lwd=5)

  p &lt;- estimate(a,f=function(p) predict(a,p=p,newdata=x))$coefmat
  plot(eta2~eta1, data=d)
  lines(x,p[,1], col="red", lwd=5)
  confband(x,lower=p[,3],upper=p[,4],center=p[,1], polygon=TRUE, col=Col(2,0.2))

  l1 &lt;- lm(eta2~splines::ns(eta1,knots=kn),data=d)
  p1 &lt;- predict(l1,newdata=data.frame(eta1=x),interval="confidence")
  lines(x,p1[,1],col="green",lwd=5)
  confband(x,lower=p1[,2],upper=p1[,3],center=p1[,1], polygon=TRUE, col=Col(3,0.2))
}
 ## Reduce test timing

## Not run:  ## Reduce timing
 ## Cross-validation example
 ma &lt;- lvm(c(x1,x2,x3)~u,latent=~u)
 ms &lt;- functional(ma, y~u, value=function(x) -.4*x^2)
 d &lt;- sim(ms,500)#,seed=1)
 ea &lt;- estimate(ma,d)

 mb &lt;- lvm()
 mb1 &lt;- nonlinear(mb,type="linear",y~u)
 mb2 &lt;- nonlinear(mb,type="quadratic",y~u)
 mb3 &lt;- nonlinear(mb,type="spline",knots=c(-3,-1,0,1,3),y~u)
 mb4 &lt;- nonlinear(mb,type="spline",knots=c(-3,-2,-1,0,1,2,3),y~u)
 ff &lt;- lapply(list(mb1,mb2,mb3,mb4),
      function(m) function(data,...) twostage(ma,m,data=data,st.derr=FALSE))
 a &lt;- cv(ff,data=d,rep=1)
 a

## End(Not run)
</code></pre>

<hr>
<h2 id='twostageCV'>Cross-validated two-stage estimator</h2><span id='topic+twostageCV'></span>

<h3>Description</h3>

<p>Cross-validated two-stage estimator for non-linear SEM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twostageCV(
  model1,
  model2,
  data,
  control1 = list(trace = 0),
  control2 = list(trace = 0),
  knots.boundary,
  nmix = 1:4,
  df = 1:9,
  fix = TRUE,
  std.err = TRUE,
  nfolds = 5,
  rep = 1,
  messages = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twostageCV_+3A_model1">model1</code></td>
<td>
<p>model 1 (exposure measurement error model)</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_model2">model2</code></td>
<td>
<p>model 2</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_control1">control1</code></td>
<td>
<p>optimization parameters for model 1</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_control2">control2</code></td>
<td>
<p>optimization parameters for model 1</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_knots.boundary">knots.boundary</code></td>
<td>
<p>boundary points for natural cubic spline basis</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_nmix">nmix</code></td>
<td>
<p>number of mixture components</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_df">df</code></td>
<td>
<p>spline degrees of freedom</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_fix">fix</code></td>
<td>
<p>automatically fix parameters for identification (TRUE)</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_std.err">std.err</code></td>
<td>
<p>calculation of standard errors (TRUE)</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_nfolds">nfolds</code></td>
<td>
<p>Number of folds (cross-validation)</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_rep">rep</code></td>
<td>
<p>Number of repeats of cross-validation</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_messages">messages</code></td>
<td>
<p>print information (&gt;0)</p>
</td></tr>
<tr><td><code id="twostageCV_+3A_...">...</code></td>
<td>
<p>additional arguments to lower</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> ## Reduce Ex.Timings##'
m1 &lt;- lvm( x1+x2+x3 ~ u, latent= ~u)
m2 &lt;- lvm( y ~ 1 )
m &lt;- functional(merge(m1,m2), y ~ u, value=function(x) sin(x)+x)
distribution(m, ~u1) &lt;- uniform.lvm(-6,6)
d &lt;- sim(m,n=500,seed=1)
nonlinear(m2) &lt;- y~u1
if (requireNamespace('mets', quietly=TRUE)) {
  set.seed(1)
  val &lt;- twostageCV(m1, m2, data=d, std.err=FALSE, df=2:6, nmix=1:2,
                  nfolds=2)
  val
}

</code></pre>

<hr>
<h2 id='vars'>Extract variable names from latent variable model</h2><span id='topic+vars'></span><span id='topic+vars.lvm'></span><span id='topic+vars.lvmfit'></span><span id='topic+latent'></span><span id='topic+latent+3C-'></span><span id='topic+latent.lvm'></span><span id='topic+latent+3C-.lvm'></span><span id='topic+latent.lvmfit'></span><span id='topic+latent.multigroup'></span><span id='topic+manifest'></span><span id='topic+manifest.lvm'></span><span id='topic+manifest.lvmfit'></span><span id='topic+manifest.multigroup'></span><span id='topic+exogenous'></span><span id='topic+exogenous+3C-'></span><span id='topic+exogenous.lvm'></span><span id='topic+exogenous+3C-.lvm'></span><span id='topic+exogenous.lvmfit'></span><span id='topic+exogenous.multigroup'></span><span id='topic+endogenous'></span><span id='topic+endogenous.lvm'></span><span id='topic+endogenous.lvmfit'></span><span id='topic+endogenous.multigroup'></span>

<h3>Description</h3>

<p>Extract exogenous variables (predictors), endogenous variables (outcomes),
latent variables (random effects), manifest (observed) variables from a
<code>lvm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vars(x,...)

endogenous(x,...)

exogenous(x,...)

manifest(x,...)

latent(x,...)

## S3 replacement method for class 'lvm'
exogenous(x, xfree = TRUE,...) &lt;- value

## S3 method for class 'lvm'
exogenous(x,variable,latent=FALSE,index=TRUE,...)

## S3 replacement method for class 'lvm'
latent(x,clear=FALSE,...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vars_+3A_x">x</code></td>
<td>
<p><code>lvm</code>-object</p>
</td></tr>
<tr><td><code id="vars_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the low level functions</p>
</td></tr>
<tr><td><code id="vars_+3A_variable">variable</code></td>
<td>
<p>list of variables to alter</p>
</td></tr>
<tr><td><code id="vars_+3A_latent">latent</code></td>
<td>
<p>Logical defining whether latent variables without parents
should be included in the result</p>
</td></tr>
<tr><td><code id="vars_+3A_index">index</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="vars_+3A_clear">clear</code></td>
<td>
<p>Logical indicating whether to add or remove latent variable
status</p>
</td></tr>
<tr><td><code id="vars_+3A_xfree">xfree</code></td>
<td>
<p>For internal use only</p>
</td></tr>
<tr><td><code id="vars_+3A_value">value</code></td>
<td>
<p>Formula or character vector of variable names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>vars</code> returns all variables of the <code>lvm</code>-object including
manifest and latent variables. Similarily <code>manifest</code> and <code>latent</code>
returns the observered resp. latent variables of the model.
<code>exogenous</code> returns all manifest variables without parents, e.g.
covariates in the model, however the argument <code>latent=TRUE</code> can be used
to also include latent variables without parents in the result. Pr. default
<code>lava</code> will not include the parameters of the exogenous variables in
the optimisation routine during estimation (likelihood of the remaining
observered variables conditional on the covariates), however this behaviour
can be altered via the assignment function <code>exogenous&lt;-</code> telling
<code>lava</code> which subset of (valid) variables to condition on.  Finally
<code>latent</code> returns a vector with the names of the latent variables in
<code>x</code>. The assigment function <code>latent&lt;-</code> can be used to change the
latent status of variables in the model.
</p>


<h3>Value</h3>

<p>Vector of variable names.
</p>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>See Also</h3>

<p><code><a href="#topic+endogenous">endogenous</a></code>, <code><a href="#topic+manifest">manifest</a></code>,
<code><a href="#topic+latent">latent</a></code>, <code><a href="#topic+exogenous">exogenous</a></code>, <code><a href="#topic+vars">vars</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
g &lt;- lvm(eta1 ~ x1+x2)
regression(g) &lt;- c(y1,y2,y3) ~ eta1
latent(g) &lt;- ~eta1
endogenous(g)
exogenous(g)
identical(latent(g), setdiff(vars(g),manifest(g)))

</code></pre>

<hr>
<h2 id='vec'>vec operator</h2><span id='topic+vec'></span>

<h3>Description</h3>

<p>vec operator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec(x, matrix = FALSE, sep = ".", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_+3A_x">x</code></td>
<td>
<p>Array</p>
</td></tr>
<tr><td><code id="vec_+3A_matrix">matrix</code></td>
<td>
<p>If TRUE a row vector (matrix) is returned</p>
</td></tr>
<tr><td><code id="vec_+3A_sep">sep</code></td>
<td>
<p>Seperator</p>
</td></tr>
<tr><td><code id="vec_+3A_...">...</code></td>
<td>
<p>Additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convert array into vector
</p>


<h3>Author(s)</h3>

<p>Klaus Holst
</p>

<hr>
<h2 id='wait'>Wait for user input (keyboard or mouse)</h2><span id='topic+wait'></span><span id='topic+waitclick'></span>

<h3>Description</h3>

<p>Wait for user input (keyboard or mouse)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wait()
</code></pre>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='wkm'>Weighted K-means</h2><span id='topic+wkm'></span>

<h3>Description</h3>

<p>Weighted K-means via Lloyd's algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wkm(
  x,
  mu,
  data,
  weights = rep(1, NROW(x)),
  iter.max = 20,
  n.start = 5,
  init = "kmpp",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wkm_+3A_x">x</code></td>
<td>
<p>Data (or formula)</p>
</td></tr>
<tr><td><code id="wkm_+3A_mu">mu</code></td>
<td>
<p>Initial centers (or number centers chosen randomly among x)</p>
</td></tr>
<tr><td><code id="wkm_+3A_data">data</code></td>
<td>
<p>optional data frmae</p>
</td></tr>
<tr><td><code id="wkm_+3A_weights">weights</code></td>
<td>
<p>Optional weights</p>
</td></tr>
<tr><td><code id="wkm_+3A_iter.max">iter.max</code></td>
<td>
<p>Max number of iterations</p>
</td></tr>
<tr><td><code id="wkm_+3A_n.start">n.start</code></td>
<td>
<p>Number of restarts</p>
</td></tr>
<tr><td><code id="wkm_+3A_init">init</code></td>
<td>
<p>method to create initial centres (default kmeans++)</p>
</td></tr>
<tr><td><code id="wkm_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>

<hr>
<h2 id='wrapvec'>Wrap vector</h2><span id='topic+wrapvec'></span>

<h3>Description</h3>

<p>Wrap vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapvec(x, delta = 0L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrapvec_+3A_x">x</code></td>
<td>
<p>Vector or integer</p>
</td></tr>
<tr><td><code id="wrapvec_+3A_delta">delta</code></td>
<td>
<p>Shift</p>
</td></tr>
<tr><td><code id="wrapvec_+3A_...">...</code></td>
<td>
<p>Additional parameters</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>wrapvec(5,2)
</code></pre>

<hr>
<h2 id='zibreg'>Regression model for binomial data with unkown group of immortals</h2><span id='topic+zibreg'></span>

<h3>Description</h3>

<p>Regression model for binomial data with unkown group of immortals (zero-inflated binomial regression)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zibreg(
  formula,
  formula.p = ~1,
  data,
  family = stats::binomial(),
  offset = NULL,
  start,
  var = "hessian",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zibreg_+3A_formula">formula</code></td>
<td>
<p>Formula specifying</p>
</td></tr>
<tr><td><code id="zibreg_+3A_formula.p">formula.p</code></td>
<td>
<p>Formula for model of disease prevalence</p>
</td></tr>
<tr><td><code id="zibreg_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="zibreg_+3A_family">family</code></td>
<td>
<p>Distribution family (see the help page <code>family</code>)</p>
</td></tr>
<tr><td><code id="zibreg_+3A_offset">offset</code></td>
<td>
<p>Optional offset</p>
</td></tr>
<tr><td><code id="zibreg_+3A_start">start</code></td>
<td>
<p>Optional starting values</p>
</td></tr>
<tr><td><code id="zibreg_+3A_var">var</code></td>
<td>
<p>Type of variance (robust, expected, hessian, outer)</p>
</td></tr>
<tr><td><code id="zibreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to lower level functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus K. Holst
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulation
n &lt;- 2e3
x &lt;- runif(n,0,20)
age &lt;- runif(n,10,30)
z0 &lt;- rnorm(n,mean=-1+0.05*age)
z &lt;- cut(z0,breaks=c(-Inf,-1,0,1,Inf))
p0 &lt;- lava:::expit(model.matrix(~z+age) %*% c(-.4, -.4, 0.2, 2, -0.05))
y &lt;- (runif(n)&lt;lava:::tigol(-1+0.25*x-0*age))*1
u &lt;- runif(n)&lt;p0
y[u==0] &lt;- 0
d &lt;- data.frame(y=y,x=x,u=u*1,z=z,age=age)
head(d)

## Estimation
e0 &lt;- zibreg(y~x*z,~1+z+age,data=d)
e &lt;- zibreg(y~x,~1+z+age,data=d)
compare(e,e0)
e
PD(e0,intercept=c(1,3),slope=c(2,6))

B &lt;- rbind(c(1,0,0,0,20),
           c(1,1,0,0,20),
           c(1,0,1,0,20),
           c(1,0,0,1,20))
prev &lt;- summary(e,pr.contrast=B)$prevalence

x &lt;- seq(0,100,length.out=100)
newdata &lt;- expand.grid(x=x,age=20,z=levels(d$z))
fit &lt;- predict(e,newdata=newdata)
plot(0,0,type="n",xlim=c(0,101),ylim=c(0,1),xlab="x",ylab="Probability(Event)")
count &lt;- 0
for (i in levels(newdata$z)) {
  count &lt;- count+1
  lines(x,fit[which(newdata$z==i)],col="darkblue",lty=count)
}
abline(h=prev[3:4,1],lty=3:4,col="gray")
abline(h=prev[3:4,2],lty=3:4,col="lightgray")
abline(h=prev[3:4,3],lty=3:4,col="lightgray")
legend("topleft",levels(d$z),col="darkblue",lty=seq_len(length(levels(d$z))))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
