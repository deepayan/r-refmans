<!DOCTYPE html><html><head><title>Help for package rstatix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rstatix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_significance'><p>Add P-value Significance Symbols</p></a></li>
<li><a href='#adjust_pvalue'><p>Adjust P-values for Multiple Comparisons</p></a></li>
<li><a href='#anova_summary'><p>Create Nice Summary Tables of ANOVA Results</p></a></li>
<li><a href='#anova_test'><p>Anova Test</p></a></li>
<li><a href='#as_cor_mat'><p>Convert a Correlation Test Data Frame into a Correlation Matrix</p></a></li>
<li><a href='#binom_test'><p>Exact Binomial Test</p></a></li>
<li><a href='#box_m'><p>Box's M-test for Homogeneity of Covariance Matrices</p></a></li>
<li><a href='#chisq_test'><p>Chi-squared Test for Count Data</p></a></li>
<li><a href='#cochran_qtest'><p>Cochran's Q Test</p></a></li>
<li><a href='#cohens_d'><p>Compute Cohen's d Measure of Effect Size</p></a></li>
<li><a href='#convert_as_factor'><p>Factors</p></a></li>
<li><a href='#cor_as_symbols'><p>Replace Correlation Coefficients by Symbols</p></a></li>
<li><a href='#cor_gather'><p>Reshape Correlation Data</p></a></li>
<li><a href='#cor_mark_significant'><p>Add Significance Levels To a Correlation Matrix</p></a></li>
<li><a href='#cor_mat'><p>Compute Correlation Matrix with P-values</p></a></li>
<li><a href='#cor_plot'><p>Visualize Correlation Matrix Using Base Plot</p></a></li>
<li><a href='#cor_reorder'><p>Reorder Correlation Matrix</p></a></li>
<li><a href='#cor_select'><p>Subset Correlation Matrix</p></a></li>
<li><a href='#cor_test'><p>Correlation Test</p></a></li>
<li><a href='#counts_to_cases'><p>Convert a Table of Counts into a Data Frame of cases</p></a></li>
<li><a href='#cramer_v'><p>Compute Cramer's V</p></a></li>
<li><a href='#df_arrange'><p>Arrange Rows by Column Values</p></a></li>
<li><a href='#df_get_var_names'><p>Get User Specified Variable Names</p></a></li>
<li><a href='#df_group_by'><p>Group a Data Frame by One or more Variables</p></a></li>
<li><a href='#df_label_both'><p>Functions to Label Data Frames by Grouping Variables</p></a></li>
<li><a href='#df_nest_by'><p>Nest a Tibble By Groups</p></a></li>
<li><a href='#df_select'><p>Select Columns in a Data Frame</p></a></li>
<li><a href='#df_split_by'><p>Split a Data Frame into Subset</p></a></li>
<li><a href='#df_unite'><p>Unite Multiple Columns into One</p></a></li>
<li><a href='#doo'><p>Alternative to dplyr::do for Doing Anything</p></a></li>
<li><a href='#dunn_test'><p>Dunn's Test of Multiple Comparisons</p></a></li>
<li><a href='#emmeans_test'><p>Pairwise Comparisons of Estimated Marginal Means</p></a></li>
<li><a href='#eta_squared'><p>Effect Size for ANOVA</p></a></li>
<li><a href='#factorial_design'><p>Build Factorial Designs for ANOVA</p></a></li>
<li><a href='#fisher_test'><p>Fisher's Exact Test for Count Data</p></a></li>
<li><a href='#freq_table'><p>Compute Frequency Table</p></a></li>
<li><a href='#friedman_effsize'><p>Friedman Test Effect Size (Kendall's W Value)</p></a></li>
<li><a href='#friedman_test'><p>Friedman Rank Sum Test</p></a></li>
<li><a href='#games_howell_test'><p>Games Howell Post-hoc Tests</p></a></li>
<li><a href='#get_comparisons'><p>Create a List of Possible Comparisons Between Groups</p></a></li>
<li><a href='#get_mode'><p>Compute Mode</p></a></li>
<li><a href='#get_pwc_label'><p>Extract Label Information from Statistical Tests</p></a></li>
<li><a href='#get_summary_stats'><p>Compute Summary Statistics</p></a></li>
<li><a href='#get_y_position'><p>Autocompute P-value Positions For Plotting Significance</p></a></li>
<li><a href='#identify_outliers'><p>Identify Univariate Outliers Using Boxplot Methods</p></a></li>
<li><a href='#kruskal_effsize'><p>Kruskal-Wallis Effect Size</p></a></li>
<li><a href='#kruskal_test'><p>Kruskal-Wallis Test</p></a></li>
<li><a href='#levene_test'><p>Levene's Test</p></a></li>
<li><a href='#mahalanobis_distance'><p>Compute Mahalanobis Distance and Flag Multivariate Outliers</p></a></li>
<li><a href='#make_clean_names'><p>Make Clean Names</p></a></li>
<li><a href='#Manova'><p>Manova exported from car package</p></a></li>
<li><a href='#mcnemar_test'><p>McNemar's Chi-squared Test for Count Data</p></a></li>
<li><a href='#multinom_test'><p>Exact Multinomial Test</p></a></li>
<li><a href='#p_round'><p>Rounding and Formatting p-values</p></a></li>
<li><a href='#prop_test'><p>Proportion Test</p></a></li>
<li><a href='#prop_trend_test'><p>Test for Trend in Proportions</p></a></li>
<li><a href='#pull_triangle'><p>Pull Lower and Upper Triangular Part of a Matrix</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#remove_ns'><p>Remove Non-Significant from Statistical Tests</p></a></li>
<li><a href='#replace_triangle'><p>Replace Lower and Upper Triangular Part of a Matrix</p></a></li>
<li><a href='#sample_n_by'><p>Sample n Rows By Group From a Table</p></a></li>
<li><a href='#shapiro_test'><p>Shapiro-Wilk Normality Test</p></a></li>
<li><a href='#sign_test'><p>Sign Test</p></a></li>
<li><a href='#t_test'><p>T-test</p></a></li>
<li><a href='#tukey_hsd'><p>Tukey Honest Significant Differences</p></a></li>
<li><a href='#welch_anova_test'><p>Welch One-Way ANOVA Test</p></a></li>
<li><a href='#wilcox_effsize'><p>Wilcoxon Effect Size</p></a></li>
<li><a href='#wilcox_test'><p>Wilcoxon Tests</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Pipe-Friendly Framework for Basic Statistical Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>0.7.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a simple and intuitive pipe-friendly framework, coherent with the 'tidyverse' design philosophy, 
    for performing basic statistical tests, including t-test, Wilcoxon test, ANOVA, Kruskal-Wallis and correlation analyses. 
    The output of each test is automatically transformed into a tidy data frame to facilitate visualization. 
    Additional functions are available for reshaping, reordering, manipulating and visualizing correlation matrix.  
    Functions are also included to facilitate the analysis of factorial experiments, including purely 'within-Ss' designs 
    (repeated measures), purely 'between-Ss' designs, and mixed 'within-and-between-Ss' designs. 
    It's also possible to compute several effect size metrics, including "eta squared" for ANOVA, "Cohen's d" for t-test and 
    'Cramer V' for the association between categorical variables. 
    The package contains helper functions for identifying univariate and multivariate outliers, assessing normality and homogeneity of variances.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, tidyr (&ge; 1.0.0), purrr, broom (&ge; 0.7.4), rlang
(&ge; 0.3.1), tibble (&ge; 2.1.3), dplyr (&ge; 0.7.1), magrittr,
corrplot, tidyselect (&ge; 1.2.0), car, generics (&ge; 0.0.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggpubr, graphics, emmeans, coin, boot,
testthat, spelling</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rpkgs.datanovia.com/rstatix/">https://rpkgs.datanovia.com/rstatix/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kassambara/rstatix/issues">https://github.com/kassambara/rstatix/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'utilities.R' 'add_significance.R' 'adjust_pvalue.R'
'factorial_design.R' 'utilities_two_sample_test.R'
'anova_summary.R' 'anova_test.R' 'as_cor_mat.R' 'binom_test.R'
'box_m.R' 'chisq_test.R' 'cochran_qtest.R' 'cohens_d.R'
'cor_as_symbols.R' 'replace_triangle.R' 'pull_triangle.R'
'cor_mark_significant.R' 'cor_mat.R' 'cor_plot.R'
'cor_reorder.R' 'cor_reshape.R' 'cor_select.R' 'cor_test.R'
'counts_to_cases.R' 'cramer_v.R' 'df.R' 'doo.R' 't_test.R'
'dunn_test.R' 'emmeans_test.R' 'eta_squared.R' 'factors.R'
'fisher_test.R' 'freq_table.R' 'friedman_test.R'
'friedman_effsize.R' 'games_howell_test.R' 'get_comparisons.R'
'get_manova_table.R' 'get_mode.R' 'get_pvalue_position.R'
'get_summary_stats.R' 'get_test_label.R' 'kruskal_effesize.R'
'kruskal_test.R' 'levene_test.R' 'mahalanobis_distance.R'
'make_clean_names.R' 'mcnemar_test.R' 'multinom_test.R'
'outliers.R' 'p_value.R' 'prop_test.R' 'prop_trend_test.R'
'reexports.R' 'remove_ns.R' 'sample_n_by.R' 'shapiro_test.R'
'sign_test.R' 'tukey_hsd.R' 'utils-manova.R' 'utils-pipe.R'
'welch_anova_test.R' 'wilcox_effsize.R' 'wilcox_test.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-01 20:38:22 UTC; kassambara</td>
</tr>
<tr>
<td>Author:</td>
<td>Alboukadel Kassambara [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alboukadel Kassambara &lt;alboukadel.kassambara@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-01 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='add_significance'>Add P-value Significance Symbols</h2><span id='topic+add_significance'></span>

<h3>Description</h3>

<p>Add p-value significance symbols into a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_significance(
  data,
  p.col = NULL,
  output.col = NULL,
  cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1),
  symbols = c("****", "***", "**", "*", "ns")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_significance_+3A_data">data</code></td>
<td>
<p>a data frame containing a p-value column.</p>
</td></tr>
<tr><td><code id="add_significance_+3A_p.col">p.col</code></td>
<td>
<p>column name containing p-values.</p>
</td></tr>
<tr><td><code id="add_significance_+3A_output.col">output.col</code></td>
<td>
<p>the output column name to hold the adjusted p-values.</p>
</td></tr>
<tr><td><code id="add_significance_+3A_cutpoints">cutpoints</code></td>
<td>
<p>numeric vector used for intervals.</p>
</td></tr>
<tr><td><code id="add_significance_+3A_symbols">symbols</code></td>
<td>
<p>character vector, one shorter than cutpoints, used as
significance symbols.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform pairwise comparisons and adjust p-values
ToothGrowth %&gt;%
 t_test(len ~ dose) %&gt;%
 adjust_pvalue() %&gt;%
 add_significance("p.adj")

</code></pre>

<hr>
<h2 id='adjust_pvalue'>Adjust P-values for Multiple Comparisons</h2><span id='topic+adjust_pvalue'></span>

<h3>Description</h3>

<p>A pipe-friendly function to add an adjusted p-value column into
a data frame. Supports grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_pvalue(data, p.col = NULL, output.col = NULL, method = "holm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjust_pvalue_+3A_data">data</code></td>
<td>
<p>a data frame containing a p-value column</p>
</td></tr>
<tr><td><code id="adjust_pvalue_+3A_p.col">p.col</code></td>
<td>
<p>column name containing p-values</p>
</td></tr>
<tr><td><code id="adjust_pvalue_+3A_output.col">output.col</code></td>
<td>
<p>the output column name to hold the adjusted p-values</p>
</td></tr>
<tr><td><code id="adjust_pvalue_+3A_method">method</code></td>
<td>
<p>method for adjusting p values (see
<code><a href="stats.html#topic+p.adjust">p.adjust</a></code>). Allowed values include &quot;holm&quot;, &quot;hochberg&quot;,
&quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't want to
adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Perform pairwise comparisons and adjust p-values
ToothGrowth %&gt;%
 t_test(len ~ dose) %&gt;%
 adjust_pvalue()

</code></pre>

<hr>
<h2 id='anova_summary'>Create Nice Summary Tables of ANOVA Results</h2><span id='topic+anova_summary'></span>

<h3>Description</h3>

<p>Create beautiful summary tables of ANOVA test results obtained
from either <code><a href="car.html#topic+Anova">Anova</a>()</code> or <code><a href="stats.html#topic+aov">aov</a>()</code>.
</p>
<p>The results include ANOVA table, generalized effect size and some assumption
checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_summary(object, effect.size = "ges", detailed = FALSE, observed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_summary_+3A_object">object</code></td>
<td>
<p>an object of returned by either <code><a href="car.html#topic+Anova">Anova</a>()</code>, or
<code><a href="stats.html#topic+aov">aov</a>()</code>.</p>
</td></tr>
<tr><td><code id="anova_summary_+3A_effect.size">effect.size</code></td>
<td>
<p>the effect size to compute and to show in the ANOVA
results. Allowed values can be either &quot;ges&quot; (generalized eta squared) or
&quot;pes&quot; (partial eta squared) or both. Default is &quot;ges&quot;.</p>
</td></tr>
<tr><td><code id="anova_summary_+3A_detailed">detailed</code></td>
<td>
<p>If TRUE, returns extra information (sums of squares columns,
intercept row, etc.) in the ANOVA table.</p>
</td></tr>
<tr><td><code id="anova_summary_+3A_observed">observed</code></td>
<td>
<p>Variables that are observed (i.e, measured) as compared to
experimentally manipulated. The default effect size reported (generalized
eta-squared) requires correct specification of the observed variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return an object of class <code>anova_test</code> a data frame containing
the ANOVA table for independent measures ANOVA. However, for repeated/mixed
measures ANOVA, it is a list containing the following components are
returned:
</p>
 <ul>
<li> <p><strong>ANOVA</strong>: a data frame containing ANOVA results </p>
</li>
<li>
<p><strong>Mauchly's Test for Sphericity</strong>: If any within-Ss variables with more
than 2 levels are present, a data frame containing the results of Mauchly's
test for Sphericity. Only reported for effects that have more than 2 levels
because sphericity necessarily holds for effects with only 2 levels. </p>
</li>
<li>
<p><strong>Sphericity Corrections</strong>: If any within-Ss variables are present, a
data frame containing the Greenhouse-Geisser and Huynh-Feldt epsilon values,
and corresponding corrected p-values. </p>
</li></ul>

<p>The <strong>returned object might have an attribute</strong> called <code>args</code> if
you compute ANOVA using the function <code><a href="#topic+anova_test">anova_test</a>()</code>. The attribute <code>args</code> is a
list holding the arguments used to fit the ANOVA model, including: data, dv,
within, between, type, model, etc.
</p>
<p>The following abbreviations are used in the different results tables:
</p>
 <ul>
<li><p> DFn	Degrees of Freedom in the numerator (i.e. DF effect).
</p>
</li>
<li><p> DFd	Degrees of Freedom in the denominator (i.e., DF error). </p>
</li>
<li>
<p>SSn	Sum of Squares in the numerator (i.e., SS effect). </p>
</li>
<li><p> SSd	Sum of
Squares in the denominator (i.e.,SS error). </p>
</li>
<li><p> F	F-value. </p>
</li>
<li><p> p	p-value
(probability of the data given the null hypothesis). </p>
</li>
<li><p> p&lt;.05	Highlights
p-values less than the traditional alpha level of .05. </p>
</li>
<li><p> ges	Generalized
Eta-Squared measure of effect size. </p>
</li>
<li><p> GGe	Greenhouse-Geisser epsilon.
</p>
</li>
<li><p> p[GGe]	p-value after correction using Greenhouse-Geisser epsilon.
</p>
</li>
<li><p> p[GGe]&lt;.05	Highlights p-values (after correction using
Greenhouse-Geisser epsilon) less than the traditional alpha level of .05.
</p>
</li>
<li><p> HFe	Huynh-Feldt epsilon. </p>
</li>
<li><p> p[HFe]	p-value after correction using
Huynh-Feldt epsilon. </p>
</li>
<li><p> p[HFe]&lt;.05	Highlights p-values (after correction
using Huynh-Feldt epsilon) less than the traditional alpha level of .05.
</p>
</li>
<li><p> W	Mauchly's W statistic </p>
</li></ul>



<h3>Author(s)</h3>

<p>Alboukadel Kassambara, <a href="mailto:alboukadel.kassambara@gmail.com">alboukadel.kassambara@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova_test">anova_test</a>()</code>, <code><a href="#topic+factorial_design">factorial_design</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)

# Independent measures ANOVA
#:::::::::::::::::::::::::::::::::::::::::
# Compute ANOVA and display the summary
res.anova &lt;- Anova(lm(len ~ dose*supp, data = df))
anova_summary(res.anova)

# Display both SSn and SSd using detailed = TRUE
# Show generalized eta squared using effect.size = "ges"
anova_summary(res.anova, detailed = TRUE, effect.size = "ges")

# Show partial eta squared using effect.size = "pes"
anova_summary(res.anova, detailed = TRUE, effect.size = "pes")

# Repeated measures designs using car::Anova()
#:::::::::::::::::::::::::::::::::::::::::
# Prepare the data
df$id &lt;- as.factor(rep(1:10, 6)) # Add individuals ids
head(df)

# Easily perform repeated measures ANOVA using the car package
design &lt;- factorial_design(df, dv = len, wid = id, within = c(supp, dose))
res.anova &lt;- Anova(design$model, idata = design$idata, idesign = design$idesign, type = 3)
anova_summary(res.anova)

# Repeated measures designs using stats::Aov()
#:::::::::::::::::::::::::::::::::::::::::
res.anova &lt;- aov(len ~ dose*supp + Error(id/(supp*dose)), data = df)
anova_summary(res.anova)
</code></pre>

<hr>
<h2 id='anova_test'>Anova Test</h2><span id='topic+anova_test'></span><span id='topic+get_anova_table'></span><span id='topic+print.anova_test'></span><span id='topic+plot.anova_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to perform different types of
ANOVA tests, including: </p>
 <ul>
<li>
<p><strong><a href="https://www.datanovia.com/en/lessons/anova-in-r/">Independent
measures ANOVA</a></strong>: between-Subjects designs, </p>
</li>
<li>
<p><strong><a href="https://www.datanovia.com/en/lessons/repeated-measures-anova-in-r/">Repeated
measures ANOVA</a></strong>: within-Subjects designs </p>
</li>
<li>
<p><strong><a href="https://www.datanovia.com/en/lessons/mixed-anova-in-r/">Mixed
ANOVA</a></strong>: Mixed within within- and between-Subjects designs, also known as
split-plot ANOVA and </p>
</li>
<li>
<p><strong><a href="https://www.datanovia.com/en/lessons/ancova-in-r/">ANCOVA:
Analysis of Covariance</a></strong>. </p>
</li></ul>

<p>The function is an easy to use wrapper around <code><a href="car.html#topic+Anova">Anova</a>()</code> and
<code><a href="stats.html#topic+aov">aov</a>()</code>. It makes ANOVA computation handy in R and It's
highly flexible: can support model and formula as input. Variables can be
also specified as character vector using the arguments <code>dv, wid,
 between, within, covariate</code>.
</p>
<p>The results include ANOVA table, generalized effect size and some assumption
checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anova_test(
  data,
  formula,
  dv,
  wid,
  between,
  within,
  covariate,
  type = NULL,
  effect.size = "ges",
  error = NULL,
  white.adjust = FALSE,
  observed = NULL,
  detailed = FALSE
)

get_anova_table(x, correction = c("auto", "GG", "HF", "none"))

## S3 method for class 'anova_test'
print(x, ...)

## S3 method for class 'anova_test'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova_test_+3A_data">data</code></td>
<td>
<p>a data.frame or a model to be analyzed.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the ANOVA model similar to
<a href="stats.html#topic+aov">aov</a>. Can be of the form <code>y ~ group</code> where <code>y</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.
</p>
<p>Examples of supported formula include: </p>
 <ul>
<li><p> Between-Ss ANOVA
(independent measures ANOVA): <code>y ~ b1*b2</code> </p>
</li>
<li><p> Within-Ss ANOVA
(repeated measures ANOVA): <code>y ~ w1*w2 + Error(id/(w1*w2))</code> </p>
</li>
<li><p> Mixed
ANOVA: <code>y ~ b1*b2*w1 + Error(id/w1)</code> </p>
</li></ul>

<p>If the formula doesn't contain any within vars, a linear model is directly
fitted and  passed to the ANOVA function. For repeated designs, the ANOVA
variables are parsed from the formula.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_dv">dv</code></td>
<td>
<p>(numeric) dependent variable name.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_wid">wid</code></td>
<td>
<p>(factor) column name containing individuals/subjects identifier.
Should be unique per individual.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_between">between</code></td>
<td>
<p>(optional) between-subject factor variables.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_within">within</code></td>
<td>
<p>(optional) within-subjects factor variables</p>
</td></tr>
<tr><td><code id="anova_test_+3A_covariate">covariate</code></td>
<td>
<p>(optional) covariate names (for ANCOVA)</p>
</td></tr>
<tr><td><code id="anova_test_+3A_type">type</code></td>
<td>
<p>the type of sums of squares for ANOVA. Allowed values are either
1, 2 or 3. <code>type = 2</code> is the default because this will yield identical
ANOVA results as type = 1 when data are balanced but type = 2 will
additionally yield various assumption tests where appropriate. When the data
are unbalanced the <code>type = 3</code> is used by popular commercial softwares
including SPSS.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_effect.size">effect.size</code></td>
<td>
<p>the effect size to compute and to show in the ANOVA
results. Allowed values can be either &quot;ges&quot; (generalized eta squared) or
&quot;pes&quot; (partial eta squared) or both. Default is &quot;ges&quot;.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_error">error</code></td>
<td>
<p>(optional) for a linear model, an lm model object from which the
overall error sum of squares and degrees of freedom are to be calculated.
Read more in <code><a href="car.html#topic+Anova">Anova</a>()</code> documentation.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_white.adjust">white.adjust</code></td>
<td>
<p>Default is FALSE. If TRUE, heteroscedasticity correction
is applied to the coefficient of covariance matrix. Used only for
independent measures ANOVA.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_observed">observed</code></td>
<td>
<p>Variables that are observed (i.e, measured) as compared to
experimentally manipulated. The default effect size reported (generalized
eta-squared) requires correct specification of the observed variables.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_detailed">detailed</code></td>
<td>
<p>If TRUE, returns extra information (sums of squares columns,
intercept row, etc.) in the ANOVA table.</p>
</td></tr>
<tr><td><code id="anova_test_+3A_x">x</code></td>
<td>
<p>an object of class <code>anova_test</code></p>
</td></tr>
<tr><td><code id="anova_test_+3A_correction">correction</code></td>
<td>
<p>character. Used only in repeated measures ANOVA test to
specify which correction of the degrees of freedom should be reported for
the within-subject factors. Possible values are: </p>
 <ul>
<li><p>&quot;GG&quot;:
applies Greenhouse-Geisser correction to all within-subjects factors even if
the assumption of sphericity is met (i.e., Mauchly's test is not
significant, p &gt; 0.05). </p>
</li>
<li><p>&quot;HF&quot;: applies Hyunh-Feldt correction to all
within-subjects factors even if the assumption of sphericity is met,
</p>
</li>
<li><p>&quot;none&quot;: returns the ANOVA table without any correction and
</p>
</li>
<li><p>&quot;auto&quot;: apply automatically GG correction to only within-subjects
factors violating the sphericity assumption (i.e., Mauchly's test p-value is
significant, p &lt;= 0.05). </p>
</li></ul>
</td></tr>
<tr><td><code id="anova_test_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The setting in <code>anova_test()</code> is done in such a way that it
gives the same results as SPSS, one of the most used commercial software. By
default, R uses treatment contrasts, where each of the levels is compared to
the first level used as baseline. The default contrast can be checked using
<code>options('contrasts')</code>. In the function <code>anova_test()</code>, the
following setting is used
<code>options(contrasts=c('contr.sum','contr.poly'))</code>, which gives
orthogonal contrasts where you compare every level to the overall mean. This
setting gives the same output as the most commonly used commercial
softwares, like SPSS. If you want to obtain the same result with the
function <code>car::Anova()</code> as the one obtained with
<code>rstatix::anova_test()</code>, then don't forget to set
<code>options(contrasts=c('contr.sum','contr.poly'))</code>.
</p>


<h3>Value</h3>

<p>return an object of class <code>anova_test</code> a data frame containing
the ANOVA table for independent measures ANOVA.
</p>
<p>However, for repeated/mixed measures ANOVA, a list containing the following
components are returned: ANOVA table, Mauchly's Test for Sphericity,
Sphericity Corrections. These table are described more in the documentation
of the function <code><a href="#topic+anova_summary">anova_summary</a>()</code>.
</p>
<p>The <strong>returned object has an attribute</strong> called <code>args</code>, which is a
list holding the arguments used to fit the ANOVA model, including: data, dv,
within, between, type, model, etc.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>anova_test()</code>: perform anova test
</p>
</li>
<li> <p><code>get_anova_table()</code>: extract anova table from an object of class
<code>anova_test</code>. When within-subject factors are present, either
sphericity corrected or uncorrected degrees of freedom can be reported.
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Alboukadel Kassambara, <a href="mailto:alboukadel.kassambara@gmail.com">alboukadel.kassambara@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova_summary">anova_summary</a>()</code>, <code><a href="#topic+factorial_design">factorial_design</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# One-way ANOVA test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% anova_test(len ~ dose)

# Grouped One-way ANOVA test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;%
  group_by(supp) %&gt;%
  anova_test(len ~ dose)

# Two-way ANOVA test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% anova_test(len ~ supp*dose)

# Two-way repeated measures ANOVA
#:::::::::::::::::::::::::::::::::::::::::
df$id &lt;- rep(1:10, 6) # Add individuals id
# Use formula

df %&gt;% anova_test(len ~ supp*dose + Error(id/(supp*dose)))



# or use character vector
df %&gt;% anova_test(dv = len, wid = id, within = c(supp, dose))

# Extract ANOVA table and apply correction
#:::::::::::::::::::::::::::::::::::::::::
res.aov &lt;- df %&gt;% anova_test(dv = len, wid = id, within = c(supp, dose))
get_anova_table(res.aov, correction = "GG")


# Use model as arguments
#:::::::::::::::::::::::::::::::::::::::::
.my.model &lt;- lm(yield ~ block + N*P*K, npk)
anova_test(.my.model)


</code></pre>

<hr>
<h2 id='as_cor_mat'>Convert a Correlation Test Data Frame into a Correlation Matrix</h2><span id='topic+as_cor_mat'></span>

<h3>Description</h3>

<p>Convert a correlation test data frame, returned by the
<code><a href="#topic+cor_test">cor_test</a>()</code>, into a correlation matrix format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cor_mat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_cor_mat_+3A_x">x</code></td>
<td>
<p>an object of class <code>cor_test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame containing the matrix of the correlation
coefficients. The output has an attribute named &quot;pvalue&quot;, which contains
the matrix of the correlation test p-values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>, <code><a href="#topic+cor_test">cor_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pairwise correlation tests between variables
#:::::::::::::::::::::::::::::::::::::::::::::::
res.cor.test &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_test()
res.cor.test

# Convert the correlation test into a correlation matrix
#:::::::::::::::::::::::::::::::::::::::::::::::
res.cor.test %&gt;% as_cor_mat()

</code></pre>

<hr>
<h2 id='binom_test'>Exact Binomial Test</h2><span id='topic+binom_test'></span><span id='topic+pairwise_binom_test'></span><span id='topic+pairwise_binom_test_against_p'></span>

<h3>Description</h3>

<p>Performs exact binomial test and pairwise comparisons following a
significant exact multinomial test. Wrapper around the R base function
<code>link[stats]{binom.test}()</code> that returns a data frame as a result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom_test(
  x,
  n,
  p = 0.5,
  alternative = "two.sided",
  conf.level = 0.95,
  detailed = FALSE
)

pairwise_binom_test(
  x,
  p.adjust.method = "holm",
  alternative = "two.sided",
  conf.level = 0.95
)

pairwise_binom_test_against_p(
  x,
  p = rep(1/length(x), length(x)),
  p.adjust.method = "holm",
  alternative = "two.sided",
  conf.level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom_test_+3A_x">x</code></td>
<td>
<p>numeric vector containing the counts.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_n">n</code></td>
<td>
<p>number of trials; ignored if <code>x</code> has length 2.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success. The length of p must be the
same as the number of groups specified by x, and its elements must be
greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.
You can specify just the initial letter.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the returned confidence
interval.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="binom_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame containing the p-value and its significance. with
some the following columns: </p>
 <ul>
<li> <p><code>group, group1, group2</code>:
the categories or groups being compared. </p>
</li>
<li> <p><code>statistic</code>: the number
of successes. </p>
</li>
<li> <p><code>parameter</code>: the number of trials. </p>
</li>
<li> <p><code>p</code>:
p-value of the test. </p>
</li>
<li> <p><code>p.adj</code>: the adjusted p-value. </p>
</li>
<li>
<p><code>method</code>: the used statistical test. </p>
</li>
<li> <p><code>p.signif,
 p.adj.signif</code>: the significance level of p-values and adjusted p-values,
respectively. </p>
</li>
<li> <p><code>estimate</code>: the estimated probability of success.
</p>
</li>
<li> <p><code>alternative</code>: a character string describing the alternative
hypothesis. </p>
</li>
<li> <p><code>conf.low,conf.high</code>: Lower and upper bound on a
confidence interval  for the probability of success.</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>binom_test()</code>: performs exact binomial test. Wrapper around the R
base function <code><a href="stats.html#topic+binom.test">binom.test</a></code> that returns a dataframe as a
result.
</p>
</li>
<li> <p><code>pairwise_binom_test()</code>: performs pairwise comparisons (binomial test)
following a significant exact multinomial test.
</p>
</li>
<li> <p><code>pairwise_binom_test_against_p()</code>: performs pairwise comparisons (binomial test)
following a significant exact multinomial test for given probabilities.
</p>
</li></ul>


<h3>See Also</h3>

<p><a href="#topic+multinom_test">multinom_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Exact binomial test
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: 160 mice with cancer including 95 male and 65 female
# Q1: Does cancer affect more males than females?
binom_test(x = 95, n = 160)
# =&gt; yes, there are a significant difference


# Q2: compare the observed proportion of males
# to an expected proportion (p = 3/5)
binom_test(x = 95, n = 160, p = 3/5)
# =&gt; there are no significant difference

# Multinomial test
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data
tulip &lt;- c(red = 81, yellow = 50, white = 27)
# Question 1: are the color equally common ?
# this is a test of homogeneity
res &lt;- multinom_test(tulip)
res
attr(res, "descriptives")

# Pairwise comparisons between groups
pairwise_binom_test(tulip, p.adjust.method = "bonferroni")


# Question 2: comparing observed to expected proportions
# this is a goodness-of-fit test
expected.p &lt;- c(red = 0.5, yellow = 0.33, white = 0.17)
res &lt;- multinom_test(tulip, expected.p)
res
attr(res, "descriptives")

# Pairwise comparisons against a given probabilities
pairwise_binom_test_against_p(tulip, expected.p)
</code></pre>

<hr>
<h2 id='box_m'>Box's M-test for Homogeneity of Covariance Matrices</h2><span id='topic+box_m'></span>

<h3>Description</h3>

<p>Performs the Box's M-test for homogeneity of covariance matrices
obtained from multivariate normal data according to one grouping variable.
The test is based on the chi-square approximation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_m(data, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_m_+3A_data">data</code></td>
<td>
<p>a numeric data.frame or matrix containing n observations of p
variables; it is expected that n &gt; p.</p>
</td></tr>
<tr><td><code id="box_m_+3A_group">group</code></td>
<td>
<p>a vector of length n containing the class of each
observation; it is usually a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following components:
</p>

<ul>
<li><p>statistic an approximated value of the chi-square distribution.
</p>
</li>
<li><p>parameter the degrees of freedom related of the test statistic in this case that it follows a Chi-square distribution.
</p>
</li>
<li><p>p.value the p-value of the test.
</p>
</li>
<li><p>method the character string &quot;Box's M-test for Homogeneity of Covariance Matrices&quot;.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
box_m(iris[, -5], iris[, 5])
</code></pre>

<hr>
<h2 id='chisq_test'>Chi-squared Test for Count Data</h2><span id='topic+chisq_test'></span><span id='topic+pairwise_chisq_gof_test'></span><span id='topic+pairwise_chisq_test_against_p'></span><span id='topic+chisq_descriptives'></span><span id='topic+expected_freq'></span><span id='topic+observed_freq'></span><span id='topic+pearson_residuals'></span><span id='topic+std_residuals'></span>

<h3>Description</h3>

<p>Performs chi-squared tests, including goodness-of-fit,
homogeneity and independence tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq_test(
  x,
  y = NULL,
  correct = TRUE,
  p = rep(1/length(x), length(x)),
  rescale.p = FALSE,
  simulate.p.value = FALSE,
  B = 2000
)

pairwise_chisq_gof_test(x, p.adjust.method = "holm", ...)

pairwise_chisq_test_against_p(
  x,
  p = rep(1/length(x), length(x)),
  p.adjust.method = "holm",
  ...
)

chisq_descriptives(res.chisq)

expected_freq(res.chisq)

observed_freq(res.chisq)

pearson_residuals(res.chisq)

std_residuals(res.chisq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq_test_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix. <code>x</code> and <code>y</code> can also
both be factors.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_y">y</code></td>
<td>
<p>a numeric vector; ignored if <code>x</code> is a matrix.  If
<code>x</code> is a factor, <code>y</code> should be a factor of the same length.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether to apply continuity
correction when computing the test statistic for 2 by 2 tables: one
half is subtracted from all <code class="reqn">|O - E|</code> differences; however, the
correction will not be bigger than the differences themselves.  No correction
is done if <code>simulate.p.value = TRUE</code>.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of the same length of <code>x</code>.
An error is given if any entry of <code>p</code> is negative.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_rescale.p">rescale.p</code></td>
<td>
<p>a logical scalar; if TRUE then <code>p</code> is rescaled
(if necessary) to sum to 1.  If <code>rescale.p</code> is FALSE, and
<code>p</code> does not sum to 1, an error is given.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute
p-values by Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_b">B</code></td>
<td>
<p>an integer specifying the number of replicates used in the
Monte Carlo test.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function <code>{chisq_test}()</code>.</p>
</td></tr>
<tr><td><code id="chisq_test_+3A_res.chisq">res.chisq</code></td>
<td>
<p>an object of class <code>chisq_test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>n</code>: the number of participants. </p>
</li>
<li> <p><code>group, group1, group2</code>:
the categories or groups being compared. </p>
</li>
<li> <p><code>statistic</code>: the value
of Pearson's chi-squared test statistic. </p>
</li>
<li> <p><code>df</code>: the degrees of
freedom of the approximate chi-squared distribution of the test statistic.
NA if the p-value is computed by Monte Carlo simulation. </p>
</li>
<li> <p><code>p</code>:
p-value. </p>
</li>
<li> <p><code>p.adj</code>: the adjusted p-value. </p>
</li>
<li> <p><code>method</code>: the
used statistical test. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance
level of p-values and adjusted p-values, respectively. </p>
</li>
<li>
<p><code>observed</code>: observed counts. </p>
</li>
<li>
<p><code>expected</code>: the expected counts under the null hypothesis.
</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>chisq_test()</code>: performs chi-square tests including goodness-of-fit,
homogeneity and independence tests.
</p>
</li>
<li> <p><code>pairwise_chisq_gof_test()</code>: perform pairwise comparisons between groups following a global
chi-square goodness of fit test.
</p>
</li>
<li> <p><code>pairwise_chisq_test_against_p()</code>: perform pairwise comparisons after a global
chi-squared test for given probabilities. For each group, the observed and
the expected proportions are shown. Each group is compared to the sum of
all others.
</p>
</li>
<li> <p><code>chisq_descriptives()</code>: returns the descriptive statistics of the chi-square
test. These include, observed and expected frequencies, proportions,
residuals and standardized residuals.
</p>
</li>
<li> <p><code>expected_freq()</code>: returns the expected counts from the chi-square test result.
</p>
</li>
<li> <p><code>observed_freq()</code>: returns the observed counts from the chi-square test result.
</p>
</li>
<li> <p><code>pearson_residuals()</code>: returns the Pearson residuals, <code>(observed - expected) / sqrt(expected)</code>.
</p>
</li>
<li> <p><code>std_residuals()</code>: returns the standardized residuals
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Chi-square goodness of fit test
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
tulip &lt;- c(red = 81, yellow = 50, white = 27)
# Q1: Are the colors equally common?
chisq_test(tulip)
pairwise_chisq_gof_test(tulip)
# Q2: comparing observed to expected proportions
chisq_test(tulip, p = c(1/2, 1/3, 1/6))
pairwise_chisq_test_against_p(tulip, p = c(0.5, 0.33, 0.17))

# Homogeneity of proportions between groups
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: Titanic
xtab &lt;- as.table(rbind(
  c(203, 118, 178, 212),
  c(122, 167, 528, 673)
))
dimnames(xtab) &lt;- list(
  Survived = c("Yes", "No"),
  Class = c("1st", "2nd", "3rd", "Crew")
)
xtab
# Chi-square test
chisq_test(xtab)
# Compare the proportion of survived between groups
pairwise_prop_test(xtab)
</code></pre>

<hr>
<h2 id='cochran_qtest'>Cochran's Q Test</h2><span id='topic+cochran_qtest'></span>

<h3>Description</h3>

<p>Performs the Cochran's Q test for unreplicated randomized block
design experiments with a binary response variable and paired data. This
test is analogue to the <code><a href="stats.html#topic+friedman.test">friedman.test</a>()</code> with 0,1 coded
response. It's an extension of the McNemar Chi-squared test for comparing
more than two paired proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cochran_qtest(data, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cochran_qtest_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="cochran_qtest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>a ~ b | c</code>, where <code>a</code> is the
outcome variable name; b is the within-subjects factor variables; and c
(factor) is the column name containing individuals/subjects identifier.
Should be unique per individual.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a demo data
mydata &lt;- data.frame(
  outcome = c(0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,1),
  treatment = gl(3,1,30,labels=LETTERS[1:3]),
  participant = gl(10,3,labels=letters[1:10])
)
mydata$outcome &lt;- factor(
  mydata$outcome, levels = c(1, 0),
  labels = c("success", "failure")
  )
# Cross-tabulation
xtabs(~outcome + treatment, mydata)

# Compare the proportion of success between treatments
cochran_qtest(mydata, outcome ~ treatment|participant)

# pairwise comparisons between groups
pairwise_mcnemar_test(mydata, outcome ~ treatment|participant)

</code></pre>

<hr>
<h2 id='cohens_d'>Compute Cohen's d Measure of Effect Size</h2><span id='topic+cohens_d'></span>

<h3>Description</h3>

<p>Compute the effect size for t-test. T-test conventional effect
sizes, proposed by Cohen, are: 0.2 (small effect), 0.5 (moderate effect) and
0.8 (large effect).
</p>
<p>Cohen's <code>d</code> is calculated as the difference between means or mean minus
<code>mu</code> divided by the estimated standardized deviation.
</p>
<p>For independent samples t-test, there are two possibilities implemented. If
the t-test did not make a homogeneity of variance assumption, (the Welch
test), the variance term will mirror the Welch test, otherwise a pooled
estimate is used.
</p>
<p>If a paired samples t-test was requested, then effect size desired is based
on the standard deviation of the differences.
</p>
<p>It can also returns confidence intervals by bootstap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohens_d(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  paired = FALSE,
  mu = 0,
  var.equal = FALSE,
  hedges.correction = FALSE,
  ci = FALSE,
  conf.level = 0.95,
  ci.type = "perc",
  nboot = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohens_d_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="cohens_d_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise two sample tests are performed for
comparing each grouping variable levels against all (i.e. basemean).</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_mu">mu</code></td>
<td>
<p>theoretical mean, use for one-sample t-test. Default is 0.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the two
variances as being equal. If TRUE then the pooled variance is used to
estimate the variance otherwise the Welch (or Satterthwaite) approximation
to the degrees of freedom is used. Used only for unpaired or independent samples test.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_hedges.correction">hedges.correction</code></td>
<td>
<p>logical indicating whether apply the Hedges
correction by multiplying the usual value of Cohen's d by
<code>(N-3)/(N-2.25)</code> (for unpaired t-test) and by <code>(n1-2)/(n1-1.25)</code> for paired t-test;
where <code>N</code> is the total size of the two groups being compared (N = n1 +
n2).</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_ci">ci</code></td>
<td>
<p>If TRUE, returns confidence intervals by bootstrap. May be slow.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_conf.level">conf.level</code></td>
<td>
<p>The level for the confidence interval.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_ci.type">ci.type</code></td>
<td>
<p>The type of confidence interval to use. Can be any of &quot;norm&quot;,
&quot;basic&quot;, &quot;perc&quot;, or &quot;bca&quot;. Passed to <code>boot::boot.ci</code>.</p>
</td></tr>
<tr><td><code id="cohens_d_+3A_nboot">nboot</code></td>
<td>
<p>The number of replications to use for bootstrap.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Quantification of the effect size magnitude is performed using the
thresholds defined in Cohen (1992). The magnitude is assessed using the
thresholds provided in (Cohen 1992), i.e. <code>|d| &lt; 0.2</code> &quot;negligible&quot;,
<code>|d| &lt; 0.5</code> &quot;small&quot;, <code>|d| &lt; 0.8</code> &quot;medium&quot;, otherwise &quot;large&quot;.
</p>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li>
<p><code>group1,group2</code>: the compared groups in the pairwise tests. </p>
</li>
<li>
<p><code>n,n1,n2</code>: Sample counts. </p>
</li>
<li> <p><code>effsize</code>: estimate of the effect
size (<code>d</code> value). </p>
</li>
<li> <p><code>magnitude</code>: magnitude of effect size.
</p>
</li>
<li> <p><code>conf.low,conf.high</code>: lower and upper bound of the effect size
confidence interval.</p>
</li></ul>



<h3>References</h3>

 <ul>
<li><p> Cohen, J. (1988). Statistical power analysis for
the behavioral sciences (2nd ed.). New York:Academic Press. </p>
</li>
<li><p> Cohen, J.
(1992). A power primer. Psychological Bulletin, 112, 155-159. </p>
</li>
<li><p> Hedges,
Larry &amp; Olkin, Ingram. (1985). Statistical Methods in Meta-Analysis.
10.2307/1164953. </p>
</li>
<li><p> Navarro, Daniel. 2015. Learning Statistics with R: A
Tutorial for Psychology Students and Other Beginners (Version 0.5). </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># One-sample t test effect size
ToothGrowth %&gt;% cohens_d(len ~ 1, mu = 0)

# Two indepedent samples t-test effect size
ToothGrowth %&gt;% cohens_d(len ~ supp, var.equal = TRUE)

# Paired samples effect size
df &lt;- data.frame(
  id = 1:5,
  pre  = c(110, 122, 101, 120, 140),
  post = c(150, 160, 110, 140, 155)
)
df &lt;- df %&gt;% gather(key = "treatment", value = "value", -id)
head(df)

df %&gt;% cohens_d(value ~ treatment, paired = TRUE)
</code></pre>

<hr>
<h2 id='convert_as_factor'>Factors</h2><span id='topic+convert_as_factor'></span><span id='topic+set_ref_level'></span><span id='topic+reorder_levels'></span>

<h3>Description</h3>

<p>Provides pipe-friendly functions to convert simultaneously
multiple variables into a factor variable.
</p>
<p>Helper functions are also available to set the reference level and the
levels order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_as_factor(data, ..., vars = NULL, make.valid.levels = FALSE)

set_ref_level(data, name, ref)

reorder_levels(data, name, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_as_factor_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_...">...</code></td>
<td>
<p>one unquoted expressions (or variable name) specifying the name of
the variables you want to convert into factor. Alternative to the argument
<code>vars</code>.</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_vars">vars</code></td>
<td>
<p>a character vector specifying the variables to convert into
factor.</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_make.valid.levels">make.valid.levels</code></td>
<td>
<p>logical. Default is FALSE. If TRUE, converts the
variable to factor and add a leading character (x) if starting with a digit.</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_name">name</code></td>
<td>
<p>a factor variable name. Can be unquoted. For example, use
<code>group</code> or <code>"group"</code>.</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_ref">ref</code></td>
<td>
<p>the reference level.</p>
</td></tr>
<tr><td><code id="convert_as_factor_+3A_order">order</code></td>
<td>
<p>a character vector specifying the order of the factor levels</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>convert_as_factor()</code>: Convert one or multiple variables into factor.
</p>
</li>
<li> <p><code>set_ref_level()</code>: Change a factor reference level or group.
</p>
</li>
<li> <p><code>reorder_levels()</code>: Change the order of a factor levels
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Create a demo data
df &lt;- tibble(
  group = c("a", "a", "b", "b", "c", "c"),
  time = c("t1", "t2", "t1", "t2", "t1", "t2"),
  value = c(5, 6, 1, 3, 4, 5)
)
df
# Convert group and time into factor variable
result &lt;- df %&gt;% convert_as_factor(group, time)
result
# Show group levels
levels(result$group)

# Set c as the reference level (the first one)
result &lt;- result %&gt;%
  set_ref_level("group", ref = "c")
levels(result$group)

# Set the order of levels
result &lt;- result %&gt;%
  reorder_levels("group", order = c("b", "c", "a"))
levels(result$group)

</code></pre>

<hr>
<h2 id='cor_as_symbols'>Replace Correlation Coefficients by Symbols</h2><span id='topic+cor_as_symbols'></span>

<h3>Description</h3>

<p>Take a correlation matrix and replace the correlation coefficients by symbols according to the
level of the correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_as_symbols(
  x,
  cutpoints = c(0, 0.25, 0.5, 0.75, 1),
  symbols = c(" ", ".", "+", "*")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_as_symbols_+3A_x">x</code></td>
<td>
<p>a correlation matrix. Particularly, an object of class <code>cor_mat</code>.</p>
</td></tr>
<tr><td><code id="cor_as_symbols_+3A_cutpoints">cutpoints</code></td>
<td>
<p>numeric vector used for intervals. Default values are
<code>c(0, 0.25, 0.5, 0.75, 1)</code>.</p>
</td></tr>
<tr><td><code id="cor_as_symbols_+3A_symbols">symbols</code></td>
<td>
<p>character vector, one shorter than cutpoints, used as
correlation coefficient symbols. Default values are <code>c(" ", ".",  "+",
"*")</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
cor.mat &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_mat()

# Replace correlation coefficient by symbols
#::::::::::::::::::::::::::::::::::::::::::
cor.mat %&gt;%
  cor_as_symbols() %&gt;%
  pull_lower_triangle()

</code></pre>

<hr>
<h2 id='cor_gather'>Reshape Correlation Data</h2><span id='topic+cor_gather'></span><span id='topic+cor_spread'></span>

<h3>Description</h3>

<p>Reshape correlation analysis results. Key functions: </p>

<ul>
<li> <p><code>cor_gather()</code>: takes a correlation matrix and collapses (i.e. melt) it into a paired list
(long format). </p>
</li>
<li> <p><code>cor_spread()</code>: spread a long correlation data format across
multiple columns. Particularly, it takes the results of <code><a href="#topic+cor_test">cor_test</a></code>
and transforms it into a correlation matrix. </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>cor_gather(data, drop.na = TRUE)

cor_spread(data, value = "cor")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_gather_+3A_data">data</code></td>
<td>
<p>a data frame or matrix.</p>
</td></tr>
<tr><td><code id="cor_gather_+3A_drop.na">drop.na</code></td>
<td>
<p>logical. If TRUE, drop rows containing missing values after gathering the data.</p>
</td></tr>
<tr><td><code id="cor_gather_+3A_value">value</code></td>
<td>
<p>column name containing the value to spread.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>cor_gather()</code>: takes a correlation matrix and collapses (or melt) it into long
format data frame (paired list)
</p>
</li>
<li> <p><code>cor_spread()</code>: spread a long correlation data frame into wide
format. Expects the columns &quot;var1&quot;, &quot;var2&quot; and &quot;cor&quot; in the data.
(correlation matrix).
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>, <code><a href="#topic+cor_reorder">cor_reorder</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
#::::::::::::::::::::::::::::::::::::::::::
mydata &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec)
head(mydata, 3)

# Reshape a correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
# Compute a correlation matrix
cor.mat &lt;- mydata %&gt;% cor_mat()
cor.mat

# Collapse the correlation matrix into long format
# paired list data frame
long.format &lt;- cor.mat %&gt;% cor_gather()
long.format

# Spread a correlation data format
#::::::::::::::::::::::::::::::::::::::::::
# Spread the correlation coefficient value
long.format %&gt;% cor_spread(value = "cor")
# Spread the p-value
long.format %&gt;% cor_spread(value = "p")
</code></pre>

<hr>
<h2 id='cor_mark_significant'>Add Significance Levels To a Correlation Matrix</h2><span id='topic+cor_mark_significant'></span>

<h3>Description</h3>

<p>Combines correlation coefficients and significance levels in a
correlation matrix data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_mark_significant(
  x,
  cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1),
  symbols = c("****", "***", "**", "*", "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_mark_significant_+3A_x">x</code></td>
<td>
<p>an object of class <code><a href="#topic+cor_mat">cor_mat</a>()</code>.</p>
</td></tr>
<tr><td><code id="cor_mark_significant_+3A_cutpoints">cutpoints</code></td>
<td>
<p>numeric vector used for intervals.</p>
</td></tr>
<tr><td><code id="cor_mark_significant_+3A_symbols">symbols</code></td>
<td>
<p>character vector, one shorter than cutpoints, used as
significance symbols.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the lower triangular part of the correlation
matrix marked by significance symbols.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_mat() %&gt;%
  cor_mark_significant()
</code></pre>

<hr>
<h2 id='cor_mat'>Compute Correlation Matrix with P-values</h2><span id='topic+cor_mat'></span><span id='topic+cor_pmat'></span><span id='topic+cor_get_pval'></span>

<h3>Description</h3>

<p>Compute correlation matrix with p-values. Numeric columns in the
data are detected and automatically selected for the analysis. You can also
specify variables of interest to be used in the correlation analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_mat(
  data,
  ...,
  vars = NULL,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95
)

cor_pmat(
  data,
  ...,
  vars = NULL,
  method = "pearson",
  alternative = "two.sided",
  conf.level = 0.95
)

cor_get_pval(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_mat_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation
coefficient is to be  used for the test.  One of <code>"pearson"</code>,
<code>"kendall"</code>, or <code>"spearman"</code>, can be abbreviated.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.  You
can specify just the initial letter.  <code>"greater"</code> corresponds
to positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the returned confidence
interval.  Currently only used for the Pearson product moment
correlation coefficient if there are at least 4 complete pairs of
observations.</p>
</td></tr>
<tr><td><code id="cor_mat_+3A_x">x</code></td>
<td>
<p>an object of class <code>cor_mat</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cor_mat()</code>: compute correlation matrix with p-values. Returns a data
frame containing the matrix of the correlation coefficients. The output has
an attribute named &quot;pvalue&quot;, which contains the matrix of the correlation
test p-values.
</p>
</li>
<li> <p><code>cor_pmat()</code>: compute the correlation matrix but returns only the p-values of the tests.
</p>
</li>
<li> <p><code>cor_get_pval()</code>: extract a correlation matrix p-values from an object of
class <code>cor_mat()</code>. P-values are not adjusted.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+cor_test">cor_test</a>()</code>, <code><a href="#topic+cor_reorder">cor_reorder</a>()</code>,
<code><a href="#topic+cor_gather">cor_gather</a>()</code>, <code><a href="#topic+cor_select">cor_select</a>()</code>,
<code><a href="#topic+cor_as_symbols">cor_as_symbols</a>()</code>, <code><a href="#topic+pull_triangle">pull_triangle</a>()</code>,
<code><a href="#topic+replace_triangle">replace_triangle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
#:::::::::::::::::::::::::::::::::::::::::::
mydata &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec)
head(mydata, 3)

# Compute correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
# Correlation matrix between all variables
cor.mat &lt;- mydata %&gt;% cor_mat()
cor.mat

# Specify some variables of interest
mydata %&gt;% cor_mat(mpg, hp, wt)

# Or remove some variables in the data
# before the analysis
mydata %&gt;% cor_mat(-mpg, -hp)

# Significance levels
#::::::::::::::::::::::::::::::::::::::::::
cor.mat %&gt;% cor_get_pval()


# Visualize
#::::::::::::::::::::::::::::::::::::::::::
# Insignificant correlations are marked by crosses
cor.mat %&gt;%
  cor_reorder() %&gt;%
  pull_lower_triangle() %&gt;%
  cor_plot(label = TRUE)

# Gather/collapse correlation matrix into long format
#::::::::::::::::::::::::::::::::::::::::::
cor.mat %&gt;% cor_gather()


</code></pre>

<hr>
<h2 id='cor_plot'>Visualize Correlation Matrix Using Base Plot</h2><span id='topic+cor_plot'></span>

<h3>Description</h3>

<p>Provide a tibble-friendly framework to visualize a correlation
matrix. Wrapper around the R base function
<code><a href="corrplot.html#topic+corrplot">corrplot</a>()</code>. Compared to
<code><a href="corrplot.html#topic+corrplot">corrplot</a>()</code>, it can handle directly the output of the
functions <code><a href="#topic+cor_mat">cor_mat</a>() (in rstatix)</code>, <code>rcorr() (in Hmisc)</code>,
<code>correlate() (in corrr)</code> and <code>cor() (in stats)</code>.
</p>
<p>The p-values contained in the outputs of the functions
<code><a href="#topic+cor_mat">cor_mat</a>()</code> and <code>rcorr()</code> are automatically detected and
used in the visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_plot(
  cor.mat,
  method = "circle",
  type = "full",
  palette = NULL,
  p.mat = NULL,
  significant.level = 0.05,
  insignificant = c("cross", "blank"),
  label = FALSE,
  font.label = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_plot_+3A_cor.mat">cor.mat</code></td>
<td>
<p>the correlation matrix to visualize</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_method">method</code></td>
<td>
<p>Character, the visualization method of correlation matrix to be
used. Currently, it supports seven methods, named <code>"circle"</code>
(default), <code>"square"</code>, <code>"ellipse"</code>, <code>"number"</code>,
<code>"pie"</code>, <code>"shade"</code> and <code>"color"</code>. See examples for details.
</p>
<p>The areas of circles or squares show the absolute value of corresponding
correlation coefficients. Method <code>"pie"</code> and <code>"shade"</code> came from
Michael Friendly's job (with some adjustment about the shade added on), and
<code>"ellipse"</code> came from D.J. Murdoch and E.D. Chow's job, see in section
References.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_type">type</code></td>
<td>
<p>Character, <code>"full"</code> (default), <code>"upper"</code> or
<code>"lower"</code>, display full matrix, lower triangular or upper triangular
matrix.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_palette">palette</code></td>
<td>
<p>character vector containing the color palette.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_p.mat">p.mat</code></td>
<td>
<p>matrix of p-value corresponding to the correlation matrix.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_significant.level">significant.level</code></td>
<td>
<p>significant level, if the p-value is bigger than
<code>significant.level</code>, then the corresponding correlation coefficient is
regarded as insignificant.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_insignificant">insignificant</code></td>
<td>
<p>character, specialized insignificant correlation
coefficients, &quot;cross&quot; (default), &quot;blank&quot;. If &quot;blank&quot;, wipe away the
corresponding glyphs; if &quot;cross&quot;, add crosses (X) on corresponding glyphs.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_label">label</code></td>
<td>
<p>logical value. If TRUE, shows the correlation coefficient
labels.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_font.label">font.label</code></td>
<td>
<p>a list with one or more of the following elements: size
(e.g., 1), color (e.g., &quot;black&quot;) and style (e.g., &quot;bold&quot;). Used to
customize the correlation coefficient labels. For example <code>font.label
= list(size = 1, color = "black", style = "bold")</code>.</p>
</td></tr>
<tr><td><code id="cor_plot_+3A_...">...</code></td>
<td>
<p>additional options not listed (i.e. &quot;tl.cex&quot;) here to pass to corrplot.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cor_as_symbols">cor_as_symbols</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
cor.mat &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_mat()

# Visualize correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
# Full correlation matrix,
# insignificant correlations are marked by crosses
cor.mat %&gt;% cor_plot()

# Reorder by correlation coefficient
# pull lower triangle and visualize
cor.lower.tri &lt;- cor.mat %&gt;%
  cor_reorder() %&gt;%
  pull_lower_triangle()
cor.lower.tri %&gt;% cor_plot()

# Change visualization methods
#::::::::::::::::::::::::::::::::::::::::::
cor.lower.tri %&gt;%
  cor_plot(method = "pie")

cor.lower.tri %&gt;%
  cor_plot(method = "color")

cor.lower.tri %&gt;%
  cor_plot(method = "number")

# Show the correlation coefficient: label = TRUE
# Blank the insignificant correlation
#::::::::::::::::::::::::::::::::::::::::::
cor.lower.tri %&gt;%
  cor_plot(
    method = "color",
    label = TRUE,
    insignificant = "blank"
  )

# Change the color palettes
#::::::::::::::::::::::::::::::::::::::::::

# Using custom color palette
# Require ggpubr: install.packages("ggpubr")
if(require("ggpubr")){
  my.palette &lt;- get_palette(c("red", "white", "blue"), 200)
  cor.lower.tri %&gt;%
   cor_plot(palette = my.palette)
}

# Using RcolorBrewer color palette
if(require("ggpubr")){
  my.palette &lt;- get_palette("PuOr", 200)
  cor.lower.tri %&gt;%
   cor_plot(palette = my.palette)
}

</code></pre>

<hr>
<h2 id='cor_reorder'>Reorder Correlation Matrix</h2><span id='topic+cor_reorder'></span>

<h3>Description</h3>

<p>reorder correlation matrix, according to the coefficients,
using the hierarchical clustering method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_reorder(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_reorder_+3A_x">x</code></td>
<td>
<p>a correlation matrix. Particularly, an object of class <code>cor_mat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>, <code><a href="#topic+cor_gather">cor_gather</a>()</code>, <code><a href="#topic+cor_spread">cor_spread</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
cor.mat &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_mat()

# Reorder by correlation and get p-values
#::::::::::::::::::::::::::::::::::::::::::
# Reorder
cor.mat %&gt;%
  cor_reorder()
# Get p-values of the reordered cor_mat
cor.mat %&gt;%
  cor_reorder() %&gt;%
  cor_get_pval()

</code></pre>

<hr>
<h2 id='cor_select'>Subset Correlation Matrix</h2><span id='topic+cor_select'></span>

<h3>Description</h3>

<p>Subset Correlation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_select(x, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_select_+3A_x">x</code></td>
<td>
<p>a correlation matrix. Particularly, an object of class <code>cor_mat</code>.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select variables of interest.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>, <code><a href="#topic+pull_triangle">pull_triangle</a>()</code>, <code><a href="#topic+replace_triangle">replace_triangle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute correlation matrix
#::::::::::::::::::::::::::::::::::::::::::
cor.mat &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec) %&gt;%
  cor_mat()

# Subsetting correlation matrix
#::::::::::::::::::::::::::::::::::::::::::

# Select some variables of interest
cor.mat %&gt;%
  cor_select(mpg, drat, wt)

# Remove variables
cor.mat %&gt;%
  cor_select(-mpg, -wt)

</code></pre>

<hr>
<h2 id='cor_test'>Correlation Test</h2><span id='topic+cor_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to perform correlation test
between paired samples, using Pearson, Kendall or Spearman method. Wrapper
around the function <code><a href="stats.html#topic+cor.test">cor.test</a>()</code>.
</p>
<p>Can also performs multiple pairwise correlation analyses between more than
two variables or between two different vectors of variables. Using this
function, you can also compute, for example, the correlation between one
variable vs many.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_test(
  data,
  ...,
  vars = NULL,
  vars2 = NULL,
  alternative = "two.sided",
  method = "pearson",
  conf.level = 0.95,
  use = "pairwise.complete.obs"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest. Alternative to the argument
<code>vars</code>.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_vars">vars</code></td>
<td>
<p>optional character vector containing variable names for
correlation analysis. Ignored when dot vars are specified. </p>
 <ul>
<li>
<p>If <code>vars</code> is NULL, multiple pairwise correlation tests is performed
between all variables in the data. </p>
</li>
<li><p> If <code>vars</code> contain only one
variable, a pairwise correlation analysis is performed between the specified
variable vs either all the remaining numeric variables in the data or
variables in <code>vars2</code> (if specified). </p>
</li>
<li><p> If <code>vars</code> contain two
or more variables: i) if <code>vars2</code> is not specified, a pairwise
correlation analysis is performed between all possible combinations of
variables. ii) if <code>vars2</code> is specified, each element in <code>vars</code> is
tested against all elements in <code>vars2</code></p>
</li></ul>
<p>. Accept unquoted
variable names: <code>c(var1, var2)</code>.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_vars2">vars2</code></td>
<td>
<p>optional character vector. If specified, each element in
<code>vars</code> is tested against all elements in <code>vars2</code>. Accept unquoted
variable names: <code>c(var1, var2)</code>.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.  You
can specify just the initial letter.  <code>"greater"</code> corresponds
to positive association, <code>"less"</code> to negative association.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_method">method</code></td>
<td>
<p>a character string indicating which correlation
coefficient is to be  used for the test.  One of <code>"pearson"</code>,
<code>"kendall"</code>, or <code>"spearman"</code>, can be abbreviated.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the returned confidence
interval.  Currently only used for the Pearson product moment
correlation coefficient if there are at least 4 complete pairs of
observations.</p>
</td></tr>
<tr><td><code id="cor_test_+3A_use">use</code></td>
<td>
<p>an optional character string giving a
method for computing covariances in the presence
of missing values.  This must be (an abbreviation of) one of the strings
<code>"everything"</code>, <code>"all.obs"</code>, <code>"complete.obs"</code>,
<code>"na.or.complete"</code>, or <code>"pairwise.complete.obs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with the following columns: </p>
 <ul>
<li>
<p><code>var1, var2</code>: the variables used in the correlation test. </p>
</li>
<li>
<p><code>cor</code>: the correlation coefficient. </p>
</li>
<li> <p><code>statistic</code>: Test
statistic used to compute the p-value. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li>
<p><code>conf.low,conf.high</code>: Lower and upper bounds on a confidence interval.
</p>
</li>
<li> <p><code>method</code>: the method used to compute the statistic.</p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>cor_test()</code>: correlation test between two or more variables.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+cor_mat">cor_mat</a>()</code>, <code><a href="#topic+as_cor_mat">as_cor_mat</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Correlation between the specified variable vs
# the remaining numeric variables in the data
#:::::::::::::::::::::::::::::::::::::::::
mtcars %&gt;% cor_test(mpg)

# Correlation test between two variables
#:::::::::::::::::::::::::::::::::::::::::
mtcars %&gt;% cor_test(wt, mpg)

# Pairwise correlation between multiple variables
#:::::::::::::::::::::::::::::::::::::::::
mtcars %&gt;% cor_test(wt, mpg, disp)

# Grouped data
#:::::::::::::::::::::::::::::::::::::::::
iris %&gt;%
  group_by(Species) %&gt;%
 cor_test(Sepal.Width, Sepal.Length)

# Multiple correlation test
#:::::::::::::::::::::::::::::::::::::::::
# Correlation between one variable vs many
mtcars %&gt;% cor_test(
  vars = "mpg",
  vars2 = c("disp", "hp", "drat")
 )

# Correlation between two vectors of variables
# Each element in vars is tested against all elements in vars2
mtcars %&gt;% cor_test(
  vars = c("mpg", "wt"),
  vars2 = c("disp", "hp", "drat")
 )


</code></pre>

<hr>
<h2 id='counts_to_cases'>Convert a Table of Counts into a Data Frame of cases</h2><span id='topic+counts_to_cases'></span>

<h3>Description</h3>

<p>converts a contingency table or a data frame of counts into a
data frame of individual observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>counts_to_cases(x, count.col = "Freq")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="counts_to_cases_+3A_x">x</code></td>
<td>
<p>a contingency table or a data frame</p>
</td></tr>
<tr><td><code id="counts_to_cases_+3A_count.col">count.col</code></td>
<td>
<p>the name of the column containing the counts. Default is &quot;Freq&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of cases
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a cross-tabulation demo data
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
xtab &lt;- as.table(
  rbind(c(20, 5), c(16,9))
)
dimnames(xtab) &lt;- list(
  before = c("non.smoker", "smoker"),
  after = c("non.smoker", "smoker")
)
xtab

# Convert into a data frame of cases
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
df &lt;- counts_to_cases(xtab)
head(df)

</code></pre>

<hr>
<h2 id='cramer_v'>Compute Cramer's V</h2><span id='topic+cramer_v'></span>

<h3>Description</h3>

<p>Compute Cramer's V, which measures the strength of the
association between categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer_v(x, y = NULL, correct = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramer_v_+3A_x">x</code></td>
<td>
<p>a numeric vector or matrix. <code>x</code> and <code>y</code> can also
both be factors.</p>
</td></tr>
<tr><td><code id="cramer_v_+3A_y">y</code></td>
<td>
<p>a numeric vector; ignored if <code>x</code> is a matrix.  If
<code>x</code> is a factor, <code>y</code> should be a factor of the same length.</p>
</td></tr>
<tr><td><code id="cramer_v_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether to apply continuity
correction when computing the test statistic for 2 by 2 tables: one
half is subtracted from all <code class="reqn">|O - E|</code> differences; however, the
correction will not be bigger than the differences themselves.  No correction
is done if <code>simulate.p.value = TRUE</code>.</p>
</td></tr>
<tr><td><code id="cramer_v_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function
<code><a href="stats.html#topic+chisq.test">chisq.test</a>()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data preparation
df &lt;- as.table(rbind(c(762, 327, 468), c(484, 239, 477)))
dimnames(df) &lt;- list(
  gender = c("F", "M"),
  party = c("Democrat","Independent", "Republican")
)
df
# Compute cramer's V
cramer_v(df)

</code></pre>

<hr>
<h2 id='df_arrange'>Arrange Rows by Column Values</h2><span id='topic+df_arrange'></span>

<h3>Description</h3>

<p>Order the rows of a data frame by values of specified columns.
Wrapper arround the <code><a href="dplyr.html#topic+arrange">arrange</a>()</code> function. Supports
standard and non standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_arrange(data, ..., vars = NULL, .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_arrange_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_arrange_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest. Use
<code><a href="dplyr.html#topic+desc">desc</a>()</code> to sort a variable in descending order.</p>
</td></tr>
<tr><td><code id="df_arrange_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
<tr><td><code id="df_arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If TRUE, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- head(ToothGrowth)
df

# Select column using standard evaluation
df %&gt;% df_arrange(vars = c("dose", "len"))

# Select column using non-standard evaluation
df %&gt;% df_arrange(dose, desc(len))
</code></pre>

<hr>
<h2 id='df_get_var_names'>Get User Specified Variable Names</h2><span id='topic+df_get_var_names'></span>

<h3>Description</h3>

<p>Returns user specified variable names. Supports standard and non standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_get_var_names(data, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_get_var_names_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_get_var_names_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest.</p>
</td></tr>
<tr><td><code id="df_get_var_names_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Non standard evaluation
ToothGrowth %&gt;%
 df_get_var_names(dose, len)

# Standard evaluation
ToothGrowth %&gt;%
 df_get_var_names(vars = c("len", "dose"))
</code></pre>

<hr>
<h2 id='df_group_by'>Group a Data Frame by One or more Variables</h2><span id='topic+df_group_by'></span>

<h3>Description</h3>

<p>Group a data frame by one or more variables. Supports standard
and non standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_group_by(data, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_group_by_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_group_by_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest.</p>
</td></tr>
<tr><td><code id="df_group_by_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Non standard evaluation
by_dose &lt;- head(ToothGrowth) %&gt;%
   df_group_by(dose)
by_dose

# Standard evaluation
head(ToothGrowth) %&gt;%
   df_group_by(vars = c("dose", "supp"))
</code></pre>

<hr>
<h2 id='df_label_both'>Functions to Label Data Frames by Grouping Variables</h2><span id='topic+df_label_both'></span><span id='topic+df_label_value'></span>

<h3>Description</h3>

<p>Functions to label data frame rows by one or multiple grouping
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_label_both(data, ..., vars = NULL, label_col = "label", sep = c(", ", ":"))

df_label_value(data, ..., vars = NULL, label_col = "label", sep = ", ")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_label_both_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_label_both_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used as grouping variables.</p>
</td></tr>
<tr><td><code id="df_label_both_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the grouping variables of interest.</p>
</td></tr>
<tr><td><code id="df_label_both_+3A_label_col">label_col</code></td>
<td>
<p>column to hold the label of the data subsets. Default column
name is &quot;label&quot;.</p>
</td></tr>
<tr><td><code id="df_label_both_+3A_sep">sep</code></td>
<td>
<p>String separating labelling variables and values. Should be of
length 2 in the function <code>df_label_both()</code>. 1) One sep is used to
separate groups, for example ','; 2) The other sep between group name and
levels; for example ':'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a modified data frame with a column containing row labels.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>df_label_both()</code>: Displays both the variable name and the factor value.
</p>
</li>
<li> <p><code>df_label_value()</code>: Displays only the value of a factor.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
df &lt;- head(ToothGrowth)

# Labelling: Non standard evaluation
df %&gt;%
  df_label_both(dose, supp)

# Standard evaluation
df %&gt;%
  df_label_both(dose, supp)

# Nesting the data then label each subset by groups
ToothGrowth %&gt;%
  df_nest_by(dose, supp) %&gt;%
  df_label_both(supp, dose)

</code></pre>

<hr>
<h2 id='df_nest_by'>Nest a Tibble By Groups</h2><span id='topic+df_nest_by'></span>

<h3>Description</h3>

<p>Nest a tibble data frame using grouping specification. Supports standard and non standard evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_nest_by(data, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_nest_by_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_nest_by_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used as grouping variables.</p>
</td></tr>
<tr><td><code id="df_nest_by_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the grouping variables of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl with one row per unique combination of the grouping variables.
The first columns are the grouping variables, followed by a list column of
tibbles with matching rows of the remaining columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Non standard evaluation
ToothGrowth %&gt;%
 df_nest_by(dose, supp)

# Standard evaluation
ToothGrowth %&gt;%
 df_nest_by(vars = c("dose", "supp"))

</code></pre>

<hr>
<h2 id='df_select'>Select Columns in a Data Frame</h2><span id='topic+df_select'></span>

<h3>Description</h3>

<p>A wrapper around the <code><a href="dplyr.html#topic+select">select</a>()</code> function for
selection data frame columns. Supports standard and non standard
evaluations. Usefull to easily program with <code>dplyr</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_select(data, ..., vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_select_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_select_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest.</p>
</td></tr>
<tr><td><code id="df_select_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the variable names of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- head(ToothGrowth)
df

# Select column using standard evaluation
df %&gt;% df_select(vars = c("dose", "len"))

# Select column using non-standard evaluation
df %&gt;% df_select(dose, len)
</code></pre>

<hr>
<h2 id='df_split_by'>Split a Data Frame into Subset</h2><span id='topic+df_split_by'></span>

<h3>Description</h3>

<p>Split a data frame by groups into subsets or data panel. Very
similar to the function <code><a href="#topic+df_nest_by">df_nest_by</a>()</code>. The only difference is
that, it adds label to each data subset. Labels are the combination of the
grouping variable levels. The column holding labels are named &quot;label&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_split_by(
  data,
  ...,
  vars = NULL,
  label_col = "label",
  labeller = df_label_both,
  sep = c(", ", ":")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_split_by_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_split_by_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used as grouping variables.</p>
</td></tr>
<tr><td><code id="df_split_by_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the grouping variables of interest.</p>
</td></tr>
<tr><td><code id="df_split_by_+3A_label_col">label_col</code></td>
<td>
<p>column to hold the label of the data subsets. Default column
name is &quot;label&quot;.</p>
</td></tr>
<tr><td><code id="df_split_by_+3A_labeller">labeller</code></td>
<td>
<p>A function that takes a data frame, the grouping variables,
label_col and label_sep arguments, and add labels into the data frame.
Example of possible values are: <code><a href="#topic+df_label_both">df_label_both</a>()</code> and
<code><a href="#topic+df_label_value">df_label_value</a>()</code>.</p>
</td></tr>
<tr><td><code id="df_split_by_+3A_sep">sep</code></td>
<td>
<p>String separating labelling variables and values. Should be of
length 2 in the function <code>df_label_both()</code>. 1) One sep is used to
separate groups, for example ','; 2) The other sep between group name and
levels; for example ':'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl with one row per unique combination of the grouping variables.
The first columns are the grouping variables, followed by a list column of
tibbles with matching rows of the remaining columns, and a column named
label, containing labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Split a data frame
# :::::::::::::::::::::::::::::::::::::::::::::::::
# Create a grouped data
res &lt;- ToothGrowth %&gt;%
  df_split_by(dose, supp)
res

# Show subsets
res$data

# Add panel/subset labels
res &lt;- ToothGrowth %&gt;%
  df_split_by(dose, supp)
res
</code></pre>

<hr>
<h2 id='df_unite'>Unite Multiple Columns into One</h2><span id='topic+df_unite'></span><span id='topic+df_unite_factors'></span>

<h3>Description</h3>

<p>Paste together multiple columns into one. Wrapper arround
<code><a href="tidyr.html#topic+unite">unite</a>()</code> that supports standard and non standard
evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_unite(data, col, ..., vars = NULL, sep = "_", remove = TRUE, na.rm = FALSE)

df_unite_factors(
  data,
  col,
  ...,
  vars = NULL,
  sep = "_",
  remove = TRUE,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_unite_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="df_unite_+3A_col">col</code></td>
<td>
<p>the name of the new column as a string or a symbol.</p>
</td></tr>
<tr><td><code id="df_unite_+3A_...">...</code></td>
<td>
<p>a selection of columns. One or more unquoted expressions (or variable names) separated by
commas.</p>
</td></tr>
<tr><td><code id="df_unite_+3A_vars">vars</code></td>
<td>
<p>a character vector containing the column names of interest.</p>
</td></tr>
<tr><td><code id="df_unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="df_unite_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="df_unite_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>df_unite()</code>: Unite multiple columns into one.
</p>
</li>
<li> <p><code>df_unite_factors()</code>: Unite factor columns. First, order factors levels then
merge them into one column. The output column is a factor.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Non standard evaluation
head(ToothGrowth) %&gt;%
 df_unite(col = "dose_supp", dose, supp)

# Standard evaluation
head(ToothGrowth) %&gt;%
 df_unite(col = "dose_supp", vars = c("dose", "supp"))
</code></pre>

<hr>
<h2 id='doo'>Alternative to dplyr::do for Doing Anything</h2><span id='topic+doo'></span>

<h3>Description</h3>

<p>Provides a flexible alternative to the <code>dplyr:do()</code> function.
Technically it uses <code>nest() + mutate() + map()</code> to apply arbitrary
computation to a grouped data frame.
</p>
<p>The output is a data frame. If the applied function returns a data frame,
then the output will be automatically unnested. Otherwise, the output includes the grouping
variables and a column named &quot;.results.&quot; (by default), which is a &quot;list-columns&quot;
containing the results for group combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doo(data, .f, ..., result = ".results.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doo_+3A_data">data</code></td>
<td>
<p>a (grouped) data frame</p>
</td></tr>
<tr><td><code id="doo_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or atomic vector. For example
<code>~t.test(len ~ supp, data = .)</code>.</p>
</td></tr>
<tr><td><code id="doo_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to .f</p>
</td></tr>
<tr><td><code id="doo_+3A_result">result</code></td>
<td>
<p>the column name to hold the results. Default is &quot;.results.&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Custom function
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
stat_test &lt;- function(data, formula){
  t.test(formula, data) %&gt;%
    tidy()
}
# Example 1: pipe-friendly stat_test().
# Two possibilities of usage are available
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Use this
ToothGrowth %&gt;%
  group_by(dose) %&gt;%
  doo(~stat_test(data =., len ~ supp))

# Or this
ToothGrowth %&gt;%
  group_by(dose) %&gt;%
  doo(stat_test, len ~ supp)

# Example 2: R base function t.test() (not pipe friendly)
# One possibility of usage
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
comparisons &lt;- ToothGrowth %&gt;%
   group_by(dose) %&gt;%
   doo(~t.test(len ~ supp, data =.))
comparisons
comparisons$.results.

# Example 3: R base function combined with tidy()
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
ToothGrowth %&gt;%
   group_by(dose) %&gt;%
   doo(~t.test(len ~ supp, data =.) %&gt;% tidy())
</code></pre>

<hr>
<h2 id='dunn_test'>Dunn's Test of Multiple Comparisons</h2><span id='topic+dunn_test'></span>

<h3>Description</h3>

<p>Performs Dunn's test for pairwise multiple comparisons of the
ranked data. The mean rank of the different groups is compared. Used for
post-hoc test following Kruskal-Wallis test.
</p>
<p>The default of the <code>rstatix::dunn_test()</code> function is to perform a
two-sided Dunn test like the well known commercial softwares, such as SPSS
and GraphPad. This is not the case for some other R packages
(<code>dunn.test</code> and <code>jamovi</code>), where the default is to perform
one-sided test. This discrepancy is documented at
<a href="https://github.com/kassambara/rstatix/issues/50">https://github.com/kassambara/rstatix/issues/50</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dunn_test(data, formula, p.adjust.method = "holm", detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunn_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="dunn_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="dunn_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="dunn_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DunnTest performs the post hoc pairwise multiple comparisons
procedure appropriate to follow up a Kruskal-Wallis test, which is a
non-parametric analog of the one-way ANOVA. The Wilcoxon rank sum test,
itself a non-parametric analog of the unpaired t-test, is possibly
intuitive, but inappropriate as a post hoc pairwise test, because (1) it
fails to retain the dependent ranking that produced the Kruskal-Wallis test
statistic, and (2) it does not incorporate the pooled variance estimate
implied by the null hypothesis of the Kruskal-Wallis test.
</p>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y (outcome) variable used in the test. </p>
</li>
<li>
<p><code>group1,group2</code>: the compared groups in the pairwise tests. </p>
</li>
<li>
<p><code>n1,n2</code>: Sample counts. </p>
</li>
<li> <p><code>estimate</code>: mean ranks difference.
</p>
</li>
<li> <p><code>estimate1, estimate2</code>: show the mean rank values of the two
groups, respectively. </p>
</li>
<li> <p><code>statistic</code>: Test statistic (z-value) used
to compute the p-value. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>: the
adjusted p-value. </p>
</li>
<li> <p><code>method</code>: the statistical test used to compare
groups. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance level of
p-values and adjusted p-values, respectively. </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>References</h3>

<p>Dunn, O. J. (1964) Multiple comparisons using rank sums
Technometrics, 6(3):241-252.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple test
ToothGrowth %&gt;% dunn_test(len ~ dose)

# Grouped data
ToothGrowth %&gt;%
  group_by(supp) %&gt;%
  dunn_test(len ~ dose)
</code></pre>

<hr>
<h2 id='emmeans_test'>Pairwise Comparisons of Estimated Marginal Means</h2><span id='topic+emmeans_test'></span><span id='topic+get_emmeans'></span>

<h3>Description</h3>

<p>Performs pairwise comparisons between groups using the estimated
marginal means. Pipe-friendly wrapper arround the functions <code>emmans() +
 contrast()</code> from the <code>emmeans</code> package, which need to be installed
before using this function. This function is useful for performing post-hoc
analyses following ANOVA/ANCOVA tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emmeans_test(
  data,
  formula,
  covariate = NULL,
  ref.group = NULL,
  comparisons = NULL,
  p.adjust.method = "bonferroni",
  conf.level = 0.95,
  model = NULL,
  detailed = FALSE
)

get_emmeans(emmeans.test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="emmeans_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_covariate">covariate</code></td>
<td>
<p>(optional) covariate names (for ANCOVA)</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise two sample tests are performed for
comparing each grouping variable levels against all (i.e. basemean).</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_model">model</code></td>
<td>
<p>a fitted-model objects such as the result of a call to
<code>lm()</code>, from which the overall degrees of
freedom are to be calculated.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="emmeans_test_+3A_emmeans.test">emmeans.test</code></td>
<td>
<p>an object of class <code>emmeans_test</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>group1,group2</code>: the
compared groups in the pairwise tests. </p>
</li>
<li> <p><code>statistic</code>: Test
statistic (t.ratio) used to compute the p-value. </p>
</li>
<li> <p><code>df</code>: degrees of
freedom. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>: the adjusted p-value.
</p>
</li>
<li> <p><code>method</code>: the statistical test used to compare groups. </p>
</li>
<li>
<p><code>p.signif, p.adj.signif</code>: the significance level of p-values and
adjusted p-values, respectively. </p>
</li>
<li> <p><code>estimate</code>: estimate of the
effect size, that is the difference between the two emmeans (estimated
marginal means). </p>
</li>
<li> <p><code>conf.low,conf.high</code>: Lower and upper bound on a
confidence interval of the estimate. </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments. It has also an attribute named &quot;emmeans&quot;, a data
frame containing the groups emmeans.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_emmeans()</code>: returns the estimated marginal means from an object of class <code>emmeans_test</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)

# Pairwise comparisons
res &lt;- df %&gt;%
 group_by(supp) %&gt;%
 emmeans_test(len ~ dose, p.adjust.method = "bonferroni")
res

# Display estimated marginal means
attr(res, "emmeans")

# Show details
df %&gt;%
 group_by(supp) %&gt;%
 emmeans_test(len ~ dose, p.adjust.method = "bonferroni", detailed = TRUE)
</code></pre>

<hr>
<h2 id='eta_squared'>Effect Size for ANOVA</h2><span id='topic+eta_squared'></span><span id='topic+partial_eta_squared'></span>

<h3>Description</h3>

<p>Compute eta-squared and partial eta-squared for all terms in an
ANOVA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eta_squared(model)

partial_eta_squared(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eta_squared_+3A_model">model</code></td>
<td>
<p>an object of class aov or anova.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector with the effect size statistics
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>eta_squared()</code>: compute eta squared
</p>
</li>
<li> <p><code>partial_eta_squared()</code>: compute partial eta squared.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)

# Compute ANOVA
res.aov &lt;- aov(len ~ supp*dose, data = df)
summary(res.aov)

# Effect size
eta_squared(res.aov)
partial_eta_squared(res.aov)
</code></pre>

<hr>
<h2 id='factorial_design'>Build Factorial Designs for ANOVA</h2><span id='topic+factorial_design'></span>

<h3>Description</h3>

<p>Provides helper functions to build factorial design for easily
computing ANOVA using the <code><a href="car.html#topic+Anova">Anova</a>()</code> function. This might be
very useful for repeated measures ANOVA, which is hard to set up with the
<code>car</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorial_design(data, dv, wid, between, within, covariate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorial_design_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables</p>
</td></tr>
<tr><td><code id="factorial_design_+3A_dv">dv</code></td>
<td>
<p>(numeric) dependent variable name.</p>
</td></tr>
<tr><td><code id="factorial_design_+3A_wid">wid</code></td>
<td>
<p>(factor) column name containing individuals/subjects identifier.
Should be unique per individual.</p>
</td></tr>
<tr><td><code id="factorial_design_+3A_between">between</code></td>
<td>
<p>(optional) between-subject factor variables.</p>
</td></tr>
<tr><td><code id="factorial_design_+3A_within">within</code></td>
<td>
<p>(optional) within-subjects factor variables</p>
</td></tr>
<tr><td><code id="factorial_design_+3A_covariate">covariate</code></td>
<td>
<p>(optional) covariate names (for ANCOVA)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following components: </p>
 <ul>
<li> <p><strong>the
specified arguments</strong>: <code>dv, wid, between, within</code> </p>
</li>
<li> <p><strong>data</strong>:
the original data (long format) or independent ANOVA. The wide format is
returned for repeated measures ANOVA. </p>
</li>
<li> <p><strong>idata</strong>: an optional data
frame giving the levels of factors defining the intra-subject model for
multivariate repeated-measures data. </p>
</li>
<li> <p><strong>idesign</strong>: a one-sided
model formula using the “data” in idata and specifying the intra-subject
design. </p>
</li>
<li> <p><strong>repeated</strong>: logical. Value is TRUE when the data is a
repeated design. </p>
</li>
<li> <p><strong>lm_formula</strong>: the formula used to build the
<code>lm</code> model. </p>
</li>
<li> <p><strong>lm_data</strong>: the data used to build the <code>lm</code>
model. Can be either in a long format (i.e., the original data for
independent measures ANOVA) or in a wide format (case of repeated measures ANOVA). </p>
</li>
<li> <p><strong>model</strong>: the <code>lm</code> model </p>
</li></ul>



<h3>Author(s)</h3>

<p>Alboukadel Kassambara, <a href="mailto:alboukadel.kassambara@gmail.com">alboukadel.kassambara@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+anova_test">anova_test</a>()</code>, <code><a href="#topic+anova_summary">anova_summary</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth
head(df)

# Repeated measures designs
#:::::::::::::::::::::::::::::::::::::::::
# Prepare the data
df$id &lt;- rep(1:10, 6) # Add individuals id
head(df)
# Build factorial designs
design &lt;- factorial_design(df, dv = len, wid = id, within = c(supp, dose))
design
# Easily perform repeated measures ANOVA using the car package
res.anova &lt;- Anova(design$model, idata = design$idata, idesign = design$idesign, type = 3)
summary(res.anova, multivariate = FALSE)

# Independent measures designs
#:::::::::::::::::::::::::::::::::::::::::
# Build factorial designs
df$id &lt;- 1:nrow(df)
design &lt;- factorial_design(df, dv = len, wid = id, between = c(supp, dose))
design
# Perform ANOVA
Anova(design$model, type = 3)

</code></pre>

<hr>
<h2 id='fisher_test'>Fisher's Exact Test for Count Data</h2><span id='topic+fisher_test'></span><span id='topic+pairwise_fisher_test'></span><span id='topic+row_wise_fisher_test'></span>

<h3>Description</h3>

<p>Performs Fisher's exact test for testing the null of independence
of rows and columns in a contingency table.
</p>
<p>Wrappers around the R base function <code><a href="stats.html#topic+fisher.test">fisher.test</a>()</code> but
have the advantage of performing pairwise and row-wise fisher tests, the
post-hoc tests following a significant chi-square test of homogeneity for 2xc
and rx2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher_test(
  xtab,
  workspace = 2e+05,
  alternative = "two.sided",
  conf.int = TRUE,
  conf.level = 0.95,
  simulate.p.value = FALSE,
  B = 2000,
  detailed = FALSE,
  ...
)

pairwise_fisher_test(xtab, p.adjust.method = "holm", detailed = FALSE, ...)

row_wise_fisher_test(xtab, p.adjust.method = "holm", detailed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher_test_+3A_xtab">xtab</code></td>
<td>
<p>a contingency table in a matrix form.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_workspace">workspace</code></td>
<td>
<p>an integer specifying the size of the workspace
used in the network algorithm.  In units of 4 bytes.  Only used for
non-simulated p-values larger than <code class="reqn">2 \times 2</code> tables.
Since <span class="rlang"><b>R</b></span> version 3.5.0, this also increases the internal stack size
which allows larger problems to be solved, however sometimes needing
hours.  In such cases, <code>simulate.p.values=TRUE</code> may be more
reasonable.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_alternative">alternative</code></td>
<td>
<p>indicates the alternative hypothesis and must be
one of <code>"two.sided"</code>, <code>"greater"</code> or <code>"less"</code>.
You can specify just the initial letter.  Only used in the
<code class="reqn">2 \times 2</code> case.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_conf.int">conf.int</code></td>
<td>
<p>logical indicating if a confidence interval for the
odds ratio in a <code class="reqn">2 \times 2</code> table should be
computed (and returned).</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for the returned confidence
interval.  Only used in the <code class="reqn">2 \times 2</code> case and if
<code>conf.int = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_simulate.p.value">simulate.p.value</code></td>
<td>
<p>a logical indicating whether to compute
p-values by Monte Carlo simulation, in larger than <code class="reqn">2 \times
      2</code> tables.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_b">B</code></td>
<td>
<p>an integer specifying the number of replicates used in the
Monte Carlo test.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function <code>fisher_test()</code>.</p>
</td></tr>
<tr><td><code id="fisher_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>group</code>: the categories in the row-wise proportion tests. </p>
</li>
<li>
<p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>: the adjusted p-value. </p>
</li>
<li>
<p><code>method</code>: the used statistical test. </p>
</li>
<li> <p><code>p.signif,
 p.adj.signif</code>: the significance level of p-values and adjusted p-values,
respectively. </p>
</li>
<li> <p><code>estimate</code>: an estimate of the odds ratio. Only
present in the 2 by 2 case. </p>
</li>
<li> <p><code>alternative</code>: a character string
describing the alternative hypothesis. </p>
</li>
<li> <p><code>conf.low,conf.high</code>: a
confidence interval for the odds ratio. Only present in the 2 by 2 case and
if argument conf.int = TRUE.</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>fisher_test()</code>: performs Fisher's exact test for testing the null of
independence of rows and columns in a contingency table with fixed
marginals. Wrapper around the function <code><a href="stats.html#topic+fisher.test">fisher.test</a>()</code>.
</p>
</li>
<li> <p><code>pairwise_fisher_test()</code>: pairwise comparisons between proportions, a post-hoc
tests following a significant Fisher's exact test of homogeneity for 2xc
design.
</p>
</li>
<li> <p><code>row_wise_fisher_test()</code>: performs row-wise Fisher's exact test of count data, a post-hoc tests following a significant chi-square test
of homogeneity for rx2 contingency table. The test is conducted for each category (row).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Comparing two proportions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: frequencies of smokers between two groups
xtab &lt;- as.table(rbind(c(490, 10), c(400, 100)))
dimnames(xtab) &lt;- list(
  group = c("grp1", "grp2"),
  smoker = c("yes", "no")
)
xtab
# compare the proportion of smokers
fisher_test(xtab, detailed = TRUE)

# Homogeneity of proportions between groups
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# H0: the proportion of smokers is similar in the four groups
# Ha:  this proportion is different in at least one of the populations.
#
# Data preparation
grp.size &lt;- c( 106, 113, 156, 102 )
smokers  &lt;- c( 50, 100, 139, 80 )
no.smokers &lt;- grp.size - smokers
xtab &lt;- as.table(rbind(
  smokers,
  no.smokers
))
dimnames(xtab) &lt;- list(
  Smokers = c("Yes", "No"),
  Groups = c("grp1", "grp2", "grp3", "grp4")
)
xtab

# Compare the proportions of smokers between groups
fisher_test(xtab, detailed = TRUE)

# Pairwise comparison between groups
pairwise_fisher_test(xtab)


# Pairwise proportion tests
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: Titanic
xtab &lt;- as.table(rbind(
  c(122, 167, 528, 673),
  c(203, 118, 178, 212)
))
dimnames(xtab) &lt;- list(
  Survived = c("No", "Yes"),
  Class = c("1st", "2nd", "3rd", "Crew")
)
xtab
# Compare the proportion of survived between groups
pairwise_fisher_test(xtab)

# Row-wise proportion tests
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: Titanic
xtab &lt;- as.table(rbind(
  c(180, 145), c(179, 106),
  c(510, 196), c(862, 23)
))
dimnames(xtab) &lt;- list(
  Class = c("1st", "2nd", "3rd", "Crew"),
  Gender = c("Male", "Female")
)
xtab
# Compare the proportion of males and females in each category
row_wise_fisher_test(xtab)

# A r x c table  Agresti (2002, p. 57) Job Satisfaction
Job &lt;- matrix(c(1,2,1,0, 3,3,6,1, 10,10,14,9, 6,7,12,11), 4, 4,
              dimnames = list(income = c("&lt; 15k", "15-25k", "25-40k", "&gt; 40k"),
                             satisfaction = c("VeryD", "LittleD", "ModerateS", "VeryS")))
fisher_test(Job)
fisher_test(Job, simulate.p.value = TRUE, B = 1e5)
</code></pre>

<hr>
<h2 id='freq_table'>Compute Frequency Table</h2><span id='topic+freq_table'></span>

<h3>Description</h3>

<p>compute frequency table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freq_table(data, ..., vars = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freq_table_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="freq_table_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to specify variables of interest.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_vars">vars</code></td>
<td>
<p>optional character vector containing variable names.</p>
</td></tr>
<tr><td><code id="freq_table_+3A_na.rm">na.rm</code></td>
<td>
<p>logical value. If TRUE (default), remove missing values in the
variables used to create the frequency table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("ToothGrowth")
ToothGrowth %&gt;% freq_table(supp, dose)
</code></pre>

<hr>
<h2 id='friedman_effsize'>Friedman Test Effect Size (Kendall's W Value)</h2><span id='topic+friedman_effsize'></span>

<h3>Description</h3>

<p>Compute the effect size estimate (referred to as <code>w</code>) for
Friedman test: <code>W = X2/N(K-1)</code>; where <code>W</code> is the Kendall's W
value; <code>X2</code> is the Friedman test statistic value; <code>N</code> is the sample
size. <code>k</code> is the number of measurements per subject.
</p>
<p>The Kendall’s W coefficient assumes the value from 0 (indicating no
relationship) to 1 (indicating a perfect relationship).
</p>
<p>Kendalls uses the Cohen’s interpretation guidelines of <code>0.1 - &lt; 0.3</code> (small
effect), <code>0.3 - &lt; 0.5</code> (moderate effect) and <code>&gt;= 0.5</code> (large
effect)
</p>
<p>Confidence intervals are calculated by bootstap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friedman_effsize(
  data,
  formula,
  ci = FALSE,
  conf.level = 0.95,
  ci.type = "perc",
  nboot = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="friedman_effsize_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>a ~ b | c</code>, where <code>a</code>
(numeric) is the dependent variable name; <code>b</code> is the within-subjects
factor variables; and <code>c</code> (factor) is the column name containing
individuals/subjects identifier. Should be unique per individual.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_ci">ci</code></td>
<td>
<p>If TRUE, returns confidence intervals by bootstrap. May be slow.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_conf.level">conf.level</code></td>
<td>
<p>The level for the confidence interval.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_ci.type">ci.type</code></td>
<td>
<p>The type of confidence interval to use. Can be any of &quot;norm&quot;,
&quot;basic&quot;, &quot;perc&quot;, or &quot;bca&quot;. Passed to <code>boot::boot.ci</code>.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_nboot">nboot</code></td>
<td>
<p>The number of replications to use for bootstrap.</p>
</td></tr>
<tr><td><code id="friedman_effsize_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function <code><a href="stats.html#topic+friedman.test">friedman.test</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>n</code>: Sample
counts. </p>
</li>
<li> <p><code>effsize</code>: estimate of the effect size. </p>
</li>
<li>
<p><code>magnitude</code>: magnitude of effect size. </p>
</li>
<li> <p><code>conf.low,conf.high</code>:
lower and upper bound of the effect size confidence interval.</p>
</li></ul>



<h3>References</h3>

<p>Maciej Tomczak and Ewa Tomczak. The need to report effect size
estimates revisited. An overview of some recommended measures of effect
size. Trends in Sport Sciences. 2014; 1(21):19-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth %&gt;%
    filter(supp == "VC") %&gt;%
    mutate(id = rep(1:10, 3))
head(df)

# Friedman test effect size
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% friedman_effsize(len ~ dose | id)
</code></pre>

<hr>
<h2 id='friedman_test'>Friedman Rank Sum Test</h2><span id='topic+friedman_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to perform a Friedman rank sum
test, which is the non-parametric alternative to the one-way repeated
measures ANOVA test. Wrapper around the function
<code><a href="stats.html#topic+friedman.test">friedman.test</a>()</code>. Read more:
<a href="https://www.datanovia.com/en/lessons/friedman-test-in-r/">Friedman
test in R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>friedman_test(data, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="friedman_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="friedman_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>a ~ b | c</code>, where <code>a</code>
(numeric) is the dependent variable name; <code>b</code> is the within-subjects
factor variables; and <code>c</code> (factor) is the column name containing
individuals/subjects identifier. Should be unique per individual.</p>
</td></tr>
<tr><td><code id="friedman_test_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="stats.html#topic+friedman.test">friedman.test</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y (dependent) variable used in the test. </p>
</li>
<li> <p><code>n</code>:
sample count. </p>
</li>
<li> <p><code>statistic</code>: the value of Friedman's chi-squared
statistic, used to compute the p-value. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li>
<p><code>method</code>: the statistical test used to compare groups.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth %&gt;%
    filter(supp == "VC") %&gt;%
    mutate(id = rep(1:10, 3))
head(df)

# Friedman rank sum test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% friedman_test(len ~ dose | id)

</code></pre>

<hr>
<h2 id='games_howell_test'>Games Howell Post-hoc Tests</h2><span id='topic+games_howell_test'></span>

<h3>Description</h3>

<p>Performs Games-Howell test, which is used to compare all possible
combinations of group differences when the assumption of homogeneity of
variances is violated. This post hoc test provides confidence intervals for
the differences between group means and shows whether the differences are
statistically significant.
</p>
<p>The test is based on Welch’s degrees of freedom correction and uses Tukey’s
studentized range distribution for computing the p-values. The test compares
the difference between each pair of means with appropriate adjustment for
the multiple testing. So there is no need to apply additional p-value
corrections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>games_howell_test(data, formula, conf.level = 0.95, detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="games_howell_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="games_howell_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="games_howell_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="games_howell_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Games-Howell method is an improved version of the Tukey-Kramer
method and is applicable in cases where the equivalence of variance
assumption is violated. It is a t-test using Welch’s degree of freedom. This
method uses a strategy for controlling the type I error for the entire
comparison and is known to maintain the preset significance level even when
the size of the sample is different. However, the smaller the number of
samples in each group, the it is more tolerant the type I error control.
Thus, this method can be applied when the number of samples is six or more.
</p>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y (outcome) variable used in the test. </p>
</li>
<li>
<p><code>group1,group2</code>: the compared groups in the pairwise tests. </p>
</li>
<li>
<p><code>n1,n2</code>: Sample counts. </p>
</li>
<li> <p><code>estimate, conf.low, conf.high</code>:
mean difference and its confidence intervals. </p>
</li>
<li> <p><code>statistic</code>: Test
statistic (t-value) used to compute the p-value. </p>
</li>
<li> <p><code>df</code>: degrees of
freedom calculated using Welch’s correction. </p>
</li>
<li> <p><code>p.adj</code>: adjusted p-value using Tukey's method. </p>
</li>
<li>
<p><code>method</code>: the statistical test used to compare groups. </p>
</li>
<li>
<p><code>p.adj.signif</code>: the significance level of p-values. </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>References</h3>

 <ul>
<li><p> Aaron Schlege,
https://rpubs.com/aaronsc32/games-howell-test. </p>
</li>
<li><p> Sangseok Lee, Dong Kyu
Lee. What is the proper way to apply the multiple comparison test?. Korean J
Anesthesiol. 2018;71(5):353-360. </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simple test
ToothGrowth %&gt;% games_howell_test(len ~ dose)

# Grouped data
ToothGrowth %&gt;%
  group_by(supp) %&gt;%
  games_howell_test(len ~ dose)

</code></pre>

<hr>
<h2 id='get_comparisons'>Create a List of Possible Comparisons Between Groups</h2><span id='topic+get_comparisons'></span>

<h3>Description</h3>

<p>Create a list of possible pairwise comparisons between groups. If
a reference group is specified, only comparisons against reference will be
kept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_comparisons(data, variable, ref.group = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_comparisons_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="get_comparisons_+3A_variable">variable</code></td>
<td>
<p>the grouping variable name. Can be unquoted.</p>
</td></tr>
<tr><td><code id="get_comparisons_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. Can be
unquoted. If numeric, then it should be quoted. If specified, for a
given grouping variable, each of the group levels will be compared to the
reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise comparisons are performed between each
grouping variable levels against all (i.e. basemean).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all possible pairwise comparisons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All possible pairwise comparisons
ToothGrowth %&gt;%
  get_comparisons("dose")

# Comparisons against reference groups
ToothGrowth %&gt;%
  get_comparisons("dose", ref.group = "0.5")

# Comparisons against  all (basemean)
ToothGrowth %&gt;%
  get_comparisons("dose", ref.group = "all")
</code></pre>

<hr>
<h2 id='get_mode'>Compute Mode</h2><span id='topic+get_mode'></span>

<h3>Description</h3>

<p>Compute the mode in a given vector. Mode is the most frequent
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mode(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mode_+3A_x">x</code></td>
<td>
<p>a vector. Can be numeric, factor or character vector.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Mode of numeric vector
x &lt;- c(1:5, 6, 6, 7:10)
get_mode(x)

# Bimodal
x &lt;- c(1:5, 6, 6, 7, 8, 9, 9, 10)
get_mode(x)

# No mode
x &lt;- c(1, 2, 3, 4, 5)
get_mode(x)

# Nominal vector
fruits &lt;-  c(rep("orange", 10), rep("apple", 5), rep("lemon", 2))
get_mode(fruits)
</code></pre>

<hr>
<h2 id='get_pwc_label'>Extract Label Information from Statistical Tests</h2><span id='topic+get_pwc_label'></span><span id='topic+get_test_label'></span><span id='topic+create_test_label'></span><span id='topic+get_n'></span><span id='topic+get_description'></span>

<h3>Description</h3>

<p>Extracts label information from statistical tests. Useful for
labelling plots with test outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pwc_label(stat.test, type = c("expression", "text"))

get_test_label(
  stat.test,
  description = NULL,
  p.col = "p",
  type = c("expression", "text"),
  correction = c("auto", "GG", "HF", "none"),
  row = NULL,
  detailed = FALSE
)

create_test_label(
  statistic.text,
  statistic,
  p,
  parameter = NA,
  description = NULL,
  n = NA,
  effect.size = NA,
  effect.size.text = NA,
  type = c("expression", "text"),
  detailed = FALSE
)

get_n(stat.test)

get_description(stat.test)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pwc_label_+3A_stat.test">stat.test</code></td>
<td>
<p>statistical test results returned by <code>rstatix</code>
functions.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_type">type</code></td>
<td>
<p>the label type. Can be one of &quot;text&quot; and &quot;expression&quot;. Partial
match allowed. If you want to add the label onto a ggplot, it might be
useful to specify <code>type = "expresion"</code>.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_description">description</code></td>
<td>
<p>the test description used as the prefix of the label.
Examples of description are &quot;ANOVA&quot;, &quot;Two Way ANOVA&quot;. To remove the default
description, specify <code>description = NULL</code>. If missing, we'll try to
guess the statistical test default description.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_p.col">p.col</code></td>
<td>
<p>character specifying the column containing the p-value. Default
is <code>"p"</code>, can be <code>"p.adj"</code>.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_correction">correction</code></td>
<td>
<p>character, considered only in the case of ANOVA test. Which sphericity
correction of the degrees of freedom should be reported for the
within-subject factors (repeated measures). The default is set to
<code>"GG"</code> corresponding to the Greenhouse-Geisser correction. Possible
values are <code>"GG"</code>, <code>"HF"</code> (i.e., Hyunh-Feldt correction),
<code>"none"</code> (i.e., no correction) and <code>"auto"</code> (apply automatically
GG correction if the sphericity assumption is not for within-subject
design.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_row">row</code></td>
<td>
<p>numeric, the row index to be considered. If NULL, the last row is
automatically considered for ANOVA test.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_detailed">detailed</code></td>
<td>
<p>logical value. If TRUE, returns detailed label.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_statistic.text">statistic.text</code></td>
<td>
<p>character specifying the test statistic. For example
<code>statistic.text = "F"</code> (for ANOVA test ); <code>statistic.text = "t"</code>
(for t-test ).</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_statistic">statistic</code></td>
<td>
<p>the numeric value of a statistic.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_p">p</code></td>
<td>
<p>the p-value of the test.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_parameter">parameter</code></td>
<td>
<p>string containing the degree of freedom (if exists). Default
is <code>NA</code> to accommodate non-parametric tests. For example
<code>parameter = "1,9"</code> (for ANOVA test. Two parameters exist: DFn and
DFd); <code>sparameter = "9"</code> (for t-test ).</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_n">n</code></td>
<td>
<p>sample count, example: <code>n = 10</code>.</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_effect.size">effect.size</code></td>
<td>
<p>the effect size value</p>
</td></tr>
<tr><td><code id="get_pwc_label_+3A_effect.size.text">effect.size.text</code></td>
<td>
<p>a character specifying the relevant effect size. For
example, for <code>Cohens d</code> statistic, <code>effect.size.text = "d"</code>. You
can also use plotmath expression as follow <code>quote(italic("d"))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a text label or an expression to pass to a plotting function.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>get_pwc_label()</code>: Extract label from pairwise comparisons.
</p>
</li>
<li> <p><code>get_test_label()</code>: Extract labels for statistical tests.
</p>
</li>
<li> <p><code>create_test_label()</code>: Create labels from user specified test results.
</p>
</li>
<li> <p><code>get_n()</code>: Extracts sample counts (n) from an rstatix test outputs. Returns a numeric vector.
</p>
</li>
<li> <p><code>get_description()</code>: Extracts the description of an rstatix test outputs. Returns a character vector.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# One-way ANOVA test
#:::::::::::::::::::::::::::::::::::::::::
anov &lt;- df %&gt;% anova_test(len ~ dose)
get_test_label(anov, detailed = TRUE, type = "text")

# Two-way ANOVA test
#:::::::::::::::::::::::::::::::::::::::::
anov &lt;- df %&gt;% anova_test(len ~ supp*dose)
get_test_label(anov, detailed = TRUE, type = "text",
   description = "Two Way ANOVA")


# Kruskal-Wallis test
#:::::::::::::::::::::::::::::::::::::::::
kruskal&lt;- df %&gt;% kruskal_test(len ~ dose)
get_test_label(kruskal, detailed = TRUE, type = "text")

# Wilcoxon test
#:::::::::::::::::::::::::::::::::::::::::
# Unpaired test
wilcox &lt;- df %&gt;% wilcox_test(len ~ supp)
get_test_label(wilcox, detailed = TRUE, type = "text")
# Paired test
wilcox &lt;- df %&gt;% wilcox_test(len ~ supp, paired = TRUE)
get_test_label(wilcox, detailed = TRUE, type = "text")

# T test
#:::::::::::::::::::::::::::::::::::::::::
ttest &lt;- df %&gt;% t_test(len ~ dose)
get_test_label(ttest, detailed = TRUE, type = "text")


# Pairwise comparisons labels
#:::::::::::::::::::::::::::::::::::::::::
get_pwc_label(ttest, type = "text")


# Create test labels
#:::::::::::::::::::::::::::::::::::::::::
create_test_label(
  statistic.text = "F", statistic = 71.82,
  parameter = "4, 294",
  p = "&lt;0.0001",
  description = "ANOVA",
  type = "text"
)


# Extract infos
#:::::::::::::::::::::::::::::::::::::::::
stat.test &lt;- df %&gt;% t_test(len ~ dose)
get_n(stat.test)
get_description(stat.test)


</code></pre>

<hr>
<h2 id='get_summary_stats'>Compute Summary Statistics</h2><span id='topic+get_summary_stats'></span>

<h3>Description</h3>

<p>Compute summary statistics for one or multiple numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_summary_stats(
  data,
  ...,
  type = c("full", "common", "robust", "five_number", "mean_sd", "mean_se", "mean_ci",
    "median_iqr", "median_mad", "quantile", "mean", "median", "min", "max"),
  show = NULL,
  probs = seq(0, 1, 0.25)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_summary_stats_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_...">...</code></td>
<td>
<p>(optional) One or more unquoted expressions (or variable names)
separated by commas. Used to select a variable of interest. If no variable
is specified, then the summary statistics of all numeric variables in the
data frame is computed.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_type">type</code></td>
<td>
<p>type of summary statistics. Possible values include: <code>"full",
"common", "robust",  "five_number", "mean_sd", "mean_se", "mean_ci",
"median_iqr", "median_mad", "quantile", "mean", "median",  "min", "max"</code></p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_show">show</code></td>
<td>
<p>a character vector specifying the summary statistics you want to
show. Example: <code>show = c("n", "mean", "sd")</code>. This is used to filter
the output after computation.</p>
</td></tr>
<tr><td><code id="get_summary_stats_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in [0,1]. Used only when type = &quot;quantile&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing descriptive statistics, such as: </p>

<ul>
<li> <p><strong>n</strong>: the number of individuals </p>
</li>
<li> <p><strong>min</strong>: minimum
</p>
</li>
<li> <p><strong>max</strong>: maximum </p>
</li>
<li> <p><strong>median</strong>: median </p>
</li>
<li>
<p><strong>mean</strong>: mean </p>
</li>
<li> <p><strong>q1, q3</strong>: the first and the third quartile,
respectively. </p>
</li>
<li> <p><strong>iqr</strong>: interquartile range </p>
</li>
<li> <p><strong>mad</strong>:
median absolute deviation (see ?MAD) </p>
</li>
<li> <p><strong>sd</strong>: standard deviation
of the mean </p>
</li>
<li> <p><strong>se</strong>: standard error of the mean </p>
</li>
<li> <p><strong>ci</strong>: 95 percent confidence interval of the mean </p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Full summary statistics
data("ToothGrowth")
ToothGrowth %&gt;% get_summary_stats(len)

# Summary statistics of grouped data
# Show only common summary
ToothGrowth %&gt;%
  group_by(dose, supp) %&gt;%
  get_summary_stats(len, type = "common")

# Robust summary statistics
ToothGrowth %&gt;% get_summary_stats(len, type = "robust")

# Five number summary statistics
ToothGrowth %&gt;% get_summary_stats(len, type = "five_number")

# Compute only mean and sd
ToothGrowth %&gt;% get_summary_stats(len, type = "mean_sd")

# Compute full summary statistics but show only mean, sd, median, iqr
ToothGrowth %&gt;%
    get_summary_stats(len, show = c("mean", "sd", "median", "iqr"))

</code></pre>

<hr>
<h2 id='get_y_position'>Autocompute P-value Positions For Plotting Significance</h2><span id='topic+get_y_position'></span><span id='topic+add_y_position'></span><span id='topic+add_x_position'></span><span id='topic+add_xy_position'></span>

<h3>Description</h3>

<p>Compute p-value x and y positions for plotting significance
levels. Many examples are provided at : </p>
 <ul>
<li>
<p><a href="https://www.datanovia.com/en/blog/how-to-add-p-values-onto-a-grouped-ggplot-using-the-ggpubr-r-package/">How
to Add P-Values onto a Grouped GGPLOT using the GGPUBR R Package</a> </p>
</li>
<li>
<p><a href="https://www.datanovia.com/en/blog/ggpubr-how-to-add-adjusted-p-values-to-a-multi-panel-ggplot/">How
to Add Adjusted P-values to a Multi-Panel GGPlot</a> </p>
</li>
<li>
<p><a href="https://www.datanovia.com/en/blog/ggpubr-how-to-add-p-values-generated-elsewhere-to-a-ggplot/">How
to Add P-Values Generated Elsewhere to a GGPLOT</a> </p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>get_y_position(
  data,
  formula,
  fun = "max",
  ref.group = NULL,
  comparisons = NULL,
  step.increase = 0.12,
  y.trans = NULL,
  stack = FALSE,
  scales = c("fixed", "free", "free_y")
)

add_y_position(
  test,
  fun = "max",
  step.increase = 0.12,
  data = NULL,
  formula = NULL,
  ref.group = NULL,
  comparisons = NULL,
  y.trans = NULL,
  stack = FALSE,
  scales = c("fixed", "free", "free_y")
)

add_x_position(test, x = NULL, group = NULL, dodge = 0.8)

add_xy_position(
  test,
  x = NULL,
  group = NULL,
  dodge = 0.8,
  stack = FALSE,
  fun = "max",
  step.increase = 0.12,
  scales = c("fixed", "free", "free_y"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_y_position_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_fun">fun</code></td>
<td>
<p>summary statistics functions used to compute automatically suitable
y positions of p-value labels and brackets. Possible values include:
<code>"max", "mean", "mean_sd", "mean_se", "mean_ci", "median",
 "median_iqr", "median_mad"</code>.
</p>
<p>For example, if <code>fun = "max"</code>, the y positions are guessed as follow:
</p>
 <ul>
<li><p> 1. Compute the maximum of each group (groups.maximum) </p>
</li>
<li>
<p>2. Use the highest groups maximum as the first bracket y position </p>
</li>
<li><p> 3.
Add successively a step increase for remaining bracket y positions. </p>
</li></ul>

<p>When the main plot is a boxplot, you need the option <code>fun = "max"</code>, to
have the p-value bracket displayed at the maximum point of the group.
</p>
<p>In some situations the main plot is a line plot or a barplot showing the
<code>mean+/-error bars</code> of the groups, where error can be SE (standard
error), SD (standard deviation) or CI (confidence interval). In this case,
to correctly compute the bracket y position you need the option <code>fun =
 "mean_se"</code>, etc.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="get_y_position_+3A_step.increase">step.increase</code></td>
<td>
<p>numeric vector with the increase in fraction of total
height for every additional comparison to minimize overlap.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_y.trans">y.trans</code></td>
<td>
<p>a function for transforming y axis scale. Value can be
<code>log2</code>, <code>log10</code> and <code>sqrt</code>. Can be also any custom function
that can take a numeric vector as input and returns a numeric vector,
example: <code>y.trans = function(x){log2(x+1)}</code></p>
</td></tr>
<tr><td><code id="get_y_position_+3A_stack">stack</code></td>
<td>
<p>logical. If TRUE, computes y position for a stacked plot. Useful
when dealing with stacked bar plots.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_scales">scales</code></td>
<td>
<p>Should scales be fixed (<code>"fixed"</code>, the default), free
(<code>"free"</code>), or free in one dimension (<code>"free_y"</code>)?. This option is
considered only when determining the y position. If the specified value is
<code>"free"</code> or <code>"free_y"</code>, then the step increase of y positions will
be calculated by plot panels. Note that, using <code>"free"</code> or
<code>"free_y"</code> gives the same result. A global step increase is computed
when <code>scales = "fixed"</code>.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_test">test</code></td>
<td>
<p>an object of class <code>rstatix_test</code> as returned by
<code><a href="#topic+t_test">t_test</a>()</code>, <code><a href="#topic+wilcox_test">wilcox_test</a>()</code>,
<code><a href="#topic+sign_test">sign_test</a>()</code>, <code><a href="#topic+tukey_hsd">tukey_hsd</a>()</code>,
<code><a href="#topic+dunn_test">dunn_test</a>()</code>.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_x">x</code></td>
<td>
<p>variable on x axis.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_group">group</code></td>
<td>
<p>group variable (legend variable).</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_dodge">dodge</code></td>
<td>
<p>dodge width for grouped ggplot/test. Default is 0.8. Used only
when <code>x</code> specified.</p>
</td></tr>
<tr><td><code id="get_y_position_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="stats.html#topic+t.test">t.test</a></code>.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>get_y_position()</code>: compute the p-value y positions
</p>
</li>
<li> <p><code>add_y_position()</code>: add p-value y positions to an object of class <code>rstatix_test</code>
</p>
</li>
<li> <p><code>add_x_position()</code>: compute and add p-value x positions.
</p>
</li>
<li> <p><code>add_xy_position()</code>: compute and add both x and y positions.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
#::::::::::::::::::::::::::::::::::::
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)
df$group &lt;- factor(rep(c(1, 2), 30))
head(df)

# Stat tests
#::::::::::::::::::::::::::::::::::::
stat.test &lt;- df %&gt;%
  t_test(len ~ dose)
stat.test

# Add the test into box plots
#::::::::::::::::::::::::::::::::::::
stat.test &lt;- stat.test %&gt;%
  add_y_position()

 if(require("ggpubr")){
   ggboxplot(df, x = "dose", y = "len") +
     stat_pvalue_manual(stat.test, label = "p.adj.signif", tip.length = 0.01)
  }

</code></pre>

<hr>
<h2 id='identify_outliers'>Identify Univariate Outliers Using Boxplot Methods</h2><span id='topic+identify_outliers'></span><span id='topic+is_outlier'></span><span id='topic+is_extreme'></span>

<h3>Description</h3>

<p>Detect outliers using boxplot methods. Boxplots are a popular and
an easy method for identifying outliers. There are two categories of
outlier: (1) outliers and (2) extreme points.
</p>
<p>Values above <code>Q3 + 1.5xIQR</code> or below <code>Q1 - 1.5xIQR</code> are considered
as outliers. Values above <code>Q3 + 3xIQR</code> or below <code>Q1 - 3xIQR</code> are
considered as extreme points (or extreme outliers).
</p>
<p>Q1 and Q3 are the first and third quartile, respectively. IQR is the
interquartile range (IQR = Q3 - Q1).
</p>
<p>Generally speaking, data points that are labelled outliers in boxplots are
not considered as troublesome as those considered extreme points and might
even be ignored. Note that, any <code>NA</code> and <code>NaN</code> are automatically removed
before the quantiles are computed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_outliers(data, ..., variable = NULL)

is_outlier(x, coef = 1.5)

is_extreme(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_outliers_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="identify_outliers_+3A_...">...</code></td>
<td>
<p>One unquoted expressions (or variable name). Used to select a
variable of interest. Alternative to the argument <code>variable</code>.</p>
</td></tr>
<tr><td><code id="identify_outliers_+3A_variable">variable</code></td>
<td>
<p>variable name for detecting outliers</p>
</td></tr>
<tr><td><code id="identify_outliers_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="identify_outliers_+3A_coef">coef</code></td>
<td>
<p>coefficient specifying how far the outlier should be from the edge
of their box. Possible values are 1.5 (for outlier) and 3 (for extreme
points only). Default is 1.5</p>
</td></tr>
</table>


<h3>Value</h3>

 <ul>
<li> <p><code>identify_outliers()</code>. Returns the input data
frame with two additional columns: &quot;is.outlier&quot; and &quot;is.extreme&quot;, which hold
logical values. </p>
</li>
<li> <p><code>is_outlier() and is_extreme()</code>. Returns logical
vectors. </p>
</li></ul>



<h3>Functions</h3>


<ul>
<li> <p><code>identify_outliers()</code>: takes a data frame and extract rows suspected as outliers
according to a numeric column. The following columns are added &quot;is.outlier&quot;
and &quot;is.extreme&quot;.
</p>
</li>
<li> <p><code>is_outlier()</code>: detect outliers in a numeric vector. Returns logical vector.
</p>
</li>
<li> <p><code>is_extreme()</code>: detect extreme points in a numeric vector. An alias of
<code>is_outlier()</code>, where coef = 3. Returns logical vector.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a demo data
set.seed(123)
demo.data &lt;- data.frame(
  sample = 1:20,
  score = c(rnorm(19, mean = 5, sd = 2), 50),
  gender = rep(c("Male", "Female"), each = 10)
)

# Identify outliers according to the variable score
demo.data %&gt;%
  identify_outliers(score)

# Identify outliers by groups
demo.data %&gt;%
  group_by(gender) %&gt;%
  identify_outliers("score")
</code></pre>

<hr>
<h2 id='kruskal_effsize'>Kruskal-Wallis Effect Size</h2><span id='topic+kruskal_effsize'></span>

<h3>Description</h3>

<p>Compute the effect size for Kruskal-Wallis test as the eta
squared based on the H-statistic: <code>eta2[H] = (H - k + 1)/(n - k)</code>;
where <code>H</code> is the value obtained in the Kruskal-Wallis test; <code>k</code> is
the number of groups; <code>n</code> is the total number of observations.
</p>
<p>The eta-squared estimate assumes values from 0 to 1 and multiplied by 100
indicates the percentage of variance in the dependent variable explained by
the independent variable. The interpretation values commonly in published
litterature are: <code>0.01- &lt; 0.06</code> (small effect), <code>0.06 - &lt; 0.14</code>
(moderate effect) and <code>&gt;= 0.14</code> (large effect).
</p>
<p>Confidence intervals are calculated by bootstap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kruskal_effsize(
  data,
  formula,
  ci = FALSE,
  conf.level = 0.95,
  ci.type = "perc",
  nboot = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kruskal_effsize_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="kruskal_effsize_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="kruskal_effsize_+3A_ci">ci</code></td>
<td>
<p>If TRUE, returns confidence intervals by bootstrap. May be slow.</p>
</td></tr>
<tr><td><code id="kruskal_effsize_+3A_conf.level">conf.level</code></td>
<td>
<p>The level for the confidence interval.</p>
</td></tr>
<tr><td><code id="kruskal_effsize_+3A_ci.type">ci.type</code></td>
<td>
<p>The type of confidence interval to use. Can be any of &quot;norm&quot;,
&quot;basic&quot;, &quot;perc&quot;, or &quot;bca&quot;. Passed to <code>boot::boot.ci</code>.</p>
</td></tr>
<tr><td><code id="kruskal_effsize_+3A_nboot">nboot</code></td>
<td>
<p>The number of replications to use for bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>n</code>: Sample
counts. </p>
</li>
<li> <p><code>effsize</code>: estimate of the effect size. </p>
</li>
<li>
<p><code>magnitude</code>: magnitude of effect size. </p>
</li>
<li> <p><code>conf.low,conf.high</code>:
lower and upper bound of the effect size confidence interval.</p>
</li></ul>



<h3>References</h3>

<p>Maciej Tomczak and Ewa Tomczak. The need to report effect size
estimates revisited. An overview of some recommended measures of effect
size. Trends in Sport Sciences. 2014; 1(21):19-25.
</p>
<p>http://imaging.mrc-cbu.cam.ac.uk/statswiki/FAQ/effectSize
</p>
<p>http://www.psy.gla.ac.uk/~steve/best/effect.html
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# Kruskal-wallis rank sum test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% kruskal_effsize(len ~ dose)

# Grouped data
df %&gt;%
  group_by(supp) %&gt;%
  kruskal_effsize(len ~ dose)
</code></pre>

<hr>
<h2 id='kruskal_test'>Kruskal-Wallis Test</h2><span id='topic+kruskal_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to perform Kruskal-Wallis
rank sum test. Wrapper around the function
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kruskal_test(data, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kruskal_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="kruskal_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="kruskal_test_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="stats.html#topic+kruskal.test">kruskal.test</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>n</code>: sample count.
</p>
</li>
<li> <p><code>statistic</code>: the kruskal-wallis rank sum statistic used to
compute the p-value. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>method</code>: the
statistical test used to compare groups.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# Kruskal-wallis rank sum test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% kruskal_test(len ~ dose)

# Grouped data
df %&gt;%
  group_by(supp) %&gt;%
  kruskal_test(len ~ dose)
</code></pre>

<hr>
<h2 id='levene_test'>Levene's Test</h2><span id='topic+levene_test'></span>

<h3>Description</h3>

<p>Provide a pipe-friendly framework to easily compute Levene's
test for homogeneity of variance across groups.
</p>
<p>Wrapper around the function <code><a href="car.html#topic+leveneTest">leveneTest</a>()</code>, which can
additionally handles a grouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>levene_test(data, formula, center = median)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levene_test_+3A_data">data</code></td>
<td>
<p>a data frame for evaluating the formula or a model</p>
</td></tr>
<tr><td><code id="levene_test_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="levene_test_+3A_center">center</code></td>
<td>
<p>The name of a function to compute the center of each group;
mean gives the original Levene's test; the default, median, provides a more
robust test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the following columns: df1, df2
(df.residual), statistic and p.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare the data
data("ToothGrowth")
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)
# Compute Levene's Test
df %&gt;% levene_test(len ~ dose)

# Grouped data
df %&gt;%
  group_by(supp) %&gt;%
  levene_test(len ~ dose)

</code></pre>

<hr>
<h2 id='mahalanobis_distance'>Compute Mahalanobis Distance and Flag Multivariate Outliers</h2><span id='topic+mahalanobis_distance'></span>

<h3>Description</h3>

<p>Pipe-friendly wrapper around to the function
<code><a href="stats.html#topic+mahalanobis">mahalanobis</a>()</code>, which returns the squared
Mahalanobis distance of all rows in x. Compared to the base function, it
automatically flags multivariate outliers.
</p>
<p>Mahalanobis distance is a common metric used to identify multivariate
outliers. The larger the value of Mahalanobis distance, the more unusual the
data point (i.e., the more likely it is to be a multivariate outlier).
</p>
<p>The distance tells us how far an observation is from the center of the cloud, taking into
account the shape (covariance) of the cloud as well.
</p>
<p>To detect outliers, the calculated Mahalanobis distance is compared against
a chi-square (X^2) distribution with degrees of freedom equal to the number
of dependent (outcome) variables and an alpha level of 0.001.
</p>
<p>The threshold to declare a multivariate outlier is determined using the
function <code>qchisq(0.999, df) </code>, where df is the degree of freedom (i.e.,
the number of dependent variable used in the computation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis_distance(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_distance_+3A_data">data</code></td>
<td>
<p>a data frame. Columns are variables.</p>
</td></tr>
<tr><td><code id="mahalanobis_distance_+3A_...">...</code></td>
<td>
<p>One unquoted expressions (or variable name). Used to select a
variable of interest. Can be also used to ignore a variable that are not
needed for the computation. For example specify <code>-id</code> to ignore the id
column.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input data frame with two additional columns: 1)
&quot;mahal.dist&quot;: Mahalanobis distance values; and 2) &quot;is.outlier&quot;: logical
values specifying whether a given observation is a multivariate outlier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute mahalonobis distance and flag outliers if any
iris %&gt;%
  doo(~mahalanobis_distance(.))

# Compute distance by groups and filter outliers
iris %&gt;%
 group_by(Species) %&gt;%
 doo(~mahalanobis_distance(.)) %&gt;%
 filter(is.outlier == TRUE)

</code></pre>

<hr>
<h2 id='make_clean_names'>Make Clean Names</h2><span id='topic+make_clean_names'></span>

<h3>Description</h3>

<p>Pipe-friendly function to make syntactically valid names out of
character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_clean_names(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_clean_names_+3A_data">data</code></td>
<td>
<p>a data frame or vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame or a vector depending on the input data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Vector
make_clean_names(c("a and b", "a-and-b"))
make_clean_names(1:10)

# data frame
df &lt;- data.frame(
`a and b` = 1:4,
`c and d` = 5:8,
 check.names = FALSE
)
df
make_clean_names(df)

</code></pre>

<hr>
<h2 id='Manova'>Manova exported from car package</h2><span id='topic+Manova'></span>

<h3>Description</h3>

<p>See <code>car::<a href="car.html#topic+Anova">Manova</a></code> for details.
</p>

<hr>
<h2 id='mcnemar_test'>McNemar's Chi-squared Test for Count Data</h2><span id='topic+mcnemar_test'></span><span id='topic+pairwise_mcnemar_test'></span>

<h3>Description</h3>

<p>Performs McNemar chi-squared test to compare paired proportions.
</p>
<p>Wrappers around the R base function <code><a href="stats.html#topic+mcnemar.test">mcnemar.test</a>()</code>, but
provide pairwise comparisons between multiple groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcnemar_test(x, y = NULL, correct = TRUE)

pairwise_mcnemar_test(
  data,
  formula,
  type = c("mcnemar", "exact"),
  correct = TRUE,
  p.adjust.method = "bonferroni"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcnemar_test_+3A_x">x</code></td>
<td>
<p>either a two-dimensional contingency table in matrix form,
or a factor object.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_y">y</code></td>
<td>
<p>a factor object; ignored if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether to apply continuity
correction when computing the test statistic.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>a ~ b | c</code>, where <code>a</code> is the
outcome variable name; b is the within-subjects factor variables; and c
(factor) is the column name containing individuals/subjects identifier.
Should be unique per individual.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_type">type</code></td>
<td>
<p>type of statistical tests used for pairwise comparisons. Allowed
values are one of <code>c("mcnemar", "exact")</code>.</p>
</td></tr>
<tr><td><code id="mcnemar_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with the following columns: </p>

<ul>
<li> <p><code>n</code>: the number of participants.
</p>
</li>
<li> <p><code>statistic</code>: the value of McNemar's statistic. </p>
</li>
<li> <p><code>df</code> the
degrees of freedom of the approximate chi-squared distribution of the test
statistic. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>: the adjusted
p-value. </p>
</li>
<li> <p><code>method</code>: the used statistical test. </p>
</li>
<li>
<p><code>p.signif</code>: the significance level of p-values.</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mcnemar_test()</code>: performs McNemar's chi-squared test for comparing two
paired proportions
</p>
</li>
<li> <p><code>pairwise_mcnemar_test()</code>: performs pairwise McNemar's chi-squared test between
multiple groups. Could be used for post-hoc tests following a significant Cochran's Q test.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Comparing two paired proportions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: frequencies of smokers before and after interventions
xtab &lt;- as.table(
  rbind(c(25, 6), c(21,10))
)
dimnames(xtab) &lt;- list(
  before = c("non.smoker", "smoker"),
  after = c("non.smoker", "smoker")
)
xtab

# Compare the proportion of smokers
mcnemar_test(xtab)

# Comparing multiple related proportions
# %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Generate a demo data
mydata &lt;- data.frame(
  outcome = c(0,1,1,0,0,1,0,1,1,1,1,1,0,0,1,1,0,1,0,1,1,0,0,1,0,1,1,0,0,1),
  treatment = gl(3,1,30,labels=LETTERS[1:3]),
  participant = gl(10,3,labels=letters[1:10])
)
mydata$outcome &lt;- factor(
  mydata$outcome, levels = c(1, 0),
  labels = c("success", "failure")
  )
# Cross-tabulation
xtabs(~outcome + treatment, mydata)

# Compare the proportion of success between treatments
cochran_qtest(mydata, outcome ~ treatment|participant)

# pairwise comparisons between groups
pairwise_mcnemar_test(mydata, outcome ~ treatment|participant)

</code></pre>

<hr>
<h2 id='multinom_test'>Exact Multinomial Test</h2><span id='topic+multinom_test'></span>

<h3>Description</h3>

<p>Performs an exact multinomial test. Alternative to the chi-square test of goodness-of-fit-test when the sample
size is small.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinom_test(x, p = rep(1/length(x), length(x)), detailed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinom_test_+3A_x">x</code></td>
<td>
<p>numeric vector containing the counts.</p>
</td></tr>
<tr><td><code id="multinom_test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success. The length of p must be the
same as the number of groups specified by x, and its elements must be
greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="multinom_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame containing the p-value and its significance.
</p>
<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>See Also</h3>

<p><a href="#topic+binom_test">binom_test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data
tulip &lt;- c(red = 81, yellow = 50, white = 27)

# Question 1: are the color equally common ?
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# this is a test of homogeneity
res &lt;- multinom_test(tulip)
res

attr(res, "descriptives")

# Pairwise comparisons between groups
pairwise_binom_test(tulip, p.adjust.method = "bonferroni")


# Question 2: comparing observed to expected proportions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# this is a goodness-of-fit test
expected.p &lt;- c(red = 0.5, yellow = 0.33, white = 0.17)
res &lt;- multinom_test(tulip, expected.p)
res
attr(res, "descriptives")

# Pairwise comparisons against a given probabilities
pairwise_binom_test_against_p(tulip, expected.p)
</code></pre>

<hr>
<h2 id='p_round'>Rounding and Formatting p-values</h2><span id='topic+p_round'></span><span id='topic+p_format'></span><span id='topic+p_mark_significant'></span><span id='topic+p_detect'></span><span id='topic+p_names'></span><span id='topic+p_adj_names'></span>

<h3>Description</h3>

<p>Round and format p-values. Can also mark significant p-values with stars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_round(x, ..., digits = 3)

p_format(
  x,
  ...,
  new.col = FALSE,
  digits = 2,
  accuracy = 1e-04,
  decimal.mark = ".",
  leading.zero = TRUE,
  trailing.zero = FALSE,
  add.p = FALSE,
  space = FALSE
)

p_mark_significant(
  x,
  ...,
  new.col = FALSE,
  cutpoints = c(0, 1e-04, 0.001, 0.01, 0.05, 1),
  symbols = c("****", "***", "**", "*", "")
)

p_detect(data, type = c("all", "p", "p.adj"))

p_names()

p_adj_names()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_round_+3A_x">x</code></td>
<td>
<p>a numeric vector of p-values or a data frame containing a p value
column. If data frame, the p-value column(s) will be automatically detected.
Known p-value column names can be obtained using the functions
<code>p_names()</code> and <code>p_adj_names()</code></p>
</td></tr>
<tr><td><code id="p_round_+3A_...">...</code></td>
<td>
<p>column names to manipulate in the case where <code>x</code> is a data
frame. P value columns are automatically detected if not specified.</p>
</td></tr>
<tr><td><code id="p_round_+3A_digits">digits</code></td>
<td>
<p>the number of significant digits to be used.</p>
</td></tr>
<tr><td><code id="p_round_+3A_new.col">new.col</code></td>
<td>
<p>logical, used only when <code>x</code> is a data frame. If TRUE, add
a new column to hold the results. The new column name is created by adding,
to the p column, the suffix &quot;format&quot; (for <code>p_format()</code>), &quot;signif&quot; (for
<code>p_mak_significant()</code>).</p>
</td></tr>
<tr><td><code id="p_round_+3A_accuracy">accuracy</code></td>
<td>
<p>number to round to, that is the threshold value above wich the
function will replace the pvalue by &quot;&lt;0.0xxx&quot;.</p>
</td></tr>
<tr><td><code id="p_round_+3A_decimal.mark">decimal.mark</code></td>
<td>
<p>the character to be used to indicate the numeric decimal
point.</p>
</td></tr>
<tr><td><code id="p_round_+3A_leading.zero">leading.zero</code></td>
<td>
<p>logical. If FALSE, remove the leading zero.</p>
</td></tr>
<tr><td><code id="p_round_+3A_trailing.zero">trailing.zero</code></td>
<td>
<p>logical. If FALSE (default), remove the training extra
zero.</p>
</td></tr>
<tr><td><code id="p_round_+3A_add.p">add.p</code></td>
<td>
<p>logical value. If TRUE, add &quot;p=&quot; before the value.</p>
</td></tr>
<tr><td><code id="p_round_+3A_space">space</code></td>
<td>
<p>logical. If TRUE (default) use space as separator between
different elements and symbols.</p>
</td></tr>
<tr><td><code id="p_round_+3A_cutpoints">cutpoints</code></td>
<td>
<p>numeric vector used for intervals</p>
</td></tr>
<tr><td><code id="p_round_+3A_symbols">symbols</code></td>
<td>
<p>character vector, one shorter than cutpoints, used as
significance symbols.</p>
</td></tr>
<tr><td><code id="p_round_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="p_round_+3A_type">type</code></td>
<td>
<p>the type of p-value to detect. Can be one of <code>c("all", "p", "p.adj")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a data frame containing the rounded/formatted p-values.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>p_round()</code>: round p-values
</p>
</li>
<li> <p><code>p_format()</code>: format p-values. Add a symbol &quot;&lt;&quot; for small p-values.
</p>
</li>
<li> <p><code>p_mark_significant()</code>: mark p-values with significance levels
</p>
</li>
<li> <p><code>p_detect()</code>: detects and returns p-value column names in a data frame.
</p>
</li>
<li> <p><code>p_names()</code>: returns known p-value column names
</p>
</li>
<li> <p><code>p_adj_names()</code>: returns known adjust p-value column names
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Round and format a vector of p-values
# ::::::::::::::::::::::::::::::::::::::::::::
# Format
p &lt;- c(0.5678, 0.127, 0.045, 0.011, 0.009, 0.00002, NA)
p_format(p)

# Specify the accuracy
p_format(p, accuracy = 0.01)

# Add p and remove the leading zero
p_format(p, add.p = TRUE, leading.zero = FALSE)

# Remove space before and after "=" or "&lt;".
p_format(p, add.p = TRUE, leading.zero = FALSE, space = FALSE)

# Mark significant p-values
# ::::::::::::::::::::::::::::::::::::::::::::
p_mark_significant(p)

# Round, the mark significant
p %&gt;% p_round(digits = 2) %&gt;% p_mark_significant()

# Format, then mark significant
p %&gt;% p_format(digits = 2) %&gt;% p_mark_significant()

# Perform stat test, format p and mark significant
# ::::::::::::::::::::::::::::::::::::::::::::
ToothGrowth %&gt;%
  group_by(dose) %&gt;%
  t_test(len ~ supp) %&gt;%
  p_format(digits = 2, leading.zero = FALSE) %&gt;%
  p_mark_significant()

</code></pre>

<hr>
<h2 id='prop_test'>Proportion Test</h2><span id='topic+prop_test'></span><span id='topic+pairwise_prop_test'></span><span id='topic+row_wise_prop_test'></span>

<h3>Description</h3>

<p>Performs proportion tests to either evaluate the homogeneity of
proportions (probabilities of success) in several groups or to test that the
proportions are equal to certain given values.
</p>
<p>Wrappers around the R base function <code><a href="stats.html#topic+prop.test">prop.test</a>()</code> but have
the advantage of performing pairwise and row-wise z-test of two proportions,
the post-hoc tests following a significant chi-square test of homogeneity
for 2xc and rx2 contingency tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_test(
  x,
  n,
  p = NULL,
  alternative = c("two.sided", "less", "greater"),
  correct = TRUE,
  conf.level = 0.95,
  detailed = FALSE
)

pairwise_prop_test(xtab, p.adjust.method = "holm", ...)

row_wise_prop_test(xtab, p.adjust.method = "holm", detailed = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_test_+3A_x">x</code></td>
<td>
<p>a vector of counts of successes, a one-dimensional table with
two entries, or a two-dimensional table (or matrix) with 2 columns,
giving the counts of successes and failures, respectively.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_n">n</code></td>
<td>
<p>a vector of counts of trials; ignored if <code>x</code> is a
matrix or a table.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success.  The length of
<code>p</code> must be the same as the number of groups specified by
<code>x</code>, and its elements must be greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.  Only used for testing the null that a single proportion
equals a given value, or that two proportions are equal; ignored
otherwise.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether Yates' continuity
correction should be applied where possible.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence
interval.  Must be a single number between 0 and 1.  Only used
when testing the null that a single proportion equals a given
value, or that two proportions are equal; ignored otherwise.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_xtab">xtab</code></td>
<td>
<p>a cross-tabulation (or contingency table) with two columns and
multiple rows (rx2 design). The columns give the counts of successes and
failures respectively.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the function <code>prop_test()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>

<ul>
<li> <p><code>n</code>: the number of participants.
</p>
</li>
<li> <p><code>group</code>: the categories in the row-wise proportion tests. </p>
</li>
<li>
<p><code>statistic</code>: the value of Pearson's chi-squared test statistic. </p>
</li>
<li>
<p><code>df</code>: the degrees of freedom of the approximate chi-squared
distribution of the test statistic. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li>
<p><code>p.adj</code>: the adjusted p-value. </p>
</li>
<li> <p><code>method</code>: the used
statistical test. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance
level of p-values and adjusted p-values, respectively. </p>
</li>
<li>
<p><code>estimate</code>: a vector with the sample proportions x/n. </p>
</li>
<li>
<p><code>estimate1, estimate2</code>: the proportion in each of the two populations.
</p>
</li>
<li> <p><code>alternative</code>: a character string describing the alternative
hypothesis. </p>
</li>
<li> <p><code>conf.low,conf.high</code>: Lower and upper bound on a
confidence interval. a confidence interval for the true proportion if there
is one group, or for the difference in proportions if there are 2 groups and
p is not given, or NULL otherwise. In the cases where it is not NULL, the
returned confidence interval has an asymptotic confidence level as specified
by conf.level, and is appropriate to the specified alternative hypothesis.</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>prop_test()</code>: performs one-sample and two-samples z-test of
proportions. Wrapper around the function <code><a href="stats.html#topic+prop.test">prop.test</a>()</code>.
</p>
</li>
<li> <p><code>pairwise_prop_test()</code>: pairwise comparisons between proportions, a post-hoc
tests following a significant chi-square test of homogeneity for 2xc
design. Wrapper around <code><a href="stats.html#topic+pairwise.prop.test">pairwise.prop.test</a>()</code>
</p>
</li>
<li> <p><code>row_wise_prop_test()</code>: performs row-wise z-test of two proportions, a post-hoc tests following a significant chi-square test
of homogeneity for rx2 contingency table. The z-test of two proportions is calculated for each category (row).
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Comparing an observed proportion to an expected proportion
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
prop_test(x = 95, n = 160, p = 0.5, detailed = TRUE)

# Comparing two proportions
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: frequencies of smokers between two groups
xtab &lt;- as.table(rbind(c(490, 10), c(400, 100)))
dimnames(xtab) &lt;- list(
  group = c("grp1", "grp2"),
  smoker = c("yes", "no")
)
xtab
# compare the proportion of smokers
prop_test(xtab, detailed = TRUE)

# Homogeneity of proportions between groups
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# H0: the proportion of smokers is similar in the four groups
# Ha:  this proportion is different in at least one of the populations.
#
# Data preparation
grp.size &lt;- c( 106, 113, 156, 102 )
smokers  &lt;- c( 50, 100, 139, 80 )
no.smokers &lt;- grp.size - smokers
xtab &lt;- as.table(rbind(
  smokers,
  no.smokers
))
dimnames(xtab) &lt;- list(
  Smokers = c("Yes", "No"),
  Groups = c("grp1", "grp2", "grp3", "grp4")
)
xtab

# Compare the proportions of smokers between groups
prop_test(xtab, detailed = TRUE)

# Pairwise comparison between groups
pairwise_prop_test(xtab)


# Pairwise proportion tests
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: Titanic
xtab &lt;- as.table(rbind(
  c(122, 167, 528, 673),
  c(203, 118, 178, 212)
))
dimnames(xtab) &lt;- list(
  Survived = c("No", "Yes"),
  Class = c("1st", "2nd", "3rd", "Crew")
)
xtab
# Compare the proportion of survived between groups
pairwise_prop_test(xtab)

# Row-wise proportion tests
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data: Titanic
xtab &lt;- as.table(rbind(
  c(180, 145), c(179, 106),
  c(510, 196), c(862, 23)
))
dimnames(xtab) &lt;- list(
  Class = c("1st", "2nd", "3rd", "Crew"),
  Gender = c("Male", "Female")
)
xtab
# Compare the proportion of males and females in each category
row_wise_prop_test(xtab)
</code></pre>

<hr>
<h2 id='prop_trend_test'>Test for Trend in Proportions</h2><span id='topic+prop_trend_test'></span>

<h3>Description</h3>

<p>Performs chi-squared test for trend in proportion. This test is
also known as Cochran-Armitage trend test.
</p>
<p>Wrappers around the R base function <code><a href="stats.html#topic+prop.trend.test">prop.trend.test</a>()</code> but
returns a data frame for easy data visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_trend_test(xtab, score = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_trend_test_+3A_xtab">xtab</code></td>
<td>
<p>a cross-tabulation (or contingency table) with two columns and
multiple rows (rx2 design). The columns give the counts of successes and
failures respectively.</p>
</td></tr>
<tr><td><code id="prop_trend_test_+3A_score">score</code></td>
<td>
<p>group score. If <code>NULL</code>, the default is group number.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>n</code>: the number of participants.  </p>
</li>
<li> <p><code>statistic</code>: the value of
Chi-squared trend test statistic. </p>
</li>
<li> <p><code>df</code>: the degrees of
freedom.
</p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li>
<p><code>method</code>: the used statistical test. </p>
</li>
<li> <p><code>p.signif</code>: the significance level of p-values and adjusted p-values,
respectively.</p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Proportion of renal stone (calculi) across age
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
# Data
xtab &lt;- as.table(rbind(
  c(384, 536, 335),
  c(951, 869, 438)
))
dimnames(xtab) &lt;- list(
  stone = c("yes", "no"),
  age = c("30-39", "40-49", "50-59")
)
xtab
# Compare the proportion of survived between groups
prop_trend_test(xtab)
</code></pre>

<hr>
<h2 id='pull_triangle'>Pull Lower and Upper Triangular Part of a Matrix</h2><span id='topic+pull_triangle'></span><span id='topic+pull_upper_triangle'></span><span id='topic+pull_lower_triangle'></span>

<h3>Description</h3>

<p>Returns the lower or the upper triangular part of a
(correlation) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pull_triangle(x, triangle = c("lower", "upper"), diagonal = FALSE)

pull_upper_triangle(x, diagonal = FALSE)

pull_lower_triangle(x, diagonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull_triangle_+3A_x">x</code></td>
<td>
<p>a (correlation) matrix</p>
</td></tr>
<tr><td><code id="pull_triangle_+3A_triangle">triangle</code></td>
<td>
<p>the triangle to pull. Allowed values are one of
&quot;upper&quot; and &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="pull_triangle_+3A_diagonal">diagonal</code></td>
<td>
<p>logical. Default is FALSE. If TRUE, the matrix diagonal is
included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>cor_mat_tri</code>, which is a data frame
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>pull_triangle()</code>: returns either the lower or upper triangular part of a matrix.
</p>
</li>
<li> <p><code>pull_upper_triangle()</code>: returns an object of class <code>upper_tri</code>, which
is a data frame containing the upper triangular part of a matrix.
</p>
</li>
<li> <p><code>pull_lower_triangle()</code>: returns an object of class <code>lower_tri</code>, which
is a data frame containing the lower triangular part of a matrix.
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+replace_triangle">replace_triangle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data preparation
#::::::::::::::::::::::::::::::::::::::::::
mydata &lt;- mtcars %&gt;%
  select(mpg, disp, hp, drat, wt, qsec)
head(mydata, 3)

# Compute correlation matrix and pull triangles
#::::::::::::::::::::::::::::::::::::::::::
# Correlation matrix
cor.mat &lt;- cor_mat(mydata)
cor.mat

# Pull lower triangular part
cor.mat %&gt;% pull_lower_triangle()

# Pull upper triangular part
cor.mat %&gt;% pull_upper_triangle()


</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+tibble'></span><span id='topic+mutate'></span><span id='topic+filter'></span><span id='topic+group_by'></span><span id='topic+select'></span><span id='topic+desc'></span><span id='topic+drop_na'></span><span id='topic+gather'></span><span id='topic+spread'></span><span id='topic+tidy'></span><span id='topic+augment'></span><span id='topic+Anova'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>car</dt><dd><p><code><a href="car.html#topic+Anova">Anova</a></code></p>
</dd>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+desc">desc</a></code>, <code><a href="dplyr.html#topic+filter">filter</a></code>, <code><a href="dplyr.html#topic+group_by">group_by</a></code>, <code><a href="dplyr.html#topic+mutate">mutate</a></code>, <code><a href="dplyr.html#topic+select">select</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code>, <code><a href="generics.html#topic+tidy">tidy</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+tibble">tibble</a></code></p>
</dd>
<dt>tidyr</dt><dd><p><code><a href="tidyr.html#topic+drop_na">drop_na</a></code>, <code><a href="tidyr.html#topic+gather">gather</a></code>, <code><a href="tidyr.html#topic+spread">spread</a></code></p>
</dd>
</dl>

<hr>
<h2 id='remove_ns'>Remove Non-Significant from Statistical Tests</h2><span id='topic+remove_ns'></span>

<h3>Description</h3>

<p>Filter out non-significant (NS) p-values from a statistical
test. Can detect automatically p-value columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_ns(stat.test, col = NULL, signif.cutoff = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_ns_+3A_stat.test">stat.test</code></td>
<td>
<p>statistical test results returned by <code>rstatix</code>
functions or any data frame containing a p-value column.</p>
</td></tr>
<tr><td><code id="remove_ns_+3A_col">col</code></td>
<td>
<p>(optional) character specifying the column containing the p-value
or the significance information, to be used for the filtering step.
Possible values include: <code>"p"</code>, <code>"p.adj"</code>, <code>"p.signif"</code>,
<code>"p.adj.signif"</code>. If missing, the function will automatically look for
p.adj.signif, p.adj, p.signif, p in this order.</p>
</td></tr>
<tr><td><code id="remove_ns_+3A_signif.cutoff">signif.cutoff</code></td>
<td>
<p>the significance cutoff; default is 0.05. Significance
is declared at <code>p-value &lt;= signif.cutoff</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Statistical test
stat.test &lt;- PlantGrowth %&gt;% wilcox_test(weight ~ group)
# Remove ns: automatic detection of p-value columns
stat.test %&gt;% remove_ns()
# Remove ns by the column p
stat.test %&gt;% remove_ns(col ="p")
</code></pre>

<hr>
<h2 id='replace_triangle'>Replace Lower and Upper Triangular Part of a Matrix</h2><span id='topic+replace_triangle'></span><span id='topic+replace_upper_triangle'></span><span id='topic+replace_lower_triangle'></span>

<h3>Description</h3>

<p>Replace the lower or the upper triangular part of a
(correlation) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_triangle(x, triangle = c("lower", "upper"), by = "", diagonal = FALSE)

replace_upper_triangle(x, by = "", diagonal = FALSE)

replace_lower_triangle(x, by = "", diagonal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_triangle_+3A_x">x</code></td>
<td>
<p>a (correlation) matrix</p>
</td></tr>
<tr><td><code id="replace_triangle_+3A_triangle">triangle</code></td>
<td>
<p>the triangle to replace. Allowed values are one of
&quot;upper&quot; and &quot;lower&quot;.</p>
</td></tr>
<tr><td><code id="replace_triangle_+3A_by">by</code></td>
<td>
<p>a replacement argument. Appropriate values are either &quot;&quot; or NA. Used to replace
the upper, lower or the diagonal part of the matrix.</p>
</td></tr>
<tr><td><code id="replace_triangle_+3A_diagonal">diagonal</code></td>
<td>
<p>logical. Default is FALSE. If TRUE, the matrix diagonal is
included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>cor_mat_tri</code>, which is a data frame
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>replace_triangle()</code>: replaces the specified triangle by empty or NA.
</p>
</li>
<li> <p><code>replace_upper_triangle()</code>: replaces the upper triangular part of a matrix.
Returns an object of class <code>lower_tri</code>.
</p>
</li>
<li> <p><code>replace_lower_triangle()</code>: replaces the lower triangular part of a matrix.
Returns an object of class <code>lower_tri</code>
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="#topic+pull_triangle">pull_triangle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute correlation matrix and pull triangles
#::::::::::::::::::::::::::::::::::::::::::
# Correlation matrix
 cor.mat &lt;- mtcars %&gt;%
   select(mpg, disp, hp, drat, wt, qsec) %&gt;%
   cor_mat()
 cor.mat

 # Replace upper triangle by NA
#::::::::::::::::::::::::::::::::::::::::::
cor.mat %&gt;% replace_upper_triangle(by = NA)


# Replace upper triangle by NA and reshape the
# correlation matrix to have unique combinations of variables
#::::::::::::::::::::::::::::::::::::::::::
cor.mat %&gt;%
  replace_upper_triangle(by = NA) %&gt;%
  cor_gather()
</code></pre>

<hr>
<h2 id='sample_n_by'>Sample n Rows By Group From a Table</h2><span id='topic+sample_n_by'></span>

<h3>Description</h3>

<p>sample n rows by group from a table using the <code><a href="dplyr.html#topic+sample_n">sample_n</a>()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_n_by(data, ..., size = 1, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_n_by_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="sample_n_by_+3A_...">...</code></td>
<td>
<p>Variables to group by</p>
</td></tr>
<tr><td><code id="sample_n_by_+3A_size">size</code></td>
<td>
<p>the number of rows to select</p>
</td></tr>
<tr><td><code id="sample_n_by_+3A_replace">replace</code></td>
<td>
<p>with or without replacement?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ToothGrowth %&gt;% sample_n_by(dose, supp, size = 2)
</code></pre>

<hr>
<h2 id='shapiro_test'>Shapiro-Wilk Normality Test</h2><span id='topic+shapiro_test'></span><span id='topic+mshapiro_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to performs Shapiro-Wilk test
of normality. Support grouped data and multiple variables for multivariate
normality tests. Wrapper around the R base function
<code><a href="stats.html#topic+shapiro.test">shapiro.test</a>()</code>. Can handle grouped data. Read more:
<a href="https://www.datanovia.com/en/lessons/normality-test-in-r/">Normality
Test in R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapiro_test(data, ..., vars = NULL)

mshapiro_test(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shapiro_test_+3A_data">data</code></td>
<td>
<p>a data frame. Columns are variables.</p>
</td></tr>
<tr><td><code id="shapiro_test_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions (or variable names) separated by
commas. Used to select a variable of interest.</p>
</td></tr>
<tr><td><code id="shapiro_test_+3A_vars">vars</code></td>
<td>
<p>optional character vector containing variable names. Ignored when
dot vars are specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the value of the Shapiro-Wilk statistic and
the corresponding p.value.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>shapiro_test()</code>: univariate Shapiro-Wilk normality test
</p>
</li>
<li> <p><code>mshapiro_test()</code>: multivariate Shapiro-Wilk normality test. This is a
modified copy of the <code>mshapiro.test()</code> function of the package
mvnormtest, for internal convenience.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
# Shapiro Wilk normality test for one variable
iris %&gt;% shapiro_test(Sepal.Length)

# Shapiro Wilk normality test for two variables
iris %&gt;% shapiro_test(Sepal.Length, Petal.Width)

# Multivariate normality test
mshapiro_test(iris[, 1:3])

</code></pre>

<hr>
<h2 id='sign_test'>Sign Test</h2><span id='topic+sign_test'></span><span id='topic+pairwise_sign_test'></span>

<h3>Description</h3>

<p>Performs one-sample and two-sample sign tests. Read more:
<a href="https://www.datanovia.com/en/lessons/sign-test-in-r/">Sign Test in R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sign_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95,
  detailed = FALSE
)

pairwise_sign_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  detailed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sign_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ treatment</code>.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="sign_test_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).</p>
</td></tr>
<tr><td><code id="sign_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_mu">mu</code></td>
<td>
<p>a single number representing the value of the population median
specified by the null hypothesis.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="sign_test_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function <code>sign_test()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>group1,group2</code>: the
compared groups in the pairwise tests. </p>
</li>
<li> <p><code>n,n1,n2</code>: Sample counts.
</p>
</li>
<li> <p><code>statistic</code>: Test statistic used to compute the p-value. That is
the S-statistic (the number of positive differences between the data and the
hypothesized median), with names attribute <code>"S"</code>. </p>
</li>
<li> <p><code>df,
 parameter</code>: degrees of freedom. Here, the total number of valid differences.
</p>
</li>
<li> <p><code>p</code>: p-value.  </p>
</li>
<li> <p><code>method</code>: the statistical test used to
compare groups. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance level
of p-values and adjusted p-values, respectively. </p>
</li>
<li> <p><code>estimate</code>:
estimate of the effect size. It corresponds to the median of the
differences. </p>
</li>
<li> <p><code>alternative</code>: a character string describing the
alternative hypothesis. </p>
</li>
<li> <p><code>conf.low,conf.high</code>: Lower and upper
bound on a confidence interval of the estimate. </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>sign_test()</code>: Sign test
</p>
</li>
<li> <p><code>pairwise_sign_test()</code>: performs pairwise two sample Wilcoxon test.
</p>
</li></ul>


<h3>Note</h3>

<p>This function is a reimplementation of the function <code>SignTest()</code>
from the <code>DescTools</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# One-sample test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% sign_test(len ~ 1, mu = 0)


# Two-samples paired test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% sign_test(len ~ supp)


# Compare supp levels after grouping the data by "dose"
#::::::::::::::::::::::::::::::::::::::::
df %&gt;%
  group_by(dose) %&gt;%
  sign_test(data =., len ~ supp) %&gt;%
  adjust_pvalue(method = "bonferroni") %&gt;%
  add_significance("p.adj")

# pairwise comparisons
#::::::::::::::::::::::::::::::::::::::::
# As dose contains more than two levels ==&gt;
# pairwise test is automatically performed.
df %&gt;% sign_test(len ~ dose)

# Comparison against reference group
#::::::::::::::::::::::::::::::::::::::::
# each level is compared to the ref group
df %&gt;% sign_test(len ~ dose, ref.group = "0.5")


</code></pre>

<hr>
<h2 id='t_test'>T-test</h2><span id='topic+t_test'></span><span id='topic+pairwise_t_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to performs one and two sample
t-tests. Read more: <a href="https://www.datanovia.com/en/lessons/t-test-in-r/">T-test in R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  paired = FALSE,
  var.equal = FALSE,
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95,
  detailed = FALSE
)

pairwise_t_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  paired = FALSE,
  pool.sd = !paired,
  detailed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="t_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="t_test_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="t_test_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise two sample tests are performed for
comparing each grouping variable levels against all (i.e. basemean).</p>
</td></tr>
<tr><td><code id="t_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="t_test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="t_test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="t_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="t_test_+3A_mu">mu</code></td>
<td>
<p>a number specifying an optional parameter used to form the null hypothesis.</p>
</td></tr>
<tr><td><code id="t_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="t_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="t_test_+3A_pool.sd">pool.sd</code></td>
<td>
<p>logical value used in the function <code>pairwise_t_test()</code>.
Switch to allow/disallow the use of a pooled SD.
</p>
<p>The <code>pool.sd = TRUE</code> (default) calculates a common SD for all groups
and uses that for all comparisons (this can be useful if some groups are
small). This method does not actually call t.test, so extra arguments are
ignored. Pooling does not generalize to paired tests so pool.sd and paired
cannot both be TRUE.
</p>
<p>If <code>pool.sd = FALSE</code> the standard two sample t-test is applied to all
possible pairs of groups. This method calls the <code>t.test()</code>, so extra
arguments, such as <code>var.equal</code> are accepted.</p>
</td></tr>
<tr><td><code id="t_test_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="stats.html#topic+t.test">t.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- If a list of comparisons is specified, the result of the pairwise tests is
filtered to keep only the comparisons of interest. The p-value is adjusted
after filtering.
</p>
<p>- For a grouped data, if pairwise test is performed, then the p-values are
adjusted for each group level independently.
</p>


<h3>Value</h3>

<p>return a data frame with some the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>group1,group2</code>: the
compared groups in the pairwise tests. </p>
</li>
<li> <p><code>n,n1,n2</code>: Sample counts.
</p>
</li>
<li> <p><code>statistic</code>: Test statistic used to compute the p-value. </p>
</li>
<li>
<p><code>df</code>: degrees of freedom. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>:
the adjusted p-value. </p>
</li>
<li> <p><code>method</code>: the statistical test used to
compare groups. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance level
of p-values and adjusted p-values, respectively. </p>
</li>
<li> <p><code>estimate</code>:
estimate of the effect size. It corresponds to the estimated mean or
difference in means depending on whether it was a one-sample test or a
two-sample test. </p>
</li>
<li> <p><code>estimate1, estimate2</code>: show the mean values of
the two groups, respectively, for independent samples t-tests. </p>
</li>
<li>
<p><code>alternative</code>: a character string describing the alternative
hypothesis. </p>
</li>
<li> <p><code>conf.low,conf.high</code>: Lower and upper bound on a
confidence interval. </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>t_test()</code>: t test
</p>
</li>
<li> <p><code>pairwise_t_test()</code>: performs pairwise two sample t-test. Wrapper around the R
base function <code><a href="stats.html#topic+pairwise.t.test">pairwise.t.test</a></code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# One-sample test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% t_test(len ~ 1, mu = 0)


# Two-samples unpaired test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% t_test(len ~ supp)

# Two-samples paired test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% t_test (len ~ supp, paired = TRUE)

# Compare supp levels after grouping the data by "dose"
#::::::::::::::::::::::::::::::::::::::::
df %&gt;%
  group_by(dose) %&gt;%
  t_test(data =., len ~ supp) %&gt;%
  adjust_pvalue(method = "bonferroni") %&gt;%
  add_significance("p.adj")

# pairwise comparisons
#::::::::::::::::::::::::::::::::::::::::
# As dose contains more than two levels ==&gt;
# pairwise test is automatically performed.
df %&gt;% t_test(len ~ dose)

# Comparison against reference group
#::::::::::::::::::::::::::::::::::::::::
# each level is compared to the ref group
df %&gt;% t_test(len ~ dose, ref.group = "0.5")

# Comparison against all
#::::::::::::::::::::::::::::::::::::::::
df %&gt;% t_test(len ~ dose, ref.group = "all")

</code></pre>

<hr>
<h2 id='tukey_hsd'>Tukey Honest Significant Differences</h2><span id='topic+tukey_hsd'></span><span id='topic+tukey_hsd.default'></span><span id='topic+tukey_hsd.lm'></span><span id='topic+tukey_hsd.data.frame'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to performs Tukey post-hoc
tests. Wrapper around the function <code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a>()</code>. It is
essentially a t-test that corrects for multiple testing.
</p>
<p>Can handle different inputs formats: aov, lm, formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tukey_hsd(x, ...)

## Default S3 method:
tukey_hsd(x, ...)

## S3 method for class 'lm'
tukey_hsd(x, ...)

## S3 method for class 'data.frame'
tukey_hsd(x, formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tukey_hsd_+3A_x">x</code></td>
<td>
<p>an object of class <code>aov</code>, <code>lm</code> or <code>data.frame</code>
containing the variables used in the formula.</p>
</td></tr>
<tr><td><code id="tukey_hsd_+3A_...">...</code></td>
<td>
<p>other arguments passed to the function
<code><a href="stats.html#topic+TukeyHSD">TukeyHSD</a>()</code>. These include: </p>
 <ul>
<li>
<p><strong>which</strong>: A character vector listing terms in the fitted model for
which the intervals should be calculated. Defaults to all the terms. </p>
</li>
<li>
<p><strong>ordered</strong>: A logical value indicating if the levels of the factor
should be ordered according to increasing average in the sample before
taking differences. If ordered is true then the calculated differences in
the means will all be positive. The significant differences will be those
for which the lwr end point is positive. </p>
</li></ul>
</td></tr>
<tr><td><code id="tukey_hsd_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="tukey_hsd_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a tibble data frame containing the results of the different
comparisons.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tukey_hsd(default)</code>: performs tukey post-hoc test from <code>aov()</code> results.
</p>
</li>
<li> <p><code>tukey_hsd(lm)</code>: performs tukey post-hoc test from <code>lm()</code> model.
</p>
</li>
<li> <p><code>tukey_hsd(data.frame)</code>: performs tukey post-hoc tests using data and formula as
inputs. ANOVA will be automatically performed using the function
<code><a href="stats.html#topic+aov">aov</a>()</code>
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Data preparation
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)
# Tukey HSD from ANOVA results
aov(len ~ dose, data = df) %&gt;% tukey_hsd()

# two-way anova with interaction
aov(len ~ dose*supp, data = df) %&gt;% tukey_hsd()

# Tukey HSD from lm() results
lm(len ~ dose, data = df) %&gt;% tukey_hsd()

# Tukey HSD from data frame and formula
tukey_hsd(df, len ~ dose)

# Tukey HSD using grouped data
df %&gt;%
  group_by(supp) %&gt;%
  tukey_hsd(len ~ dose)

</code></pre>

<hr>
<h2 id='welch_anova_test'>Welch One-Way ANOVA Test</h2><span id='topic+welch_anova_test'></span>

<h3>Description</h3>

<p>Tests for equal means in a one-way design (not assuming equal
variance). A wrapper around the base function
<code><a href="stats.html#topic+oneway.test">oneway.test</a>()</code>. This is is an alternative to the
standard one-way ANOVA in the situation where the homogeneity of variance
assumption is violated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welch_anova_test(data, formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="welch_anova_test_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="welch_anova_test_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the ANOVA model similar to aov. Can be of
the form y ~ group where y is a numeric variable giving the data values and
group is a factor with one or multiple levels giving the corresponding
groups. For example, formula = TP53 ~ cancer_group.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with the following columns: </p>
 <ul>
<li>
<p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li> <p><code>n</code>: sample count.
</p>
</li>
<li> <p><code>statistic</code>: the value of the test statistic. </p>
</li>
<li> <p><code>p</code>:
p-value. </p>
</li>
<li> <p><code>method</code>: the statistical test used to compare groups.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth
df$dose &lt;- as.factor(df$dose)

# Welch one-way ANOVA test (not assuming equal variance)
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% welch_anova_test(len ~ dose)

# Grouped data
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;%
  group_by(supp) %&gt;%
  welch_anova_test(len ~ dose)
</code></pre>

<hr>
<h2 id='wilcox_effsize'>Wilcoxon Effect Size</h2><span id='topic+wilcox_effsize'></span>

<h3>Description</h3>

<p>Compute Wilcoxon effect size (<code>r</code>) for: </p>
 <ul>
<li>
<p>one-sample test (Wilcoxon one-sample signed-rank test); </p>
</li>
<li><p> paired
two-samples test (Wilcoxon two-sample paired signed-rank test) and </p>
</li>
<li>
<p>independent two-samples test ( Mann-Whitney, two-sample rank-sum test). </p>
</li></ul>

<p>It can also returns confidence intervals by bootstap.
</p>
<p>The effect size <code>r</code> is calculated as <code>Z</code> statistic divided by
square root of the sample size (N) (<code class="reqn">Z/\sqrt{N}</code>). The <code>Z</code> value is
extracted from either <code>coin::wilcoxsign_test()</code> (case of one- or
paired-samples test) or <code>coin::wilcox_test()</code> (case of independent
two-samples test).
</p>
<p>Note that <code>N</code> corresponds to total sample size for independent samples
test and to total number of pairs for paired samples test.
</p>
<p>The <code>r</code> value varies from 0 to close to 1. The interpretation values
for r commonly in published litterature and on the internet are: <code>0.10
 - &lt; 0.3</code> (small effect), <code>0.30 - &lt; 0.5</code> (moderate effect) and <code>&gt;=
 0.5</code> (large effect).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcox_effsize(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  paired = FALSE,
  alternative = "two.sided",
  mu = 0,
  ci = FALSE,
  conf.level = 0.95,
  ci.type = "perc",
  nboot = 1000,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcox_effsize_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise two sample tests are performed for
comparing each grouping variable levels against all (i.e. basemean).</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_mu">mu</code></td>
<td>
<p>a number specifying an optional parameter used to form the null
hypothesis.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_ci">ci</code></td>
<td>
<p>If TRUE, returns confidence intervals by bootstrap. May be slow.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_conf.level">conf.level</code></td>
<td>
<p>The level for the confidence interval.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_ci.type">ci.type</code></td>
<td>
<p>The type of confidence interval to use. Can be any of &quot;norm&quot;,
&quot;basic&quot;, &quot;perc&quot;, or &quot;bca&quot;. Passed to <code>boot::boot.ci</code>.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_nboot">nboot</code></td>
<td>
<p>The number of replications to use for bootstrap.</p>
</td></tr>
<tr><td><code id="wilcox_effsize_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the functions
<code>coin::wilcoxsign_test()</code> (case of one- or paired-samples test) or
<code>coin::wilcox_test()</code> (case of independent two-samples test).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li>
<p><code>group1,group2</code>: the compared groups in the pairwise tests. </p>
</li>
<li>
<p><code>n,n1,n2</code>: Sample counts. </p>
</li>
<li> <p><code>effsize</code>: estimate of the effect
size (<code>r</code> value). </p>
</li>
<li> <p><code>magnitude</code>: magnitude of effect size.
</p>
</li>
<li> <p><code>conf.low,conf.high</code>: lower and upper bound of the effect size
confidence interval.</p>
</li></ul>



<h3>References</h3>

<p>Maciej Tomczak and Ewa Tomczak. The need to report effect size
estimates revisited. An overview of some recommended measures of effect
size. Trends in Sport Sciences. 2014; 1(21):19-25.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require("coin")){

# One-sample Wilcoxon test effect size
ToothGrowth %&gt;% wilcox_effsize(len ~ 1, mu = 0)

# Independent two-samples wilcoxon effect size
ToothGrowth %&gt;% wilcox_effsize(len ~ supp)


# Paired-samples wilcoxon effect size
ToothGrowth %&gt;% wilcox_effsize(len ~ supp, paired = TRUE)

# Pairwise comparisons
ToothGrowth %&gt;% wilcox_effsize(len ~ dose)

# Grouped data
ToothGrowth %&gt;%
  group_by(supp) %&gt;%
  wilcox_effsize(len ~ dose)

}
</code></pre>

<hr>
<h2 id='wilcox_test'>Wilcoxon Tests</h2><span id='topic+wilcox_test'></span><span id='topic+pairwise_wilcox_test'></span>

<h3>Description</h3>

<p>Provides a pipe-friendly framework to performs one and two sample
Wilcoxon tests. Read more:
<a href="https://www.datanovia.com/en/lessons/wilcoxon-test-in-r/">Wilcoxon in
R</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wilcox_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  paired = FALSE,
  exact = NULL,
  alternative = "two.sided",
  mu = 0,
  conf.level = 0.95,
  detailed = FALSE
)

pairwise_wilcox_test(
  data,
  formula,
  comparisons = NULL,
  ref.group = NULL,
  p.adjust.method = "holm",
  detailed = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wilcox_test_+3A_data">data</code></td>
<td>
<p>a data.frame containing the variables in the formula.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>x ~ group</code> where <code>x</code> is a
numeric variable giving the data values and <code>group</code> is a factor with
one or multiple levels giving the corresponding groups. For example,
<code>formula = TP53 ~ cancer_group</code>.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_comparisons">comparisons</code></td>
<td>
<p>A list of length-2 vectors specifying the groups of
interest to be compared. For example to compare groups &quot;A&quot; vs &quot;B&quot; and &quot;B&quot; vs
&quot;C&quot;, the argument is as follow: <code>comparisons = list(c("A", "B"), c("B",
"C"))</code></p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_ref.group">ref.group</code></td>
<td>
<p>a character string specifying the reference group. If
specified, for a given grouping variable, each of the group levels will be
compared to the reference group (i.e. control group).
</p>
<p>If <code>ref.group = "all"</code>, pairwise two sample tests are performed for
comparing each grouping variable levels against all (i.e. basemean).</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>method to adjust p values for multiple comparisons.
Used when pairwise comparisons are performed. Allowed values include &quot;holm&quot;,
&quot;hochberg&quot;, &quot;hommel&quot;, &quot;bonferroni&quot;, &quot;BH&quot;, &quot;BY&quot;, &quot;fdr&quot;, &quot;none&quot;. If you don't
want to adjust the p value (not recommended), use p.adjust.method = &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired test.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_exact">exact</code></td>
<td>
<p>a logical indicating whether an exact p-value
should be computed.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_mu">mu</code></td>
<td>
<p>a number specifying an optional parameter used to form the null
hypothesis.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_detailed">detailed</code></td>
<td>
<p>logical value. Default is FALSE. If TRUE, a detailed result is
shown.</p>
</td></tr>
<tr><td><code id="wilcox_test_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to the function
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>- <code>pairwise_wilcox_test()</code> applies the standard two sample
Wilcoxon test to all possible pairs of groups. This method calls the
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a>()</code>, so extra arguments are accepted.
</p>
<p>- If a list of comparisons is specified, the result of the pairwise tests is
filtered to keep only the comparisons of interest.The p-value is adjusted
after filtering.
</p>
<p>- For a grouped data, if pairwise test is performed, then the p-values are
adjusted for each group level independently.
</p>
<p>- a nonparametric confidence interval and an estimator for the pseudomedian
(one-sample case) or for the difference of the location parameters
<code>x-y</code> is computed, where x and y are the compared samples or groups.
The column <code>estimate</code> and the confidence intervals are displayed in the
test result when the option <code>detailed = TRUE</code> is specified in the
<code>wilcox_test()</code> and <code>pairwise_wilcox_test()</code> functions. Read more
about the calculation of the estimate in the details section of the R base
function <code>wilcox.test()</code> documentation by typing <code>?wilcox.test</code> in
the R console.
</p>


<h3>Value</h3>

<p>return a data frame with some of the following columns: </p>

<ul>
<li> <p><code>.y.</code>: the y variable used in the test. </p>
</li>
<li>
<p><code>group1,group2</code>: the compared groups in the pairwise tests. </p>
</li>
<li>
<p><code>n,n1,n2</code>: Sample counts. </p>
</li>
<li> <p><code>statistic</code>: Test statistic used
to compute the p-value. </p>
</li>
<li> <p><code>p</code>: p-value. </p>
</li>
<li> <p><code>p.adj</code>: the
adjusted p-value. </p>
</li>
<li> <p><code>method</code>: the statistical test used to compare
groups. </p>
</li>
<li> <p><code>p.signif, p.adj.signif</code>: the significance level of
p-values and adjusted p-values, respectively. </p>
</li>
<li> <p><code>estimate</code>: an
estimate of the location parameter (Only present if argument <code>detailed
 = TRUE</code>). This corresponds to the pseudomedian (for one-sample case) or to
the difference of the location parameter (for two-samples case). </p>

<ul>
<li><p> The pseudomedian of a distribution <code>F</code> is the median of the
distribution of <code>(u+v)/2</code>, where <code>u</code> and v are independent, each
with distribution <code>F</code>. If <code>F</code> is symmetric, then the pseudomedian
and median coincide. </p>
</li>
<li><p> Note that in the two-sample case the estimator
for the difference in location parameters does not estimate the difference
in medians (a common misconception) but rather the median of the difference
between a sample from x and a sample from y. </p>
</li></ul>
 </li>
<li> <p><code>conf.low,
 conf.high</code>: a confidence interval for the location parameter. (Only present
if argument conf.int = TRUE.) </p>
</li></ul>

<p>The <strong>returned object has an attribute called args</strong>, which is a list
holding the test arguments.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>wilcox_test()</code>: Wilcoxon test
</p>
</li>
<li> <p><code>pairwise_wilcox_test()</code>: performs pairwise two sample Wilcoxon test.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># Load data
#:::::::::::::::::::::::::::::::::::::::
data("ToothGrowth")
df &lt;- ToothGrowth

# One-sample test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% wilcox_test(len ~ 1, mu = 0)


# Two-samples unpaired test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% wilcox_test(len ~ supp)

# Two-samples paired test
#:::::::::::::::::::::::::::::::::::::::::
df %&gt;% wilcox_test (len ~ supp, paired = TRUE)

# Compare supp levels after grouping the data by "dose"
#::::::::::::::::::::::::::::::::::::::::
df %&gt;%
  group_by(dose) %&gt;%
  wilcox_test(data =., len ~ supp) %&gt;%
  adjust_pvalue(method = "bonferroni") %&gt;%
  add_significance("p.adj")

# pairwise comparisons
#::::::::::::::::::::::::::::::::::::::::
# As dose contains more than two levels ==&gt;
# pairwise test is automatically performed.
df %&gt;% wilcox_test(len ~ dose)

# Comparison against reference group
#::::::::::::::::::::::::::::::::::::::::
# each level is compared to the ref group
df %&gt;% wilcox_test(len ~ dose, ref.group = "0.5")

# Comparison against all
#::::::::::::::::::::::::::::::::::::::::
df %&gt;% wilcox_test(len ~ dose, ref.group = "all")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
