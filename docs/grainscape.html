<!DOCTYPE html><html><head><title>Help for package grainscape</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grainscape}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#grainscape-package'><p>Landscape Connectivity, Habitat, and Protected Area Networks</p></a></li>
<li><a href='#.gFinal'><p><code>.gFinal</code></p></a></li>
<li><a href='#.habConnEngine'><p>Habitat connectivity engine</p></a></li>
<li><a href='#.habConnRcpp'><p>Habitat connectivity engine (C++)</p></a></li>
<li><a href='#+24'><p>Extract or Replace Parts of an Object</p></a></li>
<li><a href='#corridor'><p>Visualize corridors between two points using a grains of connectivity (GOC)</p></a></li>
<li><a href='#corridor-class'><p>The <code>corridor</code> class</p></a></li>
<li><a href='#distance'><p>Find the grains of connectivity network distance</p></a></li>
<li><a href='#export'><p>Export spatial data from MPG and GOC models</p></a></li>
<li><a href='#ggGS'><p>Prepare data in <code>MPG</code> and <code>grain</code> objects for use with <code>ggplot2</code></p></a></li>
<li><a href='#GOC'><p>Produce a grains of connectivity model at multiple scales (patch-based or lattice GOC)</p></a></li>
<li><a href='#goc-class'><p>The <code>goc</code> class</p></a></li>
<li><a href='#grain'><p>Extract a grain of connectivity (GOC) tessellation at a given scale</p></a></li>
<li><a href='#grain-class'><p>The <code>grain</code> class</p></a></li>
<li><a href='#grainscape-maps'><p>Test maps included with <code>grainscape</code></p></a></li>
<li><a href='#graphdf'><p>Produce a <code>data.frame</code> containing the structure and associated attributes</p></a></li>
<li><a href='#gsGOC'><p>Deprecated functions</p></a></li>
<li><a href='#gsMPGstitch'><p><code>grainscape</code>: Defunct</p></a></li>
<li><a href='#hce-class'><p>The <code>hce</code> class</p></a></li>
<li><a href='#MPG'><p>Extract a minimum planar graph (MPG) model from a landscape resistance surface</p></a></li>
<li><a href='#mpg-class'><p>The <code>mpg</code> class</p></a></li>
<li><a href='#patchFilter'><p>Filter out patches smaller than a specified area</p></a></li>
<li><a href='#plot+2Ccorridor+2CANY-method'><p>Plot quick visualizations of <code>grainscape</code> objects</p></a></li>
<li><a href='#point'><p>Identify the polygons containing locations in grains of connectivity (GOC) tessellations</p></a></li>
<li><a href='#show+2Cgoc-method'><p>Show a <code>grainscape</code> object</p></a></li>
<li><a href='#theme_grainscape'><p>A <code>ggplot2</code> theme for <code>grainscape</code></p></a></li>
<li><a href='#threshold'><p>Produce a minimum planar graph (MPG) at multiple scales</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Landscape Connectivity, Habitat, and Protected Area Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Given a landscape resistance surface, creates minimum planar graph
    (Fall et al. (2007) &lt;<a href="https://doi.org/10.1007%2Fs10021-007-9038-7">doi:10.1007/s10021-007-9038-7</a>&gt;) and grains of connectivity
    (Galpern et al. (2012) &lt;<a href="https://doi.org/10.1111%2Fj.1365-294X.2012.05677.x">doi:10.1111/j.1365-294X.2012.05677.x</a>&gt;) models that can be
    used to calculate effective distances for landscape connectivity at multiple scales.
    Documentation is provided by several vignettes, and a paper
    (Chubaty, Galpern &amp; Doctolero (2020) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13350">doi:10.1111/2041-210X.13350</a>&gt;).</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.alexchubaty.com/grainscape/">https://www.alexchubaty.com/grainscape/</a>,
<a href="https://github.com/achubaty/grainscape">https://github.com/achubaty/grainscape</a></td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-20</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, graphics, grDevices, igraph, methods, sf, sp, raster,
Rcpp (&ge; 0.12.11.4), utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, cowplot, ggthemes, knitr, parallel, rmarkdown,
spelling, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/achubaty/grainscape/issues">https://github.com/achubaty/grainscape/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Collate:</td>
<td>'grainscape-package.R' 'classes.R' 'GOC.R' 'MPG.R'
'RcppExports.R' 'grain.R' 'corridor.R' 'distance.R' 'export.R'
'extract.R' 'ggGS.R' 'grainscape-deprecated.R' 'graphdf.R'
'habitatConnectivityEngine.R' 'patchFilter.R' 'plot.R'
'point.R' 'theme_grainscape.R' 'threshold.R' 'zzz.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-20 02:43:09 UTC; achubaty</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Galpern <a href="https://orcid.org/0000-0003-0099-3981"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph],
  Sam Doctolero [aut],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alex M Chubaty &lt;alex.chubaty@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-20 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='grainscape-package'>Landscape Connectivity, Habitat, and Protected Area Networks</h2><span id='topic+grainscape'></span><span id='topic+grainscape-package'></span>

<h3>Description</h3>

<p>Given a landscape resistance surface, creates minimum planar graph and
grains of connectivity models that can be used to calculate effective
distances for landscape connectivity at multiple scales.
</p>


<h3>Details</h3>

<p>Landscape connectivity modelling to understand the movement and dispersal of
organisms has been done using raster resistance surfaces and landscape graph methods.
Grains of connectivity (GOC) models combine elements of both approaches to produce
a continuous and scalable tool that can be applied in a variety of study systems.
The purpose of this package is to implement grains of connectivity analyses.
Routines accept raster-based resistance surfaces as input and return raster,
vector and graph-based data structures to represent connectivity at multiple scales.
Effective distances describing connectivity between geographic locations can
be determined at multiple scales.
Analyses of this sort can contribute to corridor identification, landscape genetics,
as well as other connectivity assessments.
Minimum planar graph (MPG; Fall <em>et al.</em>, 2007) models of resource patches on
landscapes can also be generated using the software.
</p>
<p>MPG calculations and generalization of the Voronoi tessellation used in GOC models
is based on the routines in SELES software (Fall and Fall, 2001).
Routines also depend on the <span class="pkg">sp</span> (Pebesma and Bivand, 2005),
<span class="pkg">raster</span> (Hijmans and van Etten, 2011), and <span class="pkg">igraph</span> (Csardi and Nepusz, 2006) packages.
</p>
<p>A paper describing the use of this package for landscape connectivity modelling is
available at <a href="https://doi.org/10.1111/2041-210X.13350">doi:10.1111/2041-210X.13350</a>.
</p>
<p>A detailed tutorial is available as a vignette (see <code>browseVignettes('grainscape')</code>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Alex M Chubaty <a href="mailto:alex.chubaty@gmail.com">alex.chubaty@gmail.com</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Paul Galpern <a href="mailto:pgalpern@gmail.com">pgalpern@gmail.com</a> (<a href="https://orcid.org/0000-0003-0099-3981">ORCID</a>) [copyright holder]
</p>
</li>
<li><p> Sam Doctolero <a href="mailto:sam.doctolero@gmail.com">sam.doctolero@gmail.com</a>
</p>
</li></ul>



<h3>References</h3>

<p>Csardi, G. and T. Nepusz. (2006). The igraph software package for complex network research.
InterJournal Complex Systems 1695. <a href="https://igraph.org">https://igraph.org</a>.
</p>
<p>Fall, A. and J. Fall. (2001). A domain-specific language for models of landscape dynamics.
Ecological Modelling 141:1-18.
</p>
<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs: Principles
and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011)  Patch-based graphs of landscape connectivity:
A guide to construction, analysis and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>
<p>Hijmans, R.J. (2023). raster: Geographic Data Analysis and Modeling.
R package version 3.6-20, <a href="https://CRAN.R-project.org/package=raster">https://CRAN.R-project.org/package=raster</a>.
</p>
<p>Pebesma, E.J. and R.S. Bivand. (2005). Classes and methods for spatial data in R.
R News 5 (2), <a href="https://cran.r-project.org/doc/Rnews/">https://cran.r-project.org/doc/Rnews/</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://www.alexchubaty.com/grainscape/">https://www.alexchubaty.com/grainscape/</a>
</p>
</li>
<li> <p><a href="https://github.com/achubaty/grainscape">https://github.com/achubaty/grainscape</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/achubaty/grainscape/issues">https://github.com/achubaty/grainscape/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.gFinal'><code>.gFinal</code></h2><span id='topic+.gFinal'></span>

<h3>Description</h3>

<p><code>.gFinal</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.gFinal(g, print, theme)
</code></pre>


<h3>Author(s)</h3>

<p>Paul Galpern
</p>

<hr>
<h2 id='.habConnEngine'>Habitat connectivity engine</h2><span id='topic+.habConnEngine'></span>

<h3>Description</h3>

<p>Internal function. Serves as a wrapper around the habitat connectivity engine
developed in C++.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.habConnEngine(cost, patches)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".habConnEngine_+3A_cost">cost</code></td>
<td>
<p>Numeric raster cost (resistance) map.</p>
</td></tr>
<tr><td><code id=".habConnEngine_+3A_patches">patches</code></td>
<td>
<p>Logical raster indicating presence of habitat patches.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+hce-class">hce</a>.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>


<h3>See Also</h3>

<p><code>link{habConnRcpp}</code>
</p>

<hr>
<h2 id='.habConnRcpp'>Habitat connectivity engine (C++)</h2><span id='topic+.habConnRcpp'></span>

<h3>Description</h3>

<p>Internal function, not intended to be called directly.
DESCRIPTION NEEDED.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.habConnRcpp(cost, patches, ncol, nrow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".habConnRcpp_+3A_cost">cost</code></td>
<td>
<p>Numeric vector of habitat cost (resistance) values
extracted from a raster cost map.</p>
</td></tr>
<tr><td><code id=".habConnRcpp_+3A_patches">patches</code></td>
<td>
<p>Numeric vector that have binary values (<code>0</code> and <code>1</code>)
where ones corresponds to patch cells and zeroes to
non-habitat (i.e., matrix) cells.</p>
</td></tr>
<tr><td><code id=".habConnRcpp_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns in the raster cost/patch map.</p>
</td></tr>
<tr><td><code id=".habConnRcpp_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows in the raster cost/patch map.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Sam Doctolero
</p>

<hr>
<h2 id='+24'>Extract or Replace Parts of an Object</h2><span id='topic++24'></span><span id='topic++24+2Cgoc-method'></span><span id='topic++24+3C-'></span><span id='topic++24+3C-+2Cgoc-method'></span><span id='topic++24+2Cmpg-method'></span><span id='topic++24+3C-+2Cmpg-method'></span>

<h3>Description</h3>

<p>Extract or Replace Parts of an Object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'goc'
x$name

## S4 replacement method for signature 'goc'
x$name &lt;- value

## S4 method for signature 'mpg'
x$name

## S4 replacement method for signature 'mpg'
x$name &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24_+3A_x">x</code></td>
<td>
<p>A <code>simList</code> object from which to extract element(s) or
in which to replace element(s).</p>
</td></tr>
<tr><td><code id="+2B24_+3A_name">name</code></td>
<td>
<p>A literal character string or a <code><a href="base.html#topic+name">name()</a></code>.</p>
</td></tr>
<tr><td><code id="+2B24_+3A_value">value</code></td>
<td>
<p>Any R object.</p>
</td></tr>
</table>

<hr>
<h2 id='corridor'>Visualize corridors between two points using a grains of connectivity (GOC)</h2><span id='topic+corridor'></span><span id='topic+corridor+2Cgoc-method'></span>

<h3>Description</h3>

<p>Given a series of GOC models built at different scales, visualize the corridor
(or shortest path) between two points using one of the tessellations
(i.e., scales) in these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corridor(x, ...)

## S4 method for signature 'goc'
corridor(x, whichThresh, coords, weight = "meanWeight", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corridor_+3A_x">x</code></td>
<td>
<p>A <code>goc</code> object created by <code><a href="#topic+GOC">GOC()</a></code>.</p>
</td></tr>
<tr><td><code id="corridor_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="corridor_+3A_whichthresh">whichThresh</code></td>
<td>
<p>Integer giving the index of the threshold to visualize.</p>
</td></tr>
<tr><td><code id="corridor_+3A_coords">coords</code></td>
<td>
<p>A two column matrix or a <code><a href="sp.html#topic+SpatialPoints">SpatialPoints()</a></code> object
giving coordinates at the end points of the corridor.</p>
</td></tr>
<tr><td><code id="corridor_+3A_weight">weight</code></td>
<td>
<p>The GOC graph link weight to use in calculating the distance.
Please see details in <code><a href="#topic+distance">distance()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+corridor-class">corridor</a>.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GOC">GOC()</a></code>, <code><a href="#topic+visualize">visualize()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Quick visualization of a corridor
corridorStartEnd &lt;- rbind(c(10, 10), c(90, 90))
tinyPatchCorridor &lt;- corridor(tinyPatchGOC, whichThresh = 3, coords = corridorStartEnd)
if (interactive())
  plot(tinyPatchCorridor)

## More control over a corridor visualization
if (interactive()) {
  plot(tinyPatchCorridor@voronoi, col = "lightgrey", lwd = 2)
  plot(tinyPatchCorridor@linksSP, col = "darkred", lty = "dashed", add = TRUE)
  plot(tinyPatchCorridor@nodesSP, col = "darkred", pch = 21, bg = "white", add = TRUE)
  plot(tinyPatchCorridor@shortestLinksSP, col = "darkred", lty = "solid", lwd = 2, add = TRUE)
  plot(tinyPatchCorridor@shortestNodesSP, col = "darkred", pch = 21, bg = "darkred", add = TRUE)
  mtext(paste("Corridor shortest path length:",
              round(tinyPatchCorridor@corridorLength, 2),
              "resistance units"), side = 1)
}
</code></pre>

<hr>
<h2 id='corridor-class'>The <code>corridor</code> class</h2><span id='topic+corridor-class'></span>

<h3>Description</h3>

<p>The <code>corridor</code> class
</p>


<h3>Slots</h3>


<dl>
<dt><code>voronoi</code></dt><dd><p>A <code>RasterLayer</code> representation of the boundaries
of the voronoi polygons.</p>
</dd>
<dt><code>linksSP</code></dt><dd><p>A <code>SpatialLinesDataFrame</code> representation of links
in the grains of connectivity graph.</p>
</dd>
<dt><code>nodesSP</code></dt><dd><p>A <code>SpatialPoints</code> representation of the nodes in
the grains of connectivity graph</p>
</dd>
<dt><code>shortestLinksSP</code></dt><dd><p>A <code>SpatialLines</code> representation of the links in
the shortest path between coordinates</p>
</dd>
<dt><code>shortestNodesSP</code></dt><dd><p>A <code>SpatialPoints</code> representation of the nodes in
the shortest path between coordinates</p>
</dd>
<dt><code>corridorLength</code></dt><dd><p>A <code>numeric</code> of length 1 giving the length of the
shortest path between coordinates in accumulated
resistance units.
</p>
<p>See <code><a href="#topic+corridor">corridor()</a></code> for more information.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alex Chubaty and Paul Galpern
</p>

<hr>
<h2 id='distance'>Find the grains of connectivity network distance</h2><span id='topic+distance'></span><span id='topic+distance+2Cgoc+2CSpatialPoints-method'></span><span id='topic+distance+2Cgoc+2Cmatrix-method'></span><span id='topic+distance+2Cgoc+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Find the shortest network distance between pairs of points using the GOC graph.
This can be used as an effective distance for landscape connectivity assessments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance(x, y, ...)

## S4 method for signature 'goc,SpatialPoints'
distance(x, y, weight = "meanWeight", ...)

## S4 method for signature 'goc,matrix'
distance(x, y, weight = "meanWeight", ...)

## S4 method for signature 'goc,numeric'
distance(x, y, weight = "meanWeight", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_+3A_x">x</code></td>
<td>
<p>A <code>goc</code> object produced by <code><a href="#topic+GOC">GOC()</a></code>.</p>
</td></tr>
<tr><td><code id="distance_+3A_y">y</code></td>
<td>
<p>A two column matrix or a <code><a href="sp.html#topic+SpatialPoints">SpatialPoints()</a></code> object
giving the coordinates of points of interest.</p>
</td></tr>
<tr><td><code id="distance_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="distance_+3A_weight">weight</code></td>
<td>
<p>The GOC graph link weight to use in calculating the distance.
Please see Details for explanation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object giving a distance matrix for each threshold in the <code>GOC</code> object.
Distance matrices give the pairwise grains of connectivity network distances
between sampling locations.
Matrix indices correspond to rows in the coordinates matrix (<code>y</code>).
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GOC">GOC()</a></code>, <code><a href="#topic+point">point()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Three sets of coordinates in the study area
loc &lt;- cbind(c(30, 60, 90), c(30, 60, 90))

## Find the GOC network distance matrices between these points
## for each of the 5 grains of connectivity
tinyDist &lt;- grainscape::distance(tinyPatchGOC, loc)
</code></pre>

<hr>
<h2 id='export'>Export spatial data from MPG and GOC models</h2><span id='topic+export'></span><span id='topic+export+2Cmpg-method'></span><span id='topic+export+2Cgrain-method'></span><span id='topic+export+2Cgoc-method'></span>

<h3>Description</h3>

<p>This function automates the export of raster and vector spatial data from <code>mpg</code> and
<code>grain</code> objects. By default it places them in a new directory, unless an existing one is
specified with <code>overwrite = TRUE</code>.
</p>
<p>It can also be used to process <code>mpg</code> and <code>grain</code> objects to
produce R spatial objects that are convenient for plotting or analysis within R.
Use <code>R = TRUE</code> in which case all parameters related to file export
are ignored. (Default <code>R = FALSE</code>)
</p>
<p>The <code><a href="raster.html#topic+writeRaster">raster::writeRaster()</a></code> is used for rasters,
and <code><a href="sf.html#topic+st_write">sf::st_write()</a></code> is used to export ESRI compatible shape files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(
  x,
  dirname = NULL,
  path = ".",
  rasterFormat = "GTiff",
  overwrite = FALSE,
  R = FALSE,
  vorBound = FALSE,
  ...
)

## S4 method for signature 'mpg'
export(
  x,
  dirname = NULL,
  path = ".",
  rasterFormat = "GTiff",
  overwrite = FALSE,
  R = FALSE,
  vorBound = FALSE,
  ...
)

## S4 method for signature 'grain'
export(
  x,
  dirname = NULL,
  path = ".",
  rasterFormat = "GTiff",
  overwrite = FALSE,
  R = FALSE,
  vorBound = FALSE,
  ...
)

## S4 method for signature 'goc'
export(
  x,
  dirname = NULL,
  path = ".",
  rasterFormat = "GTiff",
  overwrite = FALSE,
  R = FALSE,
  vorBound = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_+3A_x">x</code></td>
<td>
<p>A <code>mpg</code> or <code>grain</code> object</p>
</td></tr>
<tr><td><code id="export_+3A_dirname">dirname</code></td>
<td>
<p>The name of a new directory to create. If <code>NULL</code>
a directory with a name containing the date and time will be created.</p>
</td></tr>
<tr><td><code id="export_+3A_path">path</code></td>
<td>
<p>A path to where this new directory <code>dirname</code> should be created.
Defaults to the working directory.</p>
</td></tr>
<tr><td><code id="export_+3A_rasterformat">rasterFormat</code></td>
<td>
<p>The format for exported rasters. See <code><a href="raster.html#topic+writeFormats">writeFormats()</a></code> for
options. Defaults to GeoTiff (<code>rasterFormat='GTiff'</code>).
Use <code>rasterFormat='raster'</code> to save <code>.grd</code> files in
native <code>raster</code> package format.</p>
</td></tr>
<tr><td><code id="export_+3A_overwrite">overwrite</code></td>
<td>
<p>If directory already exists will overwrite existing files inside.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_r">R</code></td>
<td>
<p>If <code>TRUE</code>, return the spatial objects that would be written to files.
Do not write these files and ignore <code>dirname</code>, <code>path</code>,
<code>rasterFormat</code>, <code>overwrite</code> parameters.
This is useful for visualization using R plotting functions,
or spatial analysis within R. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="export_+3A_vorbound">vorBound</code></td>
<td>
<p>Specify whether to create a raster with the boundaries of
the Voronoi polygons <code style="white-space: pre;">&#8288;=1&#8288;</code> and the remainder <code style="white-space: pre;">&#8288;=NA&#8288;</code>.
This may be useful for visualizing relationships among
polygons in a grain of connectivity.
This can add time to the export on very large rasters.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the path to the folder created.
</p>
<p>Side effect of exporting files representing raster and vector spatial data
in the object.
</p>
<p>Please note that for vector data export the attribute name is limited
to 8 characters in shape files. See the tables below for the abbreviations
used and their meaning.
</p>
<p><strong>Exported from <code>mpg</code> objects:</strong>
</p>
<p><code>nodes</code>, <code>linksCentroid</code>, <code>linksPerim</code> are shape files giving
the locations of the patch centroids, links among centroids, and links
among perimeters of patches respectively. <code style="white-space: pre;">&#8288;patchId, voronoi&#8288;</code> are
rasters giving the patch identifier of the patch, or of the patch that
the Voronoi polygon refers to. <code style="white-space: pre;">&#8288;lcpPerimWeight, lcpLinkId&#8288;</code> give
the weight in cost surface units of the shortest paths between perimeters,
and the identifiers of those links respectively. <code>vorBound</code> gives
the boundaries of the Voronoi polygons (if specified).
</p>
<p>Description of node (vertex) and link (edge) weights in <code>mpg</code> objects
and their corresponding attribute names in the shape files created.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>type</strong> </td><td style="text-align: left;"> <strong>MPG name</strong> </td><td style="text-align: left;"> <strong>SHP name</strong> </td><td style="text-align: left;"> <strong>Description</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>patchId</code> </td><td style="text-align: left;"> <code>patchId</code> </td><td style="text-align: left;"> Patch ID from <code>patchId</code> raster </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>patchArea</code> </td><td style="text-align: left;"> <code>patchA</code> </td><td style="text-align: left;"> Area of patch </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>patchEdgeArea</code> </td><td style="text-align: left;"> <code>patchEA</code> </td><td style="text-align: left;"> Edge area of patch </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>coreArea</code> </td><td style="text-align: left;"> <code>coreA</code> </td><td style="text-align: left;"> Area excluding edge of patch </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>centroidX</code> </td><td style="text-align: left;"> <code>ctrX</code> </td><td style="text-align: left;"> Centroid of the patch (X)</td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>centroidY</code> </td><td style="text-align: left;"> <code>ctrY</code> </td><td style="text-align: left;"> Centroid of the patch (Y)</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>e1</code> </td><td style="text-align: left;"> <code>e1</code> </td><td style="text-align: left;"> Id of first patch at end of link</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>e2</code> </td><td style="text-align: left;"> <code>e2</code> </td><td style="text-align: left;"> Id of second patch at end of link</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>linkId</code> </td><td style="text-align: left;"> <code>linkId</code> </td><td style="text-align: left;"> Link ID from <code>lcpLinkId</code> raster</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>lcPerimWeight</code> </td><td style="text-align: left;"> <code>lcpPerWt</code> </td><td style="text-align: left;"> Cost length of link from patch perimeters</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>startPerimX</code> </td><td style="text-align: left;"> <code>strtPerX</code> </td><td style="text-align: left;"> Coordinate of link endpoint on first patch (X)</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>startPerimY</code> </td><td style="text-align: left;"> <code>strtPerY</code> </td><td style="text-align: left;"> Coordinate of link endpoint on first patch (Y)</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>endPerimX</code> </td><td style="text-align: left;"> <code>endPerX</code> </td><td style="text-align: left;"> Coordinate of link endpoint on second patch (X)</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>endPerimY</code> </td><td style="text-align: left;"> <code>endPerY</code> </td><td style="text-align: left;"> Coordinate of link endpoint on second patch (Y)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p><strong>Exported from <code>grain</code> objects:</strong>
</p>
<p><code style="white-space: pre;">&#8288;nodes, linksCentroid&#8288;</code> are shape files giving the locations of the
Voronoi polygon centroids and links among them respectively.
<code>voronoi</code> are rasters gives the polygon identifier of each cluster of patches.
<code>vorBound</code> gives the boundaries of the Voronoi polygons (if specified).
</p>
<p>Description of node (vertex) and link (edge) weights in <code>grain</code>
objects  and their corresponding attribute names in the shape files created.
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong>Type</strong> </td><td style="text-align: left;"> <strong>GOC name</strong> </td><td style="text-align: left;"> <strong>SHP name</strong> </td><td style="text-align: left;"> <strong>Description</strong></td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>polygonId</code> </td><td style="text-align: left;"> <code>polyId</code> </td><td style="text-align: left;"> Polygon ID from grain voronoi raster </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>polygonArea</code> </td><td style="text-align: left;"> <code>polyA</code> </td><td style="text-align: left;"> Area of polygon from grain voronoi raster </td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>totalPatchArea</code> </td><td style="text-align: left;"> <code>patchA</code> </td><td style="text-align: left;"> Total area of all patches in polygon</td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>totalPatchEdgeArea</code> </td><td style="text-align: left;"> <code>patchEA</code> </td><td style="text-align: left;"> Total area of all patch edges in polygon</td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>totalCoreArea</code> </td><td style="text-align: left;"> <code>coreA</code> </td><td style="text-align: left;"> Total area of patches in polygon excluding edges</td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>centroidX</code> </td><td style="text-align: left;"> <code>ctrX</code> </td><td style="text-align: left;"> Centroid of the polygon (X)</td>
</tr>
<tr>
 <td style="text-align: left;">
node </td><td style="text-align: left;"> <code>centroidY</code> </td><td style="text-align: left;"> <code>ctrY</code> </td><td style="text-align: left;"> Centroid of the polygon (Y)</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>e1</code> </td><td style="text-align: left;"> <code>e1</code> </td><td style="text-align: left;"> ID of first patch at end of link</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>e2</code> </td><td style="text-align: left;"> <code>e2</code> </td><td style="text-align: left;"> ID of second patch at end of link</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>maxWeight</code> </td><td style="text-align: left;"> <code>maxWt</code> </td><td style="text-align: left;"> The maximum weight of all links connecting
patches between polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>linkIdMaxWeight</code> </td><td style="text-align: left;"> <code>maxWt</code> </td><td style="text-align: left;"> The link id of that maximum weight
<code>link (lcpLinkId)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>minWeight</code> </td><td style="text-align: left;"> <code>min</code> </td><td style="text-align: left;"> The minimum weight of all links connecting
patches between polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>linkIdMinWeight</code> </td><td style="text-align: left;"> <code>minWt</code> </td><td style="text-align: left;"> The link id of that minimum weight
<code>link (lcpLinkId)</code></td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>medianWeight</code> </td><td style="text-align: left;"> <code>medWt</code> </td><td style="text-align: left;"> The median weight of all links connecting
patches between polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>meanWeight</code> </td><td style="text-align: left;"> <code>meanWT</code> </td><td style="text-align: left;"> The minimum weight of all links connecting
patches between polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>numlinksWeight</code> </td><td style="text-align: left;"> <code>numEWt</code> </td><td style="text-align: left;"> The number of links connecting patches
between polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
link </td><td style="text-align: left;"> <code>eucCentroidWeight</code> </td><td style="text-align: left;"> <code>eucCtrWt</code> </td><td style="text-align: left;"> The Euclidean distance between
centroids of polygons</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>, <code><a href="#topic+GOC">GOC()</a></code>, <code><a href="#topic+grain">grain()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Export rasters and vectors and place in an R object
sp_tinyPatchGOC &lt;- export(grain(tinyPatchGOC, 2), R = TRUE)  # nolint
sp_tinyPatchMPG &lt;- export(tinyPatchMPG, R = TRUE) # nolint

## Export raster and vectors to a specified directory
exportPath &lt;- tempdir()
export(grain(tinyPatchGOC, 2), dirname = "tiny_goc_thresh2", path = exportPath)
export(tinyPatchMPG, dirname = "tiny_mpg", path = exportPath, vorBound = TRUE)

## clean up
unlink(file.path(exportPath, "tiny_goc_thresh2"), recursive = TRUE)
unlink(file.path(exportPath, "tiny_mpg"), recursive = TRUE)
</code></pre>

<hr>
<h2 id='ggGS'>Prepare data in <code>MPG</code> and <code>grain</code> objects for use with <code>ggplot2</code></h2><span id='topic+ggGS'></span><span id='topic+ggGS+2CRasterLayer-method'></span><span id='topic+ggGS+2Clist-method'></span><span id='topic+ggGS+2Cmpg-method'></span><span id='topic+ggGS+2Cgrain-method'></span><span id='topic+ggGS+2Cgoc-method'></span>

<h3>Description</h3>

<p>This is an informal <code>fortify</code>-type method that prepares either
<code>RasterLayer</code> or <code>igraph</code> objects contained as slots within
<code>MPG</code> or <code>grain</code> objects for easy plotting with <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggGS(x, type = NULL, ...)

## S4 method for signature 'RasterLayer'
ggGS(x, type = NULL, ...)

## S4 method for signature 'list'
ggGS(x, type = NULL, ...)

## S4 method for signature 'mpg'
ggGS(x, type = NULL, ...)

## S4 method for signature 'grain'
ggGS(x, type = NULL, ...)

## S4 method for signature 'goc'
ggGS(x, type = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggGS_+3A_x">x</code></td>
<td>
<p>A <code>mpg</code>, <code>grain</code>, or <code>RasterLayer</code> object.</p>
</td></tr>
<tr><td><code id="ggGS_+3A_type">type</code></td>
<td>
<p>If a <code>mpg</code> or <code>grain</code> object is supplied, this
gives the name of the slot to prepare for plotting. Options
are discussed below. Not required if a <code>RasterLayer</code>
is supplied.</p>
</td></tr>
<tr><td><code id="ggGS_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> suitable for plotting with <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>Where <code>type</code> is a raster the <code>data.frame</code> will have the following columns:
</p>

<dl>
<dt><code>value</code></dt><dd><p>the value of the raster cell</p>
</dd>
<dt><code>x</code></dt><dd><p>the x coordinate of the centre of the raster cell</p>
</dd>
<dt><code>y</code></dt><dd><p>the y coordinate of the centre of the raster cell</p>
</dd>
</dl>

<p>Where <code>type = 'nodes'</code> the <code>data.frame</code> will have the following columns:
</p>

<dl>
<dt><code>x</code></dt><dd><p>the x coordinate of the node</p>
</dd>
<dt><code>y</code></dt><dd><p>the y coordinate of the node</p>
</dd>
<dt><code>...</code></dt><dd><p>other attributes associated with the network nodes</p>
</dd>
</dl>

<p>Where <code>type = 'links'</code> the <code>data.frame</code> will have the following columns:
</p>

<dl>
<dt><code>x1</code></dt><dd><p>the x coordinate of the first node</p>
</dd>
<dt><code>y1</code></dt><dd><p>the y coordinate of the first node</p>
</dd>
<dt><code>x2</code></dt><dd><p>the x coordinate of the second node</p>
</dd>
<dt><code>y2</code></dt><dd><p>the y coordinate of the second node</p>
</dd>
<dt><code>x1p</code></dt><dd><p>the x coordinate at the perimeter of the first node</p>
</dd>
<dt><code>y1p</code></dt><dd><p>the y coordinate at the perimeter of the first node</p>
</dd>
<dt><code>x2p</code></dt><dd><p>the x coordinate at the perimeter of the second node</p>
</dd>
<dt><code>y2p</code></dt><dd><p>the y coordinate at the perimeter of the second node</p>
</dd>
<dt><code>...</code></dt><dd><p>other attributes associated with the network links</p>
</dd>
</dl>



<h3>Note</h3>

<p><strong>Options for <code>type</code> parameter</strong>
</p>
<p>If a <code>RasterLayer</code> is supplied <code>type</code> is optional.
</p>
<p>For <code>mpg</code> <code>type</code> options are <code>"node"</code> or <code>"links"</code>.
This prepares the nodes and links of the minimum planar graph network for
plotting,  Also <code>"patchId"</code>, <code>"voronoi"</code>, <code>"lcpPerimWeight"</code>,
<code>"lcpLinkId"</code>, <code>"mpgPlot"</code> will prepare rasters for plotting.
</p>
<p>For <code>grain</code> objects <code>type</code>  options are <code>"nodes"</code> or<code>"links"</code>
to prepare the nodes and links of the grains of connectivity network  for
plotting. Also <code>"voronoi"</code> will prepare the grains of connectivity
Voronoi polygons raster for plotting.
</p>
<p>For either <code>mpg</code> or <code>grain</code> objects <code>type = "vorBound"</code>
will identify the boundaries of the Voronoi polygons for plotting.
This is potentially time consuming for large rasters.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>, <code><a href="#topic+GOC">GOC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
if (interactive()) {
  library(ggplot2)

  ## Plot the patches in a minimum planar graph
  theme_set(theme_grainscape())
  ggplot() +
    geom_tile(data = ggGS(tinyPatchMPG, "patchId"),
              aes(x = x, y = y, fill = value))

  ## Plot the grain polygons in a grain of connectivity
  ggplot() +
    geom_tile(data = ggGS(grain(tinyPatchGOC, 3), "voronoi"),
              aes(x = x, y = y, fill = value))

  ## Plot the grain polygon boundaries
  ggplot() +
    geom_tile(data = ggGS(grain(tinyPatchGOC, 3), "vorBound"),
              aes(x = x, y = y, fill = value))

  ## Plot the patches and perimeter links of a minimum planar graph
  ggplot() +
    geom_tile(data = ggGS(tinyPatchMPG, "patchId"),
              aes(x = x, y = y, fill = value)) +
    geom_segment(data = ggGS(tinyPatchMPG, "links"),
                 aes(x = x1p, y = y1p, xend = x2p, yend = y2p))

  ## Plot the patches and linear representations of the perimeter links
  ## of a minimum planar graph
  ggplot() +
    geom_tile(data = ggGS(tinyPatchMPG, "patchId"),
              aes(x = x, y = y, fill = value)) +
    geom_segment(data = ggGS(tinyPatchMPG, "links"),
                 aes(x = x1p, y = y1p, xend = x2p, yend = y2p))

  ## Plot the nodes and links of a grains of connectivity network
  ## superimposed over the grain polygons
  focalGrain &lt;- grain(tinyPatchGOC, 3)
  ggplot() +
    geom_tile(data = ggGS(focalGrain, "vorBound"),
              aes(x = x, y = y, fill = value)) +
    geom_point(data = ggGS(focalGrain, "nodes"),
               aes(x = x, y = y)) +
    geom_segment(data = ggGS(focalGrain, "links"),
                 aes(x = x1, y = y1, xend = x2, yend = y2))
}
</code></pre>

<hr>
<h2 id='GOC'>Produce a grains of connectivity model at multiple scales (patch-based or lattice GOC)</h2><span id='topic+GOC'></span><span id='topic+GOC+2Cmpg-method'></span>

<h3>Description</h3>

<p>Produce a grains of connectivity (GOC) model at multiple scales (resistance thresholds)
by scalar analysis.
Patch-based or lattice GOC modelling can be done with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GOC(x, ...)

## S4 method for signature 'mpg'
GOC(
  x,
  nThresh = NULL,
  doThresh = NULL,
  weight = "lcpPerimWeight",
  verbose = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GOC_+3A_x">x</code></td>
<td>
<p>A <code>mpg</code> object produced by <code><a href="#topic+MPG">MPG()</a></code>.
For lattice GOC <code>MPG</code> must be run with patch set as an integer value.</p>
</td></tr>
<tr><td><code id="GOC_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="GOC_+3A_nthresh">nThresh</code></td>
<td>
<p>Optional. An integer giving the number of thresholds (or scales)
at which to create GOC models. Thresholds are selected to produce
a maximum number of unique grains (i.e., models).
<code>nThresh</code> thresholds are also approximately evenly spread
between 0 and the threshold at which all patches or focal points
on the landscape are connected. This is a simple way to get
a representative subset of all possible GOC models.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
<tr><td><code id="GOC_+3A_dothresh">doThresh</code></td>
<td>
<p>Optional. A vector giving the link thresholds at which to create GOC models.
Use <code><a href="#topic+threshold">threshold()</a></code> to identify thresholds of interest.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
<tr><td><code id="GOC_+3A_weight">weight</code></td>
<td>
<p>A string giving the link weight or attribute to use for threshold.
<code>"lcpPerimWeight"</code> uses the accumulated resistance or least-cost
path distance from the perimeters of patches as the link weight.</p>
</td></tr>
<tr><td><code id="GOC_+3A_verbose">verbose</code></td>
<td>
<p>Set <code>verbose=0</code> for no progress information to console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Grain or scalar analysis of connectivity may be appropriate for a variety of purposes, not
limited to visualization and improving connectivity estimates for highly-mobile organisms.
See Galpern <em>et al.</em> (2012), Galpern &amp; Manseau (2013a, 2013b) for applications
and review of these capabilities.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+goc-class">goc()</a></code> object.
</p>


<h3>Note</h3>

<p>Researchers should consider whether the use of a patch-based GOC or a lattice
GOC model is appropriate based on the patch-dependency of the organism under study.
Patch-based models make most sense when animals are restricted to, or dependent on,
a resource patch.
Lattice models can be used as a generalized and functional approach to scaling
resistance surfaces.
</p>
<p>See <code><a href="#topic+MPG">MPG()</a></code> for warning related to areal measurements.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>, <code><a href="#topic+grain">grain()</a></code>,
<code><a href="#topic+distance">distance()</a></code>, <code><a href="#topic+point">point()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Examine the properties of the GOC graph of grain 3 of 5
graphdf(grain(tinyPatchGOC, whichThresh = 3))

## Extract grains of connectivity
## representation of the finest grain and three others
## by giving thresholds in link weights (doThresh)
tinyPatchGOC &lt;- GOC(tinyPatchMPG, doThresh = c(0, 20, 40))
</code></pre>

<hr>
<h2 id='goc-class'>The <code>goc</code> class</h2><span id='topic+goc-class'></span>

<h3>Description</h3>

<p>The <code>goc</code> class
</p>


<h3>Slots</h3>


<dl>
<dt><code>voronoi</code></dt><dd><p>A <code>RasterLayer</code> describing the regions of proximity in
resistance units around the focal patches or points.</p>
</dd>
<dt><code>summary</code></dt><dd><p>A summary of the the grains of connectivity generated and
their properties.</p>
</dd>
<dt><code>th</code></dt><dd><p>A list giving the GOC graph at each threshold.
</p>
<p>Each element of <code>th</code> contains a <code>goc</code> object giving the GOC graph
as class <code><a href="igraph.html#topic+igraph">igraph()</a></code>.
Vertex attributes describes qualities of each polygon including the coordinates
of each polygon centroid, the area of these polygons, and the original patch
IDs in the MPG that are included in each polygon.
All areal measurements are given as raster cell counts.
A variety of edge attributes are also given in the GOC graph.
See <code><a href="#topic+distance">distance()</a></code> for more information.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alex Chubaty and Paul Galpern
</p>

<hr>
<h2 id='grain'>Extract a grain of connectivity (GOC) tessellation at a given scale</h2><span id='topic+grain'></span><span id='topic+grain+2Cgoc-method'></span>

<h3>Description</h3>

<p>Extract a grain (i.e. a scaled version of a Voronoi tessellation) from a GOC model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grain(x, ...)

## S4 method for signature 'goc'
grain(x, whichThresh, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grain_+3A_x">x</code></td>
<td>
<p>A <code>goc</code> object created by <code><a href="#topic+GOC">GOC()</a></code>.</p>
</td></tr>
<tr><td><code id="grain_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="grain_+3A_whichthresh">whichThresh</code></td>
<td>
<p>Integer giving the grain threshold to extract.
This is the index of the threshold extracted by <code><a href="#topic+GOC">GOC()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing the following elements:
</p>

<dl>
<dt><code>summary</code></dt><dd><p>gives the properties of the specified scale/grain <code>whichThresh</code>
of the GOC model;</p>
</dd>
<dt><code>voronoi</code></dt><dd><p>a <code>RasterLayer</code> giving the Voronoi tessellation the
specified scale/grain <code>whichThresh</code> of the GOC model;</p>
</dd>
<dt><code>centroids</code></dt><dd><p>a <code>SpatialPoints</code> objects giving the centroids
of the polygons in the Voronoi tessellation at the specified scale/grain <code>whichThresh</code>;</p>
</dd>
<dt><code>th</code></dt><dd><p>a <code>igraph</code> object giving the graph describing the relationship
among the polygons at the specified scale/grain <code>whichThresh</code></p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GOC">GOC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Very quick visualization at the finest scale/grain/threshold
tinyPatchGOCgrain &lt;- grain(tinyPatchGOC, whichThresh = 1)
if (interactive())
  plot(tinyPatchGOCgrain, col = topo.colors(10))

## Visualize the model at the finest scale/grain/threshold
## Manual control of plotting
if (interactive()) {
  plot(grain(tinyPatchGOC, whichThresh = 1)@voronoi,
       col = sample(rainbow(100)), legend = FALSE, main = "Threshold 1")
}
</code></pre>

<hr>
<h2 id='grain-class'>The <code>grain</code> class</h2><span id='topic+grain-class'></span>

<h3>Description</h3>

<p>The <code>grain</code> class
</p>


<h3>Slots</h3>


<dl>
<dt><code>voronoi</code></dt><dd><p>A <code>RasterLayer</code> describing the regions of proximity in
resistance units around the focal patches or points.</p>
</dd>
<dt><code>summary</code></dt><dd><p>A summary of the the grains of connectivity generated and
their properties.</p>
</dd>
<dt><code>centroids</code></dt><dd><p>A <code>SpatialPoints</code> object indicating the grain's polygon
centroids.</p>
</dd>
<dt><code>th</code></dt><dd><p>A list of <code>igraph</code> objects giving the graphs describing the relationship
among the polygons in that grain
</p>
<p>See <code><a href="#topic+grain">grain()</a></code> for more information.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alex Chubaty and Paul Galpern
</p>

<hr>
<h2 id='grainscape-maps'>Test maps included with <code>grainscape</code></h2><span id='topic+grainscape-maps'></span>

<h3>Description</h3>

<p>Intended for users to explore the functionality of the package using simple
and artificial land cover maps.
These maps have four or five discrete land cover classes (integers from 1 to 5)
intended to represent distinct land cover types.
Typical analyses begin by reclassifying these to reflect resistance to movement.
</p>


<h3>Format</h3>

<p>raster
</p>


<h3>Details</h3>


<dl>
<dt><code>patchy.asc</code></dt><dd><p>A caricatured map of four land cover classes, where
patches are large and easy to identify polygonal regions for heuristic purposes.
This unrealistic map can be used to illustrate the method and understand how it works.
The map also serves a similar heuristic purpose in a review of graph-based
connectivity methods (Galpern <em>et al.</em>, 2011). (400 x 400 raster cells.)</p>
</dd>
<dt><code>fragmented.asc</code></dt><dd><p>A simulated land cover map with five land cover
classes using an algorithm that produces fragmentation. (400 x 400 raster cells.)</p>
</dd>
<dt><code>tiny.asc</code></dt><dd><p>Similar to <code>fragmented.asc</code> but smaller in extent
for lightning-fast computation and experimental use. (100 x 100 raster cells.)</p>
</dd>
</dl>


<hr>
<h2 id='graphdf'>Produce a <code>data.frame</code> containing the structure and associated attributes</h2><span id='topic+graphdf'></span><span id='topic+graphdf+2Clist-method'></span><span id='topic+graphdf+2Cgoc-method'></span><span id='topic+graphdf+2Cgrain-method'></span><span id='topic+graphdf+2Cmpg-method'></span><span id='topic+graphdf+2Cigraph-method'></span>

<h3>Description</h3>

<p>Produce a <code>data.frame</code> containing the node (vertex) and link (edge)
structure as well as the associated attributes for these.
This provides an easy way to create data tables describing graphs, particularly
helpful for users unfamiliar with the structure of <code>igraph</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphdf(x, ...)

## S4 method for signature 'list'
graphdf(x, ...)

## S4 method for signature 'goc'
graphdf(x, ...)

## S4 method for signature 'grain'
graphdf(x, ...)

## S4 method for signature 'mpg'
graphdf(x, ...)

## S4 method for signature 'igraph'
graphdf(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graphdf_+3A_x">x</code></td>
<td>
<p>A <code>goc</code>, <code>mpg</code>, <code>igraph</code>, or <code>list</code> object.</p>
</td></tr>
<tr><td><code id="graphdf_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing:
</p>

<dl>
<dt><code>v</code></dt><dd><p>node (vertex) names and associated attributes;</p>
</dd>
<dt><code>e</code></dt><dd><p>link (edge) lists and associated attributes.</p>
</dd>
</dl>

<p>Please see <code><a href="#topic+MPG">MPG()</a></code> and <code><a href="#topic+GOC">GOC()</a></code> for details about the attributes.
</p>
<p>For <code><a href="#topic+GOC">GOC()</a></code> objects which typically contain multiple thresholds,
an enumerated list of the same length as the number of thresholds is returned
each containing <code>v</code> and <code>e</code> elements.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>, <code><a href="#topic+GOC">GOC()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Create a data.frame with the structure and attributes of a MPG object
tinyPatchMPG_df &lt;- graphdf(tinyPatchMPG) # nolint

## Create a data.frame with the structure and attributes of a GOC object
tinyPatchGOC_df &lt;- graphdf(tinyPatchGOC) # nolint

## Create a data.frame with the structure and attributes of any igraph object
graphdf(tinyPatchGOC@th[[1]]$goc)
</code></pre>

<hr>
<h2 id='gsGOC'>Deprecated functions</h2><span id='topic+gsGOC'></span><span id='topic+gsGOCCorridor'></span><span id='topic+gsGOCDistance'></span><span id='topic+gsGOCPoint'></span><span id='topic+gsGOCVisualize'></span><span id='topic+visualize'></span><span id='topic+gsGraphDataFrame'></span><span id='topic+gsMPG'></span>

<h3>Description</h3>

<p>These have been deprecated and will be removed in a future release.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsGOC(
  mpg,
  nThresh = NULL,
  doThresh = NULL,
  weight = "lcpPerimWeight",
  sp = FALSE,
  verbose = 3
)

gsGOCCorridor(GOC, whichThresh, coords, doPlot = FALSE, weight = "meanWeight")

gsGOCDistance(GOC, coords, weight = "meanWeight")

gsGOCPoint(GOC, coords)

gsGOCVisualize(GOC, whichThresh, sp = FALSE, doPlot = FALSE)

visualize(GOC, whichThresh, sp = FALSE, doPlot = FALSE)

gsGraphDataFrame(x)

gsMPG(cost, patch, sa = NULL, filterPatch = NULL, spreadFactor = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsGOC_+3A_mpg">mpg</code></td>
<td>
<p>A <code>mpg</code> object.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_nthresh">nThresh</code></td>
<td>
<p>Optional. An integer giving the number of thresholds (or scales)
at which to create GOC models. Thresholds are selected to produce
a maximum number of unique grains (i.e., models).
<code>nThresh</code> thresholds are also approximately evenly spread
between 0 and the threshold at which all patches or focal points
on the landscape are connected. This is a simple way to get
a representative subset of all possible GOC models.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_dothresh">doThresh</code></td>
<td>
<p>Optional. A vector giving the link thresholds at which to create GOC models.
Use <code><a href="#topic+threshold">threshold()</a></code> to identify thresholds of interest.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_weight">weight</code></td>
<td>
<p>A string giving the link weight or attribute to use for threshold.
<code>"lcpPerimWeight"</code> uses the accumulated resistance or least-cost
path distance from the perimeters of patches as the link weight.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_sp">sp</code></td>
<td>
<p>Logical. If <code>TRUE</code> the <code>sp</code> package is used to create
a vector of class <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame()</a></code> describing
the finest grain of connectivity.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_verbose">verbose</code></td>
<td>
<p>Set <code>verbose=0</code> for no progress information to console.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_goc">GOC</code></td>
<td>
<p>A <code>goc</code> object.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_whichthresh">whichThresh</code></td>
<td>
<p>Integer giving the index of the threshold to visualize.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_coords">coords</code></td>
<td>
<p>A two column matrix or a <code><a href="sp.html#topic+SpatialPoints">SpatialPoints()</a></code> object
giving coordinates at the end points of the corridor.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_doplot">doPlot</code></td>
<td>
<p>Logical. If <code>TRUE</code> plots a vector visualization of the
corridor at the given scale</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_x">x</code></td>
<td>
<p>A <code>mpg</code> object produced by <code><a href="#topic+MPG">MPG()</a></code>.
For lattice GOC <code>MPG</code> must be run with patch set as an integer value.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_cost">cost</code></td>
<td>
<p>A <code>RasterLayer</code> giving a landscape resistance surface,
where the values of each raster cell are proportional to the
resistance to movement, dispersal, or gene flow for an organism
in the landscape feature they represent.
Missing values <code>NA</code> are acceptable (but see below).
Negative values are not.
To extract an MPG with Euclidean links (i.e., and not least-cost
path links) set <code>cost[] &lt;- 1</code>.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_patch">patch</code></td>
<td>
<p>A raster of class <code>RasterLayer</code> for a patch-based analysis
OR an integer for a lattice analysis.
If a raster is given it must be of the same extent, origin and
projection as <code>cost</code> and be binary, without missing values,
where patches=1 and non-patches=0.
For lattice analyses, an integer gives the spacing in raster
cells between focal points in the lattice.</p>
</td></tr>
<tr><td><code id="gsGOC_+3A_filterpatch">filterPatch</code>, <code id="gsGOC_+3A_sa">sa</code>, <code id="gsGOC_+3A_spreadfactor">spreadFactor</code></td>
<td>
<p>No longer used.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>the <code>sp</code> argument has also been deprecated from all functions.
</p>

<hr>
<h2 id='gsMPGstitch'><code>grainscape</code>: Defunct</h2><span id='topic+gsMPGstitch'></span>

<h3>Description</h3>

<p>These functions have removed from <code>grainscape</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsMPGstitch(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsMPGstitch_+3A_...">...</code></td>
<td>
<p>Any arguments passed to defunct functions.</p>
</td></tr>
</table>

<hr>
<h2 id='hce-class'>The <code>hce</code> class</h2><span id='topic+hce-class'></span>

<h3>Description</h3>

<p>Used internally.
</p>


<h3>Slots</h3>


<dl>
<dt><code>voronoi</code></dt><dd><p>The Voronoi tessellation of the patches and resistance
surface (<code>RasterLayer</code>).</p>
</dd>
<dt><code>patchLinks</code></dt><dd><p>A <code>RasterLayer</code> whose values indicate patch ids
(positive integers) and link ids (negative integers).</p>
</dd>
<dt><code>linkData</code></dt><dd><p>A <code>data.frame</code> of link attributes.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alex Chubaty and Sam Doctolero
</p>

<hr>
<h2 id='MPG'>Extract a minimum planar graph (MPG) model from a landscape resistance surface</h2><span id='topic+MPG'></span><span id='topic+MPG+2CRasterLayer+2CRasterLayer-method'></span><span id='topic+MPG+2CRasterLayer+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Extracts a minimum planar graph (MPG) and is also the first step
in grains of connectivity (GOC) modelling.
Both patch-based and lattice MPGs can be extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MPG(cost, patch, ...)

## S4 method for signature 'RasterLayer,RasterLayer'
MPG(cost, patch, ...)

## S4 method for signature 'RasterLayer,numeric'
MPG(cost, patch, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MPG_+3A_cost">cost</code></td>
<td>
<p>A <code>RasterLayer</code> giving a landscape resistance surface,
where the values of each raster cell are proportional to the
resistance to movement, dispersal, or gene flow for an organism
in the landscape feature they represent.
Missing values <code>NA</code> are acceptable (but see below).
Negative values are not.
To extract an MPG with Euclidean links (i.e., and not least-cost
path links) set <code>cost[] &lt;- 1</code>.</p>
</td></tr>
<tr><td><code id="MPG_+3A_patch">patch</code></td>
<td>
<p>A raster of class <code>RasterLayer</code> for a patch-based analysis
OR an integer for a lattice analysis.
If a raster is given it must be of the same extent, origin and
projection as <code>cost</code> and be binary, without missing values,
where patches=1 and non-patches=0.
For lattice analyses, an integer gives the spacing in raster
cells between focal points in the lattice.</p>
</td></tr>
<tr><td><code id="MPG_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to create a minimum planar graph (MPG) that can be
further analyzed using <code><a href="igraph.html#topic+igraph">igraph()</a></code> routines.
It is also the first step in grains of connectivity (GOC) modelling.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+mpg-class">mpg()</a></code> object.
</p>


<h3>Note</h3>

<p>Researchers should consider whether the use of a patch-based MPG or a lattice
MPG model is appropriate based on the patch-dependency of the organism under study.
Patch-based models make most sense when animals are restricted to, or dependent on,
a resource patch. Lattice models can be used as a generalized and functional
approach to scaling resistance surfaces.
</p>
<p>Rasters should be projected and not in geographic coordinates (i.e. <code>projection(cost)</code>
should not contain <code>"+proj=longlat"</code>) or the function will issue a warning.
In unprojected cases consider using <code><a href="raster.html#topic+projectRaster">projectRaster()</a></code> to change to an appropriate
coordinate system for the location and extent of interest that balances both distance and areal
accuracy. See <a href="https://www.spatialreference.org/">https://www.spatialreference.org/</a> for location-specific suggestions.
Use of geographic coordinates will result in inaccurate areal and distance measurements,
rendering the models themselves inaccurate.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern, Sam Doctolero, Alex Chubaty
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code style="white-space: pre;">&#8288;[GOC], [threshold]&#8288;</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Explore the graph structure and node/link attributes
graphdf(tinyPatchMPG)

## Find the mean patch area (see igraph manual for use of V() and E())
mean(igraph::V(tinyPatchMPG@mpg)$patchArea)

## Quick visualization of the MPG
if (interactive())
  plot(tinyPatchMPG, col = c("grey", "black"), legend = FALSE)

## Additional graph extraction scenarios
## Produce a lattice MPG where focal points are spaced 10 cells apart
tinyLatticeMPG &lt;- MPG(cost = tinyCost, patch = 10)
if (interactive())
  plot(tinyLatticeMPG)
</code></pre>

<hr>
<h2 id='mpg-class'>The <code>mpg</code> class</h2><span id='topic+mpg-class'></span>

<h3>Description</h3>

<p>The <code>mpg</code> class
</p>


<h3>Slots</h3>


<dl>
<dt><code>mpg</code></dt><dd><p>The minimum planar graph as class <code>igraph</code>.</p>
</dd>
<dt><code>patchId</code></dt><dd><p>The input <code>patch</code> raster with patch cells assigned to
their id (<code>RasterLayer</code>).</p>
</dd>
<dt><code>voronoi</code></dt><dd><p>The Voronoi tessellation of the patches and resistance
surface (<code>RasterLayer</code>).</p>
</dd>
<dt><code>lcpPerimWeight</code></dt><dd><p>The paths of the links between patches and their
accumulated costs (<code>RasterLayer</code>).</p>
</dd>
<dt><code>lcpLinkId</code></dt><dd><p>The paths of the links between patches and their id (<code>RasterLayer</code>).</p>
</dd>
<dt><code>mpgPlot</code></dt><dd><p>A <code>RasterLayer</code> version of the <code>mpg</code>, which can be
easily plotted to visualize the MPG.
</p>
<p>The <code>mpg</code> slot contains useful vertex and edge attributes.
Vertex attributes give attributes of patches including patch area,
the area of patch edges, the core area of each patch, and the coordinates
of the patch centroid.
All areal measurements are given as raster cell counts.
Edge attributes give attributes of the graph links including link
weights giving accumulated resistance/least-cost path distance,
Euclidean distance, and the start and end coordinates of each link.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Alex Chubaty and Paul Galpern
</p>

<hr>
<h2 id='patchFilter'>Filter out patches smaller than a specified area</h2><span id='topic+patchFilter'></span><span id='topic+patchFilter+2CRasterLayer-method'></span>

<h3>Description</h3>

<p>Pre-process patch rasters prior to their use with <code><a href="#topic+MPG">MPG()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patchFilter(x, cells = NULL, area = NULL, ...)

## S4 method for signature 'RasterLayer'
patchFilter(x, cells = NULL, area = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patchFilter_+3A_x">x</code></td>
<td>
<p>A binary raster (i.e. consisting of <code>0</code>, <code>1</code>,
or <code>NA</code> cells), where cells <code style="white-space: pre;">&#8288;=1&#8288;</code> represent
patches</p>
</td></tr>
<tr><td><code id="patchFilter_+3A_cells">cells</code></td>
<td>
<p>The minimum number of cells that constitute a patch.
Default <code>NULL</code>. Only one of <code>cells</code> or
<code>area</code> may be specified.</p>
</td></tr>
<tr><td><code id="patchFilter_+3A_area">area</code></td>
<td>
<p>The minimum area that constitutes a patch (where area is
calculated in the coordinate reference system of the
raster by multiplying the count of cells in patch by the x
and y resolution of a raster cell). Default <code>NULL</code>.
Only one of <code>cells</code> or <code>area</code> may be specified.</p>
</td></tr>
<tr><td><code id="patchFilter_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code><a href="raster.html#topic+clump">clump()</a></code>
function in the <code>raster</code> package. For example
<code>directions = 4</code> may be used to be more conservative
about which cells constitute a patch.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It examines a binary raster to identify all patches or clumps of cells with
values <code style="white-space: pre;">&#8288;=1&#8288;</code>, determines their area, and returns a binary raster where
only patches of area greater than or equal to the specified amount are represented.
</p>
<p>This is helpful when analyzing habitat connectivity models where patches
represent a land cover or habitat type.
For example, a raster may have patches of a certain habitat type of insufficient
area to support the ecological process of interest.
Another use case is remote sensing classification errors that have introduced artifacts.
Filtering can help in both cases.
</p>


<h3>Value</h3>

<p>A binary raster where all patches (i.e. clumped areas <code style="white-space: pre;">&#8288;=1&#8288;</code>)
are greater than the specified area.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features = 10
## and all patches are greater than or equal to 2 cells in size
filteredPatch &lt;- patchFilter(tinyCost == 10, cells = 2)
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = filteredPatch)
if (interactive()) plot(tinyPatchMPG)

## Compare to removal of patches greater than or equal to 40 cells in size!
filteredPatch &lt;- patchFilter(tinyCost == 10, cells = 40)
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = filteredPatch)
if (interactive()) plot(tinyPatchMPG)

## Use a rook/castle 4-direction case rather than the queen 8-direction case
## to identify neighbouring cells in a patch
filteredPatch &lt;- patchFilter(tinyCost == 10, cells = 40, directions = 4)
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = filteredPatch)
if (interactive()) plot(tinyPatchMPG)
</code></pre>

<hr>
<h2 id='plot+2Ccorridor+2CANY-method'>Plot quick visualizations of <code>grainscape</code> objects</h2><span id='topic+plot+2Ccorridor+2CANY-method'></span><span id='topic+plot+2Cgrain+2CANY-method'></span><span id='topic+plot+2Cmpg+2CANY-method'></span>

<h3>Description</h3>

<p>Plot quick visualizations of <code>mpg</code>, <code>grain</code>, and <code>corridor</code>
objects.
</p>
<p>This function is intended to get a quick look at the state of a <code>grainscape</code>
object by rendering what are likely to be the most universally useful
visualizations of the spatial data within these objects.
</p>
<p>Much more control is available using <code><a href="#topic+ggGS">ggGS()</a></code> with <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>
enabling the layering of different different analytical products, and the
visualization of node and link attributes.
</p>
<p>For high-resolution visualization and the greatest level of control use
<code><a href="#topic+export">export()</a></code> to export spatial objects for cartographic representation
in a geographic information system (GIS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'corridor,ANY'
plot(x, y, quick = NULL, print = TRUE, theme = TRUE, ...)

## S4 method for signature 'grain,ANY'
plot(x, y, quick = NULL, print = TRUE, theme = TRUE, ...)

## S4 method for signature 'mpg,ANY'
plot(x, y, quick = NULL, print = TRUE, theme = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_x">x</code></td>
<td>
<p>A <code>grainscape</code> object (<code>corridor</code>, <code>grain</code>, or <code>mpg</code>).</p>
</td></tr>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_y">y</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_quick">quick</code></td>
<td>
<p>If <code>NULL</code> (the default) it will plot the most useful quick
visualization for the supplied object type. See below for a
description of the available quick plots, and the defaults.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_print">print</code></td>
<td>
<p>Render the <code>ggplot</code> on the default graphics device.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_theme">theme</code></td>
<td>
<p>Apply grainscape theme and scale aesthetics. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2Ccorridor+2B2CANY-method_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
</table>


<h3>Value</h3>

<div class="sourceCode"><pre>   Invisibly, a `ggplot2` object to which additional `ggplot`
           geoms and adjustments can be applied. Has the side effect of
           rendering the plot, unless `print = FALSE`.
</pre></div>


<h3>Types of visualization available with the <code>quick</code> parameter</h3>

<p><code>"mpgPerimPlot"</code> gives a a vector rendering of the minimum planar
graph with vector links connecting the perimeters of the patches. This
doesn't accurately represent the sinuosity of paths of the links between patches
but offers a good approximation that renders better at large extents.
Default for <code>mpg</code> objects. Not available for other objects.
</p>
<p><code>"mpgPlot"</code> gives a raster-only rendering of the minimum planar graph
where <code>patchId</code> are positive integers, and <code>linkId</code> are negative
integers showing the shortest paths between patches  Only available for
<code>mpg</code> objects.
</p>
<p><code>"network"</code> gives a vector rendering of the minimum planar graph or
the grains of connectivity network with nodes and links plotted at the
patch or polygon centroid locations. Available for <code>mpg</code> and <code>grain</code>
objects. Default for <code>grain</code> objects.
</p>
<p><code>"grainPlot"</code> gives a raster and vector rendering of the grains of
connectivity network with nodes and links plotted at polygon centroid locations,
superimposed over the boundaries of the Voronoi polygons.
Can be time consuming on large rasters due to the Voronoi boundary extraction.
Only available for <code>grain</code> objects.
</p>
<p><code>"corridorPlot"</code> renders the output of a <code><a href="#topic+corridor">corridor()</a></code> analysis.
It is the only option available with <code>corridor</code> objects and the default.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty and Paul Galpern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggGS">ggGS()</a></code>,
<code><a href="#topic+export">export()</a></code>,
<a href="#topic+corridor-class">corridor</a>,
<a href="#topic+grain-class">grain</a>,
<a href="#topic+mpg-class">mpg</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
if (interactive()) {
  library(ggplot2)

  ## MPG and showing simplified links among the perimeters of patches
  plot(tinyPatchMPG)

  ## MPG showing links among the nodes of connected patches
  plot(tinyPatchMPG, quick = "network")

  ## MPG showing the shortest paths between patches actually used to
  ## to calculate link weight values
  plot(tinyPatchMPG, quick = "mpgPlot")

  ## A grain of connectivity network plot with Voronoi boundaries
  plot(grain(tinyPatchGOC, 3), quick = "grainPlot")

  ## Capture plot output for further processing with ggplot
  g &lt;- plot(tinyPatchMPG, print = FALSE, theme = FALSE)
  g &lt;- g + theme_minimal() + ggtitle("Minimum planar graph") +
    theme(plot.title = element_text(size = 20, hjust = 0.5)) +
    theme(legend.position = "none") +
    xlab("Easting") + ylab("Northing")
  g

  ## To change aesthetics it is best to build the plot from scratch
  ## using grainscape::ggGS(). See examples therein.
}
</code></pre>

<hr>
<h2 id='point'>Identify the polygons containing locations in grains of connectivity (GOC) tessellations</h2><span id='topic+point'></span><span id='topic+point+2Cgoc-method'></span>

<h3>Description</h3>

<p>Identify the polygon containing a location at multiple scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point(x, ...)

## S4 method for signature 'goc'
point(x, coords, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="point_+3A_x">x</code></td>
<td>
<p>A <code>goc</code> object produced by <code><a href="#topic+GOC">GOC()</a></code>.</p>
</td></tr>
<tr><td><code id="point_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="point_+3A_coords">coords</code></td>
<td>
<p>A two column matrix or a <code><a href="sp.html#topic+SpatialPoints">SpatialPoints()</a></code> object giving
the coordinates of points of interest.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements:
</p>

<dl>
<dt><code>pointPolygon</code></dt><dd><p>a matrix with elements giving the id of the
polygon from the <code>goc</code>, where rows give points of interest and
columns give thresholds;</p>
</dd>
<dt><code>pointTotalPatchArea</code></dt><dd><p>is a matrix with elements giving the area
of patches in a polygon (in cell counts), where rows give points of and
columns give thresholds;</p>
</dd>
<dt><code>pointTotalCoreArea</code></dt><dd><p>the same for core area of patches;</p>
</dd>
<dt><code>pointECS</code></dt><dd><p>gives the patch area (in cell counts) averaged for
all points of interest (defined by O'Brien <em>et al.</em>, 2006);</p>
</dd>
<dt><code>pointECSCore</code></dt><dd><p>is the same for the core area of patches.</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <code><a href="#topic+MPG">MPG()</a></code> for warning related to areal measurements.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>References</h3>

<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>
<p>O'Brien, D., M. Manseau, A. Fall, and M.-J. Fortin. (2006) Testing the importance of
spatial configuration of winter habitat for woodland caribou: An application of graph theory.
Biological Conservation 130:70-83.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GOC">GOC()</a></code>, <code><a href="#topic+distance">distance()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Extract a representative subset of 5 grains of connectivity
tinyPatchGOC &lt;- GOC(tinyPatchMPG, nThresh = 5)
## Three sets of coordinates in the study area
loc &lt;- cbind(c(30, 60, 90), c(30, 60, 90))

## Find the GOC polygon containing these three locations
## for each of the 5 grains of connectivity
tinyPts &lt;- point(tinyPatchGOC, loc)
</code></pre>

<hr>
<h2 id='show+2Cgoc-method'>Show a <code>grainscape</code> object</h2><span id='topic+show+2Cgoc-method'></span><span id='topic+show+2Cgrain-method'></span><span id='topic+show+2Ccorridor-method'></span>

<h3>Description</h3>

<p>Custom <code>show</code> method to safely print the contents of a <code>goc</code> or
<code>grain</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'goc'
show(object)

## S4 method for signature 'grain'
show(object)

## S4 method for signature 'corridor'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show+2B2Cgoc-method_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+goc-class">goc()</a></code> or
<code><a href="#topic+grain-class">grain()</a></code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='theme_grainscape'>A <code>ggplot2</code> theme for <code>grainscape</code></h2><span id='topic+theme_grainscape'></span>

<h3>Description</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot2">ggplot2()</a></code> theme designed for <code>grainscape</code> based on the
<code><a href="ggthemes.html#topic+theme_map">ggthemes::theme_map()</a></code> theme, with several modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_grainscape(base_size = 9, base_family = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_grainscape_+3A_base_size">base_size</code></td>
<td>
<p>Base font size</p>
</td></tr>
<tr><td><code id="theme_grainscape_+3A_base_family">base_family</code></td>
<td>
<p>Base font family</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A theme suitable for use with <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggGS">ggGS()</a></code>, <code><a href="base.html#topic+plot">plot()</a></code>, <code><a href="ggthemes.html#topic+theme_map">ggthemes::theme_map()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
if (interactive()) {
  library(ggplot2)

  ## Plot the patches in a minimum planar graph
  theme_set(theme_grainscape())
  plot(tinyPatchMPG, quick = "mpgPlot")
}
</code></pre>

<hr>
<h2 id='threshold'>Produce a minimum planar graph (MPG) at multiple scales</h2><span id='topic+threshold'></span><span id='topic+threshold+2Cmpg-method'></span>

<h3>Description</h3>

<p>Perform a scalar analysis of a minimum planar graph (MPG) by building the
graph at a series of link thresholds.
As the threshold value increases more nodes in the graph become connected,
forming increasingly fewer components, until the graph becomes connected (e.g., Brooks, 2003).
N.B. Grains of connectivity (GOC) done by <code><a href="#topic+GOC">GOC()</a></code> is also a scalar
analysis using Voronoi tessellations rather than patches (see Galpern <em>et al.</em>, 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threshold(x, ...)

## S4 method for signature 'mpg'
threshold(x, weight = "lcpPerimWeight", nThresh = NULL, doThresh = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threshold_+3A_x">x</code></td>
<td>
<p>A <code>mpg</code> object produced by <code><a href="#topic+MPG">MPG()</a></code>.</p>
</td></tr>
<tr><td><code id="threshold_+3A_...">...</code></td>
<td>
<p>Additional arguments (not used).</p>
</td></tr>
<tr><td><code id="threshold_+3A_weight">weight</code></td>
<td>
<p>A string giving the link weight or attribute to use for threshold.
<code>"lcpPerimWeight"</code> uses the accumulated resistance or least-cost path
distance from the perimeters of patches as the link weight.</p>
</td></tr>
<tr><td><code id="threshold_+3A_nthresh">nThresh</code></td>
<td>
<p>Optional. An integer giving the number of thresholds (or scales)
at which to create GOC models.
Thresholds are selected to produce a maximum number of unique
grains (i.e., models).
<code>nThresh</code> thresholds are also approximately evenly spread
between 0 and the threshold at which all patches or focal points
on the landscape are connected.
This is a simple way to get a representative subset of all
possible GOC models.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
<tr><td><code id="threshold_+3A_dothresh">doThresh</code></td>
<td>
<p>Optional. A vector giving the link thresholds at which to create GOC models.
Use <code><a href="#topic+threshold">threshold()</a></code> to identify thresholds of interest.
Provide either <code>nThresh</code> or <code>doThresh</code> not both.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object with the following elements:
</p>

<dl>
<dt><code>summary</code></dt><dd><p>summarizes the thresholded graphs generated and their properties;</p>
</dd>
<dt><code>th</code></dt><dd><p>a list of length <code>nThresh</code> or <code>length(doThresh)</code>
giving the thresholded graph (class <code>igraph</code>) at each threshold.</p>
</dd>
</dl>



<h3>Note</h3>

<p>See <code><a href="#topic+MPG">MPG()</a></code> for warning related to areal measurements.
</p>


<h3>Author(s)</h3>

<p>Paul Galpern and Alex Chubaty
</p>


<h3>References</h3>

<p>Brooks, C.P. (2003) A scalar analysis of landscape connectivity. Oikos 102:433-439.
</p>
<p>Fall, A., M.-J. Fortin, M. Manseau, D. O'Brien. (2007) Spatial graphs:
Principles and applications for habitat connectivity. Ecosystems 10:448:461.
</p>
<p>Galpern, P., M. Manseau. (2013a) Finding the functional grain: comparing methods
for scaling resistance surfaces. Landscape Ecology 28:1269-1291.
</p>
<p>Galpern, P., M. Manseau. (2013b) Modelling the influence of landscape connectivity
on animal distribution: a functional grain approach. Ecography 36:1004-1016.
</p>
<p>Galpern, P., M. Manseau, A. Fall. (2011) Patch-based graphs of landscape connectivity:
a guide to construction, analysis, and application for conservation.
Biological Conservation 144:44-55.
</p>
<p>Galpern, P., M. Manseau, P.J. Wilson. (2012) Grains of connectivity: analysis
at multiple spatial scales in landscape genetics. Molecular Ecology 21:3996-4009.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MPG">MPG()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load raster landscape
tiny &lt;- raster::raster(system.file("extdata/tiny.asc", package = "grainscape"))

## Create a resistance surface from a raster using an is-becomes reclassification
tinyCost &lt;- raster::reclassify(tiny, rcl = cbind(c(1, 2, 3, 4), c(1, 5, 10, 12)))
## Produce a patch-based MPG where patches are resistance features=1
tinyPatchMPG &lt;- MPG(cost = tinyCost, patch = tinyCost == 1)
## Threshold this graph at a representative subset of 10 thresholds
tinyThresh &lt;- threshold(tinyPatchMPG, nThresh = 10)

## Examine the properties of one of these threshold graphs
print(tinyThresh$th[[7]], vertex = TRUE, edge = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
