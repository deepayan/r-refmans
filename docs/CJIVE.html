<!DOCTYPE html><html><head><title>Help for package CJIVE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CJIVE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdjSigVarExp'><p>Adjust Signal Variation Explained</p></a></li>
<li><a href='#cc.jive'><p>Canonical (Correlation) JIVE</p></a></li>
<li><a href='#cc.jive.pred'><p>CJIVE joint subject score prediction</p></a></li>
<li><a href='#chord.norm.diff'><p>Chordal norm between column-subspaces of two matrices</p></a></li>
<li><a href='#ConvSims_gg'><p>Convert simulation study results</p></a></li>
<li><a href='#create.graph.long'><p>Function for plotting networks with ggplot</p></a></li>
<li><a href='#GenerateToyData'><p>Generate 'Toy' Data</p></a></li>
<li><a href='#GetSimResults_Dir'><p>Retrieve simulation results</p></a></li>
<li><a href='#gg.corr.plot'><p>Function for plotting Pearson correlations between predicted and true subject scores within the simulation study described in CJIVE manuscript</p></a></li>
<li><a href='#gg.load.norm.plot'><p>Function for plotting chordal norms between estimated and true variable loading subspaces within the simulation study described in CJIVE manuscript</p></a></li>
<li><a href='#gg.norm.plot'><p>Function for plotting chordal norms between estimated and true subspaces within the simulation study described in CJIVE manuscript</p></a></li>
<li><a href='#gg.rank.plot'><p>Function for plotting selected joint ranks</p></a></li>
<li><a href='#gg.score.norm.plot'><p>Function for plotting chordal norms between estimated and true subject score subspaces within the simulation study described in CJIVE manuscript</p></a></li>
<li><a href='#MatVar'><p>Matrix variation (i.e. Frobenius norm)</p></a></li>
<li><a href='#MatVar2'><p>Alternative calculation - Matrix variation (i.e. Frobenius norm)</p></a></li>
<li><a href='#Melt.Sim.Cors'><p>Converts correlations of predicted to true joint subject scores to a format conducive to ggplot2</p></a></li>
<li><a href='#perm.jntrank'><p>Permutation Test for Joint Rank in CJIVE</p></a></li>
<li><a href='#scale_loadings'><p>Scale and sign-correct variable loadings to assist interpretation</p></a></li>
<li><a href='#show.image.2'><p>Display a heatmap of a matrix (adapted from Erick Lock's show.image function in the r.jive package)</p></a></li>
<li><a href='#sjive'><p>Simple JIVE</p></a></li>
<li><a href='#vec2net.l'><p>Convert vector to network</p></a></li>
<li><a href='#vec2net.u'><p>Convert vector to network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Canonical Joint and Individual Variation Explained (CJIVE)</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Raphiel Murden &lt;rmurden@emory.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Joint and Individual Variation Explained (JIVE) is a method for decomposing multiple datasets obtained on the same subjects into
		shared structure, structure unique to each dataset, and noise. The two most common implementations are R.JIVE, an iterative
		approach, and AJIVE, which uses principal angle analysis. JIVE estimates subspaces but interpreting these subspaces can be
		challenging with AJIVE or R.JIVE. We expand upon insights into AJIVE as a canonical correlation analysis (CCA) of principal component
		scores. This reformulation, which we call CJIVE, 1) provides an ordering of joint components by the degree of correlation between
		corresponding canonical variables; 2) uses a computationally efficient permutation test for the number of joint components, which
		provides a p-value for each component; and 3) can be used to predict subject scores for out-of-sample observations.
		Please cite the following article when utilizing this package: 
		Murden, R., Zhang, Z., Guo, Y., &amp; Risk, B. (2022) &lt;<a href="https://doi.org/10.3389%2Ffnins.2022.969510">doi:10.3389/fnins.2022.969510</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>rootSolve, ggplot2, reshape2, fields, gplots, psych</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-18 18:03:19 UTC; RMURDEN</td>
</tr>
<tr>
<td>Author:</td>
<td>Raphiel Murden <a href="https://orcid.org/0000-0002-6396-9105"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Benjamin Risk [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-20 10:10:13 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdjSigVarExp'>Adjust Signal Variation Explained</h2><span id='topic+AdjSigVarExp'></span>

<h3>Description</h3>

<p>Adjusts the proportion of total variation attributable to each signal component to predetermined values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdjSigVarExp(J, I, N, JntVarEx, IndVarEx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdjSigVarExp_+3A_j">J</code></td>
<td>
<p>joint signal matrix of size n-by-p</p>
</td></tr>
<tr><td><code id="AdjSigVarExp_+3A_i">I</code></td>
<td>
<p>individual signal matrix of size n-by-p</p>
</td></tr>
<tr><td><code id="AdjSigVarExp_+3A_n">N</code></td>
<td>
<p>noise/error matrix of size n-by-p</p>
</td></tr>
<tr><td><code id="AdjSigVarExp_+3A_jntvarex">JntVarEx</code></td>
<td>
<p>desired proportion of total variation explained by the joint signal</p>
</td></tr>
<tr><td><code id="AdjSigVarExp_+3A_indvarex">IndVarEx</code></td>
<td>
<p>desired proportion of total variation explained by the individual signal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of 3 items: 1) adjusted joint signal matrix; 2) adjusted individual signal matrix; 3) data matrix additively comprised of the adjusted signal matrices
</p>

<hr>
<h2 id='cc.jive'>Canonical (Correlation) JIVE</h2><span id='topic+cc.jive'></span>

<h3>Description</h3>

<p>Performs Canonical JIVE as described in the CJVE manuscript. This method is equivalent to AJIVE for 2 data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc.jive(
  dat.blocks,
  signal.ranks = NULL,
  joint.rank = 1,
  perc.var = 0.95,
  perm.test = TRUE,
  center = FALSE,
  nperms = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc.jive_+3A_dat.blocks">dat.blocks</code></td>
<td>
<p>a list of two matrices with samples along rows and features along columns, which contain data on the same n individuals/sampling units</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_signal.ranks">signal.ranks</code></td>
<td>
<p>a vector of length two which contains the rank for the signal within each data block. The rank corresponds to the number of principal
components (PCs) to be retained within each data block. If NULL, the ranks are determined by the parameter 'perc.var.' Default is NULL</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_joint.rank">joint.rank</code></td>
<td>
<p>The rank of the joint subspace i.e., number of components in the joint subspace</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_perc.var">perc.var</code></td>
<td>
<p>an alternative to signal.ranks that allows specification of ranks based on the desired proportion of total variation to be retained. F
For perc.var = p (where 0&lt;p&lt;1), rank is determined as the minimum number of eigenvalues whose cumulative sum is at least p*(total sum of eigenvalues)
Default is 0.95 (i.e. 95% of total variation preserved for each data block).</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_perm.test">perm.test</code></td>
<td>
<p>logical (TRUE/FALSE) of whether permutation test for joint rank should be performed. Overrides 'joint.rank' parameter if TRUE. Default is TRUE</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_center">center</code></td>
<td>
<p>logical (TRUE/FALSE) indicating whether data should be column-centered prior to testing. Default is TRUE</p>
</td></tr>
<tr><td><code id="cc.jive_+3A_nperms">nperms</code></td>
<td>
<p>integer value indicating the number of permutations that should be performed. Default is 1000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two lists:
1) 'CanCorRes' contains results from the canonical correlation of PC scores including, the joint rank, joint subject sores,
canonical correlations (and their respective p-values if perm.test was used), canonical loadings for the joint subspace, and total signal ranks
2) 'sJIVE', i.e. Simple JIVE results, correspond to the AJIVE when all ranks are known; includes the joint and individual signal matrices, concatenated PC scores,
and the projection matrix used to project each data block onto the joint subspace
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Assign sample size and the number of features in each dataset
n = 200 #sample size
p1 = 100 #Number of features in data set X1
p2 = 100 #Number of features in data set X2

# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2


# Simulate data sets
ToyDat = GenerateToyData(n = 200, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
                          IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
                          ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
                          print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks &lt;- ToyDat$'Data Blocks'

# Save Subject scores as R objects
JntScores = ToyDat[['Scores']][['Joint']]
IndivScore.X = ToyDat[['Scores']][["Indiv_1"]]
IndivScore.Y = ToyDat[['Scores']][["Indiv_2"]]

# Save joint variable loadings as R objects
JntLd.X = t(ToyDat$Loadings$Joint_1)
JntLd.Y = t(ToyDat$Loadings$Joint_2)

# Save individual variable loadings as R objects
IndivLd.X =t(ToyDat$Loadings$Indiv_1)
IndivLd.Y = t(ToyDat$Loadings$Indiv_2)

# Save joint, individual, and noise signal matrices as R objects
JX = ToyDat[[1]]$J1
JY = ToyDat[[1]]$J2
IX = ToyDat[[1]]$I1
IY = ToyDat[[1]]$I2
EX = ToyDat[[1]]$E1
EY = ToyDat[[1]]$E2


## Check that proportions of variation explained are (approximately) equal to intended values
JVE.X = MatVar(JX)/MatVar(blocks[[1]])
JVE.Y = MatVar(JY)/MatVar(blocks[[2]])

IVE.X = MatVar(IX)/MatVar(blocks[[1]])
IVE.Y = MatVar(IY)/MatVar(blocks[[2]])

TotVE.X = MatVar((JX + IX))/MatVar(blocks[[1]])
TotVE.Y = MatVar((JY + IY))/MatVar(blocks[[2]])


CJIVE.res = cc.jive(blocks, c(r.I1,r.I2)+r.J, r.J, perm.test = FALSE)
# CJIVE signal matrix estimates
J.hat = CJIVE.res$sJIVE$joint_matrices
I.hat = CJIVE.res$sJIVE$indiv_matrices

# CJIVE loading estimates
WJ = lapply(J.hat, function(x) x[['v']])
WI = lapply(I.hat, function(x) x[['v']])

# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal norm
layout(matrix(1:6,2, byrow = TRUE))
plot(JntScores, CJIVE.res$CanCorRes$Jnt_Scores, xlab = "True Joint Scores",
    ylab = "CJIVE Joint Scores",
    sub = paste0("Chordal Norm = ",
                 round(chord.norm.diff(JntScores, CJIVE.res$CanCorRes$Jnt_Scores), 3)))
plot(JntLd.X, WJ[[1]][,1], xlab = "True Joint Loadings X", ylab = "CJIVE Joint Loadings X",
    sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.X, WJ[[1]][,1]), 3)))
plot(JntLd.Y, WJ[[2]][,1], xlab = "True Joint Loadings Y", ylab = "CJIVE Joint Loadings Y",
    sub = paste0("Chordal Norm = ", round(chord.norm.diff(JntLd.Y, WJ[[2]][,1]), 3)))
plot.new(); legend("left", paste("Comp.", 1:2), pch = 1, col  = c("orange", "green"),bty = "n" )
plot(IndivLd.X, WI[[1]][,1:2], xlab = "True Individual Loadings X",
    ylab = "CJIVE Individual Loadings X",
    col = c(rep("orange",p1), rep("green",p2)),
    sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.X, WI[[1]][,1:2]), 3)))
plot(IndivLd.Y, WI[[2]][,1:2], xlab = "True Individual Loadings Y",
    ylab = "CJIVE Individual Loadings Y",
    col = c(rep("orange",p1), rep("green",p2)),
    sub = paste0("Chordal Norm = ", round(chord.norm.diff(IndivLd.Y, WI[[2]][,1:2]), 3)))
layout(1)

</code></pre>

<hr>
<h2 id='cc.jive.pred'>CJIVE joint subject score prediction</h2><span id='topic+cc.jive.pred'></span>

<h3>Description</h3>

<p>Predicts joint scores for new subjects based on CJIVE joint scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc.jive.pred(
  orig.dat.blocks,
  new.subjs,
  signal.ranks,
  cc.jive.loadings,
  can.cors
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc.jive.pred_+3A_orig.dat.blocks">orig.dat.blocks</code></td>
<td>
<p>list of the two data matrices on which CJIVE was initially conducted</p>
</td></tr>
<tr><td><code id="cc.jive.pred_+3A_new.subjs">new.subjs</code></td>
<td>
<p>list of two data matrices containing information on new subjects</p>
</td></tr>
<tr><td><code id="cc.jive.pred_+3A_signal.ranks">signal.ranks</code></td>
<td>
<p>a vector of length two which contains the rank for the signal within each data block. The rank corresponds to the number of principal
components (PCs) to be retained within each data block. If NULL, the ranks are determined by the parameter 'perc.var.' Default is NULL</p>
</td></tr>
<tr><td><code id="cc.jive.pred_+3A_cc.jive.loadings">cc.jive.loadings</code></td>
<td>
<p>canonical loadings for the joint subspace</p>
</td></tr>
<tr><td><code id="cc.jive.pred_+3A_can.cors">can.cors</code></td>
<td>
<p>canonical correlations from the PCs of the data on which CJIVE was initially conducted - notated as rho_j in CJIVE manuscript</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of joint subject score for new subjects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 200 #sample size
p1 = 100 #Number of features in data set X1
p2 = 100 #Number of features in data set X2
# Assign values of joint and individual signal ranks
r.J = 1 #joint rank
r.I1 = 2 #individual rank for data set X1
r.I2 = 2 #individual rank for data set X2
true_signal_ranks = r.J + c(r.I1,r.I2)
# Simulate data sets
ToyDat = GenerateToyData(n = n, p1 = p1, p2 = p2, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
                          IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = r.J, equal.eig = FALSE,
                          ind_rank1 = r.I1, ind_rank2 = r.I2, SVD.plots = TRUE, Error = TRUE,
                          print.cor = TRUE)
# Store simulated data sets in an object called 'blocks'
blocks &lt;- ToyDat$'Data Blocks'
# Split data randomly into two subsamples
rnd.smp = sample(n, n/2)
blocks.sub1 = lapply(blocks, function(x){x[rnd.smp,]})
blocks.sub2 = lapply(blocks, function(x){x[-rnd.smp,]})
# Joint scores for the two sub samples
JntScores.1 = ToyDat[['Scores']][['Joint']][rnd.smp]
JntScores.2 = ToyDat[['Scores']][['Joint']][-rnd.smp]
# Conduct CJIVE analysis on the first sub-sample and store the canonical loadings and canonical
# correlations
cc.jive.res_sub1 = cc.jive(blocks.sub1, signal.ranks = r.J+c(r.I1,r.I2), center = FALSE,
                           perm.test = FALSE, joint.rank = r.J)
cc.ldgs1 = cc.jive.res_sub1$CanCorRes$Loadings
can.cors = cc.jive.res_sub1$CanCorRes$Canonical_Correlations[1:r.J]
# Conduct CJIVE analysis on the second sub-sample. We will predict these joint scores using the
# results above
cc.jive.res_sub2 = cc.jive(blocks.sub2, signal.ranks = true_signal_ranks, center = FALSE,
                          perm.test = FALSE, joint.rank = r.J)
cc.jnt.scores.sub2 = cc.jive.res_sub2$CanCorRes$Jnt_Scores
cc.pred.jnt.scores.sub2 = cc.jive.pred(blocks.sub1, new.subjs = blocks.sub2,
                                      signal.ranks = true_signal_ranks,
                                      cc.jive.loadings = cc.ldgs1, can.cors = can.cors)
# Calculate the Pearson correlation coefficient between predicted and calculated joint scores
# for sub-sample 2
cc.pred.cor = diag(cor(cc.pred.jnt.scores.sub2, cc.jnt.scores.sub2))
print(cc.pred.cor)
# Plots of CJIVE estimates against true counterparts and include an estimate of their chordal
# norm
layout(matrix(1:2, ncol = 2))
plot(JntScores.2, cc.pred.jnt.scores.sub2, ylab = "Predicted Joint Scores",
    xlab = "True Joint Scores",
    col = rep(1:r.J, each = n/2),
    main = paste("Chordal Norm = ",
    round(chord.norm.diff(JntScores.2, cc.pred.jnt.scores.sub2),2)))
legend("topleft", legend = paste("Component", 1:r.J), col = 1:r.J, pch = 1)
plot(cc.jnt.scores.sub2, cc.pred.jnt.scores.sub2, ylab = "Predicted Joint Scores",
   xlab = "Estimated Joint Scores",
    col = rep(1:r.J, each = n/2),
    main = paste("Chordal Norm = ",
                  round(chord.norm.diff(cc.jnt.scores.sub2, cc.pred.jnt.scores.sub2),2)))
layout(1)

</code></pre>

<hr>
<h2 id='chord.norm.diff'>Chordal norm between column-subspaces of two matrices</h2><span id='topic+chord.norm.diff'></span>

<h3>Description</h3>

<p>Calculates the chordal norm between the column subspaces of two matrices. Matrices must have the same number of rows. Let U_x and U_y represent the singular
vectors of matrices X and Y, respectively. The chordal norm can be calculated as the square root of the sum of the singular values of t(U_x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chord.norm.diff(X, Y, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chord.norm.diff_+3A_x">X</code></td>
<td>
<p>a matrix with the same number of rows as Y and any number of columns</p>
</td></tr>
<tr><td><code id="chord.norm.diff_+3A_y">Y</code></td>
<td>
<p>a matrix with the same number of rows as X and any number of columns</p>
</td></tr>
<tr><td><code id="chord.norm.diff_+3A_tol">tol</code></td>
<td>
<p>threshold under which singular values of inner product are zeroed out</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(Numeric) Chordal norm between column-subspaces of X and Y, scaled to the interval [0,1]
</p>

<hr>
<h2 id='ConvSims_gg'>Convert simulation study results</h2><span id='topic+ConvSims_gg'></span>

<h3>Description</h3>

<p>Convert results from simulation study into a form for graphing with ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ConvSims_gg(AllSims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ConvSims_gg_+3A_allsims">AllSims</code></td>
<td>
<p>matrix with each row representing results from a replicate in the simulation study described in CJIVE manuscript</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 2 items: 1) joint ranks determined by each method employed in the simulations study
2) chordal norms between true and estimated joint/individual loadings/scores for each method employed in the simulation study
</p>

<hr>
<h2 id='create.graph.long'>Function for plotting networks with ggplot</h2><span id='topic+create.graph.long'></span>

<h3>Description</h3>

<p>Convert matrix representation of a network for graphical display via ggplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create.graph.long(gmatrix, sort_indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create.graph.long_+3A_gmatrix">gmatrix</code></td>
<td>
<p>square matrix of size p-by-p in which entries represent the strength of (un-directed) edges between the p nodes</p>
</td></tr>
<tr><td><code id="create.graph.long_+3A_sort_indices">sort_indices</code></td>
<td>
<p>vector of length p by which nodes are sorted. If NULL, then nodes are not sorted. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of three variables: X1, which represents the row from which the edge comes;  X2, which represents the column from which the edge comes;
3) value, matrix entry representing the strength of the edge between the nodes represented by X1 and X2
</p>

<hr>
<h2 id='GenerateToyData'>Generate 'Toy' Data</h2><span id='topic+GenerateToyData'></span>

<h3>Description</h3>

<p>Generates two Simulated Datasets that follow JIVE Model using binary subject scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateToyData(
  n,
  p1,
  p2,
  JntVarEx1,
  JntVarEx2,
  IndVarEx1,
  IndVarEx2,
  jnt_rank = 1,
  equal.eig = FALSE,
  ind_rank1 = 2,
  ind_rank2 = 2,
  SVD.plots = TRUE,
  Error = TRUE,
  print.cor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GenerateToyData_+3A_n">n</code></td>
<td>
<p>integer for sample size, i.e. number of subjects</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_p1">p1</code></td>
<td>
<p>integer for number of features/variables in first data set</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_p2">p2</code></td>
<td>
<p>integer for number of features/variables in second data set</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_jntvarex1">JntVarEx1</code></td>
<td>
<p>numeric between (0,1) which describes proportion of variance in the first data set which is attributable to the joint signal</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_jntvarex2">JntVarEx2</code></td>
<td>
<p>numeric between (0,1) which describes proportion of variance in the second data set which is attributable to the joint signal</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_indvarex1">IndVarEx1</code></td>
<td>
<p>numeric between (0,1) which describes proportion of variance in the first data set which is attributable to the individual signal</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_indvarex2">IndVarEx2</code></td>
<td>
<p>numeric between (0,1) which describes proportion of variance in the second data set which is attributable to the individual signal</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_jnt_rank">jnt_rank</code></td>
<td>
<p>integer for rank of the joint signal, i.e., number of joint components</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_equal.eig">equal.eig</code></td>
<td>
<p>logical (TRUE/FALSE) for whether components should contribute equal variance to signal matrices - default is FALSE</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_ind_rank1">ind_rank1</code></td>
<td>
<p>integer for rank of the individual signal in first data set, i.e., number of joint components</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_ind_rank2">ind_rank2</code></td>
<td>
<p>integer for rank of the individual signal in second data set, i.e., number of joint components</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_svd.plots">SVD.plots</code></td>
<td>
<p>logical (TRUE/FALSE)  for whether plots of singular values from signal should be produced - used to confirm number of components</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_error">Error</code></td>
<td>
<p>logical (TRUE/FALSE)  final data sets should be noise contaminated - default is FALSE; use TRUE to obtain pure signal datasets</p>
</td></tr>
<tr><td><code id="GenerateToyData_+3A_print.cor">print.cor</code></td>
<td>
<p>logical (TRUE/FALSE)  for whether to print matrix of correlations between subject scores)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'list' object which contains 1) list of signal matrices which additively comprise the simulated data sets, i.e. joint, individual,
and error matrices for each data set; 2) list of simulated data sets (each equal to the sum of the matrices in part 1);
3) list of joint subject scores and individual subject scores for each data set, and 4) lsit of joint and individual loadings for each data set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ToyDat = GenerateToyData(n = 200, p1 = 2000, p2 = 1000, JntVarEx1 = 0.05, JntVarEx2 = 0.05,
                           IndVarEx1 = 0.25, IndVarEx2 = 0.25, jnt_rank = 1, equal.eig = FALSE,
                           ind_rank1 = 2, ind_rank2 = 3, SVD.plots = TRUE, Error = TRUE,
                           print.cor = TRUE)
</code></pre>

<hr>
<h2 id='GetSimResults_Dir'>Retrieve simulation results</h2><span id='topic+GetSimResults_Dir'></span>

<h3>Description</h3>

<p>Retrives and compiles results from simulation study which are stored in a directory. A directory should contain separate .csv files (one per replicate),
each of which will include all evaluation metrics and most experimental settings for that particular replicate. For the CJIVE manuscript, a directory houses results of all
100 replicates for each combination of experimental factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetSimResults_Dir(sim.dir, p1, p2, Preds = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetSimResults_Dir_+3A_sim.dir">sim.dir</code></td>
<td>
<p>(character string) file path for the directory from which results will be retrieved</p>
</td></tr>
<tr><td><code id="GetSimResults_Dir_+3A_p1">p1</code></td>
<td>
<p>number of features in data set 1</p>
</td></tr>
<tr><td><code id="GetSimResults_Dir_+3A_p2">p2</code></td>
<td>
<p>number of features in data set 2</p>
</td></tr>
<tr><td><code id="GetSimResults_Dir_+3A_preds">Preds</code></td>
<td>
<p>(logical) do the replicate results contain correlations between predicted and true joint subject scores. Default is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>upper triangular p-by-p matrix
</p>

<hr>
<h2 id='gg.corr.plot'>Function for plotting Pearson correlations between predicted and true subject scores within the simulation study described in CJIVE manuscript</h2><span id='topic+gg.corr.plot'></span>

<h3>Description</h3>

<p>Graphically displays the center and spread of chordal norms for joint/individual subject score subspaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.corr.plot(cor.dat, cols, show.legend = FALSE, text.size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.corr.plot_+3A_cor.dat">cor.dat</code></td>
<td>
<p>data frame with at least the 5 following variables:
Norm - the value of the norm for a particular subspace;
Type - the subspace for which the norm is given (i.e., joint/individual score/loading for dataset X1 or X2 (except for joint scores))
Method - the method by which the subspace was estimated, e.g. CJIVE, AJIVE, R.JIVE
JVE_1 and JVE_2 - labels describing the proportion of joint variation explained in each dataset (and typically the number of variables in dataset X2)</p>
</td></tr>
<tr><td><code id="gg.corr.plot_+3A_cols">cols</code></td>
<td>
<p>a vector of colors, must have length equal to the number of methods used in the simulation</p>
</td></tr>
<tr><td><code id="gg.corr.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical (TRUE/FALSE) for whether a legend should be included in the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg.corr.plot_+3A_text.size">text.size</code></td>
<td>
<p>numeric value for the font size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display (via ggplot2)
</p>

<hr>
<h2 id='gg.load.norm.plot'>Function for plotting chordal norms between estimated and true variable loading subspaces within the simulation study described in CJIVE manuscript</h2><span id='topic+gg.load.norm.plot'></span>

<h3>Description</h3>

<p>Graphically displays the center and spread of chordal norms for joint/individual variable loading subspaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.load.norm.plot(
  norm.dat,
  cols,
  show.legend = FALSE,
  text.size,
  lty = 1,
  y.max = 1,
  x.lab.angle = 70
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.load.norm.plot_+3A_norm.dat">norm.dat</code></td>
<td>
<p>data frame with at least the 5 following variables:
Norm - the value of the norm for a particular subspace;
Type - the subspace for which the norm is given (i.e., joint/individual variable loadings for dataset X1 or X2)
Method - the method by which the subspace was estimated, e.g. CJIVE, AJIVE, R.JIVE
JVE_1 and JVE_2 - labels describing the proportion of joint variation explained in each dataset (and typically the number of variables in dataset X2)</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_cols">cols</code></td>
<td>
<p>a vector of colors, must have length equal to the number of methods used in the simulation</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical (TRUE/FALSE) for whether a legend should be included in the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_text.size">text.size</code></td>
<td>
<p>numeric value for the font size</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_lty">lty</code></td>
<td>
<p>linetype (see ggplot2). Default = 1</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_y.max">y.max</code></td>
<td>
<p>maximum value for the horizontal axis of the plot</p>
</td></tr>
<tr><td><code id="gg.load.norm.plot_+3A_x.lab.angle">x.lab.angle</code></td>
<td>
<p>angle at which x-axis labels are tilted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display (via ggplot2)
</p>

<hr>
<h2 id='gg.norm.plot'>Function for plotting chordal norms between estimated and true subspaces within the simulation study described in CJIVE manuscript</h2><span id='topic+gg.norm.plot'></span>

<h3>Description</h3>

<p>Graphically displays the center and spread of chordal norms for joint/individual score/loading subspaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.norm.plot(
  norm.dat,
  cols,
  show.legend = FALSE,
  text.size,
  lty = 1,
  y.max = 1,
  x.lab.angle = 70
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.norm.plot_+3A_norm.dat">norm.dat</code></td>
<td>
<p>data frame with at least the 5 following variables:
Norm - the value of the norm for a particular subspace;
Type - the subspace for which the norm is given (i.e., joint/individual score/loading for dataset X1 or X2 (except for joint scores))
Method - the method by which the subspace was estimated, e.g. CJIVE, AJIVE, R.JIVE
JVE_1 and JVE_2 - labels describing the proportion of joint variation explained in each dataset (and typically the number of variables in dataset X2)</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_cols">cols</code></td>
<td>
<p>a vector of colors, must have length equal to the number of methods used in the simulation</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical (TRUE/FALSE) for whether a legend should be included in the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_text.size">text.size</code></td>
<td>
<p>numeric value for the font size</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_lty">lty</code></td>
<td>
<p>linetype (see ggplot2). Default = 1</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_y.max">y.max</code></td>
<td>
<p>maximum value for the horizontal axis of the plot</p>
</td></tr>
<tr><td><code id="gg.norm.plot_+3A_x.lab.angle">x.lab.angle</code></td>
<td>
<p>angle at which x-axis labels are tilted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display (via ggplot2)
</p>

<hr>
<h2 id='gg.rank.plot'>Function for plotting selected joint ranks</h2><span id='topic+gg.rank.plot'></span>

<h3>Description</h3>

<p>Graphically displays the count of joint ranks selected by each method employed in the simulation study described in the CJIVE manuscript
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.rank.plot(rank.dat, cols, show.legend = FALSE, text.size, num.sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.rank.plot_+3A_rank.dat">rank.dat</code></td>
<td>
<p>data frame expected to be built with the functions dplyr::count and tidyr::complete, which should include the following variables
Rank - numeric values of the rank selected by each method in each replicate simulation
n - the number of times this value was selected as the rank
Type - the subspace for which the norm is given (i.e., joint/individual score/loading for dataset X1 or X2 (except for joint scores))
Method - the method by which the subspace was estimated, e.g. CJIVE, AJIVE, R.JIVE
JVE_1 and JVE_2 - labels describing the proportion of joint variation explained in each dataset (and typically the number of variables in dataset X2)</p>
</td></tr>
<tr><td><code id="gg.rank.plot_+3A_cols">cols</code></td>
<td>
<p>a vector of colors, must have length equal to the number of methods used in the simulation</p>
</td></tr>
<tr><td><code id="gg.rank.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical (TRUE/FALSE) for whether a legend should be included in the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg.rank.plot_+3A_text.size">text.size</code></td>
<td>
<p>numeric value for the font size</p>
</td></tr>
<tr><td><code id="gg.rank.plot_+3A_num.sims">num.sims</code></td>
<td>
<p>numeric value for the number of replicates evaluated in each full combination of experimental settings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display (via ggplot2)
</p>

<hr>
<h2 id='gg.score.norm.plot'>Function for plotting chordal norms between estimated and true subject score subspaces within the simulation study described in CJIVE manuscript</h2><span id='topic+gg.score.norm.plot'></span>

<h3>Description</h3>

<p>Graphically displays the center and spread of chordal norms for joint/individual subject score subspaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg.score.norm.plot(
  norm.dat,
  cols,
  show.legend = FALSE,
  text.size,
  lty = 1,
  y.max = 1,
  x.lab.angle = 70
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg.score.norm.plot_+3A_norm.dat">norm.dat</code></td>
<td>
<p>data frame with at least the 5 following variables:
Norm - the value of the norm for a particular subspace;
Type - the subspace for which the norm is given (i.e., joint and individual subject scores for dataset X1 or X2 (except joint scores, which are for both datasets))
Method - the method by which the subspace was estimated, e.g. CJIVE, AJIVE, R.JIVE
JVE_1 and JVE_2 - labels describing the proportion of joint variation explained in each dataset (and typically the number of variables in dataset X2)</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_cols">cols</code></td>
<td>
<p>a vector of colors, must have length equal to the number of methods used in the simulation</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_show.legend">show.legend</code></td>
<td>
<p>logical (TRUE/FALSE) for whether a legend should be included in the plot. Default is FALSE</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_text.size">text.size</code></td>
<td>
<p>numeric value for the font size</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_lty">lty</code></td>
<td>
<p>linetype (see ggplot2). Default = 1</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_y.max">y.max</code></td>
<td>
<p>maximum value for the horizontal axis of the plot</p>
</td></tr>
<tr><td><code id="gg.score.norm.plot_+3A_x.lab.angle">x.lab.angle</code></td>
<td>
<p>angle at which x-axis labels are tilted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display (via ggplot2)
</p>

<hr>
<h2 id='MatVar'>Matrix variation (i.e. Frobenius norm)</h2><span id='topic+MatVar'></span>

<h3>Description</h3>

<p>Calculates the Frobenius norm of a matrix, which can be used as a measure of total variation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatVar(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatVar_+3A_x">X</code></td>
<td>
<p>a matrix of any size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Frobenius norm of the matrix X, calculated as the square root of the sum of squared entries in X
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(rnorm(10), 5,2)
MatVar(X)
</code></pre>

<hr>
<h2 id='MatVar2'>Alternative calculation - Matrix variation (i.e. Frobenius norm)</h2><span id='topic+MatVar2'></span>

<h3>Description</h3>

<p>Calculates the Frobenius norm of a matrix, which can be used as a measure of total variation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MatVar2(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MatVar2_+3A_x">X</code></td>
<td>
<p>a matrix of any size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Frobenius norm of the matrix X, calculated as the square root of the trace of t(X)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X = matrix(rnorm(10), 5,2)
MatVar2(X)
</code></pre>

<hr>
<h2 id='Melt.Sim.Cors'>Converts correlations of predicted to true joint subject scores to a format conducive to ggplot2</h2><span id='topic+Melt.Sim.Cors'></span>

<h3>Description</h3>

<p>Converts correlations of predicted to true joint subject scores into a format conducive to ggplot2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Melt.Sim.Cors(sim.dat, r.J, p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Melt.Sim.Cors_+3A_sim.dat">sim.dat</code></td>
<td>
<p>matrix with each row representing results from a replicate in the simulation study described in CJIVE manuscript</p>
</td></tr>
<tr><td><code id="Melt.Sim.Cors_+3A_r.j">r.J</code></td>
<td>
<p>(Numeric/integer) the joint rank, i.e. number of components in the joint subspace</p>
</td></tr>
<tr><td><code id="Melt.Sim.Cors_+3A_p1">p1</code></td>
<td>
<p>number of variables/features in data set X1</p>
</td></tr>
<tr><td><code id="Melt.Sim.Cors_+3A_p2">p2</code></td>
<td>
<p>number of variables/features in data set X2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with seven columns: one each for the joint variance explained in each data set,
one column containing the method by which predictions were obtained,
one column containing the component number (1,...,r.J),
</p>

<hr>
<h2 id='perm.jntrank'>Permutation Test for Joint Rank in CJIVE</h2><span id='topic+perm.jntrank'></span>

<h3>Description</h3>

<p>Conducts the permutation test for the number of joint components as described in CJIVE manuscript. Briefly, canonical correlations (CC) between principal component
vectors of the data are obtained (PC). Then for 1:nperms, the rows of one data set are permuted and CCs between PC vectors are calculated, retaining
the maximum CC. These maximum CCs form a null distribution against which the original CCs are tested. The number of original CCs exceeding the (1-alpha)^th
percentile is the returned as the joint rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perm.jntrank(
  dat.blocks,
  signal.ranks = NULL,
  nperms = 500,
  perc.var = 0.95,
  alpha = 0.05,
  center = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perm.jntrank_+3A_dat.blocks">dat.blocks</code></td>
<td>
<p>a list of two matrices with samples along rows and features along columns, which contain data on the same n individuals/sampling units</p>
</td></tr>
<tr><td><code id="perm.jntrank_+3A_signal.ranks">signal.ranks</code></td>
<td>
<p>a vector of length two which contains the rank for the signal within each data block. The rank corresponds to the number of principal
components (PCs) to be retained within each data block. If NULL, the ranks are determined by the parameter 'perc.var.' Default is NULL</p>
</td></tr>
<tr><td><code id="perm.jntrank_+3A_nperms">nperms</code></td>
<td>
<p>integer value indicating the number of permutations that should be performed</p>
</td></tr>
<tr><td><code id="perm.jntrank_+3A_perc.var">perc.var</code></td>
<td>
<p>numeric value of either a scalar or of length 2: an alternative to signal.ranks that allows specification of signal ranks based on the
desired proportion of total variation to be retained in each data block.
For perc.var = p (where 0&lt;p&lt;1), rank is determined as the minimum number of eigenvalues whose cumulative sum is at least p*(total sum of eigenvalues).
Default is 0.95 (i.e. 95% of total variation preserved for each data block). For p=c(p1,p2) pk is used to determine the rank of block k</p>
</td></tr>
<tr><td><code id="perm.jntrank_+3A_alpha">alpha</code></td>
<td>
<p>nominal type-I error rate</p>
</td></tr>
<tr><td><code id="perm.jntrank_+3A_center">center</code></td>
<td>
<p>logical (TRUE/FALSE) indicating whether data should be column-centered prior to testing. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Frobenius norm of the matrix X, calculated as the sum of square entries in X
</p>

<hr>
<h2 id='scale_loadings'>Scale and sign-correct variable loadings to assist interpretation</h2><span id='topic+scale_loadings'></span>

<h3>Description</h3>

<p>Scale loadings for a joint or individual component by its largest absolute value resulting in loadings between -1 and 1.
Loadings are also sign-corrected to result in positive skewness
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_loadings(loading.comp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_loadings_+3A_loading.comp">loading.comp</code></td>
<td>
<p>numeric vector of variable loadings from a JIVE analysis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of loadings which have been scaled and sign-corrected
</p>

<hr>
<h2 id='show.image.2'>Display a heatmap of a matrix (adapted from Erick Lock's show.image function in the r.jive package)</h2><span id='topic+show.image.2'></span>

<h3>Description</h3>

<p>Visual display of a matrix as a heatmap with colors determined by entry values, and including a colorbar to aid interpretation of the heatmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show.image.2(
  Image,
  ylab = "",
  xlab = "",
  net = FALSE,
  main = "",
  sub = "",
  colorbar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="show.image.2_+3A_image">Image</code></td>
<td>
<p>matrix to display</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_ylab">ylab</code></td>
<td>
<p>lab for y-axis of heatmap</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_xlab">xlab</code></td>
<td>
<p>lab for x-axis of heatmap</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_net">net</code></td>
<td>
<p>logical (TRUE/FALUSE) of whether entries correspond to edges between regions of interest in the Power-264 brain atlas. Default is FALSE</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_main">main</code></td>
<td>
<p>main title for heatmap</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_sub">sub</code></td>
<td>
<p>subtitle for heatmap</p>
</td></tr>
<tr><td><code id="show.image.2_+3A_colorbar">colorbar</code></td>
<td>
<p>logical (TRUE/FALUSE) of whether colorabar shouldl be included to aid interpretation. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical display of matrix as a heatmap
</p>

<hr>
<h2 id='sjive'>Simple JIVE</h2><span id='topic+sjive'></span>

<h3>Description</h3>

<p>Conducts AJIVE estimation under the assumption that all ranks are known and no components are discarded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjive(blocks, signal_ranks, joint.rank, joint_scores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sjive_+3A_blocks">blocks</code></td>
<td>
<p>list of data blocks, i.e. matrices, all having the same number of rows, which correspond to the same sampling units (i.e. study participants, patients, etc.)</p>
</td></tr>
<tr><td><code id="sjive_+3A_signal_ranks">signal_ranks</code></td>
<td>
<p>numerical vector of the same length as 'blocks' with each entry corresponding to the rank of the respective matrix in 'blocks'</p>
</td></tr>
<tr><td><code id="sjive_+3A_joint.rank">joint.rank</code></td>
<td>
<p>integer value corresponding to the rank of the joint signal subspace, i.e. number of components in the signal subspace</p>
</td></tr>
<tr><td><code id="sjive_+3A_joint_scores">joint_scores</code></td>
<td>
<p>numerical matrix containing joint subject scores if they were calculated by some other method, e.g. Canonical Correlation of PC scores.
Must have the same number of rows as each matrix in 'blocks' and number of columns equal to 'joint_rank'. If NULL, joint scores are calculated and
returned. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 4 or 5 items: 1) joint signal matrices, their SVDs, and the proportion of total variation in each matrix that is attributable to the joint signal
2) individual signal matrices, their SVDs, and the proportion of total variation in each matrix that is attributable to the individual signal
3) concatenated PC scores, used to determine joint subspace
4) projection matrix for joint subspace
5) joint subject scores (only returned if not provided initially)
</p>

<hr>
<h2 id='vec2net.l'>Convert vector to network</h2><span id='topic+vec2net.l'></span>

<h3>Description</h3>

<p>Converts a vector of size p choose 2 into a p-by-p lower triangular matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2net.l(invector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2net.l_+3A_invector">invector</code></td>
<td>
<p>numeric vector of size p choose 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lower triangular p-by-p matrix
</p>

<hr>
<h2 id='vec2net.u'>Convert vector to network</h2><span id='topic+vec2net.u'></span>

<h3>Description</h3>

<p>Converts a vector of size p choose 2 into a p-by-p upper triangular matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2net.u(invector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2net.u_+3A_invector">invector</code></td>
<td>
<p>numeric vector of size p choose 2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>upper triangular p-by-p matrix
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
