<!DOCTYPE html><html><head><title>Help for package logcondiscr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {logcondiscr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#internal'><p>Functions for estimation of a log-concave probability mass function via maximum likelihood</p></a></li>
<li><a href='#kInflatedLogConDiscr'><p>Compute a mixture of a point mass at 0 and a log-concave probability mass function from i.i.d. data</p></a></li>
<li><a href='#logcondiscr-package'><p>Estimate a Log-Concave Probability Mass Function from Discrete i.i.d. Observations</p></a></li>
<li><a href='#logConDiscrCI'><p>Compute pointwise confidence bands for the log-concave MLE of a PMF</p></a></li>
<li><a href='#logConDiscrMLE'><p>Compute log-concave probability mass function from i.i.d. data</p></a></li>
<li><a href='#Triangular'><p>Functions to compute a and simulate from a triangular probability mass function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Estimate a Log-Concave Probability Mass Function from Discrete
i.i.d. Observations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-07-03</td>
</tr>
<tr>
<td>Author:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt; and Fadoua Balabdaoui &lt;fadoua@ceremade.dauphine.fr&gt; and Hanna Jankowski &lt;hkj@mathstat.yorku.ca&gt; and Kathrin Weyermann &lt;kathrin.weyermann@bkw-fmb.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kaspar Rufibach &lt;kaspar.rufibach@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, mvtnorm, cobs</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Given independent and identically distributed observations X(1), ..., X(n), allows to compute the maximum likelihood estimator (MLE) of probability mass function (pmf) under the assumption that it is log-concave, see Weyermann (2007) and Balabdaoui, Jankowski, Rufibach, and Pavlides (2012). The main functions of the package are 'logConDiscrMLE' that allows computation of the log-concave MLE, 'logConDiscrCI' that computes pointwise confidence bands for the MLE, and 'kInflatedLogConDiscr' that computes a mixture of a log-concave PMF and a point mass at k.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> ,
<a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a> ,
<a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-03 09:36:27 UTC; rufibach</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-03 12:51:05</td>
</tr>
</table>
<hr>
<h2 id='internal'>Functions for estimation of a log-concave probability mass function via maximum likelihood</h2><span id='topic+Direction'></span><span id='topic+dMLE'></span><span id='topic+GradientL'></span><span id='topic+HesseL'></span><span id='topic+J00'></span><span id='topic+J10'></span><span id='topic+J11'></span><span id='topic+J20'></span><span id='topic+LikFunk'></span><span id='topic+LocalCoarsen'></span><span id='topic+LocalConcavity'></span><span id='topic+LocalExtend'></span><span id='topic+LocalMLE'></span><span id='topic+LocalNormalize'></span><span id='topic+StepSize'></span>

<h3>Description</h3>

<p>Internal functions for the estimation of a log-concave probability mass function.
These functions are not intended to be called by the user directly. 
</p>
<p><code><a href="#topic+Direction">Direction</a></code> Compute vector that points in direction of <code class="reqn">\max L(\psi)</code> via Newton step.
</p>
<p><code><a href="#topic+dMLE">dMLE</a></code> Compute the vector <code class="reqn">\psi</code> s.t. the log-likelihood function <code class="reqn">L</code>, as implemented in <code>LikFunk</code>, is maximized
over all PMFs (under no additional restrictions, though).
</p>
<p><code><a href="#topic+GradientL">GradientL</a></code> Gradient of <code>LikFunk</code>.
</p>
<p><code><a href="#topic+HesseL">HesseL</a></code> Hesse matrix of <code>LikFunk</code>.
</p>
<p><code><a href="#topic+J00">J00</a></code> Function introduced in Section 2.3 in Weyermann (2007), defined as
</p>
<p style="text-align: center;"><code class="reqn">J^{\delta_k}(\psi_k, \psi_{k+1}) := \sum_{j=0}^{\delta_k} \exp \Bigl((1-j/\delta_k)\psi_k + (j/\delta_k) \psi_{k+1} \Bigr).</code>
</p>

<p>This function is used to compute the value of the log-likelihood in <code>LikFunk</code>.
</p>
<p><code><a href="#topic+J10">J10</a></code> Derivative of <code class="reqn">J^{\delta_k}(\psi_k, \psi_{k+1})</code> w.r.t to the first argument.
</p>
<p><code><a href="#topic+J11">J11</a></code> Derivative of <code class="reqn">J^{\delta_k}(\psi_k, \psi_{k+1})</code> w.r.t to both arguments.
</p>
<p><code><a href="#topic+J20">J20</a></code> Second derivative of <code class="reqn">J^{\delta_k}(\psi_k, \psi_{k+1})</code> w.r.t to the first argument.
</p>
<p><code><a href="#topic+LikFunk">LikFunk</a></code> The log-likelihood function for the discrete log-concave MLE.
</p>
<p><code><a href="#topic+LocalCoarsen">LocalCoarsen</a></code> Auxiliary function.
</p>
<p><code><a href="#topic+LocalConcavity">LocalConcavity</a></code> Auxiliary function.
</p>
<p><code><a href="#topic+LocalExtend">LocalExtend</a></code> Auxiliary function.
</p>
<p><code><a href="#topic+LocalMLE">LocalMLE</a></code> Auxiliary function.
</p>
<p><code><a href="#topic+LocalNormalize">LocalNormalize</a></code> Auxiliary function.
</p>
<p><code><a href="#topic+StepSize">StepSize</a></code> Auxiliary function.
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Weyermann, K. (2007).
An Active Set Algorithm for Log-Concave Discrete Distributions.
<em>MSc thesis, University of Bern</em> (Supervisor: Lutz Duembgen).
</p>


<h3>See Also</h3>

<p>All these functions are used by the function <code><a href="#topic+logConDiscrMLE">logConDiscrMLE</a></code>.</p>

<hr>
<h2 id='kInflatedLogConDiscr'>Compute a mixture of a point mass at 0 and a log-concave probability mass function from i.i.d. data</h2><span id='topic+kInflatedLogConDiscr'></span>

<h3>Description</h3>

<p>Using an EM algorithm, compute an estimate of a mixture of a point mass at <code class="reqn">k</code> and a 
log-concave probability mass function from discrete i.i.d. data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kInflatedLogConDiscr(x, k = 0, prec1 = 1e-10, prec2 = 1e-15, 
    itermax = 200, output = TRUE, theta0 = 0.5, p0 = NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kInflatedLogConDiscr_+3A_x">x</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_k">k</code></td>
<td>
<p>Point at which inflation should be assumed. Must be in <code class="reqn">x_1, x_1 + 1, \ldots, x_{n - 1}, x_n</code>.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_prec1">prec1</code></td>
<td>
<p>Precision for stopping criterion.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_prec2">prec2</code></td>
<td>
<p>Precision to remove ends of support in case weights <code class="reqn">&lt;</code><code>prec2</code>.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_itermax">itermax</code></td>
<td>
<p>Maximal number of iterations of EM algorithm.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_output">output</code></td>
<td>
<p>Logical, if <code>TRUE</code>, progress of EM algorithm is shown.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_theta0">theta0</code></td>
<td>
<p>Optional initialization for <code class="reqn">\theta_0</code>, the point mass at <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code id="kInflatedLogConDiscr_+3A_p0">p0</code></td>
<td>
<p>Optional initialization for the PMF.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of observations <code class="reqn">{\bold{x}_n} = (x_1, \ldots, x_n)</code> from a discrete PMF with a (potential)
point mass at <code class="reqn">k</code> (typically <code class="reqn">k = 0</code>), <code><a href="#topic+kInflatedLogConDiscr">kInflatedLogConDiscr</a></code> computes a pmf that is a mixture between a point mass at <code class="reqn">k</code> and a log-concave PMF on <code class="reqn">x</code>. 
To accomplish this, an EM algorithm is used.</p>


<h3>Value</h3>

<p>A list containing the following elementes:
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>The support.</p>
</td></tr>
<tr><td><code>f</code></td>
<td>
<p>The estimated <code class="reqn">k</code>-inflated log-concave PMF.</p>
</td></tr>
<tr><td><code>E(L)</code></td>
<td>
<p>The value of the expected composite log-likelihood at the maximum.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>The value of the composite log-likelihood at the maximum.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>The estimated weight at <code class="reqn">k</code>.</p>
</td></tr>
<tr><td><code>logconc.pmf</code></td>
<td>
<p>The log-concave part of the mixture.</p>
</td></tr>
<tr><td><code>logconc.z</code></td>
<td>
<p>The support of <code>logconc.pmf</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Weyermann, K. (2007).
An Active Set Algorithm for Log-Concave Discrete Distributions.
<em>MSc thesis, University of Bern</em> (Supervisor: Lutz Duembgen).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## -----------------------------------------------
## generate zero-inflated negative binomial sample
## -----------------------------------------------
set.seed(2011)
n &lt;- 100
theta &lt;- 0.05
r &lt;- 6
p &lt;- 0.3
x &lt;- rnbinom(n, r, p)

## inflate at 0
x &lt;- ifelse(runif(n) &lt;= theta, 0, x)

## estimate log-concave MLE
fit1 &lt;- logConDiscrMLE(x, w = NA, psi_o = NA, prec = 1e-05, output = TRUE)

## estimate zero-inflated log-concave MLE
fit2 &lt;- kInflatedLogConDiscr(x, k = 0)

## plot the results
par(mfrow = c(1, 1), las = 1)
plot(fit1$x, exp(fit1$psi), type = "b", col = 2, xlim = range(x), xlab = "x", 
    ylim = c(0, max(exp(fit1$psi), fit2$f)), ylab = "PMF", 
    main = "Estimate MLE from a zero-inflated negative-binomial", pch = 19)
lines(fit2$z, fit2$f, type = "b", col = 4, pch = 15)

## add the true PMF we sampled from
z &lt;- fit2$z
f.true &lt;- theta * c(1, rep(0, length(z) - 1)) + (1 - theta) * dnbinom(z, r, p)
lines(z, f.true, col = 6, type = "b", pch = 17)

legend("topright", c("log-concave MLE", "zero-inflated log-concave MLE", 
    "true PMF"), col = c(2, 4, 6), lty = c(1, 1, 1), pch = c(19, 15, 17), 
    bty = "n")
    
## Not run: 
## -----------------------------------------------
## generate seven-inflated negative binomial sample
## -----------------------------------------------
theta &lt;- 0.05
r &lt;- 4
p &lt;- 0.3
n &lt;- 10000
x &lt;- rnbinom(n, r, p)
x &lt;- ifelse(runif(n) &lt;= theta, 7, x)
x &lt;- c(x, rep(7, 10))

## compute different estimates
zero.mle &lt;- kInflatedLogConDiscr(x, k = 7)
mle &lt;- logConDiscrMLE(x, output = FALSE)
f.mle &lt;- exp(mle$psiSupp)
z&lt;-	zero.mle$z
f1 &lt;- theta * c(rep(0, 7 - min(x)), 1, rep(0, max(x) - 7))
f2 &lt;- (1 - theta) * dnbinom(z, r, p)
f.true &lt;- f1 + f2
true &lt;- dnbinom(z, r, p)
f.fit &lt;- zero.mle$f
xx &lt;- sort(unique(x))
emp &lt;- rep(0, length(z))
emp[xx - min(x) + 1] &lt;- as.vector(table(x) / n)

## plot results
plot(z, f.true, type = "l", ylim = c(0, max(emp)), xlab = "x", 
    ylab = "PMF", main = "Illustration k-inflated estimator")
points(z, true, type = "l", lty = 2)
points(z, f.fit, type = "l", col = "red")
points(z, zero.mle$logconc.pmf, type = "l", col = "red", lty = 2)
points(min(x):max(x), f.mle, type = "l", col = "green")
points(z, emp, type = "l", col = "purple")
points(z, emp, col = "purple")
legend("topright", inset = 0.05, c("true", "true less seven", "seven-inflated", 
    "recovered", "logconc", "empirical"), lty=c(1, 2, 1, 2, 1, 1), col = c("black", 
    "black", "red", "red", "green", "purple"))

## zoom in near mode
subs &lt;- 4:12
plot(z[subs], f.true[subs], type = "l", ylim = c(0, max(emp)), xlab = "x", 
    ylab = "PMF", main = "Illustration k-inflated estimator")
points(z[subs], true[subs], type = "l", lty = 2)
points(z[subs], f.fit[subs], type = "l", col = "red")
points(z[subs], zero.mle$logconc.pmf[subs], type = "l", col = "red", lty = 2)
points((min(x):max(x))[subs], f.mle[subs], type = "l", col = "green")
points(z[subs], emp[subs], type = "l", col = "purple")
points(z[subs], emp[subs], col = "purple")

## End(Not run)
</code></pre>

<hr>
<h2 id='logcondiscr-package'>Estimate a Log-Concave Probability Mass Function from Discrete i.i.d. Observations</h2><span id='topic+logcondiscr-package'></span><span id='topic+logcondiscr'></span>

<h3>Description</h3>

<p>Implements the maximum likelihood estimator (MLE) for a probability mass function (PMF) under the assumption of log-concavity from i.i.d. data.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> logcondiscr </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.6 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-07-03 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main functions in the package are: 
</p>
<p><code><a href="#topic+logConDiscrMLE">logConDiscrMLE</a></code>: Compute the maximum likelihood estimator (MLE) of a log-concave PMF from i.i.d. data. The constrained log-likelihood function is maximized using an active set algorithm as initially described in Weyermann (2007). 
</p>
<p><code><a href="#topic+logConDiscrCI">logConDiscrCI</a></code>: Compute the maximum likelihood estimator (MLE) of a log-concave PMF from i.i.d. data and corresponding, asymptotically valid, pointwise confidence bands as
developed in Balabdaoui et al (2012). 
</p>
<p><code><a href="#topic+kInflatedLogConDiscr">kInflatedLogConDiscr</a></code>: Compute an estimate of a mixture of a log-concave PMF that is inflated at <code class="reqn">k</code>, from i.i.d. data, using an EM algorithm. 
</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann 
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Weyermann, K. (2007).
An Active Set Algorithm for Log-Concave Discrete Distributions.
<em>MSc thesis, University of Bern</em> (Supervisor: Lutz Duembgen).
</p>


<h3>See Also</h3>

<p>Functions to estimate the log-concave MLE for a univariate continuous distribution are provided in the package <span class="pkg">logcondens</span> and
for observations in more than one dimension in <span class="pkg">LogConDEAD</span>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>## see the help files for the abovementioned functions for examples</code></pre>

<hr>
<h2 id='logConDiscrCI'>Compute pointwise confidence bands for the log-concave MLE of a PMF</h2><span id='topic+logConDiscrCI'></span>

<h3>Description</h3>

<p>Compute pointwise confidence bands for the log-concave maximum likelihood estimate of a log-concave probability mass function based on the limiting
theory developed in Balabdaoui et al (2012).</p>


<h3>Usage</h3>

<pre><code class='language-R'>logConDiscrCI(dat, conf.level = 0.95, type = c("MLE", "all")[1], 
    B = 1000, output = TRUE, seed = 2011)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logConDiscrCI_+3A_dat">dat</code></td>
<td>
<p>Data to compute MLE and confidence band for.</p>
</td></tr>
<tr><td><code id="logConDiscrCI_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to be used.</p>
</td></tr>
<tr><td><code id="logConDiscrCI_+3A_type">type</code></td>
<td>
<p>To compute confidence bands one theoretically needs to know the knots of the true PMF. For type <code>MLE</code> the knots of the MLE will be used instead
and for type <code>all</code> all observations will be considered knots. The latter is conservative and gives pointwise confidence intervals that are based on standard 
errors from a Normal approximation (the latter comes from the asymptotic theory in Balabdaoui et al, 2011).</p>
</td></tr>
<tr><td><code id="logConDiscrCI_+3A_b">B</code></td>
<td>
<p>Number of samples to be drawn to compute resampling quantiles.</p>
</td></tr>
<tr><td><code id="logConDiscrCI_+3A_output">output</code></td>
<td>
<p>If <code>TRUE</code>, progress of computations is output.</p>
</td></tr>
<tr><td><code id="logConDiscrCI_+3A_seed">seed</code></td>
<td>
<p>Optional seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The pointwise confidence bands are based on the limiting theory in Balabdaoui et al (2011).</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>MLE</code></td>
<td>
<p>The estimated MLE (simply the output list of the function <code>logConDiscrMLE</code> applied to <code>dat</code>).</p>
</td></tr>
<tr><td><code>emp</code></td>
<td>
<p>A dataframe containing two columns: the unique sorted observations and the empirical PMF.</p>
</td></tr>
<tr><td><code>CIs</code></td>
<td>
<p>The computed confidence intervals for each <code class="reqn">x \in \{</code><code>min(dat), ..., max(dat)</code><code class="reqn">\}</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Values outside <code class="reqn">[0, 1]</code> will be clipped. As a consequence, coverage may be higher than <code class="reqn">1 - \alpha</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann 
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Weyermann, K. (2007).
An Active Set Algorithm for Log-Concave Discrete Distributions.
<em>MSc thesis, University of Bern</em> (Supervisor: Lutz Duembgen).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># -------------------------------------------------------------
# compute MLE and confidence bands for a random sample from a 
# Poisson distribution
# -------------------------------------------------------------
set.seed(2011)
x &lt;- sort(rpois(n = 100, lambda = 2))
mle &lt;- logConDiscrMLE(x)
psi &lt;- mle$psi

# compute confidence bands
CIs &lt;- logConDiscrCI(x, type = "MLE", output = TRUE, seed = 20062011)$CIs

# plot estimated PMF and log of estimate
par(mfrow = c(1, 2), las = 1)
true &lt;- dpois(0:20, lambda = 2)
plot(mle$x, exp(psi), type = "b", col = 2, xlim = c(min(x), max(x) + 1), 
    xlab = "x", ylim = c(0, max(exp(psi), true, CIs[, 3])), ylab = "PMF", 
    main = "Estimate MLE from a Poisson", pch = 19)
legend("topright", c("truth", "MLE", "confidence bands"), col = c(4, 2, 2), 
    lty = c(1, 1, 2), pch = c(0, 19, NA), bty = "n")

# add true PMF
lines(0:20, true, type = "l", col = 4)

# add confidence bands
matlines(CIs[, 1], CIs[, 2:3], type = "l", lty = 2, col = 2)

# log-density
plot(mle$x, psi, type = "p", col = 2, xlim = c(min(x), max(x) + 1), 
    xlab = "x", ylab = "PMF", main = "Estimate MLE from a Poisson", 
    pch = 19, ylim = c(-6, log(max(exp(psi), true, CIs[, 3]))))
lines(0:20, log(true), type = "l", col = 4)

# add confidence bands
matlines(CIs[, 1], log(CIs[, 2:3]), type = "l", lty = 2, col = 2)


# -------------------------------------------------------------
# compute confidence bands when only estimate (not original data)
# are available (as a an example we simply use the estimator from
# above)
# -------------------------------------------------------------
x.est &lt;- 0:6
est &lt;- c(0.09, 0.30, 0.30, 0.19, 0.09, 0.02, 0.01)

# generate original data (up to given precision)
x &lt;- rep(0:6, times = 100 * est)
</code></pre>

<hr>
<h2 id='logConDiscrMLE'>Compute log-concave probability mass function from i.i.d. data</h2><span id='topic+logConDiscrMLE'></span>

<h3>Description</h3>

<p>Compute the maximum likelihood estimate of a log-concave probability mass function from discrete i.i.d. data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>logConDiscrMLE(x, w = NA, psi_o = NA, prec = 1e-05, output = TRUE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logConDiscrMLE_+3A_x">x</code></td>
<td>
<p>Vector of observations. If <code>w = NA</code>, then weights will be generated for each non-unique observation of <code>x</code>.</p>
</td></tr>
<tr><td><code id="logConDiscrMLE_+3A_w">w</code></td>
<td>
<p>If <code>w = NA</code>, weights will be generated from <code>x</code>. If <code>w != NA</code>, then it is assumed that <code>x</code> and <code>w</code> are of equal length and 
the elements in <code>w</code> correspond to the weights in <code>x</code>.</p>
</td></tr>
<tr><td><code id="logConDiscrMLE_+3A_psi_o">psi_o</code></td>
<td>
<p>Optional start vector.</p>
</td></tr>
<tr><td><code id="logConDiscrMLE_+3A_prec">prec</code></td>
<td>
<p>Precision for stopping criterion.</p>
</td></tr>
<tr><td><code id="logConDiscrMLE_+3A_output">output</code></td>
<td>
<p>Logical, if <code>TRUE</code>, progress of the active set algorithm is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a vector of observations <code class="reqn">{\bold{x}_n} = (x_1, \ldots, x_n)</code> from a discrete PMF,
<code><a href="#topic+logConDiscrMLE">logConDiscrMLE</a></code> computes a function <code class="reqn">\widehat p_k</code> on <code class="reqn">\{x_1, \ldots, x_n\}</code> with knots only 
in <code class="reqn">\{x_1, \ldots, x_n\}</code> such that 
</p>
<p style="text-align: center;"><code class="reqn">L(\bold{p}) = \sum_{i=1}^n w_i \log(p_i)</code>
</p>

<p>is maximal over all log-concave PMFs <code class="reqn">\{p_k\}, k=1, \ldots, n</code>, where <code class="reqn">w_i</code> is the frequency of the observation <code class="reqn">x_i</code>. 
To accomplish this, an active set algorithm is used.</p>


<h3>Value</h3>

<p>A list containing the following elementes:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>Vector of unique observations, sorted.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>Generated weights.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>The estimated log-density on the grid of unique, sorted observations.</p>
</td></tr>
<tr><td><code>L</code></td>
<td>
<p>The value of the log-likelihood at the maximum.</p>
</td></tr>
<tr><td><code>IsKnot</code></td>
<td>
<p>Binary vector where <code>isKnot_k = 1</code> if <code class="reqn">\psi</code> has a knot at <code class="reqn">x_k</code>.</p>
</td></tr>
<tr><td><code>xSupp</code></td>
<td>
<p>The full support <code class="reqn">\{x_1, x_1 + 1, \ldots, x_m - 1, x_m\}</code>.</p>
</td></tr>
<tr><td><code>psiSupp</code></td>
<td>
<p><code class="reqn">\psi</code> interpolated on <code>xSupp</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann 
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Weyermann, K. (2007).
An Active Set Algorithm for Log-Concave Discrete Distributions.
<em>MSc thesis, University of Bern</em> (Supervisor: Lutz Duembgen).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# -------------------------------------------------------------
# compute MLE for a random sample from a Poisson distribution
# -------------------------------------------------------------
x &lt;- sort(rpois(n = 100, lambda = 2))
mle &lt;- logConDiscrMLE(x)
psi &lt;- mle$psi

# plot estimated PMF and log of estimate
par(mfrow = c(1, 2), las = 1)
true &lt;- dpois(0:20, lambda = 2)
plot(mle$x, exp(psi), type = "p", col = 2, xlim = range(x), xlab = "x", 
    ylim = c(0, max(exp(psi), true)), ylab = "PMF", 
    main = "Estimate MLE from a Poisson", pch = 19)
legend("topright", c("truth", "MLE"), col = c(4, 2), lty = c(1, 0), 
    pch = c(0, 19), bty = "n")

# add true PMF
lines(0:20, true, type = "l", col = 4)

# log-density
plot(mle$x, psi, type = "p", col = 2, xlim = range(x), xlab = "x", 
    ylab = "PMF", main = "Estimate MLE from a Poisson", pch = 19)
lines(0:20, log(true), type = "l", col = 4)

# use a priori specified weights: mle = mle2
mle2 &lt;- logConDiscrMLE(x = unique(x), w = table(x))


## -------------------------------------------------------------
## Illustrate the limit process: the code below can be used to
## to reproduce the limit process figure in Balabdaoui et al (2011)
## -------------------------------------------------------------
a &lt;- 1
b &lt;- 7
c &lt;- 8
d &lt;- 11
e &lt;- 2
n &lt;- 10 ^ 2

## support
x &lt;- seq(a, d, by = 1)

## true density
dens &lt;- dTriangular(a, b, c, d, e)
logdens &lt;- log(dens)
rand &lt;- rTriangular(n, a, b, c, d, e)$rand

## empirical
emp &lt;- table(rand) / n
x.emp &lt;- names(table(rand))

## log-concave MLE
mle &lt;- logConDiscrMLE(rand, output = FALSE)

## plot log PMF and PMF
par(mfrow = c(1, 2))
plot(x, logdens, type = "l", col = 1, pch = 19, main = "log-density", 
    xlim = c(a, d), ylim = range(range(log(emp), logdens)))
lines(x, logdens, type = "l", col = 1, lwd = 0.1)
points(x.emp, log(emp), col = 4, pch = 19)
points(mle$x, mle$psi, col = 6, pch = 19)
abline(v = mle$x[mle$isKnot == 1], lty = 3, col = 3)

plot(x, dens, type = "l", col = 1, pch = 19, main = "density", 
    xlim = c(a, d), ylim = c(0, max(dens, emp)))
lines(x, dens, type = "l", col = 1, lwd = 0.1)
points(x.emp, emp, col = 4, pch = 19)
points(mle$x, exp(mle$psi), col = 6, pch = 19)
legend("topleft", c("truth", "MLE", "knots of the MLE", "empirical"), 
    col = c(1, 6, 3, 4), pch = c(NA, 19, NA, 19), lty = c(1, NA, 3, NA), 
    bg = "white", bty = "n")
abline(v = mle$x[mle$isKnot == 1], lty = 3, col = 3)


## -------------------------------------------------------------
## Now compute and plot Y(x) and H(x)
## -------------------------------------------------------------
xla &lt;- paste("x = {r = ", a, ", ..., s - 1 = ", b - 1, "}", sep = "")
par(mfcol = c(2, 2), oma = rep(0, 4), mar = c(4.5, 4.5, 2, 1), las = 1)
plot(x, logdens, type = "b", col = 2, pch = 19, main = "log of 
    normalized triangular pmf", xlim = c(a, d), xaxt = "n", xlab = "x", 
    ylab = "log of normalized pmf")
axis(1, at = c(a, b, d), labels = paste(c("a = ", "b = ", "d = "), 
    c(a, b, d), sep = ""))

## compute H(x)
r &lt;- a
s &lt;- b
ind &lt;- r:(s - 1)
px &lt;- dens
p_rs &lt;- px[ind]
m &lt;- s - r

## -------------------------------------------------------------
## generate one observation from the distribution of U(F(x)) - U(F(x - 1))
## -------------------------------------------------------------
sigma &lt;- diag(m) * 0
for (i in 1:m){
    for (j in 1:m){
        sigma[i, j] &lt;- p_rs[i] * (i == j) - p_rs[i] * p_rs[j]
    }
}

set.seed(23041977)
cx &lt;- rep(NA, d - a + 1)
cx[ind] &lt;- rmvnorm(1, mean = rep(0, m), sigma = sigma, method = 
    c("eigen", "svd", "chol")[3])
Ux &lt;- rep(NA, length(x))
Ux[ind] &lt;- cx[ind]

X &lt;- x[ind]
Y &lt;- Ux[ind] / p_rs
W &lt;- p_rs

## concave regression using 'cobs'
Res &lt;- conreg(x = X, y = Y, w = W, verbose = TRUE)
g &lt;- Res$yf
gKnots &lt;- Res$iKnots
plot(X, Y, main = expression("The concave function g* that 
    minimizes "*Phi*"(g)"), xaxt = "n", ylab = "g*", ylim = 
    range(c(Y, g)), xlab = xla, type = "n")
axis(1, at = 0:100, labels = 0:100); abline(v = x[gKnots], 
    lty = 2, col = grey(0.75))
lines(X, g, lwd = 2, col = 3, type = "b", pch = 1)
lines(X, Y, lwd = 1, col = 2, type = "p", pch = 19)
legend("bottomright", c("values of cx / px", "minimizer g*"), 
    lty = c(NA, 1), pch = c(19, 1), col = 2:3, bty = "n", 
    lwd = c(NA, 2))

## compute H(x) for x = r, ..., s - 1 and plot it
gstar &lt;- rep(NA, length(x))
gstar[ind] &lt;- g
xs &lt;- r:(s - 1)
Hs &lt;- rep(0, length(xs))
for (i in 2:length(xs)){
    for (ks in r:(xs[i] - 1)){
        js &lt;- r:ks
        Hs[i] &lt;- Hs[i] + sum(gstar[js] * px[js])
    }
}

## check
(Hs[3:length(Hs)] - 2 * Hs[2:(length(Hs) - 1)] + Hs[1:(length(Hs) - 2)]) / p_rs[2:(length(Hs) - 1)]
gstar

## -------------------------------------------------------------
## plot the product of g* and px (the limit of the PMF)
## -------------------------------------------------------------
plot(x[ind], gstar[ind] * p_rs, main = expression("g"^"*"* " * p"), 
    xaxt = "n", pch = 19, col = 2, ylab = "g*", type = "b", xlab = xla)
axis(1, at = 0:100, labels = 0:100); abline(v = x[gKnots], lty = 2, 
    col = grey(0.75))

## compute Y(x) for x = r, ..., s - 1 and plot it
Ys &lt;- rep(0, length(xs))
for (i in 2:length(xs)){
    for (ks in r:(xs[i] - 1)){
        js &lt;- r:ks
        Ys[i] &lt;- Ys[i] + sum(cx[js])
    }
}

## plot the two processes
plot(xs, Ys, type = "n", col = 2, xaxt = "n", lwd = 2, main = "The 
    processes H(x) and Y(x)", ylab = "H and Y", xlab = xla)
axis(1, at = 0:100, labels = 0:100); abline(v = x[gKnots], lty = 2, 
    col = grey(0.75))
lines(xs, Hs, col = 2, lwd = 1, type = "b")
lines(xs, Ys, col = 3, lwd = 2, type = "l", lty = 2)
legend("topleft", c("H(x)", "Y(x)"), col = 2:3, lty = c(1, 2), pch = 1, 
    bty = "n", lwd = c(1, 2))
</code></pre>

<hr>
<h2 id='Triangular'>Functions to compute a and simulate from a triangular probability mass function</h2><span id='topic+dTriangular'></span><span id='topic+rTriangular'></span>

<h3>Description</h3>

<p>In Balabdaoui et al (2012) the triangular density, defined as
</p>
<p style="text-align: center;"><code class="reqn">p_x^{a, b, c, d, e} = c(x - a) / (b - a)</code>
</p>

<p>for <code class="reqn">x \in \{a, \ldots, c\}</code> and 
</p>
<p style="text-align: center;"><code class="reqn">p_x^{a, b, c, d, e} = (e - c)(x - b) / (d - b) + c</code>
</p>

<p>for <code class="reqn">x \in \{c, \ldots, d\}</code>, was used to illustrate the limit process of the log-concave MLE. In order to provide the code to generate the limit process figure in Balabdaoui et al (2012, see the example in <code><a href="#topic+logConDiscrMLE">logConDiscrMLE</a></code> for the code to generate that figure) the functions <code>dTriangular</code> and <code>rTriangular</code> are included in this package. Note that <code>rTriangular</code> uses the rejection sampling algorithm in Devroye (1987) which was specifically developed to generate random numbers from a log-concave PMF.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dTriangular(a, b, c, d, e)
rTriangular(n, a, b, c, d, e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Triangular_+3A_a">a</code></td>
<td>
<p>Left endpoint of triangular pmf.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_b">b</code></td>
<td>
<p>Mode of triangular pmf.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_c">c</code></td>
<td>
<p>Height at mode.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_d">d</code></td>
<td>
<p>Left endpoint.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_e">e</code></td>
<td>
<p>Height at left endpoint.</p>
</td></tr>
<tr><td><code id="Triangular_+3A_n">n</code></td>
<td>
<p>Number of random numbers to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dTriangular</code> returns a vector containing the value of the PMF at all values in <code class="reqn">x \in \{a, \ldots, d\}</code>.
<code>rTriangular</code> returns a list containing the elements:
</p>
<table>
<tr><td><code>rand</code></td>
<td>
<p>Vector with generated random numbers of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>Vector <code class="reqn">(a, \ldots, d)</code>.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>Value of the pmf at <code class="reqn">x</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is used to generate the plot of the limit process in the help file for the function <code>logConDiscrMLE</code>.</p>


<h3>Author(s)</h3>

<p>Kaspar Rufibach (maintainer) <a href="mailto:kaspar.rufibach@gmail.com">kaspar.rufibach@gmail.com</a> <br /> <a href="http://www.kasparrufibach.ch">http://www.kasparrufibach.ch</a> <br />
Fadoua Balabdaoui <a href="mailto:fadoua@ceremade.dauphine.fr">fadoua@ceremade.dauphine.fr</a> <br /> <a href="http://www.ceremade.dauphine.fr/~fadoua">http://www.ceremade.dauphine.fr/~fadoua</a>  <br />
Hanna Jankowski <a href="mailto:hkj@mathstat.yorku.ca">hkj@mathstat.yorku.ca</a> <br /> <a href="http://www.math.yorku.ca/~hkj">http://www.math.yorku.ca/~hkj</a> <br />
Kathrin Weyermann 
</p>


<h3>References</h3>

<p>Balabdaoui, F., Jankowski, H., Rufibach, K., and Pavlides, M. (2013).
Maximum likelihood estimation and confidence bands for a discrete log-concave distribution.
<em>J. R. Stat. Soc. Ser. B Stat. Methodol.</em>, <b>75</b>(4), 769&ndash;790. 
</p>
<p>Devroye, L. (1987). 
A simple generator for discrete log-concave distributions. 
<em>Computing</em>, <b>39</b>, 87-91.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## -------------------------------------------------------------
## compute values of triangular density and simulate from it
## -------------------------------------------------------------
a &lt;- 1
b &lt;- 7
c &lt;- 8
d &lt;- 11
e &lt;- 2
n &lt;- 10 ^ 2

## support
x &lt;- seq(a, d, by = 1)

## true density
dens &lt;- dTriangular(a, b, c, d, e)
logdens &lt;- log(dens)
rand &lt;- rTriangular(n, a, b, c, d, e)$rand

## does the same as rTriangular()
rand2 &lt;- sample(x = a:d, size = n, prob = dens, replace = TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
