<!DOCTYPE html><html lang="en"><head><title>Help for package LocalCop</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LocalCop}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LocalCop-package'><p>Local likelihood inference for conditional copula models.</p></a></li>
<li><a href='#CondiCopLikCV'><p>Cross-validated likelihood.</p></a></li>
<li><a href='#CondiCopLocFit'><p>Local likelihood estimation.</p></a></li>
<li><a href='#CondiCopLocFun'><p>Create a <span class="pkg">TMB</span> local likelihood function.</p></a></li>
<li><a href='#CondiCopSelect'><p>Local likelihood bandwidth and/or family selection.</p></a></li>
<li><a href='#ConvertPar'><p>Conversions between various bivariate copula parametrizations.</p></a></li>
<li><a href='#KernFun'><p>Local likelihood kernel functions.</p></a></li>
<li><a href='#KernWeight'><p>Calculate local likelihood kernel weights.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Local Likelihood Inference for Conditional Copula Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-08-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a local likelihood estimator for the dependence parameter in bivariate conditional copula models.  Copula family and local likelihood bandwidth parameters are selected by leave-one-out cross-validation.  The models are implemented in 'TMB', meaning that the local score function is efficiently calculated via automated differentiation (AD), such that quasi-Newton algorithms may be used for parameter estimation.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mlysy/LocalCop">https://github.com/mlysy/LocalCop</a>,
<a href="https://mlysy.github.io/LocalCop/">https://mlysy.github.io/LocalCop/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlysy/LocalCop/issues">https://github.com/mlysy/LocalCop/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>TMB, RcppEigen</td>
</tr>
<tr>
<td>Imports:</td>
<td>TMB (&ge; 1.7.20), VineCopula</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, parallel, knitr, rmarkdown, bookdown, kableExtra,
dplyr, readr, tidyr, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-12 15:40:20 UTC; mlysy</td>
</tr>
<tr>
<td>Author:</td>
<td>Elif Fidan Acar [aut],
  Martin Lysy [aut, cre],
  Alan Kuchinsky [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Lysy &lt;mlysy@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-12 17:41:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='LocalCop-package'>Local likelihood inference for conditional copula models.</h2><span id='topic+LocalCop'></span><span id='topic+LocalCop-package'></span>

<h3>Description</h3>

<p>Fits a bivariate conditional copula <code class="reqn">C(u_1, u_2 | \theta_x)</code>, where <code class="reqn">\theta_x</code> is a variable dependence parameter, nonparametrically estimated from a single covariate <code class="reqn">x</code> via local likelihood.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Lysy <a href="mailto:mlysy@uwaterloo.ca">mlysy@uwaterloo.ca</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Elif Acar <a href="mailto:elif.acar@umanitoba.ca">elif.acar@umanitoba.ca</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Alan Kuchinsky [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mlysy/LocalCop">https://github.com/mlysy/LocalCop</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlysy/LocalCop/issues">https://github.com/mlysy/LocalCop/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># simulate data
set.seed(123)
family &lt;- 5 # Frank copula
n &lt;- 1000
x &lt;- runif(n) # covariate values
eta_fun &lt;- function(x) 2*cos(12*pi*x) # copula dependence parameter
eta_true &lt;- eta_fun(x)
par_true &lt;- BiCopEta2Par(family, eta = eta_true)
udata &lt;- VineCopula::BiCopSim(n, family=family,
                              par = par_true$par)

# bandwidth and family selection
bandset &lt;- c(.01, .04, .1) # bandwidth set
famset &lt;- c(2, 5) # family set
n_loo &lt;- 100 # number of leave-one-out observations in CV likelihood calculation
system.time({
  cvsel &lt;- CondiCopSelect(u1= udata[,1], u2 = udata[,2],
                          x = x, family = famset, band = bandset,
                          xind = n_loo)
})

# compare estimates to true value
xseq &lt;- cvsel$x
famsel &lt;- cvsel$cv$family
bandsel &lt;- cvsel$cv$band
etasel &lt;- cvsel$eta
clrs &lt;- c("red", "blue", "green4")
names(clrs) &lt;- bandset

plot_fun &lt;- function(fam) {
  nband &lt;- length(bandset)
  if(fam == 2) {
    famind &lt;- 1:nband
    main &lt;- "Student-t Copula"
  } else {
    famind &lt;- nband+1:nband
    main &lt;- "Frank Copula"
  }
  plot(xseq, BiCopEta2Tau(family, eta = eta_fun(xseq)),
       type = "l", lwd = 2, ylim = c(-.5, .5),
       xlab = expression(x), ylab = expression(tau(x)),
       main = main)
  for(ii in famind) {
    lines(xseq, BiCopEta2Tau(fam, eta = etasel[,ii]),
          col = clrs[as.character(bandsel[ii])], lwd = 1)
  }
  legend("bottomright", fill = clrs,
         legend = paste0("band_", bandsel[famind],
                         " = ", signif(cvsel$cv$cv[famind], 3)))
}

oldpar &lt;- par(mfrow = c(1,2))
plot_fun(2)
plot_fun(5)
par(oldpar)
</code></pre>

<hr>
<h2 id='CondiCopLikCV'>Cross-validated likelihood.</h2><span id='topic+CondiCopLikCV'></span>

<h3>Description</h3>

<p>Leave-one-out local likelihood copula parameter estimates are interpolated, then used to calculate the conditional copula likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondiCopLikCV(
  u1,
  u2,
  family,
  x,
  xind = 100,
  degree = 1,
  eta,
  nu,
  kernel = KernEpa,
  band,
  optim_fun,
  cveta_out = FALSE,
  cv_all = FALSE,
  cl = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CondiCopLikCV_+3A_u1">u1</code></td>
<td>
<p>Vector of first uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_u2">u2</code></td>
<td>
<p>Vector of second uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family to use.  See <code><a href="#topic+ConvertPar">ConvertPar()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_x">x</code></td>
<td>
<p>Vector of observed covariate values.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_xind">xind</code></td>
<td>
<p>Vector of indices in <code>sort(x)</code> at which to calculate leave-one-out parameter estimates.  Can also be supplied as a single integer, in which case <code>xind</code> equally spaced observations are taken from <code>x</code>.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_degree">degree</code></td>
<td>
<p>Integer specifying the polynomial order of the local likelihood function.  Currently only 0 and 1 are supported.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_eta">eta</code>, <code id="CondiCopLikCV_+3A_nu">nu</code>, <code id="CondiCopLikCV_+3A_kernel">kernel</code>, <code id="CondiCopLikCV_+3A_band">band</code>, <code id="CondiCopLikCV_+3A_optim_fun">optim_fun</code>, <code id="CondiCopLikCV_+3A_cl">cl</code></td>
<td>
<p>See <code><a href="#topic+CondiCopLocFit">CondiCopLocFit()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_cveta_out">cveta_out</code></td>
<td>
<p>If <code>TRUE</code>, return the CV estimate of eta at each point in <code>x</code> in addition to the CV log-likelihood.</p>
</td></tr>
<tr><td><code id="CondiCopLikCV_+3A_cv_all">cv_all</code></td>
<td>
<p>If <code>FALSE</code>, evaluate the CV likelihood at only the leave-one-out observations specified by <code>xind</code>.  Otherwise, interpolate the leave-one-out estimates of eta to all values in <code>x</code>, and evaluate the CV likelihood at all observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>cveta_out = FALSE</code>, scalar value of the cross-validated log-likelihood.  Otherwise, a list with elements:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The sorted values of <code>x</code>.</p>
</dd>
<dt><code>eta</code></dt><dd><p>The leave-one-out estimates interpolated from the values in <code>xind</code> to all of those in <code>x</code>.</p>
</dd>
<dt><code>nu</code></dt><dd><p>The scalar value of the estimated (or provided) second copula parameter.</p>
</dd>
<dt><code>loglik</code></dt><dd><p>The cross-validated log-likelihood.</p>
</dd>
</dl>



<h3>See Also</h3>

<p>This function is typically used in conjunction with <code><a href="#topic+CondiCopSelect">CondiCopSelect()</a></code>; see example there.
</p>

<hr>
<h2 id='CondiCopLocFit'>Local likelihood estimation.</h2><span id='topic+CondiCopLocFit'></span>

<h3>Description</h3>

<p>Estimate the bivariate copula dependence parameter <code>eta</code> at multiple covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondiCopLocFit(
  u1,
  u2,
  family,
  x,
  x0,
  nx = 100,
  degree = 1,
  eta,
  nu,
  kernel = KernEpa,
  band,
  optim_fun,
  cl = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CondiCopLocFit_+3A_u1">u1</code></td>
<td>
<p>Vector of first uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_u2">u2</code></td>
<td>
<p>Vector of second uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family to use.  See <code><a href="#topic+ConvertPar">ConvertPar()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_x">x</code></td>
<td>
<p>Vector of observed covariate values.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_x0">x0</code></td>
<td>
<p>Vector of covariate values within <code>range(x)</code> at which to fit the local likelihood.  Does not have to be a subset of <code>x</code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_nx">nx</code></td>
<td>
<p>If <code>x0</code> is missing, defaults to <code>nx</code> equally spaced values in <code>range(x)</code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_degree">degree</code></td>
<td>
<p>Integer specifying the polynomial order of the local likelihood function.  Currently only 0 and 1 are supported.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_eta">eta</code></td>
<td>
<p>Optional initial value of the copula dependence parameter (scalar).  If missing will be estimated unconditionally by <code><a href="VineCopula.html#topic+BiCopEst">VineCopula::BiCopEst()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_nu">nu</code></td>
<td>
<p>Optional initial value of second copula parameter, if it exists.  If missing and required, will be estimated unconditionally by <code><a href="VineCopula.html#topic+BiCopEst">VineCopula::BiCopEst()</a></code>.  If provided and required, will not be estimated.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function to use.  Should accept a numeric vector parameter and return a non-negative numeric vector of the same length.  See <code><a href="#topic+KernFun">KernFun()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_band">band</code></td>
<td>
<p>Kernal bandwidth parameter (positive scalar).  See <code><a href="#topic+KernWeight">KernWeight()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_optim_fun">optim_fun</code></td>
<td>
<p>Optional specification of local likelihood optimization algorithm.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFit_+3A_cl">cl</code></td>
<td>
<p>Optional parallel cluster created with <code><a href="parallel.html#topic+makeCluster">parallel::makeCluster()</a></code>, in which case optimization for each element of <code>x0</code> will be done in parallel on separate cores.  If <code>cl == NA</code>, computations are run serially.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, optimization is performed with the quasi-Newton algorithm provided by <code><a href="stats.html#topic+nlminb">stats::nlminb()</a></code>, which uses gradient information provided by automatic differentiation (AD) as implemented by <span class="pkg">TMB</span>.
</p>
<p>If the default method is to be overridden, <code>optim_fun</code> should be provided as a function taking a single argument corresponding to the output of <code><a href="#topic+CondiCopLocFun">CondiCopLocFun()</a></code>, and return a scalar value corresponding to the estimate of <code>eta</code> at a given covariate value in <code>x0</code>.  Note that <span class="pkg">TMB</span> calculates the <em>negative</em> local (log)likelihood, such that the objective function is to be minimized.  See <strong>Examples</strong>.
</p>


<h3>Value</h3>

<p>List with the following elements:
</p>

<dl>
<dt><code>x</code></dt><dd><p>The vector of covariate values <code>x0</code> at which the local likelihood is fit.</p>
</dd>
<dt><code>eta</code></dt><dd><p>The vector of estimated dependence parameters of the same length as <code>x0</code>.</p>
</dd>
<dt><code>nu</code></dt><dd><p>The scalar value of the estimated (or provided) second copula parameter.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># simulate data
family &lt;- 5 # Frank copula
n &lt;- 1000
x &lt;- runif(n) # covariate values
eta_fun &lt;- function(x) 2*cos(12*pi*x) # copula dependence parameter
eta_true &lt;- eta_fun(x)
par_true &lt;- BiCopEta2Par(family, eta = eta_true)
udata &lt;- VineCopula::BiCopSim(n, family=family,
                              par = par_true$par)

# local likelihood estimation
x0 &lt;- seq(min(x), max(x), len = 100)
band &lt;- .02
system.time({
  eta_hat &lt;- CondiCopLocFit(u1 = udata[,1], u2 = udata[,2],
                            family = family, x = x, x0 = x0, band = band)
})

# custom optimization routine using stats::optim (gradient-free)
my_optim &lt;- function(obj) {
  opt &lt;- stats::optim(par = obj$par, fn = obj$fn, method = "Nelder-Mead")
  return(opt$par[1]) # always return constant term, even if degree &gt; 0
}
system.time({
  eta_hat2 &lt;- CondiCopLocFit(u1 = udata[,1], u2 = udata[,2],
                             family = family, x = x, x0 = x0, band = band,
                             optim_fun = my_optim)
})

plot(x0, BiCopEta2Tau(family, eta = eta_fun(x0)), type = "l",
     xlab = expression(x), ylab = expression(tau(x)))
lines(x0, BiCopEta2Tau(family, eta = eta_hat$eta), col = "red")
lines(x0, BiCopEta2Tau(family, eta = eta_hat2$eta), col = "blue")
legend("bottomright", fill = c("black", "red", "blue"),
       legend = c("True", "optim_default", "Nelder-Mead"))
</code></pre>

<hr>
<h2 id='CondiCopLocFun'>Create a <span class="pkg">TMB</span> local likelihood function.</h2><span id='topic+CondiCopLocFun'></span>

<h3>Description</h3>

<p>Wraps a call to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondiCopLocFun(u1, u2, family, x, x0, wgt, degree = 1, eta, nu)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CondiCopLocFun_+3A_u1">u1</code></td>
<td>
<p>Vector of first uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_u2">u2</code></td>
<td>
<p>Vector of second uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family to use.  See <code><a href="#topic+ConvertPar">ConvertPar()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_x">x</code></td>
<td>
<p>Vector of observed covariate values.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_x0">x0</code></td>
<td>
<p>Scalar covariate value at which to evaluate the local likelihood.  Does not have to be a subset of <code>x</code>.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_wgt">wgt</code></td>
<td>
<p>Vector of positive kernel weights.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_degree">degree</code></td>
<td>
<p>Integer specifying the polynomial order of the local likelihood function.  Currently only 0 and 1 are supported.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_eta">eta</code></td>
<td>
<p>Value of the copula dependence parameter.  Scalar or vector of length two, depending on whether <code>degree</code> is 0 or 1.</p>
</td></tr>
<tr><td><code id="CondiCopLocFun_+3A_nu">nu</code></td>
<td>
<p>Value of the other copula parameter.  Scalar or vector of same length as <code>u1</code>.  Ignored if <code>family != 2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list as returned by a call to <code><a href="TMB.html#topic+MakeADFun">TMB::MakeADFun()</a></code>.  In particular, this contains elements <code>fun</code> and <code>gr</code> for the <em>negative</em> local likelihood and its gradient with respect to <code>eta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the following example shows how to create
# an unconditional copula likelihood function

# simulate data
n &lt;- 1000 # sample size
family &lt;- 2 # Student-t copula
rho &lt;- runif(1, -1, 1) # unconditional dependence parameter
nu &lt;- runif(1, 4, 20)# degrees of freedom parameter
udata &lt;- VineCopula::BiCopSim(n, family = family, par = rho, par2 = nu)

# create likelihood function

# parameter conversion: equivalent to BiCopPar2Eta(family = 2, ...)
rho2eta &lt;- function(rho) .5 * log((1+rho)/(1-rho))
nll_obj &lt;- CondiCopLocFun(u1 = udata[,1], u2 = udata[,2], family = family,
                          x = rep(0, n), x0 = 0, # centered covariate x - x0 == 0
                          wgt = rep(1, n), # unweighted
                          degree = 0, # zero-order fit
                          eta = c(rho2eta(rho), 0),
                          nu = nu)

# likelihood function: recall that TMB requires a _negative_ ll
stucop_lik &lt;- function(rho) {
  -nll_obj$fn(c(rho2eta(rho), 0))
}

# compare to VineCopula.
rhovec &lt;- runif(50, -1, 1)
system.time({
  ll1 &lt;- sapply(rhovec, stucop_lik) # LocalCop
})
system.time({
  ll2 &lt;- sapply(rhovec, function(rho) {
    # VineCopula
    sum(log(VineCopula::BiCopPDF(u1 = udata[,1], u2 = udata[,2],
                                 family = family,
                                 par = rho, par2 = nu)))
  })
})

# difference between the two
range(ll1 - ll2)
</code></pre>

<hr>
<h2 id='CondiCopSelect'>Local likelihood bandwidth and/or family selection.</h2><span id='topic+CondiCopSelect'></span>

<h3>Description</h3>

<p>Selects among a set of bandwidths and/or copula families the one which maximizes the cross-validated local likelihood.  See <code><a href="#topic+CondiCopLikCV">CondiCopLikCV()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CondiCopSelect(
  u1,
  u2,
  family,
  x,
  xind = 100,
  degree = 1,
  nu,
  kernel = KernEpa,
  band,
  nband = 6,
  optim_fun,
  cv_all = FALSE,
  full_out = TRUE,
  cl = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CondiCopSelect_+3A_u1">u1</code></td>
<td>
<p>Vector of first uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_u2">u2</code></td>
<td>
<p>Vector of second uniform response.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_family">family</code></td>
<td>
<p>Vector of integers specifying the family set.  See <code><a href="#topic+ConvertPar">ConvertPar()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_x">x</code></td>
<td>
<p>Vector of observed covariate values.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_xind">xind</code></td>
<td>
<p>Specification of <code>xind</code> for each bandwidth.  Can be a scalar integer, a vector of <code>nband</code> integers, or a list of <code>nband</code> vectors of integers.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_degree">degree</code></td>
<td>
<p>Integer specifying the polynomial order of the local likelihood function.  Currently only 0 and 1 are supported.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_nu">nu</code></td>
<td>
<p>Optional vector of fixed <code>nu</code> parameter for each family.  If missing or <code>NA</code> get estimated from the data (if required)</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_kernel">kernel</code>, <code id="CondiCopSelect_+3A_optim_fun">optim_fun</code>, <code id="CondiCopSelect_+3A_cl">cl</code></td>
<td>
<p>See <code><a href="#topic+CondiCopLocFit">CondiCopLocFit()</a></code>.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_band">band</code></td>
<td>
<p>Vector of positive numbers specifying the bandwidth value set.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_nband">nband</code></td>
<td>
<p>If <code>band</code> is missing, automatically choose <code>nband</code> bandwidth values spanning the range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_cv_all">cv_all</code></td>
<td>
<p>If <code>FALSE</code>, evaluate the CV likelihood at only the leave-one-out observations specified by <code>xind</code>.  Otherwise, interpolate the leave-one-out estimates of eta to all values in <code>x</code>, and evaluate the CV likelihood at all observations.</p>
</td></tr>
<tr><td><code id="CondiCopSelect_+3A_full_out">full_out</code></td>
<td>
<p>Logical; whether or not to output all fitted models or just the selected family/bandwidth combination.  See <strong>Value</strong>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>full_out = FALSE</code>, a list with elements <code>family</code> and <code>bandwidth</code> containing the selected value of each.  Otherwise, a list with the following elements:
</p>

<dl>
<dt><code>cv</code></dt><dd><p>A data frame with <code style="white-space: pre;">&#8288;nBF = length(band) x length(family)&#8288;</code> rows and columns named <code>family</code>, <code>band</code>, and <code>cv</code> containing the cross-validated likelihood evaluated at each combination of bandwidth and family values.</p>
</dd>
<dt><code>x</code></dt><dd><p>The sorted values of <code>x</code>.</p>
</dd>
<dt><code>eta</code></dt><dd><p>A <code style="white-space: pre;">&#8288;length(x) x nBF&#8288;</code> matrix of eta estimates, the columns of which are in the same order as the rows of <code>cv</code>.</p>
</dd>
<dt><code>nu</code></dt><dd><p>A vector of length <code>nBF</code> second copula parameters, with zero if they don't exist.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># simulate data
set.seed(123)
family &lt;- 5 # Frank copula
n &lt;- 1000
x &lt;- runif(n) # covariate values
eta_fun &lt;- function(x) 2*cos(12*pi*x) # copula dependence parameter
eta_true &lt;- eta_fun(x)
par_true &lt;- BiCopEta2Par(family, eta = eta_true)
udata &lt;- VineCopula::BiCopSim(n, family=family,
                              par = par_true$par)

# bandwidth and family selection
bandset &lt;- c(.01, .04, .1) # bandwidth set
famset &lt;- c(2, 5) # family set
n_loo &lt;- 100 # number of leave-one-out observations in CV likelihood calculation
system.time({
  cvsel &lt;- CondiCopSelect(u1= udata[,1], u2 = udata[,2],
                          x = x, family = famset, band = bandset,
                          xind = n_loo)
})

# compare estimates to true value
xseq &lt;- cvsel$x
famsel &lt;- cvsel$cv$family
bandsel &lt;- cvsel$cv$band
etasel &lt;- cvsel$eta
clrs &lt;- c("red", "blue", "green4")
names(clrs) &lt;- bandset

plot_fun &lt;- function(fam) {
  nband &lt;- length(bandset)
  if(fam == 2) {
    famind &lt;- 1:nband
    main &lt;- "Student-t Copula"
  } else {
    famind &lt;- nband+1:nband
    main &lt;- "Frank Copula"
  }
  plot(xseq, BiCopEta2Tau(family, eta = eta_fun(xseq)),
       type = "l", lwd = 2, ylim = c(-.5, .5),
       xlab = expression(x), ylab = expression(tau(x)),
       main = main)
  for(ii in famind) {
    lines(xseq, BiCopEta2Tau(fam, eta = etasel[,ii]),
          col = clrs[as.character(bandsel[ii])], lwd = 1)
  }
  legend("bottomright", fill = clrs,
         legend = paste0("band_", bandsel[famind],
                         " = ", signif(cvsel$cv$cv[famind], 3)))
}

oldpar &lt;- par(mfrow = c(1,2))
plot_fun(2)
plot_fun(5)
par(oldpar)
</code></pre>

<hr>
<h2 id='ConvertPar'>Conversions between various bivariate copula parametrizations.</h2><span id='topic+ConvertPar'></span><span id='topic+BiCopEta2Par'></span><span id='topic+BiCopPar2Eta'></span><span id='topic+BiCopEta2Tau'></span><span id='topic+BiCopTau2Eta'></span>

<h3>Description</h3>

<p>Conversions between various bivariate copula parametrizations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BiCopEta2Par(family, eta, eta2 = 0)

BiCopPar2Eta(family, par, par2 = 0)

BiCopEta2Tau(family, eta, eta2 = 0)

BiCopTau2Eta(family, tau)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ConvertPar_+3A_family">family</code></td>
<td>
<p>An integer defining the bivariate copula family to use.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="ConvertPar_+3A_eta">eta</code>, <code id="ConvertPar_+3A_eta2">eta2</code></td>
<td>
<p>Vector of parameters on the <code>eta</code> scale.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="ConvertPar_+3A_par">par</code>, <code id="ConvertPar_+3A_par2">par2</code></td>
<td>
<p>Vector of parameters on the <code>par</code> scale.</p>
</td></tr>
<tr><td><code id="ConvertPar_+3A_tau">tau</code></td>
<td>
<p>Vector of parameters on the <code>tau</code> scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The copula family integer codes are identical to those of the <span class="pkg">VineCopula</span> package. Currently, the following families are implemented:
</p>

<dl>
<dt>1</dt><dd><p>Gaussian copula.</p>
</dd>
<dt>2</dt><dd><p>Student-t copula.</p>
</dd>
<dt>3</dt><dd><p>Clayton copula.</p>
</dd>
<dt>4</dt><dd><p>Gumbel copula.</p>
</dd>
<dt>5</dt><dd><p>Frank copula.</p>
</dd>
<dt>13</dt><dd><p>Clayton copula &ndash; rotated 180 degrees.</p>
</dd>
<dt>14</dt><dd><p>Gumbel copula &ndash; rotated 180 degrees.</p>
</dd>
<dt>23</dt><dd><p>Clayton copula &ndash; rotated 90 degrees.</p>
</dd>
<dt>24</dt><dd><p>Gumbel copula &ndash; rotated 90 degrees.</p>
</dd>
<dt>33</dt><dd><p>Clayton copula &ndash; rotated 270 degrees.</p>
</dd>
<dt>34</dt><dd><p>Gumbel copula &ndash; rotated 270 degrees.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Vector of converted parameters.
</p>

<hr>
<h2 id='KernFun'>Local likelihood kernel functions.</h2><span id='topic+KernFun'></span><span id='topic+KernEpa'></span><span id='topic+KernGaus'></span><span id='topic+KernBeta'></span><span id='topic+KernBiQuad'></span><span id='topic+KernTriAng'></span>

<h3>Description</h3>

<p>Local likelihood kernel functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernEpa(t)

KernGaus(t)

KernBeta(t, par = 0.5)

KernBiQuad(t)

KernTriAng(t)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernFun_+3A_t">t</code></td>
<td>
<p>Vector of distances from mode of kernel.</p>
</td></tr>
<tr><td><code id="KernFun_+3A_par">par</code></td>
<td>
<p>Shape parameter for Beta kernel (positive scalar).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Describe kernels here.
</p>


<h3>Value</h3>

<p>Vector of kernel weights.
</p>

<hr>
<h2 id='KernWeight'>Calculate local likelihood kernel weights.</h2><span id='topic+KernWeight'></span>

<h3>Description</h3>

<p>Calculate local likelihood kernel weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KernWeight(x, x0, band, kernel = KernEpa, band_type = "constant")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="KernWeight_+3A_x">x</code></td>
<td>
<p>Vector of observed covariate values.</p>
</td></tr>
<tr><td><code id="KernWeight_+3A_x0">x0</code></td>
<td>
<p>Scalar covariate value at which local likelihood estimation is performed.</p>
</td></tr>
<tr><td><code id="KernWeight_+3A_band">band</code></td>
<td>
<p>Kernel bandwidth parameter (positive scalar).  See <strong>Details.</strong></p>
</td></tr>
<tr><td><code id="KernWeight_+3A_kernel">kernel</code></td>
<td>
<p>Kernel function to use.  Should accept a numeric vector parameter and return a non-negative numeric vector of the same length.  See <code><a href="#topic+KernFun">KernFun()</a></code>.</p>
</td></tr>
<tr><td><code id="KernWeight_+3A_band_type">band_type</code></td>
<td>
<p>A character string specifying the type of bandwidth: either &quot;constant&quot; or &quot;variable&quot;.  See <strong>Details</strong>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the constant bandwidth of size <code>band = h</code>, the weights are calculated as
</p>
<div class="sourceCode"><pre>wgt = kernel((x-x0) / h) / h
</pre></div>
<p>where <code>kernel</code> is the kernel function.  For bandwidth type &quot;variable&quot;, a fixed fraction <code>band</code> of observations is used, i.e,
</p>
<div class="sourceCode"><pre>h = sort( abs(x-x0) )[ floor(band*length(x)) ]
</pre></div>


<h3>Value</h3>

<p>A vector of nonnegative kernel weights of the same length as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sort(runif(20))
x0 &lt;- runif(1, min = min(x), max= max(x))
KernWeight(x, x0, band=0.3, kernel = KernEpa, band_type = "constant")
KernWeight(x, x0, band=0.3, kernel = KernEpa, band_type = "variable")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
