<!DOCTYPE html><html lang="en"><head><title>Help for package speakeasyR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {speakeasyR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster'><p>SpeakEasy 2 community detection</p></a></li>
<li><a href='#cluster_genes'><p>Cluster a gene expression matrix</p></a></li>
<li><a href='#knn_graph'><p>K-nearest neighbors graph</p></a></li>
<li><a href='#order_nodes'><p>Group nodes by community</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Fast and Robust Multi-Scale Graph Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>A graph community detection algorithm that aims to be performant
    on large graphs and robust, returning consistent results across runs.
    SpeakEasy 2 (SE2), the underlying algorithm, is described in Chris Gaiteri,
    David R. Connell &amp; Faraz A. Sultan et al. (2023)
    &lt;<a href="https://doi.org/10.1186%2Fs13059-023-03062-0">doi:10.1186/s13059-023-03062-0</a>&gt;. The core algorithm is written in 'C',
    providing speed and keeping the memory requirements low. This implementation
    can take advantage of multiple computing cores without increasing memory
    usage. SE2 can detect community structure across scales, making it a good
    choice for biological data, which often has hierarchical structure. Graphs
    can be passed to the algorithm as adjacency matrices using base 'R'
    matrices, the 'Matrix' library, 'igraph' graphs, or any data that can be
    coerced into a matrix.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, scRNAseq, SummarizedExperiment, knitr, rmarkdown,
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SpeakEasy-2/speakeasyR">https://github.com/SpeakEasy-2/speakeasyR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SpeakEasy-2/speakeasyR/issues">https://github.com/SpeakEasy-2/speakeasyR/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>arpack (optional)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-24 22:18:21 UTC; voidee</td>
</tr>
<tr>
<td>Author:</td>
<td>David Connell <a href="https://orcid.org/0000-0002-4841-6756"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Chris Gaiteri [cph] (Author of original SpeakEasy 2 algorithm.),
  Gábor Csárdi [cph, ctb] (Author of igraph C library.),
  Tamás Nepusz [cph, ctb] (Author of igraph C library.),
  Szabolcs Horvát [cph, ctb] (Author of igraph C library.),
  Vincent Traag [cph, ctb] (Author of igraph C library.),
  Fabio Zanini [cph, ctb] (Author of igraph C library.),
  Daniel Noom [cph, ctb] (Author of igraph C library.),
  The igraph development team [cph] (Copyright holder of igraph C
    library.),
  Free Software Foundation, Inc. [cph] (Copyright holder of GPL
    licenses.),
  Ross Ihaka [cph, ctb] (Author of Mathlib.),
  The R Development Core Team [cph] (Copyright holder of Mathlib.),
  Royal Statistical Society [cph] (Copyright holder of Mathlib.),
  The R Core Team [cph] (Copyright holder of Mathlib.),
  The Regents of the University of California [cph] (Copyright holder of
    stdlib's qsort.),
  Timothy Davis [cph, ctb] (Author of CXSPARSE (cs).),
  Richard Lehoucq [cph, ctb] (Author of arpack.),
  Danny Scrensen [cph, ctb] (Author of arpack and lapack.),
  Phuong Vu [cph, ctb] (Author of arpack.),
  Chao Yang [cph, ctb] (Author of arpack.),
  Allan Cornet [cph, ctb] (Author of arpack.),
  Sylvestre Ledru [cph, ctb] (Author of arpack.),
  Chao Yang [cph, ctb] (Author of arpack.),
  Rice University [cph] (Copyright holder of arpack.),
  Scilab Enterprises [cph] (Copyright holder of arpack-ng.),
  Melissa O'Neill [cph, ctb] (Author of PCG random number generator.),
  Steven Johnson [cph, ctb] (Author of ax_pthread.),
  Daniel G. [cph, ctb] (Author of ax_pthread.),
  Marc Stevens [cph, ctb] (Author of ax_pthread.),
  Minh Nguyen [cph, ctb] (Author of ax_pthread.),
  Elliot Paquette [cph, ctb] (Contributor to igraph.),
  Pascal Pons [cph, ctb] (Contributor to igraph.),
  Jordi Hermoso [cph, ctb] (Contributor to arpack.),
  Sébastien Fabbro [cph, ctb] (Contributor to arpack.),
  Shinya Tasaki [cph, ctb] (Provided code used in the gene clustering
    example.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Connell &lt;david32@dcon.addy.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-24 22:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster'>SpeakEasy 2 community detection</h2><span id='topic+cluster'></span>

<h3>Description</h3>

<p>Group nodes into communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster(
  graph,
  discard_transient = 3,
  independent_runs = 10,
  max_threads = 0,
  seed = 0,
  target_clusters = 0,
  target_partitions = 5,
  subcluster = 1,
  min_clust = 5,
  verbose = FALSE,
  is_directed = "detect"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_+3A_graph">graph</code></td>
<td>
<p>A graph or adjacency matrix in a form that can be converted to
<code>matrix</code> or <code>Matrix::dgCMatrix</code> using an <code>as.matrix()</code> coercion method.
Accepted types include <code>matrix</code>, <code>dgCMatrix</code>, <code>ngCMatrix</code>, and
<code>igraph::graph</code>s.</p>
</td></tr>
<tr><td><code id="cluster_+3A_discard_transient">discard_transient</code></td>
<td>
<p>The number of partitions to discard before tracking.</p>
</td></tr>
<tr><td><code id="cluster_+3A_independent_runs">independent_runs</code></td>
<td>
<p>How many runs SpeakEasy2 should perform.</p>
</td></tr>
<tr><td><code id="cluster_+3A_max_threads">max_threads</code></td>
<td>
<p>The maximum number of threads to use. By default this is
the same as the number of independent runs. If max_threads is greater than
or equal to the number of processing cores, all cores may run. If
max_threads is less than the number of cores, at most max_threads cores
will run.</p>
</td></tr>
<tr><td><code id="cluster_+3A_seed">seed</code></td>
<td>
<p>Random seed to use for reproducible results. SpeakEasy2 uses a
different random number generator than R, but if the seed is not
explicitly set, R's random number generator is used create one. Because of
this, setting R's RNG will also cause reproducible results.</p>
</td></tr>
<tr><td><code id="cluster_+3A_target_clusters">target_clusters</code></td>
<td>
<p>The number of random initial labels to use.</p>
</td></tr>
<tr><td><code id="cluster_+3A_target_partitions">target_partitions</code></td>
<td>
<p>Number of partitions to find per independent run.</p>
</td></tr>
<tr><td><code id="cluster_+3A_subcluster">subcluster</code></td>
<td>
<p>Depth of clustering. If greater than 1, perform recursive
clustering.</p>
</td></tr>
<tr><td><code id="cluster_+3A_min_clust">min_clust</code></td>
<td>
<p>Smallest clusters to recursively cluster. If subcluster not
set to a value greater than 1, this has no effect.</p>
</td></tr>
<tr><td><code id="cluster_+3A_verbose">verbose</code></td>
<td>
<p>Whether to provide additional information about the
clustering or not.</p>
</td></tr>
<tr><td><code id="cluster_+3A_is_directed">is_directed</code></td>
<td>
<p>Whether the graph should be treated as directed or not.
By default, if the graph is symmetric it is treated as undirected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A membership vector. If subclustering, returns a matrix with number
of rows equal to the number of recursive clustering. Each row is the
membership at different hierarchical scales, such that the last rows are
the highest resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("igraph")) {
  graph &lt;- igraph::graph.famous("zachary")
  membership &lt;- cluster(graph, max_threads = 2)
}
</code></pre>

<hr>
<h2 id='cluster_genes'>Cluster a gene expression matrix</h2><span id='topic+cluster_genes'></span>

<h3>Description</h3>

<p>Use the Speakeasy 2 community detection algorithm to cluster genes based on
their gene expression. A gene coexpression network is created by taking
correlating the input gene expression matrix to genes that tend to be
expressed together. This matrix is then clustered to find gene modules.
</p>
<p>Note: This is intended for gene expression sampled from bulk sequencing.
Samples from single cell sequencing may work but will need to be
preprocessed due to the greater noise-to-signal ratio. See the speakeasyR
vignette for an example of single cell preprocessing. For more information
about working with single cell data see:
Malte D Luecken &amp; Fabian J Theis (2019) Current Best Practices in
Single‐cell Rna‐seq Analysis: a Tutorial, Molecular Systems Biology.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster_genes(
  gene_expression,
  k = NULL,
  discard_transient = 3,
  independent_runs = 10,
  max_threads = 0,
  seed = 0,
  target_clusters = 0,
  target_partitions = 5,
  subcluster = 1,
  min_clust = 5,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster_genes_+3A_gene_expression">gene_expression</code></td>
<td>
<p>a matrix of gene expression data with data from
multiple samples (in the form genes x samples).</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_k">k</code></td>
<td>
<p>number of neighbors to include if converting to a k-nearest
neighbor graph. Should be a non-negative integer less than the number of
genes. If this value is not set the raw GCN is clustered. The kNN graph is
a sparse directed graph with binary edges between a node and it's most
similar k neighbors. Conversion to a kNN graph can provide good clustering
results much faster than using the full graph in cases with a large number
of genes.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_discard_transient">discard_transient</code></td>
<td>
<p>The number of partitions to discard before tracking.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_independent_runs">independent_runs</code></td>
<td>
<p>How many runs SpeakEasy2 should perform.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_max_threads">max_threads</code></td>
<td>
<p>The maximum number of threads to use. By default this is
the same as the number of independent runs. If max_threads is greater than
or equal to the number of processing cores, all cores may run. If
max_threads is less than the number of cores, at most max_threads cores
will run.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_seed">seed</code></td>
<td>
<p>Random seed to use for reproducible results. SpeakEasy2 uses a
different random number generator than R, but if the seed is not
explicitly set, R's random number generator is used create one. Because of
this, setting R's RNG will also cause reproducible results.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_target_clusters">target_clusters</code></td>
<td>
<p>The number of random initial labels to use.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_target_partitions">target_partitions</code></td>
<td>
<p>Number of partitions to find per independent run.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_subcluster">subcluster</code></td>
<td>
<p>Depth of clustering. If greater than 1, perform recursive
clustering.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_min_clust">min_clust</code></td>
<td>
<p>Smallest clusters to recursively cluster. If subcluster not
set to a value greater than 1, this has no effect.</p>
</td></tr>
<tr><td><code id="cluster_genes_+3A_verbose">verbose</code></td>
<td>
<p>Whether to provide additional information about the
clustering or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A membership vector. If subclustering, returns a matrix with number
of rows equal to the number of recursive clustering. Each row is the
membership at different hierarchical scales, such that the last rows are
the highest resolution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set parameters
set.seed(123) # For reproducibility
ngene &lt;- 200
nsample &lt;- 1000
ncluster &lt;- 5

# Create a function to simulate gene expression data
simulate_gene_expression &lt;- function(ngene, nsample, ncluster) {
  # Initialize the expression matrix
  expr_matrix &lt;- matrix(0, nrow = ngene, ncol = nsample)

  # Create cluster centers for genes
  cluster_centers &lt;- matrix(rnorm(ncluster * nsample, mean = 5, sd = 2),
    nrow = ncluster, ncol = nsample
  )

  # Assign genes to clusters
  gene_clusters &lt;- sample(1:ncluster, ngene, replace = TRUE)

  for (i in 1:ngene) {
    cluster &lt;- gene_clusters[i]
    expr_matrix[i, ] &lt;- cluster_centers[cluster, ] +
      rnorm(nsample, mean = 0, sd = 1)
  }

  return(list(expr_matrix = expr_matrix, gene_clusters = gene_clusters))
}

# Simulate the data
simulated_data &lt;- simulate_gene_expression(ngene, nsample, ncluster)

# Extract the expression matrix and gene clusters
expr_matrix &lt;- simulated_data$expr_matrix
gene_clusters &lt;- simulated_data$gene_clusters

# Cluster and test quality of results
modules &lt;- cluster_genes(expr_matrix, max_threads = 2)
</code></pre>

<hr>
<h2 id='knn_graph'>K-nearest neighbors graph</h2><span id='topic+knn_graph'></span>

<h3>Description</h3>

<p>Create a directed sparse graph with edges to each nodes <code>k</code> nearest
neighbors. Nearness is calculated as the inverse of the euclidean distance
between two columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_graph(mat, k, weighted = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knn_graph_+3A_mat">mat</code></td>
<td>
<p>A matrix to be compared column-by-column.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_k">k</code></td>
<td>
<p>How many nearest neighbors to collect.</p>
</td></tr>
<tr><td><code id="knn_graph_+3A_weighted">weighted</code></td>
<td>
<p>By default, a binary edge is made between a node and each of
it's <code>k</code> closest nodes. Set <code>weighted</code> to <code>TRUE</code> to weigh each edge by the
similarity (inverse of euclidean distance).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A directed sparse adjacency matrix with <code>k * ncol(mat)</code> nonzero
edges. Each column has k edges connected to the k closest columns (not
including itself).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple random graph
mat &lt;- matrix(runif(100) &gt; 0.75, nrow = 5)
knn_graph(mat, 3)

## Don't run because loading data is slow.

if (requireNamespace("scRNAseq") &amp;&amp;
  requireNamespace("SummarizedExperiment")) {
  # Single Cell RNA data
  library(Matrix)

  expression &lt;- scRNAseq::FletcherOlfactoryData()
  cell_types &lt;- expression$cluster_id

  ## Filter genes with low expression. Remove any genes with less than 10
  ## cells with with any reads.
  counts &lt;- SummarizedExperiment::assay(expression, "counts")
  indices &lt;- rowSums(counts &gt; 0) &gt; 10
  counts &lt;- counts[indices, ]

  ## Normalize by shifted logarithm
  target &lt;- median(colSums(counts))
  size_factors &lt;- colSums(counts) / target
  counts_norm &lt;- log(t(t(counts) / size_factors + 1))

  ## Dimension reduction
  counts_norm &lt;- t(prcomp(t(counts_norm), scale. = FALSE)$x)[1:50, ]

  adj &lt;- knn_graph(counts_norm, 10)
}

</code></pre>

<hr>
<h2 id='order_nodes'>Group nodes by community</h2><span id='topic+order_nodes'></span>

<h3>Description</h3>

<p>Reorders the graph to group nodes in the same community together.
Useful for viewing community structure of a graph using a <code>heatmap()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>order_nodes(graph, membership, is_directed = "detect")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="order_nodes_+3A_graph">graph</code></td>
<td>
<p>The graph or adjacency matrix the membership vector was created
for.</p>
</td></tr>
<tr><td><code id="order_nodes_+3A_membership">membership</code></td>
<td>
<p>A vector or matrix listing node communities. The output
from <code><a href="#topic+cluster">cluster()</a></code> (should also work for other clustering
algorithms that return membership in the same format).</p>
</td></tr>
<tr><td><code id="order_nodes_+3A_is_directed">is_directed</code></td>
<td>
<p>Whether the graph should be treated as directed or not.
By default, if the graph is symmetric it is treated as undirected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Communities are ordered by size, so nodes in the largest community are
first. Within a community, nodes are order by highest-to-lowest degree.
</p>
<p>If membership is in matrix form (the output from <code><a href="#topic+cluster">cluster()</a></code>
with <code>subcluster</code> &gt; 1) a matrix is returned with the indices for level one
in row 1 and level n in row n. Each row reorders the communities of the
previous row such that, at the second level, nodes are still grouped by
the first level communities. This allows the hierarchical structure to be
viewed.
</p>
<p>See vignette for a multilevel example.
</p>


<h3>Value</h3>

<p>An index vector or matrix. The number of rows are equal to the value
of <code>subcluster</code> passed to <code><a href="#topic+cluster">cluster()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("igraph")) {
  n_nodes &lt;- 100
  n_types &lt;- 3
  # Mixing parameter (likelihood an edge is between communities).
  mu &lt;- 0.3
  pref &lt;- matrix(mu, n_types, n_types)
  diag(pref) &lt;- 1 - mu
  g &lt;- igraph::sample_pref(n_nodes, types = n_types, pref.matrix = pref)
  # Use a dense matrix representation to easily apply index.
  adj &lt;- as(g[], "matrix")
  memb &lt;- speakeasyR::cluster(adj, seed = 222, max_threads = 2)
  ordering &lt;- speakeasyR::order_nodes(adj, memb)
  
  heatmap(adj[ordering, ordering], scale = "none", Rowv = NA, Colv = NA)
  
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
