<!DOCTYPE html><html><head><title>Help for package RtsEva</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RtsEva}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ArdecheStMartin'><p>Simulated river discharge of the Ardeche river at Saint Martin d'Ardeche</p></a></li>
<li><a href='#check_timeseries'><p>Check if all years in a time series are present</p></a></li>
<li><a href='#computeAnnualMaxima'><p>computeAnnualMaxima</p></a></li>
<li><a href='#computeMonthlyMaxima'><p>computeMonthlyMaxima</p></a></li>
<li><a href='#DanubeVienna'><p>Simulated river discharge of the Danube river at Vienna</p></a></li>
<li><a href='#declustpeaks'><p>declustpeaks</p></a></li>
<li><a href='#EbroZaragoza'><p>Simulated river discharge of the Ebro river at Zaragoza</p></a></li>
<li><a href='#empdis'><p>empdis: Empirical Distribution Function</p></a></li>
<li><a href='#empdisl'><p>Empirical Distribution Function</p></a></li>
<li><a href='#findMax'><p>findMax</p></a></li>
<li><a href='#initPercentiles'><p>Initialize Percentiles</p></a></li>
<li><a href='#max_daily_value'><p>Max Daily Value Function</p></a></li>
<li><a href='#RhoneLyon'><p>Simulated river discharge of the Rhone river at Lyon</p></a></li>
<li><a href='#tsEasyParseNamedArgs'><p>Parse named arguments and assign values to a predefined argument structure.</p></a></li>
<li><a href='#tsEstimateAverageSeasonality'><p>Estimate Average Seasonality</p></a></li>
<li><a href='#tsEvaChangepts'><p>Change point detection in time series</p></a></li>
<li><a href='#tsEvaComputeReturnLevelsGEV'><p>tsEvaComputeReturnLevelsGEV</p></a></li>
<li><a href='#tsEvaComputeReturnLevelsGEVFromAnalysisObj'><p>tsEvaComputeReturnLevelsGEVFromAnalysisObj</p></a></li>
<li><a href='#tsEvaComputeReturnLevelsGPD'><p>tsEvaComputeReturnLevelsGPD</p></a></li>
<li><a href='#tsEvaComputeReturnLevelsGPDFromAnalysisObj'><p>tsEvaComputeReturnLevelsGPDFromAnalysisObj</p></a></li>
<li><a href='#tsEvaComputeReturnPeriodsGEV'><p>tsEvaComputeReturnPeriodsGEV</p></a></li>
<li><a href='#tsEvaComputeReturnPeriodsGPD'><p>tsEvaComputeReturnPeriodsGPD</p></a></li>
<li><a href='#tsEvaComputeRLsGEVGPD'><p>tsEvaComputeRLsGEVGPD</p></a></li>
<li><a href='#tsEvaComputeTimeRP'><p>tsEvaComputeTimeRP</p></a></li>
<li><a href='#tsEvaDetrendTimeSeries'><p>Detrend a Time Series</p></a></li>
<li><a href='#tsEvaFillSeries'><p>Fill missing values in a time series using a moving average approach.</p></a></li>
<li><a href='#tsEvaFindTrendThreshold'><p>Find Trend Threshold</p></a></li>
<li><a href='#tsEvaNanRunnigBlowTh'><p>Calculate the return period of low flow based on a threshold and window size</p></a></li>
<li><a href='#tsEvaNanRunningMean'><p>Calculate the running mean of a time series with NaN handling</p></a></li>
<li><a href='#tsEvaNanRunningPercentiles'><p>tsEvaNanRunningPercentiles</p></a></li>
<li><a href='#tsEvaNanRunningStatistics'><p>tsEvaNanRunningStatistics</p></a></li>
<li><a href='#tsEvaNanRunningVariance'><p>Calculate the running variance of a time series with NaN handling</p></a></li>
<li><a href='#TsEvaNs'><p>TsEvaNs Function</p></a></li>
<li><a href='#tsEvaPlotAllRLevelsGEV'><p>tsEvaPlotAllRLevelsGEV</p></a></li>
<li><a href='#tsEvaPlotAllRLevelsGPD'><p>tsEvaPlotAllRLevelsGPD</p></a></li>
<li><a href='#tsEvaPlotGEVImageSc'><p>tsEvaPlotGEVImageSc</p></a></li>
<li><a href='#tsEvaPlotGEVImageScFromAnalysisObj'><p>tsEvaPlotGEVImageScFromAnalysisObj</p></a></li>
<li><a href='#tsEvaPlotGPDImageSc'><p>tsEvaPlotGPDImageSc</p></a></li>
<li><a href='#tsEvaPlotGPDImageScFromAnalysisObj'><p>tsEvaPlotGPDImageScFromAnalysisObj</p></a></li>
<li><a href='#tsEvaPlotReturnLevelsGEV'><p>tsEvaPlotReturnLevelsGEV</p></a></li>
<li><a href='#tsEvaPlotReturnLevelsGEVFromAnalysisObj'><p>tsEvaPlotReturnLevelsGEVFromAnalysisObj</p></a></li>
<li><a href='#tsEvaPlotReturnLevelsGPD'><p>tsEvaPlotReturnLevelsGPD</p></a></li>
<li><a href='#tsEvaPlotReturnLevelsGPDFromAnalysisObj'><p>tsEvaPlotReturnLevelsGPDFromAnalysisObj</p></a></li>
<li><a href='#tsEvaPlotSeriesTrendStdDevFromAnalyisObj'><p>tsEvaPlotSeriesTrendStdDevFromAnalyisObj</p></a></li>
<li><a href='#tsEvaPlotTransfToStat'><p>tsEvaPlotTransfToStat</p></a></li>
<li><a href='#tsEvaPlotTransfToStatFromAnalysisObj'><p>tsEvaPlotTransfToStatFromAnalysisObj</p></a></li>
<li><a href='#tsEvaRunningMeanTrend'><p>Calculate the running mean trend of a time series</p></a></li>
<li><a href='#tsEvaSampleData'><p>tsEvaSampleData Function</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryMultiplicativeSeasonality'><p>tsEvaTransformSeriesToStationaryMultiplicativeSeasonality</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryPeakTrend'><p>tsEvaTransformSeriesToStationaryPeakTrend</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryTrendAndChangepts'><p>Transform Time Series to Stationary Trend and Change Points</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile'><p>Transform Time Series to Stationary Trend and Change Points with Confidence Intervals</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryTrendOnly'><p>tsEvaTransformSeriesToStationaryTrendOnly</p></a></li>
<li><a href='#tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile'><p>tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile</p></a></li>
<li><a href='#tsEvaTransformSeriesToStatSeasonal_ciPercentile'><p>tsEvaTransformSeriesToStatSeasonal_ciPercentile</p></a></li>
<li><a href='#tsEVstatistics'><p>tsEVstatistics</p></a></li>
<li><a href='#tsGetNumberPerYear'><p>tsGetNumberPerYear</p></a></li>
<li><a href='#tsGetPOT'><p>tsGetPOT Function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Performs the Transformed-Stationary Extreme Values Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alois Tilloy &lt;alois.tilloy@ec.europa.eu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Adaptation of the 'Matlab' 'tsEVA' toolbox developed by Lorenzo Mentaschi
    available here:
    <a href="https://github.com/menta78/tsEva">https://github.com/menta78/tsEva</a>. It contains an implementation of the
    Transformed-Stationary (TS) methodology for non-stationary extreme 
    value Analysis (EVA) as described in Mentaschi et al. (2016) &lt;<a href="https://doi.org/10.5194%2Fhess-20-3527-2016">doi:10.5194/hess-20-3527-2016</a>&gt;.  
    In synthesis this approach consists in:
    (i) transforming a non-stationary time series into a
    stationary one to which the stationary extreme value theory can be applied; and
    (ii) reverse-transforming the result into a non-stationary extreme
    value distribution.
    'RtsEva' offers several options for trend estimation (mean, extremes, seasonal)
    and contains multiple plotting functions displaying different aspects
    of the non-stationarity of extremes.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/devtools">https://github.com/r-lib/devtools</a>,
<a href="https://github.com/Alowis/RtsEva">https://github.com/Alowis/RtsEva</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, evd, ggplot2, lubridate, methods, moments, POT, pracma,
scales, texmex, tsibble, xts, grDevices, stats, rlang,
changepoint</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ncdf4, rmarkdown, rnaturalearth, terra, testthat (&ge;
3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Alowis/RtsEva/issues">https://github.com/Alowis/RtsEva/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-21 12:11:13 UTC; tilloal</td>
</tr>
<tr>
<td>Author:</td>
<td>Alois Tilloy <a href="https://orcid.org/0000-0002-5881-0642"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-24 12:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='ArdecheStMartin'>Simulated river discharge of the Ardeche river at Saint Martin d'Ardeche</h2><span id='topic+ArdecheStMartin'></span>

<h3>Description</h3>

<p>A time series of simulated river discharge of the Ardeche river close
to its confluence with the Rhone (longitude = 4.658 \ latitude = 44.258) from
1951 to 2020. Time series extracted from the HERA dataset:
https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95.
The Ard√®che is Mediterranean river mostly known for tourism due
to its scenic gorges, but floods and droughts can impact the
local economy and environment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ArdecheStMartin)
</code></pre>


<h3>Format</h3>

<p>Two column dataframe:
#' </p>

<ul>
<li><p> time (POSIXct timestamp with 6-hourly resolution)
</p>
</li>
<li><p> Q (6-houry mean discharge in cubic meter per second)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95">https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95</a>
</p>

<hr>
<h2 id='check_timeseries'>Check if all years in a time series are present</h2><span id='topic+check_timeseries'></span>

<h3>Description</h3>

<p>This function checks if all years specified in a given time series are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_timeseries(timeseries, yro)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_timeseries_+3A_timeseries">timeseries</code></td>
<td>
<p>A time series object.</p>
</td></tr>
<tr><td><code id="check_timeseries_+3A_yro">yro</code></td>
<td>
<p>A vector specifying the start and end years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value indicating whether all years in the time series are present.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_data &lt;- seq(as.POSIXct("2000-01-01"), as.POSIXct("2004-12-31"), by = "year")
check_timeseries(ts_data, c(2000, 2004))
# Output: TRUE

check_timeseries(ts_data, c(2000, 2005))
# Output: FALSE

</code></pre>

<hr>
<h2 id='computeAnnualMaxima'>computeAnnualMaxima</h2><span id='topic+computeAnnualMaxima'></span>

<h3>Description</h3>

<p><code>computeAnnualMaxima</code> is a function that computes the annual maxima of
a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeAnnualMaxima(timeAndSeries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeAnnualMaxima_+3A_timeandseries">timeAndSeries</code></td>
<td>
<p>A matrix or data frame containing the time stamps and
series values. The first column should contain the time stamps and the
second column should contain the series values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the annual maximum values, their corresponding dates,
and their indices.
</p>

<dl>
<dt><code>annualMax</code></dt><dd><p>A numeric vector of annual maximum values.</p>
</dd>
<dt><code>annualMaxDate</code></dt><dd><p>A vector of dates corresponding to the annual
maximum values.</p>
</dd>
<dt><code>annualMaxIndx</code></dt><dd><p>A vector of indices indicating the positions
of the annual maximum values in the original time series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
computeAnnualMaxima(timeAndSeries)
</code></pre>

<hr>
<h2 id='computeMonthlyMaxima'>computeMonthlyMaxima</h2><span id='topic+computeMonthlyMaxima'></span>

<h3>Description</h3>

<p><code>computeMonthlyMaxima</code> is a function that computes the monthly maxima
of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeMonthlyMaxima(timeAndSeries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeMonthlyMaxima_+3A_timeandseries">timeAndSeries</code></td>
<td>
<p>A data frame containing the time stamps and series values.
The first column should contain the time stamps,
and the second column should contain the series values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the monthly maxima, corresponding dates, and indices.
</p>

<dl>
<dt><code>monthlyMax</code></dt><dd><p>A vector of the monthly maximum values.</p>
</dd>
<dt><code>monthlyMaxDate</code></dt><dd><p>A vector of the dates corresponding to the monthly maximum values.</p>
</dd>
<dt><code>monthlyMaxIndx</code></dt><dd><p>A vector of the indices of the monthly maximum values in the original series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
computeMonthlyMaxima(timeAndSeries)
</code></pre>

<hr>
<h2 id='DanubeVienna'>Simulated river discharge of the Danube river at Vienna</h2><span id='topic+DanubeVienna'></span>

<h3>Description</h3>

<p>A time series of simulated river discharge of the Danube river in Vienna
(longitude = 16.64 \ latitude = 48.13) from 1951 to 2020.
Time series extracted from the HERA dataset:
https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95.
The Danube is the longest river in the EU and is an important waterway for
international trade, connecting several countries in Central and Eastern Europe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DanubeVienna)
</code></pre>


<h3>Format</h3>

<p>Two column dataframe:
#' </p>

<ul>
<li><p> time (POSIXct timestamp with 6-hourly resolution)
</p>
</li>
<li><p> Q (6-houry mean discharge in cubic meter per second)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95">https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95</a>
</p>

<hr>
<h2 id='declustpeaks'>declustpeaks</h2><span id='topic+declustpeaks'></span>

<h3>Description</h3>

<p><code>declustpeaks</code> is a function that takes in a data vector, minimum peak distance, minimum run distance, and a threshold value.
It finds peaks in the data vector based on the minimum peak distance and threshold value.
It then declusters the peaks based on the minimum run distance and threshold value.
The function returns a data frame with information about the peaks, including the peak value,
start and end indices, duration, and cluster information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>declustpeaks(data, minpeakdistance = 10, minrundistance = 7, qt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="declustpeaks_+3A_data">data</code></td>
<td>
<p>A numeric vector representing the data.</p>
</td></tr>
<tr><td><code id="declustpeaks_+3A_minpeakdistance">minpeakdistance</code></td>
<td>
<p>An integer specifying the minimum distance between peaks.</p>
</td></tr>
<tr><td><code id="declustpeaks_+3A_minrundistance">minrundistance</code></td>
<td>
<p>An integer specifying the minimum distance between runs.</p>
</td></tr>
<tr><td><code id="declustpeaks_+3A_qt">qt</code></td>
<td>
<p>A numeric value representing the threshold for peak detection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with information about the peaks, including:
</p>

<dl>
<dt><code>Q</code></dt><dd><p>the peak value</p>
</dd>
<dt><code>max</code></dt><dd><p>max time index</p>
</dd>
<dt><code>start</code></dt><dd><p>start time index</p>
</dd>
<dt><code>end</code></dt><dd><p>end time index</p>
</dd>
<dt><code>dur</code></dt><dd><p>duration</p>
</dd>
<dt><code>cluster</code></dt><dd><p>cluster information </p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- c(1, 2, 3, 4, 5, 4, 3, 2, 1)
declustpeaks(data, minpeakdistance = 2, minrundistance = 2, qt = 3)

</code></pre>

<hr>
<h2 id='EbroZaragoza'>Simulated river discharge of the Ebro river at Zaragoza</h2><span id='topic+EbroZaragoza'></span>

<h3>Description</h3>

<p>A time series of simulated river discharge of the Ebro river at
Zaragoza (longitude = -0.825 \ latitude = 41.608) from
1951 to 2020. Time series extracted from the HERA dataset:
https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95.
The Ebro is Spain's longest river, with low and high water levels
alternating throughout the year, influenced by winter snowmelt and summer
evaporation/human usage. The river is vital for agriculture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EbroZaragoza)
</code></pre>


<h3>Format</h3>

<p>Two column dataframe:
#' </p>

<ul>
<li><p> time (POSIXct timestamp with 6-hourly resolution)
</p>
</li>
<li><p> Q (6-houry mean discharge in cubic meter per second)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95">https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95</a>
</p>

<hr>
<h2 id='empdis'>empdis: Empirical Distribution Function</h2><span id='topic+empdis'></span>

<h3>Description</h3>

<p><code>empdis</code> is a function that calculates the empirical
distribution function for a given dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empdis(x, nyr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empdis_+3A_x">x</code></td>
<td>
<p>A numeric vector representing the dataset.</p>
</td></tr>
<tr><td><code id="empdis_+3A_nyr">nyr</code></td>
<td>
<p>An integer representing the number of years in the dataset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing:
</p>

<dl>
<dt><code>emp.RP</code></dt><dd><p>empirical return period</p>
</dd>
<dt><code>haz.RP</code></dt><dd><p>Hazen return period</p>
</dd>
<dt><code>cun.RP</code></dt><dd><p>Cunnane return period</p>
</dd>
<dt><code>gumbel</code></dt><dd><p>Gumbel values</p>
</dd>
<dt><code>emp.f</code></dt><dd><p>empirical cumulative density</p>
</dd>
<dt><code>emp.hazen</code></dt><dd><p>Hazen cumulative density</p>
</dd>
<dt><code>emp.cunnan</code></dt><dd><p>Cunnane cumulative density</p>
</dd>
<dt><code>Q</code></dt><dd><p>original data</p>
</dd>
<dt><code>timestamp</code></dt><dd><p>time component</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 2, 3, 4, 5)
nyr &lt;- 5
empdis(x, nyr)

</code></pre>

<hr>
<h2 id='empdisl'>Empirical Distribution Function</h2><span id='topic+empdisl'></span>

<h3>Description</h3>

<p>This function calculates the empirical distribution function for a given dataset,
with a focus on low values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empdisl(x, nyr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empdisl_+3A_x">x</code></td>
<td>
<p>A numeric vector or matrix representing the discharge values.</p>
</td></tr>
<tr><td><code id="empdisl_+3A_nyr">nyr</code></td>
<td>
<p>An integer representing the number of years.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following columns:
</p>

<dl>
<dt><code>emp.RP</code></dt><dd><p>Empirical return period</p>
</dd>
<dt><code>haz.RP</code></dt><dd><p>Hazen return period</p>
</dd>
<dt><code>gumbel</code></dt><dd><p>Gumbel frequency</p>
</dd>
<dt><code>emp.f</code></dt><dd><p>Empirical frequency</p>
</dd>
<dt><code>emp.hazen</code></dt><dd><p>Empirical Hazen frequency</p>
</dd>
<dt><code>Q</code></dt><dd><p>Discharge values</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(10, 20, 30, 40, 50)
nyr &lt;- 5
empdisl(x, nyr)

</code></pre>

<hr>
<h2 id='findMax'>findMax</h2><span id='topic+findMax'></span>

<h3>Description</h3>

<p><code>findMax</code> is a function that takes a subset of a vector
and returns the index of the maximum value in that subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findMax(subIndxs, srs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findMax_+3A_subindxs">subIndxs</code></td>
<td>
<p>A numeric vector representing the subset of indices to consider.</p>
</td></tr>
<tr><td><code id="findMax_+3A_srs">srs</code></td>
<td>
<p>A vector of numerical data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The index of the maximum value in the subset.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>srs &lt;- c(10, 20, 30, 40, 50)
findMax(c(1, 3, 5),srs)
#result is 5.
</code></pre>

<hr>
<h2 id='initPercentiles'>Initialize Percentiles</h2><span id='topic+initPercentiles'></span>

<h3>Description</h3>

<p>This function calculates percentiles for a given dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initPercentiles(subsrs, percentM, percent, percentP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initPercentiles_+3A_subsrs">subsrs</code></td>
<td>
<p>The input dataset.</p>
</td></tr>
<tr><td><code id="initPercentiles_+3A_percentm">percentM</code></td>
<td>
<p>The percentile for the lower bound.</p>
</td></tr>
<tr><td><code id="initPercentiles_+3A_percent">percent</code></td>
<td>
<p>The percentile for the middle bound.</p>
</td></tr>
<tr><td><code id="initPercentiles_+3A_percentp">percentP</code></td>
<td>
<p>The percentile for the upper bound.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the calculated percentiles and probabilities.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaNanRunningPercentiles">tsEvaNanRunningPercentiles()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
initPercentiles(series, 89, 90, 91)
</code></pre>

<hr>
<h2 id='max_daily_value'>Max Daily Value Function</h2><span id='topic+max_daily_value'></span>

<h3>Description</h3>

<p>This function converts a 6-hourly time series to a daily time series and
calculates the maximum value for each day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_daily_value(timeseries)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_daily_value_+3A_timeseries">timeseries</code></td>
<td>
<p>A time series with a 6-hourly resolution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the daily maximum values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage:
timeseries &lt;- ArdecheStMartin
max_daily_value(timeseries)
</code></pre>

<hr>
<h2 id='RhoneLyon'>Simulated river discharge of the Rhone river at Lyon</h2><span id='topic+RhoneLyon'></span>

<h3>Description</h3>

<p>A time series of simulated river discharge of the Rhone river close
to its confluence with the Saone (longitude = 4.891 \ latitude = 45.772) from
1951 to 2020. Time series extracted from the HERA dataset:
https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95.
The Rh√¥ne is France's most powerful river,characterized by a significant
seasonal variation in flow rates. The Rh√¥ne River is crucial for
transportation, hydropower generation, and irrigation in the region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(RhoneLyon)
</code></pre>


<h3>Format</h3>

<p>Two column dataframe:
#' </p>

<ul>
<li><p> time (POSIXct timestamp with 6-hourly resolution)
</p>
</li>
<li><p> Q (6-houry mean discharge in cubic meter per second)
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95">https://data.jrc.ec.europa.eu/dataset/a605a675-9444-4017-8b34-d66be5b18c95</a>
</p>

<hr>
<h2 id='tsEasyParseNamedArgs'>Parse named arguments and assign values to a predefined argument structure.</h2><span id='topic+tsEasyParseNamedArgs'></span>

<h3>Description</h3>

<p>This function takes a list of named arguments and assigns their values to a predefined argument structure.
The argument structure is a list with named elements representing the available arguments.
If an argument is present in the list of named arguments, its value is assigned to the corresponding element in the argument structure.
If an argument is not present, its value in the argument structure remains unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEasyParseNamedArgs(args, argStruct)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEasyParseNamedArgs_+3A_args">args</code></td>
<td>
<p>A list of named arguments.</p>
</td></tr>
<tr><td><code id="tsEasyParseNamedArgs_+3A_argstruct">argStruct</code></td>
<td>
<p>A list representing the argument structure with named elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified argument structure with values assigned from the list of named arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>args &lt;- list(arg1 = 10, arg2 = "tanargue")
argStruct &lt;- list(arg1 = 0, arg2 = "", arg3 = TRUE)
modifiedArgStruct &lt;- tsEasyParseNamedArgs(args, argStruct)
modifiedArgStruct

</code></pre>

<hr>
<h2 id='tsEstimateAverageSeasonality'>Estimate Average Seasonality</h2><span id='topic+tsEstimateAverageSeasonality'></span>

<h3>Description</h3>

<p>This function estimates the average seasonality of a time series based on the given parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEstimateAverageSeasonality(timeStamps, seasonalitySeries, timeWindow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEstimateAverageSeasonality_+3A_timestamps">timeStamps</code></td>
<td>
<p>The time stamps of the time series.</p>
</td></tr>
<tr><td><code id="tsEstimateAverageSeasonality_+3A_seasonalityseries">seasonalitySeries</code></td>
<td>
<p>The series representing the seasonality.</p>
</td></tr>
<tr><td><code id="tsEstimateAverageSeasonality_+3A_timewindow">timeWindow</code></td>
<td>
<p>The time window used for averaging the seasonality.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the estimated regime and the seasonality series:
</p>

<dl>
<dt><code>regime</code></dt><dd><p>The estimated regime of the time series.</p>
</dd>
<dt><code>Seasonality</code></dt><dd><p>A data frame containing the average and varying seasonality series.</p>
</dd>
<dt><code>averageSeasonalitySeries</code></dt><dd><p>The average seasonality series.</p>
</dd>
<dt><code>varyingSeasonalitySeries</code></dt><dd><p>The varying seasonality series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series  &lt;- ArdecheStMartin[,2]
timeWindow &lt;- 30*365  # 30 years
rs &lt;- tsEvaDetrendTimeSeries(timeStamps, series, timeWindow)
nRunMn &lt;- rs@nRunMn
cat("computing trend seasonality ...\n")
seasonalitySeries &lt;- rs@detrendSeries
result &lt;- tsEstimateAverageSeasonality(timeStamps, seasonalitySeries, timeWindow=rs@nRunMn)
plot(result$regime, type = "l", xlab = "Day", ylab = "Regime", main = "Estimated Regime")
plot(result$Seasonality$averageSeasonalitySeries, type = "l", xlab = "Day",
ylab = "Seasonality", main = "Average Seasonality")
plot(result$Seasonality$varyingSeasonalitySeries, type = "l", xlab = "Day",
ylab = "Seasonality", main = "Varying Seasonality")
</code></pre>

<hr>
<h2 id='tsEvaChangepts'>Change point detection in time series</h2><span id='topic+tsEvaChangepts'></span>

<h3>Description</h3>

<p>This function applies the PELT method for change point detection in a time series.
It returns the mean and variance of the series segments between change points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaChangepts(series, timeWindow, timeStamps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaChangepts_+3A_series">series</code></td>
<td>
<p>A numeric vector representing the time series.</p>
</td></tr>
<tr><td><code id="tsEvaChangepts_+3A_timewindow">timeWindow</code></td>
<td>
<p>An integer specifying the minimum length of segments.</p>
</td></tr>
<tr><td><code id="tsEvaChangepts_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of timestamps corresponding to the series data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt><code>trend</code></dt><dd><p>A numeric vector of the same length as series, with each segment between change points filled with its mean value</p>
</dd>
<dt><code>variance</code></dt><dd><p>A numeric vector of the same length as series, with each segment between change points filled with its variance</p>
</dd>
<dt><code>changepoints</code></dt><dd><p>A vector of timestamps at which change points were detected</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
timeWindow &lt;- 30*365 # 30 years
result &lt;- tsEvaChangepts(series, timeWindow, timeStamps)
plot(timeAndSeries, type = "l")
lines(timeStamps,result$trend,col=2)
points(timeStamps[result$changepoints], result$trend[result$changepoints], col = "red")

</code></pre>

<hr>
<h2 id='tsEvaComputeReturnLevelsGEV'>tsEvaComputeReturnLevelsGEV</h2><span id='topic+tsEvaComputeReturnLevelsGEV'></span>

<h3>Description</h3>

<p><code>tsEvaComputeReturnPeriodsGPD</code>is a function that calculates the return
levels for a Generalized Extreme Value (GEV) distribution given the GEV
parameters and their standard errors. The return periods are specified in a
time unit that corresponds to the size of the time segments for
evaluating the maxima.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnLevelsGEV(
  epsilon,
  sigma,
  mu,
  epsilonStdErr,
  sigmaStdErr,
  muStdErr,
  returnPeriodsInDts
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_mu">mu</code></td>
<td>
<p>The location parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_epsilonstderr">epsilonStdErr</code></td>
<td>
<p>The standard error of the shape parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_sigmastderr">sigmaStdErr</code></td>
<td>
<p>The standard error of the scale parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_mustderr">muStdErr</code></td>
<td>
<p>The standard error of the location parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEV_+3A_returnperiodsindts">returnPeriodsInDts</code></td>
<td>
<p>The return periods expressed in the
corresponding time unit. For example, while working on yearly</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>returnLevels</code></dt><dd><p>A matrix of return levels corresponding to the specified return periods.</p>
</dd>
<dt><code>returnLevelsErr</code></dt><dd><p>A matrix of standard errors for the return levels.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+empdis">empdis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with some sample data
epsilon &lt;- c(0.1)
sigma &lt;- c(2.3)
mu &lt;- c(1.3)
epsilonStdErr &lt;- c(0.01)
sigmaStdErr &lt;- c(0.11)
muStdErr &lt;- c(0.011)
returnPeriodsInDts &lt;- c( 5, 10, 20, 50)
results &lt;- tsEvaComputeReturnLevelsGEV(epsilon, sigma, mu, epsilonStdErr,
sigmaStdErr, muStdErr, returnPeriodsInDts)
head(results$returnLevels)
head(results$returnLevelsErr)
</code></pre>

<hr>
<h2 id='tsEvaComputeReturnLevelsGEVFromAnalysisObj'>tsEvaComputeReturnLevelsGEVFromAnalysisObj</h2><span id='topic+tsEvaComputeReturnLevelsGEVFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaComputeReturnLevelsGEVFromAnalysisObj</code>is a function that calculates the return levels for a Generalized Extreme Value (GEV) distribution using the parameters obtained from a non-stationary extreme value analysis. It supports non-stationary analysis by considering different parameters for each time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnLevelsGEVFromAnalysisObj(
  nonStationaryEvaParams,
  returnPeriodsInYears,
  timeIndex = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnLevelsGEVFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The parameters obtained from a non-stationary extreme value analysis.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEVFromAnalysisObj_+3A_returnperiodsinyears">returnPeriodsInYears</code></td>
<td>
<p>The return periods expressed in years.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGEVFromAnalysisObj_+3A_timeindex">timeIndex</code></td>
<td>
<p>Temporal index corresponding to the time step on which compute the GEV RLs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>returnLevels</code></dt><dd><p>A matrix of return levels corresponding to the specified return periods.</p>
</dd>
<dt><code>returnLevelsErr</code></dt><dd><p>A matrix of standard errors for the return levels.</p>
</dd>
<dt><code>returnLevelsErrFit</code></dt><dd><p>A matrix of standard errors for the return levels obtained from fitting the non-stationary model.</p>
</dd>
<dt><code>returnLevelsErrTransf</code></dt><dd><p>A matrix of standard errors for the return levels obtained from the transformed data.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGEV">tsEvaComputeReturnLevelsGEV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with some sample data
nonStationaryEvaParams &lt;- list(list(
parameters = list(
  epsilon = 0.1,
  sigma = c(2.1, 2.2, 2.3),
  mu = c(1.1, 1.2, 1.3),
  timeHorizonStart=as.POSIXct("1951-01-01"),
  timeHorizonEnd=as.POSIXct("2020-12-31"),
  nPeaks=90

),
paramErr = list(
  epsilonErr = 0.01,
  sigmaErr = c(0.11, 0.12, 0.13),
  muErr = c(0.011, 0.012, 0.013)
),NA
)
)
returnPeriodsInYears &lt;- c(1, 5, 10, 20, 50)
timeIndex=1
results &lt;- tsEvaComputeReturnLevelsGEVFromAnalysisObj(nonStationaryEvaParams, returnPeriodsInYears)
head(results$returnLevels)
</code></pre>

<hr>
<h2 id='tsEvaComputeReturnLevelsGPD'>tsEvaComputeReturnLevelsGPD</h2><span id='topic+tsEvaComputeReturnLevelsGPD'></span>

<h3>Description</h3>

<p>#' <code>tsEvaComputeReturnLevelsGPD</code>is a function that
compute the return levels for a Generalized Pareto Distribution (GPD)
using the parameters of the distribution and their standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnLevelsGPD(
  epsilon,
  sigma,
  threshold,
  epsilonStdErr,
  sigmaStdErr,
  thresholdStdErr,
  nPeaks,
  sampleTimeHorizon,
  returnPeriods
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_threshold">threshold</code></td>
<td>
<p>The threshold parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_epsilonstderr">epsilonStdErr</code></td>
<td>
<p>The standard error of the shape parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_sigmastderr">sigmaStdErr</code></td>
<td>
<p>The standard error of the scale parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_thresholdstderr">thresholdStdErr</code></td>
<td>
<p>The standard error of the threshold parameter.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_npeaks">nPeaks</code></td>
<td>
<p>The number of peaks used to estimate the parameters.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_sampletimehorizon">sampleTimeHorizon</code></td>
<td>
<p>The time horizon of the sample in the same units as the return periods (e.g., years).</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPD_+3A_returnperiods">returnPeriods</code></td>
<td>
<p>The return periods for which to compute the return levels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sampleTimeHorizon and returnPeriods must be in the same units, e.g. years
</p>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>returnLevels</code></dt><dd><p>A vector of return levels corresponding to the specified return periods.</p>
</dd>
<dt><code>returnLevelsErr</code></dt><dd><p>A vector of standard errors for the return levels.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Example usage with some sample data
epsilon &lt;- c(0.1)
sigma &lt;- c(2.3)
threshold &lt;- c(1.3)
epsilonStdErr &lt;- c(0.01)
sigmaStdErr &lt;- c(0.11)
thresholdStdErr &lt;- c(0.011)
returnPeriodsInDts &lt;- c( 5, 10, 20, 50)
nPeaks=70
SampleTimeHorizon=70
results &lt;- tsEvaComputeReturnLevelsGPD(epsilon, sigma, threshold, epsilonStdErr,
sigmaStdErr, thresholdStdErr, nPeaks, SampleTimeHorizon, returnPeriodsInDts)
head(results$returnLevels)
head(results$returnLevelsErr)
</code></pre>

<hr>
<h2 id='tsEvaComputeReturnLevelsGPDFromAnalysisObj'>tsEvaComputeReturnLevelsGPDFromAnalysisObj</h2><span id='topic+tsEvaComputeReturnLevelsGPDFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaComputeReturnLevelsGPDFromAnalysisObj</code> is a function that calculates the return levels for a Generalized Pareto Distribution (GPD) using the parameters obtained from an analysis object. It takes into account non-stationarity by considering time-varying parameters and their associated standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnLevelsGPDFromAnalysisObj(
  nonStationaryEvaParams,
  returnPeriodsInYears,
  timeIndex = -1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnLevelsGPDFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The non-stationary parameters obtained from the analysis object.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPDFromAnalysisObj_+3A_returnperiodsinyears">returnPeriodsInYears</code></td>
<td>
<p>The return periods for which to compute the return levels, expressed in years.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnLevelsGPDFromAnalysisObj_+3A_timeindex">timeIndex</code></td>
<td>
<p>Temporal index corresponding to the time step on which compute the GEV RLs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt><code>returnLevels</code></dt><dd><p>A vector of return levels corresponding to the specified return periods.</p>
</dd>
<dt><code>returnLevelsErrFit</code></dt><dd><p>A vector of standard errors for the return levels estimated based on the fit.</p>
</dd>
<dt><code>returnLevelsErrTransf</code></dt><dd><p>A vector of standard errors for the return levels estimated based on the transformed parameters.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGPD">tsEvaComputeReturnLevelsGPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with some sample data
nonStationaryEvaParams &lt;- list(NA,list(
 parameters = list(
   epsilon = 0.1,
   sigma = c(2.1, 2.2, 2.3),
   threshold = c(1.1, 1.2, 1.3),
   timeHorizonStart=as.POSIXct("1951-01-01"),
   timeHorizonEnd=as.POSIXct("2020-12-31"),
   nPeaks=90

 ),
 paramErr = list(
   epsilonErr = 0.01,
   sigmaErr = c(0.11, 0.12, 0.13),
   thresholdErr = c(0.011, 0.012, 0.013)
 )
)
)
returnPeriodsInYears &lt;- c(1, 5, 10, 20, 50)
timeIndex=1
results &lt;- tsEvaComputeReturnLevelsGPDFromAnalysisObj(nonStationaryEvaParams, returnPeriodsInYears)
head(results$returnLevels)
</code></pre>

<hr>
<h2 id='tsEvaComputeReturnPeriodsGEV'>tsEvaComputeReturnPeriodsGEV</h2><span id='topic+tsEvaComputeReturnPeriodsGEV'></span>

<h3>Description</h3>

<p><code>tsEvaComputeReturnPeriodsGEV</code>is a function that computes the return
periods of a set of observations (can be Annual maxima or others)
for a Generalized Extreme Value (GEV)
distribution, given the GEV parameters and their standard error.
The return levels represent the values of annual maxima
with a certain probability, while the return periods indicate the average
time between exceedances of those threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnPeriodsGEV(epsilon, sigma, mu, BlockMax)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnPeriodsGEV_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGEV_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGEV_+3A_mu">mu</code></td>
<td>
<p>The location parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGEV_+3A_blockmax">BlockMax</code></td>
<td>
<p>A vector containing the block maxima data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>GevPseudo</code></dt><dd><p>A matrix of pseudo observations obtained from
the GEV distribution for each annual extreme at every time step.</p>
</dd>
<dt><code>returnPeriods</code></dt><dd><p>A matrix of return periods corresponding to
the pseudo observations.</p>
</dd>
<dt><code>PseudoObs</code></dt><dd><p>The pseudo observation corresponding to
the maximum value used in the computation.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+empdis">empdis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example usage with some sample data
epsilon &lt;- 0.1
sigma &lt;- 2.2
mu &lt;- 1.3
BlockMax &lt;- c(10, 20, 30, 40, 50)

results &lt;- tsEvaComputeReturnPeriodsGEV(epsilon, sigma, mu, BlockMax)
head(results$GevPseudo)
head(results$returnPeriods)
head(results$PseudoObs)
</code></pre>

<hr>
<h2 id='tsEvaComputeReturnPeriodsGPD'>tsEvaComputeReturnPeriodsGPD</h2><span id='topic+tsEvaComputeReturnPeriodsGPD'></span>

<h3>Description</h3>

<p><code>tsEvaComputeReturnPeriodsGPD</code>is a function that computes the return
periods of a set of observations (peaks) for a
Generalized Pareto Distribution (GPD), given the GPD parameters,
threshold, peaks data, and sample time horizon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeReturnPeriodsGPD(
  epsilon,
  sigma,
  threshold,
  peaks,
  nPeaks,
  peaksID,
  sampleTimeHorizon
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value for the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_peaks">peaks</code></td>
<td>
<p>A vector containing the peak values.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_npeaks">nPeaks</code></td>
<td>
<p>The number of peak values.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_peaksid">peaksID</code></td>
<td>
<p>An identifier for each peak value.</p>
</td></tr>
<tr><td><code id="tsEvaComputeReturnPeriodsGPD_+3A_sampletimehorizon">sampleTimeHorizon</code></td>
<td>
<p>The time horizon of the sample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>GpdPseudo</code></dt><dd><p>A matrix of pseudo observations obtained from
the GPD for each peak value at every time step.</p>
</dd>
<dt><code>returnPeriods</code></dt><dd><p>A matrix of return periods
corresponding to the pseudo observations.</p>
</dd>
<dt><code>PseudoObs</code></dt><dd><p>A data frame containing the pseudo
observations and their corresponding identifiers.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+empdis">empdis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage with some sample data
epsilon &lt;- 0.1
sigma &lt;- 2.2
threshold &lt;- 1.3
peaks &lt;- c(10, 20, 30, 40, 50)
nPeaks=5
peaksID=c(230,550,999,1540,3012)
SampleTimeHorizon = 70

results &lt;- tsEvaComputeReturnPeriodsGPD(epsilon, sigma, threshold, peaks,
nPeaks, peaksID, SampleTimeHorizon)
head(results$GpdPseudo)
head(results$returnPeriods)
head(results$PseudoObs)
</code></pre>

<hr>
<h2 id='tsEvaComputeRLsGEVGPD'>tsEvaComputeRLsGEVGPD</h2><span id='topic+tsEvaComputeRLsGEVGPD'></span>

<h3>Description</h3>

<p><code>tsEvaComputeRLsGEVGPD</code> is a function that calculates the return levels
and their associated errors for a Generalized Extreme Value (GEV)
and Generalized Pareto (GPD) distribution using the parameters obtained
from a non-stationary extreme value analysis.
It supports non-stationary analysis by considering different parameters
for each time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeRLsGEVGPD(nonStationaryEvaParams, RPgoal, timeIndex, trans = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeRLsGEVGPD_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The parameters obtained from a non-stationary
extreme value analysis.</p>
</td></tr>
<tr><td><code id="tsEvaComputeRLsGEVGPD_+3A_rpgoal">RPgoal</code></td>
<td>
<p>The target return period for which the return levels are computed.</p>
</td></tr>
<tr><td><code id="tsEvaComputeRLsGEVGPD_+3A_timeindex">timeIndex</code></td>
<td>
<p>The index at which the time-varying analysis should be estimated.</p>
</td></tr>
<tr><td><code id="tsEvaComputeRLsGEVGPD_+3A_trans">trans</code></td>
<td>
<p>A character string indicating the transformation to be applied
to the data before fitting the EVD. default value is NA, corresponding
to no transformation. Currently only the &quot;rev&quot; for reverse transformation is
implemented.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>Fit</code></dt><dd><p>A character string indicating whether the EVD could be
fitted to the data (&quot;No fit&quot;) or the EVD was successfully fitted to the data (&quot;Fitted&quot;).</p>
</dd>
<dt><code>ReturnLevels</code></dt><dd><p>A data frame containing the target
return period (<code>ReturnPeriod</code>), GEV return level (<code>GEV</code>), GPD return level (<code>GPD</code>),
GEV return level error (<code>errGEV</code>), and GPD return level error (<code>errGPD</code>) for
the specified time index.</p>
</dd>
<dt><code>Params</code></dt><dd><p>A list containing the GEV and GPD parameters for the
specified time index, including their standard errors.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGEV">tsEvaComputeReturnLevelsGEV</a></code>, <code><a href="#topic+tsEvaComputeReturnLevelsGPD">tsEvaComputeReturnLevelsGPD</a></code>
</p>

<hr>
<h2 id='tsEvaComputeTimeRP'>tsEvaComputeTimeRP</h2><span id='topic+tsEvaComputeTimeRP'></span>

<h3>Description</h3>

<p><code>tsEvaComputeTimeRP</code>is a function that calculates the return period
of a given event for GEV and GPD distributions at a given time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaComputeTimeRP(params, RPiGEV, RPiGPD)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaComputeTimeRP_+3A_params">params</code></td>
<td>
<p>A data frame containing the following parameters:
</p>

<dl>
<dt><code>epsilonGEV</code></dt><dd><p>Shape parameter for the Generalized Extreme Value
(GEV) distribution.</p>
</dd>
<dt><code>muGEV</code></dt><dd><p>Location parameter for the GEV distribution.</p>
</dd>
<dt><code>sigmaGEV</code></dt><dd><p>Scale parameter for the GEV distribution.</p>
</dd>
<dt><code>epsilonGPD</code></dt><dd><p>Shape parameter for the Generalized Pareto
(GPD) distribution.</p>
</dd>
<dt><code>thresholdGPD</code></dt><dd><p>Threshold parameter for the GPD distribution.</p>
</dd>
<dt><code>sigmaGPD</code></dt><dd><p>Scale parameter for the GPD distribution.</p>
</dd>
<dt><code>nPeaks</code></dt><dd><p>Number of peaks in the sample time horizon.</p>
</dd>
<dt><code>SampleTimeHorizon</code></dt><dd><p>Total number of years in the data sample.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="tsEvaComputeTimeRP_+3A_rpigev">RPiGEV</code></td>
<td>
<p>Value of RP for the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaComputeTimeRP_+3A_rpigpd">RPiGPD</code></td>
<td>
<p>Value of RP for the GPD distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the calculated return period for GEV and GPD distributions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Parameter vector:
params &lt;- t(data.frame(epsilonGEV = 0.2, muGEV = 3, sigmaGEV = 1,
                  epsilonGPD = 0.2, thresholdGPD = 3, sigmaGPD = 1,
                  nPeaks = 70, SampleTimeHorizon = 70))

tsEvaComputeTimeRP(params, RPiGEV = 10, RPiGPD = 10)
</code></pre>

<hr>
<h2 id='tsEvaDetrendTimeSeries'>Detrend a Time Series</h2><span id='topic+tsEvaDetrendTimeSeries'></span>

<h3>Description</h3>

<p>This function detrends a time series by subtracting the trend component from the original series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaDetrendTimeSeries(
  timeStamps,
  series,
  timeWindow,
  percent = NA,
  fast = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaDetrendTimeSeries_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps for the time series.</p>
</td></tr>
<tr><td><code id="tsEvaDetrendTimeSeries_+3A_series">series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="tsEvaDetrendTimeSeries_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the moving window used to calculate the trend.</p>
</td></tr>
<tr><td><code id="tsEvaDetrendTimeSeries_+3A_percent">percent</code></td>
<td>
<p>The percentile value used to calculate the trend for extreme values. Default is NA.</p>
</td></tr>
<tr><td><code id="tsEvaDetrendTimeSeries_+3A_fast">fast</code></td>
<td>
<p>A logical value indicating whether to print additional information. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;tsTrend&quot; with the following components:
</p>

<dl>
<dt><code>originSeries</code></dt><dd><p>The original time series</p>
</dd>
<dt><code>detrendSeries</code></dt><dd><p>The detrended time series</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend component of the time series</p>
</dd>
<dt><code>nRunMn </code></dt><dd><p>The number of data points in the moving window used to calculate the trend</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series  &lt;- ArdecheStMartin[,2]
timeWindow &lt;- 365*30
detrended &lt;- tsEvaDetrendTimeSeries(timeStamps, series, timeWindow)
</code></pre>

<hr>
<h2 id='tsEvaFillSeries'>Fill missing values in a time series using a moving average approach.</h2><span id='topic+tsEvaFillSeries'></span>

<h3>Description</h3>

<p>This function takes a vector of timestamps and a corresponding series with missing values,
and fills the missing values by taking the average of the surrounding values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaFillSeries(timeStamps, series)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaFillSeries_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of timestamps.</p>
</td></tr>
<tr><td><code id="tsEvaFillSeries_+3A_series">series</code></td>
<td>
<p>A vector representing the time series with missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with missing values filled using a moving average approach.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeStamps &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
series &lt;- c(1, 2, NA, 4, 5, NA, 7, 8, NA, 10)
filledSeries &lt;- tsEvaFillSeries(timeStamps, series)
filledSeries

</code></pre>

<hr>
<h2 id='tsEvaFindTrendThreshold'>Find Trend Threshold</h2><span id='topic+tsEvaFindTrendThreshold'></span>

<h3>Description</h3>

<p>This function calculates the optimal trend threshold for a given time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaFindTrendThreshold(series, timeStamps, timeWindow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaFindTrendThreshold_+3A_series">series</code></td>
<td>
<p>The time series data.</p>
</td></tr>
<tr><td><code id="tsEvaFindTrendThreshold_+3A_timestamps">timeStamps</code></td>
<td>
<p>The timestamps corresponding to the time series data.</p>
</td></tr>
<tr><td><code id="tsEvaFindTrendThreshold_+3A_timewindow">timeWindow</code></td>
<td>
<p>The time window for detrending the time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function iterates over different percentiles and calculates the
threshold based on each percentile. It then removes data points below the
threshold and detrends the time series using the specified time window.
The function calculates the correlation between the normalized trend
and the time series and stores the correlation coefficient for each percentile.
It performs a changepoint analysis to determine if there is a significant change
in the correlation coefficients. If a change point is found, the function returns
the percentile corresponding to the change point. If no change point is found,
the function returns the percentile with the highest correlation coefficient.
If there are negative values in the detrended time series,
the function returns the percentile with the fewest negative values.
</p>


<h3>Value</h3>

<p>The trend threshold value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries[,1], "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
timeStamps &lt;- timeAndSeries[,1]
series &lt;- timeAndSeries[,2]
tsEvaFindTrendThreshold(series, timeStamps, timeWindow)

</code></pre>

<hr>
<h2 id='tsEvaNanRunnigBlowTh'>Calculate the return period of low flow based on a threshold and window size</h2><span id='topic+tsEvaNanRunnigBlowTh'></span>

<h3>Description</h3>

<p>This function calculates the return period of low flow for a given time series
based on a threshold and window size. It uses a sliding window approach to
count the number of values below the threshold within each window, and then
calculates the return period based on the proportion of values below the
threshold. Assumes that the input data has a 7 days timestep.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaNanRunnigBlowTh(series, threshold, windowSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaNanRunnigBlowTh_+3A_series">series</code></td>
<td>
<p>The time series data.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunnigBlowTh_+3A_threshold">threshold</code></td>
<td>
<p>The threshold value for low flow.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunnigBlowTh_+3A_windowsize">windowSize</code></td>
<td>
<p>The size of the sliding window.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: &quot;time&quot; representing the time points
corresponding to the sliding windows, and &quot;RP&quot; representing the
calculated return period of low flow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
threshold &lt;- 5
windowSize &lt;- 3
tsEvaNanRunnigBlowTh(series, threshold, windowSize)

</code></pre>

<hr>
<h2 id='tsEvaNanRunningMean'>Calculate the running mean of a time series with NaN handling</h2><span id='topic+tsEvaNanRunningMean'></span>

<h3>Description</h3>

<p>This function calculates the running mean of a time series, taking into account NaN values.
It uses a sliding window approach to calculate the mean, where the window size is specified by the user.
If the number of non-NaN values within the window is greater than a threshold, the mean is calculated.
Otherwise, NaN is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaNanRunningMean(series, windowSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaNanRunningMean_+3A_series">series</code></td>
<td>
<p>The input time series</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningMean_+3A_windowsize">windowSize</code></td>
<td>
<p>The size of the sliding window</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the running mean of the time series
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- c(1,2,NaN,4,5,6,NaN,8,9,4,5,6,7,3,9,1,0,4,5,2)
windowSize &lt;- 3
result &lt;- tsEvaNanRunningMean(series, windowSize)
print(result)

</code></pre>

<hr>
<h2 id='tsEvaNanRunningPercentiles'>tsEvaNanRunningPercentiles</h2><span id='topic+tsEvaNanRunningPercentiles'></span>

<h3>Description</h3>

<p>Computes a running percentile for a given series using a window with a specified size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaNanRunningPercentiles(timeStamps, series, windowSize, percent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaNanRunningPercentiles_+3A_timestamps">timeStamps</code></td>
<td>
<p>The timestamps of the series.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningPercentiles_+3A_series">series</code></td>
<td>
<p>The input series.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningPercentiles_+3A_windowsize">windowSize</code></td>
<td>
<p>The size of the window for the running percentile. Must be greater than or equal to 100.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningPercentiles_+3A_percent">percent</code></td>
<td>
<p>The percent level to which the percentile is computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes a running percentile for a given series using a window with a specified size.
The running percentile is computed by interpolating the percentile value for the requested percentage
based on the quitting values and incoming values in the window.
The function also performs smoothing on the output and calculates the standard error.
</p>
<p>The function uses the following label parameters:
</p>

<dl>
<dt><code>percentDelta</code></dt><dd><p>Delta for the computation of a percentile interval around the requested percentage.
If the windowSize is greater than 2000, percentDelta is set to 1.
If the windowSize is between 1000 and 2000, percentDelta is set to 2.
If the windowSize is between 100 and 1000, percentDelta is set to 5.</p>
</dd>
<dt><code>nLowLimit</code></dt><dd><p>Minimum number of non-NA elements for a window for percentile computation</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the approximated running percentile (rnprcnt) and the standard error (stdError).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series  &lt;- ArdecheStMartin[,2]
windowSize &lt;- 365
percent &lt;- 90
result &lt;- tsEvaNanRunningPercentiles(timeStamps, series, windowSize, percent)
print(result$rnprcnt)
print(result$stdError)

</code></pre>

<hr>
<h2 id='tsEvaNanRunningStatistics'>tsEvaNanRunningStatistics</h2><span id='topic+tsEvaNanRunningStatistics'></span>

<h3>Description</h3>

<p>Returns the moving statistical momentums to the forth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaNanRunningStatistics(series, windowSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaNanRunningStatistics_+3A_series">series</code></td>
<td>
<p>The input time series data.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningStatistics_+3A_windowsize">windowSize</code></td>
<td>
<p>The size of the moving window.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the running variance, running third statistical
momentum, and running fourth statistical momentum for a given time series
data using a moving window approach. The window size determines the number
of observations used to calculate the statistics at each point.
</p>


<h3>Value</h3>

<p>A data frame containing the following running statistics:
</p>

<dl>
<dt><code>rnvar</code></dt><dd><p>running variance</p>
</dd>
<dt><code>rn3mom</code></dt><dd><p>running third statistical momentum</p>
</dd>
<dt><code>rn4mom</code></dt><dd><p>running fourth statistical momentum</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- c(1,2,NaN,4,5,6,NaN,8,9,4,5,6,7,3,9,1,0,4,5,2)
windowSize &lt;- 3
tsEvaNanRunningStatistics(series, windowSize)

</code></pre>

<hr>
<h2 id='tsEvaNanRunningVariance'>Calculate the running variance of a time series with NaN handling</h2><span id='topic+tsEvaNanRunningVariance'></span>

<h3>Description</h3>

<p>This function calculates the running variance of a time series, taking into account NaN values.
The series must be zero-averaged before passing it to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaNanRunningVariance(series, windowSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaNanRunningVariance_+3A_series">series</code></td>
<td>
<p>The time series data.</p>
</td></tr>
<tr><td><code id="tsEvaNanRunningVariance_+3A_windowsize">windowSize</code></td>
<td>
<p>The size of the window used for calculating the running variance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the running variance values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>series &lt;- c(1,2,NaN,4,5,6,NaN,8,9,4,5,6,7,3,9,1,0,4,5,2)
windowSize &lt;- 3
tsEvaNanRunningVariance(series, windowSize)

</code></pre>

<hr>
<h2 id='TsEvaNs'>TsEvaNs Function</h2><span id='topic+TsEvaNs'></span>

<h3>Description</h3>

<p>This function performs non-stationary extreme value analysis (EVA) on a
time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TsEvaNs(
  timeAndSeries,
  timeWindow,
  transfType = "trendPeaks",
  minPeakDistanceInDays = 10,
  seasonalityVar = NA,
  minEventsPerYear = -1,
  gevMaxima = "annual",
  ciPercentile = 90,
  gevType = "GEV",
  evdType = c("GEV", "GPD"),
  tail = "high",
  epy = -1,
  lowdt = 7,
  trans = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TsEvaNs_+3A_timeandseries">timeAndSeries</code></td>
<td>
<p>A data frame containing the timestamp and
corresponding series data.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_timewindow">timeWindow</code></td>
<td>
<p>The time window for analysis.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_transftype">transfType</code></td>
<td>
<p>The transformation type for non-stationary EVA.
It can be one of the following:
</p>

<dl>
<dt><code>trend</code></dt><dd><p>Long-term variations of the timeseries</p>
</dd>
<dt><code>seasonal</code></dt><dd><p>Long-term and seasonal variations of extremes</p>
</dd>
<dt><code>trendCIPercentile</code></dt><dd><p>Long-term variations of extremes using
a specified percentile</p>
</dd>
<dt><code>trendPeaks</code></dt><dd><p>Long-term variations of the peaks</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_minpeakdistanceindays">minPeakDistanceInDays</code></td>
<td>
<p>The minimum peak distance in days.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_seasonalityvar">seasonalityVar</code></td>
<td>
<p>A logical value indicating whether to consider
seasonality in the analysis.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_mineventsperyear">minEventsPerYear</code></td>
<td>
<p>The minimum number of events per year.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_gevmaxima">gevMaxima</code></td>
<td>
<p>The type of maxima for the GEV distribution
(annual or monthly, default is annual).</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_cipercentile">ciPercentile</code></td>
<td>
<p>The percentile value for confidence intervals.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_gevtype">gevType</code></td>
<td>
<p>The type of GEV distribution (GEV or GPD).</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_evdtype">evdType</code></td>
<td>
<p>The type of extreme value distribution (GEV or GPD).</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_tail">tail</code></td>
<td>
<p>The mode of the analysis
(e.g., high for flood peaks or low for drought peaks).</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_epy">epy</code></td>
<td>
<p>The average number of events per year, can be specified by the
user or automatically set according to the tail selected.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_lowdt">lowdt</code></td>
<td>
<p>The temporal resolultion used for low values. default is 7 days.</p>
</td></tr>
<tr><td><code id="TsEvaNs_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD. Can be:
</p>

<dl>
<dt><code>ori</code></dt><dd><p>use of original data</p>
</dd>
<dt><code>rev</code></dt><dd><p>Reversing the data (used for low extremes)</p>
</dd>
<dt><code>inv</code></dt><dd><p>inversing the data (used for low extreme, can lead to unstabilities)</p>
</dd>
<dt><code>lninv</code></dt><dd><p>log of inverse the data (used for low extreme, under development)</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The function takes a time series data and performs non-stationary
EVA using various transformation types and parameters depending
on the input data provided.
Results are returned as a list containing the non-stationary EVA parameters
and the transformed data for stationary EVA
and can be used as input for further analysis.
In particular for the following function
</p>


<h3>Value</h3>

<p>A list containing the results of the non-stationary EVA.
Containing the following components:
</p>

<dl>
<dt><code>nonStationaryEvaParams</code></dt><dd><p>The estimated parameters
for non-stationary EVA.
Parameters include GEV and GPD parameters for each timestep,
confidence intervals, and other statistical measures</p>
</dd>
<dt><code>stationaryTransformData</code></dt><dd><p>The transformed data for stationary EVA.
Includes the stationary series, trend, and standard deviation series</p>
</dd>
</dl>



<h3>References</h3>

<p>Mentaschi, L., Vousdoukas, M., Voukouvalas, E., Sartini, L., Feyen, L.,
Besio, G., and Alfieri, L. (2016). The transformed-stationary approach:
a generic and simplified methodology for non-stationary extreme value analysis.
<em>Hydrology and Earth System Sciences</em>, <strong>20</strong>(9), 3527-3547.
doi:10.5194/hess-20-3527-2016.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
result &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')

</code></pre>

<hr>
<h2 id='tsEvaPlotAllRLevelsGEV'>tsEvaPlotAllRLevelsGEV</h2><span id='topic+tsEvaPlotAllRLevelsGEV'></span>

<h3>Description</h3>

<p><code>tsEvaPlotAllRLevelsGEV</code> is a function that generates
a beam plot of return levels for a Generalized Extreme Value (GEV)
distribution based on the provided parameters and data.
The plot showcases the evolving relationship between return periods and
return levels through time, allowing for visual analysis of extreme events
and their probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotAllRLevelsGEV(
  nonStationaryEvaParams,
  stationaryTransformData,
  rlvmax,
  timeIndex,
  timeStamps,
  tstamps,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>A list of non-stationary evaluation parameters containing the GEV distribution parameters (epsilon, sigma, mu) and the time delta in years (dtSampleYears).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transformed data used for the analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_rlvmax">rlvmax</code></td>
<td>
<p>The maximum return level data, including the return periods (haz.RP) and the actual return levels (QNS).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_timeindex">timeIndex</code></td>
<td>
<p>The index of the time step used for analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_timestamps">timeStamps</code></td>
<td>
<p>The timestamps corresponding to the time steps in the analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_tstamps">tstamps</code></td>
<td>
<p>The timestamps used for labeling the plot.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD, either &quot;ori&quot; (original) or &quot;rev&quot; (reverse).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGEV_+3A_...">...</code></td>
<td>
<p>Additional optional arguments for customizing the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object showing the relationship between return periods and return levels for the GEV distribution at different timesteps.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGEV">tsEvaComputeReturnLevelsGEV</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 20 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=2000)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 5*365 # 5 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
amax &lt;- nonStationaryEvaParams[[1]]$parameters$annualMax
amaxID &lt;- nonStationaryEvaParams[[1]]$parameters$annualMaxIndx
timeStamps &lt;- stationaryTransformData$timeStamps
trendPeaks &lt;- stationaryTransformData$trendSeries[amaxID]
stdPeaks &lt;- stationaryTransformData$stdDevSeries[amaxID]
amaxCor &lt;- (amax - trendPeaks) / stdPeaks
nYears &lt;- length(amaxCor)
rlvlmax &lt;- empdis(amaxCor, nYears)
rlvlmax$QNS &lt;- amax[order(amax)]
rlvlmax$Idt &lt;- stationaryTransformData$timeStamps[amaxID][order(amax)]
timeIndex &lt;- 2
tstamps &lt;- "Example Timestamps"
trans &lt;- "ori"
# Call the function with the defined arguments
result &lt;- tsEvaPlotAllRLevelsGEV(
  nonStationaryEvaParams, stationaryTransformData,
  rlvlmax, timeIndex, timeStamps, tstamps,
  trans)
result
</code></pre>

<hr>
<h2 id='tsEvaPlotAllRLevelsGPD'>tsEvaPlotAllRLevelsGPD</h2><span id='topic+tsEvaPlotAllRLevelsGPD'></span>

<h3>Description</h3>

<p><code>tsEvaPlotAllRLevelsGPD</code> is a function that generates a plot of
return levels for a Generalized Pareto Distribution (GPD) based on the
provided parameters and data. The plot showcases the evolving relationship
between return periods and return levels, allowing for visual analysis of
extreme events and their probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotAllRLevelsGPD(
  nonStationaryEvaParams,
  stationaryTransformData,
  rlvmax,
  timeIndex,
  timeStamps,
  tstamps,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>A list of non-stationary evaluation parameters
containing the GPD distribution parameters (epsilon, sigma, threshold),
time horizon start and end (thStart, thEnd), time horizon in years
(timeHorizonInYears), and number of peaks (nPeaks).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transformed data used for
the analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_rlvmax">rlvmax</code></td>
<td>
<p>The maximum return level data, including the return periods
(haz.RP) and the actual return levels (QNS).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_timeindex">timeIndex</code></td>
<td>
<p>The index of the time step used for analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_timestamps">timeStamps</code></td>
<td>
<p>The timestamps corresponding to the time steps in
the analysis.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_tstamps">tstamps</code></td>
<td>
<p>The timestamps used for labeling the plot.</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD, either
&quot;ori&quot; (original) or &quot;rev&quot; (reverse).</p>
</td></tr>
<tr><td><code id="tsEvaPlotAllRLevelsGPD_+3A_...">...</code></td>
<td>
<p>Additional optional arguments for customizing the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot object showing the relationship between return periods and
return levels for the GPD distribution at different timest
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGPD">tsEvaComputeReturnLevelsGPD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 20 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=2000)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 5*365 # 5 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
                      transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
peax &lt;- nonStationaryEvaParams[[2]]$parameters$peaks
peaxID &lt;- nonStationaryEvaParams[[2]]$parameters$peakID
timeStamps &lt;- stationaryTransformData$timeStamps
trendPeaks &lt;- stationaryTransformData$trendSeries[peaxID]
stdPeaks &lt;- stationaryTransformData$stdDevSeries[peaxID]
peaksCor &lt;- (peax - trendPeaks) / stdPeaks
nYears &lt;- round(length(timeStamps) / 365.25 )
rlvlmax &lt;- empdis(peaksCor, nYears)
rlvlmax$QNS &lt;- peax[order(peax)]
rlvlmax$Idt &lt;- stationaryTransformData$timeStamps[peaxID][order(peax)]
timeIndex &lt;- 2
tstamps &lt;- "Example Timestamps"
trans &lt;- "ori"
# Call the function with the defined arguments
result &lt;- tsEvaPlotAllRLevelsGPD(
  nonStationaryEvaParams, stationaryTransformData,
  rlvlmax, timeIndex, timeStamps, tstamps,
  trans)
# Plot the result
result
</code></pre>

<hr>
<h2 id='tsEvaPlotGEVImageSc'>tsEvaPlotGEVImageSc</h2><span id='topic+tsEvaPlotGEVImageSc'></span>

<h3>Description</h3>

<p><code>tsEvaPlotGEVImageSc</code>is a function that generates a plot of the
Generalized Extreme Value (GEV) distribution with evolving parameters
using the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotGEVImageSc(
  Y,
  timeStamps,
  serix,
  epsilon,
  sigma,
  mu,
  returnPeriodInDts,
  maxObs,
  trans,
  varargin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_y">Y</code></td>
<td>
<p>A vector of extreme values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of timestamps corresponding to the extreme values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_serix">serix</code></td>
<td>
<p>The y-value at which to draw a horizontal line on the plot.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric value representing the shape parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_sigma">sigma</code></td>
<td>
<p>A vector of scale parameters corresponding to the timestamps.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_mu">mu</code></td>
<td>
<p>A vector of location parameters corresponding to the timestamps.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_returnperiodindts">returnPeriodInDts</code></td>
<td>
<p>The return period in decimal time steps.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_maxobs">maxObs</code></td>
<td>
<p>A data frame containing the maximum observations.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_trans">trans</code></td>
<td>
<p>A character string indicating the transformation for the plot.
Possible values are &quot;rev&quot; (reverse), inv&quot; (inverse),
lninv (log of inverse) and &quot;ori&quot;(original).</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageSc_+3A_varargin">varargin</code></td>
<td>
<p>Additional arguments to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the GEV plot with a raster image.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotGEVImageScFromAnalysisObj">tsEvaPlotGEVImageScFromAnalysisObj</a></code>
</p>

<hr>
<h2 id='tsEvaPlotGEVImageScFromAnalysisObj'>tsEvaPlotGEVImageScFromAnalysisObj</h2><span id='topic+tsEvaPlotGEVImageScFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotGEVImageScFromAnalysisObj</code>is a function that generates a GEV
(Generalized Extreme Value) time-varying distribution through time as
and show the evolution of exceedance probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotGEVImageScFromAnalysisObj(
  Y,
  nonStationaryEvaParams,
  stationaryTransformData,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotGEVImageScFromAnalysisObj_+3A_y">Y</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageScFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>A list of non-stationary evaluation parameters.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageScFromAnalysisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transform data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageScFromAnalysisObj_+3A_trans">trans</code></td>
<td>
<p>The transformation method.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGEVImageScFromAnalysisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The GEV image scatter plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotGEVImageSc">tsEvaPlotGEVImageSc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 20 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=2000)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 5*365 # 10 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')

# Define the required function arguments
stationaryTransformData &lt;- TSEVA_data[[2]]
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
trans='ori'

ExRange= c(min(nonStationaryEvaParams$potObj$parameters$peaks),
max(nonStationaryEvaParams$potObj$parameters$peaks))
Y &lt;- c(seq(min(ExRange),max(ExRange),length.out=700))

result = tsEvaPlotGEVImageScFromAnalysisObj(Y,nonStationaryEvaParams,
stationaryTransformData, trans)
result
</code></pre>

<hr>
<h2 id='tsEvaPlotGPDImageSc'>tsEvaPlotGPDImageSc</h2><span id='topic+tsEvaPlotGPDImageSc'></span>

<h3>Description</h3>

<p><code>tsEvaPlotGPDImageSc</code>is a function that generates a  time series plot
of the Generalized Pareto Distribution (GPD) with evolving parameters
using the provided data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotGPDImageSc(
  Y,
  timeStamps,
  serix,
  epsilon,
  sigma,
  threshold,
  peakplot,
  trans,
  varargin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_y">Y</code></td>
<td>
<p>A vector of values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of timestamps corresponding to the values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_serix">serix</code></td>
<td>
<p>A vector of series values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_epsilon">epsilon</code></td>
<td>
<p>A numeric value representing the shape parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_sigma">sigma</code></td>
<td>
<p>A vector of standard deviation values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_threshold">threshold</code></td>
<td>
<p>A vector of threshold values.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_peakplot">peakplot</code></td>
<td>
<p>A data frame containing peak values and their corresponding timestamps.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_trans">trans</code></td>
<td>
<p>A character string indicating the transformation to be applied to the data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageSc_+3A_varargin">varargin</code></td>
<td>
<p>Additional optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the GPD plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotGPDImageScFromAnalysisObj">tsEvaPlotGPDImageScFromAnalysisObj</a></code>
</p>

<hr>
<h2 id='tsEvaPlotGPDImageScFromAnalysisObj'>tsEvaPlotGPDImageScFromAnalysisObj</h2><span id='topic+tsEvaPlotGPDImageScFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotGPDImageScFromAnalysisObj</code>is a function that plots the GPD
(Generalized Pareto Distribution) time-varying distribution through time as
and show the evolution of exceedance probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotGPDImageScFromAnalysisObj(
  Y,
  nonStationaryEvaParams,
  stationaryTransformData,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotGPDImageScFromAnalysisObj_+3A_y">Y</code></td>
<td>
<p>The input data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageScFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>A list containing non-stationary evaluation parameters.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageScFromAnalysisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>A data frame containing stationary transform data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageScFromAnalysisObj_+3A_trans">trans</code></td>
<td>
<p>The transformation method to be applied to the data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotGPDImageScFromAnalysisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the <code><a href="#topic+tsEvaPlotGPDImageSc">tsEvaPlotGPDImageSc</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the input data <code>Y</code>, non-stationary evaluation parameters <code>nonStationaryEvaParams</code>,
stationary transform data <code>stationaryTransformData</code>, transformation method <code>trans</code>, and additional arguments <code>...</code>.
It then updates the arguments with the passed-in values, calculates the time stamps, and performs necessary transformations.
Finally, it plots the GPD image score using the <code><a href="#topic+tsEvaPlotGPDImageSc">tsEvaPlotGPDImageSc</a></code> function and returns the plot object.
</p>


<h3>Value</h3>

<p>The plot object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotGPDImageSc">tsEvaPlotGPDImageSc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 20 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=2000)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 5*365 # 5 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
trans='ori'
ExRange= c(min(nonStationaryEvaParams$potObj$parameters$peaks),
max(nonStationaryEvaParams$potObj$parameters$peaks))
Y &lt;- c(seq(min(ExRange),max(ExRange),length.out=700))
result = tsEvaPlotGEVImageScFromAnalysisObj(Y, nonStationaryEvaParams,
stationaryTransformData, trans)
result

</code></pre>

<hr>
<h2 id='tsEvaPlotReturnLevelsGEV'>tsEvaPlotReturnLevelsGEV</h2><span id='topic+tsEvaPlotReturnLevelsGEV'></span>

<h3>Description</h3>

<p><code>tsEvaPlotReturnLevelsGEV</code> is a function that plots the return levels
using the Generalized Extreme Value (GEV) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotReturnLevelsGEV(
  epsilon,
  sigma,
  mu,
  epsilonStdErr,
  sigmaStdErr,
  muStdErr,
  rlvmax,
  tstamps,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_mu">mu</code></td>
<td>
<p>The location parameter of the GEV distribution.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_epsilonstderr">epsilonStdErr</code></td>
<td>
<p>The standard error of the shape parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_sigmastderr">sigmaStdErr</code></td>
<td>
<p>The standard error of the scale parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_mustderr">muStdErr</code></td>
<td>
<p>The standard error of the location parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_rlvmax">rlvmax</code></td>
<td>
<p>A data frame containing the return levels of annual maxima.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_tstamps">tstamps</code></td>
<td>
<p>The title for the plot.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD, either &quot;ori&quot; (original)
or &quot;rev&quot; (reverse). &quot;inv&quot; and &quot;lninv&quot; are also available
but in development phase.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEV_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the plot of return levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGEV">tsEvaComputeReturnLevelsGEV</a></code>
<code><a href="#topic+tsEvaPlotReturnLevelsGEVFromAnalysisObj">tsEvaPlotReturnLevelsGEVFromAnalysisObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the required function arguments
epsilon &lt;- 0.2
sigma &lt;- 0.5
mu &lt;- 10
epsilonStdErr &lt;- 0.05
sigmaStdErr &lt;- 0.05
muStdErr &lt;- 0.1
rlvmax &lt;- data.frame(
  haz.RP = c(2, 5, 10, 20, 50, 100, 200, 500, 1000),
  Idt = as.POSIXct(as.Date("2000-01-01") + round(runif(9, 0, 21 * 365.25)),
    origin = "1970-01-01"
  ),
  QNS = c(10, 12, 13, 13.2, 14, 15.7, 16, 16.2, 18)
)
tstamps &lt;- "Example Timestamps"
trans &lt;- "ori"
# Call the function with the defined arguments
result &lt;- tsEvaPlotReturnLevelsGEV(
  epsilon, sigma, mu, epsilonStdErr, sigmaStdErr, muStdErr,
  rlvmax, tstamps, trans
)

# Plot the result
result
</code></pre>

<hr>
<h2 id='tsEvaPlotReturnLevelsGEVFromAnalysisObj'>tsEvaPlotReturnLevelsGEVFromAnalysisObj</h2><span id='topic+tsEvaPlotReturnLevelsGEVFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotReturnLevelsGEVFromAnalysisObj</code> is a function that plots the
return levels for a Generalized Extreme Value (GEV) distribution using the
parameters obtained from an analysis object. It considers non-stationarity
by considering time-varying parameters and their associated standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotReturnLevelsGEVFromAnalysisObj(
  nonStationaryEvaParams,
  stationaryTransformData,
  timeIndex,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotReturnLevelsGEVFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The non-stationary parameters obtained from the
analysis object.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEVFromAnalysisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transformed data obtained from
the analysis object.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEVFromAnalysisObj_+3A_timeindex">timeIndex</code></td>
<td>
<p>The index at which the time-varying analysis should be
estimated.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEVFromAnalysisObj_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD. Can be &quot;ori&quot; for no
transformation or &quot;rev&quot; for reverse transformation.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGEVFromAnalysisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>Plot 1</dt><dd><p>RLtstep: return level curve with confidence interval for the
selected timeIndex</p>
</dd>
<dt>Plot 2</dt><dd></dd></dl>
<p>beam: beam of return level curve for all with highlited curve
for selected timeIndex
</p>


<h3>References</h3>

<p>Mentaschi, L., Vousdoukas, M., Voukouvalas, E., Sartini, L., Feyen, L., Besio,
G., and Alfieri, L. (2016). The transformed-stationary approach: a generic
and simplified methodology for non-stationary extreme value analysis.
<em>Hydrology and Earth System Sciences</em>, 20, 3527-3547.
doi:10.5194/hess-20-3527-2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotReturnLevelsGEV">tsEvaPlotReturnLevelsGEV()</a></code> and <code><a href="#topic+tsEvaPlotAllRLevelsGEV">tsEvaPlotAllRLevelsGEV()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 # Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
timeIndex=2
trans='ori'
result = tsEvaPlotReturnLevelsGEVFromAnalysisObj(nonStationaryEvaParams, stationaryTransformData,
timeIndex, trans)
result
</code></pre>

<hr>
<h2 id='tsEvaPlotReturnLevelsGPD'>tsEvaPlotReturnLevelsGPD</h2><span id='topic+tsEvaPlotReturnLevelsGPD'></span>

<h3>Description</h3>

<p><code>tsEvaPlotReturnLevelsGPD</code> is a function that plots the return levels
using the Generalized Pareto Distribution (GPD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotReturnLevelsGPD(
  epsilon,
  sigma,
  threshold,
  epsilonStdErr,
  sigmaStdErr,
  thresholdStdErr,
  nPeaks,
  timeHorizonInYears,
  rlvmax,
  tstamps,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_epsilon">epsilon</code></td>
<td>
<p>The shape parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_sigma">sigma</code></td>
<td>
<p>The scale parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_threshold">threshold</code></td>
<td>
<p>The threshold parameter of the GPD.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_epsilonstderr">epsilonStdErr</code></td>
<td>
<p>The standard error of the shape parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_sigmastderr">sigmaStdErr</code></td>
<td>
<p>The standard error of the scale parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_thresholdstderr">thresholdStdErr</code></td>
<td>
<p>The standard error of the threshold parameter.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_npeaks">nPeaks</code></td>
<td>
<p>The number of peaks used in the GPD estimation.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_timehorizoninyears">timeHorizonInYears</code></td>
<td>
<p>The time horizon in years for the GPD estimation.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_rlvmax">rlvmax</code></td>
<td>
<p>A data frame containing the return levels of annual maxima.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_tstamps">tstamps</code></td>
<td>
<p>The title for the plot.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_trans">trans</code></td>
<td>
<p>The transformation type for the return levels.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPD_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the plot of return levels.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaComputeReturnLevelsGPD">tsEvaComputeReturnLevelsGPD</a></code>
<code><a href="#topic+tsEvaPlotReturnLevelsGPDFromAnalysisObj">tsEvaPlotReturnLevelsGPDFromAnalysisObj</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define the required function arguments
epsilon &lt;- 0.2
sigma &lt;- 0.5
threshold &lt;- 10
epsilonStdErr &lt;- 0.05
sigmaStdErr &lt;- 0.05
thresholdStdErr &lt;- 0.1
rlvmax &lt;- data.frame(
  haz.RP = c(2, 5, 10, 20, 50, 100, 200, 500, 1000),
  Idt = as.POSIXct(as.Date("2000-01-01") + round(runif(9, 0, 21 * 365.25)),
    origin = "1970-01-01"
  ),
  QNS = c(10, 12, 13, 13.2, 14, 15.7, 16, 16.2, 18)
)
tstamps &lt;- "Example Timestamps"
trans &lt;- "ori"
nPeaks=70
SampleTimeHorizon=70
# Call the function with the defined arguments
result &lt;- tsEvaPlotReturnLevelsGPD(
  epsilon, sigma, threshold, epsilonStdErr, sigmaStdErr, thresholdStdErr,nPeaks,
  SampleTimeHorizon,rlvmax, tstamps, trans
)
# Plot the result
result
</code></pre>

<hr>
<h2 id='tsEvaPlotReturnLevelsGPDFromAnalysisObj'>tsEvaPlotReturnLevelsGPDFromAnalysisObj</h2><span id='topic+tsEvaPlotReturnLevelsGPDFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotReturnLevelsGPDFromAnalysisObj</code> is a function that plots the return levels for a Generalized Pareto Distribution (GPD) using the parameters obtained from an analysis object. It considers non-stationarity by considering time-varying parameters and their associated standard errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotReturnLevelsGPDFromAnalysisObj(
  nonStationaryEvaParams,
  stationaryTransformData,
  timeIndex,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotReturnLevelsGPDFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The non-stationary parameters obtained from the analysis object.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPDFromAnalysisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transformed data obtained from the analysis object.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPDFromAnalysisObj_+3A_timeindex">timeIndex</code></td>
<td>
<p>The index at which the time-varying analysis should be estimated.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPDFromAnalysisObj_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD. Can be &quot;ori&quot; for no transformation or &quot;rev&quot; for reverse transformation.</p>
</td></tr>
<tr><td><code id="tsEvaPlotReturnLevelsGPDFromAnalysisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the function.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>Plot 1</dt><dd><p>RLtstep: return level curve with confidence interval for the
selected timeIndex</p>
</dd>
<dt>Plot 2</dt><dd></dd></dl>
<p>beam: beam of return level curve for all with highlited curve
for selected timeIndex
</p>


<h3>References</h3>

<p>Mentaschi, L., Vousdoukas, M., Voukouvalas, E., Sartini, L., Feyen, L., Besio, G., and Alfieri, L. (2016). The transformed-stationary approach: a generic and simplified methodology for non-stationary extreme value analysis. <em>Hydrology and Earth System Sciences</em>, 20, 3527-3547. doi:10.5194/hess-20-3527-2016.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotReturnLevelsGPD">tsEvaPlotReturnLevelsGPD()</a></code> and <code><a href="#topic+tsEvaPlotAllRLevelsGPD">tsEvaPlotAllRLevelsGPD()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
timeIndex=2
trans='ori'
result = tsEvaPlotReturnLevelsGPDFromAnalysisObj(nonStationaryEvaParams, stationaryTransformData,
timeIndex, trans)
result
</code></pre>

<hr>
<h2 id='tsEvaPlotSeriesTrendStdDevFromAnalyisObj'>tsEvaPlotSeriesTrendStdDevFromAnalyisObj</h2><span id='topic+tsEvaPlotSeriesTrendStdDevFromAnalyisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotTrendStdDevFromAnalysisObj</code>is a function that plots a
time series along with its trend and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotSeriesTrendStdDevFromAnalyisObj(
  nonStationaryEvaParams,
  stationaryTransformData,
  trans,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotSeriesTrendStdDevFromAnalyisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>The non-stationary evaluation parameters.</p>
</td></tr>
<tr><td><code id="tsEvaPlotSeriesTrendStdDevFromAnalyisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>The stationary transformed data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotSeriesTrendStdDevFromAnalyisObj_+3A_trans">trans</code></td>
<td>
<p>The transformation used to fit the EVD, either &quot;ori&quot; (original)
or &quot;rev&quot; (reverse). &quot;inv&quot; and &quot;lninv&quot; are also available</p>
</td></tr>
<tr><td><code id="tsEvaPlotSeriesTrendStdDevFromAnalyisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments to customize the plot (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
trans='ori'
result = tsEvaPlotSeriesTrendStdDevFromAnalyisObj(nonStationaryEvaParams,
stationaryTransformData, trans)
result

</code></pre>

<hr>
<h2 id='tsEvaPlotTransfToStat'>tsEvaPlotTransfToStat</h2><span id='topic+tsEvaPlotTransfToStat'></span>

<h3>Description</h3>

<p><code>tsEvaPlotTransfToStat</code>is a function that creates a
line plot of time series data along with statistical measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotTransfToStat(
  timeStamps,
  statSeries,
  srsmean,
  stdDev,
  st3mom,
  st4mom,
  varargin
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps for the data points.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_statseries">statSeries</code></td>
<td>
<p>A vector of the main time series data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_srsmean">srsmean</code></td>
<td>
<p>A vector of the mean values for each time stamp.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_stddev">stdDev</code></td>
<td>
<p>A vector of the standard deviation values for each time stamp.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_st3mom">st3mom</code></td>
<td>
<p>A vector of the third moment values for each time stamp.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_st4mom">st4mom</code></td>
<td>
<p>A vector of the fourth moment values for each time stamp.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStat_+3A_varargin">varargin</code></td>
<td>
<p>Additional optional arguments to customize the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object representing the line plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotTransfToStatFromAnalysisObj">tsEvaPlotTransfToStatFromAnalysisObj</a></code>
</p>

<hr>
<h2 id='tsEvaPlotTransfToStatFromAnalysisObj'>tsEvaPlotTransfToStatFromAnalysisObj</h2><span id='topic+tsEvaPlotTransfToStatFromAnalysisObj'></span>

<h3>Description</h3>

<p><code>tsEvaPlotTransfToStatFromAnalysisObj</code>is a function that takes the
parameters of a non-stationary time series evaluation,
along with the transformed stationary data,
and plots the converted stationary series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaPlotTransfToStatFromAnalysisObj(
  nonStationaryEvaParams,
  stationaryTransformData,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaPlotTransfToStatFromAnalysisObj_+3A_nonstationaryevaparams">nonStationaryEvaParams</code></td>
<td>
<p>A list of parameters for non-stationary
time series evaluation.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStatFromAnalysisObj_+3A_stationarytransformdata">stationaryTransformData</code></td>
<td>
<p>A list containing the transformed stationary data.</p>
</td></tr>
<tr><td><code id="tsEvaPlotTransfToStatFromAnalysisObj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to
the <code><a href="#topic+tsEvaPlotTransfToStat">tsEvaPlotTransfToStat</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot object representing the converted stationary series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tsEvaPlotTransfToStat">tsEvaPlotTransfToStat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example usage of TsEvaNs function
timeAndSeries &lt;- ArdecheStMartin
#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
#keep only the 30 last years
yrs &lt;- as.integer(format(timeAndSeries$date, "%Y"))
tokeep &lt;- which(yrs&gt;=1990)
timeAndSeries &lt;- timeAndSeries[tokeep,]
timeWindow &lt;- 10*365 # 10 years
TSEVA_data &lt;- TsEvaNs(timeAndSeries, timeWindow,
transfType = 'trendPeaks',tail = 'high')
# Define the required function argumentsnonStationaryEvaParams &lt;- TSEVA_data[[1]]
stationaryTransformData &lt;- TSEVA_data[[2]]
nonStationaryEvaParams &lt;- TSEVA_data[[1]]
trans='ori'
ExRange= c(min(nonStationaryEvaParams$potObj$parameters$peaks),
max(nonStationaryEvaParams$potObj$parameters$peaks))
Y &lt;- c(seq(min(ExRange),max(ExRange),length.out=700))
result = tsEvaPlotTransfToStatFromAnalysisObj (nonStationaryEvaParams,
stationaryTransformData)
result
</code></pre>

<hr>
<h2 id='tsEvaRunningMeanTrend'>Calculate the running mean trend of a time series</h2><span id='topic+tsEvaRunningMeanTrend'></span>

<h3>Description</h3>

<p>This function calculates the running mean trend of a given time series using a specified time window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaRunningMeanTrend(timeStamps, series, timeWindow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaRunningMeanTrend_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps corresponding to the observations in the series.</p>
</td></tr>
<tr><td><code id="tsEvaRunningMeanTrend_+3A_series">series</code></td>
<td>
<p>A vector of numeric values representing the time series.</p>
</td></tr>
<tr><td><code id="tsEvaRunningMeanTrend_+3A_timewindow">timeWindow</code></td>
<td>
<p>The length of the time window (in the same time units as the time stamps) used for calculating the running mean trend.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the running mean trend series and the number of observations used for each running mean calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series  &lt;- ArdecheStMartin[,2]
timeWindow &lt;- 365*30
result &lt;- tsEvaRunningMeanTrend(timeStamps, series, timeWindow)
result$trendSeries
result$nRunMn

</code></pre>

<hr>
<h2 id='tsEvaSampleData'>tsEvaSampleData Function</h2><span id='topic+tsEvaSampleData'></span>

<h3>Description</h3>

<p><code>tsEvaSampleData</code> is a function that calculates various statistics
and data for time series evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaSampleData(
  ms,
  meanEventsPerYear,
  minEventsPerYear,
  minPeakDistanceInDays,
  tail = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaSampleData_+3A_ms">ms</code></td>
<td>
<p>A matrix containing the time series data.</p>
</td></tr>
<tr><td><code id="tsEvaSampleData_+3A_meaneventsperyear">meanEventsPerYear</code></td>
<td>
<p>The mean number of events per year.</p>
</td></tr>
<tr><td><code id="tsEvaSampleData_+3A_mineventsperyear">minEventsPerYear</code></td>
<td>
<p>The minimum number of events per year.</p>
</td></tr>
<tr><td><code id="tsEvaSampleData_+3A_minpeakdistanceindays">minPeakDistanceInDays</code></td>
<td>
<p>The minimum peak distance in days.</p>
</td></tr>
<tr><td><code id="tsEvaSampleData_+3A_tail">tail</code></td>
<td>
<p>The tail to be studied for POT selection, either 'high' or 'low'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>completeSeries</code></dt><dd><p>The complete time series data.</p>
</dd>
<dt><code>POT</code></dt><dd><p>The data for Peaks Over Threshold (POT) analysis.</p>
</dd>
<dt><code>years</code></dt><dd><p>The years in the time series data.</p>
</dd>
<dt><code>Percentiles</code></dt><dd><p>The desired percentiles and their corresponding values.</p>
</dd>
<dt><code>annualMax</code></dt><dd><p>The annual maximum values.</p>
</dd>
<dt><code>annualMaxDate</code></dt><dd><p>The dates corresponding to the annual maximum values.</p>
</dd>
<dt><code>annualMaxIndx</code></dt><dd><p>The indices of the annual maximum values.</p>
</dd>
<dt><code>monthlyMax</code></dt><dd><p>The monthly maximum values.</p>
</dd>
<dt><code>monthlyMaxDate</code></dt><dd><p>The dates corresponding to the monthly maximum values.</p>
</dd>
<dt><code>monthlyMaxIndx</code></dt><dd><p>The indices of the monthly maximum values.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsGetPOT">tsGetPOT()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate sample data
data &lt;- ArdecheStMartin
colnames(data) &lt;- c("Date", "Value")
#select only the 5 latest years
yrs &lt;- as.integer(format(data$Date, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
data &lt;- data[tokeep,]
timeWindow &lt;- 365 # 1 year
# Calculate statistics and data
result &lt;- tsEvaSampleData(data, meanEventsPerYear=3, minEventsPerYear=0,
minPeakDistanceInDays=7, "high")
# View the result
print(result)
</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryMultiplicativeSeasonality'>tsEvaTransformSeriesToStationaryMultiplicativeSeasonality</h2><span id='topic+tsEvaTransformSeriesToStationaryMultiplicativeSeasonality'></span>

<h3>Description</h3>

<p>This function decomposes a time series into a season-dependent trend and a
season-dependent standard deviation.It performs a transformation from
non-stationary to stationary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryMultiplicativeSeasonality(
  timeStamps,
  series,
  timeWindow,
  seasonalityVar = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryMultiplicativeSeasonality_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of timestamps for the time series data.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryMultiplicativeSeasonality_+3A_series">series</code></td>
<td>
<p>A vector of the time series data.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryMultiplicativeSeasonality_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the moving window used for trend estimation.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryMultiplicativeSeasonality_+3A_seasonalityvar">seasonalityVar</code></td>
<td>
<p>A logical value indicating whether to consider
a time varying seasonality (30 years moving average)  or a static
seasonal cycle in the transformation. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the transformed data and various statistics and errors.
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The size of the moving window used for trend estimation</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary series</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend component of the transformed series</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The trend component of the original series without seasonality</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The standard deviation component of the transformed series</p>
</dd>
<dt><code>stdDevSeriesNonSeasonal</code></dt><dd><p>The standard deviation component of the original series without seasonality</p>
</dd>
<dt><code>trendNonSeasonalError</code></dt><dd><p>The error on the non-seasonal trend component</p>
</dd>
<dt><code>stdDevNonSeasonalError</code></dt><dd><p>The error on the non-seasonal standard deviation component</p>
</dd>
<dt><code>trendSeasonalError</code></dt><dd><p>The error on the seasonal trend component</p>
</dd>
<dt><code>stdDevSeasonalError</code></dt><dd><p>The error on the seasonal standard deviation component</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The overall error on the trend component</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The overall error on the standard deviation component</p>
</dd>
<dt><code>Regime</code></dt><dd><p>The estimated regime of the trend seasonality</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The input timestamps</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The third moment of the transformed stationary series</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The fourth moment of the transformed stationary series</p>
</dd>
</dl>



<h3>transformation non stationary -&gt; stationary</h3>

<p>transformation stationary -&gt; non stationary
y(t) = stdDev(t)*ssn_stdDev(t)*x(t) + trend(t) + ssn_trend(t)
trasfData.trendSeries = trend(t) + ssn_trend(t)
trasfData.stdDevSeries = stdDev(t)*ssn_stdDev(t)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
TrendTh &lt;- NA
result &lt;- tsEvaTransformSeriesToStationaryMultiplicativeSeasonality(timeStamps,
series, timeWindow,seasonalityVar=FALSE)
plot(result$trendSeries)
</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryPeakTrend'>tsEvaTransformSeriesToStationaryPeakTrend</h2><span id='topic+tsEvaTransformSeriesToStationaryPeakTrend'></span>

<h3>Description</h3>

<p><code>tsEvaTransformSeriesToStationaryPeakTrend</code>
transforms a time series to a stationary one by focusing on extremes.
The trend and slowly varying amplitude are computed on values above a
threshold defined by the user or automatically
with the function <code>tsEvaFindTrendThreshold</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryPeakTrend(
  timeStamps,
  series,
  timeWindow,
  TrendTh
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryPeakTrend_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps corresponding to the observations in the series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryPeakTrend_+3A_series">series</code></td>
<td>
<p>A vector of the time series data.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryPeakTrend_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the time window used for detrending.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryPeakTrend_+3A_trendth">TrendTh</code></td>
<td>
<p>The threshold for fitting the trend on the means above a
given quantile. Default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The multiplicity of running statistics.</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The stationary series after removing the trend.</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend component of the series.</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>NULL (not used).</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend component.</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The standard deviation series.</p>
</dd>
<dt><code>stdDevSeriesNonSeasonal</code></dt><dd><p>NULL (not used).</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation series.</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps.</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series.</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The running mean of the third moment of the stationary series.</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The running mean of the fourth moment of the stationary series.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsEvaFindTrendThreshold">tsEvaFindTrendThreshold()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
TrendTh &lt;- NA
result &lt;- tsEvaTransformSeriesToStationaryPeakTrend(timeStamps,
series, timeWindow, TrendTh)
plot(result$trendSeries)

</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryTrendAndChangepts'>Transform Time Series to Stationary Trend and Change Points</h2><span id='topic+tsEvaTransformSeriesToStationaryTrendAndChangepts'></span>

<h3>Description</h3>

<p>This function takes a time series and transforms it into a stationary trend series
by removing the trend component and detecting change points. It computes the slowly
varying standard deviation and normalizes the stationary series before detecting
step changes. It also calculates the error on the trend and standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryTrendAndChangepts(
  timeStamps,
  series,
  timeWindow
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps corresponding to the data points in the series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_+3A_series">series</code></td>
<td>
<p>The original time series data.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the time window used for detrending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The running statistics multiplicity.</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary series.</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend series.</p>
</dd>
<dt><code>trendonlySeries</code></dt><dd><p>The trend series without the stationary component.</p>
</dd>
<dt><code>ChpointsSeries2</code></dt><dd><p>The trend component of the change points.</p>
</dd>
<dt><code>changePoints</code></dt><dd><p>The detected change points.</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The trend series without the seasonal component.</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend.</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The slowly varying standard deviation series.</p>
</dd>
<dt><code>stdDevSeriesNonStep</code></dt><dd><p>The slowly varying standard deviation series without step changes.</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation.</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps.</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series.</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The running mean of the third moment of the stationary series.</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The running mean of the fourth moment of the stationary series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
percentile &lt;- 90
result &lt;- tsEvaTransformSeriesToStationaryTrendAndChangepts(timeStamps,
series, timeWindow)
plot(result$trendSeries)

</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile'>Transform Time Series to Stationary Trend and Change Points with Confidence Intervals</h2><span id='topic+tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile'></span>

<h3>Description</h3>

<p>This function takes a time series and transforms it into a stationary trend series with change points and confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile(
  timeStamps,
  series,
  timeWindow,
  percentile
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps corresponding to the observations in the series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile_+3A_series">series</code></td>
<td>
<p>The time series data.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the sliding window used for detrending the series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile_+3A_percentile">percentile</code></td>
<td>
<p>The percentile value used for computing the running percentile of the stationary series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The running statistics multiplicity</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary series</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend series</p>
</dd>
<dt><code>trendonlySeries</code></dt><dd><p>The trend series without the stationary component</p>
</dd>
<dt><code>ChpointsSeries2</code></dt><dd><p>The trend series with change points</p>
</dd>
<dt><code>changePoints</code></dt><dd><p>The detected change points</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The trend series without the seasonal component</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The standard deviation series</p>
</dd>
<dt><code>stdDevSeriesNonStep</code></dt><dd><p>The standard deviation series without the step change component</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The running mean of the third moment of the stationary series</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The running mean of the fourth moment of the stationary series</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin

#go from six-hourly values to daily max
timeAndSeries &lt;- max_daily_value(timeAndSeries)
timeStamps &lt;- timeAndSeries[,1]
series &lt;- timeAndSeries[,2]

#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
percentile &lt;- 90
result &lt;- tsEvaTransformSeriesToStationaryTrendAndChangepts_ciPercentile(timeStamps,
series, timeWindow, percentile)
plot(result$trendSeries)
</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryTrendOnly'>tsEvaTransformSeriesToStationaryTrendOnly</h2><span id='topic+tsEvaTransformSeriesToStationaryTrendOnly'></span>

<h3>Description</h3>

<p><code>tsEvaTransformSeriesToStationaryTrendOnly</code> is the original detrending
function implemented in Mentaschi et al.(2016).
It takes a time series and transforms it into a stationary one.
It computes the trend as a running average of the time series,
the slowly varying amplitude as its standard deviation, and other statistical measures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryTrendOnly(timeStamps, series, timeWindow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps for the time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_+3A_series">series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the time window used for detrending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The running statistics multiplicity.</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary series.</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend series.</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The non-seasonal trend series.</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend.</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The slowly varying standard deviation series.</p>
</dd>
<dt><code>stdDevSeriesNonSeasonal</code></dt><dd><p>The non-seasonal slowly varying standard deviation series.</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation.</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps.</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series.</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The third moment of the transformed stationary series.</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The fourth moment of the transformed stationary series.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
timeWindow &lt;- 30*365 # 30 years
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
result &lt;- tsEvaTransformSeriesToStationaryTrendOnly(timeStamps, series, timeWindow)
plot(result$trendSeries)
</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile'>tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile</h2><span id='topic+tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile'></span>

<h3>Description</h3>

<p><code>tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile</code> transforms a
time series to a stationary ones using a moving average as the trend and
a running percentiles to represent the slowly varying amplitude of the distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile(
  timeStamps,
  series,
  timeWindow,
  percentile
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps for the time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile_+3A_series">series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile_+3A_timewindow">timeWindow</code></td>
<td>
<p>The size of the moving window used for detrending.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile_+3A_percentile">percentile</code></td>
<td>
<p>The percentile value used to compute the extreme trend
of the stationary series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The running statistics multiplicity</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary trend only series</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend series</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The non-seasonal trend series</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The standard deviation series</p>
</dd>
<dt><code>stdDevSeriesNonSeasonal</code></dt><dd><p>The non-seasonal standard deviation series</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The running mean of the third moment of the stationary series</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The running mean of the fourth moment of the stationary series</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
percentile &lt;- 90
result &lt;- tsEvaTransformSeriesToStationaryTrendOnly_ciPercentile(timeStamps,
series, timeWindow, percentile)
plot(result$trendSeries)
</code></pre>

<hr>
<h2 id='tsEvaTransformSeriesToStatSeasonal_ciPercentile'>tsEvaTransformSeriesToStatSeasonal_ciPercentile</h2><span id='topic+tsEvaTransformSeriesToStatSeasonal_ciPercentile'></span>

<h3>Description</h3>

<p>This function decomposes a time series into a season-dependent trend and a season-dependent standard deviation.
The season-dependent amplitude is given by a seasonal factor multiplied by a slowly varying percentile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEvaTransformSeriesToStatSeasonal_ciPercentile(
  timeStamps,
  series,
  timeWindow,
  percentile
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEvaTransformSeriesToStatSeasonal_ciPercentile_+3A_timestamps">timeStamps</code></td>
<td>
<p>A vector of time stamps for the time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStatSeasonal_ciPercentile_+3A_series">series</code></td>
<td>
<p>The original time series.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStatSeasonal_ciPercentile_+3A_timewindow">timeWindow</code></td>
<td>
<p>The length of the moving window used for trend estimation.</p>
</td></tr>
<tr><td><code id="tsEvaTransformSeriesToStatSeasonal_ciPercentile_+3A_percentile">percentile</code></td>
<td>
<p>The percentile value used for computing the slowly varying percentile.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>runningStatsMulteplicity</code></dt><dd><p>The size of each sample used to compute the average</p>
</dd>
<dt><code>stationarySeries</code></dt><dd><p>The transformed stationary series</p>
</dd>
<dt><code>trendSeries</code></dt><dd><p>The trend series</p>
</dd>
<dt><code>trendSeriesNonSeasonal</code></dt><dd><p>The non-seasonal trend series</p>
</dd>
<dt><code>stdDevSeries</code></dt><dd><p>The season-dependent standard deviation series</p>
</dd>
<dt><code>stdDevSeriesNonSeasonal</code></dt><dd><p>The non-seasonal standard deviation series</p>
</dd>
<dt><code>trendError</code></dt><dd><p>The error on the trend</p>
</dd>
<dt><code>stdDevError</code></dt><dd><p>The error on the standard deviation</p>
</dd>
<dt><code>statSer3Mom</code></dt><dd><p>The 3rd moment of the transformed stationary series</p>
</dd>
<dt><code>statSer4Mom</code></dt><dd><p>The 4th moment of the transformed stationary series</p>
</dd>
<dt><code>nonStatSeries</code></dt><dd><p>The original non-stationary series</p>
</dd>
<dt><code>Regime</code></dt><dd><p>The regime of the trend seasonality</p>
</dd>
<dt><code>timeStamps</code></dt><dd><p>The time stamps</p>
</dd>
<dt><code>trendNonSeasonalError</code></dt><dd><p>The error on the non-seasonal trend</p>
</dd>
<dt><code>stdDevNonSeasonalError</code></dt><dd><p>The error on the non-seasonal standard deviation</p>
</dd>
<dt><code>trendSeasonalError</code></dt><dd><p>The error on the seasonal trend</p>
</dd>
<dt><code>stdDevSeasonalError</code></dt><dd><p>The error on the seasonal standard deviation</p>
</dd>
</dl>



<h3>this function decomposes the series into a season-dependent trend and a</h3>

<p>season-dependent standard deviation.
The season-dependent standard deviation is given by a seasonal factor
multiplied by a slowly varying standard deviation.
transformation non stationary -&gt; stationary
x(t) =  (y(t) - trend(t) - ssn_trend(t))/(stdDev(t)*ssn_stdDev(t))
transformation stationary -&gt; non stationary
y(t) = stdDev(t)*ssn_stdDev(t)*x(t) + trend(t) + ssn_trend(t)
trasfData.trendSeries = trend(t) + ssn_trend(t)
trasfData.stdDevSeries = stdDev(t)*ssn_stdDev(t)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>timeAndSeries &lt;- ArdecheStMartin
timeStamps &lt;- ArdecheStMartin[,1]
series &lt;- ArdecheStMartin[,2]
#select only the 5 latest years
yrs &lt;- as.integer(format(timeStamps, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
timeStamps &lt;- timeStamps[tokeep]
series &lt;- series[tokeep]
timeWindow &lt;- 365 # 1 year
percentile &lt;- 90
result &lt;- tsEvaTransformSeriesToStatSeasonal_ciPercentile(timeStamps,
series, timeWindow, percentile)
plot(result$trendSeries)
</code></pre>

<hr>
<h2 id='tsEVstatistics'>tsEVstatistics</h2><span id='topic+tsEVstatistics'></span>

<h3>Description</h3>

<p><code>tsEvstatistics</code> is a function that calculates the Generalized Extreme
Value (GEV) and Generalized Pareto Distribution (GPD) statistics
and return levels for a given dataset of extreme values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsEVstatistics(
  pointData,
  alphaCI = 0.95,
  gevMaxima = "annual",
  gevType = "GEV",
  evdType = c("GEV", "GPD"),
  shape_bnd = c(-0.5, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsEVstatistics_+3A_pointdata">pointData</code></td>
<td>
<p>A list containing the dataset of extreme values. It should include the following components:
</p>

<dl>
<dt><code>annualMax</code></dt><dd><p>A vector of annual maximum values</p>
</dd>
<dt><code>annualMaxDate</code></dt><dd><p>A vector of dates corresponding to the annual maximum values</p>
</dd>
<dt><code>monthlyMax</code></dt><dd><p>A matrix of monthly maximum values</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="tsEVstatistics_+3A_alphaci">alphaCI</code></td>
<td>
<p>The confidence level for the confidence intervals of the parameter estimates. Default is 0.95.</p>
</td></tr>
<tr><td><code id="tsEVstatistics_+3A_gevmaxima">gevMaxima</code></td>
<td>
<p>The type of maxima to use for GEV fitting. Can be either 'annual' or 'monthly'. Default is 'annual'.</p>
</td></tr>
<tr><td><code id="tsEVstatistics_+3A_gevtype">gevType</code></td>
<td>
<p>The type of GEV distribution to use. Can be either 'GEV', 'Gumbel'. Default is 'GEV'.</p>
</td></tr>
<tr><td><code id="tsEVstatistics_+3A_evdtype">evdType</code></td>
<td>
<p>The types of extreme value distributions to calculate. Can be a combination of 'GEV' and 'GPD'. Default is c('GEV', 'GPD').</p>
</td></tr>
<tr><td><code id="tsEVstatistics_+3A_shape_bnd">shape_bnd</code></td>
<td>
<p>The lower and upper bounds for the shape parameter of the GEV distribution. Default is c(-0.5, 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt><code>EVmeta</code></dt><dd><p>A list containing metadata about the analysis.
It includes Tr, A vector of return periods for which
return levels are calculated</p>
</dd>
<dt><code>EVdata</code></dt><dd><p>A list containing the calculated statistics and return levels. It includes the following components:</p>
</dd>
</dl>

<dl>
<dt><code>GEVstat</code></dt><dd><p>A list containing the GEV statistics and return levels:</p>
</dd>
</dl>

<dl>
<dt><code>method</code></dt><dd><p>The method used for fitting the GEV distribution.</p>
</dd>
<dt><code>values</code></dt><dd><p>A vector of return levels calculated using the GEV distribution.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>A vector of parameter estimates for the GEV distribution.</p>
</dd>
<dt><code>paramCIs</code></dt><dd><p>A matrix of confidence intervals for the parameter estimates.</p>
</dd>
</dl>


<dl>
<dt><code>GPDstat</code></dt><dd><p>list containing the GPD statistics and return levels:</p>
</dd>
</dl>

<dl>
<dt><code>method</code></dt><dd><p>The method used for fitting the GPD distribution</p>
</dd>
<dt><code>values</code></dt><dd><p>A vector of return levels calculated using the GPD distribution</p>
</dd>
<dt><code>parameters</code></dt><dd><p>A vector of parameter estimates for the GPD distribution</p>
</dd>
<dt><code>paramCIs</code></dt><dd><p>A matrix of confidence intervals for the parameter estimates</p>
</dd>
</dl>

<dl>
<dt><code>isValid</code></dt><dd><p>A logical value indicating whether the analysis was performed or not.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Create a sample dataset
data &lt;- ArdecheStMartin
colnames(data) &lt;- c("Date", "Value")
yrs &lt;- as.integer(format(data$Date, "%Y"))
tokeep &lt;- which(yrs&gt;=2015)
data &lt;- data[tokeep,]
pointData &lt;- tsEvaSampleData(data, meanEventsPerYear=3, minEventsPerYear=0,
minPeakDistanceInDays=7, "high")
result &lt;- tsEVstatistics(pointData)
result$EVdata$GEVstat$values
result$EVdata$GPDstat$values
</code></pre>

<hr>
<h2 id='tsGetNumberPerYear'>tsGetNumberPerYear</h2><span id='topic+tsGetNumberPerYear'></span>

<h3>Description</h3>

<p><code>tsGetNumberPerYear</code> is a function that calculates the number of events per year based on a given time series and a set of locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsGetNumberPerYear(ms, locs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsGetNumberPerYear_+3A_ms">ms</code></td>
<td>
<p>A data frame representing the time series data, where the first column contains the dates of the events.</p>
</td></tr>
<tr><td><code id="tsGetNumberPerYear_+3A_locs">locs</code></td>
<td>
<p>A vector of indices representing the locations of interest in the time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: &quot;year&quot; and &quot;Freq&quot;. The &quot;year&quot; column contains the years, and the &quot;Freq&quot; column contains the number of events per year.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample time series data frame
set.seed(123)
ms &lt;- data.frame(date = seq(as.Date("2000-01-01"), as.Date("2022-12-31"), by = "day"),
                values=rnorm(8401))
# Generate random events
events &lt;- match(sample(ms$date, 100),ms$date)
# Get the number of events per year
tsGetNumberPerYear(ms, events)
</code></pre>

<hr>
<h2 id='tsGetPOT'>tsGetPOT Function</h2><span id='topic+tsGetPOT'></span>

<h3>Description</h3>

<p><code>tsGetPOT</code> is a function that calculates the Peaks Over Threshold (POT)
for a given time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsGetPOT(
  ms,
  pcts,
  desiredEventsPerYear,
  minEventsPerYear,
  minPeakDistanceInDays,
  tail
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsGetPOT_+3A_ms">ms</code></td>
<td>
<p>A matrix containing the time series data with two columns:
the first column represents the time and the second column represents the values.</p>
</td></tr>
<tr><td><code id="tsGetPOT_+3A_pcts">pcts</code></td>
<td>
<p>A numeric vector specifying the percentiles to be used as
thresholds for identifying peaks.</p>
</td></tr>
<tr><td><code id="tsGetPOT_+3A_desiredeventsperyear">desiredEventsPerYear</code></td>
<td>
<p>The desired number of events per year.</p>
</td></tr>
<tr><td><code id="tsGetPOT_+3A_mineventsperyear">minEventsPerYear</code></td>
<td>
<p>The minimum number of events per year.</p>
</td></tr>
<tr><td><code id="tsGetPOT_+3A_minpeakdistanceindays">minPeakDistanceInDays</code></td>
<td>
<p>The minimum distance between two peaks in days.</p>
</td></tr>
<tr><td><code id="tsGetPOT_+3A_tail">tail</code></td>
<td>
<p>The tail to be studied for POT selection, either 'high' or 'low'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following fields:
</p>

<dl>
<dt><code>threshold</code></dt><dd><p>The threshold value used for identifying peaks</p>
</dd>
<dt><code>thresholdError</code></dt><dd><p>The error associated with the threshold value</p>
</dd>
<dt><code>percentile</code></dt><dd><p>The percentile value used as the threshold.</p>
</dd>
<dt><code>peaks</code></dt><dd><p>The values of the identified peaks.</p>
</dd>
<dt><code>stpeaks</code></dt><dd><p>The start indices of the identified peaks.</p>
</dd>
<dt><code>endpeaks</code></dt><dd><p>The end indices of the identified peaks.</p>
</dd>
<dt><code>ipeaks</code></dt><dd><p>The indices of the identified peaks.</p>
</dd>
<dt><code>time</code></dt><dd><p>The time values corresponding to the identified peaks.</p>
</dd>
<dt><code>pars</code></dt><dd><p>The parameters of the Generalized Pareto Distribution (GPD)
fitted to the peaks.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+tsEvaSampleData">tsEvaSampleData()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a sample time series data
ms &lt;- ArdecheStMartin

# Calculate the POT using the tsGetPOT function
pcts &lt;- c(90, 95, 99)
desiredEventsPerYear &lt;- 5
minEventsPerYear &lt;- 2
minPeakDistanceInDays &lt;- 10
tail &lt;- "high"
POTdata &lt;- tsGetPOT(ms, pcts, desiredEventsPerYear, minEventsPerYear, minPeakDistanceInDays, tail)
# Print the results
print(POTdata)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
