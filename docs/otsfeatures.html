<!DOCTYPE html><html lang="en"><head><title>Help for package otsfeatures</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {otsfeatures}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AustrianWages'><p>AustrianWages</p></a></li>
<li><a href='#binarization'><p>Constructs the binarized time series associated with a given</p>
ordinal time series</a></li>
<li><a href='#c_binarization'><p>Constructs the cumulative binarized time series associated with a given</p>
ordinal time series</a></li>
<li><a href='#c_conditional_probabilities'><p>Computes the cumulative conditional probabilities of an ordinal time series</p></a></li>
<li><a href='#c_joint_probabilities'><p>Computes the cumulative joint probabilities of an ordinal time series</p></a></li>
<li><a href='#c_marginal_probabilities'><p>Computes the cumulative marginal probabilities of an ordinal time series</p></a></li>
<li><a href='#ci_ordinal_asymmetry'><p>Constructs a confidence interval for the</p>
ordinal asymmetry (block distance)</a></li>
<li><a href='#ci_ordinal_dispersion'><p>Constructs a confidence interval for the</p>
ordinal dispersion (block distance)</a></li>
<li><a href='#ci_ordinal_skewness'><p>Constructs a confidence interval for the</p>
ordinal skewness (block distance)</a></li>
<li><a href='#conditional_probabilities'><p>Computes the conditional probabilities of an ordinal time series</p></a></li>
<li><a href='#CreditRatings'><p>CreditRatings</p></a></li>
<li><a href='#index_ordinal_variation'><p>Computes the  estimated index of ordinal variation (IOV) of an ordinal time series</p></a></li>
<li><a href='#joint_probabilities'><p>Computes the joint probabilities of an ordinal time series</p></a></li>
<li><a href='#marginal_probabilities'><p>Computes the marginal probabilities of an ordinal time series</p></a></li>
<li><a href='#ordinal_asymmetry'><p>Computes the estimated asymmetry of an ordinal time series</p></a></li>
<li><a href='#ordinal_cohens_kappa'><p>Computes the estimated ordinal Cohen's kappa of an ordinal time series</p></a></li>
<li><a href='#ordinal_dispersion_1'><p>Computes the standard estimated dispersion of an ordinal time series</p></a></li>
<li><a href='#ordinal_dispersion_2'><p>Computes the estimated dispersion of an ordinal time series according to</p>
the approach based on the diversity coefficient (DIVC)</a></li>
<li><a href='#ordinal_location_1'><p>Computes the standard estimated location of an ordinal time series</p></a></li>
<li><a href='#ordinal_location_2'><p>Computes the estimated location of an ordinal time series</p>
with respect to the lowest category</a></li>
<li><a href='#ordinal_skewness'><p>Computes the estimated skewness of an ordinal time series</p></a></li>
<li><a href='#ots_plot'><p>Constructs an ordinal time series plot</p></a></li>
<li><a href='#plot_ordinal_cohens_kappa'><p>Constructs a serial dependence plot based on the ordinal Cohen's kappa</p>
considering the block distance</a></li>
<li><a href='#SyntheticData1'><p>SyntheticData1</p></a></li>
<li><a href='#SyntheticData2'><p>SyntheticData2</p></a></li>
<li><a href='#SyntheticData3'><p>SyntheticData3</p></a></li>
<li><a href='#test_ordinal_asymmetry'><p>Performs the hypothesis test associated with the</p>
ordinal asymmetry for the block distance</a></li>
<li><a href='#test_ordinal_dispersion'><p>Performs the hypothesis test associated with the</p>
ordinal dispersion for the block distance</a></li>
<li><a href='#test_ordinal_skewness'><p>Performs the hypothesis test associated with the</p>
ordinal skewness for the block distance</a></li>
<li><a href='#total_c_correlation'><p>Computes the total cumulative correlation of an ordinal time series</p></a></li>
<li><a href='#total_mixed_c_correlation_1'><p>Computes the total mixed cumulative linear correlation (TMCLC) between an ordinal and a</p>
real-valued time series</a></li>
<li><a href='#total_mixed_c_correlation_2'><p>Computes the total mixed cumulative quantile correlation (TMCQC) between an ordinal and a</p>
real-valued time series</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ordinal Time Series Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of several functions for feature extraction in 
    ordinal time series datasets. Specifically, some of the features proposed by
    Weiss (2019) &lt;<a href="https://doi.org/10.1080%2F01621459.2019.1604370">doi:10.1080/01621459.2019.1604370</a>&gt; can be computed.  
    These features can be used to perform inferential tasks or to feed machine
    learning algorithms for ordinal time series, among others. The package also includes some
    interesting datasets containing financial time series. Practitioners from a 
    broad variety of fields could benefit from the general framework provided 
    by 'otsfeatures'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, astsa, latex2exp, Rdpack, Bolstad2</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 19:04:18 UTC; angel</td>
</tr>
<tr>
<td>Author:</td>
<td>Angel Lopez-Oriona [aut, cre],
  Jose A. Vilar [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Angel Lopez-Oriona &lt;oriona38@hotmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-01 10:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AustrianWages'>AustrianWages</h2><span id='topic+AustrianWages'></span>

<h3>Description</h3>

<p>Ordinal time series (OTS) of yearly categories of salaries for different
Austrian employees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(AustrianWages)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with one element, which is:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A list with 9402 MTS.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each element in <code>data</code> is an ordinal time series
containing 6 states (yearly categorized wages). 9402 Austrian workers
considered. The series exhibit individual lengths ranging from 2 to 32 years with the median length being equal to 22.
For more information, see López-Oriona et al. (2023).
</p>


<h3>References</h3>


<p>López-Oriona Á, Weiß C, Vilar JA (2023).
&ldquo;Fuzzy clustering of ordinal time series based on two novel distances with     financial applications.&rdquo;
<em>Manuscript submitted for publication</em>, 000-000.
</p>


<hr>
<h2 id='binarization'>Constructs the binarized time series associated with a given
ordinal time series</h2><span id='topic+binarization'></span>

<h3>Description</h3>

<p><code>binarization</code> constructs the binarized time series associated with a given
ordinal time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarization(series, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarization_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="binarization_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function
constructs the binarized time series, which is defined as
<code class="reqn">\overline{\boldsymbol Y}_t=\{\overline{\boldsymbol Y}_1, \ldots, \overline{\boldsymbol Y}_T\}</code>,
with <code class="reqn">\overline{\boldsymbol Y}_k=(\overline{Y}_{k,0}, \overline{Y}_{k,1},\ldots, \overline{Y}_{k,n})^\top</code>
such that <code class="reqn">\overline{Y}_{k,i}=1</code> if <code class="reqn">\overline{X}_k=s_i</code> (<code class="reqn">k=1,\ldots,T,
, i=0,\ldots,n</code>). The binarized series is constructed in the form of a matrix
whose rows represent time observations and whose columns represent the
states in the original series.
</p>


<h3>Value</h3>

<p>The binarized time series.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2018).
<em>An introduction to discrete-valued time series</em>.
John Wiley and Sons.
López-Oriona Á, Vilar JA, D’Urso P (2023).
&ldquo;Hard and soft clustering of categorical time series based on two novel distances with an application to biological sequences.&rdquo;
<em>Information Sciences</em>, <b>624</b>, 467&ndash;492.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>binarized_series &lt;- binarization(AustrianWages$data[[100]],
states = 0 : 5) # Constructing the binarized
# time series for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='c_binarization'>Constructs the cumulative binarized time series associated with a given
ordinal time series</h2><span id='topic+c_binarization'></span>

<h3>Description</h3>

<p><code>c_binarization</code> constructs the cumulative binarized time series associated with a given
ordinal time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_binarization(series, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_binarization_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="c_binarization_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function
constructs the cumulative binarized time series, which is defined as
<code class="reqn">\overline{\boldsymbol Y}_t=\{\overline{\boldsymbol Y}_1, \ldots, \overline{\boldsymbol Y}_T\}</code>,
with <code class="reqn">\overline{\boldsymbol Y}_k=(\overline{Y}_{k,0}, \overline{Y}_{k,1},\ldots, \overline{Y}_{k,n-1})^\top</code>
such that <code class="reqn">\overline{Y}_{k,i}=1</code> if <code class="reqn">\overline{X}_k \le s_i</code> (<code class="reqn">k=1,\ldots,T,
, i=0,\ldots,n-1</code>). The cumulative binarized series is constructed in the form of a matrix
whose rows represent time observations and whose columns represent the
states in the original series.
</p>


<h3>Value</h3>

<p>The binarized time series.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2018).
<em>An introduction to discrete-valued time series</em>.
John Wiley and Sons.
</p>
<p>López-Oriona Á, Vilar JA, D’Urso P (2023).
&ldquo;Hard and soft clustering of categorical time series based on two novel distances with an application to biological sequences.&rdquo;
<em>Information Sciences</em>, <b>624</b>, 467&ndash;492.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>c_binarized_series &lt;- c_binarization(AustrianWages$data[[100]],
states = 0 : 5) # Constructing the cumulative binarized
# time series for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='c_conditional_probabilities'>Computes the cumulative conditional probabilities of an ordinal time series</h2><span id='topic+c_conditional_probabilities'></span>

<h3>Description</h3>

<p><code>c_conditional_probabilities</code> returns a matrix with the cumulative conditional
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_conditional_probabilities(series, lag = 1, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_conditional_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="c_conditional_probabilities_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="c_conditional_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
matrix <code class="reqn">\widehat{\boldsymbol F}^c(l) = \big(\widehat{f}^c_{i-1j-1}(l)\big)_{1 \le i, j \le n}</code>,
with <code class="reqn">\widehat{f}^c_{ij}(l)=\frac{TN_{ij}(l)}{(T-l)N_i}</code>, where
<code class="reqn">N_i</code> is the number of elements less one or equal to <code class="reqn">s_i</code> in the realization <code class="reqn">\overline{X}_t</code> and <code class="reqn">N_{ij}(l)</code> is the number
of pairs <code class="reqn">(\overline{X}_t, \overline{X}_{t-l})</code> in the realization <code class="reqn">\overline{X}_t</code>
such that <code class="reqn">\overline{X}_t \le s_i</code> and <code class="reqn">\overline{X}_{t-l} \le s_j</code>.
</p>


<h3>Value</h3>

<p>A matrix with the conditional probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>matrix_ccp &lt;- c_conditional_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the matrix of
# cumulative conditional probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='c_joint_probabilities'>Computes the cumulative joint probabilities of an ordinal time series</h2><span id='topic+c_joint_probabilities'></span>

<h3>Description</h3>

<p><code>c_joint_probabilities</code> returns a matrix with the cumulative joint
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_joint_probabilities(series, lag = 1, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_joint_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="c_joint_probabilities_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="c_joint_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
matrix <code class="reqn">\widehat{\boldsymbol F}(l) = \big(\widehat{f}_{i-1j-1}(l)\big)_{1 \le i, j \le n}</code>,
with <code class="reqn">\widehat{f}_{ij}(l)=\frac{N_{ij}(l)}{T-l}</code>, where <code class="reqn">N_{ij}(l)</code> is the number
of pairs <code class="reqn">(\overline{X}_t, \overline{X}_{t-l})</code> in the realization <code class="reqn">\overline{X}_t</code>
such that <code class="reqn">\overline{X}_t \le s_i</code> and <code class="reqn">\overline{X}_{t-l} \le s_j</code>.
</p>


<h3>Value</h3>

<p>A matrix with the jcumulative oint probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>matrix_cjp &lt;- c_joint_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the matrix of
# cumulative joint probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='c_marginal_probabilities'>Computes the cumulative marginal probabilities of an ordinal time series</h2><span id='topic+c_marginal_probabilities'></span>

<h3>Description</h3>

<p><code>c_marginal_probabilities</code> returns a vector with the cumulative marginal
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_marginal_probabilities(series, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c_marginal_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="c_marginal_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
vector <code class="reqn">\widehat{\boldsymbol f} =(\widehat{f}_0, \ldots, \widehat{f}_n)</code>,
with <code class="reqn">\widehat{f}_i=\frac{N_i}{T}</code>, where <code class="reqn">N_i</code> is the number
of elements less than or equal to <code class="reqn">s_i</code> in the realization <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>A vector with the cumulative marginal probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>vector_cmp &lt;- c_marginal_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the vector of
# cumulative marginal probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='ci_ordinal_asymmetry'>Constructs a confidence interval for the
ordinal asymmetry (block distance)</h2><span id='topic+ci_ordinal_asymmetry'></span>

<h3>Description</h3>

<p><code>ci_ordinal_asymmetry</code> constructs a confidence interval for the
ordinal asymmetry (block distance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_ordinal_asymmetry(
  series,
  states,
  level = 0.95,
  temporal = TRUE,
  max_lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_ordinal_asymmetry_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="ci_ordinal_asymmetry_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ci_ordinal_asymmetry_+3A_level">level</code></td>
<td>
<p>The confidence level (default is 0.95).</p>
</td></tr>
<tr><td><code id="ci_ordinal_asymmetry_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the interval is computed for a time series. Otherwise,
the interval is computed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="ci_ordinal_asymmetry_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function constructs the confidence interval for the
ordinal asymmetry relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the interval is constructed according to Theorem 4.1 in Weiß (2019).
</p>


<h3>Value</h3>

<p>The confidence interval.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ci_asymmetry &lt;- ci_ordinal_asymmetry(AustrianWages$data[[100]],
states = 0 : 5) # Constructing a confidence interval for the
# ordinal asymmetry for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='ci_ordinal_dispersion'>Constructs a confidence interval for the
ordinal dispersion (block distance)</h2><span id='topic+ci_ordinal_dispersion'></span>

<h3>Description</h3>

<p><code>ci_ordinal_dispersion</code> constructs a confidence interval for the
ordinal dispersion (block distance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_ordinal_dispersion(
  series,
  states,
  level = 0.95,
  temporal = TRUE,
  max_lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_ordinal_dispersion_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="ci_ordinal_dispersion_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ci_ordinal_dispersion_+3A_level">level</code></td>
<td>
<p>The confidence level (default is 0.95).</p>
</td></tr>
<tr><td><code id="ci_ordinal_dispersion_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the interval is computed for a time series. Otherwise,
the interval is computed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="ci_ordinal_dispersion_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function constructs the confidence interval for the
ordinal dispersion relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the interval is constructed according to Theorem 4.1 in Weiß (2019).
</p>


<h3>Value</h3>

<p>The confidence interval.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ci_dispersion &lt;- ci_ordinal_dispersion(AustrianWages$data[[100]],
states = 0 : 5) # Constructing a confidence interval for the
# ordinal dispersion for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='ci_ordinal_skewness'>Constructs a confidence interval for the
ordinal skewness (block distance)</h2><span id='topic+ci_ordinal_skewness'></span>

<h3>Description</h3>

<p><code>ci_ordinal_skewness</code> constructs a confidence interval for the
ordinal skewness (block distance)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ci_ordinal_skewness(series, states, level = 0.95, temporal = TRUE, max_lag = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ci_ordinal_skewness_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="ci_ordinal_skewness_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ci_ordinal_skewness_+3A_level">level</code></td>
<td>
<p>The confidence level (default is 0.95).</p>
</td></tr>
<tr><td><code id="ci_ordinal_skewness_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the interval is computed for a time series. Otherwise,
the interval is computed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="ci_ordinal_skewness_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function constructs the confidence interval for the
ordinal skewness relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the interval is constructed according to Theorem 4.1 in Weiß (2019).
</p>


<h3>Value</h3>

<p>The confidence interval.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ci_skewness &lt;- ci_ordinal_skewness(AustrianWages$data[[100]],
states = 0 : 5) # Constructing a confidence interval for the
# ordinal skewness for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='conditional_probabilities'>Computes the conditional probabilities of an ordinal time series</h2><span id='topic+conditional_probabilities'></span>

<h3>Description</h3>

<p><code>conditional_probabilities</code> returns a matrix with the conditional
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conditional_probabilities(series, lag = 1, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="conditional_probabilities_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="conditional_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
matrix <code class="reqn">\widehat{\boldsymbol P}^c(l) = \big(\widehat{p}^c_{i-1j-1}(l)\big)_{1 \le i, j \le n+1}</code>,
with <code class="reqn">\widehat{p}^c_{ij}(l)=\frac{TN_{ij}(l)}{(T-l)N_i}</code>, where
<code class="reqn">N_i</code> is the number of elements equal to <code class="reqn">s_i</code> in the realization <code class="reqn">\overline{X}_t</code> and <code class="reqn">N_{ij}(l)</code> is the number
of pairs <code class="reqn">(\overline{X}_t, \overline{X}_{t-l})=(s_i,s_j)</code> in the realization <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>A matrix with the conditional probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>matrix_cp &lt;- conditional_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the matrix of
# conditional probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='CreditRatings'>CreditRatings</h2><span id='topic+CreditRatings'></span>

<h3>Description</h3>

<p>Ordinal time series (OTS) of monthly credit ratings of different
European countries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CreditRatings)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with one element, which is:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A list with 28 MTS.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each element in <code>data</code> is an ordinal time series
containing 23 states (monthly credit ratings). The 28 countries of the European Union plus
the United Kingdom are considered. The sample period spans from January 2000 to December 2017, thus resulting serial realizations of length <code class="reqn">T=216</code>.
For more information, see Weiß (2019).
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<hr>
<h2 id='index_ordinal_variation'>Computes the  estimated index of ordinal variation (IOV) of an ordinal time series</h2><span id='topic+index_ordinal_variation'></span>

<h3>Description</h3>

<p><code>index_ordinal_variation</code> computes the estimated index of ordinal variation
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>index_ordinal_variation(series, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index_ordinal_variation_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="index_ordinal_variation_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
estimated IOV given by <code class="reqn">\widehat{IOV}=\frac{4}{n}\sum_{k=1}^{n-1}\widehat{f}_k(1-\widehat{f}_k)</code>,
where <code class="reqn">\widehat{f}_k</code> is the standard estimate of the cumulative marginal probability
for state <code class="reqn">s_k</code> computed from the series <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>The estimated IOV.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_iov &lt;- index_ordinal_variation(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the estimate of the IOV
# for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='joint_probabilities'>Computes the joint probabilities of an ordinal time series</h2><span id='topic+joint_probabilities'></span>

<h3>Description</h3>

<p><code>joint_probabilities</code> returns a matrix with the joint
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>joint_probabilities(series, lag = 1, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="joint_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="joint_probabilities_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="joint_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
matrix <code class="reqn">\widehat{\boldsymbol P}(l) = \big(\widehat{p}_{i-1j-1}(l)\big)_{1 \le i, j \le n+1}</code>,
with <code class="reqn">\widehat{p}_{ij}(l)=\frac{N_{ij}(l)}{T-l}</code>, where <code class="reqn">N_{ij}(l)</code> is the number
of pairs <code class="reqn">(\overline{X}_t, \overline{X}_{t-l})=(s_i,s_j)</code> in the realization <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>A matrix with the joint probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>matrix_jp &lt;- joint_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the matrix of
# joint probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='marginal_probabilities'>Computes the marginal probabilities of an ordinal time series</h2><span id='topic+marginal_probabilities'></span>

<h3>Description</h3>

<p><code>marginal_probabilities</code> returns a vector with the marginal
probabilities of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_probabilities(series, states)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="marginal_probabilities_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="marginal_probabilities_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
vector <code class="reqn">\widehat{\boldsymbol p} =(\widehat{p}_0, \ldots, \widehat{p}_n)</code>,
with <code class="reqn">\widehat{p}_i=\frac{N_i}{T}</code>, where <code class="reqn">N_i</code> is the number
of elements equal to <code class="reqn">s_i</code> in the realization <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>A vector with the marginal probabilities.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>vector_mp &lt;- marginal_probabilities(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the vector of
# marginal probabilities for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='ordinal_asymmetry'>Computes the estimated asymmetry of an ordinal time series</h2><span id='topic+ordinal_asymmetry'></span>

<h3>Description</h3>

<p><code>ordinal_asymmetry</code> computes the estimated asymmetry
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_asymmetry(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_asymmetry_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_asymmetry_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_asymmetry_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_asymmetry_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the estimated asymmetry is returned. Otherwise, the function
returns the normalized estimated asymmetry.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
estimated asymmetry given by <code class="reqn">\widehat{asym}_{d}=\widehat{\boldsymbol p}^\top (\boldsymbol J-\boldsymbol I)\boldsymbol D\widehat{\boldsymbol p}</code>,
where <code class="reqn">\widehat{\boldsymbol p}=(\widehat{p}_0, \widehat{p}_1, \ldots, \widehat{p}_n)^\top</code>,
with <code class="reqn">\widehat{p}_k</code> being the standard estimate of the marginal probability for state
<code class="reqn">s_k</code>, <code class="reqn">\boldsymbol I</code> and <code class="reqn">\boldsymbol J</code> are the identity and counteridentity
matrices of order <code class="reqn">n + 1</code>, respectively, and <code class="reqn">\boldsymbol D</code> is a pairwise distance
matrix for the elements in the set <code class="reqn">\mathcal{S}</code> considering a specific distance
between ordinal states, <code class="reqn">d(\cdot, \cdot)</code>. If <code>normalize = TRUE</code>, then the normalized estimate is computed, namely
<code class="reqn">\frac{\widehat{asym}_{d}}{max_{s_i, s_j \in \mathcal{S}}d(s_i, s_j)}</code>.
</p>


<h3>Value</h3>

<p>The estimated asymmetry.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_asymmetry &lt;- ordinal_asymmetry(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the asymmetry estimate
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ordinal_cohens_kappa'>Computes the estimated ordinal Cohen's kappa of an ordinal time series</h2><span id='topic+ordinal_cohens_kappa'></span>

<h3>Description</h3>

<p><code>ordinal_cohens_kappa</code> computes the estimated ordinal Cohen's kappa
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_cohens_kappa(series, states, distance = "Block", lag = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_cohens_kappa_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_cohens_kappa_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_cohens_kappa_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_cohens_kappa_+3A_lag">lag</code></td>
<td>
<p>The considered lag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
estimated ordinal Cohen's kappa given by <code class="reqn">\widehat{\kappa}_d(l)=\frac{\widehat{disp}_d(X_t)-\widehat{E}[d(X_t, X_{t-l})]}{{\widehat{disp}}_d(X_t)}</code>,
where <code class="reqn">\widehat{disp}_{d}(X_t)=\frac{T}{T-1}\sum_{i,j=0}^nd\big(s_i, s_j\big)\widehat{p}_i\widehat{p}_j</code> is the DIVC estimate of the dispersion, with
<code class="reqn">d(\cdot, \cdot)</code> being a distance between ordinal states and <code class="reqn">\widehat{p}_k</code> being the
standard estimate of the marginal probability for state <code class="reqn">s_k</code>,
and <code class="reqn">\widehat{E}[d(X_t, X_{t-l})]=\frac{1}{T-l} \sum_{t=l+1}^T d(\overline{X}_t, \overline{X}_{t-l})</code>.
</p>


<h3>Value</h3>

<p>The estimated ordinal Cohen's kappa.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_ock &lt;- ordinal_cohens_kappa(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the estimated ordinal Cohen's kappa
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ordinal_dispersion_1'>Computes the standard estimated dispersion of an ordinal time series</h2><span id='topic+ordinal_dispersion_1'></span>

<h3>Description</h3>

<p><code>ordinal_dispersion_1</code> computes the standard estimated dispersion
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_dispersion_1(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_dispersion_1_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_1_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_1_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_1_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the standard estimated dispersion is returned. Otherwise, the function
returns the normalized standard estimated dispersion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the standard
estimated dispersion given by <code class="reqn">\widehat{disp}_{loc, d}=\frac{1}{T}\sum_{t=1}^Td\big(\overline{X}_t, \widehat{x}_{loc, d}\big)</code>,
where <code class="reqn">\widehat{x}_{loc, d}</code> is the standard estimate of the location and <code class="reqn">d(\cdot, \cdot)</code> is a distance between ordinal states.
If <code>normalize = TRUE</code>, then the normalized dispersion is computed, namely
<code class="reqn">\widehat{disp}_{loc, d}/</code>max<code class="reqn">_{s_i, s_j \in \mathcal{S}}d(s_i, s_j)</code>.
</p>


<h3>Value</h3>

<p>The standard estimated dispersion.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_dispersion &lt;- ordinal_dispersion_1(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the standard dispersion estimate
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ordinal_dispersion_2'>Computes the estimated dispersion of an ordinal time series according to
the approach based on the diversity coefficient (DIVC)</h2><span id='topic+ordinal_dispersion_2'></span>

<h3>Description</h3>

<p><code>ordinal_dispersion_2</code> computes the estimated dispersion
of an ordinal time series according to the approach based on the
diversity coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_dispersion_2(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_dispersion_2_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_2_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_2_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_dispersion_2_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the estimated dispersion is returned. Otherwise, the function
returns the normalized estimated dispersion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the DIVC
estimated dispersion given by <code class="reqn">\widehat{disp}_{d}=\frac{T}{T-1}\sum_{i,j=0}^nd\big(s_i, s_j\big)\widehat{p}_i\widehat{p}_j</code>,
where <code class="reqn">d(\cdot, \cdot)</code> is a distance between ordinal states and <code class="reqn">\widehat{p}_k</code> is the
standard estimate of the marginal probability for state <code class="reqn">s_k</code>.
If <code>normalize = TRUE</code>, and <code>distance = "Block"</code> or <code>distance = "Euclidean"</code>, then the normalized versions are computed, that is,
the corresponding estimates are divided by the factors <code class="reqn">2/m</code> or <code class="reqn">2/m^2</code>, respectively.
</p>


<h3>Value</h3>

<p>The estimated dispersion according to the approach based on the
diversity coefficient.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_dispersion &lt;- ordinal_dispersion_2(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the DIVC dispersion estimate
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ordinal_location_1'>Computes the standard estimated location of an ordinal time series</h2><span id='topic+ordinal_location_1'></span>

<h3>Description</h3>

<p><code>ordinal_location_1</code> computes the standard estimated location
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_location_1(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_location_1_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_location_1_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_location_1_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_location_1_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the standard estimated location is returned. Otherwise, the function
returns the normalized standard estimated location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the standard
estimated location given by <code class="reqn">\widehat{x}_{loc, d}=</code>argmin<code class="reqn">_{s \in \mathcal{S}}\frac{1}{T}\sum_{t=1}^Td\big(\overline{X}_t, s\big)</code>,
where <code class="reqn">d(\cdot, \cdot)</code> is a distance between ordinal states.
</p>


<h3>Value</h3>

<p>The standard estimated location.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_location &lt;- ordinal_location_1(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the standard location estimate
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ordinal_location_2'>Computes the estimated location of an ordinal time series
with respect to the lowest category</h2><span id='topic+ordinal_location_2'></span>

<h3>Description</h3>

<p><code>ordinal_location_2</code> computes the estimated location
of an ordinal time series with respect to the lowest category
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_location_2(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_location_2_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_location_2_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_location_2_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_location_2_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the standard estimated location is returned. Otherwise, the function
returns the normalized standard estimated location.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
estimated location with respect to the lowest state, that is, the state
<code class="reqn">s_j</code> such that <code class="reqn">a_j=d(s_j, s_0)</code> is the closest to
<code class="reqn">\frac{1}{T}\sum_{t=1}^Td\big(\overline{X}_t, s_0\big)</code> is determined,
where <code class="reqn">d(\cdot, \cdot)</code> is a distance between ordinal states.
</p>


<h3>Value</h3>

<p>The estimated location with respect to the lowest category.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_location &lt;- ordinal_location_2(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the location estimate
# with respect to the lowest state for one series in dataset AustrianWages
</code></pre>

<hr>
<h2 id='ordinal_skewness'>Computes the estimated skewness of an ordinal time series</h2><span id='topic+ordinal_skewness'></span>

<h3>Description</h3>

<p><code>ordinal_skewness</code> computes the estimated skewness
of an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinal_skewness(series, states, distance = "Block", normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinal_skewness_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ordinal_skewness_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ordinal_skewness_+3A_distance">distance</code></td>
<td>
<p>A function defining the underlying distance between
states. The Hamming, block and Euclidean distances are already
implemented by means of the arguments &quot;Hamming&quot;, &quot;Block&quot; (default)
and &quot;Euclidean&quot;. Otherwise, a function taking as input two states must
be provided.</p>
</td></tr>
<tr><td><code id="ordinal_skewness_+3A_normalize">normalize</code></td>
<td>
<p>Logical. If <code>normalize = FALSE</code> (default), the value of the estimated skewness is returned. Otherwise, the function
returns the normalized estimated skewness.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, s_2, \ldots, s_n\}</code> (<code class="reqn">s_0 &lt; s_1 &lt; s_2 &lt; \ldots &lt; s_n</code>),
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, the function computes the
estimated skewness given by <code class="reqn">\widehat{skew}_{d}=\sum_{i=0}^n\big(d(s_i,s_n)-d(s_i,s_0)\big)\widehat{p}_i</code>,
where <code class="reqn">d(\cdot, \cdot)</code> is a distance between ordinal states and <code class="reqn">\widehat{p}_k</code> is the standard estimate
of the marginal probability for state <code class="reqn">s_k</code> computed from the realization <code class="reqn">\overline{X}_t</code>.
</p>


<h3>Value</h3>

<p>The estimated skewness.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>estimated_skewness &lt;- ordinal_skewness(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the skewness estimate
# for one series in dataset AustrianWages using the block distance
</code></pre>

<hr>
<h2 id='ots_plot'>Constructs an ordinal time series plot</h2><span id='topic+ots_plot'></span>

<h3>Description</h3>

<p><code>ots_plot</code> constructs an ordinal time series plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ots_plot(series, states, title = "Time series plot", labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ots_plot_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="ots_plot_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="ots_plot_+3A_title">title</code></td>
<td>
<p>The title of the graph.</p>
</td></tr>
<tr><td><code id="ots_plot_+3A_labels">labels</code></td>
<td>
<p>The labels of the graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs an ordinal time series plot for a given OTS.
</p>


<h3>Value</h3>

<p>The ordinal time series plot.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2018).
<em>An introduction to discrete-valued time series</em>.
John Wiley and Sons.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>ordinal_time_series_plot &lt;- ots_plot(series = AustrianWages$data[[100]],,
states = 0 : 5) # Constructs an ordinal
# time series plot for one series in
# dataset AustrianWages
</code></pre>

<hr>
<h2 id='plot_ordinal_cohens_kappa'>Constructs a serial dependence plot based on the ordinal Cohen's kappa
considering the block distance</h2><span id='topic+plot_ordinal_cohens_kappa'></span>

<h3>Description</h3>

<p><code>plot_ordinal_cohens_kappa</code> constructs a serial dependence plot of an ordinal
time series based on the ordinal Cohen's kappa considering the block distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ordinal_cohens_kappa(
  series,
  states,
  max_lag = 10,
  alpha = 0.05,
  plot = TRUE,
  title = "Serial dependence plot",
  bar_width = 0.12,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_max_lag">max_lag</code></td>
<td>
<p>The maximum lag represented in the plot (default is 10).</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_alpha">alpha</code></td>
<td>
<p>The significance level for the corresponding hypothesis test (default is 0.05).</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_plot">plot</code></td>
<td>
<p>Logical. If <code>plot = TRUE</code> (default), returns the serial dependence
plot. Otherwise, returns a list with the values of the ordinal Cohens's kappa, the critical
value and the corresponding p-values.</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_title">title</code></td>
<td>
<p>The title of the graph.</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_bar_width">bar_width</code></td>
<td>
<p>The width of the corresponding bars.</p>
</td></tr>
<tr><td><code id="plot_ordinal_cohens_kappa_+3A_...">...</code></td>
<td>
<p>Additional parameters for the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Constructs a serial dependence plot based on the ordinal Cohens's kappa, <code class="reqn">\widehat{\kappa}_d(l)</code>,
for several lags, where <code class="reqn">d</code> is the block distance between ordinal states, that is, <code class="reqn">d(s_i, s_j)=|i-j|</code> for two states <code class="reqn">s_i</code> and <code class="reqn">s_j</code>.
A dashed lined is incorporated indicating the critical value
of the test based on the following asymptotic approximation (under the i.i.d. assumption):
</p>
<p style="text-align: center;"><code class="reqn">\sqrt{\frac{T\widehat{disp}_d^2}{4\sum_{k,l=0}^{n-1}(\widehat{f}_{min\{k,l\}}-\widehat{f}_k\widehat{f}_l)^2}}\bigg(\widehat{\kappa}_d(l)+\frac{1}{T}\bigg)\sim N\big(0, 1\big),</code>
</p>
<p> where <code class="reqn">T</code> is the series length,
<code class="reqn">\widehat{f_k}</code> is the estimated cumulative probability for state <code class="reqn">s_k</code>
and <code class="reqn">\widehat{disp}_d</code> is the DIVC estimate of the dispersion.
</p>


<h3>Value</h3>

<p>If <code>plot = TRUE</code> (default), returns the serial dependence plot based on the ordinal Cohens's kappa. Otherwise, the function
returns a list with the values of the ordinal Cohens's kappa, the critical
value and the corresponding p-values.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>plot_ock &lt;- plot_ordinal_cohens_kappa(series = AustrianWages$data[[100]],
states = 0 : 5, max_lag = 3) # Representing
# the serial dependence plot
list_ck &lt;- plot_ordinal_cohens_kappa(series = AustrianWages$data[[100]],
states = 0 : 5, max_lag = 3, plot = FALSE) # Obtaining
# the values of the ordinal Cohens's kappa, the critical value and the p-values
</code></pre>

<hr>
<h2 id='SyntheticData1'>SyntheticData1</h2><span id='topic+SyntheticData1'></span>

<h3>Description</h3>

<p>Synthetic dataset containing 80 OTS generated from four
different generating processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SyntheticData1)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with two elements, which are:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A list with 80 OTS.</p>
</dd>
<dt><code>classes</code></dt><dd><p>A numeric vector indicating the corresponding classes associated with the elements in <code>data</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each element in <code>data</code> is a 6-state OTS of length 600.
Series 1-20, 21-40, 41-60 and 61-80 were generated from
binomial AR(p) processes with different coefficients (see Scenario 1 in López-Oriona et al. (2023)).
Therefore, there are 4 different classes in the dataset.
</p>


<h3>References</h3>


<p>López-Oriona Á, Weiß C, Vilar JA (2023).
&ldquo;Fuzzy clustering of ordinal time series based on two novel distances with     financial applications.&rdquo;
<em>Manuscript submitted for publication</em>, 000-000.
</p>


<hr>
<h2 id='SyntheticData2'>SyntheticData2</h2><span id='topic+SyntheticData2'></span>

<h3>Description</h3>

<p>Synthetic dataset containing 80 OTS generated from four
different generating processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SyntheticData2)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with two elements, which are:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A list with 80 OTS.</p>
</dd>
<dt><code>classes</code></dt><dd><p>A numeric vector indicating the corresponding classes associated with the elements in <code>data</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each element in <code>data</code> is a 6-state OTS of length 600.
Series 1-20, 21-40, 41-60 and 61-80 were generated from
binomial INARCH(p) processes with different coefficients (see Scenario 2 in López-Oriona et al. (2023)).
Therefore, there are 4 different classes in the dataset.
</p>


<h3>References</h3>


<p>López-Oriona Á, Weiß C, Vilar JA (2023).
&ldquo;Fuzzy clustering of ordinal time series based on two novel distances with     financial applications.&rdquo;
<em>Manuscript submitted for publication</em>, 000-000.
</p>


<hr>
<h2 id='SyntheticData3'>SyntheticData3</h2><span id='topic+SyntheticData3'></span>

<h3>Description</h3>

<p>Synthetic dataset containing 80 OTS generated from four
different generating processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SyntheticData3)
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with two elements, which are:
</p>

<dl>
<dt><code>data</code></dt><dd><p>A list with 80 OTS.</p>
</dd>
<dt><code>classes</code></dt><dd><p>A numeric vector indicating the corresponding classes associated with the elements in <code>data</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Each element in <code>data</code> is a 6-state OTS of length 600.
Series 1-20, 21-40, 41-60 and 61-80 were generated from
ordinal logit AR(1) processes with different coefficients (see Scenario 3 in López-Oriona et al. (2023)).
Therefore, there are 4 different classes in the dataset.
</p>


<h3>References</h3>


<p>López-Oriona Á, Weiß C, Vilar JA (2023).
&ldquo;Fuzzy clustering of ordinal time series based on two novel distances with     financial applications.&rdquo;
<em>Manuscript submitted for publication</em>, 000-000.
</p>


<hr>
<h2 id='test_ordinal_asymmetry'>Performs the hypothesis test associated with the
ordinal asymmetry for the block distance</h2><span id='topic+test_ordinal_asymmetry'></span>

<h3>Description</h3>

<p><code>test_ordinal_asymmetry</code> performs the hypothesis test associated with the
ordinal asymmetry for the block distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_ordinal_asymmetry(
  series,
  states,
  true_asymmetry,
  alpha = 0.05,
  temporal = TRUE,
  max_lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_ordinal_asymmetry_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="test_ordinal_asymmetry_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="test_ordinal_asymmetry_+3A_true_asymmetry">true_asymmetry</code></td>
<td>
<p>The value for the true asymmetry.</p>
</td></tr>
<tr><td><code id="test_ordinal_asymmetry_+3A_alpha">alpha</code></td>
<td>
<p>The significance level (default is 0.05).</p>
</td></tr>
<tr><td><code id="test_ordinal_asymmetry_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the test is performed for a time series. Otherwise,
the test is performed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="test_ordinal_asymmetry_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function performs the hypothesis test based on the
ordinal asymmetry relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the test based on Theorem 4.1 in Weiß (2019) is carried out.
</p>


<h3>Value</h3>

<p>The results of the hypothesis test.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>results_test &lt;- test_ordinal_asymmetry(AustrianWages$data[[100]],
states = 0 : 5, true_asymmetry = 2) # Performing the hypothesis test associated with the
# ordinal asymmetry for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='test_ordinal_dispersion'>Performs the hypothesis test associated with the
ordinal dispersion for the block distance</h2><span id='topic+test_ordinal_dispersion'></span>

<h3>Description</h3>

<p><code>test_ordinal_dispersion</code> performs the hypothesis test associated with the
ordinal dispersion for the block distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_ordinal_dispersion(
  series,
  states,
  true_dispersion,
  alpha = 0.05,
  temporal = TRUE,
  max_lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_ordinal_dispersion_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="test_ordinal_dispersion_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="test_ordinal_dispersion_+3A_true_dispersion">true_dispersion</code></td>
<td>
<p>The value for the true dispersion.</p>
</td></tr>
<tr><td><code id="test_ordinal_dispersion_+3A_alpha">alpha</code></td>
<td>
<p>The significance level (default is 0.05).</p>
</td></tr>
<tr><td><code id="test_ordinal_dispersion_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the test is performed for a time series. Otherwise,
the test is performed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="test_ordinal_dispersion_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function performs the hypothesis test based on the
ordinal dispersion relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the test based on Theorem 4.1 in Weiß (2019) is carried out.
</p>


<h3>Value</h3>

<p>The results of the hypothesis test.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>results_test &lt;- test_ordinal_dispersion(AustrianWages$data[[100]],
states = 0 : 5, true_dispersion = 2) # Performing the hypothesis test associated with the
# ordinal dispersion for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='test_ordinal_skewness'>Performs the hypothesis test associated with the
ordinal skewness for the block distance</h2><span id='topic+test_ordinal_skewness'></span>

<h3>Description</h3>

<p><code>test_ordinal_skewness</code> performs the hypothesis test associated with the
ordinal skewness for the block distance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_ordinal_skewness(
  series,
  states,
  true_skewness,
  alpha = 0.05,
  temporal = TRUE,
  max_lag = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="test_ordinal_skewness_+3A_series">series</code></td>
<td>
<p>An OTS (numerical vector with integers).</p>
</td></tr>
<tr><td><code id="test_ordinal_skewness_+3A_states">states</code></td>
<td>
<p>A numeric vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="test_ordinal_skewness_+3A_true_skewness">true_skewness</code></td>
<td>
<p>The value for the true skewness.</p>
</td></tr>
<tr><td><code id="test_ordinal_skewness_+3A_alpha">alpha</code></td>
<td>
<p>The significance level (default is 0.05).</p>
</td></tr>
<tr><td><code id="test_ordinal_skewness_+3A_temporal">temporal</code></td>
<td>
<p>Logical. If <code>temporal = TRUE</code> (default), the test is performed for a time series. Otherwise,
the test is performed for i.i.d. data.</p>
</td></tr>
<tr><td><code id="test_ordinal_skewness_+3A_max_lag">max_lag</code></td>
<td>
<p>If <code>temporal = TRUE</code>, the maximum considered lag to compute the
estimates related to the cumulative joint probabilities.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>temporal = TRUE</code> (default), the function performs the hypothesis test based on the
ordinal skewness relying on Theorem 7.1.1 in Weiß (2019). Otherwise,
the test based on Theorem 4.1 in Weiß (2019) is carried out.
</p>


<h3>Value</h3>

<p>The results of the hypothesis test.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>References</h3>


<p>Weiß CH (2019).
&ldquo;Distance-based analysis of ordinal data and ordinal time series.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>results_test &lt;- test_ordinal_skewness(AustrianWages$data[[100]],
states = 0 : 5, true_skewness = 2) # Performing the hypothesis test associated with the
# ordinal skewness for one OTS in dataset AustrianWages
</code></pre>

<hr>
<h2 id='total_c_correlation'>Computes the total cumulative correlation of an ordinal time series</h2><span id='topic+total_c_correlation'></span>

<h3>Description</h3>

<p><code>total_c_correlation</code> returns the value of the total cumulative correlation for
an ordinal time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_c_correlation(series, lag = 1, states, features = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_c_correlation_+3A_series">series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="total_c_correlation_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="total_c_correlation_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="total_c_correlation_+3A_features">features</code></td>
<td>
<p>Logical. If <code>features = FALSE</code> (default), the value of the total cumulative correlation is returned. Otherwise, the function
returns a matrix with the individual components of the total cumulative correlation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, \ldots, s_n\}</code>,
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, and
the cumulative binarized time series, which is defined as
<code class="reqn">\overline{\boldsymbol Y}_t=\{\overline{\boldsymbol Y}_1, \ldots, \overline{\boldsymbol Y}_T\}</code>,
with <code class="reqn">\overline{\boldsymbol Y}_k=(\overline{Y}_{k,0}, \ldots, \overline{Y}_{k,n-1})^\top</code>
such that <code class="reqn">\overline{Y}_{k,i}=1</code> if <code class="reqn">\overline{X}_k\leq s_i</code> (<code class="reqn">k=1,\ldots,T,
, i=0,\ldots,n-1</code>), the function computes the estimated average <code class="reqn">\widehat{\Psi}(l)^c=\frac{1}{n^2}\sum_{i,j=0}^{n-1}\widehat{\psi}_{ij}(l)^2</code>,
where <code class="reqn">\widehat{\psi}_{ij}(l)</code> is the estimated correlation
<code class="reqn">\widehat{Corr}(Y_{t, i}, Y_{t-l, j})</code>, <code class="reqn">i,j=0, 1,\ldots,n-1</code>. If <code>features = TRUE</code>, the function
returns a matrix whose components are the quantities <code class="reqn">\widehat{\psi}_{ij}(l)</code>,
<code class="reqn">i,j=0,1, \ldots,n-1</code>.
</p>


<h3>Value</h3>

<p>If <code>features = FALSE</code> (default), returns the value of the total cumulative correlation. Otherwise, the function
returns a matrix of features, i.e., the matrix contains the features employed to compute the
total cumulative correlation.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tcc &lt;- total_c_correlation(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the total cumulative correlation
# for one of the series in dataset AustrianWages
feature_matrix &lt;- total_c_correlation(series = AustrianWages$data[[100]],
states = 0 : 5) # Computing the corresponding matrix of features
</code></pre>

<hr>
<h2 id='total_mixed_c_correlation_1'>Computes the total mixed cumulative linear correlation (TMCLC) between an ordinal and a
real-valued time series</h2><span id='topic+total_mixed_c_correlation_1'></span>

<h3>Description</h3>

<p><code>total_mixed_c_correlation_1</code> returns the TMCLC between an ordinal and a
real-valued time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_mixed_c_correlation_1(
  o_series,
  n_series,
  lag = 1,
  states,
  features = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_mixed_c_correlation_1_+3A_o_series">o_series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_1_+3A_n_series">n_series</code></td>
<td>
<p>A real-valued time series.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_1_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_1_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_1_+3A_features">features</code></td>
<td>
<p>Logical. If <code>features = FALSE</code> (default), the value of the TMCLC is returned. Otherwise, the function
returns a vector with the individual components of the TMCLC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, \ldots, s_n\}</code>,
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, and
the cumulative binarized time series, which is defined as
<code class="reqn">\overline{\boldsymbol Y}_t=\{\overline{\boldsymbol Y}_1, \ldots, \overline{\boldsymbol Y}_T\}</code>,
with <code class="reqn">\overline{\boldsymbol Y}_k=(\overline{Y}_{k,0}, \ldots, \overline{Y}_{k,n-1})^\top</code>
such that <code class="reqn">\overline{Y}_{k,i}=1</code> if <code class="reqn">\overline{X}_k \leq s_i</code> (<code class="reqn">k=1,\ldots,T
, i=0,\ldots,n-1</code>), the function computes the estimated TMCLC given by
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\Psi}_1^m(l)=\frac{1}{n}\sum_{i=0}^{n-1}\widehat{\psi}_{i}^*(l)^2,</code>
</p>
<p> where
<code class="reqn">\widehat{\psi}_{i}^*(l)=\widehat{Corr}(Y_{t,i}, Z_{t-l})</code>, with
<code class="reqn">\overline{Z}_t=\{\overline{Z}_1,\ldots, \overline{Z}_T\}</code> being a
<code class="reqn">T</code>-length real-valued time series. If <code>features = TRUE</code>, the function
returns a vector whose components are the quantities <code class="reqn">\widehat{\psi}_{i}(l)</code>,
<code class="reqn">i=0,1, \ldots,n-1</code>.
</p>


<h3>Value</h3>

<p>If <code>features = FALSE</code> (default), returns the value of the TMCLC. Otherwise, the function
returns a vector of features, i.e., the vector contains the features employed to compute the
TMCLC.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmclc &lt;- total_mixed_c_correlation_1(o_series = SyntheticData1$data[[1]],
n_series = rnorm(600), states = 0 : 5) # Computing the TMCLC
# between the first series in dataset SyntheticData1 and white noise
feature_vector &lt;- total_mixed_c_correlation_1(o_series = SyntheticData1$data[[1]],
n_series = rnorm(600), states = 0 : 5, features = TRUE) # Computing the corresponding
# vector of features
</code></pre>

<hr>
<h2 id='total_mixed_c_correlation_2'>Computes the total mixed cumulative quantile correlation (TMCQC) between an ordinal and a
real-valued time series</h2><span id='topic+total_mixed_c_correlation_2'></span>

<h3>Description</h3>

<p><code>total_mixed_c_correlation_2</code> returns the TMCQC
between an ordinal and a real-valued time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total_mixed_c_correlation_2(
  o_series,
  n_series,
  lag = 1,
  states,
  features = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="total_mixed_c_correlation_2_+3A_o_series">o_series</code></td>
<td>
<p>An OTS.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_2_+3A_n_series">n_series</code></td>
<td>
<p>A real-valued time series.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_2_+3A_lag">lag</code></td>
<td>
<p>The considered lag (default is 1).</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_2_+3A_states">states</code></td>
<td>
<p>A numerical vector containing the corresponding
states.</p>
</td></tr>
<tr><td><code id="total_mixed_c_correlation_2_+3A_features">features</code></td>
<td>
<p>Logical. If <code>features = FALSE</code> (default), the value of the TMCLC is returned. Otherwise, the function
returns a vector with the individual components of the TMCQC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a OTS of length <code class="reqn">T</code> with range <code class="reqn">\mathcal{S}=\{s_0, s_1, \ldots, s_n\}</code>,
<code class="reqn">\overline{X}_t=\{\overline{X}_1,\ldots, \overline{X}_T\}</code>, and
the cumulative binarized time series, which is defined as
<code class="reqn">\overline{\boldsymbol Y}_t=\{\overline{\boldsymbol Y}_1, \ldots, \overline{\boldsymbol Y}_T\}</code>,
with <code class="reqn">\overline{\boldsymbol Y}_k=(\overline{Y}_{k,0}, \ldots, \overline{Y}_{k,n-1})^\top</code>
such that <code class="reqn">\overline{Y}_{k,i}=1</code> if <code class="reqn">\overline{X}_k \leq s_i</code> (<code class="reqn">k=1,\ldots,T
, i=0,\ldots,n-1</code>), the function computes the estimated TMCQC given by
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\Psi}_2^m(l)=\frac{1}{n}\sum_{i=0}^{n-1}\int_{0}^{1}\widehat{\psi}^\rho_{i}(l)^2d\rho,</code>
</p>
<p> where
<code class="reqn">\widehat{\psi}_{i}^\rho(l)=\widehat{Corr}\big(Y_{t,i}, I(Z_{t-l}\leq q_{Z_t}(\rho)) \big)</code>, with
<code class="reqn">\overline{Z}_t=\{\overline{Z}_1,\ldots, \overline{Z}_T\}</code> being a
<code class="reqn">T</code>-length real-valued time series, <code class="reqn">\rho \in (0, 1)</code> a probability
level, <code class="reqn">I(\cdot)</code> the indicator function and <code class="reqn">q_{Z_t}</code> the quantile
function of the corresponding real-valued process. If <code>features = TRUE</code>, the function
returns a vector whose components are the quantities <code class="reqn">\int_{0}^{1}\widehat{\psi}^\rho_{i}(l)^2d\rho</code>,
<code class="reqn">i=0,1, \ldots,n-1</code>.
</p>


<h3>Value</h3>

<p>If <code>features = FALSE</code> (default), returns the value of the TMCQC. Otherwise, the function
returns a vector of features, i.e., the vector contains the features employed to compute the
TMCLC.
</p>


<h3>Author(s)</h3>

<p>Ángel López-Oriona, José A. Vilar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmclc &lt;- total_mixed_c_correlation_2(o_series = SyntheticData1$data[[1]],
n_series = rnorm(600), states = 0 : 5) # Computing the TMCQC
# between the first series in dataset SyntheticData1 and white noise
feature_vector &lt;- total_mixed_c_correlation_2(o_series = SyntheticData1$data[[1]],
n_series = rnorm(600), states = 0 : 5, features = TRUE) # Computing the corresponding
# vector of features
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
