<!DOCTYPE html><html lang="en"><head><title>Help for package NScluster</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NScluster}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#NScluster-package'>
<p>Simulation and Estimation of the Neyman-Scott Type Spatial Cluster Models</p></a></li>
<li><a href='#boot.mple'><p>Bootstrap resampling for MPLE</p></a></li>
<li><a href='#mple.cppm'><p>MPLE of Neyman-Scott Cluster Point Process Models and Their Extensions</p></a></li>
<li><a href='#palm.cppm'><p>Non-parametric and Parametric Estimation for Palm Intensity</p></a></li>
<li><a href='#plot.mple'><p>Show the Process for Optimizing Parameter Set</p></a></li>
<li><a href='#plot.Palm'>
<p>Plot Non-Parametric and Parametric Normalized Palm Intensity</p></a></li>
<li><a href='#print.mple'><p>Print Process for Maximizing Log-Palm Likelihood Function</p></a></li>
<li><a href='#sim.cppm'><p>Simulation for Neyman-Scott Cluster Point Process Models and Their</p>
Extensions</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.3.6-1</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Estimation of the Neyman-Scott Type Spatial
Cluster Models</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and estimation for Neyman-Scott spatial cluster point
 process models and their extensions, based on the methodology in Tanaka, Ogata,
 and Stoyan (2008) &lt;<a href="https://doi.org/10.1002%2Fbimj.200610339">doi:10.1002/bimj.200610339</a>&gt;. To estimate parameters by the
 simplex method, parallel computation using 'OpenMP' application programming
 interface is available. For more details see Tanaka, Saga and Nakano
 &lt;<a href="https://doi.org/10.18637%2Fjss.v098.i06">doi:10.18637/jss.v098.i06</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>MailingList:</td>
<td>Please send bug reports to ismrp@jasp.ism.ac.jp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-25 10:51:50 UTC; msaga</td>
</tr>
<tr>
<td>Author:</td>
<td>Ushio Tanaka [aut] (Fortran original),
  Masami Saga [aut, cre],
  Junji Nakano [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Masami Saga &lt;msaga@mtb.biglobe.ne.jp&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-25 11:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='NScluster-package'>
Simulation and Estimation of the Neyman-Scott Type Spatial Cluster Models
</h2><span id='topic+NScluster-package'></span><span id='topic+NScluster'></span>

<h3>Description</h3>

<p>NScluster involves the maximum Palm likelihood estimation procedure for
Neyman-Scott cluster point process models and their extensions with parallel
computation using OpenMP technology. The maximum Palm likelihood estimates
(MPLEs for short) are those that maximize the log-Palm likelihood function.
The computation of MPLEs is implemented by simplex maximization with parallel
computation via OpenMP. Together with the likelihood estimation procedure,
NScluster also provides a simulation procedure for cluster point process
models.
</p>


<h3>Details</h3>

<p>The documentation 'A Guide to NScluster: R Package for Maximum Palm Likelihood
Estimation for Cluster Point Process Models using OpenMP' is available in the
package vignette using the <code>vignette</code> function (e.g.,
<code>vignette("NScluster")</code>).
</p>
<p>The package NScluster comprises of four tasks:
simulation, parameter estimation (MPLE), confidence interval estimation, and
non-parametric and parametric Palm intensity comparison.
</p>

<ul>
<li><p>Simulation:
</p>
<p>The <code><a href="#topic+sim.cppm">sim.cppm</a></code> function simulates the five cluster point 
process models: the Thomas and Inverse-power type models, and the extended
Thomas models of type A, B, and C.
</p>
</li>
<li><p>Parameter estimation (MPLE):
</p>
<p>The <code><a href="#topic+mple.cppm">mple.cppm</a></code> function improves the given initial parameters
using the simplex method to maximize the log-Palm likelihood function.
</p>
<p>The expensive calculation of the estimation for calculating the parameters
can be parallelized to reduce calculation time. The package is implemented
to employ OpenMP, which is a simple framework for shared memory parallel
computation. 
</p>
</li>
<li><p>Confidence interval of parameter estimates:
</p>
<p>The <code><a href="#topic+boot.mple">boot.mple</a></code> function carries out the bootstarp replicates
for an object generated by <code><a href="#topic+mple.cppm">mple.cppm</a></code> and computes confidence
intervals and standard errors.
</p>
</li>
<li><p>Palm intensity comparison:
</p>
<p>The package can depict non-parametric and parametric normalized Palm 
intensity function of the five cluster point process models using the
<code><a href="#topic+palm.cppm">palm.cppm</a></code> function.
</p>
</li></ul>



<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Katsura, K. (2008)
Simulation and estimation of the Neyman-Scott type spatial cluster models.
<em>Computer Science Monographs</em> <b>34</b>, 1-44.
The Institute of Statistical Mathematics, Tokyo.
<a href="https://www.ism.ac.jp/editsec/csm/">https://www.ism.ac.jp/editsec/csm/</a>
</p>
<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43-57.
</p>
<p>Tanaka, U., Saga, M. and Nakano, J. (2021)
NScluster: An R Package for Maximum Palm Likelihood Estimation for Cluster Point Process Models Using OpenMP.
<em>Journal of Statistical Software</em>, <b>98(6)</b>, 1-22. <a href="https://doi.org/10.18637/jss.v098.i06">doi:10.18637/jss.v098.i06</a>.
</p>

<hr>
<h2 id='boot.mple'>Bootstrap resampling for MPLE</h2><span id='topic+boot.mple'></span><span id='topic+summary.boot.mple'></span>

<h3>Description</h3>

<p>Carry out bootstrap replicates of MPLE on simulated data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot.mple(mple.out, n = 100, conf.level = 0.95, se = TRUE, trace = FALSE)

## S3 method for class 'boot.mple'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot.mple_+3A_mple.out">mple.out</code></td>
<td>
<p>an object of class &quot;mple&quot;, usually the result of a call to 
<code><a href="#topic+mple.cppm">mple.cppm</a></code>.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_n">n</code></td>
<td>
<p>number of bootstrap replicates performed.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_se">se</code></td>
<td>
<p>logical. If <code>TRUE</code> standard errors are returned.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_trace">trace</code></td>
<td>
<p>logical: if <code>TRUE</code>, a progress bar is shown.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_object">object</code></td>
<td>
<p>an object of class <code>"boot.mple"</code>.</p>
</td></tr>
<tr><td><code id="boot.mple_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boot.mple</code> returns an object of class <code>"boot.mple"</code> containing the
following components:
</p>
<table role = "presentation">
<tr><td><code>boot.mples</code></td>
<td>
<p>a matrix of <code>n</code> rows each of which is a bootstrap
replicate of the result of calling <code><a href="#topic+mple.cppm">mple.cppm</a></code>.</p>
</td></tr>
<tr><td><code>confint</code></td>
<td>
<p>confidence intervals for MPLEs.</p>
</td></tr>
<tr><td><code>mple</code></td>
<td>
<p>MPLE of <code>mple.out</code> passed as <code>'pars'</code> argument to
<code><a href="#topic+sim.cppm">sim.cppm</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### Thomas Model
# simulation
pars &lt;- c(mu = 50.0, nu = 30.0, sigma = 0.03)
t.sim &lt;- sim.cppm("Thomas", pars, seed = 117)

## Not run:  # estimation (need long CPU time)
init.pars &lt;- c(mu = 40.0, nu = 40.0, sigma = 0.05)
t.mple &lt;- mple.cppm("Thomas", t.sim$offspring$xy, init.pars)
t.boot &lt;- boot.mple(t.mple)
summary(t.boot)

## End(Not run)
</code></pre>

<hr>
<h2 id='mple.cppm'>MPLE of Neyman-Scott Cluster Point Process Models and Their Extensions</h2><span id='topic+mple.cppm'></span><span id='topic+coef.mple'></span><span id='topic+summary.mple'></span>

<h3>Description</h3>

<p>MPLE of the five cluster point process models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mple.cppm(model = "Thomas", xy.points, pars = NULL, eps = 0.001, uplimit = 0.3,
          skip = 1)

## S3 method for class 'mple'
coef(object, ...)
## S3 method for class 'mple'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mple.cppm_+3A_model">model</code></td>
<td>
<p>a character string indicating each cluster point process model:
<code>"Thomas"</code>, <code>"IP"</code>, <code>"TypeA"</code>, <code>"TypeB"</code>, and
<code>"TypeC"</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_xy.points">xy.points</code></td>
<td>
<p>a matrix containing the coordinates <code>(x,y)</code> of points
in <code class="reqn">W=[0,1]\times[0,1]</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_pars">pars</code></td>
<td>
<p>a named vector containing a given initial guess of each
parameter. If <code>NULL</code>, any suitable parameters are used. See Details' in
<code><a href="#topic+sim.cppm">sim.cppm</a></code> for the parameters of each model.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_eps">eps</code></td>
<td>
<p>the sufficiently small number to implement the optimization
procedure for the log-Palm likelihood function. The procedure is iterated
at most 1000 times until the <code>process2$stderr</code> becomes smaller than the
<code>eps</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_uplimit">uplimit</code></td>
<td>
<p>upper limit in place of <code class="reqn">\infty</code> of the integral in the
probability distribution function relative to the random distance between
two descendant points within the same cluster. The <code>uplimit</code> is valid
for <code>"IP"</code> and <code>"TypeA"</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_skip">skip</code></td>
<td>
<p>the variable enables one to obtain speedily the initial MPLEs, but
rough approximation. The <code>skip</code> calculates the Palm intensity function 
of the log-Palm likelihood function for every <code>skip</code>-th
<code class="reqn">r_{ij}</code> in the ordered distances of the pairs <code class="reqn">i</code> and 
<code class="reqn">j</code>. The <code>skip</code> is valid for <code>"IP"</code> and <code>"TypeA"</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_object">object</code></td>
<td>
<p>an object of class <code>"mple"</code>.</p>
</td></tr>
<tr><td><code id="mple.cppm_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p><code>"Thomas"</code>
(Thomas model)
</p>
<p>The Palm intensity function is given as follows:
</p>
<p>For all <code class="reqn">r \ge 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{\bm{o}}(r) = \mu\nu + \frac{\nu}{4\pi \sigma^2}
        \exp \left( -\frac{r^2}{4 \sigma^2} \right).</code>
</p>

<p>The log-Palm likelihood function is given by
</p>
<p style="text-align: center;"><code class="reqn">\log L(\mu,\nu,\sigma) = \sum_{\{i,j; i&lt;j, r_{ij} \le 1/2\}}
        \log \nu \left\{ \mu + \frac{1}{4 \pi \sigma^2}
        \exp \left( -\frac{{r_{ij}}^2}{4 \sigma^2} \right) \right\}</code>
</p>

<p style="text-align: center;"><code class="reqn">- N(W)\nu \left\{ \frac{\pi \mu}{4} + 1 -
        \exp \left( -\frac{1}{16 \sigma^2} \right) \right\}.</code>
</p>


</li></ul>


<ul>
<li><p><code>"TypeB"</code>
(Type B model)
</p>
<p>The Palm intensity function is given as follows:
</p>
<p>For all <code class="reqn">r \ge 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{\bm{o}}(r) = \lambda + \frac{\nu}{4 \pi} 
        \left\{ \frac{a}{{\sigma_1}^2} \exp \left( -\frac{r^2}{4{\sigma_1}^2}
        \right)+ \frac{(1-a)}{{\sigma_2}^2} \exp
		\left( -\frac{r^2}{4{\sigma_2}^2} \right) \right\},</code>
</p>

<p>where <code class="reqn">\lambda = \nu(\mu_1+\mu_2)</code> and
<code class="reqn">a = \mu_1/(\mu_1+\mu_2)</code> are the total
intensity and the ratio of the intensity of the parent points of the
smaller cluster to the total one, respectively.
</p>
<p>The log-Palm likelihood function is given by
</p>
<p><code class="reqn">\log L(\lambda, \alpha, \beta, \sigma_1, \sigma_2)</code> 
</p>
<p style="text-align: center;"><code class="reqn">=\sum_{\{i,j; i&lt;j, r_{ij} \le 1/2\}} \log
        \left[ \lambda + \frac{1}{4 \pi} \left\{ \frac{\alpha}{{\sigma_1}^2}
		\exp \left( -\frac{{r_{ij}}^2}{4{\sigma_1}^2} \right) + 
        \frac{\beta}{{\sigma_2}^2} \exp \left( -\frac{{r_{ij}}^2}{4{\sigma_2}^2}
	    \right) \right\} \right]</code>
</p>

<p style="text-align: center;"><code class="reqn">- N(W) \left[ \frac{\pi \lambda}{4} + \alpha \left\{ 1 - \exp
        \left( -\frac{1}{16{\sigma_1}^2} \right) \right\} + \beta
		\left\{ 1- \exp \left( -\frac{1}{16{\sigma_2}^2} \right) \right\}
		\right],</code>
</p>

<p>where <code class="reqn">\alpha = a\nu</code> and <code class="reqn">\beta = (1-a)\nu</code>.

</p>
</li></ul>


<ul>
<li><p><code>"TypeC"</code>
(Type C model)
</p>
<p>The Palm intensity function is  given as follows:
</p>
<p>For all <code class="reqn">r \ge 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">\lambda_{\bm{o}}(r) = \lambda + \frac{1}{4 \pi} \left\{
        \frac{a\nu_1}{{\sigma_1}^2} \exp
		\left( -\frac{r^2}{4{\sigma_1}^2} \right) +
        \frac{(1-a)\nu_2}{{\sigma_2}^2} \exp \left( -\frac{r^2}{4{\sigma_2}^2}
        \right) \right\},</code>
</p>

<p>where <code class="reqn">\lambda = \mu_1\nu_1 + \mu_2\nu_2</code> and <code class="reqn">a = \mu_1\nu_1/\lambda</code> are the total intensity and the
ratio of the intensity of the smaller cluster to the total one,
respectively.
</p>
<p>The log-Palm likelihood function is given by
</p>
<p><code class="reqn">\log L(\lambda, \alpha, \beta, \sigma_1, \sigma_2)</code>
</p>
<p style="text-align: center;"><code class="reqn">= \sum_{\{i,j; i&lt;j, r_{ij} \le 1/2\}} \log \left[ \lambda + \frac{1}
        {4 \pi} \left\{ \frac{\alpha}{{\sigma_1}^2} \exp
        \left( -\frac{{r_{ij}}^2}{4{\sigma_1}^2} \right) +
        \frac{\beta}{{\sigma_2}^2} \exp
		\left( -\frac{{r_{ij}}^2}{4{\sigma_2}^2} \right) \right\} \right]</code>
</p>

<p style="text-align: center;"><code class="reqn">-N(W) \left[ \frac{\pi\lambda}{4} + \alpha \left\{ 1 - \exp
        \left( -\frac{1}{16{\sigma_1}^2} \right) \right\} + \beta \left\{ 1-
        \exp \left( -\frac{1}{16{\sigma_2}^2} \right) \right\} \right],</code>
</p>

<p>where <code class="reqn">\alpha = a\nu_1</code> and
<code class="reqn">\beta = (1-a)\nu_2</code>.

</p>
</li></ul>

<p>For the inverse-power model and the Type A models, we need to take the 
alternative form without explicit representation of the Palm intensity 
function. See the second reference below for details.
</p>


<h3>Value</h3>

<p><code>mple.cppm</code> returns an object of class <code>"mple"</code> containing the
following main components:
</p>
<table role = "presentation">
<tr><td><code>mple</code></td>
<td>
<p>MPLE (maximum Palm likelihood estimate).</p>
</td></tr>
<tr><td><code>log.mpl</code></td>
<td>
<p>the log maximum Palm likelihood.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>AIC.</p>
</td></tr>
<tr><td><code>process1</code></td>
<td>
<p>a list with following components.
</p>

<dl>
<dt>cflg</dt><dd><p>1 (=&quot;update&quot;) or -1 (=&quot;testfn&quot;), where &quot;update&quot; indicates that
-log L value has attained the minimum so far, otherwise not.</p>
</dd> 
<dt>logl</dt><dd><p>the minimized -log L in the process to minimize the
negative log-Palm likelihood function.</p>
</dd>
<dt>mples</dt><dd><p>corresponding MPLEs.</p>
</dd>
</dl>

</td></tr>
<tr><td><code>process2</code></td>
<td>
<p>a list with following components.
</p>

<dl>
<dt>logl.simplex</dt><dd><p>the minimized -log L by the simplex method.</p>
</dd>
<dt>stderr</dt><dd><p>standard error.</p>
</dd>
<dt>pa.normal</dt><dd><p>the normalized variables corresponding to the MPLEs
relative to the initial estimates.</p>
</dd>
</dl>

</td></tr>
</table>
<p>There are other methods <code><a href="#topic+plot.mple">plot.mple</a></code> and <code><a href="#topic+print.mple">print.mple</a></code>
for this class.
</p>


<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Katsura, K. (2008)
Simulation and estimation of the Neyman-Scott type spatial cluster models.
<em>Computer Science Monographs</em> <b>34</b>, 1-44.
The Institute of Statistical Mathematics, Tokyo.
<a href="https://www.ism.ac.jp/editsec/csm/">https://www.ism.ac.jp/editsec/csm/</a>.
</p>
<p>Tanaka, U., Ogata, Y. and Stoyan, D. (2008)
Parameter estimation and model selection for Neyman-Scott point processes.
<em>Biometrical Journal</em> <b>50</b>, 43-57.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The computation of MPLEs takes a long CPU time in the minimization procedure,
# especially for the Inverse-power type and the Type A models.

### Thomas Model
 # simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, sigma = 0.03)
 t.sim &lt;- sim.cppm("Thomas", pars, seed = 117)
 ## estimation
 init.pars &lt;- c(mu = 40.0, nu = 40.0, sigma = 0.05)
 t.mple &lt;- mple.cppm("Thomas", t.sim$offspring$xy, init.pars)
 coef(t.mple)

### Inverse-Power Type Model
 # simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, p = 1.5, c = 0.005)
 ip.sim &lt;- sim.cppm("IP", pars, seed = 353)
 ## estimation
 init.pars &lt;- c(mu = 55.0, nu = 35.0, p = 1.0, c = 0.01)
 ip.mple &lt;- mple.cppm("IP", ip.sim$offspring$xy, init.pars, skip = 100)
 coef(ip.mple)

### Type A Model
 # simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, a = 0.3, sigma1 = 0.005, sigma2 = 0.1)
 a.sim &lt;- sim.cppm("TypeA", pars, seed = 575)
 ## estimation
 init.pars &lt;- c(mu = 60.0, nu = 40.0, a = 0.5, sigma1 = 0.01, sigma2 = 0.1)
 a.mple &lt;- mple.cppm("TypeA", a.sim$offspring$xy, init.pars, skip = 100)
 coef(a.mple)

### Type B Model
 # simulation
 pars &lt;- c(mu1 = 10.0, mu2 = 40.0, nu = 30.0, sigma1 = 0.01, sigma2 = 0.03)
 b.sim &lt;- sim.cppm("TypeB", pars, seed = 257)
 ## estimation
 init.pars &lt;- c(mu1 = 20.0, mu2 = 30.0, nu = 30.0, sigma1 = 0.02, sigma2 = 0.02)
 b.mple &lt;- mple.cppm("TypeB", b.sim$offspring$xy, init.pars)
 coef(b.mple)

### Type C Model
 # simulation
 pars &lt;- c(mu1 = 5.0, mu2 = 9.0, nu1 = 30.0, nu2 = 150.0,
           sigma1 = 0.01, sigma2 = 0.05)
 c.sim &lt;- sim.cppm("TypeC", pars, seed = 555)
 ## estimation
 init.pars &lt;- c(mu1 = 10.0, mu2 = 10.0, nu1 = 30.0, nu2 = 120.0,
                sigma1 = 0.03, sigma2 = 0.03)
 c.mple &lt;- mple.cppm("TypeC", c.sim$offspring$xy, init.pars)
 coef(c.mple)

## End(Not run)
</code></pre>

<hr>
<h2 id='palm.cppm'>Non-parametric and Parametric Estimation for Palm Intensity</h2><span id='topic+palm.cppm'></span><span id='topic+print.Palm'></span>

<h3>Description</h3>

<p>Compute the non-parametric and the parametric Palm intensity function of the
Neyman-Scott cluster point process models and their extensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>palm.cppm(mple, pars = NULL, delta = 0.001, uplimit = 0.3)

## S3 method for class 'Palm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="palm.cppm_+3A_mple">mple</code></td>
<td>
<p>an object of class &quot;mple&quot;.</p>
</td></tr>
<tr><td><code id="palm.cppm_+3A_pars">pars</code></td>
<td>
<p>a named vector of the true parameters, if any.</p>
</td></tr>
<tr><td><code id="palm.cppm_+3A_delta">delta</code></td>
<td>
<p>a width for the non-parametric Palm intensity function.</p>
</td></tr>
<tr><td><code id="palm.cppm_+3A_uplimit">uplimit</code></td>
<td>
<p>upper limit in place of <code class="reqn">\infty</code> of the integral in the
probability distribution function relative to the random distance between
two descendant points within the same cluster. The <code>uplimit</code> is valid 
for <code>"IP"</code> and <code>"TypeA"</code>.</p>
</td></tr>
<tr><td><code id="palm.cppm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"Palm"</code>.</p>
</td></tr>
<tr><td><code id="palm.cppm_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"Palm"</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>r</code></td>
<td>
<p>the distance <code class="reqn">r=j\Delta</code>,
where <code class="reqn">j=1,2,\dots,[R/\Delta]</code>, <code class="reqn">[\cdot]</code> is
the Gauss' symbol and <code class="reqn">R=1/2</code> in the program.</p>
</td></tr>
<tr><td><code>np.palm</code></td>
<td>
<p>the corresponding values of the non-parametric Palm intensity
function, which is normalized by the total intensity estimate (the mean
number of points in <code class="reqn">W</code>) of a given point pattern data.</p>
</td></tr>
<tr><td><code>norm.palm</code></td>
<td>
<p>the corresponding values of the normalized Palm intensity
function, i.e., <code class="reqn">\lambda_{\bm{o}}(r)/\hat{\lambda}</code>, where <code class="reqn">\lambda_{\bm{o}}(r)</code> is the
Palm intensity and <code class="reqn">\lambda</code> is an intensity of a cluster point process
model. See 'Details' in <code><a href="#topic+mple.cppm">mple.cppm</a>.</code></p>
</td></tr>
</table>
<p>There is another method <code><a href="#topic+plot.Palm">plot.Palm</a></code> for this class.
</p>


<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Katsura, K. (2008)
Simulation and estimation of the Neyman-Scott type spatial cluster models.
<em>Computer Science Monographs</em> <b>34</b>, 1-44.
The Institute of Statistical Mathematics, Tokyo.
<a href="https://www.ism.ac.jp/editsec/csm/">https://www.ism.ac.jp/editsec/csm/</a>.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+sim.cppm">sim.cppm</a></code> and <code><a href="#topic+mple.cppm">mple.cppm</a></code> to simulate the
Neyman-Scott cluster point process models and their extensions and to compute
the MPLEs, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The computation of MPLEs takes a long CPU time in the minimization procedure,
# especially for the Inverse-power type and the Type A models.

### Thomas Model
 #simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, sigma = 0.03)
 t.sim &lt;- sim.cppm("Thomas", pars, seed = 117)
 ## estimation =&gt; Palm intensity
 init.pars &lt;- c(mu = 40.0, nu = 40.0, sigma = 0.05)
 t.mple &lt;- mple.cppm("Thomas", t.sim$offspring$xy, init.pars)
 t.palm &lt;- palm.cppm(t.mple, pars)
 plot(t.palm)

### Inverse-Power Type Model
 # simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, p = 1.5, c = 0.005)
 ip.sim &lt;- sim.cppm("IP", pars, seed = 353)
 ## estimation =&gt; Palm intensity
 init.pars &lt;- c(mu = 55.0, nu = 35.0, p = 1.0, c = 0.01)
 ip.mple &lt;- mple.cppm("IP", ip.sim$offspring$xy, init.pars, skip = 100)
 ip.palm &lt;- palm.cppm(ip.mple, pars)
 plot(ip.palm)

### Type A Model
# simulation
 pars &lt;- c(mu = 50.0, nu = 30.0, a = 0.3, sigma1 = 0.005, sigma2 = 0.1)
 a.sim &lt;- sim.cppm("TypeA", pars, seed=575)
 ## estimation =&gt; Palm intensity
 init.pars &lt;- c(mu=60.0, nu=40.0, a=0.5, sigma1=0.01, sigma2=0.1)
 a.mple &lt;- mple.cppm("TypeA", a.sim$offspring$xy, init.pars, skip=100)
 a.palm &lt;- palm.cppm(a.mple, pars)
 plot(a.palm)

### Type B Model
 # simulation
 pars &lt;- c(mu1 = 10.0, mu2 = 40.0, nu = 30.0, sigma1 = 0.01, sigma2 = 0.03)
 b.sim &lt;- sim.cppm("TypeB", pars, seed = 257)
 ## estimation =&gt; Palm intensity
 init.pars &lt;- c(mu1 = 20.0, mu2 = 30.0, nu = 30.0, sigma1 = 0.02, sigma2 = 0.02)
 b.mple &lt;- mple.cppm("TypeB", b.sim$offspring$xy, init.pars)
 b.palm &lt;- palm.cppm(b.mple, pars)
 plot(b.palm)


### Type C Model
 # simulation
 pars &lt;- c(mu1 = 5.0, mu2 = 9.0, nu1 = 30.0, nu2 = 150.0,
           sigma1 = 0.01, sigma2 = 0.05)
 c.sim &lt;- sim.cppm("TypeC", pars, seed = 555)
 ## estimation =&gt; Palm intensity
 init.pars &lt;- c(mu1 = 10.0, mu2 = 10.0, nu1 = 30.0, nu2 = 120.0,
                sigma1 = 0.03, sigma2 = 0.03)
 c.mple &lt;- mple.cppm("TypeC", c.sim$offspring$xy, init.pars)
 c.palm &lt;- palm.cppm(c.mple, pars)
 plot(c.palm)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.mple'>Show the Process for Optimizing Parameter Set
</h2><span id='topic+plot.mple'></span>

<h3>Description</h3>

<p>Plot method for object of class <code>"mple"</code> shows process for optimizing the
normalized parameters depending on a given initial guess of each parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mple'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mple_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mple"</code> returned by <code><a href="#topic+mple.cppm">mple.cppm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.mple_+3A_...">...</code></td>
<td>
<p>further graphical parameters from <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.Palm'>
Plot Non-Parametric and Parametric Normalized Palm Intensity
</h2><span id='topic+plot.Palm'></span>

<h3>Description</h3>

<p>Plot method for objects of class <code>"Palm"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Palm'
plot(x, ..., log = "xy")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Palm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"Palm"</code>, usually the result of a call to
<code><a href="#topic+palm.cppm">palm.cppm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.Palm_+3A_...">...</code></td>
<td>
<p>optional. At most 4 additional objects of class &quot;Palm&quot;.</p>
</td></tr>
<tr><td><code id="plot.Palm_+3A_log">log</code></td>
<td>
<p>a character string indicating if logarithmic axes are to be used.</p>
</td></tr>
</table>

<hr>
<h2 id='print.mple'>Print Process for Maximizing Log-Palm Likelihood Function</h2><span id='topic+print.mple'></span>

<h3>Description</h3>

<p>Print the process for minimizing the negative log-Palm likelihood function 
and/or the process for optimizing the normalized parameters depending on a
given initial guess of each parameter by the simplex method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mple'
print(x, print.level = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mple_+3A_x">x</code></td>
<td>
<p>an object of class <code>"mple"</code> returned by <code><a href="#topic+mple.cppm">mple.cppm</a></code>.</p>
</td></tr>
<tr><td><code id="print.mple_+3A_print.level">print.level</code></td>
<td>
<p>We have the following processes:
</p>

<dl>
<dt>0</dt><dd><p>output initial values and MPLE.</p>
</dd>
<dt>1</dt><dd><p>output the process for minimizing the negative log-Palm 
likelihood function, in addition. (<code>x$process1</code>)</p>
</dd>
<dt>2</dt><dd><p>output the process for optimizing the normalized parameters
depending on a given initial guess of each parameter by the 
simplex method, in addition. (<code>x$process2</code>)</p>
</dd>
<dt>3</dt><dd><p>output both processes.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="print.mple_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='sim.cppm'>Simulation for Neyman-Scott Cluster Point Process Models and Their
Extensions</h2><span id='topic+sim.cppm'></span><span id='topic+print.sim.cpp'></span><span id='topic+plot.sim.cpp'></span>

<h3>Description</h3>

<p>Simulation for the Thomas and Inverse-power type models, and the extended
Thomas models of type A, B, and C.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim.cppm(model = "Thomas", pars, seed = NULL)

## S3 method for class 'sim.cpp'
print(x, ...)
## S3 method for class 'sim.cpp'
plot(x, parents.distinct = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim.cppm_+3A_model">model</code></td>
<td>
<p>a character string indicating each cluster point process model:
<code>"Thomas"</code>, <code>"IP"</code>, <code>"TypeA"</code>, <code>"TypeB"</code>, and
<code>"TypeC"</code>.</p>
</td></tr>
<tr><td><code id="sim.cppm_+3A_pars">pars</code></td>
<td>
<p>a named vector giving the values of each parameter. See 'Details'.</p>
</td></tr>
<tr><td><code id="sim.cppm_+3A_seed">seed</code></td>
<td>
<p>arbitrary positive integer to generate a sequence of uniform
random numbers. The default seed is based on the current time.</p>
</td></tr>
<tr><td><code id="sim.cppm_+3A_x">x</code></td>
<td>
<p>an object of class <code>"sim.cpp"</code>.</p>
</td></tr>
<tr><td><code id="sim.cppm_+3A_parents.distinct">parents.distinct</code></td>
<td>
<p>logical. If <code>TRUE</code>, simulated points are
distinguished by two groups specified by parameters. (Only valid if
<code>model</code> = <code>"TypeB"</code> or <code>"TypeC"</code>.)</p>
</td></tr>
<tr><td><code id="sim.cppm_+3A_...">...</code></td>
<td>
<p>further graphical parameters from <code><a href="graphics.html#topic+par">par</a></code>
for <code>plot</code> or ignored for <code>print</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We consider the five cluster point process models: the Thomas and
Inverse-power type models, and the extended Thomas models of type A, B, and C.
</p>

<ul>
<li><p><code>"Thomas" </code>
(Thomas model)
</p>
<p>The parameters of the model are as follows: 
</p>

<ul>
<li> <p><code>mu</code>: the intensity of parent points.
</p>
</li>
<li> <p><code>nu</code>: the expectation of a random number of descendant points
of each parent point.
</p>
</li>
<li> <p><code>sigma</code>: the parameter set of the dispersal kernel.
</p>
</li></ul>

<p>Let a random variable <code class="reqn">U</code> be independently and uniformly distributed
in [0,1].
</p>
<p>Consider
</p>
<p style="text-align: center;"><code class="reqn">U = \int_0^r q_\sigma(t)dt =
              1 - \exp \left( -\frac{r^2}{2\sigma^2} \right),</code>
</p>

<p>where <code class="reqn">r</code> is the random variable of the distance between each parent
point and the descendant points associated with the given parent. The
distance is distributed independently and identically according to the
dispersal kernel.
</p>
<p>We have
</p>
<p style="text-align: center;"><code class="reqn">r = \sigma \sqrt{-2 \log(1-U)}.</code>
</p>

<p>Let <code class="reqn">(x_i^p, y_i^p), i=1,2,\dots, I,</code> be a coordinate of each parent
point where the integer <code class="reqn">I</code> is generated from the Poisson random
variable <code class="reqn">Poisson(\mu)</code> with mean <code class="reqn">\mu</code> from now on. Then, for
each <code class="reqn">i</code>, the number of offspring <code class="reqn">J_i</code> is generated by the random
variable <code class="reqn">Poisson(\nu)</code> with mean <code class="reqn">\nu</code>. Then, using series of
different uniform random numbers <code class="reqn">\{U\}</code> for different <code class="reqn">i</code>
and <code class="reqn">j</code>, each of the offspring coordinates
<code class="reqn">(x_j^i, y_j^i), j=1,2,\dots,J_i</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">x_j^i = x_i^p + r \cos(2 \pi U),</code>
</p>

<p style="text-align: center;"><code class="reqn">y_j^i = y_i^p + r \sin(2 \pi U),</code>
</p>

<p>owing to the isotropy condition of the distribution.
</p>
<p>Given a positive number <code class="reqn">\nu</code> and let a sequence of a random variable
<code class="reqn">\{U_k\}</code> be independently and uniformly distributed in [0,1],
the Poisson random number <code class="reqn">M</code> is the smallest integer such that
</p>
<p style="text-align: center;"><code class="reqn">\sum_{k=1}^{M+1} - \log U_k &gt; \nu,</code>
</p>

<p>where <code class="reqn">\log</code> represents natural logarithm.

</p>
</li></ul>


<ul>
<li><p><code>"IP"</code> 
(Inverse-power type model)
</p>
<p>The parameters of the model are as follows: 
</p>

<ul>
<li> <p><code>mu</code>: the intensity of parent points.
</p>
</li>
<li> <p><code>nu</code>: the expectation of a random number of descendant points
of each parent point.
</p>
</li>
<li> <p><code>p</code>, <code>c</code>: the set of parameters of the dispersal kernel,
where <code>p</code> &gt; 1 and <code>c</code> &gt; 0.
</p>
</li></ul>

<p>Let <code class="reqn">U</code> be as above.
</p>
<p>For all <code class="reqn">r \ge 0</code>,
</p>
<p style="text-align: center;"><code class="reqn">Q_{p,c}(r) := \int_0^r q_{p,c}(t)dt</code>
</p>

<p style="text-align: center;"><code class="reqn">= c^{p-1}(p-1) \frac{(r+c)^{1-p} - c^{1-p}}{1-p}</code>
</p>

<p style="text-align: center;"><code class="reqn">= 1 - c^{p-1} (r+c)^{1-p}.</code>
</p>

<p>Here, we put <code class="reqn">Q_{p,c}(r) = U</code>. From this, we have
</p>
<p style="text-align: center;"><code class="reqn">r = c\{(1-U)^{1/(1-p)} - 1\}.</code>
</p>

<p>The parent points and their descendant points are generated the same as
the Thomas model.

</p>
</li></ul>


<ul>
<li><p><code>"TypeA"</code> 
(Type A model)
</p>
<p>The parameters of the model are as follows: 
</p>

<ul>
<li> <p><code>mu</code>: the intensity of parent points.
</p>
</li>
<li> <p><code>nu</code>: the expectation of a random number of descendant points
of each parent point.
</p>
</li>
<li> <p><code>a</code>, <code>sigma1</code>, <code>sigma2</code>: the set of parameters of
the dispersal kernel, where where <code>a</code> is a mixture ratio
parameter with 0 &lt; <code>a</code> &lt; 1. 
</p>
</li></ul>

<p>Let each random variable <code class="reqn">U_k, k=1,2</code>, be independently and
uniformly distributed in [0,1].
</p>
<p>Then <code class="reqn">r</code> satisfies as follows: 
</p>
<p style="text-align: center;"><code class="reqn">r = \sigma_1 \sqrt{-2 \log(1-U_1)},  \quad U_2 \le a ,</code>
</p>

<p style="text-align: center;"><code class="reqn">r = \sigma_2 \sqrt{-2 \log(1-U_1)},  \quad \mathrm{otherwise.}</code>
</p>

<p>The parent points and their descendant points are generated the same as
the Thomas model.

</p>
</li></ul>


<ul>
<li><p><code>"TypeB"</code> 
(Type B model)
</p>
<p>The TypeB is a superposed Thomas model. The parameters of the model are as
follows: 
</p>

<ul>
<li> <p><code>mu1</code>, <code>mu2</code>: the corresponding intensity of parent
points of each Thomas model.
</p>
</li>
<li> <p><code>nu</code>: the expectation of a random number of descendant points
of each parent point.
</p>
</li>
<li> <p><code>sigma1</code>, <code>sigma2</code>: the corresponding set of parameters
of the dispersal kernel of each Thomas model.
</p>
</li></ul>

<p>Consider the two types of the Thomas model with parameters
<code class="reqn">(\mu_1, \nu, \sigma_1)</code> and
<code class="reqn">(\mu_2, \nu, \sigma_2)</code>.
Parents' configuration and numbers of the descendant cluster sizes are
generated by the two types of uniformly distributed parents
<code class="reqn">(x_i^k, y_i^k)</code> with
<code class="reqn">i=1,2,\dots,Poisson(\mu_k)</code> for <code class="reqn">k=1,2</code>,
respectively.
</p>
<p>Then, using series of different uniform random numbers <code class="reqn">\{U\}</code>
for different <code class="reqn">i</code> and <code class="reqn">j</code>, each of the descendant coordinates
<code class="reqn">(x_j^{k,i}, y_j^{k,i})</code> of the parents <code class="reqn">(x_i^k, y_i^k)</code>,
<code class="reqn">k=1,2</code>, <code class="reqn">j=1,2,\dots,Poisson(\nu)</code>, is 
given by
</p>
<p style="text-align: center;"><code class="reqn">x_j^{k,i} = x_i^k + r_k \cos (2 \pi U),</code>
</p>

<p style="text-align: center;"><code class="reqn">y_j^{k,i} = y_i^k + r_k \sin (2 \pi U),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">r_k = \sigma_k \sqrt{-2 \log (1-U_k)}, \quad k = 1, 2,</code>
</p>

<p>with different random numbers <code class="reqn">\{U_k, U\}</code> for different
<code class="reqn">k, i</code>, and <code class="reqn">j</code>.

</p>
</li></ul>


<ul>
<li><p><code>"TypeC"</code> 
(Type C model)
</p>
<p>The TypeC is a superposed Thomas model. The parameters of the model are as
follows: 
</p>

<ul>
<li> <p><code>mu1</code>, <code>mu2</code>: the corresponding intensity of parent
points of each Thomas model.
</p>
</li>
<li> <p><code>nu1</code>, <code>nu2</code>: the corresponding expectation of a random
number of descendant points of each Thomas model.
</p>
</li>
<li> <p><code>sigma1</code>, <code>sigma2</code>: the corresponding set of parameters
of the dispersal kernel of each Thomas model.
</p>
</li></ul>

<p>The parent points and their descendant points are generated the same as
the Type B model.

</p>
</li></ul>



<h3>Value</h3>

<p><code>sim.cppm</code> returns an object of class <code>"sim.cpp"</code> containing the
following components which has <code>print</code> and <code>plot</code> methods.
</p>
<table role = "presentation">
<tr><td><code>parents</code></td>
<td>
<p>a list containing two components named &quot;<code>n</code>&quot; and
&quot;<code>xy</code>&quot;, which are the number and the matrix of <code>(x,y)</code> coordinates
of simulated parent points, respectively. For <code>"TypeB"</code>, <code>xy</code>
[1:<code>n</code>[1], 1:2] and the remainder are generated from (<code>mu1</code>, 
<code>nu</code>, <code>sigma1</code>) and (<code>mu2</code>, <code>nu</code>, <code>sigma2</code>), 
respectively. For <code>"TypeC"</code>, <code>xy</code>[1:<code>n</code>[1], 1:2] and the
remainder are generated from (<code>mu1</code>, <code>nu1</code>, <code>sigma1</code>) and
(<code>mu2</code>, <code>nu2</code>, <code>sigma2</code>), respectively.</p>
</td></tr>
<tr><td><code>offspring</code></td>
<td>
<p>a list containing two components named &quot;<code>n</code>&quot; and
&quot;<code>xy</code>&quot;, which are the number and the matrix of <code>(x,y)</code> coordinates
of simulated descendant points, respectively. For <code>"TypeB"</code>, <code>xy</code>
[1:<code>n</code>[1], 1:2] and the remainder are generated from (<code>mu1</code>,
<code>nu</code>, <code>sigma1</code>) and (<code>mu2</code>, <code>nu</code>, <code>sigma2</code>),
respectively. For <code>"TypeC"</code>, <code>xy</code>[1:<code>n</code>[1], 1:2] and the
remainder are generated from (<code>mu1</code>, <code>nu1</code>, <code>sigma1</code>) and
(<code>mu2</code>, <code>nu2</code>, <code>sigma2</code>), respectively.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Tanaka, U., Ogata, Y. and Katsura, K. (2008)
Simulation and estimation of the Neyman-Scott type spatial cluster models.
<em>Computer Science Monographs</em> <b>34</b>, 1-44.
The Institute of Statistical Mathematics, Tokyo.
<a href="https://www.ism.ac.jp/editsec/csm/">https://www.ism.ac.jp/editsec/csm/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Thomas Model
pars &lt;- c(mu = 50.0, nu = 30.0, sigma = 0.03)
t.sim &lt;- sim.cppm("Thomas", pars, seed = 117)
t.sim
plot(t.sim)

## Inverse-Power Type Model
pars &lt;- c(mu = 50.0, nu = 30.0, p = 1.5, c = 0.005)
ip.sim &lt;- sim.cppm("IP", pars, seed = 353)
ip.sim
plot(ip.sim)

## Type A Model
pars &lt;- c(mu = 50.0, nu = 30.0, a = 0.3, sigma1 = 0.005, sigma2 = 0.1)
a.sim &lt;- sim.cppm("TypeA", pars, seed = 575)
a.sim
plot(a.sim)

## Type B Model
pars &lt;- c(mu1 = 10.0, mu2 = 40.0, nu = 30.0, sigma1 = 0.01, sigma2 = 0.03)
b.sim &lt;- sim.cppm("TypeB", pars, seed = 257)
b.sim
plot(b.sim, parents.distinct = TRUE)

## Type C Model
pars &lt;- c(mu1 = 5.0, mu2 = 9.0, nu1 = 30.0, nu2 = 150.0,
               sigma1 = 0.01, sigma2 = 0.05)
c.sim &lt;- sim.cppm("TypeC", pars, seed = 555)
c.sim
plot(c.sim, parents.distinct = FALSE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
