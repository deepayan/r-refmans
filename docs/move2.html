<!DOCTYPE html><html><head><title>Help for package move2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {move2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#filter_track_data'><p><code>dplyr</code> functions to manipulate the track data</p></a></li>
<li><a href='#movebank_download_study'><p>Download data from movebank</p></a></li>
<li><a href='#movebank_get_vocabulary'><p>Retrieve information from the movebank vocabulary describing the columns</p></a></li>
<li><a href='#movebank_handle'><p>Create a curl handle for accessing movebank</p></a></li>
<li><a href='#movebank_store_credentials'><p>Store or remove credentials in the system keyring</p></a></li>
<li><a href='#mt_aeqd_crs'><p>Create a AEQD coordinate reference system</p></a></li>
<li><a href='#mt_as_move2'><p>Create a new move2 object</p></a></li>
<li><a href='#mt_as_track_attribute'><p>Move one or more columns to track attributes or event attributes</p></a></li>
<li><a href='#mt_azimuth'><p>Calculate azimuths or turn angles</p></a></li>
<li><a href='#mt_distance'><p>Return distances or speeds between locations</p></a></li>
<li><a href='#mt_example'><p>Get path to <code>move2</code> example data</p></a></li>
<li><a href='#mt_filter_movebank_visible'><p>Identify records that are not outliers according to the logic used in movebank</p></a></li>
<li><a href='#mt_filter_per_interval'><p>Find subset of records based on time windows</p></a></li>
<li><a href='#mt_filter_unique'><p>Filter out duplicated records from a <code>move2</code> object</p></a></li>
<li><a href='#mt_interpolate'><p>Linearly interpolate locations</p></a></li>
<li><a href='#mt_is_track_id_cleaved'><p>Functions for asserting properties of a <code>move2</code> object</p></a></li>
<li><a href='#mt_read'><p>Reading files downloaded from movebank</p></a></li>
<li><a href='#mt_segments'><p>Create a <code>LINESTRING</code> for each track segment</p></a></li>
<li><a href='#mt_sim_brownian_motion'><p>Simulate Brownian motion</p></a></li>
<li><a href='#mt_stack'><p>Combine multiple <code>move2</code> objects into one</p></a></li>
<li><a href='#mt_time'><p>Retrieve/replace timestamps or get the interval duration between locations</p></a></li>
<li><a href='#mt_time_column'><p>Get or set the name of the column containing the <code>track_id</code> and <code>time</code></p></a></li>
<li><a href='#mt_track_data'><p>Setting and retrieving the track data in <code>move2</code> objects</p></a></li>
<li><a href='#mt_track_id'><p>Retrieve the column with track ids or get the number of tracks</p></a></li>
<li><a href='#mt_track_lines'><p>Convert trajectories into lines</p></a></li>
<li><a href='#to_move'><p>Convert a move2 object to a move object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Processing and Analysing Animal Trajectories</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools to handle, manipulate and explore trajectory data, with an emphasis on data from tracked animals. The package is designed to support large studies with several million location records and keep track of units where possible. Data import directly from 'movebank' <a href="https://www.movebank.org/cms/movebank-main">https://www.movebank.org/cms/movebank-main</a> and files is facilitated.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://bartk.gitlab.io/move2/">https://bartk.gitlab.io/move2/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/bartk/move2/-/issues">https://gitlab.com/bartk/move2/-/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, assertthat, sf (&ge; 1.0.16), rlang, units, tidyselect,
dplyr (&ge; 1.1.0), tibble, vroom (&ge; 1.6.1), cli, vctrs (&ge;
0.5.2), bit64</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, askpass, digest, keyring, xml2, curl, magrittr, purrr,
ggplot2, testthat (&ge; 3.0.0), rmarkdown, lwgeom, s2, move,
raster, withr, lubridate, rnaturalearth, rnaturalearthdata,
circular, tidyr, gganimate, prettymapr, gifski, ggspatial</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-22 14:49:44 UTC; bart</td>
</tr>
<tr>
<td>Author:</td>
<td>Bart Kranstauber <a href="https://orcid.org/0000-0001-8303-780X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kamran Safi <a href="https://orcid.org/0000-0002-8418-6759"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Anne K. Scharf <a href="https://orcid.org/0000-0002-3357-8533"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bart Kranstauber &lt;b.kranstauber@uva.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-22 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='filter_track_data'><code>dplyr</code> functions to manipulate the track data</h2><span id='topic+filter_track_data'></span><span id='topic+select_track_data'></span><span id='topic+mutate_track_data'></span><span id='topic+group_by_track_data'></span>

<h3>Description</h3>


<ul>
<li> <p><code>filter_track_data</code> filter data based on a track attribute (e.g. select all juveniles).
Based on <code><a href="dplyr.html#topic+filter">filter</a></code>.
</p>
</li>
<li> <p><code>select_track_data</code> keep or drop attributes in the track data. Based on <code><a href="dplyr.html#topic+select">select</a></code>.
</p>
</li>
<li> <p><code>mutate_track_data</code> create or modify attributes in the track data. Based on <code><a href="dplyr.html#topic+mutate">mutate</a></code>.
</p>
</li>
<li> <p><code>group_by_track_data</code> group by one or more attribute of the track data (e.g. group by sex, by taxon, by life stage,
etc). Based on <code><a href="dplyr.html#topic+group_by">group_by</a></code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>filter_track_data(.data, ..., .track_id = NULL)

select_track_data(.data, ...)

mutate_track_data(.data, ...)

group_by_track_data(
  .data,
  ...,
  .add = FALSE,
  .drop = dplyr::group_by_drop_default(.data)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_track_data_+3A_.data">.data</code></td>
<td>
<p>the <code>move2</code> object</p>
</td></tr>
<tr><td><code id="filter_track_data_+3A_...">...</code></td>
<td>
<p>The identifiers of one or more tracks to select or selection criteria based on track attributes</p>
</td></tr>
<tr><td><code id="filter_track_data_+3A_.track_id">.track_id</code></td>
<td>
<p>A vector of the ids of the tracks to select</p>
</td></tr>
<tr><td><code id="filter_track_data_+3A_.add">.add</code></td>
<td>
<p>see original function docs <code><a href="dplyr.html#topic+group_by">group_by</a></code></p>
</td></tr>
<tr><td><code id="filter_track_data_+3A_.drop">.drop</code></td>
<td>
<p>see original function docs <code><a href="dplyr.html#topic+group_by">group_by</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>move2</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simulating a move2 object with 4 tracks
data &lt;- mt_sim_brownian_motion(tracks = letters[1:4])

## retaining tracks "b" and "d"
data |&gt;
  filter_track_data(.track_id = c("b", "d"))

## adding the attribute "sex" to the track data
data &lt;- data |&gt;
  mutate_track_data(sex = c("m", "f", "f", "m"))

## retaining tracks of females
data |&gt; filter_track_data(sex == "f")

</code></pre>

<hr>
<h2 id='movebank_download_study'>Download data from movebank</h2><span id='topic+movebank_download_study'></span><span id='topic+movebank_download_study_info'></span><span id='topic+movebank_download_deployment'></span><span id='topic+movebank_retrieve'></span><span id='topic+movebank_get_study_id'></span>

<h3>Description</h3>


<ul>
<li> <p><code>movebank_download_study</code> downloads a complete study from Movebank by the study id or name.
</p>
</li>
<li> <p><code>movebank_download_deployment</code> downloads all tag, individual and deployment information and merges it into one
<code>data.frame</code>
</p>
</li>
<li> <p><code>movebank_download_study_info</code> downloads all study level information, either for all studies, one study with
the argument <code>id</code> or a subset, for example, <code>license_type = "CC_0"</code>
</p>
</li>
<li> <p><code>movebank_retrieve</code> is a more flexible function for retrieving information directly from the api.
</p>
</li>
<li> <p><code>movebank_get_study_id</code> using a character string retrieve the associated study id.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>movebank_download_study(
  study_id,
  attributes = "all",
  ...,
  remove_movebank_outliers = TRUE
)

movebank_download_study_info(...)

movebank_download_deployment(study_id, ...)

movebank_retrieve(
  entity_type = NA,
  ...,
  handle = movebank_handle(),
  rename_columns = FALSE,
  omit_derived_data = TRUE,
  convert_spatial_columns = TRUE,
  progress = vroom::vroom_progress()
)

movebank_get_study_id(study_id, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movebank_download_study_+3A_study_id">study_id</code></td>
<td>
<p>the study id as a number or a character string can be used to identify a study. This character string
needs to be unique enough to identify one and only one study. Argument applicable to all functions.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_attributes">attributes</code></td>
<td>
<p>a character vector with the event data attributes to download. By default <code>"all"</code> are downloaded,
this make it slightly slower, to speed up <code>NULL</code> can be used as it reduces it to the minimal set of required
attributes (only for location data). Alternatively a vector of attributes can be provided (the minimal ones are
automatically added). Argument applicable to <code>movebank_download_study</code> and <code>movebank_retrieve</code>. See 'Details' for more information.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_...">...</code></td>
<td>
<p>arguments added to the
<a href="https://github.com/movebank/movebank-api-doc/blob/master/movebank-api.md">movebank api</a> call. See 'Details' for some
common arguments.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_remove_movebank_outliers">remove_movebank_outliers</code></td>
<td>
<p>if <code>TRUE</code> outliers according to the movebank logic are removed. This should
correspond to the <code>visible</code> attribute in movebank. Argument applicable to <code>movebank_download_study</code> and <code>movebank_retrieve</code>.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_entity_type">entity_type</code></td>
<td>
<p>the entity type of the data requested from movebank (e.g. <code>"study"</code>, <code>"tag"</code>, <code>"event"</code>).
Alternatively it can be the complete api url for testing purposes. Argument applicable to <code>movebank_retrieve</code>.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_handle">handle</code></td>
<td>
<p>the curl handle used to perform the api call, generally this is extracted from the system keyring if
correctly set up with <code>movebank_store_credentials</code>. Argument applicable to all functions.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_rename_columns">rename_columns</code></td>
<td>
<p>if <code>TRUE</code> column names of properties that are repeated in the api output (e.g. <code>id</code>,
<code>local_identifier</code> and <code>comments</code>) will be appended with the <code>entity_type</code> (e.g. &quot;tag&quot;, &quot;individual&quot;). Argument applicable to <code>movebank_download_study</code>, <code>movebank_download_study_info</code>, <code>movebank_retrieve</code>.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_omit_derived_data">omit_derived_data</code></td>
<td>
<p>derived data (e.g. <code>timestamp_start</code>, <code>timestamp_end</code>, <code>number_of_events</code>
and <code>number_of_deployments</code>) is omitted from the result. The default is <code>TRUE</code> as this data quickly becomes
unrepresentative if the results are processed. However in some occasions it might be worth retrieving it,
for example if you want to identify deployment periods without downloading all data. Argument applicable to <code>movebank_download_study</code> and <code>movebank_retrieve</code>.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_convert_spatial_columns">convert_spatial_columns</code></td>
<td>
<p>if <code>TRUE</code> column pairs containing spatial data will be converted to an <code>sfc</code> column. Argument applicable to all functions.</p>
</td></tr>
<tr><td><code id="movebank_download_study_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> a progress bar will be displayed. More details can be found here <code><a href="vroom.html#topic+vroom">vroom</a></code>. Argument applicable to <code>movebank_download_study</code> and <code>movebank_retrieve</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caution, when downloading data with <code>movebank_download_study</code> without specifying the sensor in the argument <code>sensor_type_id</code>
(see below), all data of all sensors will be downloaded, but only the attributes of location sensors will be
included. We recommend to always specify the sensor(s) to ensure that all associated attributes are downloaded.
Use e.g. <code>movebank_download_study_info(study_id=my_study_id)$sensor_type_ids</code> to find out which sensors are
available in a given study.
<code>attributes = "all"</code> is the default, and it will include only location sensor attributes if no sensor is specified
in <code>sensor_type_id</code>. When sensors are specified, it will download all associated attributes of all sensors.
<code>attributes = NULL</code> should only be used when downloading location data (by specifying the sensor), as only timestamp,
location and track id is downloaded. To specify only a subset of attributes to download, check the list of attributes
available for a specific sensor (e.g. GPS) in a given study, use
<code>movebank_retrieve(entity_type = "study_attribute", study_id = myStudyID, sensor_type_id = "gps")$short_name</code>
(more details in &quot;Downloading data from movebank&quot; vignette).
</p>
<p>The api is quite flexible for adjusting requests. This is elaborately documented in the
<a href="https://github.com/movebank/movebank-api-doc/blob/master/movebank-api.md">movebank api documentation</a>. To identify the available arguments, please note that <code>movebank_download_study</code> is based on the entity_type &quot;event&quot;, <code>movebank_download_study_info</code> on the entity_type &quot;study&quot; and <code>movebank_download_deployment</code> on the entity_type &quot;deployment&quot;, &quot;individual&quot; and &quot;tag&quot;.
Here a list of a few arguments that are common for the entity_type &quot;event&quot;:
</p>

<ul>
<li> <p><code>sensor_type_id</code> can be used to restrict the download to specific sensors. It can be either a character or and
integer with the tag_type. For a full list of options see: <code>movebank_retrieve(entity_type='tag_type')</code>, values from
the <code>id</code> and <code>external_id</code> columns are valid.
</p>
</li>
<li> <p><code>timestamp_start</code> and <code>timestamp_end</code> can be used to limit the temporal range to download.
This argument can either be formatted as a <code>POSIXct</code> timestamp, <code>Date</code> or a character string
(e.g. <code>"20080604133046000"</code>(<code>yyyyMMddHHmmssSSS</code>))
</p>
</li>
<li> <p><code>event_reduction_profile</code> might be useful to reduce the data downloaded (e.g. daily locations) possible values
are character strings (e.g. <code>"EURING_01"</code>). For details see the movebank api
<a href="https://github.com/movebank/movebank-api-doc/blob/master/movebank-api.md#get-reduced-event-data">documentation</a>.
Note that for the time being the required attributes need to be explicitly stated (e.g. <code>attributes = NULL</code>)
as <code>"all"</code> does not work with the current movebank api.
</p>
</li>
<li> <p><code>individual_local_identifier</code> for selecting one or more individuals by the local identifier
</p>
</li></ul>

<p>For more elaborate usage see <code>vignette("movebank", package='move2')</code>
</p>


<h3>Value</h3>

<p><code>movebank_download_study</code> returns a <code>move2</code> object. <br />
<code>movebank_retrieve</code>, <code>movebank_download_deployment</code>, <code>movebank_download_study_info</code> return a <code>data.frame</code>/<code>tbl</code>.<br />
<code>movebank_get_study_id</code> returns a <code><a href="bit64.html#topic+integer64">big integer</a></code>.
</p>


<h3>See Also</h3>

<p>Other movebank-download: 
<code><a href="#topic+movebank_handle">movebank_handle</a>()</code>,
<code><a href="#topic+movebank_store_credentials">movebank_store_credentials</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## download entire study (all data of all sensors)
movebank_download_study_info(study_id = myStudyID)$sensor_type_ids
movebank_download_study(2911040, sensor_type_id = c("gps", "acceleration"))

## download data of one individual
movebank_download_study(2911040,
  individual_local_identifier = "unbanded-160"
)
## download gps data for multiple individuals
movebank_download_study(2911040,
  sensor_type_id = "gps",
  individual_local_identifier = c("1094-1094", "1103-1103")
)
movebank_download_study(2911040,
  sensor_type_id = "gps",
  individual_id = c(2911086, 2911065)
)
## download acceleration data of one or several individuals
movebank_download_study(2911040,
  sensor_type_id = "acceleration",
  individual_local_identifier = "1094-1094"
)
## download data of a specific time window and sensor
movebank_download_study(2911040,
  sensor_type_id = "gps",
  timestamp_start = as.POSIXct("2008-08-01 00:00:00"),
  timestamp_end = as.POSIXct("2008-08-03 00:00:00")
)

## download study filtered to one location per day
## (see movebank api documentation for options)
## also possible to add specific columns in "attributes"
movebank_download_study(2911040,
  sensor_type_id = "gps",
  event_reduction_profile = "EURING_01",
  attributes = NULL
)
## download data associated to tag, individual and deployment
movebank_download_deployment(2911040)
## download study information for all studies
movebank_download_study_info()
## download study information for all studies where you have
## access to download the data
movebank_download_study_info(i_have_download_access = TRUE)
## download study information for a specific study
movebank_download_study_info(id = 2911040)
## get study id
movebank_get_study_id(study_id = "Galapagos Albatrosses")
## Find studies you can download and have a creative commons zero license
## Note "CC_BY" is also frequently used
movebank_download_study_info(
  license_type = "CC_0",
  i_have_download_access = TRUE,
  attributes = c("name", "id")
)
## Download list of own studies
movebank_download_study_info(i_am_owner = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='movebank_get_vocabulary'>Retrieve information from the movebank vocabulary describing the columns</h2><span id='topic+movebank_get_vocabulary'></span>

<h3>Description</h3>

<p>Retrieve information describing the columns from the 'Movebank Attribute Dictionary'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movebank_get_vocabulary(
  labels,
  xml = "http://vocab.nerc.ac.uk/collection/MVB/current/",
  omit_deprecated = TRUE,
  return_type = c("definition", "list", "xml", "uri")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movebank_get_vocabulary_+3A_labels">labels</code></td>
<td>
<p>Either a character vector with the column names to look up or a <code>move2</code> object from which the column
names will be extracted. If no argument is provided all movebank terms are returned</p>
</td></tr>
<tr><td><code id="movebank_get_vocabulary_+3A_xml">xml</code></td>
<td>
<p>Either a connection to the movebank vocabulary xml, a path to the vocabulary file or an url where it can
be downloaded. The later is the default. By downloading the xml yourself the function will speed up and become
independent of an internet connection being available.</p>
</td></tr>
<tr><td><code id="movebank_get_vocabulary_+3A_omit_deprecated">omit_deprecated</code></td>
<td>
<p>If concepts are marked deprecated they are omitted from the set of possible labels.</p>
</td></tr>
<tr><td><code id="movebank_get_vocabulary_+3A_return_type">return_type</code></td>
<td>
<p>A character scalar identifying the desired return type, see details for more information on the
specific types.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can return data in several formats (see <code>return_type</code> argument):
</p>

<ul>
<li> <p><code>definition</code> A named text vector with the description of the term.
</p>
</li>
<li> <p><code>list</code> A list with all information for each term.
</p>
</li>
<li> <p><code>xml</code> A xml_node with the definition.
</p>
</li>
<li> <p><code>uri</code> A link to the full definitions page.
</p>
</li></ul>



<h3>Value</h3>

<p>A named list of the selected <code>return_type</code>, note that if deprecated are not omitted duplicated names can
occur.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the names of all terms used in movebank
movebank_get_vocabulary() |&gt;
  names()
## retrieve one variable
movebank_get_vocabulary("gps hdop")
## Count the units used in movebank
movebank_get_vocabulary() |&gt;
  unlist() |&gt;
  grep(pattern = "Units:", value = TRUE) |&gt;
  sub(replacement = "", pattern = ".*Units: ") |&gt;
  sub(replacement = "", pattern = "; .*") |&gt;
  table() |&gt;
  sort()
## different return types:
movebank_get_vocabulary("light-level", return_type = "definition")
movebank_get_vocabulary("light-level", return_type = "xml")
movebank_get_vocabulary("light-level", return_type = "uri")
movebank_get_vocabulary("light-level", return_type = "list")
## get definitions of all column names of a move2 object, the conversion
## to a list is for better printing
data &lt;- mt_read(mt_example())
movebank_get_vocabulary(data) |&gt;
  as.list()

</code></pre>

<hr>
<h2 id='movebank_handle'>Create a curl handle for accessing movebank</h2><span id='topic+movebank_handle'></span>

<h3>Description</h3>

<p>Create a curl handle for accessing movebank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movebank_handle(username = NULL, password = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movebank_handle_+3A_username">username</code></td>
<td>
<p>Optionally a username as a character string</p>
</td></tr>
<tr><td><code id="movebank_handle_+3A_password">password</code></td>
<td>
<p>Optionally a password as a character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If no credentials are provided the function tries to retrieve the username and password from the system
keyring using the keyring package. If a username is provided but no password it is requested using
<code><a href="askpass.html#topic+askpass">askpass</a></code>
</p>


<h3>Value</h3>

<p>A <code><a href="curl.html#topic+handle">handle</a></code> that can be added to a request made with <code><a href="curl.html#topic+curl">curl</a></code>
</p>


<h3>See Also</h3>

<p>Other movebank-download: 
<code><a href="#topic+movebank_download_study">movebank_download_study</a>()</code>,
<code><a href="#topic+movebank_store_credentials">movebank_store_credentials</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>movebank_handle("test_user", "test_password")
</code></pre>

<hr>
<h2 id='movebank_store_credentials'>Store or remove credentials in the system keyring</h2><span id='topic+movebank_store_credentials'></span><span id='topic+movebank_remove_credentials'></span>

<h3>Description</h3>

<p>The function stores the credentials for accessing movebank, by default it checks if accessing movebank is possible,
and fails when either the credentials are invalid or movebank cannot be reached. The force option can be used to
override this. Once credentials are stored, these functions are not needed again as all call to movebank can use the
credentials from the keyring.
</p>
<p>For more details on the usage of the keyring, how passwords are handled and handling multiple accounts see
<code>vignette("movebank", package="move2")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movebank_store_credentials(
  username,
  password,
  key_name = getOption("move2_movebank_key_name"),
  force = FALSE
)

movebank_remove_credentials(key_name = getOption("move2_movebank_key_name"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movebank_store_credentials_+3A_username">username</code></td>
<td>
<p>A string with the movebank username</p>
</td></tr>
<tr><td><code id="movebank_store_credentials_+3A_password">password</code></td>
<td>
<p>Either a string or missing, if missing then the password is asked for using
<code><a href="askpass.html#topic+askpass">askpass</a></code></p>
</td></tr>
<tr><td><code id="movebank_store_credentials_+3A_key_name">key_name</code></td>
<td>
<p>The name of the key in the keyring. By default this is stored in
<code>getOption("move2_movebank_key_name")</code>, this might be useful if you have multiple accounts</p>
</td></tr>
<tr><td><code id="movebank_store_credentials_+3A_force">force</code></td>
<td>
<p>If TRUE, when accessing movebank fails the key is stored anyway.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> invisible if successful
</p>


<h3>See Also</h3>

<p>Other movebank-download: 
<code><a href="#topic+movebank_download_study">movebank_download_study</a>()</code>,
<code><a href="#topic+movebank_handle">movebank_handle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
movebank_store_credentials("bart")

## End(Not run)
</code></pre>

<hr>
<h2 id='mt_aeqd_crs'>Create a AEQD coordinate reference system</h2><span id='topic+mt_aeqd_crs'></span>

<h3>Description</h3>

<p>The CRS can be centered around the centroid or center of a <code>move2</code> object or a reference location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_aeqd_crs(x, center = c("centroid", "center"), units = c("m", "km"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_aeqd_crs_+3A_x">x</code></td>
<td>
<p>An object of the class <code>sf</code> or <code>sfc</code>, for example a <code>move2</code> to determine the center from. This argument
is only required if <code>center</code> is a character.</p>
</td></tr>
<tr><td><code id="mt_aeqd_crs_+3A_center">center</code></td>
<td>
<p>Either the method to identify the coordinates of the center of <code>x</code> or the center as a <code>numeric</code>,
<code>POINT</code> or a <code>sf</code>/<code>sfc</code> of length 1. <code>"centroid"</code> calculates the centroid of a collection of points while <code>"center"</code>
calculates the center from the range of the locations.</p>
</td></tr>
<tr><td><code id="mt_aeqd_crs_+3A_units">units</code></td>
<td>
<p>The units of the AEQD projection either <code>m</code> or <code>km</code> for meter or kilometer respectively</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the class <code>crs</code> that can for example be used for re projecting
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt_aeqd_crs(center = c(10, 45))
mt_aeqd_crs(center = sf::st_point(c(10, 45)), units = "km")

m &lt;- mt_read(mt_example())
mt_aeqd_crs(center = sf::st_geometry(m)[5])
mt_aeqd_crs(m)
aeqd_crs &lt;- mt_aeqd_crs(m, "center", "km")
aeqd_crs
sf::st_transform(m, aeqd_crs)

</code></pre>

<hr>
<h2 id='mt_as_move2'>Create a new move2 object</h2><span id='topic+mt_as_move2'></span><span id='topic+mt_as_move2.sf'></span><span id='topic+mt_as_move2.data.frame'></span><span id='topic+mt_as_move2.track_xyt'></span><span id='topic+mt_as_move2.telemetry'></span><span id='topic+mt_as_move2.list'></span><span id='topic+mt_as_move2..MoveTrack'></span>

<h3>Description</h3>

<p>Create a new move2 object from a <code>data.frame</code>, <code>sf</code>, <code>telemetry</code>, <code>telemetry</code> list, <code>track_xyt</code>, <code>Move</code> or <code>MoveStack</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_as_move2(x, ...)

## S3 method for class 'sf'
mt_as_move2(x, time_column, track_id_column, track_attributes = "", ...)

## S3 method for class 'data.frame'
mt_as_move2(x, time_column, track_id_column, track_attributes = "", ...)

## S3 method for class 'track_xyt'
mt_as_move2(x, time_column, track_id_column, track_attributes = "", ...)

## S3 method for class 'telemetry'
mt_as_move2(x, time_column, track_id_column, track_attributes = "", ...)

## S3 method for class 'list'
mt_as_move2(x, time_column, track_id_column, track_attributes = "", ...)

## S3 method for class '.MoveTrack'
mt_as_move2(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_as_move2_+3A_x">x</code></td>
<td>
<p>A <code>data.frame</code>, <code>sf</code>, <code>telemetry</code>, <code>telemetry</code> list, <code>track_xyt</code>, <code>Move</code> or <code>MoveStack</code> object</p>
</td></tr>
<tr><td><code id="mt_as_move2_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code> if <code>x</code> is a <code>data.frame</code>, see the details below
for more information</p>
</td></tr>
<tr><td><code id="mt_as_move2_+3A_time_column">time_column</code></td>
<td>
<p>The name of the column in <code>x</code> containing timestamps</p>
</td></tr>
<tr><td><code id="mt_as_move2_+3A_track_id_column">track_id_column</code></td>
<td>
<p>The name of the column in <code>x</code> containing the track identities</p>
</td></tr>
<tr><td><code id="mt_as_move2_+3A_track_attributes">track_attributes</code></td>
<td>
<p>The name(s) of the column(s) that contain track level attributes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frequently used arguments to <code><a href="sf.html#topic+st_as_sf">st_as_sf</a></code> are:
</p>

<ul>
<li> <p><code>coords</code> a character vector indicating the columns used as coordinates, the length is generally two, for <code>x</code> and
<code>y</code>, but can also be more if <code>z</code> is included
</p>
</li>
<li> <p><code>sf_column_name</code> if a geometry column is present the name of the geometry column to use as coordinates as a
character scalar
</p>
</li>
<li> <p><code>crs</code> the coordinate reference system to use, either as character, number or a <code>crs</code> object for more details see
<code><a href="sf.html#topic+st_crs">st_crs</a></code>
</p>
</li>
<li> <p><code>na.fail</code> normally when the coordinate columns are converted to spatial points <code>NA</code> values cause an error, if set
to <code>FALSE</code> empty points are allowed
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>move2</code> object
</p>


<h3>See Also</h3>

<p>Other move2-convert: 
<code><a href="#topic+to_move">to_move</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a move2 object from a data.frame and defining projection
n &lt;- 5
data &lt;- data.frame(
  x = cumsum(rnorm(n)), y = cumsum(rnorm(n)),
  time = seq(n), track = "a"
)
mt_as_move2(data,
  coords = c("x", "y"), time_column = "time",
  track_id_column = "track"
) |&gt; sf::st_set_crs(4326L)

## Dealing with empty coordinates:
## If the data frame contains NA coordinates, the coords argument in sf
## will fail. An alternative is to first create an sfc column,
## or to use the na.fail argument
nn &lt;- 3
data &lt;- data.frame(
  x = c(cumsum(rnorm(n)), rep(NA, nn)), y = c(cumsum(rnorm(n)), rep(NA, nn)),
  time = seq(n + nn), track = "a",
  sensor = c(rep("sensor1", n), rep("sensor2", nn)),
  sensor2values = c(rep(NA, n), runif(nn))
)
mt_as_move2(data,
  coords = c("x", "y"),
  na.fail = FALSE,
  time_column = "time",
  track_id_column = "track"
)

## create a move2 object from a sf object
data$geometry &lt;- sf::st_sfc(apply(data[, c("x", "y")], 1, sf::st_point, simplify = FALSE))
mt_as_move2(data,
  sf_column_name = c("geometry"), time_column = "time",
  track_id_column = "track"
)

</code></pre>

<hr>
<h2 id='mt_as_track_attribute'>Move one or more columns to track attributes or event attributes</h2><span id='topic+mt_as_track_attribute'></span><span id='topic+mt_as_event_attribute'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_as_track_attribute</code>: move a column from the event to the track attributes
</p>
</li>
<li> <p><code>mt_as_event_attribute</code>: move a column from the track to the event attributes
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_as_track_attribute(x, ..., .keep = FALSE)

mt_as_event_attribute(x, ..., .keep = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_as_track_attribute_+3A_x">x</code></td>
<td>
<p>The move2 object</p>
</td></tr>
<tr><td><code id="mt_as_track_attribute_+3A_...">...</code></td>
<td>
<p>the names of columns to move, it is also possible to use <code><a href="tidyselect.html#topic+language">helpers</a></code>.</p>
</td></tr>
<tr><td><code id="mt_as_track_attribute_+3A_.keep">.keep</code></td>
<td>
<p>a logical if the variables also kept in their original location</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When one or more of the selected columns contain more then one unique value per track an error is raised.
</p>


<h3>Value</h3>

<p>An object of the class <code>move2</code> with the column(s) moved
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mt_track_data">mt_track_data()</a></code> to retrieve the track attribute table
</p>
</li>
<li> <p><code><a href="#topic+mt_set_track_data">mt_set_track_data()</a></code> to replace attribute table with new values
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>sim_data &lt;- mt_sim_brownian_motion()
sim_data$sex &lt;- "female"

## different ways to move column "sex" from event to track attribute
sim_data |&gt; mt_as_track_attribute(sex)
sim_data |&gt; mt_as_track_attribute(starts_with("s"))
sim_data |&gt; mt_as_track_attribute(any_of(c("sex", "age")))
</code></pre>

<hr>
<h2 id='mt_azimuth'>Calculate azimuths or turn angles</h2><span id='topic+mt_azimuth'></span><span id='topic+mt_turnangle'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_azimuth</code>: calculates the heading/azimuth/direction of movement of each segment between consecutive locations
of a track.
</p>
</li>
<li> <p><code>mt_turnangle</code>: calculates the relative angle between consecutive segments.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_azimuth(x, units)

mt_turnangle(x, units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_azimuth_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object. Timestamps must be ordered within tracks and only contain location data and
it must be in a geographic coordinate system or without a coordinate reference system (See 'Details').</p>
</td></tr>
<tr><td><code id="mt_azimuth_+3A_units">units</code></td>
<td>
<p>Optional. Valid values are <code>character</code>, <code>symbolic_units</code> or <code>units</code>, for more details see the <code>value</code> argument of <a href="units.html#topic+units">units::as_units</a>. If no units are stated (default) the function flexibly determines the units to return. Fixing the units can be useful if specific return units are for example required for subsequent functions. This argument only takes effect if the initial return value already has units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mt_is_time_ordered_non_empty_points</code> can be used to check if the timestamps are ordered and if the object only
contains location data. To omit empty locations use e.g. <code>dplyr::filter(x,!sf::st_is_empty(x))</code>.
</p>
<p>Currently the calculation of both angles is only implemented for data in a geographic coordinate system and data
without coordinates reference system. To reproject the data into long/lat use e.g.
<code>sf::st_transform(x, crs="EPSG:4326")</code>
</p>
<p>Azimuths for geographic coordinates are calculated using <code><a href="lwgeom.html#topic+st_geod_azimuth">lwgeom::st_geod_azimuth()</a></code>. The angles are relative to
the North pole.
</p>


<h3>Value</h3>

<p>A vector of angles, currently default is in radians (between <code>-pi</code> and <code>pi</code>).<br />
</p>
<p>In <code>mt_azimuth</code> north is represented by 0, positive values are movements towards the east, and negative values
towards the west. The last value for each track will be <code>NA</code>.
</p>
<p>In <code>mt_turnangle</code> negative values are left turns and positive right turns. The first and the last value for each
track will be <code>NA</code>.
</p>


<h3>See Also</h3>

<p>Other track-measures: 
<code><a href="#topic+mt_distance">mt_distance</a>()</code>,
<code><a href="#topic+mt_time">mt_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mt_sim_brownian_motion()
mt_azimuth(data)
mt_turnangle(data)

x &lt;- mt_read(mt_example())[330:340, ]
mt_azimuth(x)
mt_turnangle(x)

</code></pre>

<hr>
<h2 id='mt_distance'>Return distances or speeds between locations</h2><span id='topic+mt_distance'></span><span id='topic+mt_speed'></span>

<h3>Description</h3>

<p>The distance or speed is calculated between consecutive locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_distance(x, units)

mt_speed(x, units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_distance_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object. Timestamps must be ordered within tracks and only contain location data (See 'Details').</p>
</td></tr>
<tr><td><code id="mt_distance_+3A_units">units</code></td>
<td>
<p>Optional. Valid values are <code>character</code>, <code>symbolic_units</code> or <code>units</code>, for more details see the <code>value</code> argument of <a href="units.html#topic+units">units::as_units</a>. If no units are stated (default) the function flexibly determines the units to return. Fixing the units can be useful if specific return units are for example required for subsequent functions. This argument only takes effect if the initial return value already has units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mt_is_time_ordered_non_empty_points</code> can be used to check if the timestamps are ordered and if the object only
contains location data.  To omit empty locations use e.g. <code>dplyr::filter(x,!sf::st_is_empty(x))</code>.
</p>
<p>Distances are calculated using <a href="sf.html#topic+geos_measures">sf::st_distance</a>.
</p>


<h3>Value</h3>

<p>a vector of the same length as the <code>move2</code> object containing the distances/speeds between locations.
Each element is the distance/speed to the next location.
The last value for each track will be <code>NA</code>. Units are included when the data have a coordinate reference system set.
</p>


<h3>See Also</h3>

<p>Other track-measures: 
<code><a href="#topic+mt_azimuth">mt_azimuth</a>()</code>,
<code><a href="#topic+mt_time">mt_time</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## distance between consecutive locations
mt_sim_brownian_motion() |&gt;
  mt_distance() |&gt;
  head()
## When the data has a coordinate reference system set,
## units are included
dist &lt;- mt_sim_brownian_motion(1:4) |&gt;
  sf::st_set_crs(4326L) |&gt;
  mt_distance()
dist
## transform units of output
units::set_units(dist, km)

## speed between consecutive locations
mt_sim_brownian_motion() |&gt; mt_speed()

## When projections are provided units are included
data &lt;- mt_read(mt_example())[330:340, ]
speed_calc &lt;- data |&gt;
  mt_speed()
speed_calc
## transform units of output
units::set_units(speed_calc, m / s)

## Different projection gives same speed
data |&gt;
  sf::st_transform("+proj=aeqd +units=km +lon_0=-73.9 +lat_0=42.7") |&gt;
  mt_speed() |&gt;
  units::set_units(m / s)

</code></pre>

<hr>
<h2 id='mt_example'>Get path to <code>move2</code> example data</h2><span id='topic+mt_example'></span>

<h3>Description</h3>

<p>The <code>move2</code> package comes with an example data files that is directly downloaded from
<a href="https://www.movebank.org">movebank</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_example(
  file = c("fishers.csv.gz", "Galapagos_Albatrosses-1332012225316982996.zip")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_example_+3A_file">file</code></td>
<td>
<p>The name of the file for which the path needs to be retrieved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fisher example dataset is the study &quot;Martes pennanti LaPoint New York&quot; (study id: <code>69258089</code>), shared under
the CC-BY-NC license.
For more information on the data see LaPoint et al. (2013) Landscape Ecology. doi: 10.1007/s10980-013-9910-0 .
This csv file is gz compressed for reduction in package size.
</p>
<p>The Galapagos Albatrosses (study id: <code>2911040</code>) dataset annotated with environmental data using the Env-DATA system.
For this dataset two individuals (<code>4261-2228</code> &amp; <code>2131-2131</code>) were selected. Data was annotated with wind and
an productivity variables.
</p>


<h3>Value</h3>

<p>The path to the example file of the <code>move2</code> package
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mt_read">mt_read()</a></code> to read in the file
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
## Get path to one example
mt_example()
mt_example("Galapagos_Albatrosses-1332012225316982996.zip")
</code></pre>

<hr>
<h2 id='mt_filter_movebank_visible'>Identify records that are not outliers according to the logic used in movebank</h2><span id='topic+mt_filter_movebank_visible'></span><span id='topic+mt_movebank_visible'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_filter_movebank_visible</code>: returns a <code>move2</code> object with all visible data, i.e., excluding all records marked
as outliers according to the logic used in movebank (See <em>Details</em>)
</p>
</li>
<li> <p><code>mt_movebank_visible</code>: indicates with <code>TRUE</code> the visible records, and with <code>FALSE</code> those marked as outliers
according to the logic used in movebank (See <em>Details</em>)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_filter_movebank_visible(x)

mt_movebank_visible(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_filter_movebank_visible_+3A_x">x</code></td>
<td>
<p>a move2 object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions rely on the columns 'visible', 'algorithm_marked_outlier', 'import_marked_outlier',
'manually_marked_outlier', and/or 'manually_marked_valid'. All of them are expected to be logical. More details
can be found in the <a href="http://vocab.nerc.ac.uk/collection/MVB/current/MVB000209/">movebank vocabulary</a>
</p>


<h3>Value</h3>

<p><code>mt_movebank_visible</code>returns a logical vector indicating the records that are valid.<br />
<code>mt_filter_movebank_visible</code> returns a filtered <code>move2</code> object
</p>


<h3>See Also</h3>

<p>Other filter: 
<code><a href="#topic+mt_filter_per_interval">mt_filter_per_interval</a>()</code>,
<code><a href="#topic+mt_filter_unique">mt_filter_unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m &lt;- mt_read(mt_example())
table(mt_movebank_visible(m))
mt_filter_movebank_visible(m)

</code></pre>

<hr>
<h2 id='mt_filter_per_interval'>Find subset of records based on time windows</h2><span id='topic+mt_filter_per_interval'></span><span id='topic+mt_per_interval'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_filter_per_interval</code>: returns a <code>move2</code> with the selected records
</p>
</li>
<li> <p><code>mt_per_interval</code>: returns a logical vector indicating the selected records
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_filter_per_interval(x, ...)

mt_per_interval(
  x,
  criterion = c("first", "random", "last"),
  unit = "hour",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_filter_per_interval_+3A_x">x</code></td>
<td>
<p>a move2 object</p>
</td></tr>
<tr><td><code id="mt_filter_per_interval_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>mt_per_interval</code> and <code><a href="lubridate.html#topic+floor_date">floor_date</a></code>,
for example the day that starts the week</p>
</td></tr>
<tr><td><code id="mt_filter_per_interval_+3A_criterion">criterion</code></td>
<td>
<p>the criterion of what record to select per time interval</p>
</td></tr>
<tr><td><code id="mt_filter_per_interval_+3A_unit">unit</code></td>
<td>
<p>the time units to select the first record per. This can also be a multiple of units (e.g. &quot;30 seconds&quot;).
For more details see <code><a href="lubridate.html#topic+floor_date">floor_date</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects one event per defined interval (time window). The time lag
between the selected events does not necessarily correspond to the defined interval. For
example, if the defined time interval is &quot;1 hour&quot; with the criterion &quot;first&quot;, the function will select the
event that is closest to every full hour, so if the first event of a track is at 10:45 and the second at 11:05,
both of them will be selected, as they fall into different hour windows, but the time lag between them is 20 minutes.
When sampling down a track, the time lags mostly correspond to the defined time interval, except the first time lag,
and when there are gaps in the data.
</p>


<h3>Value</h3>

<p><code>mt_per_interval</code> returns a logical vector indicating the selected records. <br />
<code>mt_filter_per_interval</code> returns a filtered <code>move2</code> object
</p>


<h3>See Also</h3>

<p>Other filter: 
<code><a href="#topic+mt_filter_movebank_visible">mt_filter_movebank_visible</a>()</code>,
<code><a href="#topic+mt_filter_unique">mt_filter_unique</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mt_sim_brownian_motion(as.POSIXct("2022-1-1") + 1:10)
data |&gt; mt_filter_per_interval(criterion = "random")
data |&gt; mt_filter_per_interval(unit = "3 secs")
data[mt_per_interval(data, unit = "6 secs"), ]
</code></pre>

<hr>
<h2 id='mt_filter_unique'>Filter out duplicated records from a <code>move2</code> object</h2><span id='topic+mt_filter_unique'></span><span id='topic+mt_unique'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_filter_unique</code>: returns a <code>move2</code> from which duplicated records have been removed
</p>
</li>
<li> <p><code>mt_unique</code>: returns a logical vector indicating the unique records
By default columns that have a duplicated timestamps and track identifier are filtered
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_filter_unique(x, ...)

mt_unique(
  x,
  criterion = c("subsets", "subsets_equal", "sample", "first", "last"),
  additional_columns = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_filter_unique_+3A_x">x</code></td>
<td>
<p>The <code>move2</code> object to filter</p>
</td></tr>
<tr><td><code id="mt_filter_unique_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>mt_unique</code> function like <code>criterion</code> and arguments to the equivalence function
when one of the <code>"subsets"</code> criteria is use, this allows for example controlling the <code>tolerance</code> (<code><a href="base.html#topic+all.equal">base::all.equal()</a></code>)</p>
</td></tr>
<tr><td><code id="mt_filter_unique_+3A_criterion">criterion</code></td>
<td>
<p>The criterion to decide what records to filter out. For more information see <em>Details</em> below.</p>
</td></tr>
<tr><td><code id="mt_filter_unique_+3A_additional_columns">additional_columns</code></td>
<td>
<p>In some cases different sensors or tracking devices
might have the same combination of time and track identifier.
It might, for example, be desirable to retain records from an accelerometer
and gps recorded at the same time.
This argument can be used to indicate additional column to include in the grouping
within which the records should not be duplicated.
See the examples below for its usage.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make an informed choice of how to remove duplicates, we recommend to first try to understand why the data set has duplicates.
</p>
<p>Several methods for filtering duplicates are available the options can be controlled through the <code>criterion</code>
argument:
</p>

<ul>
<li> <p><code>"subsets"</code>: Only records that are a subset of other records are omitted.
Some tracking devices first transmit an smaller dataset that does not contain all information, therefore some
records may be the same as others only containing additional <code>NA</code> values.
This strategy only omits those (duplicated) records. As a result duplicates that contain unique information are
retained, the dataset is thus not guaranteed to not have unique records afterwards.
</p>
</li>
<li> <p><code>"subsets_equal"</code>: The same as <code>"subsets"</code> however not exact equivalence is tested using <code><a href="base.html#topic+identical">base::identical()</a></code> but
rather <code><a href="base.html#topic+all.equal">base::all.equal()</a></code> is used. This makes it possible to allow for small numeric differences to be considered
equal. This can however reduce speed considerably.
</p>
</li>
<li> <p><code>"sample"</code>: In this case one record is randomly selected from the duplicated records.
</p>
</li>
<li> <p><code>"first"</code>: Select the first location from a set of duplicated locations. Note that reordering the data will affect
which record is selected. For movebank data no specific order is enforced, ensure that the order of the locations is like you expect (same goes for <code>"last"</code>).
</p>
</li>
<li> <p><code>"last"</code>: Select the last location from a set of duplicated locations.
</p>
</li></ul>



<h3>Value</h3>

<p><code>mt_unique</code>returns a logical vector indicating the unique records.<br />
<code>mt_filter_unique</code> returns a filtered <code>move2</code> object
</p>


<h3>See Also</h3>

<p>Other filter: 
<code><a href="#topic+mt_filter_movebank_visible">mt_filter_movebank_visible</a>()</code>,
<code><a href="#topic+mt_filter_per_interval">mt_filter_per_interval</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- mt_sim_brownian_motion(1:2)[rep(1:4, 4), ]
m$sensor_type &lt;- as.character(gl(2, 4))
m$sensor_type_2 &lt;- as.character(gl(2, 8))
table(mt_unique(m, "sample"))
mt_filter_unique(m[, c("time", "track", "geometry")])
mt_filter_unique(m[, c("time", "track", "geometry", "sensor_type")],
  additional_columns = sensor_type
)
if (requireNamespace("dplyr")) {
  mt_filter_unique(m, additional_columns = across(all_of(c("sensor_type", "sensor_type_2"))))
}
mt_filter_unique(m, "sample")
mt_filter_unique(m, "first")
m$sensor_type[1:12] &lt;- NA
mt_filter_unique(m[, c("time", "track", "geometry", "sensor_type")])


## Sometimes it is desirable to not consider specific columns for finding
## the unique records. For example the record identifier like `event_id`
## in movebank This can be done by reducing the data.frame used to identify
## the unique records e.g.:
m$event_id &lt;- seq_len(nrow(m))
m[mt_unique(m |&gt; dplyr::select(-event_id, -ends_with("type_2"))), ]
## Note that because we subset the full original data.frame the
## columns are not lost


## This example is to retain the duplicate entry which contains the least
## number of columns with NA values
mv &lt;- mt_read(mt_example())
mv &lt;- dplyr::bind_rows(mv, mv[1:10, ])
mv[, "eobs:used-time-to-get-fix"] &lt;- NA
mv_no_dup &lt;- mv |&gt;
  dplyr::mutate(n_na = rowSums(is.na(pick(everything())))) |&gt;
  dplyr::arrange(n_na) |&gt;
  mt_filter_unique(criterion = "first")

</code></pre>

<hr>
<h2 id='mt_interpolate'>Linearly interpolate locations</h2><span id='topic+mt_interpolate'></span>

<h3>Description</h3>

<p>Linear interpolation along the straight line between consecutive locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_interpolate(x, time, max_time_lag, omit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_interpolate_+3A_x">x</code></td>
<td>
<p>A <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_interpolate_+3A_time">time</code></td>
<td>
<p>The times to interpolate to, if missing the interpolation is to the empty locations.
Alternatively if the timestamps in <code>x</code> are <code>POSIXct</code> then also an interval can be provided.
For details on the interval specification see <code><a href="lubridate.html#topic+floor_date">floor_date</a></code>.</p>
</td></tr>
<tr><td><code id="mt_interpolate_+3A_max_time_lag">max_time_lag</code></td>
<td>
<p>The maximal time lag to interpolate over, if not provided any interval is interpolated</p>
</td></tr>
<tr><td><code id="mt_interpolate_+3A_omit">omit</code></td>
<td>
<p>If the original location that do not match a value in <code>time</code> should be omitted. This only
takes affect when <code>time</code> is not missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each interpolation is done along a straight path from the previous to the next location.
Interpolation is done with <code><a href="sf.html#topic+st_line_sample">st_line_sample</a></code> when there is no CRS provided and <code><a href="s2.html#topic+s2_interpolate_normalized">s2_interpolate_normalized</a></code> when the data has a projection.
</p>


<h3>Value</h3>

<p>A <code>move2</code> object with the interpolated locations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mt_sim_brownian_motion(t = c(0, 0.6, 3, 3.5))
## interpolating at specific times
mt_interpolate(data, c(.5, 1.5, 2.5))
## interpolating to empty locations
data$geometry[c(1, 3)] &lt;- sf::st_point() ## creating empty locations
mt_interpolate(data)

fishers &lt;- mt_read(mt_example())[1:200, ]
mt_interpolate(fishers, "2 hours")
## omit the original records
mt_interpolate(fishers, "2 hours", omit = TRUE)

</code></pre>

<hr>
<h2 id='mt_is_track_id_cleaved'>Functions for asserting properties of a <code>move2</code> object</h2><span id='topic+mt_is_track_id_cleaved'></span><span id='topic+mt_is_time_ordered'></span><span id='topic+mt_has_unique_location_time_records'></span><span id='topic+mt_is_time_ordered_non_empty_points'></span><span id='topic+mt_has_no_empty_points'></span><span id='topic+mt_is_move2'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_is_track_id_cleaved()</code> asserts all tracks are grouped in the data set, they occur consecutively.
</p>
</li>
<li> <p><code>mt_is_time_ordered()</code> checks if all tracks are groups and if timestamps within a track are ascending (i.e. the
time differences between successive locations are equal or above 0).
</p>
</li>
<li> <p><code>mt_has_unique_location_time_records()</code> checks if all records with a location have a unique timestamp (i.e. checks
for duplicated timestamps within a track).
</p>
</li>
<li> <p><code>mt_is_time_ordered_non_empty_points()</code> this assertion combines the <code>mt_is_time_ordered()</code> and
<code>mt_has_no_empty_points()</code> assertions and thus ensures that each record has a location and timestamps are ordered.
</p>
</li>
<li> <p><code>mt_has_no_empty_points()</code> asserts all geometries are points and that there are no empty points.
</p>
</li>
<li> <p><code>mt_is_move2()</code> asserts <code>x</code> inherits the class <code>move2</code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_is_track_id_cleaved(x)

mt_is_time_ordered(x, non_zero = FALSE)

mt_has_unique_location_time_records(x)

mt_is_time_ordered_non_empty_points(x, non_zero = FALSE)

mt_has_no_empty_points(x)

mt_is_move2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_is_track_id_cleaved_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_is_track_id_cleaved_+3A_non_zero">non_zero</code></td>
<td>
<p>If <code>TRUE</code> only intervals longer than 0 are considered ordered (i.e. no coinciding timestamps),
if <code>FALSE</code> also 0 intervals are considered ordered</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For these functions an <code><a href="assertthat.html#topic+on_failure">on_failure</a></code> error
function is defined. This results in meaningful error messages when the
function is used in combination with <code><a href="assertthat.html#topic+assert_that">assert_that</a></code>. These functions can also be used in
normal logical operations as <code>TRUE</code> or <code>FALSE</code> is returned.
</p>


<h3>Value</h3>

<p>a logical value if the asserted property is <code>TRUE</code> or <code>FALSE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## examples of what to do if assertion if FALSE
n &lt;- 8
data &lt;- data.frame(
  x = cumsum(rnorm(n)), y = cumsum(rnorm(n)),
  time = seq(n), track = sample(c("a", "b"), size = n, replace = TRUE)
)
data &lt;- rbind(data, data[sample(nrow(data), 2), ]) # adding duplicate timestamps
mv &lt;- mt_as_move2(data,
  coords = c("x", "y"),
  time_column = "time",
  track_id_column = "track"
)
mv$geometry[c(1, 3)] &lt;- sf::st_point() # adding empty locations

mt_is_track_id_cleaved(mv)
mv &lt;- dplyr::arrange(mv, mt_track_id(mv))

mt_is_time_ordered(mv)
mv &lt;- dplyr::arrange(mv, mt_track_id(mv), mt_time(mv))

mt_has_unique_location_time_records(mv)
mv &lt;- mt_filter_unique(mv)

mt_has_no_empty_points(mv)
mv &lt;- dplyr::filter(mv, !sf::st_is_empty(mv))

## example of using the assertions with assertthat
if (requireNamespace("assertthat")) {
  m &lt;- mt_sim_brownian_motion(t = 1:2, tracks = 2)
  assertthat::see_if(mt_is_track_id_cleaved(m))
  assertthat::see_if(mt_is_track_id_cleaved(m[c(3, 1, 2, 4), ]))
  assertthat::see_if(mt_is_time_ordered(m[c(2:1, 3, 4), ]))
  assertthat::see_if(mt_has_unique_location_time_records(m[c(1, 1, 2, 3, 4), ]))
  assertthat::see_if(mt_is_move2(m$time))
}

</code></pre>

<hr>
<h2 id='mt_read'>Reading files downloaded from movebank</h2><span id='topic+mt_read'></span>

<h3>Description</h3>

<p>Reading files downloaded from movebank
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_read(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_read_+3A_file">file</code></td>
<td>
<p>The file path to read or a R connection (for details see <code><a href="base.html#topic+connections">connections</a></code>).
Files can either be csv files from movebank or zip files that are created using Env-DATA.</p>
</td></tr>
<tr><td><code id="mt_read_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="vroom.html#topic+vroom">vroom</a></code>, for example <code>col_select</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Files can be <code>gz</code> compressed and if the same columns are present multiple files can be read simultaneously.
Using the pipe command in R and some command line tools it is possible to select specific days or months.
</p>
<p>When using the <code>col_select</code> argument of <code><a href="vroom.html#topic+vroom">vroom</a></code> it is possible to speed up file reading
considerably while reducing memory consumption.
Especially columns containing acceleration values can become quite large.
</p>
<p>For files that contain both a <code>individual-local-identifier</code> and a <code>tag-local-identifier</code> column a
check is preformed if individuals have been wearing multiple tags over time. If this is the case tracks are
created based on the combination of both id's. A new column names <code>individual-tag-local-identifier</code> in created,
which will correspond to the track ids. This somewhat resembles the movebank logic however the track ids do
not necessarily correspond to the deployments in movebank as this information is not contained in exported csv's.
</p>


<h3>Value</h3>

<p>An object of the class <code>move2</code>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mt_example">mt_example()</a></code> for the path to an example file.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>path_fishers &lt;- mt_example()

mt_read(path_fishers)

## Reduce the mount of data read this might provide memory advantages
## and speed up reading
mt_read(path_fishers, col_select = c(
  "location-long", "location-lat",
  "timestamp", "individual-local-identifier"
))
## Read Galapagos Albatross data that has been annotated
mt_read(mt_example("Galapagos_Albatrosses-1332012225316982996.zip"))
## Notice this produces a warning as some units are not recognized
## This can be prevented by installing the units
## Not run: 
units::install_unit("gC", "g", "Grams of carbon")

## End(Not run)

## Not run: 
## Reading can also be manipulted to speed up or reduce memory consumption
## Here we assume the Galapagos albatross data has been downloaded
mt_read("~/Downloads/Galapagos Albatrosses.csv")
## Exclude the column 'eobs:accelerations-raw'
mt_read("~/Downloads/Galapagos Albatrosses.csv",
  col_select = (!`eobs:accelerations-raw`)
)
## Only read records from July 2008 using a system pipe where the data
## is already filtered before reading into R
mt_read(pipe('cat "~/Downloads/Galapagos Albatrosses.csv" | grep "2008-07\\|time"'))

## End(Not run)

</code></pre>

<hr>
<h2 id='mt_segments'>Create a <code>LINESTRING</code> for each track segment</h2><span id='topic+mt_segments'></span>

<h3>Description</h3>

<p>Creates a <code>LINESTRING</code> for each segment between consecutive points within a track.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_segments(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_segments_+3A_x">x</code></td>
<td>
<p>A <code>move2</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The last location of each track is formed by a <code>POINT</code> as no segment can be formed.
</p>


<h3>Value</h3>

<p>A <code>sfc</code> object containing <code>LINESTRING</code>s for each segment of a trajectory.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mt_track_lines">mt_track_lines()</a></code> For transforming the full tracks into one <code>LINESTRING</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>track &lt;- mt_sim_brownian_motion()
mt_segments(track)
## adding the segments as an attribute to the move2 object
track$segments &lt;- mt_segments(track)
track

</code></pre>

<hr>
<h2 id='mt_sim_brownian_motion'>Simulate Brownian motion</h2><span id='topic+mt_sim_brownian_motion'></span>

<h3>Description</h3>

<p>Creates a <code>move2</code> object with simulated data following a Brownian motion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_sim_brownian_motion(
  t = 1L:10L,
  sigma = 1L,
  tracks = 2L,
  start_location = c(0L, 0L),
  track_id = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_sim_brownian_motion_+3A_t">t</code></td>
<td>
<p>a vector of timestamps, numeric values or times to simulate for. If multiple tracks are created this vector will
be used for all of them, alternatively a list with a vector per track can be provided.</p>
</td></tr>
<tr><td><code id="mt_sim_brownian_motion_+3A_sigma">sigma</code></td>
<td>
<p>The Brownian motion variance movement rate  <code class="reqn">[\frac{\sigma}{time}]</code> either as scalar number or a
vector with a number per segment. Not that this argument is the movement rate so the motion variance will be
adjusted for the length of the interval. Alternatively a function that is integrated over time in the simulation
function, this function needs to be vectorized (if needed see <code><a href="base.html#topic+Vectorize">Vectorize</a></code>). If a list is provided
one element of the list is taken per track.</p>
</td></tr>
<tr><td><code id="mt_sim_brownian_motion_+3A_tracks">tracks</code></td>
<td>
<p>Either the number of tracks or a vector containing the names of the tracks.</p>
</td></tr>
<tr><td><code id="mt_sim_brownian_motion_+3A_start_location">start_location</code></td>
<td>
<p>Either one or a list of start locations, as a vector with two numbers.</p>
</td></tr>
<tr><td><code id="mt_sim_brownian_motion_+3A_track_id">track_id</code></td>
<td>
<p>The identifier of the track if a single track is requested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when lists are provided as in input the names of these lists are ignored. Individuals are simulated by
order.
</p>
<p>If <code>t</code> is numeric the movement rate (<code>sigma</code>) is assumed to be expressed per unit <code>t</code>, if <code>t</code> is a timestamp or a
date, <code>sigma</code> is assumed to be expressed per second.
</p>


<h3>Value</h3>

<p>a move2 object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt_sim_brownian_motion() |&gt; plot()
mt_sim_brownian_motion(list(1:10, 1:100)) |&gt;
  mt_track_lines() |&gt;
  plot()
mt_sim_brownian_motion(1:200,
  sigma = .25, letters[1:4],
  list(c(0, 0), c(10, 0), c(0, 10), c(10, 10))
) |&gt;
  mt_track_lines() |&gt;
  plot()
</code></pre>

<hr>
<h2 id='mt_stack'>Combine multiple <code>move2</code> objects into one</h2><span id='topic+mt_stack'></span>

<h3>Description</h3>

<p>This function does a similar job to <code><a href="dplyr.html#topic+bind_rows">dplyr::bind_rows()</a></code>, when columns are missing of any of the
objects, they are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_stack(
  ...,
  .track_combine = c("check_unique", "merge", "merge_list", "rename"),
  .track_id_repair = c("unique", "universal", "unique_quiet", "universal_quiet")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_stack_+3A_...">...</code></td>
<td>
<p>Either a list of <code>move2</code> objects to combine or the objects to combine as separate arguments</p>
</td></tr>
<tr><td><code id="mt_stack_+3A_.track_combine">.track_combine</code></td>
<td>
<p>A character string indicating the way duplicated tracks should be resolved. By default (&quot;check_unique&quot;)
an error is raised if different objects contain tracks with the same name. With &quot;merge&quot; and &quot;merge_list&quot; tracks with the same name can be merged, and with &quot;rename&quot; non unique tracks can be renamed.</p>
</td></tr>
<tr><td><code id="mt_stack_+3A_.track_id_repair">.track_id_repair</code></td>
<td>
<p>The way in which names should be repaired when renaming is done, see <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>
for more details on each option</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An attempt is made to combine objects that have a different <code>track_id_column</code> or <code>time_column</code>, however this is
only done if it can be done without data loss.
</p>
<p>When objects are too different (e.g. different projection or different types of time columns that cannot
be combine) and error is raised.
When tracks have the same name in different objects to combine this will results in an error.
</p>
<p>When merging several tracks, the track attributes of these tracks are also combined.
For track data this can result in conflicts. With &quot;merge&quot; unique values are selected if not one unique value is present a warning is raised.
With &quot;merge_list&quot; a list column is created for each track attribute that can be summarized later.
</p>


<h3>Value</h3>

<p>An object of the class <code>move2</code>
</p>


<h3>See Also</h3>

<p>rbind
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- mt_sim_brownian_motion(1:2, tracks = c("a", "b"))
b &lt;- mt_sim_brownian_motion(1:2, tracks = c("g", "h"))
mt_stack(a, b)

## having different columns does not cause problems
a$extra_data &lt;- 1:nrow(a)
mt_stack(list(a, b))


## Combining different datasets works
fishers &lt;- mt_read(mt_example(), n_max = 100, col_select = c(
  "eobs:used-time-to-get-fix",
  "location-long", "location-lat", "timestamp", "individual-local-identifier"
))

## Objects to stack need to have the same CRS, use either st_set_crs
## or st_transform depending what is appropriate
random_track &lt;- mt_sim_brownian_motion(
  t = as.POSIXct("1970-1-1") + 1:3,
  tracks = factor(letters[1:2])
) |&gt; sf::st_set_crs(4326)
mt_time(random_track) &lt;- "timestamp"
mt_stack(
  random_track,
  fishers
)
track_1 &lt;- mt_sim_brownian_motion(tracks = letters[1:3], t = 1:3) |&gt;
  mutate_track_data(sex = "f")
track_2 &lt;- mt_sim_brownian_motion(tracks = letters[3:4], t = 4:6) |&gt;
  mutate_track_data(sex = c("f", "m"))
mt_stack(track_1, track_2,
  .track_combine = "merge_list"
)
mt_stack(track_1, track_2,
  .track_combine = "merge"
)

if (requireNamespace("units")) {
  males &lt;- tail(filter_track_data(
    fishers,
    grepl("M", `individual-local-identifier`)
  ), 5)
  females &lt;- filter_track_data(
    fishers,
    grepl("F", `individual-local-identifier`)
  )
  females$`eobs:used-time-to-get-fix` &lt;- units::set_units(
    females$`eobs:used-time-to-get-fix`,
    "hours"
  )
  females &lt;- tail(females, 5)
  ## combining with different units works correctly (units are unified with correct conversion)
  mt_stack(males, females)
}


</code></pre>

<hr>
<h2 id='mt_time'>Retrieve/replace timestamps or get the interval duration between locations</h2><span id='topic+mt_time'></span><span id='topic+mt_time+3C-'></span><span id='topic+mt_set_time'></span><span id='topic+mt_time_lags'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_time()</code> retrieve timestamps
</p>
</li>
<li> <p><code>mt_time(x) &lt;- value</code> and <code>mt_set_time(x, value)</code>  replace timestamps with new values, set new column to define time or rename time column
</p>
</li>
<li> <p><code>mt_time_lags()</code> returns time lags, i.e. duration interval between consecutive locations
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_time(x)

mt_time(x) &lt;- value

mt_set_time(x, value)

mt_time_lags(x, units)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_time_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_time_+3A_value">value</code></td>
<td>
<p>either a vector with new timestamps, the name of the new column to define time as a scalar character (this column must be present in the event table), or a scalar character to rename the time column.</p>
</td></tr>
<tr><td><code id="mt_time_+3A_units">units</code></td>
<td>
<p>Optional. Valid values are <code>character</code>, <code>symbolic_units</code> or <code>units</code>, for more details see the <code>value</code> argument of <a href="units.html#topic+units">units::as_units</a>. If no units are stated (default) the function flexibly determines the units to return. Fixing the units can be useful if specific return units are for example required for subsequent functions. This argument only takes effect if the initial return value already has units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time lags are calculated as the time difference to the next location.
</p>
<p>When calculating time lags between locations <code>NA</code> values are used for the transitions between tracks. This is
because the interval between the last location of the previous track and first of the next track do not make
sense.
</p>


<h3>Value</h3>

<p><code>mt_time()</code> returns a vector of timestamps, depending on the type of data these can be either <code>POSIXct</code>,
<code>date</code>or <code>numeric</code> <br />
<code>mt_time_lags()</code> returns a vector of the time lags as <code>numeric</code> or <code><a href="units.html#topic+units">units</a></code> depending on the type of data.
</p>


<h3>See Also</h3>

<p>Other track-measures: 
<code><a href="#topic+mt_azimuth">mt_azimuth</a>()</code>,
<code><a href="#topic+mt_distance">mt_distance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## in the simulated track, time is numeric, so the time lags are also numeric
x &lt;- mt_sim_brownian_motion(1:3)
x |&gt; mt_time()
x |&gt; mt_time_lags()

## here the simulated track has timestamps, so the time lags have units
x &lt;- mt_sim_brownian_motion(as.POSIXct((1:3) * 60^2, origin = "1970-1-1"), tracks = 1)
x |&gt; mt_time()
x |&gt; mt_time_lags()
x &lt;- mt_sim_brownian_motion(as.Date(1:3, "1990-1-1"), tracks = 2)
x |&gt; mt_time()
x |&gt; mt_time_lags()

## units of the time lags can also be transformed, e.g. from days to hours
tl &lt;- x |&gt; mt_time_lags()
units::set_units(tl, h)

x &lt;- mt_sim_brownian_motion(t = as.POSIXct(1:3, , origin = "1970-1-1"), tracks = 2)
## providing a vector with new timestamps
head(mt_time(x))
mt_time(x) &lt;- 1:nrow(x)
head(mt_time(x))

## renaming the column defining time
mt_time_column(x)
mt_time(x) &lt;- "my_new_time_name"
mt_time_column(x)

## setting a new column to define time
x$new_time &lt;- as.POSIXct(1:6, origin = "2020-1-1")
mt_time(x) &lt;- "new_time"
mt_time_column(x)
head(mt_time(x))
</code></pre>

<hr>
<h2 id='mt_time_column'>Get or set the name of the column containing the <code>track_id</code> and <code>time</code></h2><span id='topic+mt_time_column'></span><span id='topic+mt_track_id_column'></span><span id='topic+mt_set_time_column'></span><span id='topic+mt_set_track_id_column'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_time_column()</code> returns the name of the column containing the timestamps
</p>
</li>
<li> <p><code>mt_track_id_column()</code> returns the name of the column containing the track ids
</p>
</li>
<li> <p><code>mt_set_time_column()</code> set the column that should be used as time column
</p>
</li>
<li> <p><code>mt_set_track_id_column()</code> set the column that should be used as track id column (the column has to be present in event and track table)
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_time_column(x)

mt_track_id_column(x)

mt_set_time_column(x, value)

mt_set_track_id_column(x, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_time_column_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_time_column_+3A_value">value</code></td>
<td>
<p>a character string of the new column name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The set functions purely update the attribute containing the column name after checking the minimal requirements.
</p>
<p>For <code>mt_set_track_id_column()</code> the column has to be present in event and track table, if this is not the case consider using <code><a href="#topic+mt_track_id">mt_track_id()</a></code>.
</p>


<h3>Value</h3>

<p><code>mt_time_column</code> and <code>mt_track_id_column</code> return character string of the column name <br />
<code>mt_set_time_column</code> and <code>mt_set_track_id_column</code> return an updated <code>move2</code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mt_time">mt_time()</a></code> to retrieve or change timestamps from each record.<br />
<code><a href="#topic+mt_track_id">mt_track_id()</a></code> to retrieve or change the track id from each record.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## getting the column names
mt_sim_brownian_motion() |&gt; mt_time_column()
mt_sim_brownian_motion() |&gt; mt_track_id_column()

## setting 'time' to a new column
x &lt;- mt_sim_brownian_motion()
x$date &lt;- as.Date("2020-1-1") + x$time * 3
x |&gt; mt_time_lags()
x |&gt;
  mt_set_time_column("date") |&gt;
  mt_time_lags()
</code></pre>

<hr>
<h2 id='mt_track_data'>Setting and retrieving the track data in <code>move2</code> objects</h2><span id='topic+mt_track_data'></span><span id='topic+mt_set_track_data'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_track_data()</code> retrieve track attribute table
</p>
</li>
<li> <p><code>mt_set_track_data()</code> replace the attribute table
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_track_data(x)

mt_set_track_data(x, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_track_data_+3A_x">x</code></td>
<td>
<p>the <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_track_data_+3A_data">data</code></td>
<td>
<p>the new track data. This <code>data.frame</code> must contain the column
with the track ids, the column name must be the same as in the <code>move2</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mt_track_data</code> returns a data.frame containing the track attribute data.<br />
<code>mt_set_track_data</code> returns the <code>move2</code> object with updated track data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mt_sim_brownian_motion() |&gt;
  mutate_track_data(sex = c("f", "m")) |&gt;
  mt_track_data()
x &lt;- mt_sim_brownian_motion(1:2, tracks = letters[1:4])
mt_set_track_data(x, data.frame(track = letters[1:4], age = 2:5))
</code></pre>

<hr>
<h2 id='mt_track_id'>Retrieve the column with track ids or get the number of tracks</h2><span id='topic+mt_track_id'></span><span id='topic+mt_track_id+3C-'></span><span id='topic+mt_set_track_id'></span><span id='topic+mt_n_tracks'></span>

<h3>Description</h3>


<ul>
<li> <p><code>mt_track_id()</code> retrieve track ids
</p>
</li>
<li> <p><code>mt_track_id(x) &lt;- value</code> and <code>mt_set_track_id(x, value)</code>  replace track ids with new values, set new column to define tracks or rename track id column
</p>
</li>
<li> <p><code>mt_n_tracks()</code> returns the number of tracks
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>mt_track_id(x)

mt_track_id(x) &lt;- value

mt_set_track_id(x, value)

mt_n_tracks(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_track_id_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object</p>
</td></tr>
<tr><td><code id="mt_track_id_+3A_value">value</code></td>
<td>
<p>either a vector with new track id values, the name of the new column to define track ids as a scalar
character (this column must be present in either the event or track table), or a scalar character to rename the track
id column. IF <code>value</code> is <code>NULL</code> the move2 class is dropped and a object of the class <code>sf</code> is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector containing the new track ids must be of the same length as the event table.
</p>
<p>To set a new column defining the track ids, this column has to be present in
the event table. See examples.
</p>
<p>When changing the track ids with new values that results in the combination
of several tracks, the track attributes of these tracks are also combined.
This is done by creating a lists within each column. See examples.
</p>


<h3>Value</h3>

<p><code>mt_track_id</code> returns a vector of the length of the number of locations that indicated the points belonging to one track. <br />
<code>mt_n_tracks</code> returns the number of tracks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- mt_read(mt_example())
mt_n_tracks(x)
unique(mt_track_id(x))
mt_track_id(x) |&gt; table()
x &lt;- mt_sim_brownian_motion(t = 1:10, tracks = 2) |&gt;
  dplyr::mutate(attrib_evnt = gl(4, 5, labels = c("XX", "YY", "TT", "ZZ"))) |&gt;
  mutate_track_data(attrib_trk = c("a", "b"))

## providing a vector with new track ids
unique(mt_track_id(x))
mt_track_id(x) &lt;- c(rep("track_1", 10), rep("track_2", 10))
unique(mt_track_id(x))

## renaming the track id column
mt_track_id_column(x)
mt_track_id(x) &lt;- "my_new_track_name"
mt_track_id_column(x)

## setting a new column to define track ids
## 1. when this column is present in the track table it has to be
## moved to the event table
names(mt_track_data(x))
x &lt;- mt_as_event_attribute(x, "attrib_trk")
mt_track_id(x) &lt;- "attrib_trk"
mt_track_id_column(x)
unique(mt_track_id(x))

## 2. using an existing column in the event table
mt_track_id(x) &lt;- "attrib_evnt"
mt_track_id_column(x)
unique(mt_track_id(x))

## example of track data attributes being combined
m &lt;- mt_sim_brownian_motion(1:3, tracks = letters[5:8]) |&gt;
  mutate_track_data(sex = c("f", "f", "m", "m"), age = c(4, 4, 5, 6), old_track = track)
new_m &lt;- m |&gt; mt_set_track_id(c(rep("a", 6), rep("b", 6)))
mt_track_data(new_m)
</code></pre>

<hr>
<h2 id='mt_track_lines'>Convert trajectories into lines</h2><span id='topic+mt_track_lines'></span>

<h3>Description</h3>

<p>Converts each track into one line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mt_track_lines(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mt_track_lines_+3A_x">x</code></td>
<td>
<p>A move object</p>
</td></tr>
<tr><td><code id="mt_track_lines_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <a href="dplyr.html#topic+summarise">summarise</a> function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all empty points are removed before summarizing. Arguments passed with <code>...</code> thus only summarize for the
non empty locations.
</p>


<h3>Value</h3>

<p>A <a href="sf.html#topic+sf">sf::sf</a> object with a <code>LINESTRING</code> representing the track as geometry for each track. The
<code>track_data</code> for each track is included as well as the products from summarize
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+mt_segments">mt_segments()</a></code> For transforming all segments to a <code>LINESTRING</code> separately
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mt_sim_brownian_motion() |&gt;
  mt_track_lines(
    n = dplyr::n(),
    minTime = min(time),
    maxTime = max(time)
  )
## empty points are not counted in summary statistic
x &lt;- mt_sim_brownian_motion(1:3)
x$geometry[[2]] &lt;- sf::st_point()
x |&gt; mt_track_lines(
  n = dplyr::n()
)
## plot of the tracks as a line
mt_sim_brownian_motion(
  tracks = letters[1:2],
  start_location = list(c(0, 0), c(10, 0))
) |&gt;
  mt_track_lines() |&gt;
  plot()

</code></pre>

<hr>
<h2 id='to_move'>Convert a move2 object to a move object</h2><span id='topic+to_move'></span>

<h3>Description</h3>

<p>Convert a move2 object to a move object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_move(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_move_+3A_x">x</code></td>
<td>
<p>a <code>move2</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the individuals are ordered as they occur in the event data in the created
<code><a href="move.html#topic+MoveStack-class">MoveStack-class</a></code> object as the order needs to correspond there between the event and track data
for <code>move</code>.
</p>


<h3>Value</h3>

<p>an object of the class <code>Move</code>/<code>MoveStack</code>
</p>
<p><code>to_move</code> converts back to a objects from the <code>move</code> package. When multiple individuals are provided a
<code><a href="move.html#topic+MoveStack-class">MoveStack-class</a></code> is created otherwise a <code><a href="move.html#topic+Move-class">Move-class</a></code> object.
</p>


<h3>See Also</h3>

<p>Other move2-convert: 
<code><a href="#topic+mt_as_move2">mt_as_move2</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("move")) {
  data(leroy, package = "move")
  leroy_move2 &lt;- mt_as_move2(leroy)
  to_move(leroy_move2)
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
