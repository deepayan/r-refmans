<!DOCTYPE html><html lang="en"><head><title>Help for package starvars</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {starvars}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coef.VLSTAR'><p>Coefficient method for objects of class VLSTAR</p></a></li>
<li><a href='#logLik.VLSTAR'><p>Log-Likelihood method</p></a></li>
<li><a href='#loglike'><p>Multivariate log-likelihood</p></a></li>
<li><a href='#lrvarbart'><p>Long-run variance using Bartlett kernel</p></a></li>
<li><a href='#multiCUMSUM'><p>Multivariate CUMSUM test</p></a></li>
<li><a href='#plot.VLSTAR'><p>Plot methods for a VLSTAR object</p></a></li>
<li><a href='#plot.vlstarpred'><p>Plot methods for a vlstarpred object</p></a></li>
<li><a href='#predict.VLSTAR'><p>VLSTAR Prediction</p></a></li>
<li><a href='#print.VLSTAR'><p>Print method for objects of class VLSTAR</p></a></li>
<li><a href='#rcov'><p>Realized Covariance</p></a></li>
<li><a href='#Realized'>
<p>Monthly time series used to test VLSTAR models.</p></a></li>
<li><a href='#Sample5minutes'>
<p>Ten simulated prices series for 19 trading days in January 2010.</p></a></li>
<li><a href='#SSQ'><p>Sum of squared error</p></a></li>
<li><a href='#startingVLSTAR'><p>Starting parameters for a VLSTAR model</p></a></li>
<li><a href='#summary.VLSTAR'><p>Summary method for objects of class VLSTAR</p></a></li>
<li><a href='#techprices'>
<p>Daily closing prices of 3 tech stocks.</p></a></li>
<li><a href='#VLSTAR'><p>VLSTAR- Estimation</p></a></li>
<li><a href='#VLSTARjoint'><p>Joint linearity test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Vector Logistic Smooth Transition Models Estimation and
Prediction</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.10</td>
</tr>
<tr>
<td>Description:</td>
<td>Allows the user to estimate a vector logistic smooth transition autoregressive model via maximum log-likelihood or nonlinear least squares. It further permits to test for linearity in the multivariate framework against a vector logistic smooth transition autoregressive model with a single transition variable. The estimation method is discussed in Terasvirta and Yang (2014, &lt;<a href="https://doi.org/10.1108%2FS0731-9053%282013%290000031008">doi:10.1108/S0731-9053(2013)0000031008</a>&gt;). Also, realized covariances can be constructed from stock market prices or returns, as explained in Andersen et al. (2001, &lt;<a href="https://doi.org/10.1016%2FS0304-405X%2801%2900055-1">doi:10.1016/S0304-405X(01)00055-1</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, ks, zoo, doSNOW, foreach, methods, matrixcalc,
optimParallel, parallel, vars, xts, lessR, quantmod</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/andbucci/starvars">https://github.com/andbucci/starvars</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-17 17:04:50 UTC; andre</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrea Bucci [aut, cre, cph],
  Giulio Palomba [aut],
  Eduardo Rossi [aut],
  Andrea Faragalli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrea Bucci &lt;andrea.bucci@unich.it&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-17 21:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coef.VLSTAR'>Coefficient method for objects of class VLSTAR</h2><span id='topic+coef.VLSTAR'></span><span id='topic+coef'></span><span id='topic+coefficients'></span>

<h3>Description</h3>

<p>Returns the coefficients of a VLSTAR model for objects generated by <code>VLSTAR()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.VLSTAR_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo;; generated by <code>VLSTAR()</code>.</p>
</td></tr>
<tr><td><code id="coef.VLSTAR_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Estimated coefficients of the VLSTAR model
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition
Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean(1:3)
</code></pre>

<hr>
<h2 id='logLik.VLSTAR'>Log-Likelihood method</h2><span id='topic+logLik.VLSTAR'></span><span id='topic+logLik'></span>

<h3>Description</h3>

<p>Returns the log-Likelihood of a VLSTAR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
logLik(object, type = c('Univariate', 'Multivariate'), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.VLSTAR_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo; obtained through <code>VLSTAR()</code>.</p>
</td></tr>
<tr><td><code id="logLik.VLSTAR_+3A_type">type</code></td>
<td>
<p>Type of Log-Likelihood to be showed (univariate or multivariate).</p>
</td></tr>
<tr><td><code id="logLik.VLSTAR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The log-likelihood of a VLSTAR model is defined as: </p>
<p style="text-align: center;"><code class="reqn">\log l(y_t|I_t;\theta)=-\frac{T\tilde{n}}{2}\ln(2\pi)-\frac{T}{2}\ln|\Omega|-\frac{1}{2}\sum_{t=1}^{T}(y_t-\tilde{G}_tB\,z_t)'\Omega^{-1}(y_t-\tilde{G}_tB\,z_t)</code>
</p>



<h3>Value</h3>

<p>An object with class attribute <code>logLik</code>.
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code>
</p>

<hr>
<h2 id='loglike'>Multivariate log-likelihood</h2><span id='topic+loglike'></span>

<h3>Description</h3>

<p>Log-likelihood to be optimized in the ML method and used to check convergence in both methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglike(param, data)
</code></pre>

<hr>
<h2 id='lrvarbart'>Long-run variance using Bartlett kernel</h2><span id='topic+lrvarbart'></span>

<h3>Description</h3>

<p>Function returns the long-run variance of a time series, relying on the Bartlett kernel.
The window size of the kernel is the cube root of the sample size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrvarbart(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrvarbart_+3A_x">x</code></td>
<td>
<p>a <code>(T x 1)</code> vector containing the time series over period <code>T</code></p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lrv</code></td>
<td>
<p>long-run variance</p>
</td></tr>
<tr><td><code>return</code></td>
<td>
<p>bandwidth size of the window</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Hamilton J. D. (1994), Time Series Analysis. <em>Princeton University Press</em>; Tsay R.S. (2005), Analysis of Financial Time Series. <em>John Wiley &amp; SONS</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Realized)
lrvarbart(Realized[,1])

</code></pre>

<hr>
<h2 id='multiCUMSUM'>Multivariate CUMSUM test</h2><span id='topic+multiCUMSUM'></span><span id='topic+print.multiCUMSUM'></span>

<h3>Description</h3>

<p>Function returns the test statistics for the presence of co-breaks in a set of multivariate time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiCUMSUM(data, conf.level = 0.95, max.breaks = 7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="multiCUMSUM_+3A_data">data</code></td>
<td>
<p>a <code>(T x N)</code> <code>matrix</code> or <code>data.frame</code> containing the <code>N</code> time series over period <code>T</code></p>
</td></tr>
<tr><td><code id="multiCUMSUM_+3A_conf.level">conf.level</code></td>
<td>
<p>Confidence level. By default set to 0.95</p>
</td></tr>
<tr><td><code id="multiCUMSUM_+3A_max.breaks">max.breaks</code></td>
<td>
<p>Integer, determines the highest number of common breaks from 1 to 7.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Lambda Test statistics</code></td>
<td>
<p>a matrix of test statistics on the presence of a number of co-break equal to <code>max.breaks</code> in the conditional mean</p>
</td></tr>
<tr><td><code>Omega Test statistics</code></td>
<td>
<p>a matrix of test statistics on the presence of a number of co-break equal to <code>max.breaks</code> in the conditional variance</p>
</td></tr>
<tr><td><code>Break location</code></td>
<td>
<p>the index and the Date where the common breaks are located</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Bucci and Giulio Palomba
</p>


<h3>References</h3>

<p>Aue A., Hormann S., Horvath  L.and Reimherr M. (2009), Break detection in the covariance structure of multivariate time series models. <em>The Annals of Statistics</em>. 37: 4046-4087
Bai J., Lumsdaine R. L. and Stock J. H. (1998), Testing For and Dating Common Breaks in Multivariate Time Series. <em>Review of Economic Studies</em>. 65: 395-432
Barassi M., Horvath L. and Yuqian Z. (2018), Change-Point Detection in the Conditional Correlation Structure of Multivariate Volatility Models. <em>Journal of Business \&amp; Economic Statistics</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Realized)
testCS &lt;- multiCUMSUM(Realized[,1:10], conf.level = 0.95)
print(testCS)
</code></pre>

<hr>
<h2 id='plot.VLSTAR'>Plot methods for a VLSTAR object</h2><span id='topic+plot.VLSTAR'></span>

<h3>Description</h3>

<p>Plot method for objects with class attribute <code>VLSTAR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
plot(
  x,
  names = NULL,
  main.fit = NULL,
  main.acf = NULL,
  main.pacf = NULL,
  main.logi = NULL,
  ylim.fit = NULL,
  ylim.resid = NULL,
  lty.fit = NULL,
  lty.resid = NULL,
  lty.logi = NULL,
  lwd.fit = NULL,
  lwd.resid = NULL,
  lwd.logi = NULL,
  lag.acf = NULL,
  lag.pacf = NULL,
  col.fit = NULL,
  col.resid = NULL,
  col.logi = NULL,
  ylab.fit = NULL,
  ylab.resid = NULL,
  ylab.acf = NULL,
  ylab.pacf = NULL,
  ylab.logi = NULL,
  xlab.fit = NULL,
  xlab.resid = NULL,
  xlab.logi = NULL,
  mar = par("mar"),
  oma = par("oma"),
  adj.mtext = NA,
  padj.mtext = NA,
  col.mtext = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.VLSTAR_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_names">names</code></td>
<td>
<p>Character vector, the variables names to be plotted. If left <code>NULL</code>, all variables are plotted.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_main.fit">main.fit</code></td>
<td>
<p>Character vector, main for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_main.acf">main.acf</code></td>
<td>
<p>Character vector, main for residuals' ACF.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_main.pacf">main.pacf</code></td>
<td>
<p>Character vector, main for residuals' PACF.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_main.logi">main.logi</code></td>
<td>
<p>Character vector, main for the plot of the logistic function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylim.fit">ylim.fit</code></td>
<td>
<p>Vector, ylim for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylim.resid">ylim.resid</code></td>
<td>
<p>Vector, ylim for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lty.fit">lty.fit</code></td>
<td>
<p>Vector, lty for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lty.resid">lty.resid</code></td>
<td>
<p>Vector, lty for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lty.logi">lty.logi</code></td>
<td>
<p>Vector, lty for the plot of the logistic function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lwd.fit">lwd.fit</code></td>
<td>
<p>Vector, lwd for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lwd.resid">lwd.resid</code></td>
<td>
<p>Vector, lwd for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lwd.logi">lwd.logi</code></td>
<td>
<p>Vector, lwd for the plot of the logistic function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lag.acf">lag.acf</code></td>
<td>
<p>Integer, lag.max for ACF of residuals.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_lag.pacf">lag.pacf</code></td>
<td>
<p>Integer, lag.max for PACF of residuals.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_col.fit">col.fit</code></td>
<td>
<p>Character vector, colors for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_col.resid">col.resid</code></td>
<td>
<p>Character vector, colors for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_col.logi">col.logi</code></td>
<td>
<p>Character vector, colors for logistic function plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab.fit">ylab.fit</code></td>
<td>
<p>Character vector, ylab for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab.resid">ylab.resid</code></td>
<td>
<p>Character vector, ylab for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab.acf">ylab.acf</code></td>
<td>
<p>Character, ylab for ACF.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab.pacf">ylab.pacf</code></td>
<td>
<p>Character, ylab for PACF</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab.logi">ylab.logi</code></td>
<td>
<p>Character vector, ylab for the plot of the logistic function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_xlab.fit">xlab.fit</code></td>
<td>
<p>Character vector, xlab for diagram of fit.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_xlab.resid">xlab.resid</code></td>
<td>
<p>Character vector, xlab for residual plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_xlab.logi">xlab.logi</code></td>
<td>
<p>Character vector, xlab for the plot of the logistic function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_mar">mar</code></td>
<td>
<p>Setting of margins.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_oma">oma</code></td>
<td>
<p>Setting of outer margins.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_adj.mtext">adj.mtext</code></td>
<td>
<p>Adjustment for <code>mtext()</code>.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_padj.mtext">padj.mtext</code></td>
<td>
<p>Adjustment for <code>mtext()</code>.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_col.mtext">col.mtext</code></td>
<td>
<p>Character, color for <code>mtext()</code>, only applicable.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_...">...</code></td>
<td>
<p>Passed to internal plot function.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_main">main</code></td>
<td>
<p>Character vector, the titles of the plot.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_xlab">xlab</code></td>
<td>
<p>Character vector signifying the labels for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylab">ylab</code></td>
<td>
<p>Character vector signifying the labels for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.VLSTAR_+3A_ylim">ylim</code></td>
<td>
<p>Vector, the limits of the y-axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the <code>plot</code> function is applied to a <code>VLSTAR</code> object, the values of the logistic function, given the estimated values of gamma and c through <code>VLSTAR</code>, are reported.
</p>


<h3>Value</h3>

<p>Plot of VLSTAR fitted values, residuals, ACF, PACF and logistic function
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code>
</p>

<hr>
<h2 id='plot.vlstarpred'>Plot methods for a vlstarpred object</h2><span id='topic+plot.vlstarpred'></span>

<h3>Description</h3>

<p>Plot method for objects with class attribute <code>vlstarpred</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vlstarpred'
plot(
  x,
  type = c("single", "multiple"),
  names = NULL,
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  lty.obs = 2,
  lty.pred = 1,
  lty.ci = 3,
  lty.vline = 1,
  lwd.obs = 1,
  lwd.pred = 1,
  lwd.ci = 1,
  lwd.vline = 1,
  col.obs = NULL,
  col.pred = NULL,
  col.ci = NULL,
  col.vline = NULL,
  ylim = NULL,
  mar = par("mar"),
  oma = par("oma"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.vlstarpred_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>vlstarpred</code>&rsquo;.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_type">type</code></td>
<td>
<p>Character, if <code>multiple</code> all plots are drawn in a single device, otherwise the plots are shown consecutively.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_names">names</code></td>
<td>
<p>Character vector, the variables names to be plotted. If left <code>NULL</code>, all variables are plotted.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_main">main</code></td>
<td>
<p>Character vector, the titles of the plot.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_xlab">xlab</code></td>
<td>
<p>Character vector signifying the labels for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_ylab">ylab</code></td>
<td>
<p>Character vector signifying the labels for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lty.obs">lty.obs</code></td>
<td>
<p>Vector, lty for the plot of the observed values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lty.pred">lty.pred</code></td>
<td>
<p>Vector, lty for the plot of the predicted values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lty.ci">lty.ci</code></td>
<td>
<p>Vector, lty for the interval forecast.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lty.vline">lty.vline</code></td>
<td>
<p>Vector, lty for the vertical line.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lwd.obs">lwd.obs</code></td>
<td>
<p>Vector, lwd for the plot of the observed values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lwd.pred">lwd.pred</code></td>
<td>
<p>Vector, lwd for the plot of the predicted values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lwd.ci">lwd.ci</code></td>
<td>
<p>Vector, lwd for the interval forecast.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_lwd.vline">lwd.vline</code></td>
<td>
<p>Vector, lwd for the vertical line.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_col.obs">col.obs</code></td>
<td>
<p>Character vector, colors for the observed values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_col.pred">col.pred</code></td>
<td>
<p>Character vector, colors for the predicted values.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_col.ci">col.ci</code></td>
<td>
<p>Character vector, colors for the interval forecast.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_col.vline">col.vline</code></td>
<td>
<p>Character vector, colors for the vertical line.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_ylim">ylim</code></td>
<td>
<p>Vector, the limits of the y-axis.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_mar">mar</code></td>
<td>
<p>Setting of margins.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_oma">oma</code></td>
<td>
<p>Setting of outer margins.</p>
</td></tr>
<tr><td><code id="plot.vlstarpred_+3A_...">...</code></td>
<td>
<p>Passed to internal plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot of predictions from VLSTAR with their prediction interval
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.VLSTAR">predict.VLSTAR</a></code>
</p>

<hr>
<h2 id='predict.VLSTAR'>VLSTAR Prediction</h2><span id='topic+predict.VLSTAR'></span><span id='topic+predict'></span><span id='topic+print.vlstarpred'></span>

<h3>Description</h3>

<p>One-step or multi-step ahead forecasts, with interval forecast, of a VLSTAR object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
predict(
  object,
  ...,
  n.ahead = 1,
  conf.lev = 0.95,
  st.new = NULL,
  M = 5000,
  B = 1000,
  st.num = NULL,
  newdata = NULL,
  method = c("naive", "Monte Carlo", "bootstrap")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.VLSTAR_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo; obtained through <code>VLSTAR()</code></p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_n.ahead">n.ahead</code></td>
<td>
<p>An integer specifying the number of ahead predictions</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_conf.lev">conf.lev</code></td>
<td>
<p>Confidence level of the interval forecast</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_st.new">st.new</code></td>
<td>
<p>Vector of new data for the transition variable</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_m">M</code></td>
<td>
<p>An integer with the number of errors sampled for the <code>Monte Carlo</code> method</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_b">B</code></td>
<td>
<p>An integer with the number of errors sampled for the <code>bootstrap</code> method</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_st.num">st.num</code></td>
<td>
<p>An integer with the index of dependent variable if <code>st.new</code> is <code>NULL</code>
and the transition variable is a lag of one of the dependent variables</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_newdata">newdata</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> of new data for the exogenous variables</p>
</td></tr>
<tr><td><code id="predict.VLSTAR_+3A_method">method</code></td>
<td>
<p>A character identifying which multi-step ahead method should be used among <code>naive</code>, <code>Monte Carlo</code> and <code>bootstrap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>
<table role = "presentation">
<tr><td><code>forecasts</code></td>
<td>
<p><code>data.frame</code> of predictions for each dependent variable and the (1-<code class="reqn">\alpha</code>) prediction intervals</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>a matrix of values for y</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Bucci and Eduardo Rossi
</p>


<h3>References</h3>

<p>Granger C.W.J. and Terasvirta T. (1993), Modelling Non-Linear Economic Relationships. <em>Oxford University Press</em>;
</p>
<p>Lundbergh S. and Terasvirta T. (2007), Forecasting with Smooth Transition Autoregressive Models. <em>John Wiley and Sons</em>;
</p>
<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code> for log-likehood and nonlinear least squares estimation of the VLSTAR model.
</p>

<hr>
<h2 id='print.VLSTAR'>Print method for objects of class VLSTAR</h2><span id='topic+print.VLSTAR'></span><span id='topic+print'></span>

<h3>Description</h3>

<p>&lsquo;<code>print</code>&rsquo; methods for class &lsquo;<code>VLSTAR</code>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.VLSTAR_+3A_x">x</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo; obtained through <code>VLSTAR()</code>.</p>
</td></tr>
<tr><td><code id="print.VLSTAR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print of VLSTAR results
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code>
</p>

<hr>
<h2 id='rcov'>Realized Covariance</h2><span id='topic+rcov'></span>

<h3>Description</h3>

<p>Function returns the vectorization of the lowest triangular of the Realized Covariance matrices for different frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcov(
  data,
  freq = c("daily", "monthly", "quarterly", "yearly"),
  make.ret = TRUE,
  cholesky = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rcov_+3A_data">data</code></td>
<td>
<p>a <code>(T x N)</code> <code>xts</code> object containing the <code>N</code> price/return series over period <code>T</code></p>
</td></tr>
<tr><td><code id="rcov_+3A_freq">freq</code></td>
<td>
<p>a string defining the desired frequency for the Realized Covariance matrices between &quot;daily&quot;, &quot;monthly&quot;, &quot;quarterly&quot; or &quot;yearly&quot;</p>
</td></tr>
<tr><td><code id="rcov_+3A_make.ret">make.ret</code></td>
<td>
<p>boolean, in case it is <code>TRUE</code> the data are converted in returns, <code>FALSE</code> otherwise</p>
</td></tr>
<tr><td><code id="rcov_+3A_cholesky">cholesky</code></td>
<td>
<p>boolean, in case it is <code>TRUE</code> the Cholesky factors of the Realized Covariance matrices are calculated, <code>FALSE</code> by default</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Realized Covariances</code></td>
<td>
<p>a <code class="reqn">M \times N(N+1)/2</code> matrix of realized covariances, where <em>M</em> is the number of lower frequency data</p>
</td></tr>
<tr><td><code>Cholesky Factors (optional)</code></td>
<td>
<p>a <code class="reqn">M \times N(N+1)/2</code> matrix of Cholesky factors of the realized
covariance matrices, where <em>M</em> is the number of lower frequency data</p>
</td></tr>
<tr><td><code>returns (optional)</code></td>
<td>
<p>a <code class="reqn">T \times N</code> matrix of returns, when <code>make.ret = TRUE</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Andersen T.G., Bollerslev T., Diebold F.X. and Labys P. (2003), Modeling and Forecasting Realized Volatility. <em>Econometrica</em>. 71: 579-625
</p>
<p>Barndorff-Nielsen O.E. and Shephard  N. (2002), Econometric analysis of realised volatility and its use in estimating stochastic volatility models <em>Journal of the Royal Statistical Society</em>. 64(2): 253-280
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Sample5minutes)
rc &lt;- rcov(Sample5minutes, freq = 'daily', cholesky = TRUE, make.ret = TRUE)
print(rc)

</code></pre>

<hr>
<h2 id='Realized'>
Monthly time series used to test VLSTAR models.
</h2><span id='topic+Realized'></span>

<h3>Description</h3>

<p>This data set contains the series of realized covariances in 4 stock market indices, i.e. SP-500, Nikkei, DAX, and FTSE, Dividend Yield and Earning Price growth rate, inflation growth rates for U.S., U.K., Japan and Germany, from August 1990 to June 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(Realized)
</code></pre>


<h3>Format</h3>

<p>A zoo data frame with 334 monthly observations,
ranging from 1990:M8 until 2018:M6.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>SP</code> </td><td style="text-align: left;"> Monthly realized variances of S&amp;P 500 index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>SP-NIKKEI</code> </td><td style="text-align: left;"> Monthly realized covariances between S&amp;P 500 and Nikkei. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>SP-FTSE</code> </td><td style="text-align: left;"> Monthly realized covariances between S&amp;P 500 and FTSE. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>SP-DAX</code> </td><td style="text-align: left;"> Monthly realized covariances between S&amp;P 500 and DAX. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>NIKKEI</code> </td><td style="text-align: left;"> Monthly realized variances of Nikkei index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>NIKKEI-FTSE</code> </td><td style="text-align: left;"> Monthly realized covariances between Nikkei and FTSE. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>NIKKEI-DAX</code> </td><td style="text-align: left;"> Monthly realized covariances between Nikkei and DAX. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>FTSE</code> </td><td style="text-align: left;"> Monthly realized variances of FTSE index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>FTSE-DAX</code> </td><td style="text-align: left;"> Monthly realized covariances between FTSE and DAX. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>DAX</code> </td><td style="text-align: left;"> Monthly realized variances of DAX index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>DP</code> </td><td style="text-align: left;"> Monthly Dividends growth rate over the past year relative to current market prices; S&amp;P 500 index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>EP</code> </td><td style="text-align: left;"> Monthly Earnings growth rate over the past year relative to current market prices; S&amp;P500 index. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Inf_US</code> </td><td style="text-align: left;"> US monthly Industrial Production growth. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Inf_UK</code> </td><td style="text-align: left;"> UK monthly Industrial Production growth. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Inf_JPN</code> </td><td style="text-align: left;"> Japan monthly Industrial Production growth. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Inf_GER</code> </td><td style="text-align: left;"> Germany monthly Industrial Production growth. </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rcov">rcov</a></code> to build realized covariances from stock prices or returns.
</p>

<hr>
<h2 id='Sample5minutes'>
Ten simulated prices series for 19 trading days in January 2010.
</h2><span id='topic+Sample5minutes'></span>

<h3>Description</h3>

<p>Ten hypothetical price series were simulated according to the factor diffusion process discussed in Barndorff-Nielsen et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Sample5minutes")
</code></pre>


<h3>Format</h3>

<p><code>xts</code> object
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>

<hr>
<h2 id='SSQ'>Sum of squared error</h2><span id='topic+SSQ'></span>

<h3>Description</h3>

<p>Sum of squared error to be optimized in the NLS method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSQ(param, data)
</code></pre>

<hr>
<h2 id='startingVLSTAR'>Starting parameters for a VLSTAR model</h2><span id='topic+startingVLSTAR'></span>

<h3>Description</h3>

<p>This function allows the user to obtain the set of starting values of Gamma and C for the convergence algorithm via searching grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>startingVLSTAR(
  y,
  exo = NULL,
  p = 1,
  m = 2,
  st = NULL,
  constant = TRUE,
  n.combi = NULL,
  ncores = 2,
  singlecgamma = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="startingVLSTAR_+3A_y">y</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> of dependent variables of dimension <code>(Txn)</code></p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_exo">exo</code></td>
<td>
<p>(optional) <code>data.frame</code> or <code>matrix</code> of exogenous variables of dimension <code>(Txk)</code></p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_p">p</code></td>
<td>
<p>lag order</p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_m">m</code></td>
<td>
<p>number of regimes</p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_st">st</code></td>
<td>
<p>single transition variable for all the equation of dimension <code>(Tx1)</code></p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_constant">constant</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to include or not the constant</p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_n.combi">n.combi</code></td>
<td>
<p>Number of combination for the searching grid of Gamma and C</p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallel computation. Set to 2 by default</p>
</td></tr>
<tr><td><code id="startingVLSTAR_+3A_singlecgamma">singlecgamma</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to use single gamma and c</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The searching grid algorithm allows for the optimal choice of the parameters <code class="reqn">\gamma</code> and c by minimizing the sum of the Squared residuals for each possible combination.
</p>
<p>The parameter c is initialized by using the mean of the dependent(s) variable, while <code class="reqn">\gamma</code> is sampled between 0 and 100.
</p>


<h3>Value</h3>

<p>An object of class <code>startingVLSTAR</code>.
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Anderson H.M. and Vahid F. (1998), Testing multiple equation systems for common nonlinear components. <em>Journal of Econometrics</em>. 84: 1-36
</p>
<p>Bacon D.W. and Watts D.G. (1971), Estimating the transition between two intersecting straight lines. <em>Biometrika</em>. 58: 525-534
</p>
<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Realized)
y &lt;- Realized[-1,1:10]
y &lt;- y[-nrow(y),]
st &lt;- Realized[-nrow(Realized),1]
st &lt;- st[-length(st)]
starting &lt;- startingVLSTAR(y, p = 1, n.combi = 3,
                           singlecgamma = FALSE, st = st,
                           ncores = 1)
</code></pre>

<hr>
<h2 id='summary.VLSTAR'>Summary method for objects of class VLSTAR</h2><span id='topic+summary.VLSTAR'></span><span id='topic+summary'></span><span id='topic+print.summary.VLSTAR'></span><span id='topic+print.summary'></span>

<h3>Description</h3>

<p>&lsquo;<code>summary</code>&rsquo; methods for class &lsquo;<code>VLSTAR</code>&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'VLSTAR'
summary(object, ...)

## S3 method for class 'summary.VLSTAR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.VLSTAR_+3A_object">object</code></td>
<td>
<p>An object of class &lsquo;<code>VLSTAR</code>&rsquo; obtained through <code>VLSTAR()</code>.</p>
</td></tr>
<tr><td><code id="summary.VLSTAR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to and from other methods</p>
</td></tr>
<tr><td><code id="summary.VLSTAR_+3A_x">x</code></td>
<td>
<p>A summary object of class &lsquo;<code>VLSTAR</code>&rsquo; obtained through <code>summary()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.VLSTAR</code> containing a list of summary information from VLSTAR estimates. When <code>print</code> is applied to this object, summary information are printed
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>print.summary.VLSTAR</code>: Print of the summary
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VLSTAR">VLSTAR</a></code>
</p>

<hr>
<h2 id='techprices'>
Daily closing prices of 3 tech stocks.
</h2><span id='topic+techprices'></span>

<h3>Description</h3>

<p>This data set contains the series of daily prices of Google, Microsof and Amazon stocks from January 3, 2005 to June 16, 2020, gathered from Yahoo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("techprices")
</code></pre>


<h3>Format</h3>

<p>An <code>xts</code> object with 3890 daily observations,
ranging from from January 3, 2005 to June 16, 2020.
</p>

<table>
<tr>
 <td style="text-align: right;">
    <code>Google</code> </td><td style="text-align: left;"> daily closing prices of Google (GOOG) stock. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Microsoft</code> </td><td style="text-align: left;"> daily closing prices of Microsoft (MSFT) stock. </td>
</tr>
<tr>
 <td style="text-align: right;">
    <code>Amazon</code> </td><td style="text-align: left;"> daily closing stock prices of Amazon (AMZN) stock. </td>
</tr>
<tr>
 <td style="text-align: right;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Andrea Bucci
</p>

<hr>
<h2 id='VLSTAR'>VLSTAR- Estimation</h2><span id='topic+VLSTAR'></span>

<h3>Description</h3>

<p>This function allows the user to estimate the coefficients of a VLSTAR model with <em>m</em> regimes through maximum likelihood or nonlinear least squares.
The set of starting values of Gamma and C for the convergence algorithm can be either passed or obtained via searching grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VLSTAR(
  y,
  exo = NULL,
  p = 1,
  m = 2,
  st = NULL,
  constant = TRUE,
  starting = NULL,
  method = c("ML", "NLS"),
  n.iter = 500,
  singlecgamma = FALSE,
  epsilon = 10^(-3),
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VLSTAR_+3A_y">y</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> of dependent variables of dimension <code>(Txn)</code></p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_exo">exo</code></td>
<td>
<p>(optional) <code>data.frame</code> or <code>matrix</code> of exogenous variables of dimension <code>(Txk)</code></p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_p">p</code></td>
<td>
<p>lag order</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_m">m</code></td>
<td>
<p>number of regimes</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_st">st</code></td>
<td>
<p>single transition variable for all the equation of dimension <code>(Tx1)</code></p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_constant">constant</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to include or not the constant</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_starting">starting</code></td>
<td>
<p>set of intial values for Gamma and C, inserted as a list of length <code>m-1</code>.
Each element of the list should contain a <code>data.frame</code> with 2 columns (one for Gamma and one for c), and <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_method">method</code></td>
<td>
<p>Fitting method: maximum likelihood or nonlinear least squares.</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_n.iter">n.iter</code></td>
<td>
<p>number of iteration of the algorithm until forced convergence</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_singlecgamma">singlecgamma</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> to use single gamma and c</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_epsilon">epsilon</code></td>
<td>
<p>convergence check measure</p>
</td></tr>
<tr><td><code id="VLSTAR_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used for parallel computation. Set to <code>NULL</code> by default and automatically calculated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate smooth transition model is an extension of the smooth transition regression model introduced by Bacon and Watts (1971)  (see also Anderson and Vahid, 1998). The general model is
</p>
<p style="text-align: center;"><code class="reqn">y_{t} = \mu_0+\sum_{j=1}^{p}\Phi_{0,j}\,y_{t-j}+A_0 x_t \cdot G_t(s_t;\gamma,c)[\mu_{1}+\sum_{j=1}^{p}\Phi_{1,j}\,y_{t-j}+A_1x_t]+\varepsilon_t</code>
</p>

<p>where <code class="reqn">\mu_{0}</code> and <code class="reqn">\mu_{1}</code> are the <code class="reqn">\tilde{n} \times 1</code> vectors of intercepts, <code class="reqn">\Phi_{0,j}</code> and <code class="reqn">\Phi_{1,j}</code> are square
<code class="reqn">\tilde{n}\times\tilde{n}</code> matrices of parameters for lags <code class="reqn">j=1,2,\dots,p</code>, A_0 and A_1 are <code class="reqn">\tilde{n}\times k</code> matrices of parameters,
x_t is the <code class="reqn">k \times 1</code> vector of exogenous variables and <code class="reqn">\varepsilon_t</code> is the innovation. Finally, <code class="reqn">G_t(s_t;\gamma,c)</code> is a <code class="reqn">\tilde{n}\times \tilde{n}</code> diagonal matrix of transition function at time <em>t</em>, such that
</p>
<p style="text-align: center;"><code class="reqn">G_t(s_t;\gamma,c)=\{G_{1,t}(s_{1,t};\gamma_{1},c_{1}),G_{2,t}(s_{2,t};\gamma_{2},c_{2}),
\dots,G_{\tilde{n},t}(s_{\tilde{n},t};\gamma_{\tilde{n}},c_{\tilde{n}})\}.</code>
</p>

<p>Each diagonal element <code class="reqn">G_{i,t}^r</code> is specified as a logistic cumulative density functions, i.e.
</p>
<p style="text-align: center;"><code class="reqn">G_{i,t}^r(s_{i,t}^r; \gamma_i^r, c_i^r) = \left[1 + \exp\big\{-\gamma_i^r(s_{i,t}^r-c_i^r)\big\}\right]^{-1}</code>
</p>

<p>for <code class="reqn">latex</code> and <code class="reqn">r=0,1,\dots,m-1</code>, so that the first model is a Vector Logistic Smooth Transition AutoRegressive
(VLSTAR) model.
The ML estimator of <code class="reqn">\theta</code> is obtained by solving the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}_{ML} = arg \max_{\theta}log L(\theta)</code>
</p>

<p>where <code class="reqn">log L(\theta)</code> is the log-likelihood function of VLSTAR model, given by
</p>
<p style="text-align: center;"><code class="reqn">  ll(y_t|I_t;\theta)=-\frac{T\tilde{n}}{2}\ln(2\pi)-\frac{T}{2}\ln|\Omega|-\frac{1}{2}\sum_{t=1}^{T}(y_t-\tilde{G}_tB\,z_t)'\Omega^{-1}(y_t-\tilde{G}_tB\,z_t)</code>
</p>

<p>The NLS estimators of the VLSTAR model are obtained by solving the optimization problem
</p>
<p style="text-align: center;"><code class="reqn">\hat{\theta}_{NLS} = arg \min_{\theta}\sum_{t=1}^{T}(y_t - \Psi_t'B'x_t)'(y_t - \Psi_t'B'x_t).</code>
</p>

<p>Generally, the optimization algorithm may converge to some local minimum. For this reason, providing valid starting values of <code class="reqn">\theta</code> is crucial. If there is no clear indication on the initial set of parameters, <code class="reqn">\theta</code>, this can be done by implementing a grid search. Thus, a discrete grid in the parameter space of <code class="reqn">\Gamma</code> and C is create to obtain the estimates of B conditionally on each point in the grid. The initial pair of <code class="reqn">\Gamma</code> and C producing the smallest sum of squared residuals is chosen as initial values, then the model is linear in parameters.
The algorithm is the following:
</p>

<ol>
<li><p> Construction of the grid for <code class="reqn">\Gamma</code> and C, computing <code class="reqn">\Psi</code> for each poin in the grid
</p>
</li>
<li><p> Estimation of <code class="reqn">\hat{B}</code> in each equation, calculating the residual sum of squares, <code class="reqn">Q_t</code>
</p>
</li>
<li><p> Finding the pair of <code class="reqn">\Gamma</code> and C providing the smallest <code class="reqn">Q_t</code>
</p>
</li>
<li><p> Once obtained the starting-values, estimation of parameters, <em>B</em>, via nonlinear least squares (NLS)
</p>
</li>
<li><p> Estimation of <code class="reqn">\Gamma</code> and C given the parameters found in step 4
</p>
</li>
<li><p> Repeat step 4 and 5 until convergence.
</p>
</li></ol>



<h3>Value</h3>

<p>An object of class <code>VLSTAR</code>, with standard methods.
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Anderson H.M. and Vahid F. (1998), Testing multiple equation systems for common nonlinear components. <em>Journal of Econometrics</em>. 84: 1-36
</p>
<p>Bacon D.W. and Watts D.G. (1971), Estimating the transition between two intersecting straight lines. <em>Biometrika</em>. 58: 525-534
</p>
<p>Terasvirta T. and Yang Y. (2014), Specification, Estimation and Evaluation of Vector Smooth Transition Autoregressive Models with Applications. <em>CREATES Research Paper 2014-8</em>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Realized)
y &lt;- Realized[-1,1:10]
y &lt;- y[-nrow(y),]
st &lt;- Realized[-nrow(Realized),1]
st &lt;- st[-length(st)]
stvalues &lt;- startingVLSTAR(y, p = 1, n.combi = 3,
 singlecgamma = FALSE, st = st, ncores = 1)
fit.VLSTAR &lt;- VLSTAR(y, p = 1, singlecgamma = FALSE, starting = stvalues,
 n.iter = 1, st = st, method ='NLS', ncores = 1)
# a few methods for VLSTAR
print(fit.VLSTAR)
summary(fit.VLSTAR)
plot(fit.VLSTAR)
predict(fit.VLSTAR, st.num = 1, n.ahead = 1)
logLik(fit.VLSTAR, type = 'Univariate')
coef(fit.VLSTAR)

</code></pre>

<hr>
<h2 id='VLSTARjoint'>Joint linearity test</h2><span id='topic+VLSTARjoint'></span><span id='topic+print.VLSTARjoint'></span>

<h3>Description</h3>

<p>This function allows the user to test linearity against a Vector Smooth Transition Autoregressive Model with a single transition variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VLSTARjoint(y, exo = NULL, st, st.choice = FALSE, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="VLSTARjoint_+3A_y">y</code></td>
<td>
<p><code>data.frame</code> or <code>matrix</code> of dependent variables of dimension <code>(Txn)</code></p>
</td></tr>
<tr><td><code id="VLSTARjoint_+3A_exo">exo</code></td>
<td>
<p>(optional) <code>data.frame</code> or <code>matrix</code> of exogenous variables of dimension <code>(Txk)</code></p>
</td></tr>
<tr><td><code id="VLSTARjoint_+3A_st">st</code></td>
<td>
<p>single transition variable for all the equation of dimension <code>(Tx1)</code></p>
</td></tr>
<tr><td><code id="VLSTARjoint_+3A_st.choice">st.choice</code></td>
<td>
<p>boolean identifying whether the transition variable should be selected from a matrix of <code>R</code> potential variables of dimension <code>(TxR)</code></p>
</td></tr>
<tr><td><code id="VLSTARjoint_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a VLSTAR model with a unique transition variable, <code class="reqn">s_{1t} = s_{2t} = \dots = s_{\widetilde{n}t} = s_t</code>, a generalization of the
linearity test presented in Luukkonen, Saikkonen and Terasvirta (1988) may be implemented.
</p>
<p>Assuming a 2-state VLSTAR model, such that
</p>
<p style="text-align: center;"><code class="reqn">y_t = B_{1}z_t + G_tB_{2}z_t + \varepsilon_t.</code>
</p>

<p>Where the null <code class="reqn">H_{0} : \gamma_{j} = 0</code>, <code class="reqn">j = 1, \dots, \widetilde{n}</code>, is such that <code class="reqn">G_t \equiv (1/2)/\widetilde{n}</code> and the
previous Equation is linear. When the null cannot be rejected, an identification problem of the parameter <code class="reqn">c_{j}</code> in the transition function
emerges, that can be solved through a first-order Taylor expansion around <code class="reqn">\gamma_{j} = 0</code>.
</p>
<p>The approximation of the logistic function with a first-order Taylor expansion is given by
</p>
<p style="text-align: center;"><code class="reqn">G(s_t; \gamma_{j},c_{j}) = (1/2) + (1/4)\gamma_{j}(s_t-c_{j}) + r_{jt}</code>
</p>

<p style="text-align: center;"><code class="reqn">= a_{j}s_t + b_{j} + r_{jt}</code>
</p>

<p>where <code class="reqn">a_{j} = \gamma_{j}/4</code>, <code class="reqn">b_{j} = 1/2 - a_{j}c_{j}</code> and <code class="reqn">r_{j}</code> is the error of the approximation. If <code class="reqn">G_t</code> is specified as follows
</p>
<p style="text-align: center;"><code class="reqn">G_t = diag\big\{a_{1}s_t + b_{1} + r_{1t}, \dots, a_{\widetilde{n}}s_t+b_{\widetilde{n}} + r_{\widetilde{n}t}\big\}</code>
</p>

<p style="text-align: center;"><code class="reqn">= As_t + B + R_t</code>
</p>

<p>where <code class="reqn">A = diag(a_{1}, \dots, a_{\widetilde{n}})</code>, <code class="reqn">B = diag(b_{1},\dots, b_{\widetilde{n}})</code> e <code class="reqn">R_t = diag(r_{1t}, \dots,
                                                                                                                       r_{\widetilde{n}t})</code>, <code class="reqn">y_t</code> can be written as
</p>
<p style="text-align: center;"><code class="reqn">y_t = B_{1}z_t + (As_t + B + R_t)B_{2}z_t+\varepsilon_t</code>
</p>

<p style="text-align: center;"><code class="reqn">= (B_{1} + BB_{2})z_t+AB_{2}z_ts_t + R_tB_{2}z_t + \varepsilon_t</code>
</p>

<p style="text-align: center;"><code class="reqn">= \Theta_{0}z_t + \Theta_{1}z_ts_t+\varepsilon_t^{*}</code>
</p>

<p>where <code class="reqn">\Theta_{0} = B_{1} + B_{2}'B</code>, <code class="reqn">\Theta_{1} = B_{2}'A</code> and <code class="reqn">\varepsilon_t^{*} = R_tB_{2} + \varepsilon_t</code>. Under the null,
<code class="reqn">\Theta_{0} = B_{1}</code> and <code class="reqn">\Theta_{1} = 0</code>, while the previous model is linear, with <code class="reqn">\varepsilon_t^{*} = \varepsilon_t</code>. It
follows that the Lagrange multiplier test, under the null, is derived from the score
</p>
<p style="text-align: center;"><code class="reqn">\frac{\partial \log L(\widetilde{\theta})}{\partial \Theta_{1}} = \sum_{t=1}^{T}z_ts_t(y_t - \widetilde{B}_{1}z_t)'\widetilde{\Omega}^{-1} = S(Y - Z\widetilde{B}_{1})\widetilde{\Omega}^{-1},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">S = z_{1}'s_{1}\\\vdots\\ z_t's_t</code>
</p>

<p>and where <code class="reqn">\widetilde{B}_{1}</code> and <code class="reqn">\widetilde{\Omega}</code> are estimated from the model in <code class="reqn">H_{0}</code>. If <code class="reqn">P_{Z} = Z(Z'Z)^{-1}Z'</code> is the
projection matrix of Z, the LM test is specified as follows
</p>
<p style="text-align: center;"><code class="reqn">LM = tr\big\{\widetilde{\Omega}^{-1}(Y - Z\widetilde{B}_{1})'S\big[S'(I_t - P_{Z})S\big]^{-1}S'(Y-Z\widetilde{B}_{1})\big\}.</code>
</p>

<p>Under the null, the test statistics is distributed as a <code class="reqn">\chi^{2}</code> with <code class="reqn">\widetilde{n}(p\cdot\widetilde{n} + k)</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of class <code>VLSTARjoint</code>.
</p>


<h3>Author(s)</h3>

<p>Andrea Bucci
</p>


<h3>References</h3>

<p>Luukkonen R., Saikkonen P. and Terasvirta T. (1988), Testing Linearity Against Smooth Transition Autoregressive Models. <em>Biometrika</em>, 75: 491-499
</p>
<p>Terasvirta T. and Yang Y. (2015), Linearity and Misspecification Tests for Vector Smooth Transition Regression Models. <em>CREATES Research Paper 2014-4</em>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
