<!DOCTYPE html><html><head><title>Help for package robustlmm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustlmm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robustlmm-package'><p>Robust linear mixed effects models</p></a></li>
<li><a href='#asymptoticVariance'><p>Compute Asymptotic Efficiencies</p></a></li>
<li><a href='#bindDatasets'><p>Bind Generated Datasets</p></a></li>
<li><a href='#chgDefaults'><p>Change default arguments</p></a></li>
<li><a href='#compare'><p>Create comparison charts for multiple fits</p></a></li>
<li><a href='#createDatasetsFromList'><p>Create Dataset List From List of Data Objects</p></a></li>
<li><a href='#createRhoFunction'><p>Create Rho-Functions With Custom Tuning Parameter</p></a></li>
<li><a href='#extractTuningParameter'><p>Extract Tuning Parameters Used In Fitting</p></a></li>
<li><a href='#fitDatasets_lmer'><p>Fitting Functions</p></a></li>
<li><a href='#generateAnovaDatasets'><p>Generate ANOVA type datasets</p></a></li>
<li><a href='#generateMixedEffectDatasets'><p>Generate Mixed Effects Datasets</p></a></li>
<li><a href='#generateSensitivityCurveDatasets'><p>Generate Datasets To Create Sensitivity Curves</p></a></li>
<li><a href='#getME'><p>Extract or Get Generalize Components from a Fitted Mixed Effects Model</p></a></li>
<li><a href='#lapplyDatasets'><p>Lapply for generated datasets</p></a></li>
<li><a href='#loadAndMergePartialResults'><p>Load And Merge Partial Results</p></a></li>
<li><a href='#mergeProcessedFits'><p>Merge Processed Fits</p></a></li>
<li><a href='#other'><p>Other methods</p></a></li>
<li><a href='#partialMoment_standardNormal'><p>Compute Partial Moments</p></a></li>
<li><a href='#plot-methods'><p>Plot an Object of the &quot;Psi Function&quot; Class</p></a></li>
<li><a href='#plot.rlmerMod'><p>Plot Method for &quot;rlmerMod&quot; objects.</p></a></li>
<li><a href='#prepareMixedEffectDataset'><p>Prepare Dataset for Parametric Bootstrap</p></a></li>
<li><a href='#processDatasetsInParallel'><p>Process Datasets in Parallel</p></a></li>
<li><a href='#processFile'><p>Process File of Stored Datasets</p></a></li>
<li><a href='#processFit'><p>Process Fitted Objects</p></a></li>
<li><a href='#psi-functions'><p>Classical, Huber and smoothed Huber psi- or rho-functions</p></a></li>
<li><a href='#psi2propII'><p>Convert to Proposal 2 weight function</p></a></li>
<li><a href='#residuals.rlmerMod'><p>Get residuals</p></a></li>
<li><a href='#rlmer'><p>Robust Scoring Equations Estimator for Linear Mixed Models</p></a></li>
<li><a href='#rlmerMod-class'><p>rlmerMod Class</p></a></li>
<li><a href='#saveDatasets'><p>Save datasets</p></a></li>
<li><a href='#shortenLabelsKS2022'><p>Shorten Labels</p></a></li>
<li><a href='#splitDatasets'><p>Split Datasets Into Chunks</p></a></li>
<li><a href='#viewCopyOfSimulationStudy'><p>Access Simulation Study Code</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Robust Linear Mixed Effects Models</td>
</tr>
<tr>
<td>Version:</td>
<td>3.3-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel Koller</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel Koller &lt;kollerma@proton.me&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements the Robust Scoring Equations estimator to fit linear
    mixed effects models robustly.
    Robustness is achieved by modification of the scoring equations
    combined with the Design Adaptive Scale approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kollerma/robustlmm">https://github.com/kollerma/robustlmm</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>lme4 (&ge; 1.1-9), Matrix (&ge; 1.6-2), R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, reshape2, microbenchmark, emmeans (&ge; 1.4),
estimability, lqmm, rlme, MASS, lemon, RColorBrewer, skewt, fs,
dplyr, ggh4x, testthat, robustvarComp</td>
</tr>
<tr>
<td>Imports:</td>
<td>lattice, nlme, methods, robustbase (&ge; 0.93), xtable, Rcpp (&ge;
0.12.2), fastGHQuad, parallel, rlang, utils</td>
</tr>
<tr>
<td>Collate:</td>
<td>'ghq.R' 'psiFunc2.R' 'AllClass.R' 'rlmer.R' 'accessors.R'
'fromLme4.R' 'DAS-scale.R' 'fit.effects.R' 'helpers.R'
'AllGeneric.R' 'lmer.R' 'mutators.R' 'plot.R'
'generateAnovaDatasets.R' 'generateMixedEffectDatasets.R'
'generateSensitivityCurveDatasets.R' 'manageDatasets.R'
'fitDatasets.R' 'processFit.R' 'processFile.R'
'simulationStudies.R' 'asymptoticEfficiency.R' 'emmeans.R'</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, robustbase, Matrix</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RcppModules:</td>
<td>psi_function_module</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Config/build/clean-inst-doc:</td>
<td>false</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-10 12:11:17 UTC; kollerma</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-14 23:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='robustlmm-package'>Robust linear mixed effects models</h2><span id='topic+robustlmm'></span><span id='topic+robustlmm-package'></span>

<h3>Description</h3>

<p><code>robustlmm</code> provides functions for estimating linear mixed effects
models in a robust way.
</p>
<p>The main workhorse is the function <code><a href="#topic+rlmer">rlmer</a></code>; it is implemented
as direct robust analogue of the popular <code><a href="lme4.html#topic+lmer">lmer</a></code> function of
the <code><a href="lme4.html#topic+lme4">lme4</a></code> package. The two functions have similar abilities
and limitations. A wide range of data structures can be modeled: mixed
effects models with hierarchical as well as complete or partially crossed
random effects structures are possible. While the <code><a href="lme4.html#topic+lmer">lmer</a></code>
function is optimized to handle large datasets efficiently, the
computations employed in the <code><a href="#topic+rlmer">rlmer</a></code> function are more
complex and for this reason also more expensive to compute. The two
functions have the same limitations in the support of different random
effect and residual error covariance structures. Both support only
diagonal and unstructured random effect covariance structures.
</p>
<p>The <code>robustlmm</code> package implements most of the analysis tool chain
as is customary in R. The usual functions such as <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="stats.html#topic+coef">coef</a></code>, <code><a href="stats.html#topic+resid">resid</a></code>, etc. are provided as long as
they are applicable for this type of models (see
<code><a href="#topic+rlmerMod-class">rlmerMod-class</a></code> for a full list). The functions are designed
to be as similar as possible to the ones in the <code><a href="lme4.html#topic+lme4">lme4</a></code>
package to make switching between the two packages easy.
</p>
<p>Details on the implementation and example analyses are provided in the
package vignette available via <code>vignette("rlmer")</code> (Koller 2016).
</p>


<h3>References</h3>

<p>Manuel Koller (2016).
robustlmm: An R Package for Robust Estimation of Linear Mixed-Effects Models.
Journal of Statistical Software, 75(6), 1-24. doi:10.18637/jss.v075.i06
</p>
<p>Koller M, Stahel WA (2022).
&quot;Robust Estimation of General Linear Mixed Effects Models.”
In PM Yi, PK Nordhausen (eds.), Robust and Multivariate Statistical Methods,
Springer Nature Switzerland AG.
</p>
<p>Manuel Koller (2013).
Robust estimation of linear mixed models.
(Doctoral dissertation, Diss., Eidgenössische Technische Hochschule ETH Zürich, Nr. 20997, 2013).
</p>

<hr>
<h2 id='asymptoticVariance'>Compute Asymptotic Efficiencies</h2><span id='topic+asymptoticVariance'></span><span id='topic+asymptoticEfficiency'></span><span id='topic+findTuningParameter'></span>

<h3>Description</h3>

<p><code>asymptoticEfficiency</code> computes the theoretical asymptotic efficiency
for an M-estimator for various types of equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymptoticVariance(
  psi,
  equation = c("location", "scale", "eta", "tau", "mu"),
  dimension = 1
)

asymptoticEfficiency(
  psi,
  equation = c("location", "scale", "eta", "tau", "mu"),
  dimension = 1
)

findTuningParameter(
  desiredEfficiency,
  psi,
  equation = c("location", "scale", "eta", "tau", "mu"),
  dimension = 1,
  interval = c(0.15, 50),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymptoticVariance_+3A_psi">psi</code></td>
<td>
<p>object of class psi_func</p>
</td></tr>
<tr><td><code id="asymptoticVariance_+3A_equation">equation</code></td>
<td>
<p>equation to base computations on. <code>"location"</code> and
<code>"scale"</code> are for the univariate case. The others are for a
multivariate location and scale problem. <code>"eta"</code> is for the shape of
the covariance matrix, <code>"tau"</code> for the size of the covariance matrix
and <code>"mu"</code> for the location.</p>
</td></tr>
<tr><td><code id="asymptoticVariance_+3A_dimension">dimension</code></td>
<td>
<p>dimension for the multivariate location and scale problem.</p>
</td></tr>
<tr><td><code id="asymptoticVariance_+3A_desiredefficiency">desiredEfficiency</code></td>
<td>
<p>scalar, specifying the desired asymptotic
efficiency, needs to be between 0 and 1.</p>
</td></tr>
<tr><td><code id="asymptoticVariance_+3A_interval">interval</code></td>
<td>
<p>interval in which to do the root search, passed on to
<code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
<tr><td><code id="asymptoticVariance_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="stats.html#topic+uniroot">uniroot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The asymptotic efficiency is defined as the ratio between the asymptotic
variance of the maximum likelihood estimator and the asymptotic variance
of the (M-)estimator in question.
</p>
<p>The computations are only approximate, using numerical integration in the
general case. Depending on the regularity of the psi-function, these
approximations can be quite crude.
</p>


<h3>References</h3>

<p>Maronna, R. A., Martin, R. D., Yohai, V. J., &amp; Salibián-Barrera,
M. (2019). Robust statistics: theory and methods (with R). John Wiley &amp;
Sons., equation (2.25)
</p>
<p>Rousseeuw, P. J., Hampel, F. R., Ronchetti, E. M., &amp; Stahel, W. A. (2011).
Robust statistics: the approach based on influence functions. John Wiley &amp;
Sons., Section 5.3c, Paragraph 2 (Page 286)
</p>

<hr>
<h2 id='bindDatasets'>Bind Generated Datasets</h2><span id='topic+bindDatasets'></span>

<h3>Description</h3>

<p>This method can be used to bind multiple datasets generated using different
random genrators into one large dataset. The underlying dataset needs to be
the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bindDatasets(..., datasetList = list(...))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bindDatasets_+3A_...">...</code></td>
<td>
<p>multiple datasets to be bound together</p>
</td></tr>
<tr><td><code id="bindDatasets_+3A_datasetlist">datasetList</code></td>
<td>
<p>list of datasets created with one of the generate dataset
functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>merged list with generators and the contents of the prepared
dataset. See '<code><a href="#topic+prepareMixedEffectDataset">prepareMixedEffectDataset</a></code> and
<code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code> for a description of the contents.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splitDatasets">splitDatasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  datasets1 &lt;- generateAnovaDatasets(2, 4, 4, 4)
  datasets2 &lt;- generateAnovaDatasets(2, 4, 4, 4)
  datasets &lt;- bindDatasets(datasets1, datasets2)
  data &lt;- datasets$generateData(1)
  stopifnot(data$numberOfDatasets == 4,
            all.equal(datasets2$generateData(1), datasets$generateData(3),
                      check.attributes = FALSE),
            all.equal(datasets2$sphericalRandomEffects(1), datasets$sphericalRandomEffects(3)),
            all.equal(datasets2$createXMatrix(data), datasets$createXMatrix(data)),
            all.equal(datasets2$createZMatrix(data), datasets$createZMatrix(data)))

  preparedDataset &lt;- prepareMixedEffectDataset(Reaction ~ Days + (Days|Subject), sleepstudy)
  datasets1 &lt;- generateMixedEffectDatasets(2, preparedDataset)
  datasets2 &lt;- generateMixedEffectDatasets(2, preparedDataset)
  datasets &lt;- bindDatasets(datasets1, datasets2)
  data &lt;- datasets$generateData(1)
  stopifnot(data$numberOfDatasets == 4,
            all.equal(datasets2$generateData(1), datasets$generateData(3),
                      check.attributes = FALSE),
            all.equal(datasets2$sphericalRandomEffects(1), datasets$sphericalRandomEffects(3)),
            all.equal(datasets2$createXMatrix(data), datasets$createXMatrix(data)),
            all.equal(datasets2$createZMatrix(data), datasets$createZMatrix(data)))
</code></pre>

<hr>
<h2 id='chgDefaults'>Change default arguments</h2><span id='topic+chgDefaults'></span><span id='topic+chgDefaults+2Cpsi_func_rcpp-method'></span>

<h3>Description</h3>

<p>Change the default arguments for a psi_func_rcpp object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'psi_func_rcpp'
chgDefaults(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chgDefaults_+3A_object">object</code></td>
<td>
<p>instance to convert</p>
</td></tr>
<tr><td><code id="chgDefaults_+3A_...">...</code></td>
<td>
<p>arguments to change</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that names of named arguments are ignored. Only the order of the
arguments considered when assigning new arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sPsi &lt;- chgDefaults(smoothPsi, k=2)
curve(sPsi@psi(x), 0, 3)
curve(smoothPsi@psi(x), 0, 3, col="blue", add=TRUE)
</code></pre>

<hr>
<h2 id='compare'>Create comparison charts for multiple fits</h2><span id='topic+compare'></span><span id='topic+getInfo.lmerMod'></span><span id='topic+getInfo.rlmerMod'></span><span id='topic+xtable.comparison.table'></span><span id='topic+print.xtable.comparison.table'></span><span id='topic+getInfo'></span>

<h3>Description</h3>

<p>Use <code>compare</code> to quickly compare the estimated parameters of the fits
of multiple lmerMod or rlmerMod objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare(..., digits = 3, dnames = NULL, show.rho.functions = TRUE)

## S3 method for class 'lmerMod'
getInfo(object, ...)

## S3 method for class 'rlmerMod'
getInfo(object, ...)

## S3 method for class 'comparison.table'
xtable(
  x,
  caption = NULL,
  label = NULL,
  align = NULL,
  digits = NULL,
  display = NULL,
  ...
)

## S3 method for class 'xtable.comparison.table'
print(
  x,
  add.hlines = TRUE,
  latexify.namescol = TRUE,
  include.rownames = FALSE,
  ...
)

getInfo(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_+3A_...">...</code></td>
<td>
<p>objects to compare, or, for the <code><a href="xtable.html#topic+xtable">xtable</a></code> functions:
passed to the respective <code><a href="xtable.html#topic+xtable">xtable</a></code> function.</p>
</td></tr>
<tr><td><code id="compare_+3A_digits">digits</code></td>
<td>
<p>number of digits to show in output</p>
</td></tr>
<tr><td><code id="compare_+3A_dnames">dnames</code></td>
<td>
<p>names of objects given as arguments (optional)</p>
</td></tr>
<tr><td><code id="compare_+3A_show.rho.functions">show.rho.functions</code></td>
<td>
<p>whether to show rho functions in output.</p>
</td></tr>
<tr><td><code id="compare_+3A_object">object</code></td>
<td>
<p>object</p>
</td></tr>
<tr><td><code id="compare_+3A_x">x</code></td>
<td>
<p>object of class &quot;comparison.table&quot; or &quot;xtable.comparison.table&quot;</p>
</td></tr>
<tr><td><code id="compare_+3A_caption">caption</code></td>
<td>
<p>see <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_label">label</code></td>
<td>
<p>see <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_align">align</code></td>
<td>
<p>see <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_display">display</code></td>
<td>
<p>see <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_add.hlines">add.hlines</code></td>
<td>
<p>replace empty lines in comparison table by hlines.
Supersedes <code>hline.after</code> argument of <code>print.xtable</code>.</p>
</td></tr>
<tr><td><code id="compare_+3A_latexify.namescol">latexify.namescol</code></td>
<td>
<p>replace &ldquo;sigma&rdquo; and &ldquo;x&rdquo; in the first
column by latex equivalents.</p>
</td></tr>
<tr><td><code id="compare_+3A_include.rownames">include.rownames</code></td>
<td>
<p>include row numbers (the object returned by
<code>xtable.comparison.table</code> includes names in the first column)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>xtable.comparison.table</code> and
<code>print.xtable.comparison.table</code> are wrapper functions for the
respective <code><a href="xtable.html#topic+xtable">xtable</a></code> and <code><a href="xtable.html#topic+print.xtable">print.xtable</a></code> functions.
</p>
<p>The function <code>getInfo</code> is internally used to prepare object for
producing a comparison chart in <code>compare</code>.
</p>


<h3>Value</h3>

<p><code>getInfo</code> returns a list with estimated coefficients, estimated
variance components, sigma, deviance and parameter configuration used to
fit.
</p>


<h3>See Also</h3>

<p><code><a href="xtable.html#topic+xtable">xtable</a></code>
</p>
<p><code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  fm1 &lt;- lmer(Yield ~ (1|Batch), Dyestuff)
  fm2 &lt;- rlmer(Yield ~ (1|Batch), Dyestuff)
  compare(fm1, fm2)
  require(xtable)
  xtable(compare(fm1, fm2))
  str(getInfo(fm1))

## End(Not run)
</code></pre>

<hr>
<h2 id='createDatasetsFromList'>Create Dataset List From List of Data Objects</h2><span id='topic+createDatasetsFromList'></span>

<h3>Description</h3>

<p>Convert a list of datasets to a dataset list similar to the ones created by
<code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code> and
<code><a href="#topic+generateMixedEffectDatasets">generateMixedEffectDatasets</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createDatasetsFromList(
  datasetList,
  formula,
  trueBeta,
  trueSigma,
  trueTheta,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createDatasetsFromList_+3A_datasetlist">datasetList</code></td>
<td>
<p>list of data objects, usually of type <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="createDatasetsFromList_+3A_formula">formula</code></td>
<td>
<p>formula to fit the model using <code>lmer</code>.</p>
</td></tr>
<tr><td><code id="createDatasetsFromList_+3A_truebeta">trueBeta</code></td>
<td>
<p>scalar or vector with the true values of the fixed effects
coefficients. Can be of length one in which case it will be replicated to
the required length if needed.</p>
</td></tr>
<tr><td><code id="createDatasetsFromList_+3A_truesigma">trueSigma</code></td>
<td>
<p>scalar with the true value of the error scale.</p>
</td></tr>
<tr><td><code id="createDatasetsFromList_+3A_truetheta">trueTheta</code></td>
<td>
<p>scalar or vector with the true values for the variance
component coefficients, not including sigma. Can be of length one in which
case it will be replicated to the required length if needed.</p>
</td></tr>
<tr><td><code id="createDatasetsFromList_+3A_...">...</code></td>
<td>
<p>all additional arguments are added to the returned list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned list can be passed to <code><a href="#topic+processFit">processFit</a></code> and to any of
the <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions. Splitting and binding of datasets
using <code><a href="#topic+splitDatasets">splitDatasets</a></code> and <code><a href="#topic+bindDatasets">bindDatasets</a></code> is not
supported.
</p>


<h3>Value</h3>

<p>list that can be passed to <code><a href="#topic+processFit">processFit</a></code> and to any of
the <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions. Only <code>generateData</code> is
implemented, all the other functions return an error if called.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code> and
<code><a href="#topic+generateMixedEffectDatasets">generateMixedEffectDatasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(sleepstudy)
  sleepstudy2 &lt;- sleepstudy
  sleepstudy2[1, "Reaction"] &lt;- sleepstudy2[1, "Reaction"] + 10
  fm1 &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
  datasets &lt;- createDatasetsFromList(list(sleepstudy, sleepstudy2),
                                     formula = Reaction ~ Days + (Days|Subject),
                                     trueBeta = getME(fm1, "beta"),
                                     trueSigma = sigma(fm1),
                                     trueTheta = getME(fm1, "theta"))
  fitDatasets_lmer(datasets)
</code></pre>

<hr>
<h2 id='createRhoFunction'>Create Rho-Functions With Custom Tuning Parameter</h2><span id='topic+createRhoFunction'></span>

<h3>Description</h3>

<p>Convenience function to create rho-functions with custom tuning parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRhoFunction(
  tuningParameter,
  which = c("rho.e", "rho.sigma.e", "rho.b.diagonal", "rho.sigma.b.diagonal",
    "rho.b.blockDiagonal", "rho.sigma.b.blockDiagonal"),
  rho.e = smoothPsi,
  rho.sigma.e = psi2propII(rho.e),
  rho.b.diagonal = rho.e,
  rho.sigma.b.diagonal = psi2propII(rho.b.diagonal),
  rho.b.blockDiagonal = rho.e,
  rho.sigma.b.blockDiagonal = rho.b.blockDiagonal,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createRhoFunction_+3A_tuningparameter">tuningParameter</code></td>
<td>
<p>argument passed on to
<code><a href="#topic+extractTuningParameter">extractTuningParameter</a></code>. See its documentation for details.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_which">which</code></td>
<td>
<p>string specifiying which tuning parameter should be extracted.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.e">rho.e</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for <code>rho.e</code>.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.sigma.e">rho.sigma.e</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for
<code>rho.sigma.e</code>.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.b.diagonal">rho.b.diagonal</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for <code>rho.b</code>
for models with diagonal random effects covariance matrix.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.sigma.b.diagonal">rho.sigma.b.diagonal</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for
<code>rho.sigma.b</code> for models with diagonal random effects covariance
matrix.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.b.blockdiagonal">rho.b.blockDiagonal</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for
<code>rho.b</code> for models with block-diagonal random effects covariance
matrix.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_rho.sigma.b.blockdiagonal">rho.sigma.b.blockDiagonal</code></td>
<td>
<p><code><a href="#topic+PsiFunction">PsiFunction</a></code> to be used for
<code>rho.sigma.b</code> for models with block-diagonal random effects
covariance matrix.</p>
</td></tr>
<tr><td><code id="createRhoFunction_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+chgDefaults">chgDefaults</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'rho.b.diagonal' denotes the tuning parameter to be used for 'rho.b' for
models with diagonal random effects covariance matrix. 'rho.b.blockDiagonal'
is the tuning parameter to be used in the block diagonal case, respectively.
</p>
<p>For arguments <code>rho.sigma.e</code> (and <code>rho.sigma.b.diagonal</code>), the
Proposal 2 variant of the function specified for <code>rho.e</code> (and
<code>rho.b</code>) is used.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  createRhoFunction(c(1.345, 2.28, 1.345, 2.28, 5.14, 5.14), "rho.sigma.e")
</code></pre>

<hr>
<h2 id='extractTuningParameter'>Extract Tuning Parameters Used In Fitting</h2><span id='topic+extractTuningParameter'></span><span id='topic+extractPredefinedTuningParameter'></span>

<h3>Description</h3>

<p>Methods to extract which tuning parameters have been used for fitting
models. Use <code>extractTuningParameter</code> for custom configurations and
<code>extractPredefinedTuningParameter</code> for predefined configurations
provided in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractTuningParameter(
  tuningParameter,
  which = c("rho.e", "rho.sigma.e", "rho.b.diagonal", "rho.sigma.b.diagonal",
    "rho.b.blockDiagonal", "rho.sigma.b.blockDiagonal")
)

extractPredefinedTuningParameter(label, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractTuningParameter_+3A_tuningparameter">tuningParameter</code></td>
<td>
<p>vector of tuning parameters. The vector is expected
to be of length 6, containing the tuning parameters for rho.e,
rho.sigma.e, rho.b.diagonal, rho.sigma.b.diagonal, rho.b.blockDiagonal and
rho.sigma.b.blockDiagonal. 'rho.b.diagonal' denotes the tuning parameter
to be used for 'rho.b' for models with diagonal random effects covariance
matrix. Names are optional.</p>
</td></tr>
<tr><td><code id="extractTuningParameter_+3A_which">which</code></td>
<td>
<p>string specifiying which tuning parameter should be extracted.</p>
</td></tr>
<tr><td><code id="extractTuningParameter_+3A_label">label</code></td>
<td>
<p>label or vector of labels in results. Only predefined labels of
the form 'fitDatasets_rlmer_...' are supported (for others NA is
returned).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar tuning parameter
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  extractPredefinedTuningParameter("fitDatasets_rlmer_DAStau", "rho.e")
</code></pre>

<hr>
<h2 id='fitDatasets_lmer'>Fitting Functions</h2><span id='topic+fitDatasets_lmer'></span><span id='topic+fitDatasets'></span><span id='topic+fitDatasets_lmer_bobyqa'></span><span id='topic+fitDatasets_lmer_Nelder_Mead'></span><span id='topic+fitDatasets_rlmer'></span><span id='topic+fitDatasets_rlmer_DAStau'></span><span id='topic+fitDatasets_rlmer_DAStau_lmerNoFit'></span><span id='topic+fitDatasets_rlmer_DASvar'></span><span id='topic+fitDatasets_rlmer_DAStau_noAdj'></span><span id='topic+fitDatasets_rlmer_DAStau_k_0_5'></span><span id='topic+fitDatasets_rlmer_DAStau_k_0_5_noAdj'></span><span id='topic+fitDatasets_rlmer_DAStau_k_2'></span><span id='topic+fitDatasets_rlmer_DAStau_k_2_noAdj'></span><span id='topic+fitDatasets_rlmer_DAStau_k_5'></span><span id='topic+fitDatasets_rlmer_DAStau_k_5_noAdj'></span><span id='topic+fitDatasets_heavyLme'></span><span id='topic+fitDatasets_lqmm'></span><span id='topic+fitDatasets_rlme'></span><span id='topic+fitDatasets_varComprob'></span><span id='topic+fitDatasets_varComprob_compositeTau'></span><span id='topic+fitDatasets_varComprob_compositeTau_OGK'></span><span id='topic+fitDatasets_varComprob_compositeTau_2SGS'></span><span id='topic+fitDatasets_varComprob_compositeS'></span><span id='topic+fitDatasets_varComprob_compositeS_OGK'></span><span id='topic+fitDatasets_varComprob_compositeS_2SGS'></span><span id='topic+fitDatasets_varComprob_S'></span><span id='topic+fitDatasets_varComprob_S_OGK'></span><span id='topic+fitDatasets_varComprob_S_2SGS'></span>

<h3>Description</h3>

<p>Methods to fit various mixed effects estimators to all generated datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitDatasets_lmer(datasets, control, label, postFit, datasetIndices = "all")

fitDatasets_lmer_bobyqa(datasets, postFit, datasetIndices = "all")

fitDatasets_lmer_Nelder_Mead(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer(
  datasets,
  method,
  tuningParameter,
  label,
  postFit,
  datasetIndices = "all",
  ...,
  init
)

fitDatasets_rlmer_DAStau(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_lmerNoFit(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DASvar(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_noAdj(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_0_5(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_0_5_noAdj(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_2(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_2_noAdj(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_5(datasets, postFit, datasetIndices = "all")

fitDatasets_rlmer_DAStau_k_5_noAdj(datasets, postFit, datasetIndices = "all")

fitDatasets_heavyLme(datasets, postFit, datasetIndices = "all")

fitDatasets_lqmm(datasets, postFit, datasetIndices = "all")

fitDatasets_rlme(datasets, postFit, datasetIndices = "all")

fitDatasets_varComprob(
  datasets,
  control,
  label,
  postFit,
  datasetIndices = "all"
)

fitDatasets_varComprob_compositeTau(datasets, postFit, datasetIndices = "all")

fitDatasets_varComprob_compositeTau_OGK(
  datasets,
  postFit,
  datasetIndices = "all"
)

fitDatasets_varComprob_compositeTau_2SGS(
  datasets,
  postFit,
  datasetIndices = "all"
)

fitDatasets_varComprob_compositeS(datasets, postFit, datasetIndices = "all")

fitDatasets_varComprob_compositeS_OGK(
  datasets,
  postFit,
  datasetIndices = "all"
)

fitDatasets_varComprob_compositeS_2SGS(
  datasets,
  postFit,
  datasetIndices = "all"
)

fitDatasets_varComprob_S(datasets, postFit, datasetIndices = "all")

fitDatasets_varComprob_S_OGK(datasets, postFit, datasetIndices = "all")

fitDatasets_varComprob_S_2SGS(datasets, postFit, datasetIndices = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitDatasets_lmer_+3A_datasets">datasets</code></td>
<td>
<p>Datasets list to be used to generate datasets.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_control">control</code></td>
<td>
<p>a list (of correct class for the respective fitting function)
containing control parameters to be passed through.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_label">label</code></td>
<td>
<p>a string used to identify which fits have been created by which
function.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_postfit">postFit</code></td>
<td>
<p>a function, taking one argument, the resulting fit. This
makes it easy to add an additional step after fitting.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_datasetindices">datasetIndices</code></td>
<td>
<p>optional vector of dataset indices to fit, useful to
try only a few datasets instead of all of them.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_method">method</code></td>
<td>
<p>argument passed on to <code><a href="#topic+rlmer">rlmer</a></code>.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_tuningparameter">tuningParameter</code></td>
<td>
<p>argument passed on to
<code><a href="#topic+extractTuningParameter">extractTuningParameter</a></code>.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_...">...</code></td>
<td>
<p>argument passed on to <code><a href="#topic+createRhoFunction">createRhoFunction</a></code>.</p>
</td></tr>
<tr><td><code id="fitDatasets_lmer_+3A_init">init</code></td>
<td>
<p>optional argument passed on to <code><a href="#topic+rlmer">rlmer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Existing fitting functions are:
</p>
<p><code>fitDatasets_lmer</code>: Fits datasets using <code><a href="lme4.html#topic+lmer">lmer</a></code>
using its default options.
</p>
<p><code>fitDatasets_lmer_bobyqa</code>: Fits datasets using <code><a href="lme4.html#topic+lmer">lmer</a></code> using
the <code>bobyqa</code> optimizer.
</p>
<p><code>fitDatasets_lmer_Nelder_Mead</code>: Fits datasets using
<code><a href="lme4.html#topic+lmer">lmer</a></code> using the <code>Nelder Mead</code> optimizer.
</p>
<p><code>fitDatasets_rlmer</code>: Fits datasets using <code><a href="#topic+rlmer">rlmer</a></code>
using a custom configuration. The argument 'tuningParameter' is passed to
<code><a href="#topic+extractTuningParameter">extractTuningParameter</a></code>, details are documented there.
</p>
<p><code>fitDatasets_rlmer_DAStau</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau and <code><a href="#topic+smoothPsi">smoothPsi</a></code> for
the rho functions. The tuning parameters are k = 1.345 for <code>rho.e</code>.
For <code>rho.sigma.e</code>, the Proposal 2 variant is used using k = 2.28.
The choices for <code>rho.b</code> and <code>rho.sigma.b</code> depend on whether the
model uses a diagonal or a block diagonal matrix for Lambda. In the former
case, the same psi functions and tuning parameters are use as for
<code>rho.e</code> and <code>rho.sigma.b</code>. In the block diagonal case,
<code>rho.b</code> and <code>rho.sigma.b</code> both use <code><a href="#topic+smoothPsi">smoothPsi</a></code> using
a tuning parameter k = 5.14 (assuming blocks of dimension 2).
</p>
<p><code>fitDatasets_rlmer_DAStau_lmerNoFit</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using the same configuration as
<code>fitDatasets_rlmer_DAStau</code> except for that it is using
<code><a href="#topic+lmerNoFit">lmerNoFit</a></code> as initial estimator.
</p>
<p><code>fitDatasets_rlmer_DASvar</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DASvar. The same rho functions and tuning
parameters are used as for <code>fitDatasets_rlmer_DAStau</code>.
</p>
<p><code>fitDatasets_rlmer_DAStau_noAdj</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. The same rho functions and tuning
parameters are used as for <code>fitDatasets_rlmer_DAStau</code>, except for
<code>rho.sigma.e</code> (and <code>rho.sigma.b</code> in the diagonal case) for which
the Proposal 2 variant of <code>smoothPsi</code> using k = 1.345 is used.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_0_5</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 0.5</code> for <code>rho.e</code> and
<code>k = 1.47</code> for <code>rho.sigma.e</code>, the latter adjusted to reach the
same asymptotic efficiency. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 2.17</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_0_5_noAdj</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 0.5</code> for <code>rho.e</code> and
<code>rho.sigma.e</code>. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 2.17</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_2</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 2</code> for <code>rho.e</code> and
<code>k = 2.9</code> <code>rho.sigma.e</code>, the latter adjusted to reach the same
asymptotic efficiency. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 8.44</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_2_noAdj</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 2</code> for <code>rho.e</code> and
<code>rho.sigma.e</code>. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 8.44</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_5</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 5</code> for <code>rho.e</code> and
<code>k = 5.03</code> <code>rho.sigma.e</code>, the latter adjusted to reach the same
asymptotic efficiency. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 34.21</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_rlmer_DAStau_k_5_noAdj</code>: Fits datasets using
<code><a href="#topic+rlmer">rlmer</a></code> using method DAStau. Use <code><a href="#topic+smoothPsi">smoothPsi</a></code>
psi-function with tuning parameter <code>k = 5</code> for <code>rho.e</code> and
<code>rho.sigma.e</code>. In the diagonal case, the same are used for
<code>rho.b</code> and <code>rho.sigma.b</code> as well. In the block-diagonal case,
the tuning parameter <code>k = 34.21</code> is used for <code>rho.b</code> and
<code>rho.sigma.b</code>. The tuning parameter is chosen to reach about the same
asymptotic efficiency for theta as for the fixed effects.
</p>
<p><code>fitDatasets_heavyLme</code>: Fits datasets using
<code>heavyLme</code> from package <code>heavy</code>. Additional
required arguments are: <code>lmeFormula</code>, <code>heavyLmeRandom</code> and
<code>heavyLmeGroups</code>. They are passed to the <code>formula</code>,
<code>random</code> and <code>groups</code> arguments of <code>heavyLme</code>.
</p>
<p><code>fitDatasets_lqmm</code>: Fits datasets using
<code><a href="lqmm.html#topic+lqmm">lqmm</a></code> from package <code>lqmm</code>. Additional required
arguments are: <code>lmeFormula</code>, <code>lqmmRandom</code>, <code>lqmmGroup</code> and
<code>lqmmCovariance</code>. They are passed to the <code>formula</code>,
<code>random</code>, <code>groups</code> and <code>covariance</code> arguments of
<code>lqmm</code>. <code>lqmmCovariance</code> is optional, if omitted <code>pdDiag</code>
is used.
</p>
<p><code>fitDatasets_rlme</code>: Fits datasets using
<code><a href="rlme.html#topic+rlme">rlme</a></code> from package <code>rlme</code>.
</p>
<p><code>fitDatasets_varComprob</code>: Prototype method to fit datasets
using <code>varComprob</code> from package
<code>robustvarComp</code>. Additional required items in <code>datasets</code> are:
<code>lmeFormula</code>, <code>groups</code>, <code>varcov</code> and <code>lower</code>. They are
passed to the <code>fixed</code>, <code>groups</code>, <code>varcov</code> and <code>lower</code>
arguments of <code>varComprob</code>. The running of this method produces many
warnings of the form &quot;passing a char vector to .Fortran is not portable&quot;
which are suppressed.
</p>
<p><code>fitDatasets_varComprob_compositeTau</code>: Fits datasets with the
composite Tau method using <code>varComprob</code> from
package <code>robustvarComp</code>. See <code>fitDatasets_varComprob</code> for
additional details.
</p>
<p><code>fitDatasets_varComprob_compositeTau_OGK</code>: Similar to
<code>fitDatasets_varComprob_compositeTau</code> but using <code>covOGK</code> as initial
covariance matrix estimator.
</p>
<p><code>fitDatasets_varComprob_compositeTau_2SGS</code>: Similar to
<code>fitDatasets_varComprob_compositeTau</code> but using <code>2SGS</code> as initial covariance
matrix estimator.
</p>
<p><code>fitDatasets_varComprob_compositeS</code>: Similar to
<code>fitDatasets_varComprob_compositeTau</code> but using method composite S.
</p>
<p><code>fitDatasets_varComprob_compositeS_OGK</code>: Similar to
<code>fitDatasets_varComprob_compositeS</code> but using <code>covOGK</code> as
initial covariance matrix estimator.
</p>
<p><code>fitDatasets_varComprob_compositeS_2SGS</code>: Similar to
<code>fitDatasets_varComprob_compositeS</code> but using <code>2SGS</code> as initial
covariance matrix estimator.
</p>
<p><code>fitDatasets_varComprob_S</code>: Similar to
<code>fitDatasets_varComprob_compositeTau</code> but using method S and the
Rocke psi-function.
</p>
<p><code>fitDatasets_varComprob_S_OGK</code>: Similar to
<code>fitDatasets_varComprob_S</code> but using <code>covOGK</code> as initial
covariance matrix estimator.
</p>
<p><code>fitDatasets_varComprob_S_2SGS</code>: Similar to
<code>fitDatasets_varComprob_S</code> but using <code>2SGS</code> as initial
covariance matrix estimator.
</p>


<h3>Value</h3>

<p>list of fitted models. See also <code><a href="#topic+lapplyDatasets">lapplyDatasets</a></code> which
is called internally.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  oneWay &lt;- generateAnovaDatasets(1, 1, 10, 4,
                                  lmeFormula = y ~ 1,
                                  heavyLmeRandom = ~ 1,
                                  heavyLmeGroups = ~ Var2,
                                  lqmmRandom = ~ 1,
                                  lqmmGroup = "Var2",
                                  groups = cbind(rep(1:4, each = 10), rep(1:10, 4)),
                                  varcov = matrix(1, 4, 4),
                                  lower = 0)
  fitDatasets_lmer(oneWay)
  ## call rlmer with custom arguments
  fitDatasets_rlmer_custom &lt;- function(datasets) {
    return(fitDatasets_rlmer(datasets,
                             method = "DASvar",
                             tuningParameter = c(1.345, 2.28, 1.345, 2.28, 5.14, 5.14),
                             label = "fitDatasets_rlmer_custom"))
  }
  fitDatasets_rlmer_custom(oneWay)
</code></pre>

<hr>
<h2 id='generateAnovaDatasets'>Generate ANOVA type datasets</h2><span id='topic+generateAnovaDatasets'></span>

<h3>Description</h3>

<p>Generate balanced datasets with multiple factors. All combinations of all
factor variables are generated, i.e., a fully crossed dataset will be
generated. <code>numberOfReplicates</code> specifies the number of replications
per unique combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateAnovaDatasets(
  numberOfDatasetsToGenerate,
  numberOfLevelsInFixedFactor,
  numberOfSubjects,
  numberOfReplicates,
  errorGenerator = rnorm,
  randomEffectGenerator = rnorm,
  trueBeta = 1,
  trueSigma = 4,
  trueTheta = 1,
  ...,
  arrange = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateAnovaDatasets_+3A_numberofdatasetstogenerate">numberOfDatasetsToGenerate</code></td>
<td>
<p>number of datasets to generate.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_numberoflevelsinfixedfactor">numberOfLevelsInFixedFactor</code></td>
<td>
<p>scalar or vector with the number of
levels per fixed factor or grouping variable.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_numberofsubjects">numberOfSubjects</code></td>
<td>
<p>scalar or vector with the number of levels per
variance component.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_numberofreplicates">numberOfReplicates</code></td>
<td>
<p>number of replicates per unique combination of
fixed factor and variance component.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_errorgenerator">errorGenerator</code></td>
<td>
<p>random number generator used for the errors.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_randomeffectgenerator">randomEffectGenerator</code></td>
<td>
<p>random number generator used for the spherical
random effects.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_truebeta">trueBeta</code></td>
<td>
<p>scalar or vector with the true values of the fixed effects
coefficients. Can be of length one in which case it will be replicated to
the required length if needed.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_truesigma">trueSigma</code></td>
<td>
<p>scalar with the true value of the error scale.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_truetheta">trueTheta</code></td>
<td>
<p>scalar of vector with the true values for the variance
component coefficients, not including sigma. Can be of length one in which
case it will be replicated to the required length if needed.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_...">...</code></td>
<td>
<p>all additional arguments are added to the returned list.</p>
</td></tr>
<tr><td><code id="generateAnovaDatasets_+3A_arrange">arrange</code></td>
<td>
<p>If <code>TRUE</code>, the observations in the dataset are arranged
such that the call to <code><a href="dplyr.html#topic+arrange">arrange</a></code> in
<code>varComprob</code> does not break the observation-
group relationship. This requires package dplyr to be installed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>numberOfLevelsInFixedFactor</code> can either be a scalar or a vector with
the number of levels for each fixed effects group. If
<code>numberOfLevelsInFixedFactor</code> is a scalar, the value of <code>1</code> is
allowed. This can be used to generate a dataset with an intercept only. If
<code>numberOfLevelsInFixedFactor</code> is a vector with more than one entry,
then all the values need to be larger than one.
</p>
<p><code>numberOfSubjects</code> can also be a scalar of a vector with the number of
levels for each variance component. Each group needs to have more than one
level. The vector is sorted descending before the names are assigned. This
ensures that, when running <code>lmer</code>, the order of the random effects does
not change. <code>lmer</code> also sorts the random effects by decending number of
levels.
</p>
<p>In order to save memory, only the generated random effects and the errors
are stored. The dataset is only created on demand when the method
<code>generateData</code> in the returned list is evaluated.
</p>
<p>The random variables are generated in a way that one can simulate more
datasets easily. When starting from the same seed, the first generated
datasets will be the same as for the a previous call of
<code>generateAnovaDatasets</code> with a smaller number of datasets to generate,
see examples.
</p>


<h3>Value</h3>

<p>list with generators and the original arguments
</p>
<table>
<tr><td><code>generateData:</code></td>
<td>
<p>function to generate data taking one argument, the dataset index.</p>
</td></tr>
<tr><td><code>createXMatrix:</code></td>
<td>
<p>function to generate X matrix taking one argument,
the result of <code>generateData</code>.</p>
</td></tr>
<tr><td><code>createZMatrix:</code></td>
<td>
<p>function to generate Z matrix taking one argument,
the result of <code>generateData</code>.</p>
</td></tr>
<tr><td><code>createLambdaMatrix:</code></td>
<td>
<p>function to generate Lambda matrix taking one
argument, the result of <code>generateData</code>.</p>
</td></tr>
<tr><td><code>randomEffects:</code></td>
<td>
<p>function to return the generated random effects
taking one argument, the dataset index.</p>
</td></tr>
<tr><td><code>sphericalRandomeffects:</code></td>
<td>
<p>function to return the generated spherical random effects
taking one argument, the dataset index.</p>
</td></tr>
<tr><td><code>errors:</code></td>
<td>
<p>function to return the generated errors taking one argument,
the dataset index.</p>
</td></tr>
<tr><td><code>allRandomEffects:</code></td>
<td>
<p>function without arguments that returns the matrix of
all generated random effects.</p>
</td></tr>
<tr><td><code>allErrors:</code></td>
<td>
<p>function without arguments that returns the matrix of all
generated errors.</p>
</td></tr>
<tr><td><code>numberOfDatasets:</code></td>
<td>
<p><code>numberOfDatasetsToGenerate</code> as supplied</p>
</td></tr>
<tr><td><code>numberOfLevelsInFixedFactor:</code></td>
<td>
<p><code>numberOfLevelsInFixedFactor</code> as supplied</p>
</td></tr>
<tr><td><code>numberOfSubjects:</code></td>
<td>
<p><code>numberOfSubjects</code> sorted.</p>
</td></tr>
<tr><td><code>numberOfReplicates:</code></td>
<td>
<p><code>numberOfReplicates</code> as supplied</p>
</td></tr>
<tr><td><code>numberOfRows:</code></td>
<td>
<p>number of rows in the generated dataset</p>
</td></tr>
<tr><td><code>trueBeta:</code></td>
<td>
<p>true values used for beta</p>
</td></tr>
<tr><td><code>trueSigma:</code></td>
<td>
<p>true value used for sigma</p>
</td></tr>
<tr><td><code>trueTheta:</code></td>
<td>
<p>true values used for theta</p>
</td></tr>
<tr><td><code>formula:</code></td>
<td>
<p>formula to fit the model using <code>lmer</code></p>
</td></tr>
<tr><td><code>...:</code></td>
<td>
<p>additional arguments passed via <code>...</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateMixedEffectDatasets">generateMixedEffectDatasets</a></code> and
<code><a href="#topic+createDatasetsFromList">createDatasetsFromList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oneWay &lt;- generateAnovaDatasets(2, 1, 5, 4)
  head(oneWay$generateData(1))
  head(oneWay$generateData(2))
  oneWay$formula
  head(oneWay$randomEffects(1))
  head(oneWay$sphericalRandomEffects(1))
  head(oneWay$errors(1))

  twoWayFixedRandom &lt;- generateAnovaDatasets(2, 3, 5, 4)
  head(twoWayFixedRandom$generateData(1))
  twoWayFixedRandom$formula

  twoWayRandom &lt;- generateAnovaDatasets(2, 1, c(3, 5), 4)
  head(twoWayRandom$generateData(1))
  twoWayRandom$formula

  large &lt;- generateAnovaDatasets(2, c(10, 15), c(20, 30), 5)
  head(large$generateData(1))
  large$formula

  ## illustration how to generate more datasets
  set.seed(1)
  datasets1 &lt;- generateAnovaDatasets(2, 1, 5, 4)
  set.seed(1)
  datasets2 &lt;- generateAnovaDatasets(3, 1, 5, 4)
  stopifnot(all.equal(datasets1$generateData(1), datasets2$generateData(1)),
            all.equal(datasets1$generateData(2), datasets2$generateData(2)))
</code></pre>

<hr>
<h2 id='generateMixedEffectDatasets'>Generate Mixed Effects Datasets</h2><span id='topic+generateMixedEffectDatasets'></span>

<h3>Description</h3>

<p>Generates mixed effects datasets using parametric bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateMixedEffectDatasets(
  numberOfDatasetsToGenerate,
  preparedDataset,
  errorGenerator = rnorm,
  randomEffectGenerator = rnorm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateMixedEffectDatasets_+3A_numberofdatasetstogenerate">numberOfDatasetsToGenerate</code></td>
<td>
<p>number of datasets to generate.</p>
</td></tr>
<tr><td><code id="generateMixedEffectDatasets_+3A_prepareddataset">preparedDataset</code></td>
<td>
<p>dataset as prepared by
<code><a href="#topic+prepareMixedEffectDataset">prepareMixedEffectDataset</a></code>.</p>
</td></tr>
<tr><td><code id="generateMixedEffectDatasets_+3A_errorgenerator">errorGenerator</code></td>
<td>
<p>random number generator used for the errors.</p>
</td></tr>
<tr><td><code id="generateMixedEffectDatasets_+3A_randomeffectgenerator">randomEffectGenerator</code></td>
<td>
<p>random number generator used for the spherical
random effects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with generators and the contents of the prepared dataset. See
<code><a href="#topic+prepareMixedEffectDataset">prepareMixedEffectDataset</a></code> and
<code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code> for a description of the contents.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code>,
<code><a href="#topic+prepareMixedEffectDataset">prepareMixedEffectDataset</a></code> and
<code><a href="#topic+createDatasetsFromList">createDatasetsFromList</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  preparedDataset &lt;- prepareMixedEffectDataset(Reaction ~ Days + (Days|Subject), sleepstudy)
  datasets &lt;- generateMixedEffectDatasets(2, preparedDataset)
  head(datasets$generateData(1))
  head(datasets$generateData(2))
  datasets$formula
  head(datasets$randomEffects(1))
  head(datasets$sphericalRandomEffects(1))
  head(datasets$errors(1))
</code></pre>

<hr>
<h2 id='generateSensitivityCurveDatasets'>Generate Datasets To Create Sensitivity Curves</h2><span id='topic+generateSensitivityCurveDatasets'></span>

<h3>Description</h3>

<p>This method creates a list of datasets that can be used to create
sensitivity curves. The response of the dataset is modified according to the
supplied arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSensitivityCurveDatasets(
  data,
  observationsToChange,
  shifts,
  scales,
  center,
  formula,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_data">data</code></td>
<td>
<p>dataset to be modified.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_observationstochange">observationsToChange</code></td>
<td>
<p>index or logical vector indicating which
observations should be modified.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_shifts">shifts</code></td>
<td>
<p>vector of shifts that should be applied one by one to each of
the modified observations.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_scales">scales</code></td>
<td>
<p>vector scales that should be used to scale the observations
around their original center.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_center">center</code></td>
<td>
<p>optional scalar used to define the center from which the
observations are scaled from. If missing, the mean of all the changed
observations is used.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_formula">formula</code></td>
<td>
<p>formula to fit the model using <code>lmer</code>.</p>
</td></tr>
<tr><td><code id="generateSensitivityCurveDatasets_+3A_...">...</code></td>
<td>
<p>all additional arguments are added to the returned list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>shifts</code> or <code>scales</code> need to be provided. Both are also
possible.
</p>
<p>The argument <code>shifts</code> contains all the values that shall be added to
each of the observations that should be changed. One value per generated
dataset.
</p>
<p>The argument <code>scales</code> contains all the values that shall be used to
move observations away from their center. If <code>scales</code> is provided, then
<code>observationsToChange</code> needs to select more than one observation.
</p>
<p>The returned list can be passed to <code><a href="#topic+processFit">processFit</a></code> and to any of
the <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions. Splitting and binding of datasets
using <code><a href="#topic+splitDatasets">splitDatasets</a></code> and <code><a href="#topic+bindDatasets">bindDatasets</a></code> is not
supported.
</p>


<h3>Value</h3>

<p>list that can be passed to <code><a href="#topic+processFit">processFit</a></code> and to any of
the <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions. Only <code>generateData</code> is
implemented, all the other functions return an error if called.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oneWay &lt;- generateAnovaDatasets(1, 1, 10, 5)
  datasets &lt;-
      generateSensitivityCurveDatasets(oneWay$generateData(1),
                                       observationsToChange = 1:5,
                                       shifts = -10:10,
                                       formula = oneWay$formula)
  datasets$generateData(1)
</code></pre>

<hr>
<h2 id='getME'>Extract or Get Generalize Components from a Fitted Mixed Effects Model</h2><span id='topic+getME.rlmerMod'></span><span id='topic+getME'></span><span id='topic+theta'></span>

<h3>Description</h3>

<p>Extract (or &ldquo;get&rdquo;) &ldquo;components&rdquo; &ndash; in a generalized
sense &ndash; from a fitted mixed-effects model, i.e. from an object
of class <code><a href="#topic+rlmerMod-class">rlmerMod</a></code> or <code><a href="lme4.html#topic+merMod-class">merMod</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlmerMod'
getME(
  object,
  name = c("X", "Z", "Zt", "Ztlist", "mmList", "y", "mu", "u", "b.s", "b", "Gp", "Tp",
    "Lambda", "Lambdat", "Tlist", "A", "U_b", "Lind", "sigma", "flist", "fixef", "beta",
    "theta", "ST", "is_REML", "n_rtrms", "n_rfacs", "N", "n", "p", "q", "p_i", "l_i",
    "q_i", "k", "m_i", "m", "cnms", "devcomp", "offset", "lower", "rho_e", "rho_b",
    "rho_sigma_e", "rho_sigma_b", "M", "w_e", "w_b", "w_b_vector", "w_sigma_e",
    "w_sigma_b", "w_sigma_b_vector"),
  ...
)

theta(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getME_+3A_object">object</code></td>
<td>
<p>a fitted mixed-effects model of class
<code><a href="#topic+rlmerMod-class">rlmerMod</a></code>, i.e. typically the result of
<code><a href="#topic+rlmer">rlmer</a>()</code>.</p>
</td></tr>
<tr><td><code id="getME_+3A_name">name</code></td>
<td>
<p>a character string specifying the name of the
&ldquo;component&rdquo;.  Possible values are:<br />
</p>

<dl>
<dt><code>"X"</code>:</dt><dd><p>fixed-effects model matrix</p>
</dd>
<dt><code>"Z"</code>:</dt><dd><p>random-effects model matrix</p>
</dd>
<dt><code>"Zt"</code>:</dt><dd><p>transpose of random-effects model matrix</p>
</dd>
<dt><code>"Ztlist"</code>:</dt><dd><p>list of components of the transpose of the random-effects model matrix,
separated by individual variance component</p>
</dd>
<dt><code>"mmList"</code>:</dt><dd><p>list of raw model matrices associated with random effects terms</p>
</dd>
<dt><code>"y"</code>:</dt><dd><p>response vector</p>
</dd>
<dt><code>"mu"</code>:</dt><dd><p>conditional mean of the response</p>
</dd>
<dt><code>"u"</code>:</dt><dd><p>conditional mode of the &ldquo;spherical&rdquo; random effects variable</p>
</dd>
<dt><code>"b.s"</code>:</dt><dd><p>synonym for &ldquo;u&rdquo;</p>
</dd>
<dt><code>"b"</code>:</dt><dd><p>conditional mode of the random effects variable</p>
</dd>
<dt><code>"Gp"</code>:</dt><dd><p>groups pointer vector.  A pointer to the beginning of each group
of random effects corresponding to the random-effects terms.</p>
</dd>
<dt><code>"Tp"</code>:</dt><dd><p>theta pointer vector.  A pointer to the beginning
of the theta sub-vectors corresponding to the
random-effects terms, beginning with 0 and including
a final element giving the total number of random effects</p>
</dd>
<dt><code>"Lambda"</code>:</dt><dd><p>relative covariance factor of the random effects.</p>
</dd>
<dt><code>"U_b"</code>:</dt><dd><p>synonym for &ldquo;Lambda&rdquo;</p>
</dd>
<dt><code>"Lambdat"</code>:</dt><dd><p>transpose of the relative covariance factor of the random effects.</p>
</dd>
<dt><code>"Lind"</code>:</dt><dd><p>index vector for inserting elements of <code class="reqn">\theta</code> into the
nonzeros of <code class="reqn">\Lambda</code></p>
</dd>
<dt><code>"A"</code>:</dt><dd><p>Scaled sparse model matrix (class
<code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>) for
the unit, orthogonal random effects, <code class="reqn">U</code>,
equal to <code>getME(.,"Zt") %*% getME(.,"Lambdat")</code></p>
</dd>
<dt><code>"sigma"</code>:</dt><dd><p>residual standard error</p>
</dd>
<dt><code>"flist"</code>:</dt><dd><p>a list of the grouping variables (factors) involved in the random effect terms</p>
</dd>
<dt><code>"fixef"</code>:</dt><dd><p>fixed-effects parameter estimates</p>
</dd>
<dt><code>"beta"</code>:</dt><dd><p>fixed-effects parameter estimates (identical to the result of <code><a href="lme4.html#topic+fixef">fixef</a></code>, but without names)</p>
</dd>
<dt><code>"theta"</code>:</dt><dd><p>random-effects parameter estimates: these are parameterized as the relative Cholesky factors of each random effect term</p>
</dd>
<dt><code>"ST"</code>:</dt><dd><p>A list of S and T factors in the TSST' Cholesky
factorization of the relative variance matrices of the random
effects associated with each random-effects term.  The unit lower
triangular matrix, <code class="reqn">T</code>, and the diagonal matrix, <code class="reqn">S</code>, for
each term are stored as a single matrix with diagonal elements
from <code class="reqn">S</code> and off-diagonal elements from <code class="reqn">T</code>.</p>
</dd>
<dt><code>"is_REML"</code>:</dt><dd><p>returns <code>TRUE</code> for rlmerMod-objects (for compatibility with lme4)</p>
</dd>
<dt><code>"n_rtrms"</code>:</dt><dd><p>number of random-effects terms</p>
</dd>
<dt><code>"n_rfacs"</code>:</dt><dd><p>number of distinct random-effects grouping factors</p>
</dd>
<dt><code>"N"</code>:</dt><dd><p>number of rows of <code>X</code></p>
</dd>
<dt><code>"n"</code>:</dt><dd><p>length of the response vector, <code>y</code></p>
</dd>
<dt><code>"p"</code>:</dt><dd><p>number of columns of the fixed effects model matrix, <code>X</code></p>
</dd>
<dt><code>"q"</code>:</dt><dd><p>number of columns of the random effects model matrix, <code>Z</code></p>
</dd>
<dt><code>"p_i"</code>:</dt><dd><p>numbers of columns of the raw model matrices, <code>mmList</code></p>
</dd>
<dt><code>"l_i"</code>:</dt><dd><p>numbers of levels of the grouping factors</p>
</dd>
<dt><code>"q_i"</code>:</dt><dd><p>numbers of columns of the term-wise model matrices, <code>ZtList</code></p>
</dd>
<dt><code>"k"</code>:</dt><dd><p>number of random effects terms</p>
</dd>
<dt><code>"m_i"</code>:</dt><dd><p>numbers of covariance parameters in each term</p>
</dd>
<dt><code>"m"</code>:</dt><dd><p>total number of covariance parameters, i.e., the
same as <code>dim@nth</code> below.</p>
</dd>
<dt><code>"cnms"</code>:</dt><dd><p>the &ldquo;component names&rdquo;, a &lsquo;list&rsquo;.</p>
</dd>
<dt><code>"devcomp"</code>:</dt><dd><p>a list consisting of a named numeric vector,
<code>cmp</code>, and a named integer vector, <code>dims</code>, describing
the fitted model.  The elements of <code>cmp</code> are:<br />
</p>

<dl>
<dt>ldL2</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>ldRX2</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>wrss</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>ussq</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>pwrss</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>drsum</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>REML</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>dev</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>sigmaML</dt><dd><p>always NA, for consistency with lme4 output</p>
</dd>
<dt>sigmaREML</dt><dd><p>REML estimate of residual standard deviation</p>
</dd>
</dl>
<p> The elements of <code>dims</code> are:<br />
</p>

<dl>
<dt>N</dt><dd><p>number of rows of <code>X</code></p>
</dd>
<dt>n</dt><dd><p>length of <code>y</code></p>
</dd>
<dt>p</dt><dd><p>number of columns of <code>X</code></p>
</dd>
<dt>nmp</dt><dd><p><code>n-p</code></p>
</dd>
<dt>nth</dt><dd><p>length of <code>theta</code></p>
</dd>
<dt>q</dt><dd><p>number of columns of <code>Z</code></p>
</dd>
<dt>nAGQ</dt><dd><p>see <code><a href="lme4.html#topic+glmer">glmer</a></code></p>
</dd>
<dt>compDev</dt><dd><p>see <code><a href="lme4.html#topic+glmerControl">glmerControl</a></code></p>
</dd>
<dt>useSc</dt><dd><p><code>TRUE</code> if model has a scale parameter</p>
</dd>
<dt>reTrms</dt><dd><p>number of random effects terms</p>
</dd>
<dt>REML</dt><dd><p><code>0</code> indicates the model was fitted by maximum
likelihood, any other positive integer indicates fitting by
restricted maximum likelihood</p>
</dd>
<dt>GLMM</dt><dd><p><code>TRUE</code> if a GLMM</p>
</dd>
<dt>NLMM</dt><dd><p><code>TRUE</code> if an NLMM</p>
</dd>
</dl>

</dd>
<dt><code>"offset"</code>:</dt><dd><p>model offset</p>
</dd>
<dt><code>"lower"</code>:</dt><dd><p>lower bounds on random-effects model
parameters (i.e, &quot;theta&quot; parameters). In order to constrain
random effects covariance matrices to be semi-positive-definite,
this vector is equal to 0 for elements of
the <code>theta</code> vector corresponding to diagonal elements of
the Cholesky factor, <code>-Inf</code>
otherwise. (<code>getME(.,"lower")==0</code> can be used as a test to
identify diagonal elements, as in <code>isSingular</code>.)
</p>
</dd>
<dt><code>"rho_e"</code>:</dt><dd><p>rho function used for the residuals</p>
</dd>
<dt><code>"rho_b"</code>:</dt><dd><p>list of rho functions used for the random effects</p>
</dd>
<dt><code>"rho_sigma_e"</code>:</dt><dd><p>rho function used for the residuals when estimating sigma</p>
</dd>
<dt><code>"rho_sigma_b"</code>:</dt><dd><p>list of rho functions used for the random effects when estimating the covariance parameters</p>
</dd>
<dt><code>"M"</code>:</dt><dd><p>list of matrices, blocks of the Henderson's equations and the matrices used for computing the linear approximations of the estimates of beta and spherical random effects.</p>
</dd>
<dt><code>"w_e"</code>:</dt><dd><p>robustness weights associated with the observations</p>
</dd>
<dt><code>"w_b"</code>:</dt><dd><p>robustness weights associated with the spherical random effects, returned in the same format as <code><a href="lme4.html#topic+ranef">ranef</a>()</code></p>
</dd>
<dt><code>"w_b_vector"</code>:</dt><dd><p>robustness weights associated with the spherical random effects, returned as one long vector</p>
</dd>
<dt><code>"w_sigma_e"</code>:</dt><dd><p>robustness weights associated with the observations when estimating sigma</p>
</dd>
<dt><code>"w_sigma_b"</code>:</dt><dd><p>robustness weights associated with the spherical random effects when estimating the covariance parameters, returned in the same format as <code><a href="lme4.html#topic+ranef">ranef</a>()</code></p>
</dd>
<dt><code>"w_sigma_b_vector"</code>:</dt><dd><p>robustness weights associated with the spherical random effects when estimating the covariance parameters, returned as one long vector</p>
</dd>

<dt><code>"ALL"</code>:</dt><dd><p>get all of the above as a <code><a href="base.html#topic+list">list</a></code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="getME_+3A_...">...</code></td>
<td>
<p>potentially further arguments; not here.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>theta</code> is short for <code>getME(, "theta")</code>.
</p>
<p>The goal is to provide &ldquo;everything a user may want&rdquo; from a fitted
<code>rlmerMod</code> object <em>as far</em> as it is not available by methods, such
as <code><a href="lme4.html#topic+fixef">fixef</a></code>, <code><a href="lme4.html#topic+ranef">ranef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, etc.
</p>


<h3>Value</h3>

<p>Unspecified, as very much depending on the <code><a href="base.html#topic+name">name</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+getCall">getCall</a>()</code>;
more standard methods for rlmerMod objects, such as <code><a href="lme4.html#topic+ranef">ranef</a></code>,
<code><a href="lme4.html#topic+fixef">fixef</a></code>, <code><a href="stats.html#topic+vcov">vcov</a></code>, etc.:
see <code>methods(class="rlmerMod")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## shows many methods you should consider *before* using getME():
methods(class = "rlmerMod")

## doFit = FALSE to speed up example
(fm1 &lt;- rlmer(Reaction ~ Days + (Days|Subject), sleepstudy,
              method="DASvar", doFit=FALSE))
Z &lt;- getME(fm1, "Z")
stopifnot(is(Z, "CsparseMatrix"),
          c(180,36) == dim(Z),
	  all.equal(fixef(fm1), b1 &lt;- getME(fm1, "beta"),
		    check.attributes=FALSE, tolerance = 0))

## A way to get *all* getME()s :
## internal consistency check ensuring that all work:
parts &lt;- getME(fm1, "ALL")
str(parts, max=2)
stopifnot(identical(Z,  parts $ Z),
          identical(b1, parts $ beta))
stopifnot(all.equal(theta(fm1), getME(fm1, "theta")))
</code></pre>

<hr>
<h2 id='lapplyDatasets'>Lapply for generated datasets</h2><span id='topic+lapplyDatasets'></span>

<h3>Description</h3>

<p>Apply function for all generated datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lapplyDatasets(datasets, FUN, ..., label, POST_FUN, datasetIndices = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lapplyDatasets_+3A_datasets">datasets</code></td>
<td>
<p>Datasets list to be used to generate datasets.</p>
</td></tr>
<tr><td><code id="lapplyDatasets_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied to each generated dataset. The
function will be called like <code>FUN(data, ...)</code>.</p>
</td></tr>
<tr><td><code id="lapplyDatasets_+3A_...">...</code></td>
<td>
<p>optional arguments to <code>FUN</code>.</p>
</td></tr>
<tr><td><code id="lapplyDatasets_+3A_label">label</code></td>
<td>
<p>optional parameter, if present, each result is added an
attribute named <em>label</em> with the value of <code>label</code>.</p>
</td></tr>
<tr><td><code id="lapplyDatasets_+3A_post_fun">POST_FUN</code></td>
<td>
<p>function to be applied to the result of <code>FUN</code>. While
one could just modify <code>FUN</code> instead, this additional argument makes
it a bit easier to combine different kinds of methods together.</p>
</td></tr>
<tr><td><code id="lapplyDatasets_+3A_datasetindices">datasetIndices</code></td>
<td>
<p>optional vector of dataset indices to fit, useful to
try only a few datasets instead of all of them. Use <code>"all"</code> to
process all datasets (default).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of results. The items in the resulting list will have two
additional attributes: <code>datasetIndex</code> and <code>proc.time</code>. If
<code>FUN</code> failed for an item, then the item  will be the error as
returned by try, i.e., it ill be of class <code>try-error</code>.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oneWay &lt;- generateAnovaDatasets(2, 1, 5, 4)
  lapplyDatasets(oneWay, function(data) sum(data$y))
  lapplyDatasets(oneWay, function(data) sum(data$y), POST_FUN = function(x) x^2)
</code></pre>

<hr>
<h2 id='loadAndMergePartialResults'>Load And Merge Partial Results</h2><span id='topic+loadAndMergePartialResults'></span>

<h3>Description</h3>

<p>Convenience function that loads the results stored in each of the files and
then calls <code><a href="#topic+mergeProcessedFits">mergeProcessedFits</a></code> to merge them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadAndMergePartialResults(files)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadAndMergePartialResults_+3A_files">files</code></td>
<td>
<p>vector of filenames (including paths) of files containing the
processed results</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+processDatasetsInParallel">processDatasetsInParallel</a></code>
</p>

<hr>
<h2 id='mergeProcessedFits'>Merge Processed Fits</h2><span id='topic+mergeProcessedFits'></span>

<h3>Description</h3>

<p>Combine list of processed fits into one list in matrix form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeProcessedFits(processedFitList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeProcessedFits_+3A_processedfitlist">processedFitList</code></td>
<td>
<p>list of processed fits as produced by
<code><a href="#topic+processFit">processFit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>similar list as returned by <code><a href="#topic+processFit">processFit</a></code> just with
matrix entries instead of vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  preparedDataset &lt;-
      prepareMixedEffectDataset(Reaction ~ Days + (Days|Subject),
                                sleepstudy)
  set.seed(1)
  datasets &lt;- generateMixedEffectDatasets(2, preparedDataset)

  fits &lt;- fitDatasets_lmer(datasets)
  processedFits &lt;- lapply(fits, processFit, all = TRUE)
  merged &lt;- mergeProcessedFits(processedFits)
  str(merged)
</code></pre>

<hr>
<h2 id='other'>Other methods</h2><span id='topic+show'></span><span id='topic+show+2CRcpp_SmoothPsi-method'></span><span id='topic+show+2CRcpp_HuberPsi-method'></span><span id='topic+show+2CRcpp_PsiFunction-method'></span><span id='topic+show+2CRcpp_PsiFunctionToPropIIPsiFunctionWrapper-method'></span>

<h3>Description</h3>

<p>Other miscellaneous utilities for instances of the PsiFunction class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_SmoothPsi'
show(object)
## S4 method for signature 'Rcpp_HuberPsi'
show(object)
## S4 method for signature 'Rcpp_PsiFunction'
show(object)
## S4 method for signature 'Rcpp_PsiFunctionToPropIIPsiFunctionWrapper'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="other_+3A_object">object</code></td>
<td>
<p>instance of class <code>PsiFunction</code> to be plotted</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>show(smoothPsi)
</code></pre>

<hr>
<h2 id='partialMoment_standardNormal'>Compute Partial Moments</h2><span id='topic+partialMoment_standardNormal'></span>

<h3>Description</h3>

<p>Computes a partial moment for the standard normal distribution. This is the
expectation taken not from -Infinity to Infinity but just to <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partialMoment_standardNormal(z, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partialMoment_standardNormal_+3A_z">z</code></td>
<td>
<p>partial moment boundary, the expectation is taken from -Inf to z.</p>
</td></tr>
<tr><td><code id="partialMoment_standardNormal_+3A_n">n</code></td>
<td>
<p>which moment to compute, needs to be &gt;= 2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Winkler, R. L., Roodman, G. M., &amp; Britney, R. R. (1972). The
Determination of Partial Moments. Management Science, 19(3), 290–296.
http://www.jstor.org/stable/2629511, equation (2.5)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  partialMoment_standardNormal(0, 2)
</code></pre>

<hr>
<h2 id='plot-methods'>Plot an Object of the &quot;Psi Function&quot; Class</h2><span id='topic+plot-methods'></span><span id='topic+plot+2CRcpp_SmoothPsi-method'></span><span id='topic+plot+2CRcpp_HuberPsi-method'></span><span id='topic+plot+2CRcpp_PsiFunction-method'></span><span id='topic+plot+2CRcpp_PsiFunctionToPropIIPsiFunctionWrapper-method'></span>

<h3>Description</h3>

<p>The <code><a href="base.html#topic+plot">plot</a></code> method objects of class
<code>PsiFunction</code> simply visualizes the
<code class="reqn">\rho()</code>, <code class="reqn">\psi()</code>, and weight functions and their
derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Rcpp_SmoothPsi'
plot(x, y,
     which = c("rho", "psi", "Dpsi", "wgt", "Dwgt"),
     main = "full", 
     col = c("black", "red3", "blue3", "dark green", "light green"),
     leg.loc = "right", ...)
## S4 method for signature 'Rcpp_HuberPsi'
plot(x, y,
     which = c("rho", "psi", "Dpsi", "wgt", "Dwgt"),
     main = "full", 
     col = c("black", "red3", "blue3", "dark green", "light green"),
     leg.loc = "right", ...)
## S4 method for signature 'Rcpp_PsiFunction'
plot(x, y,
     which = c("rho", "psi", "Dpsi", "wgt", "Dwgt"),
     main = "full", 
     col = c("black", "red3", "blue3", "dark green", "light green"),
     leg.loc = "right", ...)
## S4 method for signature 'Rcpp_PsiFunctionToPropIIPsiFunctionWrapper'
plot(x, y,
     which = c("rho", "psi", "Dpsi", "wgt", "Dwgt"),
     main = "full", 
     col = c("black", "red3", "blue3", "dark green", "light green"),
     leg.loc = "right", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>instance of class <code>PsiFunction</code> to be plotted</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_y">y</code></td>
<td>
<p>(optional) vector of abscissa values (to plot object at).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_which">which</code></td>
<td>
<p><code><a href="base.html#topic+character">character</a></code> vector of slots to be included in
plot; by default, all of the slots are included</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_main">main</code></td>
<td>
<p>string or logical indicating the kind of plot title;
either <code>"full"</code>, <code>"short"</code> or <code>FALSE</code> which chooses a
full, a short or no main title at all.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_col">col</code></td>
<td>
<p>colors to be used for the different slots</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_leg.loc">leg.loc</code></td>
<td>
<p>legend placement, see also <code>x</code> argument
of <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="graphics.html#topic+matplot">matplot</a></code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>If you want to specify your own title, use <code>main=FALSE</code>, and a
subsequent <code><a href="graphics.html#topic+title">title</a>(...)</code> call.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+psi-functions">psi-functions</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(huberPsiRcpp)
plot(huberPsiRcpp, which=c("psi", "Dpsi", "wgt"),
     main="short", leg = "topleft")

plot(smoothPsi)
## Plotting aspect ratio = 1:1 :
plot(smoothPsi, asp=1, main="short",
     which = c("psi", "Dpsi", "wgt", "Dwgt"))
</code></pre>

<hr>
<h2 id='plot.rlmerMod'>Plot Method for &quot;rlmerMod&quot; objects.</h2><span id='topic+plot.rlmerMod'></span><span id='topic+print.rlmerMod_plots'></span>

<h3>Description</h3>

<p>Diagnostic plots for objects of class <code>rlmerMod</code> and <code>lmerMod</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlmerMod'
plot(
  x,
  y = NULL,
  which = 1:4,
  title = c("Fitted Values vs. Residuals", "Normal Q-Q vs. Residuals",
    "Normal Q-Q vs. Random Effects", "Scatterplot of Random Effects for Group \"%s\""),
  multiply.weights = FALSE,
  add.line = c("above", "below", "none"),
  ...
)

## S3 method for class 'rlmerMod_plots'
print(x, ask = interactive() &amp; length(x) &gt; 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rlmerMod_+3A_x">x</code></td>
<td>
<p>an object as created by <code>rlmer</code> or <code>rlmer</code>; or an object
as created by <code>plot.rlmerMod</code></p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_y">y</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_which">which</code></td>
<td>
<p>integer number between 1 and 4 to specify which plot is
desired.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_title">title</code></td>
<td>
<p>Titles for the different plots. The fourth item can be a format
string passed to <code>sprintf</code> to add the name of the current group.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_multiply.weights">multiply.weights</code></td>
<td>
<p>multiply the residuals / random effects with the
robustness weights when producing the Q-Q plots.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_add.line">add.line</code></td>
<td>
<p>add reference line to plots, use <code>"above"</code> or
<code>"below"</code> to show the line above or below the points. Hide the line
with <code>"none"</code>.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="ggplot2.html#topic+geom_hline">geom_hline</a></code> and
<code><a href="ggplot2.html#topic+geom_qq_line">geom_qq_line</a></code>, to customize how the line is drawn.</p>
</td></tr>
<tr><td><code id="plot.rlmerMod_+3A_ask">ask</code></td>
<td>
<p>waits for user input before displaying each plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The robustness weights for estimating the fixed and random effects are used
in the plots, e.g., the ones returned by <code>getME(object, "w_e")</code> and
<code>getME(object, "w_b")</code>.
</p>


<h3>Value</h3>

<p>a list of plots of class <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> that can be
used for further modification before plotting (using <code>print</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getME">getME</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  rfm &lt;- rlmer(Yield ~ (1|Batch), Dyestuff)
  plot(rfm)
  fm &lt;- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)
  plot.rlmerMod(fm)

## End(Not run)
</code></pre>

<hr>
<h2 id='prepareMixedEffectDataset'>Prepare Dataset for Parametric Bootstrap</h2><span id='topic+prepareMixedEffectDataset'></span>

<h3>Description</h3>

<p>This function runs <code><a href="lme4.html#topic+lmer">lmer</a></code> and extracts all information needed to
generate new datasets using parametric bootstrap later.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareMixedEffectDataset(
  formula,
  data,
  REML = TRUE,
  overrideBeta,
  overrideSigma,
  overrideTheta,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepareMixedEffectDataset_+3A_formula">formula</code></td>
<td>
<p>passed on to <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_data">data</code></td>
<td>
<p>passed on to <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_reml">REML</code></td>
<td>
<p>passed on to <code><a href="lme4.html#topic+lmer">lmer</a></code></p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_overridebeta">overrideBeta</code></td>
<td>
<p>use to override beta used to simulate new datasets, by
default <code><a href="#topic+getME">getME</a></code><code>(fm, "beta")</code> where <code>fm</code> is the
fitted model returned by <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_overridesigma">overrideSigma</code></td>
<td>
<p>use to override sigma used to simulate new datasets, by
default <code><a href="#topic+getME">getME</a></code><code>(fm, "sigma")</code> where <code>fm</code> is the
fitted model returned by <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_overridetheta">overrideTheta</code></td>
<td>
<p>use to override theta used to simulate new datasets, by
default <code><a href="#topic+getME">getME</a></code><code>(fm, "theta")</code> where <code>fm</code> is the
fitted model returned by <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="prepareMixedEffectDataset_+3A_...">...</code></td>
<td>
<p>all additional arguments are added to the returned list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List that can be passed to
<code><a href="#topic+generateMixedEffectDatasets">generateMixedEffectDatasets</a></code>. </p>
<table>
<tr><td><code>data:</code></td>
<td>
<p>the original dataset</p>
</td></tr> <tr><td><code>X:</code></td>
<td>
<p>the X matrix as returned by
<code><a href="#topic+getME">getME</a></code></p>
</td></tr> <tr><td><code>Z:</code></td>
<td>
<p>the Z matrix as returned by
<code><a href="#topic+getME">getME</a></code></p>
</td></tr> <tr><td><code>Lambda:</code></td>
<td>
<p>the Lambda matrix as returned
by <code><a href="#topic+getME">getME</a></code></p>
</td></tr> <tr><td><code>numberOfFixedEffects:</code></td>
<td>
<p>the number of
fixed effects coefficients</p>
</td></tr> <tr><td><code>numberOfRandomEffects:</code></td>
<td>
<p>the
number of random effects</p>
</td></tr> <tr><td><code>numberOfRows:</code></td>
<td>
<p>number of rows in
the generated dataset</p>
</td></tr> <tr><td><code>trueBeta:</code></td>
<td>
<p>true values used for beta</p>
</td></tr>
<tr><td><code>trueSigma:</code></td>
<td>
<p>true value used for sigma</p>
</td></tr>
<tr><td><code>trueTheta:</code></td>
<td>
<p>true values used for theta</p>
</td></tr>
<tr><td><code>formula:</code></td>
<td>
<p>formula to fit the model using <code>lmer</code></p>
</td></tr>
<tr><td><code>...:</code></td>
<td>
<p>additional arguments passed via <code>...</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  preparedDataset &lt;- prepareMixedEffectDataset(Reaction ~ Days + (Days|Subject), sleepstudy)
  str(preparedDataset)
</code></pre>

<hr>
<h2 id='processDatasetsInParallel'>Process Datasets in Parallel</h2><span id='topic+processDatasetsInParallel'></span>

<h3>Description</h3>

<p>Convenience function to run simulation study in parallel on a single
machine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processDatasetsInParallel(
  datasets,
  path,
  baseFilename,
  fittingFunctions,
  chunkSize,
  saveFitted = FALSE,
  checkProcessed = FALSE,
  createMinimalSaveFile = FALSE,
  ncores = 1,
  clusterType = "PSOCK",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processDatasetsInParallel_+3A_datasets">datasets</code></td>
<td>
<p>dataset list generated by one of the generate functions.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_path">path</code></td>
<td>
<p>path to save the datasets to.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_basefilename">baseFilename</code></td>
<td>
<p>filename to use, without extension.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_fittingfunctions">fittingFunctions</code></td>
<td>
<p>vector of <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions that
should be applied to each dataset.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_chunksize">chunkSize</code></td>
<td>
<p>number of datasets to process together in a single job.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_savefitted">saveFitted</code></td>
<td>
<p>logical, if true, the raw fits are also stored.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_checkprocessed">checkProcessed</code></td>
<td>
<p>logical, if true, will check whether the contents of
the processed output is reproduced for the first dataset. This is useful
to ensure that everything is still working as expected without having to
re-run the whole simulation study.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_createminimalsavefile">createMinimalSaveFile</code></td>
<td>
<p>logical, if true, will create a file with the
processed results of the first three datasets. This is helpful if one
wants to store only the final aggregated results but still wants to make
sure that the full code works as expected.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_ncores">ncores</code></td>
<td>
<p>number of cores to use in processing, if set to 1, datasets
are processed in the current R session. Use
<code><a href="parallel.html#topic+detectCores">detectCores</a></code> to find out how many cores are
available on your machine.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_clustertype">clusterType</code></td>
<td>
<p>type of cluster to be created, passed to
<code><a href="parallel.html#topic+makeCluster">makeCluster</a></code>.</p>
</td></tr>
<tr><td><code id="processDatasetsInParallel_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+processFit">processFit</a></code>. Use this to control what
to save.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The merged results are saved in a file taking the name
<code>&lt;path&gt;/&lt;baseFilename&gt;-processed.Rdata</code>. You can delete the
intermediate result files with the numbers (the chunk index) in the name.
</p>
<p>To run on multiple machines, use <code><a href="#topic+saveDatasets">saveDatasets</a></code> to save datasets
into multiple files. Then call <code><a href="#topic+processFile">processFile</a></code> on each of them on
the designated machine. Finally, load and merge the results together using
<code><a href="#topic+loadAndMergePartialResults">loadAndMergePartialResults</a></code>.
</p>


<h3>Value</h3>

<p>The list of all processed results merged together.
</p>
<p>To help reproduciblility, the output of <code>toLatex(sessionInfo(),
  locale = FALSE)</code> is stored in the <code>sessionInfo</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+saveDatasets">saveDatasets</a></code>, <code><a href="#topic+processFile">processFile</a></code>
</p>

<hr>
<h2 id='processFile'>Process File of Stored Datasets</h2><span id='topic+processFile'></span>

<h3>Description</h3>

<p>Call this function for each file stored using <code><a href="#topic+saveDatasets">saveDatasets</a></code>. If
a file hasn't been processed yet, then it is processed and a new file with
the postfix &ldquo;processed&rdquo; is created containing the results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processFile(
  file,
  fittingFunctions,
  saveFitted = FALSE,
  checkProcessed = FALSE,
  createMinimalSaveFile = FALSE,
  datasets,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processFile_+3A_file">file</code></td>
<td>
<p>file saved by <code><a href="#topic+saveDatasets">saveDatasets</a></code>.</p>
</td></tr>
<tr><td><code id="processFile_+3A_fittingfunctions">fittingFunctions</code></td>
<td>
<p>vector of <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions that
should be applied to each dataset.</p>
</td></tr>
<tr><td><code id="processFile_+3A_savefitted">saveFitted</code></td>
<td>
<p>logical, if true, the raw fits are also stored.</p>
</td></tr>
<tr><td><code id="processFile_+3A_checkprocessed">checkProcessed</code></td>
<td>
<p>logical, if true, will check whether the contents of
the processed output is reproduced for the first dataset. This is useful
to ensure that everything is still working as expected without having to
re-run the whole simulation study.</p>
</td></tr>
<tr><td><code id="processFile_+3A_createminimalsavefile">createMinimalSaveFile</code></td>
<td>
<p>logical, if true, will create a file with the
processed results of the first three datasets. This is helpful if one
wants to store only the final aggregated results but still wants to make
sure that the full code works as expected.</p>
</td></tr>
<tr><td><code id="processFile_+3A_datasets">datasets</code></td>
<td>
<p>optional, datasets as stored in <code>file</code>, to avoid doing
a detour of saving and loading the file.</p>
</td></tr>
<tr><td><code id="processFile_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+processFit">processFit</a></code>. Use this to control what
to save.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case the raw fits may have to be inspected or <code><a href="#topic+processFit">processFit</a></code>
may be called with another set of arguments, then set <code>saveFitted</code> to
TRUE. In that case, another file with the postfix &ldquo;fitted&rdquo; is
created. Remove the files with postfix &ldquo;processed&rdquo; and run
<code>processFile</code> again. The fits will not be re-done but instead loaded
from the file with postfix &ldquo;fitted&rdquo;.
</p>


<h3>Value</h3>

<p>The list of all processed results merged together.
</p>
<p>To help reproduciblility, the output of <code>toLatex(sessionInfo(),
  locale = FALSE)</code> is stored in the <code>sessionInfo</code> attribute.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>

<hr>
<h2 id='processFit'>Process Fitted Objects</h2><span id='topic+processFit'></span><span id='topic+processFit.lmerMod'></span><span id='topic+processFit.rlmerMod'></span><span id='topic+processFit.heavyLme'></span><span id='topic+processFit.lqmm'></span><span id='topic+processFit.rlme'></span><span id='topic+processFit.varComprob'></span>

<h3>Description</h3>

<p>Methods to process fitted objects and convert into a data structure that is
useful in post-processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'lmerMod'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'rlmerMod'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'heavyLme'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'lqmm'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'rlme'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  ...
)

## S3 method for class 'varComprob'
processFit(
  obj,
  all = FALSE,
  coefs = TRUE,
  stdErrors = all,
  tValues = all,
  sigma = TRUE,
  thetas = TRUE,
  b = all,
  meanB = all,
  meanAbsB = all,
  residuals = all,
  converged = TRUE,
  numWarnings = all,
  procTime = all,
  isInterceptCorrelationSlopeModel,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="processFit_+3A_obj">obj</code></td>
<td>
<p>object returned by the fitting method.</p>
</td></tr>
<tr><td><code id="processFit_+3A_all">all</code></td>
<td>
<p>logical, shorthand to enable all exports.</p>
</td></tr>
<tr><td><code id="processFit_+3A_coefs">coefs</code></td>
<td>
<p>logical, if true coefficients are added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_stderrors">stdErrors</code></td>
<td>
<p>logical, if true, standard errors are added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_tvalues">tValues</code></td>
<td>
<p>logical, if true, t-values are added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_sigma">sigma</code></td>
<td>
<p>logical, if true, sigma is added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_thetas">thetas</code></td>
<td>
<p>logical, if true, thetas are added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_b">b</code></td>
<td>
<p>scalar logical or index vector, if true, all random effects are
added to export. If an index vector is given, then only the corresponding
random effects are added to the export. The same order as in <code>lmer</code>
is used for all methods.</p>
</td></tr>
<tr><td><code id="processFit_+3A_meanb">meanB</code></td>
<td>
<p>logical, if true, the mean of the random effects is added to
the export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_meanabsb">meanAbsB</code></td>
<td>
<p>logical, if true, the mean of the absolute value of the
random effects is added to the export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_residuals">residuals</code></td>
<td>
<p>scalar logical or index vector, similar to argument
<code>b</code>, just returning the residuals.</p>
</td></tr>
<tr><td><code id="processFit_+3A_converged">converged</code></td>
<td>
<p>logical, if true, convergence code is added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_numwarnings">numWarnings</code></td>
<td>
<p>logical, if true, the number of warnings generated during
the fitting process is added to export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_proctime">procTime</code></td>
<td>
<p>logical, if true, time needed to fit object is added to
export.</p>
</td></tr>
<tr><td><code id="processFit_+3A_...">...</code></td>
<td>
<p>optional parameters used for some implementations.</p>
</td></tr>
<tr><td><code id="processFit_+3A_isinterceptcorrelationslopemodel">isInterceptCorrelationSlopeModel</code></td>
<td>
<p>optional logical, can be used to
override the assumption that a model with three variance components can be
interpreted as having intercept, correlation and slope.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Warning. <code>processFit.varComprob</code> uses simplistic logic to
convert from the parameterisation used in the robustvarComp package to
<code>theta</code> as used in <code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="#topic+rlmer">rlmer</a></code>. If
there are three variance components, the code assumes that they are
intercept, correlation and slope. Otherwise the code assumes that the
variance components are independent. Exports <code>b</code> and <code>residuals</code>
are not supported.
</p>


<h3>Value</h3>

<p>List with extracted values, most items can be suppressed
to save disk space.
</p>
<table>
<tr><td><code>label:</code></td>
<td>
<p>Name of fitting method used to create the fit</p>
</td></tr>
<tr><td><code>datasetIndex:</code></td>
<td>
<p>Index of the dataset in the dataset list</p>
</td></tr>
<tr><td><code>coefficients:</code></td>
<td>
<p>Vector of estimated fixed-effects coefficients of the fitted model</p>
</td></tr>
<tr><td><code>standardErrors:</code></td>
<td>
<p>Vector of estimated standard errors of the fixed-effects coefficients</p>
</td></tr>
<tr><td><code>tValues:</code></td>
<td>
<p>Vector of t-Values (or z-Values depending on fitting method)
of the fixed-effects coefficients</p>
</td></tr>
<tr><td><code>sigma:</code></td>
<td>
<p>Estimated residual standard error</p>
</td></tr>
<tr><td><code>thetas:</code></td>
<td>
<p>Vector of random-effects parameter estimates. As parameterized as by
<code><a href="lme4.html#topic+lmer">lmer</a></code> and <code><a href="#topic+rlmer">rlmer</a></code>.</p>
</td></tr>
<tr><td><code>b:</code></td>
<td>
<p>Vector of requested predicted random-effects.</p>
</td></tr>
<tr><td><code>meanB:</code></td>
<td>
<p>Vector of means of the predicted random-effects.</p>
</td></tr>
<tr><td><code>meanAbsB:</code></td>
<td>
<p>Vector of means of the absolute values of the  predicted random-effects.</p>
</td></tr>
<tr><td><code>residuals:</code></td>
<td>
<p>Vector of requested residuals.</p>
</td></tr>
<tr><td><code>converged:</code></td>
<td>
<p>Convergence status as reported by the fitting method. <code>0</code> means converged.
If not available, <code>NA</code> is used. Other values are to be interpreted carefully as codes
vary from method to method.</p>
</td></tr>
<tr><td><code>numberOfWarnings:</code></td>
<td>
<p>the number of warnings generated during the fitting process.</p>
</td></tr>
<tr><td><code>proc.time:</code></td>
<td>
<p>Vector of times (user, system, elapsed) as reported by <code><a href="base.html#topic+proc.time">proc.time</a></code>
required to fit the model.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(1)
  oneWay &lt;- generateAnovaDatasets(1, 1, 10, 4,
                                  lmeFormula = y ~ 1,
                                  heavyLmeRandom = ~ 1,
                                  heavyLmeGroups = ~ Var2,
                                  lqmmRandom = ~ 1,
                                  lqmmGroup = "Var2",
                                  groups = cbind(rep(1:4, each = 10), rep(1:10, 4)),
                                  varcov = matrix(1, 4, 4),
                                  lower = 0)
  processFit(fitDatasets_lmer(oneWay)[[1]], all = TRUE)
  processFit(fitDatasets_rlmer_DASvar(oneWay)[[1]], all = TRUE)
  ## Not run: 
    processFit(fitDatasets_heavyLme(oneWay)[[1]], all = TRUE)
  
## End(Not run)
  if (require(lqmm)) {
    processFit(fitDatasets_lqmm(oneWay)[[1]], all = TRUE)
  }
  ## Not run: 
    processFit(fitDatasets_varComprob_compositeTau(oneWay)[[1]], all = TRUE)
  
## End(Not run)
</code></pre>

<hr>
<h2 id='psi-functions'>Classical, Huber and smoothed Huber psi- or rho-functions</h2><span id='topic+psi-functions'></span><span id='topic+cPsi'></span><span id='topic+smoothPsi'></span><span id='topic+SmoothPsi'></span><span id='topic+PsiFunction'></span><span id='topic+huberPsiRcpp'></span>

<h3>Description</h3>

<p><code class="reqn">\psi</code>-functions are used by <code><a href="#topic+rlmer">rlmer</a></code> in the estimating
equations and to compute robustness weights. Change tuning parameters using
<code><a href="#topic+chgDefaults">chgDefaults</a></code> and convert to squared robustness weights using
the <code><a href="#topic+psi2propII">psi2propII</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## see examples
</code></pre>


<h3>Details</h3>

<p>The <b>&ldquo;classical&rdquo; <code class="reqn">\psi</code>-function <code>cPsi</code></b> can be
used to get a non-robust, i.e., classical, fit. The <code>psi</code> slot equals
the identity function, and the <code>rho</code> slot equals quadratic function.
Accordingly, the robustness weights will always be 1 when using <code>cPsi</code>.
</p>
<p>The <b>Huber <code class="reqn">\psi</code>-function <code>huberPsi</code></b> is identical to
the one in the package <code>robustbase</code>. The <code>psi</code> slot equals the
identity function within <code class="reqn">\pm k</code> (where <code class="reqn">k</code> is the tuning
parameter). Outside this interval it is equal to <code class="reqn">\pm k</code>. The
<code>rho</code> slot equals the quadratic function within <code class="reqn">\pm k</code> and a
linear function outside.
</p>
<p>The <b>smoothed Huber <code class="reqn">\psi</code>-function</b> is very similar to the
regular Huber <code class="reqn">\psi</code>-function. Instead of a sharp bend like the
Huber function, the smoothed Huber function bends smoothly. The first tuning
contant, k, can be compared to the tuning constant of the original Huber
function. The second tuning constant, s, determines the smoothness of the
bend.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chgDefaults">chgDefaults</a></code> and <code><a href="#topic+psi2propII">psi2propII</a></code> for changing
tuning parameters; <code><a href="robustbase.html#topic+psi_func-class">psi_func-class</a></code> for a more detailed
description of the slots;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(cPsi)
plot(huberPsiRcpp)
plot(smoothPsi)
curve(cPsi@psi(x), 0, 3, col="blue")
curve(smoothPsi@psi(x), 0, 3, add=TRUE)
curve(huberPsiRcpp@psi(x), 0, 3, add=TRUE, col="green")
</code></pre>

<hr>
<h2 id='psi2propII'>Convert to Proposal 2 weight function</h2><span id='topic+psi2propII'></span><span id='topic+psi2propII+2CRcpp_SmoothPsi'></span><span id='topic+psi2propII+2Cpsi_func_rcpp-method'></span>

<h3>Description</h3>

<p>Converts the psi_func object into a function that corresponds to Proposal
2, i.e., a function of the squared weights. The other elements of the
psi_func object are adapted accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi2propII(object, ..., adjust = FALSE)

## S4 method for signature 'psi_func_rcpp'
psi2propII(object, ..., adjust = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi2propII_+3A_object">object</code></td>
<td>
<p>instance of Rcpp_PsiFunction class to convert</p>
</td></tr>
<tr><td><code id="psi2propII_+3A_...">...</code></td>
<td>
<p>optional, new default arguments passed to chgDefaults.</p>
</td></tr>
<tr><td><code id="psi2propII_+3A_adjust">adjust</code></td>
<td>
<p>logical, whether tuning parameters should be adjusted
automatically, such that the scale estimate has the same asymptotic
efficiency as the location estimate.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>par(mfrow=c(2,1))
plot(smoothPsi)
plot(psi2propII(smoothPsi))
</code></pre>

<hr>
<h2 id='residuals.rlmerMod'>Get residuals</h2><span id='topic+residuals.rlmerMod'></span>

<h3>Description</h3>

<p>The per-observation residuals are returned, i.e., the difference of the
observation and the fitted value including random effects. With type one can
specify whether the weights should be used or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rlmerMod'
residuals(object, type = c("response", "weighted"), scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.rlmerMod_+3A_object">object</code></td>
<td>
<p>rlmerMod object</p>
</td></tr>
<tr><td><code id="residuals.rlmerMod_+3A_type">type</code></td>
<td>
<p>type of residuals</p>
</td></tr>
<tr><td><code id="residuals.rlmerMod_+3A_scaled">scaled</code></td>
<td>
<p>scale residuals by residual standard deviation (=scale
parameter)?</p>
</td></tr>
<tr><td><code id="residuals.rlmerMod_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  fm &lt;- rlmer(Yield ~ (1|Batch), Dyestuff)
  stopifnot(all.equal(resid(fm, type="weighted"),
                      resid(fm) * getME(fm, "w_e")))

## End(Not run)
</code></pre>

<hr>
<h2 id='rlmer'>Robust Scoring Equations Estimator for Linear Mixed Models</h2><span id='topic+rlmer'></span><span id='topic+lmerNoFit'></span>

<h3>Description</h3>

<p>Robust estimation of linear mixed effects models, for hierarchical nested
and non-nested, e.g., crossed, datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlmer(
  formula,
  data,
  ...,
  method = c("DAStau", "DASvar"),
  setting,
  rho.e,
  rho.b,
  rho.sigma.e,
  rho.sigma.b,
  rel.tol = 1e-08,
  max.iter = 40 * (r + 1)^2,
  verbose = 0,
  doFit = TRUE,
  init
)

lmerNoFit(formula, data = NULL, ..., initTheta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlmer_+3A_formula">formula</code></td>
<td>
<p>a two-sided linear formula object describing the
fixed-effects part of the model, with the response on the left of a
<code>~</code> operator and the terms, separated by <code>+</code> operators, on the
right.  The vertical bar character <code>"|"</code> separates an expression for
a model matrix and a grouping factor.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_data">data</code></td>
<td>
<p>an optional data frame containing the variables named in
<code>formula</code>.  By default the variables are taken from the environment
from which <code>lmer</code> is called.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to lmer to find the initial
estimates. See <code><a href="lme4.html#topic+lmer">lmer</a></code>.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_method">method</code></td>
<td>
<p>method to be used for estimation of theta and sigma, see
Details.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_setting">setting</code></td>
<td>
<p>a string specifying suggested choices for the arguments
<code>rho.e</code>, <code>rho.sigma.e</code>, <code>rho.b</code> and <code>rho.sigma.b</code>.
Use <code>"RSEn"</code> (the default) or <code>"RSEa"</code>. Both use
<code><a href="#topic+smoothPsi">smoothPsi</a></code> for all the &ldquo;rho&rdquo; arguments. For
<code>rho.sigma.e</code>, squared robustness weights are used (see
<code><a href="#topic+psi2propII">psi2propII</a></code>). <code>"RSEn"</code> uses the same tuning parameter as
for <code>rho.e</code>, which leads to higher robustness but lower efficiency.
<code>"RSEa"</code> adjusts the tuning parameter for higher asymptotic efficiency
which results in lower robustness (<code>k = 2.28</code> for default <code>rho.e</code>).
For diagonal random effects covariance matrices, <code>rho.sigma.b</code> is
treated exactly as <code>rho.sigma.e</code>. For block diagonal random effects
covariance matrices (with correlation terms), regular robustness weights
are used for <code>rho.sigma.b</code>, not squared ones, as they're not needed.
But the tuning parameters are adjusted for both <code>rho.b</code> and
<code>rho.sigma.b</code> according to the dimensions of the blocks (for both
<code>"RSEn"</code> or <code>"RSEa"</code>). For a block of dimension 2 (e.g.,
correlated random intercept and slope) <code>k = 5.14</code> is used.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_rho.e">rho.e</code></td>
<td>
<p>object of class psi_func, specifying the functions to use for
the huberization of the residuals.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_rho.b">rho.b</code></td>
<td>
<p>object of class psi_func or list of such objects (see Details),
specifying the functions to use for the huberization of the random
effects.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_rho.sigma.e">rho.sigma.e</code></td>
<td>
<p>object of class psi_func, specifying the weight functions
to use for the huberization of the residuals when estimating the variance
components, use the <code><a href="#topic+psi2propII">psi2propII</a></code> function to specify squared
weights and custom tuning parameters.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_rho.sigma.b">rho.sigma.b</code></td>
<td>
<p>(optional) object of class psi_func or list of such
objects, specifying the weight functions to use for the huberization of
the random effects when estimating the variance components (see Details).
Use <code><a href="#topic+psi2propII">psi2propII</a></code> to specify squared weights and custom tuning
parameters or <code><a href="#topic+chgDefaults">chgDefaults</a></code> for regular weights for variance
components including correlation parameters.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_rel.tol">rel.tol</code></td>
<td>
<p>relative tolerance used as criteria in the fitting process.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_verbose">verbose</code></td>
<td>
<p>verbosity of output. Ranges from 0 (none) to 3 (a lot of
output)</p>
</td></tr>
<tr><td><code id="rlmer_+3A_dofit">doFit</code></td>
<td>
<p>logical scalar. When <code>doFit = FALSE</code> the model is not fit
but instead a structure with the model matrices for the random-effects
terms is returned (used to speed up tests). When <code>doFit = TRUE</code>, the
default, the model is fit immediately.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_init">init</code></td>
<td>
<p>optional lmerMod- or rlmerMod-object to use for starting values,
a list with elements &lsquo;fixef&rsquo;, &lsquo;u&rsquo;, &lsquo;sigma&rsquo;,
&lsquo;theta&rsquo;, or a function producing an lmerMod object.</p>
</td></tr>
<tr><td><code id="rlmer_+3A_inittheta">initTheta</code></td>
<td>
<p>parameter to initialize theta with (optional)</p>
</td></tr>
</table>


<h3>Details</h3>

 <dl>
<dt>Overview:</dt><dd>
<p>This function implements the Robust Scoring Equations estimator for linear
mixed effect models. It can be used much like the function
<code><a href="lme4.html#topic+lmer">lmer</a></code> in the package <code>lme4</code>. The supported models
are the same as for <code><a href="lme4.html#topic+lmer">lmer</a></code> (gaussian family only). The
robust approach used is based on the robustification of the scoring
equations and an application of the Design Adaptive Scale approach.
</p>
<p>Example analyses and theoretical details on the method are available in the
vignette (see <code>vignette("rlmer")</code>).
</p>
<p>Models are specified using the <code>formula</code> argument, using the same
syntax as for <code><a href="lme4.html#topic+lmer">lmer</a></code>. Additionally, one also needs to
specify what robust scoring or weight functions are to be used (arguments
starting with <code>rho.</code>). By default a smoothed version of the Huber
function is used. Furthermore, the <code>method</code> argument can be used to
speed up computations at the expense of accuracy of the results. </p>
</dd>
<dt>Computation methods:</dt><dd>
<p>Currently, there are two different methods available for fitting models.
They only differ in how the consistency factors for the Design Adaptive
Scale estimates are computed. Available fitting methods for theta and
sigma.e: </p>

<ul>
<li> <p><code>DAStau</code> (default): For this method, the consistency factors are
computed using numerical quadrature. This is slower but yields more accurate
results. This is the direct analogue to the DAS-estimate in robust linear
regression.
</p>
</li>
<li> <p><code>DASvar</code>: This method computes the consistency factors using a
direct approximation which is faster but less accurate. For complex models
with correlated random effects with more than one correlation term, this is
the only method available.
</p>
</li></ul>
 </dd>
<dt>Weight functions:</dt><dd>
<p>The tuning parameters of the weight functions &ldquo;rho&rdquo; can be used to
adjust robustness and efficiency of the resulting estimates (arguments
<code>rho.e</code>, <code>rho.b</code>, <code>rho.sigma.e</code> and <code>rho.sigma.b</code>).
Better robustness will lead to a decrease of the efficiency. With the default
setting, <code>setting = "RSEn"</code>, the tuning parameters are set to yield
estimates with approximately 95% efficiency for the fixed effects. The
variance components are estimated with a lower efficiency but better
robustness properties.
</p>
<p>One has to use different weight functions and tuning parameters for simple
variance components and for such including correlation parameters. By
default, they are chosen appropriately to the model at hand. However, when
using the <code>rho.sigma.e</code> and <code>rho.sigma.b</code> arguments, it is up to
the user to specify the appropriate function. See
<code><a href="#topic+asymptoticEfficiency">asymptoticEfficiency</a></code> for methods to find tuning parameters
that yield a given asymptotic efficiency. </p>

<ul>
<li><p> For simple variance components and the residual error scale use the
function <code><a href="#topic+psi2propII">psi2propII</a></code> to change the tuning parameters. This is
similar to Proposal 2 in the location-scale problem (i.e., using the
squared robustness weights of the location estimate for the scale estimate;
otherwise the scale estimate is not robust).
</p>
</li>
<li><p> For multi-dimensional blocks of random effects modeled, e.g.,
a model with correlated random intercept and slope, (referred to as
block diagonal case below), use the <code><a href="#topic+chgDefaults">chgDefaults</a></code> function to
change the tuning parameters. The parameter estimation problem is
multivariate, unlike the case without correlation where the problem was
univariate. For the employed estimator, this amounts to switching from
simple scale estimates to estimating correlation matrices. Therefore
different weight functions have to be used. Squaring of the weights (using
the function <code><a href="#topic+psi2propII">psi2propII</a></code>) is no longer necessary. To yield
estimates with the same efficiency, the tuning parameters for the
block diagonal are larger than for the simple case. Tables of tuning parameters
are given in Table 2 and 3 of the vignette (<code>vignette("rlmer")</code>).
</p>
</li></ul>
 </dd>
<dt>Recommended tuning parameters:</dt><dd>
<p>For a more robust estimate, use <code>setting = "RSEn"</code> (the default). For
higher efficiency, use <code>setting = "RSEa"</code>. The settings described in
the following paragraph are used when <code>setting = "RSEa"</code> is specified.
</p>
<p>For the smoothed Huber function the tuning parameters to get approximately
95% efficiency are <code class="reqn">k=1.345</code> for <code>rho.e</code> and
<code class="reqn">k=2.28</code> for <code>rho.sigma.e</code> (using the squared version). For
simple variance components, the same can be used for <code>rho.b</code> and
<code>rho.sigma.b</code>. For variance components including correlation
parameters, use <code class="reqn">k=5.14</code> for both <code>rho.b</code> and
<code>rho.sigma.b</code>. Tables of tuning parameter are given in Table 2 and 3 of
the vignette (<code>vignette("rlmer")</code>). </p>
</dd>
<dt>Specifying (multiple) weight functions:</dt><dd>
<p>If custom weight functions are specified using the argument <code>rho.b</code>
(<code>rho.e</code>) but the argument <code>rho.sigma.b</code> (<code>rho.sigma.e</code>) is
missing, then the squared weights are used for simple variance components
and the regular weights are used for variance components including
correlation parameters. The same tuning parameters will be used when
<code>setting = "RSEn"</code> is used. To get
higher efficiency either use <code>setting = "RSEa"</code> (and only set arguments
<code>rho.e</code> and <code>rho.b</code>). Or specify the tuning parameters by hand
using the <code><a href="#topic+psi2propII">psi2propII</a></code> and <code><a href="#topic+chgDefaults">chgDefaults</a></code> functions.
</p>
<p>To specify separate weight functions <code>rho.b</code> and <code>rho.sigma.b</code> for
different variance components, it is possible to pass a list instead of a
psi_func object. The list entries correspond to the groups as shown by
<code>VarCorr(.)</code> when applied to the model fitted with <code>lmer</code>. A set
of correlated random effects count as just one group. </p>
</dd>
<dt><code>lmerNoFit</code>:</dt><dd>
<p>The <code>lmerNoFit</code> function can be used to get trivial starting values.
This is mainly used to verify the algorithms to reproduce the fit by
<code><a href="lme4.html#topic+lmer">lmer</a></code> when starting from trivial initial values. </p>
</dd> </dl>



<h3>Value</h3>

<p>object of class rlmerMod.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller, with thanks to Vanda Lourenço for improvements.
</p>


<h3>See Also</h3>

<p><code><a href="lme4.html#topic+lmer">lmer</a></code>, <code>vignette("rlmer")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## dropping of VC
system.time(print(rlmer(Yield ~ (1|Batch), Dyestuff2, method="DASvar")))

## Not run: 
  ## Default method "DAStau"
  system.time(rfm.DAStau &lt;- rlmer(Yield ~ (1|Batch), Dyestuff))
  summary(rfm.DAStau)
  ## DASvar method (faster, less accurate)
  system.time(rfm.DASvar &lt;- rlmer(Yield ~ (1|Batch), Dyestuff,
                                  method="DASvar"))
  ## compare the two
  compare(rfm.DAStau, rfm.DASvar)

  ## Fit variance components with higher efficiency
  ## psi2propII yields squared weights to get robust estimates
  ## this is the same as using rlmer's argument `setting = "RSEa"`
  rlmer(diameter ~ 1 + (1|plate) + (1|sample), Penicillin,
        rho.sigma.e = psi2propII(smoothPsi, k = 2.28),
        rho.sigma.b = psi2propII(smoothPsi, k = 2.28))

  ## use chgDefaults for variance components including
  ## correlation terms (regular, non squared weights suffice)
  ## this is the same as using rlmer's argument `setting = "RSEa"`
  rlmer(Reaction ~ Days + (Days|Subject), sleepstudy,
        rho.sigma.e = psi2propII(smoothPsi, k = 2.28),
        rho.b = chgDefaults(smoothPsi, k = 5.14, s=10),
        rho.sigma.b = chgDefaults(smoothPsi, k = 5.14, s=10))

## End(Not run)

## Not run: 
  ## start from lmer's initial estimate, not its fit
  rlmer(Yield ~ (1|Batch), Dyestuff, init = lmerNoFit)

## End(Not run)
</code></pre>

<hr>
<h2 id='rlmerMod-class'>rlmerMod Class</h2><span id='topic+rlmerMod-class'></span><span id='topic+coef.rlmerMod'></span><span id='topic+deviance.rlmerMod'></span><span id='topic+extractAIC.rlmerMod'></span><span id='topic+family.rlmerMod'></span><span id='topic+fitted.rlmerMod'></span><span id='topic+fixef.rlmerMod'></span><span id='topic+formula.rlmerMod'></span><span id='topic+isGLMM.rlmerMod'></span><span id='topic+isLMM.rlmerMod'></span><span id='topic+isNLMM.rlmerMod'></span><span id='topic+isREML.rlmerMod'></span><span id='topic+logLik.rlmerMod'></span><span id='topic+model.frame.rlmerMod'></span><span id='topic+model.matrix.rlmerMod'></span><span id='topic+nobs.rlmerMod'></span><span id='topic+predict.rlmerMod'></span><span id='topic+print.rlmerMod'></span><span id='topic+print.summary.rlmer'></span><span id='topic+print.VarCorr.rlmerMod'></span><span id='topic+ranef.rlmerMod'></span><span id='topic+resid.rlmerMod'></span><span id='topic+sigma.rlmerMod'></span><span id='topic+show.rlmerMod'></span><span id='topic+show+2CrlmerMod-method'></span><span id='topic+show.summary.rlmerMod'></span><span id='topic+summary.rlmerMod'></span><span id='topic+summary.summary.rlmerMod'></span><span id='topic+terms.rlmerMod'></span><span id='topic+update.rlmerMod'></span><span id='topic+VarCorr.rlmerMod'></span><span id='topic+VarCorr.summary.rlmerMod'></span><span id='topic+vcov.rlmerMod'></span><span id='topic+vcov.summary.rlmerMod'></span><span id='topic+weights.rlmerMod'></span>

<h3>Description</h3>

<p>Class &quot;rlmerMod&quot; of Robustly Fitted Mixed-Effect Models
</p>


<h3>Details</h3>

<p>A robust mixed-effects model as returned by <code><a href="#topic+rlmer">rlmer</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects are created by calls to
<code><a href="#topic+rlmer">rlmer</a></code>.
</p>


<h3>Methods</h3>

<p>Almost all methods available from objects returned from
<code><a href="lme4.html#topic+lmer">lmer</a></code> are also available for objects returned by
<code><a href="#topic+rlmer">rlmer</a></code>. They usage is the same.
</p>
<p>It follows a list of some the methods that are exported by this package:
</p>

<ul>
<li> <p><code><a href="stats.html#topic+coef">coef</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+deviance">deviance</a></code> (disabled, see below)
</p>
</li>
<li> <p><code><a href="stats.html#topic+extractAIC">extractAIC</a></code> (disabled, see below)
</p>
</li>
<li> <p><code><a href="stats.html#topic+family">family</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+fitted">fitted</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+fixef.merMod">fixef</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+formula">formula</a></code>
</p>
</li>
<li> <p><code><a href="#topic+getInfo">getInfo</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+isGLMM">isGLMM</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+isLMM">isLMM</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+isNLMM">isNLMM</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+isREML">isREML</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+logLik">logLik</a></code> (disabled, see below)
</p>
</li>
<li> <p><code><a href="stats.html#topic+model.frame">model.frame</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+nobs">nobs</a></code>
</p>
</li>
<li> <p><code><a href="#topic+plot.rlmerMod">plot</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+predict.merMod">predict</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+ranef.merMod">ranef</a></code> (only partially implemented)
</p>
</li>
<li> <p><code><a href="#topic+residuals.rlmerMod">residuals</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+sigma">sigma</a></code>
</p>
</li>
<li> <p><code><a href="base.html#topic+summary">summary</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+terms">terms</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+update">update</a></code>
</p>
</li>
<li> <p><code><a href="lme4.html#topic+VarCorr.merMod">VarCorr</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+vcov">vcov</a></code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+weights">weights</a></code>
</p>
</li></ul>



<h3>Disabled methods</h3>

<p>A log likelihood or even a pseudo log likelihood
is not defined for the robust estimates returned by <code><a href="#topic+rlmer">rlmer</a></code>.
Methods that depend on the log likelihood are therefore not available. For
this reason the methods <code>deviance</code>, <code>extractAIC</code> and
<code>logLik</code> stop with an error if they are called.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rlmer">rlmer</a></code>; corresponding class in package <code>lme4</code>:
<code><a href="lme4.html#topic+merMod">merMod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showClass("rlmerMod")

## convert an object of type 'lmerMod' to 'rlmerMod'
## to use the methods provided by robustlmm
fm &lt;- lmer(Yield ~ (1|Batch), Dyestuff)
rfm &lt;- as(fm, "rlmerMod")
compare(fm, rfm)

</code></pre>

<hr>
<h2 id='saveDatasets'>Save datasets</h2><span id='topic+saveDatasets'></span>

<h3>Description</h3>

<p>Saves dataset to one or more files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveDatasets(datasets, path = getwd(), file, chunkSize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveDatasets_+3A_datasets">datasets</code></td>
<td>
<p>dataset list generated by one of the generate functions.</p>
</td></tr>
<tr><td><code id="saveDatasets_+3A_path">path</code></td>
<td>
<p>path to save the datasets to.</p>
</td></tr>
<tr><td><code id="saveDatasets_+3A_file">file</code></td>
<td>
<p>filename to use, without extension.</p>
</td></tr>
<tr><td><code id="saveDatasets_+3A_chunksize">chunkSize</code></td>
<td>
<p>if provided, datasets are split into <code>chunkSize</code>
chunks and then saved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file will be saved to <code>path/filename.Rdata</code>.
</p>
<p>If <code>chunkSize</code> is not missing, the filename is interpreted as format
specifier and passed onto <code><a href="base.html#topic+sprintf">sprintf</a></code>. One argument is given, the
index of the chunk.
</p>


<h3>Value</h3>

<p>filename or vector of filenames.
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>

<hr>
<h2 id='shortenLabelsKS2022'>Shorten Labels</h2><span id='topic+shortenLabelsKS2022'></span>

<h3>Description</h3>

<p>Shorten labels created by the various <code><a href="#topic+fitDatasets">fitDatasets</a></code> functions,
for use in plotting, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortenLabelsKS2022(labels)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shortenLabelsKS2022_+3A_labels">labels</code></td>
<td>
<p>vector of labels as assigned by <code><a href="#topic+fitDatasets">fitDatasets</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The labels are shortened as they are in the simulation study published in
Koller and Stahel (2022).
</p>


<h3>Value</h3>

<p>Vector of shortened labels
</p>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>References</h3>

<p>Koller M, Stahel WA (2022). &quot;Robust Estimation of General Linear
Mixed Effects Models.” In PM Yi, PK Nordhausen (eds.), Robust and Multivariate
Statistical Methods, Springer Nature Switzerland AG.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  labels &lt;- c("fitDatasets_lmer", "fitDatasets_rlmer_DAStau",
              "fitDatasets_rlmer_DAStau_noAdj",
              "fitDatasets_varComprob_compositeTau_OGK",
              "fitDatasets_varComprob_S_OGK",
              "fitDatasets_heavyLme",
              "fitDatasets_lqmm")
  shortenLabelsKS2022(labels)
</code></pre>

<hr>
<h2 id='splitDatasets'>Split Datasets Into Chunks</h2><span id='topic+splitDatasets'></span>

<h3>Description</h3>

<p>Method that splits up dataset objects into smaller chunks, so that they can
be processed separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitDatasets(datasets, chunkSize = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitDatasets_+3A_datasets">datasets</code></td>
<td>
<p>dataset object to split into chunks</p>
</td></tr>
<tr><td><code id="splitDatasets_+3A_chunksize">chunkSize</code></td>
<td>
<p>number of datasets to keep in one chunk</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of dataset lists with generators and the contents of the
original dataset. See <code><a href="#topic+prepareMixedEffectDataset">prepareMixedEffectDataset</a></code> and
<code><a href="#topic+generateAnovaDatasets">generateAnovaDatasets</a></code> for a description of the contents.
There is one additional entry in the list:
</p>
<table>
<tr><td><code>chunkIndex:</code></td>
<td>
<p>index of the chunk</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Manuel Koller
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bindDatasets">bindDatasets</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  oneWay &lt;- generateAnovaDatasets(18, 1, 5, 4)
  datasetList &lt;- splitDatasets(oneWay, 5)
  data &lt;- datasetList[[4]]$generateData(1)
  stopifnot(all.equal(oneWay$generateData(16), datasetList[[4]]$generateData(1),
                      check.attributes = TRUE),
            all.equal(oneWay$sphericalRandomEffects(16),
                      datasetList[[4]]$sphericalRandomEffects(1)),
            all.equal(oneWay$createXMatrix(data), datasetList[[4]]$createXMatrix(data)),
            all.equal(oneWay$createZMatrix(data), datasetList[[4]]$createZMatrix(data)))
</code></pre>

<hr>
<h2 id='viewCopyOfSimulationStudy'>Access Simulation Study Code</h2><span id='topic+viewCopyOfSimulationStudy'></span>

<h3>Description</h3>

<p>This is a convenience function to make it simple to access the simulation
study script files that are shipped with robustlmm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>viewCopyOfSimulationStudy(
  study = c("sensitivityCurves.R", "consistencyAndEfficiencyDiagonal.R",
    "consistencyAndEfficiencyBlockDiagonal.R", "breakdown.R", "convergence.R",
    "robustnessDiagonal.R", "robustnessBlockDiagonal.R"),
  destinationPath = getwd(),
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="viewCopyOfSimulationStudy_+3A_study">study</code></td>
<td>
<p>Name of the script file, partial matching is supported via
<code><a href="base.html#topic+match.arg">match.arg</a></code>.</p>
</td></tr>
<tr><td><code id="viewCopyOfSimulationStudy_+3A_destinationpath">destinationPath</code></td>
<td>
<p>optional path to directory in which the copy of the
script should be created. By default the current working directory is
used.</p>
</td></tr>
<tr><td><code id="viewCopyOfSimulationStudy_+3A_overwrite">overwrite</code></td>
<td>
<p>logical; should existing destination files be overwritten?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function creates a copy of the script file that can be safely edited
without changing the original file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  viewCopyOfSimulationStudy("sensitivityCurves")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
