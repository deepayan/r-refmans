<!DOCTYPE html><html><head><title>Help for package ivmte</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ivmte}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AE'><p>Angrist Evans Data</p></a></li>
<li><a href='#altDefSplinesBasis'><p>(Alternative) Defining single splines basis functions, with</p>
interactions</a></li>
<li><a href='#argstring'><p>Auxiliary function: extract arguments from function in string form</p></a></li>
<li><a href='#audit'><p>Audit procedure</p></a></li>
<li><a href='#bound'><p>Obtaining TE bounds</p></a></li>
<li><a href='#boundCI'><p>Construct confidence intervals for treatment effects under partial</p>
identification</a></li>
<li><a href='#boundPvalue'><p>Construct p-values for treatment effects under partial</p>
identification</a></li>
<li><a href='#bX'><p>Spline basis function of order 1</p></a></li>
<li><a href='#checkU'><p>Check polynomial form of the u-term</p></a></li>
<li><a href='#classFormula'><p>Auxiliary function: test if object is a formula</p></a></li>
<li><a href='#classList'><p>Auxiliary function: test if object is a list</p></a></li>
<li><a href='#combinemonobound'><p>Combining the boundedness and monotonicity constraint objects</p></a></li>
<li><a href='#constructConstant'><p>Construct constant function</p></a></li>
<li><a href='#criterionMin'><p>Minimizing violation of observational equivalence</p></a></li>
<li><a href='#design'><p>Generating design matrices</p></a></li>
<li><a href='#extractcols'><p>Auxiliary function: extracting columns by component names</p></a></li>
<li><a href='#fmtResult'><p>Format result for display</p></a></li>
<li><a href='#funEval'><p>Evaluate a particular function</p></a></li>
<li><a href='#genBasisSplines'><p>Generate basis matrix for splines</p></a></li>
<li><a href='#genboundA'><p>Generating the constraint matrix</p></a></li>
<li><a href='#gendist1'><p>Generate test distribution 1</p></a></li>
<li><a href='#gendist1e'><p>Generate test distribution 1 with errors</p></a></li>
<li><a href='#gendist2'><p>Generate test distribution 2</p></a></li>
<li><a href='#gendist3'><p>Generate test distribution 3</p></a></li>
<li><a href='#gendist3e'><p>Generate test distribution 3 with errors</p></a></li>
<li><a href='#gendist4'><p>Generate test distribution 4</p></a></li>
<li><a href='#gendist5e'><p>Generate test distribution 5 (has errors and a covariate)</p></a></li>
<li><a href='#gendist6e'><p>Generate test distribution 6 (has errors and a covariate)</p></a></li>
<li><a href='#gendistBasic'><p>Generate basic data set for testing</p></a></li>
<li><a href='#gendistCovariates'><p>Generate test data set with covariates</p></a></li>
<li><a href='#gendistMosquito'><p>Generate mosquito data set</p></a></li>
<li><a href='#gendistSplines'><p>Generate test data set with splines</p></a></li>
<li><a href='#genej'><p>Auxiliary function: generating basis vectors</p></a></li>
<li><a href='#genGamma'><p>Estimating expectations of terms in the MTR (gamma objects)</p></a></li>
<li><a href='#genGammaSplines'><p>Generate Gamma moments for splines</p></a></li>
<li><a href='#genGammaSplinesTT'><p>Generating the Gamma moments for splines, for 'testthat'</p></a></li>
<li><a href='#genGammaTT'><p>Function to generate gamma moments for 'testthat'</p></a></li>
<li><a href='#gengrid'><p>Generating the grid for the audit procedure</p></a></li>
<li><a href='#genmonoA'><p>Generate components of the monotonicity constraints</p></a></li>
<li><a href='#genmonoboundA'><p>Generating monotonicity and boundedness constraints</p></a></li>
<li><a href='#genSSet'><p>Generating moments/data for IV-like estimands</p></a></li>
<li><a href='#genTarget'><p>Generating target MTR moments</p></a></li>
<li><a href='#genWeight'><p>Generating list of target weight functions</p></a></li>
<li><a href='#getXZ'><p>Auxiliary function: extract X and Z covariates from a formula</p></a></li>
<li><a href='#gmmEstimate'><p>GMM estimate of TE under point identification</p></a></li>
<li><a href='#interactSplines'><p>Update splines object with list of interactions</p></a></li>
<li><a href='#isfunctionstring'><p>Auxiliary function: check if string is command</p></a></li>
<li><a href='#ivEstimate'><p>Obtaining IV-like specifications</p></a></li>
<li><a href='#ivmte'><p>Instrumental Variables: Extrapolation by Marginal Treatment Effects</p></a></li>
<li><a href='#ivmteEstimate'><p>Single iteration of estimation procedure from Mogstad, Torgovitsky,</p>
Santos (2018)</a></li>
<li><a href='#ivmteSimData'><p>ivmte Simulated Data</p></a></li>
<li><a href='#l'><p>Listing subsets and components</p></a></li>
<li><a href='#lpSetup'><p>Constructing LP problem</p></a></li>
<li><a href='#lpSetupBound'><p>Configure LP environment for obtaining the bounds</p></a></li>
<li><a href='#lpSetupCriterion'><p>Configure LP environment for minimizing the criterion</p></a></li>
<li><a href='#lpSetupCriterionBoot'><p>Configure LP environment for specification testing</p></a></li>
<li><a href='#lpSetupEqualCoef'><p>Generate equality constraints</p></a></li>
<li><a href='#lpSetupInfeasible'><p>Configure LP environment for diagnostics</p></a></li>
<li><a href='#lpSetupSolver'><p>Configure LP environment to be compatible with solvers</p></a></li>
<li><a href='#magnitude'><p>Check magnitude of real number</p></a></li>
<li><a href='#matrixTriplets'><p>Convert matrix into triplet form</p></a></li>
<li><a href='#mInt'><p>Function to generate integral of m0 and m1</p></a></li>
<li><a href='#modcall'><p>Auxiliary function: modifying calls</p></a></li>
<li><a href='#momentMatrix'><p>Construct pre-meaned moment matrix</p></a></li>
<li><a href='#monoIntegral'><p>Integrating and evaluating monomials</p></a></li>
<li><a href='#negationCheck'><p>Check if custom weights are negations of each other</p></a></li>
<li><a href='#olsj'><p>OLS weights</p></a></li>
<li><a href='#optionsCplexAPI'><p>Function to parse options for CPLEX</p></a></li>
<li><a href='#optionsCplexAPISingle'><p>Function to parse a single set of options for CPLEX</p></a></li>
<li><a href='#optionsCplexAPITol'><p>Function to extract feasibility tolerance from CPLEX options</p></a></li>
<li><a href='#optionsGurobi'><p>Function to parse options for Gurobi</p></a></li>
<li><a href='#optionsLpSolveAPI'><p>Function to parse options for lp_solve</p></a></li>
<li><a href='#optionsRmosek'><p>Function to parse options for Gurobi</p></a></li>
<li><a href='#parenthBoolean'><p>Correct boolean expressions in terms lists</p></a></li>
<li><a href='#permute'><p>Auxiliary function: generate all permutations of a vector</p></a></li>
<li><a href='#permuteN'><p>Auxiliary function: generate all permutation orderings</p></a></li>
<li><a href='#piv'><p>Obtaining IV-like estimands</p></a></li>
<li><a href='#polyparse'><p>Parsing marginal treatment response formulas</p></a></li>
<li><a href='#polyProduct'><p>Function to multiply polynomials</p></a></li>
<li><a href='#popmean'><p>Calulating population mean</p></a></li>
<li><a href='#print.ivmte'><p>Print results</p></a></li>
<li><a href='#propensity'><p>Estimating propensity scores</p></a></li>
<li><a href='#qpSetup'><p>Constructing QCQP problem</p></a></li>
<li><a href='#qpSetupBound'><p>Constructing QCQP problem for bounding</p></a></li>
<li><a href='#qpSetupCriterion'><p>Configure QCQP problem to find minimum criterion</p></a></li>
<li><a href='#qpSetupInfeasible'><p>Configure QP environment for diagnostics</p></a></li>
<li><a href='#removeSplines'><p>Separating splines from MTR formulas</p></a></li>
<li><a href='#rescaleX'><p>Function to implement rescaling procedure</p></a></li>
<li><a href='#restring'><p>Auxiliary function that converts an expression of variable names</p>
into a vector of strings.</a></li>
<li><a href='#rhalton'><p>Generate Halton sequence</p></a></li>
<li><a href='#runCplexAPI'><p>Running cplexAPI solver</p></a></li>
<li><a href='#runGurobi'><p>Running Gurobi solver</p></a></li>
<li><a href='#runLpSolveAPI'><p>Running lpSolveAPI</p></a></li>
<li><a href='#runMosek'><p>Running Rmosek</p></a></li>
<li><a href='#selectViolations'><p>Select points from audit grid to add to the constraint grid</p></a></li>
<li><a href='#sOls1d'><p>IV-like weighting function, OLS specification 1</p></a></li>
<li><a href='#sOls2d'><p>IV-like weighting function, OLS specification 2</p></a></li>
<li><a href='#sOls3'><p>IV-like weighting function, OLS specification 3</p></a></li>
<li><a href='#sOlsSplines'><p>IV-like weighting function, OLS specifications</p></a></li>
<li><a href='#splineInt'><p>Integrating splines</p></a></li>
<li><a href='#splinesBasis'><p>Evaluating splines basis functions</p></a></li>
<li><a href='#splineUpdate'><p>Constructing higher order splines</p></a></li>
<li><a href='#statusString'><p>Convert status code to string</p></a></li>
<li><a href='#sTsls'><p>IV-like weighting function, TSLS specification</p></a></li>
<li><a href='#sTslsSplines'><p>IV-like weighting function, TSLS specification</p></a></li>
<li><a href='#subsetclean'><p>Auxiliary function: remove extraneous spaces</p></a></li>
<li><a href='#summary.ivmte'><p>Summarize results</p></a></li>
<li><a href='#sWald'><p>IV-like weighting function, Wald specification</p></a></li>
<li><a href='#symat'><p>Generate symmetric matrix</p></a></li>
<li><a href='#tsls'><p>TSLS weights, with controls</p></a></li>
<li><a href='#unstring'><p>Auxiliary function that converts a vector of strings into an</p>
expression containing variable names.</a></li>
<li><a href='#uSplineBasis'><p>Spline basis function</p></a></li>
<li><a href='#uSplineInt'><p>Integrated splines</p></a></li>
<li><a href='#vecextract'><p>Auxiliary function: extracting elements from strings</p></a></li>
<li><a href='#wate1'><p>Target weight for ATE</p></a></li>
<li><a href='#watt1'><p>Target weight for ATT</p></a></li>
<li><a href='#wAttSplines'><p>Target weighting function, for ATT</p></a></li>
<li><a href='#watu1'><p>Target weight for ATU</p></a></li>
<li><a href='#weights'><p>Generating splines weights</p></a></li>
<li><a href='#wgenlate1'><p>Target weight for generalized LATE</p></a></li>
<li><a href='#whichforlist'><p>Auxiliary function: <code>which</code> for lists</p></a></li>
<li><a href='#wlate1'><p>Target weight for LATE</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Instrumental Variables: Extrapolation by Marginal Treatment
Effects</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joshua Shea &lt;jkcshea@uchicago.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The marginal treatment effect was introduced by Heckman and
    Vytlacil (2005) &lt;<a href="https://doi.org/10.1111%2Fj.1468-0262.2005.00594.x">doi:10.1111/j.1468-0262.2005.00594.x</a>&gt; to provide a
    choice-theoretic interpretation to instrumental variables models that
    maintain the monotonicity condition of Imbens and Angrist (1994)
    &lt;<a href="https://doi.org/10.2307%2F2951620">doi:10.2307/2951620</a>&gt;. This interpretation can be used to extrapolate from
    the compliers to estimate treatment effects for other subpopulations. This
    package provides a flexible set of methods for conducting this
    extrapolation. It allows for parametric or nonparametric sieve estimation,
    and allows the user to maintain shape restrictions such as monotonicity. The
    package operates in the general framework developed by Mogstad, Santos and
    Torgovitsky (2018) &lt;<a href="https://doi.org/10.3982%2FECTA15463">doi:10.3982/ECTA15463</a>&gt;, and accommodates either point
    identification or partial identification (bounds). In the partially
    identified case, bounds are computed using either linear programming
    or quadratically constrained quadratic programming. Support for
    four solvers is provided. Gurobi and the Gurobi R API
    can be obtained from <a href="http://www.gurobi.com/index">http://www.gurobi.com/index</a>. CPLEX can be obtained
    from <a href="https://www.ibm.com/analytics/cplex-optimizer">https://www.ibm.com/analytics/cplex-optimizer</a>. CPLEX R APIs 'Rcplex'
    and 'cplexAPI' are available from CRAN. MOSEK and the MOSEK R API can be
    obtained from <a href="https://www.mosek.com/">https://www.mosek.com/</a>. The lp_solve library is freely
    available from <a href="http://lpsolve.sourceforge.net/5.5/">http://lpsolve.sourceforge.net/5.5/</a>, and is included when
    installing its API 'lpSolveAPI', which is available from CRAN.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gurobi (&ge; 8.1-0), slam (&ge; 0.1-42), cplexAPI (&ge; 1.3.3),
lpSolveAPI (&ge; 5.5.2.0-17), Rmosek (&ge; 9.2.38), testthat (&ge;
2.0.0), data.table (&ge; 1.12.0), splines2 (&ge; 0.2.8),
future.apply (&ge; 1.6.0), future (&ge; 1.18.0), Matrix, knitr,
rmarkdown, pander, AER, lsei, ggplot2, gridExtra</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-08 18:57:33 UTC; jkcshea</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Torgovitsky [aut],
  Joshua Shea [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-17 12:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='AE'>Angrist Evans Data</h2><span id='topic+AE'></span>

<h3>Description</h3>

<p>Angrist Evans Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AE
</code></pre>


<h3>Format</h3>

<p>A data frame with 209,133 rows and 8 columns.
</p>

<dl>
<dt>worked</dt><dd><p>indicator for whether worked in the previous year</p>
</dd>
<dt>hours</dt><dd><p>weekly hours worked in the previous year</p>
</dd>
<dt>morekids</dt><dd><p>indicator for having more than two children vs. exactly two children.</p>
</dd>
<dt>samesex</dt><dd><p>indicator for the first two children having the same sex (male-male or female-female)</p>
</dd>
<dt>yob</dt><dd><p>the year the woman was born</p>
</dd>
<dt>black</dt><dd><p>indicator that mother is Black</p>
</dd>
<dt>hisp</dt><dd><p>indicator that mother is Hispanic</p>
</dd>
<dt>other</dt><dd><p>indicator that mother is neither Black nor Hispanic</p>
</dd>
</dl>



<h3>Source</h3>

<p>Derived from Angrist and Evans (1998, The American Economic Review).
</p>

<hr>
<h2 id='altDefSplinesBasis'>(Alternative) Defining single splines basis functions, with
interactions</h2><span id='topic+altDefSplinesBasis'></span>

<h3>Description</h3>

<p>This function returns a numerically integrable function
corresponding to a single splines basis function. It was not
implemented because it was slower than using the function from the
<code>splines2</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>altDefSplinesBasis(splineslist, j, l, v = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="altDefSplinesBasis_+3A_splineslist">splineslist</code></td>
<td>
<p>a list of splines commands and names of
variables that interact with the splines. This is generated
using the command <code><a href="#topic+removeSplines">removeSplines</a></code>.</p>
</td></tr>
<tr><td><code id="altDefSplinesBasis_+3A_j">j</code></td>
<td>
<p>the index for the spline for which to generate the basis
functions.</p>
</td></tr>
<tr><td><code id="altDefSplinesBasis_+3A_l">l</code></td>
<td>
<p>the index for the basis.</p>
</td></tr>
<tr><td><code id="altDefSplinesBasis_+3A_v">v</code></td>
<td>
<p>a constant that multiplies the spline basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vectorized function corresponding to a single splines
basis function that can be numerically integrated.
</p>

<hr>
<h2 id='argstring'>Auxiliary function: extract arguments from function in string form</h2><span id='topic+argstring'></span>

<h3>Description</h3>

<p>Auxiliary function to extract arguments from a function that is in
string form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>argstring(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="argstring_+3A_string">string</code></td>
<td>
<p>the function in string form.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string of arguments.
</p>

<hr>
<h2 id='audit'>Audit procedure</h2><span id='topic+audit'></span>

<h3>Description</h3>

<p>This is the wrapper for running the entire audit procedure. This
function sets up the LP/QCQP problem of minimizing criterion.  for
the set of IV-like estimands, while satisfying boundedness and
monotonicity constraints declared by the user. Rather than enforce
that boundedness and monotonicity hold across the entire support of
covariates and unobservables, this procedure enforces the
conditions over a grid of points. This grid corresponds to the set
of values the covariates can take, and a set of values of the
unobservable term. The size of this grid is specified by the user
in the function arguments. The procedure first estimates the bounds
while imposing the shape constraints for an initial subset of
points in the grid. The procedure then goes on to check ('audit')
whether the constraints are satisfied over the entire grid. Any
point where either the boundedness or monotonicity constraints are
violated are incorporated into the initial grid, and the process is
repeated until the audit no longer finds any violations, or until
some maximum number of iterations is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audit(
  data,
  uname,
  m0,
  m1,
  pm0,
  pm1,
  splinesobj,
  vars_mtr,
  terms_mtr0,
  terms_mtr1,
  vars_data,
  initgrid.nu = 20,
  initgrid.nx = 20,
  audit.nx = 2500,
  audit.nu = 25,
  audit.add = 100,
  audit.max = 25,
  audit.tol,
  audit.grid = NULL,
  m1.ub,
  m0.ub,
  m1.lb,
  m0.lb,
  mte.ub,
  mte.lb,
  m1.ub.default = FALSE,
  m0.ub.default = FALSE,
  mte.ub.default = FALSE,
  m1.lb.default = FALSE,
  m0.lb.default = FALSE,
  mte.lb.default = FALSE,
  m0.dec = FALSE,
  m0.inc = FALSE,
  m1.dec = FALSE,
  m1.inc = FALSE,
  mte.dec = FALSE,
  mte.inc = FALSE,
  equal.coef0,
  equal.coef1,
  sset,
  gstar0,
  gstar1,
  orig.sset = NULL,
  orig.criterion = NULL,
  criterion.tol = 1e-04,
  solver,
  solver.options,
  solver.presolve,
  solver.options.criterion,
  solver.options.bounds,
  rescale = TRUE,
  smallreturnlist = FALSE,
  noisy = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audit_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> used to estimate
the treatment effects.</p>
</td></tr>
<tr><td><code id="audit_+3A_uname">uname</code></td>
<td>
<p>variable name for the unobservable used in declaring
the MTRs. The name can be provided with or without quotation
marks.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the control group. Splines may also be
incorporated using the expression <code>uSpline</code>, e.g.
<code>uSpline(degree = 2, knots = c(0.4, 0.8), intercept =
TRUE)</code>. The <code>intercept</code> argument may be omitted, and is
set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the treated group. See <code>m0</code> for details.</p>
</td></tr>
<tr><td><code id="audit_+3A_pm0">pm0</code></td>
<td>
<p>A list of the monomials in the MTR for the control
group.</p>
</td></tr>
<tr><td><code id="audit_+3A_pm1">pm1</code></td>
<td>
<p>A list of the monomials in the MTR for the treated
group.</p>
</td></tr>
<tr><td><code id="audit_+3A_splinesobj">splinesobj</code></td>
<td>
<p>list of spline components in the MTRs for treated
and control groups. Spline terms are extracted using
<code><a href="#topic+removeSplines">removeSplines</a></code>. This object is supposed to be a
dictionary of splines, containing the original calls of each
spline in the MTRs, their specifications, and the index used
for naming each basis spline.</p>
</td></tr>
<tr><td><code id="audit_+3A_vars_mtr">vars_mtr</code></td>
<td>
<p>character, vector of variables entering into
<code>m0</code> and <code>m1</code>.</p>
</td></tr>
<tr><td><code id="audit_+3A_terms_mtr0">terms_mtr0</code></td>
<td>
<p>character, vector of terms entering into
<code>m0</code>.</p>
</td></tr>
<tr><td><code id="audit_+3A_terms_mtr1">terms_mtr1</code></td>
<td>
<p>character, vector of terms entering into
<code>m1</code>.</p>
</td></tr>
<tr><td><code id="audit_+3A_vars_data">vars_data</code></td>
<td>
<p>character, vector of variables that can be found
in the data.</p>
</td></tr>
<tr><td><code id="audit_+3A_initgrid.nu">initgrid.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are
always a subset of the points defining the audit grid (see
<code>audit.nu</code>). These points are used to form the initial
constraint grid for imposing shape restrictions on the <code>u</code>
components of the MTRs.</p>
</td></tr>
<tr><td><code id="audit_+3A_initgrid.nx">initgrid.nx</code></td>
<td>
<p>integer determining the number of points of the
covariates used to form the initial constraint grid for
imposing shape restrictions on the MTRs.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.nx">audit.nx</code></td>
<td>
<p>integer determining the number of points on the
covariates space to audit in each iteration of the audit
procedure.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.nu">audit.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are used
to audit whether the shape restrictions on the <code>u</code>
components of the MTRs are satisfied. The initial grid used to
impose the shape constraints in the LP/QCQP problem are
constructed from a subset of these points.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.add">audit.add</code></td>
<td>
<p>maximum number of points to add to the initial
constraint grid for imposing each kind of shape constraint. For
example, if there are 5 different kinds of shape constraints,
there can be at most <code>audit.add * 5</code> additional points
added to the constraint grid.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.max">audit.max</code></td>
<td>
<p>maximum number of iterations in the audit
procedure.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be 1e-06, which is equal to the
default feasibility tolerances of Gurobi (<code>solver =
"gurobi"</code>), CPLEX (<code>solver = "cplexapi"</code>), and Rmosek
(<code>solver = "rmosek"</code>). This parameter should only be
changed if the feasibility tolerance of the solver is changed,
or if numerical issues result in discrepancies between the
solver's feasibility check and the audit.</p>
</td></tr>
<tr><td><code id="audit_+3A_audit.grid">audit.grid</code></td>
<td>
<p>list, contains the <code>A</code> matrix used in the
audit for the original sample, as well as the RHS vector used
in the audit from the original sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.ub">m1.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the treated
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.ub">m0.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the control
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.lb">m1.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the treated
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.lb">m0.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the control
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.ub">mte.ub</code></td>
<td>
<p>numeric value for upper bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.lb">mte.lb</code></td>
<td>
<p>numeric value for lower bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.ub.default">m1.ub.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.ub.default">m0.ub.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.ub.default">mte.ub.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.lb.default">m1.lb.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.lb.default">m0.lb.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.lb.default">mte.lb.default</code></td>
<td>
<p>boolean, default set to FALSE. Indicator for
whether the value assigned was by the user, or set by default.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.dec">m0.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_m0.inc">m0.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.dec">m1.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_m1.inc">m1.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.dec">mte.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone decreasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_mte.inc">mte.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone increasing.</p>
</td></tr>
<tr><td><code id="audit_+3A_equal.coef0">equal.coef0</code></td>
<td>
<p>character, a vector containing all the terms in
<code>m0</code> that should have the same coefficients in
<code>m1</code>. The order of the variables must match those of
<code>equal.coef1</code>, which contains all the corresponding terms
in <code>m1</code>. The reason the terms are entered separately for
<code>m0</code> and <code>m1</code> is because the spline terms may be
named differently across treatment and control groups.</p>
</td></tr>
<tr><td><code id="audit_+3A_equal.coef1">equal.coef1</code></td>
<td>
<p>character, a vector containing all the terms in
<code>m1</code> that should have the same coefficients in
<code>m0</code>. See the description for <code>equal.coef0</code> for more
details.</p>
</td></tr>
<tr><td><code id="audit_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma moments
for each IV-like specification.</p>
</td></tr>
<tr><td><code id="audit_+3A_gstar0">gstar0</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group, corresponding to the target parameter.</p>
</td></tr>
<tr><td><code id="audit_+3A_gstar1">gstar1</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group, corresponding to the target parameter.</p>
</td></tr>
<tr><td><code id="audit_+3A_orig.sset">orig.sset</code></td>
<td>
<p>list, only used for bootstraps. The list contains
the gamma moments for each element in the S-set, as well as the
IV-like coefficients.</p>
</td></tr>
<tr><td><code id="audit_+3A_orig.criterion">orig.criterion</code></td>
<td>
<p>numeric, only used for bootstraps. The scalar
corresponds to the minimum observational equivalence criterion
from the original sample.</p>
</td></tr>
<tr><td><code id="audit_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>tolerance for the criterion function, and is
set to 1e-4 by default. The criterion measures how well the
IV-like moments/conditional means are matched using the
l1-norm. Statistical noise may prohibit the theoretical LP/QCQP
problem from being feasible. That is, there may not exist a set
of MTR coefficients that are able to match all the specified
moments. The function thus first estimates the minimum
criterion, which is reported in the output under the name
'minimum criterion', with a criterion of 0 meaning that all
moments were able to be matched. The function then relaxes the
constraints by tolerating a criterion up to <code>minimum
criterion * (1 + criterion.tol)</code>. Set <code>criterion.tol</code> to a
value greater than 0 to allow for more conservative bounds.</p>
</td></tr>
<tr><td><code id="audit_+3A_solver">solver</code></td>
<td>
<p>character, name of the programming package in R used
to obtain the bounds on the treatment effect. The function
supports <code>'gurobi'</code>, <code>'cplexapi'</code>, <code>rmosek</code>,
<code>'lpsolveapi'</code>. The name of the solver should be provided
with quotation marks.</p>
</td></tr>
<tr><td><code id="audit_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should correspond
to an option specific to the solver selected.</p>
</td></tr>
<tr><td><code id="audit_+3A_solver.presolve">solver.presolve</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. Set
this parameter to <code>FALSE</code> if presolve should be turned off
for the LP/QCQP problems.</p>
</td></tr>
<tr><td><code id="audit_+3A_solver.options.criterion">solver.options.criterion</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the minimum criterion.</p>
</td></tr>
<tr><td><code id="audit_+3A_solver.options.bounds">solver.options.bounds</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the bounds.</p>
</td></tr>
<tr><td><code id="audit_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QCQP
optimization.</p>
</td></tr>
<tr><td><code id="audit_+3A_smallreturnlist">smallreturnlist</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> to exclude large intermediary components
(i.e. propensity score model, LP/QCQP model, bootstrap
iterations) from being included in the return list.</p>
</td></tr>
<tr><td><code id="audit_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
<tr><td><code id="audit_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The option is only
applied when <code>solver = 'gurobi'</code> or <code>solver =
'rmosek'</code>. The output provided is the same as what the Gurobi
API would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list. Included in the list are estimates of the treatment
effect bounds; the minimum violation of observational
equivalence of the set of IV-like estimands; the list of
matrices and vectors defining the LP/QCQP problem; the points used
to generate the audit grid, and the points where the shape
constraints were violated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided
sSet &lt;- list()

## Declare MTR formulas
formula0 = ~ 1 + u
formula1 = ~ 1 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## If splines are interacted with other variables, the
## 'interactSplines' should be used.
## splinesList &lt;- interactSplines(splinesobj = splinesList,
##                               m0 = formula0,
##                               m1 = formula1,
##                               data = data,
##                               uname = 'u')

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

polynomials1 &lt;- polyparse(formula = formula1,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(intercept, d),
                          treat = d,
                          list = FALSE)

## Generate target gamma moments
targetGamma &lt;- genTarget(treat = "d",
                         m0 = ~ 1 + u,
                         m1 = ~ 1 + u,
                         target = "atu",
                         data = dtm,
                         splinesobj = splinesList,
                         pmodobj = propensityObj,
                         pm0 = polynomials0,
                         pm1 = polynomials1)

## Construct S-set, which contains the coefficients and weights
## corresponding to various IV-like estimands
sSet &lt;- genSSet(data = dtm,
                sset = sSet,
                sest = ivEstimates,
                splinesobj = splinesList,
                pmodobj = propensityObj$phat,
                pm0 = polynomials0,
                pm1 = polynomials1,
                ncomponents = 2,
                scount = 1,
                yvar = "ey",
                dvar = "d",
                means = TRUE)

## Perform audit procedure and return bounds
audit(data = dtm,
      uname = u,
      m0 = formula0,
      m1 = formula1,
      pm0 = polynomials0,
      pm1 = polynomials1,
      splinesobj = splinesList,
      vars_data = colnames(dtm),
      vars_mtr = "u",
      terms_mtr0 = "u",
      terms_mtr1 = "u",
      sset = sSet$sset,
      gstar0 = targetGamma$gstar0,
      gstar1 = targetGamma$gstar1,
      m0.inc = TRUE,
      m1.dec = TRUE,
      m0.lb = 0.2,
      m1.ub = 0.8,
      audit.max = 5,
      solver = "lpSolveAPI")

</code></pre>

<hr>
<h2 id='bound'>Obtaining TE bounds</h2><span id='topic+bound'></span>

<h3>Description</h3>

<p>This function estimates the bounds on the target treatment
effect. The LP model must be passed as an environment variable,
under the entry <code>$model</code>. See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bound(
  env,
  sset,
  solver,
  solver.options,
  noisy = FALSE,
  smallreturnlist = FALSE,
  rescale = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bound_+3A_env">env</code></td>
<td>
<p>environment containing the matrices defining the LP
problem.</p>
</td></tr>
<tr><td><code id="bound_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma
components associated with each element in the S-set. This
object is only used to determine the names of terms. If it is
no submitted, then no names are provided to the solution
vector.</p>
</td></tr>
<tr><td><code id="bound_+3A_solver">solver</code></td>
<td>
<p>string, name of the package used to solve the LP
problem.</p>
</td></tr>
<tr><td><code id="bound_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should correspond
to an option specific to the LP solver selected.</p>
</td></tr>
<tr><td><code id="bound_+3A_noisy">noisy</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if optimization results
should be displayed.</p>
</td></tr>
<tr><td><code id="bound_+3A_smallreturnlist">smallreturnlist</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the LP model
should not be returned.</p>
</td></tr>
<tr><td><code id="bound_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QP/QCP
optimization.</p>
</td></tr>
<tr><td><code id="bound_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The option is only
applied when <code>solver = 'gurobi'</code> or <code>solver =
'rmosek'</code>. The output provided is the same as what the Gurobi
API would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the bounds on the treatment effect; the
coefficients on each term in the MTR associated with the upper
and lower bounds, for both counterfactuals; the optimization
status to the maximization and minimization problems; the LP
problem that the optimizer solved.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided
sSet &lt;- list()

## Declare MTR formulas
formula0 = ~ 1 + u
formula1 = ~ 1 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'.
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                          data = dtm,
                          uname = u,
                          as.function = FALSE)
polynomials1 &lt;- polyparse(formula = formula1,
                          data = dtm,
                          uname = u,
                           as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(intercept, d),
                          treat = d,
                          list = FALSE)

## Generate target gamma moments
targetGamma &lt;- genTarget(treat = "d",
                         m0 = ~ 1 + u,
                         m1 = ~ 1 + u,
                         target = "atu",
                         data = dtm,
                         splinesobj = splinesList,
                         pmodobj = propensityObj,
                         pm0 = polynomials0,
                         pm1 = polynomials1)

## Construct S-set. which contains the coefficients and weights
## corresponding to various IV-like estimands
sSet &lt;- genSSet(data = dtm,
                sset = sSet,
                sest = ivEstimates,
                splinesobj = splinesList,
                pmodobj = propensityObj$phat,
                pm0 = polynomials0,
                pm1 = polynomials1,
                ncomponents = 2,
                scount = 1,
                yvar = "ey",
                dvar = "d",
                means = TRUE)
## Only the entry $sset is required
sSet &lt;- sSet$sset

## Define additional upper- and lower-bound constraints for the LP
## problem
A &lt;- matrix(0, nrow = 22, ncol = 4)
A &lt;- cbind(A, rbind(cbind(1, seq(0, 1, 0.1)),
                    matrix(0, nrow = 11, ncol = 2)))
A &lt;- cbind(A, rbind(matrix(0, nrow = 11, ncol = 2),
                    cbind(1, seq(0, 1, 0.1))))
sense &lt;- c(rep("&gt;", 11), rep("&lt;", 11))
rhs &lt;- c(rep(0.2, 11), rep(0.8, 11))

## Construct LP object to be interpreted and solved by
## lpSolveAPI. Note that an environment has to be created for the LP
## object. The matrices defining the shape restrictions must be stored
## as a list under the entry \code{$mbobj} in the environment.
modelEnv &lt;- new.env()
modelEnv$mbobj &lt;- list(mbA = A,
                    mbs = sense,
                    mbrhs = rhs)
## Convert the matrices defining the shape constraints into a format
## that is suitable for the LP solver.
lpSetup(env = modelEnv,
        sset = sSet,
        solver = "lpsolveapi")
## Setup LP model so that it is solving for the bounds.
lpSetupBound(env = modelEnv,
             g0 = targetGamma$gstar0,
             g1 = targetGamma$gstar1,
             sset = sSet,
             criterion.tol = 0,
             criterion.min = 0,
             solver = "lpsolveapi")
## Declare any LP solver options as a list.
lpOptions &lt;- optionsLpSolveAPI(list(epslevel = "tight"))
## Obtain the bounds.
bounds &lt;- bound(env = modelEnv,
                sset = sSet,
                solver = "lpsolveapi",
                solver.options = lpOptions)
cat("The bounds are [",  bounds$min, ",", bounds$max, "].\n")

</code></pre>

<hr>
<h2 id='boundCI'>Construct confidence intervals for treatment effects under partial
identification</h2><span id='topic+boundCI'></span>

<h3>Description</h3>

<p>This function constructs the forward and backward confidence
intervals for the treatment effect under partial identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundCI(bounds, bounds.resamples, n, m, levels, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundCI_+3A_bounds">bounds</code></td>
<td>
<p>vector, bounds of the treatment effects under partial
identification.</p>
</td></tr>
<tr><td><code id="boundCI_+3A_bounds.resamples">bounds.resamples</code></td>
<td>
<p>matrix, stacked bounds of the treatment
effects under partial identification. Each row corresponds to a
subset resampled from the original data set.</p>
</td></tr>
<tr><td><code id="boundCI_+3A_n">n</code></td>
<td>
<p>integer, size of original data set.</p>
</td></tr>
<tr><td><code id="boundCI_+3A_m">m</code></td>
<td>
<p>integer, size of resampled data sets.</p>
</td></tr>
<tr><td><code id="boundCI_+3A_levels">levels</code></td>
<td>
<p>vector, real numbers between 0 and 1. Values
correspond to the level of the confidence intervals constructed
via bootstrap.</p>
</td></tr>
<tr><td><code id="boundCI_+3A_type">type</code></td>
<td>
<p>character. Set to 'forward' to construct the forward
confidence interval for the treatment effect bounds. Set to
'backward' to construct the backward confidence interval for
the treatment effect bounds. Set to 'both' to construct both
types of confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>type</code> is 'forward' or 'backward', then the
corresponding type of confidence interval for each level is
returned. The output is in the form of a matrix, with each row
corresponding to a level. If <code>type</code> is 'both', then a list
is returned. One element of the list is the matrix of backward
confidence intervals, and the other element of the list is the
matrix of forward confidence intervals.
</p>

<hr>
<h2 id='boundPvalue'>Construct p-values for treatment effects under partial
identification</h2><span id='topic+boundPvalue'></span>

<h3>Description</h3>

<p>This function estimates the p-value for the treatment effect under
partial identification. p-values corresponding to forward and
backward confidence intervals can be returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundPvalue(bounds, bounds.resamples, n, m, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundPvalue_+3A_bounds">bounds</code></td>
<td>
<p>vector, bounds of the treatment effects under partial
identification.</p>
</td></tr>
<tr><td><code id="boundPvalue_+3A_bounds.resamples">bounds.resamples</code></td>
<td>
<p>matrix, stacked bounds of the treatment
effects under partial identification. Each row corresponds to a
subset resampled from the original data set.</p>
</td></tr>
<tr><td><code id="boundPvalue_+3A_n">n</code></td>
<td>
<p>integer, size of original data set.</p>
</td></tr>
<tr><td><code id="boundPvalue_+3A_m">m</code></td>
<td>
<p>integer, size of resampled data sets.</p>
</td></tr>
<tr><td><code id="boundPvalue_+3A_type">type</code></td>
<td>
<p>character. Set to 'forward' to construct the forward
confidence interval for the treatment effect bounds. Set to
'backward' to construct the backward confidence interval for
the treatment effect bounds. Set to 'both' to construct both
types of confidence intervals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type</code> is 'forward' or 'backward', a scalar p-value
corresponding to the type of confidence interval is
returned. If <code>type</code> is 'both', a vector of p-values
corresponding to the forward and backward confidence intervals
is returned.
</p>

<hr>
<h2 id='bX'>Spline basis function of order 1</h2><span id='topic+bX'></span>

<h3>Description</h3>

<p>This function is the splines basis function of order 1. This
function was coded in accordance to Carl de Boor's set of notes on
splines, &quot;B(asic)-Spline Basics&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bX(x, knots, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bX_+3A_x">x</code></td>
<td>
<p>vector, the values at which to evaluate the basis
function.</p>
</td></tr>
<tr><td><code id="bX_+3A_knots">knots</code></td>
<td>
<p>vector, the internal knots.</p>
</td></tr>
<tr><td><code id="bX_+3A_i">i</code></td>
<td>
<p>integer, the basis component to be evaluated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='checkU'>Check polynomial form of the u-term</h2><span id='topic+checkU'></span>

<h3>Description</h3>

<p>This function ensures that the unobservable term enters into the
MTR in the correct manner. That is, it enters as a polynomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkU(formula, uname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkU_+3A_formula">formula</code></td>
<td>
<p>a formula.</p>
</td></tr>
<tr><td><code id="checkU_+3A_uname">uname</code></td>
<td>
<p>name of the unobserved variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If the unobservable term is entered correctly into the
formula, then <code>NULL</code> is returned. Otherwise, the vector of
incorrect terms is returned.
</p>

<hr>
<h2 id='classFormula'>Auxiliary function: test if object is a formula</h2><span id='topic+classFormula'></span>

<h3>Description</h3>

<p>Auxiliary function to test if an object is a formula. Warnings are
suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classFormula(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classFormula_+3A_obj">obj</code></td>
<td>
<p>the object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean expression.
</p>

<hr>
<h2 id='classList'>Auxiliary function: test if object is a list</h2><span id='topic+classList'></span>

<h3>Description</h3>

<p>Auxiliary function to test if an object is a list. Warnings are
suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classList(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classList_+3A_obj">obj</code></td>
<td>
<p>the object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean expression.
</p>

<hr>
<h2 id='combinemonobound'>Combining the boundedness and monotonicity constraint objects</h2><span id='topic+combinemonobound'></span>

<h3>Description</h3>

<p>This function simply combines the objects associated with the
boundedness constraints and the monotonicity constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinemonobound(bdA, monoA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combinemonobound_+3A_bda">bdA</code></td>
<td>
<p>list containing the constraint matrix, vector of
inequalities, and RHS vector associated with the boundedness
constraints.</p>
</td></tr>
<tr><td><code id="combinemonobound_+3A_monoa">monoA</code></td>
<td>
<p>list containing the constraint matrix, vector on
inequalities, and RHS vector associated with the monotonicity
constraints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a unified constraint matrix, unified
vector of inequalities, and unified RHS vector for the
boundedness and monotonicity constraints of an LP/QCQP problem.
</p>

<hr>
<h2 id='constructConstant'>Construct constant function</h2><span id='topic+constructConstant'></span>

<h3>Description</h3>

<p>This function constructs another function that returns a
constant. It is used for constructing weight/knot functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructConstant(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="constructConstant_+3A_x">x</code></td>
<td>
<p>scalar, the constant the function evaluates to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function.
</p>

<hr>
<h2 id='criterionMin'>Minimizing violation of observational equivalence</h2><span id='topic+criterionMin'></span>

<h3>Description</h3>

<p>Given a set of IV-like estimates and the set of matrices/vectors
defining an LP problem, this function minimizes the violation of
observational equivalence under the L1 norm. The LP model must be
passed as an environment variable, under the entry <code>$model</code>.
See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>criterionMin(env, sset, solver, solver.options, rescale = FALSE, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="criterionMin_+3A_env">env</code></td>
<td>
<p>environment containing the matrices defining the LP
problem.</p>
</td></tr>
<tr><td><code id="criterionMin_+3A_sset">sset</code></td>
<td>
<p>A list of IV-like estimates and the corresponding gamma
terms.</p>
</td></tr>
<tr><td><code id="criterionMin_+3A_solver">solver</code></td>
<td>
<p>string, name of the package used to solve the LP
problem.</p>
</td></tr>
<tr><td><code id="criterionMin_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should correspond
to an option specific to the LP solver selected.</p>
</td></tr>
<tr><td><code id="criterionMin_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QP/QCP
optimization.</p>
</td></tr>
<tr><td><code id="criterionMin_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The option is only
applied when <code>solver = 'gurobi'</code> or <code>solver =
'rmosek'</code>. The output provided is the same as what the Gurobi
API would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list including the minimum violation of observational
equivalence, the solution to the LP problem, and the status of
the solution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided
sSet &lt;- list()

## Declare MTR formulas
formula0 = ~ 1 + u
formula1 = ~ 1 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'.
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                          data = dtm,
                          uname = u,
                          as.function = FALSE)
polynomials1 &lt;- polyparse(formula = formula1,
                          data = dtm,
                          uname = u,
                           as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(intercept, d),
                          treat = d,
                          list = FALSE)

## Generate target gamma moments
targetGamma &lt;- genTarget(treat = "d",
                         m0 = ~ 1 + u,
                         m1 = ~ 1 + u,
                         target = "atu",
                         data = dtm,
                         splinesobj = splinesList,
                         pmodobj = propensityObj,
                         pm0 = polynomials0,
                         pm1 = polynomials1)

## Construct S-set. which contains the coefficients and weights
## corresponding to various IV-like estimands
sSet &lt;- genSSet(data = dtm,
                sset = sSet,
                sest = ivEstimates,
                splinesobj = splinesList,
                pmodobj = propensityObj$phat,
                pm0 = polynomials0,
                pm1 = polynomials1,
                ncomponents = 2,
                scount = 1,
                yvar = "ey",
                dvar = "d",
                means = TRUE)
## Only the entry $sset is required
sSet &lt;- sSet$sset

## Define additional upper- and lower-bound constraints for the LP
## problem.  The code below imposes a lower bound of 0.2 and upper
## bound of 0.8 on the MTRs.
A &lt;- matrix(0, nrow = 22, ncol = 4)
A &lt;- cbind(A, rbind(cbind(1, seq(0, 1, 0.1)),
                    matrix(0, nrow = 11, ncol = 2)))
A &lt;- cbind(A, rbind(matrix(0, nrow = 11, ncol = 2),
                    cbind(1, seq(0, 1, 0.1))))
sense &lt;- c(rep("&gt;", 11), rep("&lt;", 11))
rhs &lt;- c(rep(0.2, 11), rep(0.8, 11))

## Construct LP object to be interpreted and solved by
## lpSolveAPI. Note that an environment has to be created for the LP
## object. The matrices defining the shape restrictions must be stored
## as a list under the entry \code{$mbobj} in the environment.
modelEnv &lt;- new.env()
modelEnv$mbobj &lt;- list(mbA = A,
                    mbs = sense,
                    mbrhs = rhs)
## Convert the matrices defining the shape constraints into a format
## that is suitable for the LP solver.
lpSetup(env = modelEnv,
        sset = sSet,
        solver = "lpsolveapi")
## Setup LP model so that it will minimize the criterion
lpSetupCriterion(env = modelEnv,
                sset = sSet)
## Declare any LP solver options as a list.
lpOptions &lt;- optionsLpSolveAPI(list(epslevel = "tight"))
## Minimize the criterion.
obseqMin &lt;- criterionMin(env = modelEnv,
                         sset = sSet,
                         solver = "lpsolveapi",
                         solver.options = lpOptions)
obseqMin
cat("The minimum criterion is",  obseqMin$obj, "\n")

</code></pre>

<hr>
<h2 id='design'>Generating design matrices</h2><span id='topic+design'></span>

<h3>Description</h3>

<p>This function generates the design matrix given an IV
specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design(formula, data, subset, treat, orig.names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_+3A_formula">formula</code></td>
<td>
<p>Formula with which to generate the design matrix.</p>
</td></tr>
<tr><td><code id="design_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> with which to generate the design
matrix.</p>
</td></tr>
<tr><td><code id="design_+3A_subset">subset</code></td>
<td>
<p>Condition to select subset of data.</p>
</td></tr>
<tr><td><code id="design_+3A_treat">treat</code></td>
<td>
<p>The name of the treatment variable. This should only
be passed when constructing OLS weights.</p>
</td></tr>
<tr><td><code id="design_+3A_orig.names">orig.names</code></td>
<td>
<p>character vector of the terms in the final design
matrix. This is required when the user declares an IV-like
formula where the treatment variable is passed into the
<code>factor</code> function. Since the treatment variable has to be
fixed to 0 or 1, the design matrix will be unable to construct
the contrasts. The argument <code>orig.names</code> is a vector of
the terms in the IV-like specification prior to fixing the
treatment variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three matrices are returned: one for the outcome variable,
Y; one for the second stage covariates, X; and one for the
first stage covariates, Z.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()
design(formula = ey ~ d | z,
           data = dtm,
           subset = z %in% c(1, 2))

</code></pre>

<hr>
<h2 id='extractcols'>Auxiliary function: extracting columns by component names</h2><span id='topic+extractcols'></span>

<h3>Description</h3>

<p>Auxiliary function to extract columns from a matrix based on column
names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractcols(M, components)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractcols_+3A_m">M</code></td>
<td>
<p>The matrix to extract from.</p>
</td></tr>
<tr><td><code id="extractcols_+3A_components">components</code></td>
<td>
<p>The vector of variable names.</p>
</td></tr>
</table>

<hr>
<h2 id='fmtResult'>Format result for display</h2><span id='topic+fmtResult'></span>

<h3>Description</h3>

<p>This function simply takes a number and formats it for being
displayed. Numbers less than 1 in absolute value are rounded to 6
significant figure. Numbers larger than
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmtResult(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmtResult_+3A_x">x</code></td>
<td>
<p>The scalar to be formated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar.
</p>

<hr>
<h2 id='funEval'>Evaluate a particular function</h2><span id='topic+funEval'></span>

<h3>Description</h3>

<p>This function evaluates a single function in a list of functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funEval(fun, values = NULL, argnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funEval_+3A_fun">fun</code></td>
<td>
<p>the function to be evaluated.</p>
</td></tr>
<tr><td><code id="funEval_+3A_values">values</code></td>
<td>
<p>the values of the arguments to the function. Ordering
is assumed to be the same as in <code>argnames</code>.</p>
</td></tr>
<tr><td><code id="funEval_+3A_argnames">argnames</code></td>
<td>
<p>the argument names corresponding to <code>values</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the output of the function evaluated.
</p>

<hr>
<h2 id='genBasisSplines'>Generate basis matrix for splines</h2><span id='topic+genBasisSplines'></span>

<h3>Description</h3>

<p>The user can declare that the unobservable enters into the MTRs in
the form of splines. This function generates the basis matrix for
the splines. The specifications for the spline must be passed as
the <code>$splineslist</code> object generated by
<code><a href="#topic+removeSplines">removeSplines</a></code>. Note that this function does not
account for any interactions between the splines and the
covariates. Interactions can be added simply by sweeping the basis
matrix by a vector for the values of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genBasisSplines(splines, x, d = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genBasisSplines_+3A_splines">splines</code></td>
<td>
<p>a list. The name of each element should be the
spline command, and each element should be a vector. Each entry
of the vector is a covariate that the spline should be
interacted with. Such an object can be generated by
<code><a href="#topic+removeSplines">removeSplines</a></code>, and accessed using
<code>$splineslist</code>.</p>
</td></tr>
<tr><td><code id="genBasisSplines_+3A_x">x</code></td>
<td>
<p>the values of the unobservable at which the splines basis
should be evaluated.</p>
</td></tr>
<tr><td><code id="genBasisSplines_+3A_d">d</code></td>
<td>
<p>either 0 or 1, indicating the treatment status.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix. The number of rows is equal to the length of
<code>x</code>, and the number of columns depends on the
specifications of the spline. The name of each column takes the
following form: &quot;u[d]S[j].[b]&quot;, where &quot;u&quot; and &quot;S&quot; are fixed and
stand for &quot;unobservable&quot; and &quot;Splines&quot; respectively. &quot;[d]&quot; will
be either 0 or 1, depending on the treatment status. &quot;[j]&quot; will
be an integer indicating which element of the list
<code>splines</code> the column pertains to. &quot;[b]&quot; will be an integer
reflect which component of the basis the column pertains to.
</p>

<hr>
<h2 id='genboundA'>Generating the constraint matrix</h2><span id='topic+genboundA'></span>

<h3>Description</h3>

<p>This function generates the component of the constraint matrix in
the LP/QCQP problem pertaining to the lower and upper bounds on the MTRs
and MTEs. These bounds are declared by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genboundA(
  A0,
  A1,
  sset,
  gridobj,
  uname,
  m0.lb,
  m0.ub,
  m1.lb,
  m1.ub,
  mte.lb,
  mte.ub,
  solution.m0.min = NULL,
  solution.m1.min = NULL,
  solution.m0.max = NULL,
  solution.m1.max = NULL,
  audit.tol,
  direct = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genboundA_+3A_a0">A0</code></td>
<td>
<p>the matrix of values from evaluating the MTR for control
observations over the grid generated to perform the audit. This
matrix will be incorporated into the final constraint matrix
for the bounds.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_a1">A1</code></td>
<td>
<p>the matrix of values from evaluating the MTR for control
observations over the grid generated to perform the audit. This
matrix will be incorporated into the final constraint matrix
for the bounds.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma
components associated with each element in the S-set.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_gridobj">gridobj</code></td>
<td>
<p>a list containing the grid over which the
monotonicity and boundedness conditions are imposed on.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_uname">uname</code></td>
<td>
<p>name declared by user to represent the unobservable
term.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_m0.lb">m0.lb</code></td>
<td>
<p>scalar, lower bound on MTR for control group.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_m0.ub">m0.ub</code></td>
<td>
<p>scalar, upper bound on MTR for control group.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_m1.lb">m1.lb</code></td>
<td>
<p>scalar, lower bound on MTR for treated group.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_m1.ub">m1.ub</code></td>
<td>
<p>scalar, upper bound on MTR for treated group.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_mte.lb">mte.lb</code></td>
<td>
<p>scalar, lower bound on MTE.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_mte.ub">mte.ub</code></td>
<td>
<p>scalar, upper bound on MTE.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_solution.m0.min">solution.m0.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_solution.m1.min">solution.m1.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_solution.m0.max">solution.m0.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_solution.m1.max">solution.m1.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be equal <code>1e-06</code>. This
parameter should only be changed if the feasibility tolerance
of the solver is changed, or if numerical issues result in
discrepancies between the solver's feasibility check and the
audit.</p>
</td></tr>
<tr><td><code id="genboundA_+3A_direct">direct</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the direct MTR
regression is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a constraint matrix for the LP/QCQP problem, the associated
vector of inequalities, and the RHS vector in the inequality
constraint. The objects pertain only to the boundedness
constraints declared by the user.
</p>

<hr>
<h2 id='gendist1'>Generate test distribution 1</h2><span id='topic+gendist1'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1 or 2, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 0 + u and m1 ~ 1 + u. All unobservables
u are integrated out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist1(subN = 5, p1 = 0.4, p2 = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist1_+3A_subn">subN</code></td>
<td>
<p>integer, default set to 5. This is the number of
individuals possessing each value of the instrument. So the
total number of observations is subN * 2.</p>
</td></tr>
<tr><td><code id="gendist1_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist1_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist1e'>Generate test distribution 1 with errors</h2><span id='topic+gendist1e'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1 or 2, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 0 + u and m1 ~ 1 + u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist1e(N = 100, subN = 0.5, p1 = 0.4, p2 = 0.6, v0.sd = 0.5, v1.sd = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist1e_+3A_n">N</code></td>
<td>
<p>integer, default set to 100. Total number of observations
in the data.</p>
</td></tr>
<tr><td><code id="gendist1e_+3A_subn">subN</code></td>
<td>
<p>, default set to 0.5. This is the probability the agent
will have Z = 1.</p>
</td></tr>
<tr><td><code id="gendist1e_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist1e_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
<tr><td><code id="gendist1e_+3A_v0.sd">v0.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 0</code></p>
</td></tr>
<tr><td><code id="gendist1e_+3A_v1.sd">v1.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist2'>Generate test distribution 2</h2><span id='topic+gendist2'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1, 2, or 3, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 1 + u and m1 ~ 1 + u. All unobservables
u are integrated out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist2(subN = 5, p1 = 0.4, p2 = 0.6, p3 = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist2_+3A_subn">subN</code></td>
<td>
<p>integer, default set to 5. This is the number of
individuals possessing each value of the instrument. So the
total number of observations is subN * 2.</p>
</td></tr>
<tr><td><code id="gendist2_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist2_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
<tr><td><code id="gendist2_+3A_p3">p3</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist3'>Generate test distribution 3</h2><span id='topic+gendist3'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1 and 2, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 1 and m1 ~ 1. All unobservables u are
integrated out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist3(subN = 5, p1 = 0.4, p2 = 0.6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist3_+3A_subn">subN</code></td>
<td>
<p>integer, default set to 5. This is the number of
individuals possessing each value of the instrument. So the
total number of observations is subN * 2.</p>
</td></tr>
<tr><td><code id="gendist3_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist3_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist3e'>Generate test distribution 3 with errors</h2><span id='topic+gendist3e'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1 or 2, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 0 + u and m1 ~ 1 + u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist3e(N = 100, subN = 0.5, p1 = 0.4, p2 = 0.6, v0.sd = 0.5, v1.sd = 0.75)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist3e_+3A_n">N</code></td>
<td>
<p>integer, default set to 100. Total number of observations
in the data.</p>
</td></tr>
<tr><td><code id="gendist3e_+3A_subn">subN</code></td>
<td>
<p>, default set to 0.5. This is the probability the agent
will have Z = 1.</p>
</td></tr>
<tr><td><code id="gendist3e_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist3e_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
<tr><td><code id="gendist3e_+3A_v0.sd">v0.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 0</code></p>
</td></tr>
<tr><td><code id="gendist3e_+3A_v1.sd">v1.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist4'>Generate test distribution 4</h2><span id='topic+gendist4'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1, 2, and 3, and the
distribution of the values for the binary instrument is
uniform. The MTRs are m0 ~ 1 and m1 ~ 1. All unobservables u are
integrated out.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist4(subN = 5, p1 = 0.4, p2 = 0.6, p3 = 0.8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist4_+3A_subn">subN</code></td>
<td>
<p>integer, default set to 5. This is the number of
individuals possessing each value of the instrument. So the
total number of observations is subN * 2.</p>
</td></tr>
<tr><td><code id="gendist4_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist4_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
<tr><td><code id="gendist4_+3A_p3">p3</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist5e'>Generate test distribution 5 (has errors and a covariate)</h2><span id='topic+gendist5e'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that takes on values of 1 or 2, and the
distribution of the values for the binary instrument is
uniform. The MTRs are both of the form m ~ 1 + x + u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist5e(N = 100, subN = 0.5, p1 = 0.4, p2 = 0.6, v0.sd = 1, v1.sd = 1.55)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist5e_+3A_n">N</code></td>
<td>
<p>integer, default set to 100. Total number of observations
in the data.</p>
</td></tr>
<tr><td><code id="gendist5e_+3A_subn">subN</code></td>
<td>
<p>, default set to 0.5. This is the probability the agent
will have Z = 1.</p>
</td></tr>
<tr><td><code id="gendist5e_+3A_p1">p1</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 1.</p>
</td></tr>
<tr><td><code id="gendist5e_+3A_p2">p2</code></td>
<td>
<p>the probability of treatment for those with the
instrument Z = 2.</p>
</td></tr>
<tr><td><code id="gendist5e_+3A_v0.sd">v0.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 0</code></p>
</td></tr>
<tr><td><code id="gendist5e_+3A_v1.sd">v1.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendist6e'>Generate test distribution 6 (has errors and a covariate)</h2><span id='topic+gendist6e'></span>

<h3>Description</h3>

<p>This function generates a data set for testing purposes. There is a
single instrument that is uniformly distributed over [0, 1]. The
MTRs are both of the form m ~ 1 + x + x:u.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendist6e(N = 100, v0.sd = 1, v1.sd = 1.55)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendist6e_+3A_n">N</code></td>
<td>
<p>integer, default set to 100. Total number of observations
in the data.</p>
</td></tr>
<tr><td><code id="gendist6e_+3A_v0.sd">v0.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 0</code></p>
</td></tr>
<tr><td><code id="gendist6e_+3A_v1.sd">v1.sd</code></td>
<td>
<p>numeric, standard deviation of error term for
counterfactual <code>D = 1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame.
</p>

<hr>
<h2 id='gendistBasic'>Generate basic data set for testing</h2><span id='topic+gendistBasic'></span>

<h3>Description</h3>

<p>This code generates population level data to test the estimation
function. This is a simpler dataset, one in which we can more
easily estimate a correctly specified model.  The data presented
below will have already integrated over the # unobservable terms
U, where U | X, Z ~ Unif[0, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendistBasic()
</code></pre>


<h3>Value</h3>

<p>a list of two data.frame objects. One is the distribution
of the simulated data, the other is the full simulated data
set.
</p>

<hr>
<h2 id='gendistCovariates'>Generate test data set with covariates</h2><span id='topic+gendistCovariates'></span>

<h3>Description</h3>

<p>This code generates population level data to test the estimation
function. This data includes covariates. The data generated will
have already integrated over the unobservable terms U, where U | X,
Z ~ Unif[0, 1].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendistCovariates()
</code></pre>


<h3>Value</h3>

<p>a list of two data.frame objects. One is the distribution
of the simulated data, the other is the full simulated data
set.
</p>

<hr>
<h2 id='gendistMosquito'>Generate mosquito data set</h2><span id='topic+gendistMosquito'></span>

<h3>Description</h3>

<p>This code generates the population level data in Mogstad, Santos,
Torgovitsky (2018), i.e. the mosquito data set used as the running
example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendistMosquito()
</code></pre>


<h3>Value</h3>

<p>data.frame.
</p>

<hr>
<h2 id='gendistSplines'>Generate test data set with splines</h2><span id='topic+gendistSplines'></span>

<h3>Description</h3>

<p>This code generates population level data to test the
estimation function. This data set incorporates splines in the
MTRs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendistSplines()
</code></pre>


<h3>Details</h3>

<p>The distribution of the data is as follows
</p>
<p>|     Z
X/Z   |  0     1
_______|___________
-1 | 0.1   0.1
|
X   0 | 0.2   0.2
|
1 | 0.1   0.2
</p>
<p>The data presented below will have already integrated over the
unobservable terms U, and U | X, Z ~ Unif[0, 1].
</p>
<p>The propensity scores are generated according to the model
</p>
<p>p(x, z) = 0.5 - 0.1 * x + 0.2 * z
</p>
<p>|     Z
p(X,Z) |  0     1
_______|___________
-1 | 0.6   0.8
|
X   0 | 0.5   0.7
|
1 | 0.4   0.6
</p>
<p>The lowest common multiple of the first table is 12. The lowest
common multiple of the second table is 84. It turns out that 840 *
5 = 4200 observations is enough to generate the population data
set, such that each group has a whole-number of observations.
</p>
<p>The MTRs are defined as follows:
</p>
<p>y1 ~ beta0 + beta1 * x + uSpline(degree = 2,
knots  = c(0.3, 0.6),
intercept = FALSE)
</p>
<p>The coefficients (beta1, beta2), and the coefficients on the
splines, will be defined below.
</p>
<p>y0 = x : uSpline(degree = 0,
knots  = c(0.2, 0.5, 0.8),
intercept = TRUE)
+ uSpline(degree = 1,
knots  = c(0.4),
intercept = TRUE)
+ beta3 * I(u ^ 2)
</p>
<p>The coefficient beta3, and the coefficients on the splines, will be
defined below.
</p>


<h3>Value</h3>

<p>a list of two data.frame objects. One is the distribution
of the simulated data, the other is the full simulated data
set.
</p>

<hr>
<h2 id='genej'>Auxiliary function: generating basis vectors</h2><span id='topic+genej'></span>

<h3>Description</h3>

<p>Auxiliary function to generate standard basis vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genej(pos, length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genej_+3A_pos">pos</code></td>
<td>
<p>The position of the non-zero entry/dimension the basis
vector corresponds to</p>
</td></tr>
<tr><td><code id="genej_+3A_length">length</code></td>
<td>
<p>Number of dimensions in total/length of vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing 1 in a single position, and 0 elsewhere.
</p>

<hr>
<h2 id='genGamma'>Estimating expectations of terms in the MTR (gamma objects)</h2><span id='topic+genGamma'></span>

<h3>Description</h3>

<p>This function generates the gamma objects defined in the paper,
i.e. each additive term in E[md], where md is a MTR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGamma(
  monomials,
  lb,
  ub,
  multiplier = 1,
  subset = NULL,
  means = TRUE,
  late.rows = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGamma_+3A_monomials">monomials</code></td>
<td>
<p>[UPDATE DESCRIPTION] object containing list of
list of monomials. Each element of the outer list represents an
observation in the data set, each element in the inner list is
a monomial from the MTR. The variable is the unobservable u,
and the coefficient is the evaluation of any interactions with
u.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_lb">lb</code></td>
<td>
<p>vector of lower bounds for the interval of
integration. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_ub">ub</code></td>
<td>
<p>vector of upper bounds for the interval of
integration. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_multiplier">multiplier</code></td>
<td>
<p>a vector of the weights that enter into the
integral. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_subset">subset</code></td>
<td>
<p>The row names/numbers of the subset of observations
to use.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_means">means</code></td>
<td>
<p>logical, if TRUE then function returns the terms of
E[md]. If FALSE, then function instead returns each term of
E[md | D, X, Z]. This is useful for testing the code,
i.e. obtaining population estimates.</p>
</td></tr>
<tr><td><code id="genGamma_+3A_late.rows">late.rows</code></td>
<td>
<p>Boolean vector indicating which observations to
include when conditioning on covariates X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>means = TRUE</code>, then the function returns a vector
of the additive terms in Gamma (i.e. the expectation is over D,
X, Z, and u). If <code>means = FALSE</code>, then the function
returns a matrix, where each row corresponds to an observation,
and each column corresponds to an additive term in E[md | D, X,
Z] (i.e. only the integral with respect to u is performed).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare MTR formula
formula0 = ~ 1 + u

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                data = dtm,
                uname = u,
                as.function = FALSE)

## Construct propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate gamma moments, with S-weight equal to its default value
## of 1
genGamma(monomials = polynomials0,
         lb = 0,
         ub = propensityObj$phat)

</code></pre>

<hr>
<h2 id='genGammaSplines'>Generate Gamma moments for splines</h2><span id='topic+genGammaSplines'></span>

<h3>Description</h3>

<p>The user can declare that the unobservable enters into the MTRs in
the form of splines. This function generates the gamma moments for
the splines. The specifications for the spline must be passed as an
element generated by <code><a href="#topic+removeSplines">removeSplines</a></code>. This function
accounts for the interaction between covariates and splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGammaSplines(
  splinesobj,
  data,
  lb,
  ub,
  multiplier = 1,
  subset,
  d = NULL,
  means = TRUE,
  late.rows = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGammaSplines_+3A_splinesobj">splinesobj</code></td>
<td>
<p>a list generated by <code><a href="#topic+removeSplines">removeSplines</a></code>
applied to either the <code>m0</code> and <code>m1</code> argument.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> object containing all the variables
that interact with the spline components.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_lb">lb</code></td>
<td>
<p>vector of lower bounds for the interval of
integration. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_ub">ub</code></td>
<td>
<p>vector of upper bounds for the interval of
integration. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_multiplier">multiplier</code></td>
<td>
<p>a vector of the weights that enter into the
integral. Each element corresponds to an observation.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_subset">subset</code></td>
<td>
<p>Subset condition used to select observations with
which to estimate gamma.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_d">d</code></td>
<td>
<p>either 0 or 1, indicating the treatment status.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_means">means</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. Set to
<code>TRUE</code> if estimates of the gamma moments should be
returned. Set to <code>FALSE</code> if the gamma estimates for each
observation should be returned.</p>
</td></tr>
<tr><td><code id="genGammaSplines_+3A_late.rows">late.rows</code></td>
<td>
<p>Boolean vector indicating which observations to
include when conditioning on covariates X.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, corresponding to the splines being integrated
over the region specified by <code>lb</code> and <code>ub</code>,
accounting for the interaction terms. The number of rows is
equal to the number of rows in <code>data</code>. The number of
columns depends on the specifications of the spline. The name
of each column takes the following form: &quot;u[d]S[j].[b]&quot;, where
&quot;u&quot; and &quot;S&quot; are fixed and stand for &quot;unobservable&quot; and
&quot;Splines&quot; respectively. &quot;[d]&quot; will be either 0 or 1, depending
on the treatment status. &quot;[j]&quot; will be an integer indicating
which element of the list <code>splines</code> the column pertains
to. &quot;[b]&quot; will be an integer reflect which component of the
basis the column pertains to.
</p>

<hr>
<h2 id='genGammaSplinesTT'>Generating the Gamma moments for splines, for 'testthat'</h2><span id='topic+genGammaSplinesTT'></span>

<h3>Description</h3>

<p>This function generates the Gamma moments for a given set of
weights. This funciton is written specifically for tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGammaSplinesTT(distr, weight, zvars, u1s1, u0s1, u0s2, target = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGammaSplinesTT_+3A_distr">distr</code></td>
<td>
<p>data.frame, the distribution of the data.</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_weight">weight</code></td>
<td>
<p>function, the S-function corresponding to a
particular IV-like estimand.</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_zvars">zvars</code></td>
<td>
<p>vector, string names of the covariates, other than the
intercept and treatment variable.</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_u1s1">u1s1</code></td>
<td>
<p>matrix, the spline basis for the treated group (&quot;u1&quot;)
corresponding to the first (and only) spline specification
(&quot;s1&quot;).</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_u0s1">u0s1</code></td>
<td>
<p>matrix, the spline basis for the control group (&quot;u0&quot;)
corresponding to the first spline specification (&quot;s1&quot;).</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_u0s2">u0s2</code></td>
<td>
<p>matrix, the spline basis for the control group (&quot;u0&quot;)
corresponding to the second spline specification (&quot;s2&quot;).</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_target">target</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the gamma moment being
generated corresponds to the target parameter.</p>
</td></tr>
<tr><td><code id="genGammaSplinesTT_+3A_...">...</code></td>
<td>
<p>all other arguments that enter into <code>weight</code>,
excluding the argument <code>d</code> for treatment indicator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, the Gamma moments associated with <code>weight</code>.
</p>

<hr>
<h2 id='genGammaTT'>Function to generate gamma moments for 'testthat'</h2><span id='topic+genGammaTT'></span>

<h3>Description</h3>

<p>This function generates the gamma moments from a population level
data set. This is specifically constructed to carry out tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genGammaTT(data, s0, s1, lb, ub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genGammaTT_+3A_data">data</code></td>
<td>
<p>data.table.</p>
</td></tr>
<tr><td><code id="genGammaTT_+3A_s0">s0</code></td>
<td>
<p>variable name (contained in the data) for the S-weight
used to generate the Gamma moments for the control group.</p>
</td></tr>
<tr><td><code id="genGammaTT_+3A_s1">s1</code></td>
<td>
<p>variable name (contained in the data) for the S-weight
used to generate the Gamma moments for the treated group.</p>
</td></tr>
<tr><td><code id="genGammaTT_+3A_lb">lb</code></td>
<td>
<p>scalar, lower bound for integration.</p>
</td></tr>
<tr><td><code id="genGammaTT_+3A_ub">ub</code></td>
<td>
<p>scalar, upper bound for integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, contains the vectors of the Gamma moments for control
and treated observations.
</p>

<hr>
<h2 id='gengrid'>Generating the grid for the audit procedure</h2><span id='topic+gengrid'></span>

<h3>Description</h3>

<p>This function takes in a matrix summarizing the support of the
covariates, as well as set of points summarizing the support of the
unobservable variable. A Cartesian product of the subset of the
support of the covariates and the points in the support of the
unobservable generates the grid that is used for the audit
procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gengrid(index, xsupport, usupport, uname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gengrid_+3A_index">index</code></td>
<td>
<p>a vector whose elements indicate the rows in the
matrix <code>xsupport</code> to include in the grid.</p>
</td></tr>
<tr><td><code id="gengrid_+3A_xsupport">xsupport</code></td>
<td>
<p>a matrix containing all the unique combinations of
the covariates included in the MTRs.</p>
</td></tr>
<tr><td><code id="gengrid_+3A_usupport">usupport</code></td>
<td>
<p>a vector of points in the interval [0, 1],
including 0 and 1. The number of points is decided by the
user. The function generates these points using a Halton
sequence.</p>
</td></tr>
<tr><td><code id="gengrid_+3A_uname">uname</code></td>
<td>
<p>name declared by user to represent the unobservable
term.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the grid used in the audit; a vector
mapping the elements in the support of the covariates to
<code>index</code>.
</p>

<hr>
<h2 id='genmonoA'>Generate components of the monotonicity constraints</h2><span id='topic+genmonoA'></span>

<h3>Description</h3>

<p>This function generates the matrix and vectors associated with the
monotonicity constraints declared by the user. It takes in a grid
of the covariates on which the shape constraints are defined, and then
calculates the values of the MTR and MTE over the grid. The
matrices characterizing the monotonicity conditions can then be
obtained by taking first differences over the grid of the
unobservable term, within each set of values in the grid of
covariate values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genmonoA(
  A0,
  A1,
  sset,
  uname,
  gridobj,
  gstar0,
  gstar1,
  m0.dec,
  m0.inc,
  m1.dec,
  m1.inc,
  mte.dec,
  mte.inc,
  solution.m0.min = NULL,
  solution.m1.min = NULL,
  solution.m0.max = NULL,
  solution.m1.max = NULL,
  audit.tol,
  direct
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genmonoA_+3A_a0">A0</code></td>
<td>
<p>the matrix of values from evaluating the MTR for control
observations over the grid generated to perform the audit. This
matrix will be incorporated into the final constraint matrix
for the monotonicity conditions.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_a1">A1</code></td>
<td>
<p>the matrix of values from evaluating the MTR for control
observations over the grid generated to perform the audit. This
matrix will be incorporated into the final constraint matrix
for the monotonicity conditions.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma
components associated with each element in the S-set.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_uname">uname</code></td>
<td>
<p>Name of unobserved variable.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_gridobj">gridobj</code></td>
<td>
<p>a list containing the grid over which the
monotonicity and boundedness conditions are imposed on.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_gstar0">gstar0</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_gstar1">gstar1</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_m0.dec">m0.dec</code></td>
<td>
<p>boolean, indicating whether the MTR for the control
group is monotone decreasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_m0.inc">m0.inc</code></td>
<td>
<p>boolean, indicating whether the MTR for the control
group is monotone increasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_m1.dec">m1.dec</code></td>
<td>
<p>boolean, indicating whether the MTR for the treated
group is monotone decreasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_m1.inc">m1.inc</code></td>
<td>
<p>boolean, indicating whether the MTR for the treated
group is monotone increasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_mte.dec">mte.dec</code></td>
<td>
<p>boolean, indicating whether the MTE is monotone
decreasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_mte.inc">mte.inc</code></td>
<td>
<p>boolean, indicating whether the MTE is monotone
increasing.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_solution.m0.min">solution.m0.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_solution.m1.min">solution.m1.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_solution.m0.max">solution.m0.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_solution.m1.max">solution.m1.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be equal <code>1e-06</code>. This
parameter should only be changed if the feasibility tolerance
of the solver is changed, or if numerical issues result in
discrepancies between the solver's feasibility check and the
audit.</p>
</td></tr>
<tr><td><code id="genmonoA_+3A_direct">direct</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the direct MTR
regression is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>constraint matrix for the LP/QCQP problem. The matrix pertains
only to the monotonicity conditions on the MTR and MTE declared
by the user.
</p>

<hr>
<h2 id='genmonoboundA'>Generating monotonicity and boundedness constraints</h2><span id='topic+genmonoboundA'></span>

<h3>Description</h3>

<p>This is a wrapper function generating the matrices and vectors
associated with the monotonicity and boundedness constraints
declared by the user. Since this function generates all the
components required for the shape constraints, it is also the
function that performs the audit. That is, MTR coefficients are
passed, then this function will verify whether they satisfy the
shape constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genmonoboundA(
  pm0,
  pm1,
  support,
  grid_index,
  uvec,
  splinesobj,
  monov,
  uname,
  m0,
  m1,
  sset,
  gstar0,
  gstar1,
  m0.lb,
  m0.ub,
  m1.lb,
  m1.ub,
  mte.lb,
  mte.ub,
  m0.dec,
  m0.inc,
  m1.dec,
  m1.inc,
  mte.dec,
  mte.inc,
  solution.m0.min = NULL,
  solution.m1.min = NULL,
  solution.m0.max = NULL,
  solution.m1.max = NULL,
  audit.tol,
  direct
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genmonoboundA_+3A_pm0">pm0</code></td>
<td>
<p>A list of the monomials in the MTR for d = 0.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_pm1">pm1</code></td>
<td>
<p>A list of the monomials in the MTR for d = 1.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_support">support</code></td>
<td>
<p>a matrix for the support of all variables that enter
into the MTRs.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_grid_index">grid_index</code></td>
<td>
<p>a vector, the row numbers of <code>support</code> used
to generate the grid preceding the audit.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_uvec">uvec</code></td>
<td>
<p>a vector, the points in the interval [0, 1] that the
unobservable takes on.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_splinesobj">splinesobj</code></td>
<td>
<p>a list of lists. Each of the inner lists contains
details on the splines declared in the MTRs.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_monov">monov</code></td>
<td>
<p>name of variable for which the monotonicity conditions
applies to.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_uname">uname</code></td>
<td>
<p>name declared by user to represent the unobservable
term in the MTRs.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for marginal treatment response
function for the control group. The formula may differ from
what the user originally input in <code><a href="#topic+ivmte">ivmte</a></code>, as the
spline components should have been removed. This formula is
simply a linear combination of all covariates that enter into
the original <code>m0</code> declared by the user in
<code><a href="#topic+ivmte">ivmte</a></code>.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for marginal treatment response
function for the treated group. The formula may differ from
what the user originally input in <code><a href="#topic+ivmte">ivmte</a></code>, as the
spline components should have been removed. This formula is
simply a linear combination of all covariates that enter into
the original <code>m1</code> declared by the user in
<code><a href="#topic+ivmte">ivmte</a></code>.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma
components associated with each element in the S-set.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_gstar0">gstar0</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_gstar1">gstar1</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m0.lb">m0.lb</code></td>
<td>
<p>scalar, lower bound on MTR for control group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m0.ub">m0.ub</code></td>
<td>
<p>scalar, upper bound on MTR for control group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m1.lb">m1.lb</code></td>
<td>
<p>scalar, lower bound on MTR for treated group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m1.ub">m1.ub</code></td>
<td>
<p>scalar, upper bound on MTR for treated group.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_mte.lb">mte.lb</code></td>
<td>
<p>scalar, lower bound on MTE.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_mte.ub">mte.ub</code></td>
<td>
<p>scalar, upper bound on MTE.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m0.dec">m0.dec</code></td>
<td>
<p>boolean, indicating whether the MTR for the control
group is monotone decreasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m0.inc">m0.inc</code></td>
<td>
<p>boolean, indicating whether the MTR for the control
group is monotone increasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m1.dec">m1.dec</code></td>
<td>
<p>boolean, indicating whether the MTR for the treated
group is monotone decreasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_m1.inc">m1.inc</code></td>
<td>
<p>boolean, indicating whether the MTR for the treated
group is monotone increasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_mte.dec">mte.dec</code></td>
<td>
<p>boolean, indicating whether the MTE is monotone
decreasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_mte.inc">mte.inc</code></td>
<td>
<p>boolean, indicating whether the MTE is monotone
increasing.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_solution.m0.min">solution.m0.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_solution.m1.min">solution.m1.min</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the lower bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_solution.m0.max">solution.m0.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 0</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_solution.m1.max">solution.m1.max</code></td>
<td>
<p>vector, the coefficients for the MTR for
<code>D = 1</code> corresponding to the upper bound of the target
parameter. If passed, this will initiate checks of shape
constraints.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be equal <code>1e-06</code>. This
parameter should only be changed if the feasibility tolerance
of the solver is changed, or if numerical issues result in
discrepancies between the solver's feasibility check and the
audit.</p>
</td></tr>
<tr><td><code id="genmonoboundA_+3A_direct">direct</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the direct MTR
regression is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing a unified constraint matrix, unified
vector of inequalities, and unified RHS vector for the
boundedness and monotonicity constraints of an LP/QCQP problem.
</p>

<hr>
<h2 id='genSSet'>Generating moments/data for IV-like estimands</h2><span id='topic+genSSet'></span>

<h3>Description</h3>

<p>This function takes in the IV estimate and its IV-like
specification, and generates a list containing the corresponding
IV-like point estimate, and the corresponding moments (gammas) that
will enter into the constraint matrix of the LP problem. If the
option <code>means = FALSE</code>, then the data are not averaged to
generate the gamma moments and may be used for GMM. The function
requires the user to provide a list (i.e. the list the point
estimates and moments corresponding to other IV-like
specifications; or an empty list) to append these point estimates
and moments to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genSSet(
  data,
  sset,
  sest,
  splinesobj,
  pmodobj,
  pm0,
  pm1,
  ncomponents,
  scount,
  subset_index,
  means = TRUE,
  yvar,
  dvar,
  noisy = TRUE,
  ivn = NULL,
  redundant = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genSSet_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> used to estimate the treatment
effects.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_sset">sset</code></td>
<td>
<p>list, which is modified and returned as the
output. This object will contain all the information from the
IV-like specifications that can be used for estimating the
treatment effect.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_sest">sest</code></td>
<td>
<p>list containing the point estimates and S-weights
corresponding to a particular IV-like estimand.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_splinesobj">splinesobj</code></td>
<td>
<p>list of spline components in the MTRs for treated
and control groups. Spline terms are extracted using
<code><a href="#topic+removeSplines">removeSplines</a></code>.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_pmodobj">pmodobj</code></td>
<td>
<p>vector of propensity scores.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_pm0">pm0</code></td>
<td>
<p>list of the monomials in the MTR for the control group.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_pm1">pm1</code></td>
<td>
<p>list of the monomials in the MTR for the treated group.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_ncomponents">ncomponents</code></td>
<td>
<p>The number of components from the IV regression
to include in the S-set.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_scount">scount</code></td>
<td>
<p>integer, an index for the elements in the S-set.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_subset_index">subset_index</code></td>
<td>
<p>vector of integers, a row index for the subset of
the data the IV regression is restricted to.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_means">means</code></td>
<td>
<p>boolean, set to <code>TRUE</code> by default. If set to
<code>TRUE</code>, then the gamma moments are returned, i.e. sample
averages are taken. If set to <code>FALSE</code>, then no sample
averages are taken, and a matrix is returned. The sample
average of each column of the matrix corresponds to a
particular gamma moment.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_yvar">yvar</code></td>
<td>
<p>name of outcome variable. This is only used if
<code>means = FALSE</code>, which occurs when the user believes the
treatment effect is point identified.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_dvar">dvar</code></td>
<td>
<p>name of treatment indicator. This is only used if
<code>means = FALSE</code>, which occurs when the user believes the
treatment effect is point identified.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_ivn">ivn</code></td>
<td>
<p>integer, the number indicating which IV specification
the component corresponds to.</p>
</td></tr>
<tr><td><code id="genSSet_+3A_redundant">redundant</code></td>
<td>
<p>vector of integers indicating which components in
the S-set are redundant.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the point estimate for the IV regression,
and the expectation of each monomial term in the MTR.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided)
sSet &lt;- list()

## Declare MTR formulas
formula1 = ~ 1 + u
formula0 = ~ 1 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'.
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

polynomials1 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(d),
                          treat = d,
                          list = FALSE)

## Construct S-set, which contains the coefficients and weights
## corresponding to various IV-like estimands
genSSet(data = dtm,
        sset = sSet,
        sest = ivEstimates,
        splinesobj = splinesList,
        pmodobj = propensityObj$phat,
        pm0 = polynomials0,
        pm1 = polynomials1,
        ncomponents = 1,
        scount = 1)

</code></pre>

<hr>
<h2 id='genTarget'>Generating target MTR moments</h2><span id='topic+genTarget'></span>

<h3>Description</h3>

<p>This function estimates the moment of each MTR term under the
target weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genTarget(
  treat,
  m0,
  m1,
  target,
  target.weight0,
  target.weight1,
  target.knots0,
  target.knots1,
  late.Z,
  late.from,
  late.to,
  late.X,
  eval.X,
  genlate.lb,
  genlate.ub,
  data,
  splinesobj,
  pmodobj,
  pm0,
  pm1,
  noisy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genTarget_+3A_treat">treat</code></td>
<td>
<p>variable name for treatment indicator. The name can be
provided with or without quotation marks.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the control group. Splines may also be
incorporated using the expression <code>uSpline</code>, e.g.
<code>uSpline(degree = 2, knots = c(0.4, 0.8), intercept =
TRUE)</code>. The <code>intercept</code> argument may be omitted, and is
set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the treated group. See <code>m0</code> for details.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_target">target</code></td>
<td>
<p>character, target parameter to be estimated. The
function allows for ATE (<code>'ate'</code>), ATT (<code>'att'</code>), ATU
(<code>'atu'</code>), LATE (<code>'late'</code>), and generalized LATE
(<code>'genlate'</code>).</p>
</td></tr>
<tr><td><code id="genTarget_+3A_target.weight0">target.weight0</code></td>
<td>
<p>user-defined weight function for the control
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
<code>data</code>. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_target.weight1">target.weight1</code></td>
<td>
<p>user-defined weight function for the treated
group defining the target parameter. See <code>target.weight0</code>
for details.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_target.knots0">target.knots0</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the control group. The
arguments of the function should consist only of variable names
in <code>data</code>. If the knots are constant across all
observations, then the user can instead submit the vector of
knots instead of a function.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_target.knots1">target.knots1</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the treated group. See
<code>target.knots0</code> for details.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_late.z">late.Z</code></td>
<td>
<p>vector of variable names used to define the LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_late.from">late.from</code></td>
<td>
<p>baseline set of values of Z used to define the
LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_late.to">late.to</code></td>
<td>
<p>comparison set of values of Z used to define the
LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_late.x">late.X</code></td>
<td>
<p>vector of variable names of covariates to condition
on when defining the LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_eval.x">eval.X</code></td>
<td>
<p>numeric vector of the values to condition variables
in <code>late.X</code> on when estimating the LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_genlate.lb">genlate.lb</code></td>
<td>
<p>lower bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_genlate.ub">genlate.ub</code></td>
<td>
<p>upper bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> used to estimate
the treatment effects.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_splinesobj">splinesobj</code></td>
<td>
<p>list of spline components in the MTRs for treated
and control groups. Spline terms are extracted using
<code><a href="#topic+removeSplines">removeSplines</a></code>. This object is supposed to be a
dictionary of splines, containing the original calls of each
spline in the MTRs, their specifications, and the index used
for naming each basis spline.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_pmodobj">pmodobj</code></td>
<td>
<p>A vector of propensity scores.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_pm0">pm0</code></td>
<td>
<p>A list of the monomials in the MTR for d = 0.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_pm1">pm1</code></td>
<td>
<p>A list of the monomials in the MTR for d = 1.</p>
</td></tr>
<tr><td><code id="genTarget_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing either the vectors of gamma moments for
<code>D = 0</code> and <code>D = 1</code>, or a matrix of individual gamma
values for <code>D = 0</code> and <code>D = 1</code>. Additoinally, two
vectors are returned. <code>xindex0</code> and <code>xindex1</code> list
the variables that interact with the unobservable <code>u</code> in
<code>m0</code> and <code>m1</code>. <code>uexporder0</code> and
<code>uexporder1</code> lists the exponents of the unobservable
<code>u</code> in each term it appears in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare MTR functions
formula1 = ~ 1 + u
formula0 = ~ 1 + u
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Declare propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

polynomials1 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

## Generate target gamma moments
genTarget(treat = "d",
          m0 = ~ 1 + u,
          m1 = ~ 1 + u,
          target = "atu",
          data = dtm,
          splinesobj = splinesList,
          pmodobj = propensityObj,
          pm0 = polynomials0,
          pm1 = polynomials1)

</code></pre>

<hr>
<h2 id='genWeight'>Generating list of target weight functions</h2><span id='topic+genWeight'></span>

<h3>Description</h3>

<p>This function takes in the user-defined target weight functions and
the data set, and generates the weight functions for each
observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genWeight(fun, fun.name, uname, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genWeight_+3A_fun">fun</code></td>
<td>
<p>custom weight function defined by the user. Arguments of
the weight function must only be names of variables entering
into the function, and can include the unobserved variable.</p>
</td></tr>
<tr><td><code id="genWeight_+3A_fun.name">fun.name</code></td>
<td>
<p>string, name of function.</p>
</td></tr>
<tr><td><code id="genWeight_+3A_uname">uname</code></td>
<td>
<p>the name assigned to the unobserved variable entering
into the MTR.</p>
</td></tr>
<tr><td><code id="genWeight_+3A_data">data</code></td>
<td>
<p>a named vector containing the values of the variables
defining the 'fun', excluding the value of the unobservable
(generated from applying split() to a data.frame).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The weight function 'fun', where all arguments other than
that of the unobserved variable are fixed according to the
vector 'data'.
</p>

<hr>
<h2 id='getXZ'>Auxiliary function: extract X and Z covariates from a formula</h2><span id='topic+getXZ'></span>

<h3>Description</h3>

<p>Auxiliary function that takes in a two-sided formula, and extracts
the variable names of either the covariates or instruments. The
function returns an error if the formula includes a variable called
'intercept'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getXZ(fm, inst = FALSE, terms = FALSE, components = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getXZ_+3A_fm">fm</code></td>
<td>
<p>the formula.</p>
</td></tr>
<tr><td><code id="getXZ_+3A_inst">inst</code></td>
<td>
<p>boolean expression, set to TRUE if the instrument names
are to be extracted. Otherwise, the covariate names are
extracted.</p>
</td></tr>
<tr><td><code id="getXZ_+3A_terms">terms</code></td>
<td>
<p>boolean expression, set to TRUE if the terms in the
formula <code>fm</code> should be returned instead of the variable
names.</p>
</td></tr>
<tr><td><code id="getXZ_+3A_components">components</code></td>
<td>
<p>boolean expression, set to FALSE by
default. Indicates that the formula being considered is
constructed from a list of components, and thus the term
'intercept' is permitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names.
</p>

<hr>
<h2 id='gmmEstimate'>GMM estimate of TE under point identification</h2><span id='topic+gmmEstimate'></span>

<h3>Description</h3>

<p>If the user sets the argument <code>point = TRUE</code> in the function
<code>ivmte</code>, then it is assumed that the treatment effect
parameter is point identified. The observational equivalence
condition is then set up as a two-step GMM problem. Solving this
GMM problem recovers the coefficients on the MTR functions m0 and
m1. Combining these coefficients with the target gamma moments
allows one to estimate the target treatment effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmmEstimate(
  sset,
  gstar0,
  gstar1,
  center = NULL,
  subsetList = NULL,
  n = NULL,
  redundant = NULL,
  identity = FALSE,
  nMoments,
  splines,
  noisy = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmmEstimate_+3A_sset">sset</code></td>
<td>
<p>a list of lists constructed from the function
<a href="#topic+genSSet">genSSet</a>. Each inner list should include a coefficient
corresponding to a term in an IV specification, a matrix of the
estimates of the gamma moments conditional on (X, Z) for the
control group, and a matrix of the estimates of the gamma
moments conditional on (X, Z) for the treated group. The column
means of the last two matrices is what is used to generate the
gamma moments.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_gstar0">gstar0</code></td>
<td>
<p>vector, the target gamma moments for the control
group.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_gstar1">gstar1</code></td>
<td>
<p>vector, the target gamma moments for the treated
group.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_center">center</code></td>
<td>
<p>numeric, the GMM moment equations from the original
sample. When bootstrapping, the solution to the point
identified case obtained from the original sample can be passed
through this argument to recenter the bootstrap distribution of
the J-statistic.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_subsetlist">subsetList</code></td>
<td>
<p>list of subset indexes, one for each IV-like
specification.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_n">n</code></td>
<td>
<p>number of observations in the data. This option is only
used when subsetting is involved.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_redundant">redundant</code></td>
<td>
<p>vector of integers indicating which components in
the S-set are redundant.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_identity">identity</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> if GMM point estimate should use the identity
weighting matrix (i.e. one-step GMM).</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_nmoments">nMoments</code></td>
<td>
<p>number of linearly independent moments. This option
is used to determine the cause of underidentified cases.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_splines">splines</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTRs involve
splines. This option is used to determine the cause of
underidentified cases.</p>
</td></tr>
<tr><td><code id="gmmEstimate_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the point estimate of the treatment
effects, and the MTR coefficient estimates. The moment
conditions evaluated at the solution are also returned, along
with the J-test results. However, if the option <code>center</code>
is passed, then the moment conditions and J-test are centered
(this is to perform the J-test via bootstrap).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided
sSet &lt;- list()

## Declare MTR formulas
formula1 = ~ 0 + u
formula0 = ~ 0 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'.
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)
polynomials1 &lt;- polyparse(formula = formula0,
                 data = dtm,
                 uname = u,
                 as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(intercept, d),
                          treat = d,
                          list = FALSE)

## Generate target gamma moments
targetGamma &lt;- genTarget(treat = "d",
                         m0 = ~ 1 + u,
                         m1 = ~ 1 + u,
                         target = "atu",
                         data = dtm,
                         splinesobj = splinesList,
                         pmodobj = propensityObj,
                         pm0 = polynomials0,
                         pm1 = polynomials1)

## Construct S-set. which contains the coefficients and weights
## corresponding to various IV-like estimands
sSet &lt;- genSSet(data = dtm,
                sset = sSet,
                sest = ivEstimates,
                splinesobj = splinesList,
                pmodobj = propensityObj$phat,
                pm0 = polynomials0,
                pm1 = polynomials1,
                ncomponents = 2,
                scount = 1,
                yvar = "ey",
                dvar = "d",
                means = FALSE)

## Obtain point estimates using GMM
gmmEstimate(sset = sSet$sset,
            gstar0 = targetGamma$gstar0,
            gstar1 = targetGamma$gstar1)

</code></pre>

<hr>
<h2 id='interactSplines'>Update splines object with list of interactions</h2><span id='topic+interactSplines'></span>

<h3>Description</h3>

<p>Certain interactions between factor variables and splines should be
dropped to avoid collinearity. Albeit collinearity in the MTR
specification will not impact the bounds, it can substantially
impact how costly it is to carry out the estimation. What this
function does is map each spline to a temporary variable. A design
matrix is then constructed using these temporary variables in place
the splines. If an interaction involving one of the temporary
variables is dropped, then one knows to also drop the corresponding
interaction with the spline. Note that only interaction terms need
to be omitted, so one does not need to worry about the formula
contained in removeSplines$formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interactSplines(splinesobj, m0, m1, data, uname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interactSplines_+3A_splinesobj">splinesobj</code></td>
<td>
<p>list, consists of two elelments. The first is
<code>removeSplines(m0)</code>, the second is
<code>removeSplines(m1)</code>.</p>
</td></tr>
<tr><td><code id="interactSplines_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the control group. This should be the full MTR
specificaiton (i.e. not the specification after removing the
splines).</p>
</td></tr>
<tr><td><code id="interactSplines_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the treated group. This should be the full MTR
specificaiton (i.e. not the specification after removing the
splines).</p>
</td></tr>
<tr><td><code id="interactSplines_+3A_data">data</code></td>
<td>
<p>data.frame, restricted to complete observations.</p>
</td></tr>
<tr><td><code id="interactSplines_+3A_uname">uname</code></td>
<td>
<p>string, name of the unobserved variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated version of <code>splinesobj</code>.
</p>

<hr>
<h2 id='isfunctionstring'>Auxiliary function: check if string is command</h2><span id='topic+isfunctionstring'></span>

<h3>Description</h3>

<p>Auxiliary function to check if a string is in fact a command, but
in string form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isfunctionstring(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isfunctionstring_+3A_string">string</code></td>
<td>
<p>the string object to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean expression.
</p>

<hr>
<h2 id='ivEstimate'>Obtaining IV-like specifications</h2><span id='topic+ivEstimate'></span>

<h3>Description</h3>

<p>This function estimates the IV-like estimands, as well as generates
the weights associated with the IV-like specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivEstimate(
  formula,
  data,
  subset,
  components,
  treat,
  list = FALSE,
  order = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivEstimate_+3A_formula">formula</code></td>
<td>
<p>formula to be estimated using OLS/IV.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> with which to perform the estimation.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_subset">subset</code></td>
<td>
<p>subset condition with which to perform the estimate.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_components">components</code></td>
<td>
<p>vector of variable names whose coefficients we
want to include in the set of IV-like estimands.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_treat">treat</code></td>
<td>
<p>name of treatment indicator variable.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_list">list</code></td>
<td>
<p>logical, set to TRUE if this function is being used to
loop over a list of formulas.</p>
</td></tr>
<tr><td><code id="ivEstimate_+3A_order">order</code></td>
<td>
<p>integer, default set to <code>NULL</code>. This is simply an
index of which IV-like specification the estimate corresponds
to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the matrices of IV-like
specifications for <code>D = 0</code> and <code>D = 1</code>; and the
estimates of the IV-like estimands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()
ivEstimate(formula = ey ~ d | z,
           data = dtm,
           components = l(d),
           treat = d,
           list = FALSE)
</code></pre>

<hr>
<h2 id='ivmte'>Instrumental Variables: Extrapolation by Marginal Treatment Effects</h2><span id='topic+ivmte'></span>

<h3>Description</h3>

<p>This function provides a general framework for using the marginal
treatment effect (MTE) to extrapolate. The model is the same binary
treatment instrumental variable (IV) model considered by Imbens and
Angrist (1994) (doi: <a href="https://doi.org/10.2307/2951620">10.2307/2951620</a>) and Heckman and Vytlacil
(2005) (doi: <a href="https://doi.org/10.1111/j.1468-0262.2005.00594.x">10.1111/j.1468-0262.2005.00594.x</a>). The framework on
which this function is based was developed by Mogstad, Santos and
Torgovitsky (2018) (doi: <a href="https://doi.org/10.3982/ECTA15463">10.3982/ECTA15463</a>). See also the recent
survey paper on extrapolation in IV models by Mogstad and
Torgovitsky (2018)
(doi: <a href="https://doi.org/10.1146/annurev-economics-101617-041813">10.1146/annurev-economics-101617-041813</a>). A detailed
description of the module and its features can be found in
<a href="https://a-torgovitsky.github.io/shea-torgovitsky.pdf">Shea
and Torgovitsky (2021)</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivmte(
  data,
  target,
  late.from,
  late.to,
  late.X,
  genlate.lb,
  genlate.ub,
  target.weight0 = NULL,
  target.weight1 = NULL,
  target.knots0 = NULL,
  target.knots1 = NULL,
  m0,
  m1,
  uname = u,
  m1.ub,
  m0.ub,
  m1.lb,
  m0.lb,
  mte.ub,
  mte.lb,
  m0.dec,
  m0.inc,
  m1.dec,
  m1.inc,
  mte.dec,
  mte.inc,
  equal.coef,
  ivlike,
  components,
  subset,
  propensity,
  link = "logit",
  treat,
  outcome,
  solver,
  solver.options,
  solver.presolve,
  solver.options.criterion,
  solver.options.bounds,
  lpsolver,
  lpsolver.options,
  lpsolver.presolve,
  lpsolver.options.criterion,
  lpsolver.options.bounds,
  criterion.tol = 1e-04,
  initgrid.nx = 20,
  initgrid.nu = 20,
  audit.nx = 2500,
  audit.nu = 25,
  audit.add = 100,
  audit.max = 25,
  audit.tol,
  rescale,
  point,
  point.eyeweight = FALSE,
  bootstraps = 0,
  bootstraps.m,
  bootstraps.replace = TRUE,
  levels = c(0.99, 0.95, 0.9),
  ci.type = "backward",
  specification.test = TRUE,
  noisy = FALSE,
  smallreturnlist = FALSE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivmte_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> used to estimate
the treatment effects.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_target">target</code></td>
<td>
<p>character, target parameter to be estimated. The
function allows for ATE (<code>'ate'</code>), ATT (<code>'att'</code>), ATU
(<code>'atu'</code>), LATE (<code>'late'</code>), and generalized LATE
(<code>'genlate'</code>).</p>
</td></tr>
<tr><td><code id="ivmte_+3A_late.from">late.from</code></td>
<td>
<p>a named vector or a list declaring the baseline
values of Z used to define the LATE. The name associated with
each value should be the name of the corresponding variable.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_late.to">late.to</code></td>
<td>
<p>a named vector or a list declaring the comparison
set of values of Z used to define the LATE. The name associated
with each value should be the name of the corresponding
variable.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_late.x">late.X</code></td>
<td>
<p>a named vector or a list declaring the values to
condition on. The name associated with each value should be the
name of the corresponding variable.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_genlate.lb">genlate.lb</code></td>
<td>
<p>lower bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_genlate.ub">genlate.ub</code></td>
<td>
<p>upper bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_target.weight0">target.weight0</code></td>
<td>
<p>user-defined weight function for the control
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
<code>data</code>. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_target.weight1">target.weight1</code></td>
<td>
<p>user-defined weight function for the treated
group defining the target parameter. See <code>target.weight0</code>
for details.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_target.knots0">target.knots0</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the control group. The
arguments of the function should consist only of variable names
in <code>data</code>. If the knots are constant across all
observations, then the user can instead submit the vector of
knots instead of a function.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_target.knots1">target.knots1</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the treated group. See
<code>target.knots0</code> for details.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the control group. Splines may also be
incorporated using the expression <code>uSpline</code>, e.g.
<code>uSpline(degree = 2, knots = c(0.4, 0.8), intercept =
TRUE)</code>. The <code>intercept</code> argument may be omitted, and is
set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the treated group. See <code>m0</code> for details.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_uname">uname</code></td>
<td>
<p>variable name for the unobservable used in declaring
the MTRs. The name can be provided with or without quotation
marks.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m1.ub">m1.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the treated
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m0.ub">m0.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the control
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m1.lb">m1.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the treated
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m0.lb">m0.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the control
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_mte.ub">mte.ub</code></td>
<td>
<p>numeric value for upper bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_mte.lb">mte.lb</code></td>
<td>
<p>numeric value for lower bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m0.dec">m0.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m0.inc">m0.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m1.dec">m1.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_m1.inc">m1.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_mte.dec">mte.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_mte.inc">mte.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_equal.coef">equal.coef</code></td>
<td>
<p>one-sided formula to indicate which terms in
<code>m0</code> and <code>m1</code> should be constrained to have the same
coefficients. These terms therefore have no effect on the MTE.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_ivlike">ivlike</code></td>
<td>
<p>formula or vector of formulas specifying the
regressions for the IV-like estimands. Which coefficients to
use to define the constraints determining the treatment effect
bounds (alternatively, the moments determining the treatment
effect point estimate) can be selected in the argument
<code>components</code>. If no argument is passed, then a linear
regression will be performed to estimate the MTR coefficients.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_components">components</code></td>
<td>
<p>a list of vectors of the terms in the regression
specifications to include in the set of IV-like estimands. No
terms should be in quotes. To select the intercept term,
include the name <code>intercept</code>. If the factorized
counterpart of a variable is included in the IV-like
specifications, e.g. <code>factor(x)</code> where <code>x = 1, 2, 3</code>,
the user can select the coefficients for specific factors by
declaring the components <code>factor(x)-1, factor(x)-2,
factor(x)-3</code>. See <code><a href="#topic+l">l</a></code> on how to input the
argument. If no components for a IV specification are given,
then all coefficients from that IV specification will be used
to define constraints in the partially identified case, or to
define moments in the point identified case.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_subset">subset</code></td>
<td>
<p>a single subset condition or list of subset
conditions corresponding to each regression specified in
<code>ivlike</code>. The input must be logical. See <code><a href="#topic+l">l</a></code>
on how to input the argument. If the user wishes to select
specific rows, construct a binary variable in the data set, and
set the condition to use only those observations for which the
binary variable is 1, e.g. the binary variable is <code>use</code>,
and the subset condition is <code>use == 1</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_propensity">propensity</code></td>
<td>
<p>formula or variable name corresponding to
propensity to take up treatment. If a formula is declared, then
the function estimates the propensity score according to the
formula and link specified in <code>link</code>. If a variable name
is declared, then the corresponding column in the data is taken
as the vector of propensity scores. A variable name can be
passed either as a string (e.g <code>propensity = 'p'</code>), a
variable (e.g. <code>propensity = p</code>), or a one-sided formula
(e.g. <code>propensity = ~p</code>).</p>
</td></tr>
<tr><td><code id="ivmte_+3A_link">link</code></td>
<td>
<p>character, name of link function to estimate propensity
score. Can be chosen from <code>'linear'</code>, <code>'probit'</code>, or
<code>'logit'</code>. Default is set to <code>'logit'</code>. The link
should be provided with quoation marks.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_treat">treat</code></td>
<td>
<p>variable name for treatment indicator. The name can be
provided with or without quotation marks.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_outcome">outcome</code></td>
<td>
<p>variable name for outcome variable. The name can be
provided with or without quotation marks.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_solver">solver</code></td>
<td>
<p>character, name of the programming package in R used
to obtain the bounds on the treatment effect. The function
supports <code>'gurobi'</code>, <code>'cplexapi'</code>, <code>rmosek</code>,
<code>'lpsolveapi'</code>. The name of the solver should be provided
with quotation marks.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should correspond
to an option specific to the solver selected.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_solver.presolve">solver.presolve</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. Set
this parameter to <code>FALSE</code> if presolve should be turned off
for the LP/QCQP problems.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_solver.options.criterion">solver.options.criterion</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the minimum criterion.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_solver.options.bounds">solver.options.bounds</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the bounds.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_lpsolver">lpsolver</code></td>
<td>
<p>character, deprecated argument for <code>lpsolver</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_lpsolver.options">lpsolver.options</code></td>
<td>
<p>list, deprecated argument for
<code>solver.options</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_lpsolver.presolve">lpsolver.presolve</code></td>
<td>
<p>boolean, deprecated argument for
<code>solver.presolve</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_lpsolver.options.criterion">lpsolver.options.criterion</code></td>
<td>
<p>list, deprecated argument for
<code>solver.options.criterion</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_lpsolver.options.bounds">lpsolver.options.bounds</code></td>
<td>
<p>list, deprecated argument for
<code>solver.options.bounds</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>tolerance for the criterion function, and is
set to 1e-4 by default. The criterion measures how well the
IV-like moments/conditional means are matched using the
l1-norm. Statistical noise may prohibit the theoretical LP/QCQP
problem from being feasible. That is, there may not exist a set
of MTR coefficients that are able to match all the specified
moments. The function thus first estimates the minimum
criterion, which is reported in the output under the name
'minimum criterion', with a criterion of 0 meaning that all
moments were able to be matched. The function then relaxes the
constraints by tolerating a criterion up to <code>minimum
criterion * (1 + criterion.tol)</code>. Set <code>criterion.tol</code> to a
value greater than 0 to allow for more conservative bounds.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_initgrid.nx">initgrid.nx</code></td>
<td>
<p>integer determining the number of points of the
covariates used to form the initial constraint grid for
imposing shape restrictions on the MTRs.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_initgrid.nu">initgrid.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are
always a subset of the points defining the audit grid (see
<code>audit.nu</code>). These points are used to form the initial
constraint grid for imposing shape restrictions on the <code>u</code>
components of the MTRs.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_audit.nx">audit.nx</code></td>
<td>
<p>integer determining the number of points on the
covariates space to audit in each iteration of the audit
procedure.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_audit.nu">audit.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are used
to audit whether the shape restrictions on the <code>u</code>
components of the MTRs are satisfied. The initial grid used to
impose the shape constraints in the LP/QCQP problem are
constructed from a subset of these points.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_audit.add">audit.add</code></td>
<td>
<p>maximum number of points to add to the initial
constraint grid for imposing each kind of shape constraint. For
example, if there are 5 different kinds of shape constraints,
there can be at most <code>audit.add * 5</code> additional points
added to the constraint grid.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_audit.max">audit.max</code></td>
<td>
<p>maximum number of iterations in the audit
procedure.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be 1e-06, which is equal to the
default feasibility tolerances of Gurobi (<code>solver =
"gurobi"</code>), CPLEX (<code>solver = "cplexapi"</code>), and Rmosek
(<code>solver = "rmosek"</code>). This parameter should only be
changed if the feasibility tolerance of the solver is changed,
or if numerical issues result in discrepancies between the
solver's feasibility check and the audit.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> by default. This
rescalels the MTR components to improve stability in the
LP/QCQP optimization.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_point">point</code></td>
<td>
<p>boolean. Set to <code>TRUE</code> if it is believed that the
treatment effects are point identified. If set to <code>TRUE</code>
and IV-like formulas are passed, then a two-step GMM procedure
is implemented to estimate the treatment effects. Shape
constraints on the MTRs will be ignored under point
identification. If set to <code>TRUE</code> and the regression-based
criteria is used instead, then OLS will be used to estimate the
MTR coefficients used to estimate the treatment effect. If not
declared, then the function will determine whether or not the
target parameter is point identified.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_point.eyeweight">point.eyeweight</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> if the GMM point estimate should use the identity
weighting matrix (i.e. one-step GMM).</p>
</td></tr>
<tr><td><code id="ivmte_+3A_bootstraps">bootstraps</code></td>
<td>
<p>integer, default set to 0. This determines the
number of bootstraps used to perform statistical inference.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_bootstraps.m">bootstraps.m</code></td>
<td>
<p>integer, default set to size of data
set. Determines the size of the subsample drawn from the
original data set when performing inference via the
bootstrap. This option applies only to the case of constructing
confidence intervals for treatment effect bounds, i.e. it does
not apply when <code>point = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_bootstraps.replace">bootstraps.replace</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. This
determines whether the resampling procedure used for inference
will sample with replacement.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_levels">levels</code></td>
<td>
<p>vector of real numbers between 0 and 1. Values
correspond to the level of the confidence intervals constructed
via bootstrap.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_ci.type">ci.type</code></td>
<td>
<p>character, default set to <code>'both'</code>. Set to
<code>'forward'</code> to construct the forward confidence interval
for the treatment effect bound. Set to <code>'backward'</code> to
construct the backward confidence interval for the treatment
effect bound. Set to <code>'both'</code> to construct both types of
confidence intervals.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_specification.test">specification.test</code></td>
<td>
<p>boolean, default set to
<code>TRUE</code>. Function performs a specification test for the
partially identified case when <code>bootstraps &gt; 0</code>.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_smallreturnlist">smallreturnlist</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> to exclude large intermediary components
(i.e. propensity score model, LP/QCQP model, bootstrap
iterations) from being included in the return list.</p>
</td></tr>
<tr><td><code id="ivmte_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The option is only
applied when <code>solver = 'gurobi'</code> or <code>solver =
'rmosek'</code>. The output provided is the same as what the Gurobi
API would send to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the function is used to estimate bounds, and
statistical inference is not performed, the function returns
the following objects.
</p>

<dl>
<dt>audit.count</dt><dd><p>the number of audits required until there were
no more violations; or the number of audits performed before the audit
procedure was terminated.</p>
</dd>
<dt>audit.criterion</dt><dd><p>the minimum criterion.</p>
</dd>
<dt>audit.grid</dt><dd><p>a list containing the points used to define the audit
grid, as well as a table of points where the shape constraints were
violated.</p>
</dd>
<dt>bounds</dt><dd><p>a vector with the estimated lower and upper bounds of
the target treatment effect.</p>
</dd>
<dt>call.options</dt><dd><p>a list containing all the model specifications and
call options generating the results.</p>
</dd>
<dt>gstar</dt><dd><p>a list containing the estimate of the weighted means
for each component in the MTRs. The weights are determined by the
target parameter declared in <code>target</code>, or the weights defined
by <code>target.weight1</code>, <code>target.knots1</code>,
<code>target.weight0</code>, <code>target.knots0</code>.</p>
</dd>
<dt>gstar.coef</dt><dd><p>a list containing the coefficients on the treated
and control group MTRs.</p>
</dd>
<dt>gstar.weights</dt><dd><p>a list containing the target weights used to
estimate <code>gstar</code>.</p>
</dd>
<dt>result</dt><dd><p>a list containing the LP/QCQP model, and the full output
from solving the problem.</p>
</dd>
<dt>solver</dt><dd><p>the solver used in estimation.</p>
</dd>
<dt>moments</dt><dd><p>the number of elements in the S-set used to generate
achieve (partial) identification.</p>
</dd>
<dt>propensity</dt><dd><p>the propensity score model. If a variable is fed
to the <code>propensity</code> argument when calling <code>ivmte</code>, then
the returned object is a list containing the name of variable given
by the user, and the values of that variable used in estimation.</p>
</dd>
<dt>s.set</dt><dd><p>a list of all the coefficient estimates and weights
corresponding to each element in the S-set.</p>
</dd>
<dt>splines.dict</dt><dd><p>a list including the specifications of each
spline declared in each MTR.</p>
</dd>
<dt>messages</dt><dd><p>a vector of character strings logging the output of
the estimation procedure.</p>
</dd>
</dl>

<p>If <code>bootstraps</code> is greater than 0, then statistical inference
will be performed and the output will additionally contain the
following objects.
</p>

<dl>
<dt>bootstraps</dt><dd><p>the number of bootstraps.</p>
</dd>
<dt>bootstraps.failed</dt><dd><p>the number of bootstraps that failed (e.g.
due to collinearity) and had to be repeated.</p>
</dd>
<dt>bounds.bootstraps</dt><dd><p>the estimates of the bounds from every
bootstrap draw.</p>
</dd>
<dt>bounds.ci</dt><dd><p>forward and/or backward confidence intervals for
the bound estimates at the levels specified in <code>levels</code>.</p>
</dd>
<dt>bounds.se</dt><dd><p>bootstrap standard errors on the lower and upper
bound estimates.</p>
</dd>
<dt>p.value</dt><dd><p>p-value for the estimated bounds. p-values are
constructed by finding the level at which the confidence interval
no longer contains 0.</p>
</dd>
<dt>propensity.ci</dt><dd><p>confidence interval for coefficient estimates
of the propensity score model.</p>
</dd>
<dt>propensity.se</dt><dd><p>standard errors for the coefficient estimates
of the propensity score model.</p>
</dd>
<dt>specification.p.value</dt><dd><p>p-value from a specification test.
The specification test is only performed if the minimum criterion
is not 0.</p>
</dd>
</dl>

<p>If <code>point = TRUE</code> and <code>bootstraps = 0</code>, then point
estimation is performed using two-step GMM. The output will contain
the following objects.
</p>

<dl>
<dt>j.test</dt><dd><p>test statistic and results from the asymptotic J-test.</p>
</dd>
<dt>moments</dt><dd><p>a vector. Each element is the GMM criterion for each
moment condition used in estimation.</p>
</dd>
<dt>mtr.coef</dt><dd><p>coefficient estimates for the MTRs.</p>
</dd>
<dt>point.estimate</dt><dd><p>point estimate of the treatment effect.</p>
</dd>
<dt>redundant</dt><dd><p>indexes for the moment conditions (i.e. elements
in the S set) that were linearly independent and could be dropped.</p>
</dd>
</dl>

<p>If <code>point = TRUE</code> and <code>bootstraps</code> is not 0, then
point estimation is performed using two-step GMM, and additional
statistical inference is performed using the bootstrap samples.
The output will contain the following additional objects.
</p>

<dl>
<dt>bootstraps</dt><dd><p>the number of bootstraps.</p>
</dd>
<dt>bootstraps.failed</dt><dd><p>the number of bootstraps that failed (e.g.
due to collinearity) and had to be repeated.</p>
</dd>
<dt>j.test</dt><dd><p>test statistic and result from the J-test performed
using the bootstrap samples.</p>
</dd>
<dt>j.test.bootstraps</dt><dd><p>J-test statistic from each bootstrap.</p>
</dd>
<dt>mtr.bootstraps</dt><dd><p>coefficient estimates for the MTRs from
each bootstrap sample. These are used to construct the confidence
intervals and standard errors for the MTR coefficients.</p>
</dd>
<dt>mtr.ci</dt><dd><p>confidence intervals for each MTR coefficient.</p>
</dd>
<dt>mtr.se</dt><dd><p>standard errors for each MTR coefficient estimate.</p>
</dd>
<dt>p.value</dt><dd><p>p-value for the treatment effect point estimate
estimated using the bootstrap.</p>
</dd>
<dt>point.estimate.bootstraps</dt><dd><p>treatment effect point estimate
from each bootstrap sample. These are used to construct the
confidence interval, standard error, and p-value for the treatment
effect.</p>
</dd>
<dt>point.estimate.ci</dt><dd><p>confidence interval for the treatment
effect.</p>
</dd>
<dt>point.estimate.se</dt><dd><p>standard error for the treatment effect
estimate.</p>
</dd>
<dt>propensity.ci</dt><dd><p>confidence interval for the coefficients in
the propensity score model, constructed using the bootstrap.</p>
</dd>
<dt>propensity.se</dt><dd><p>standard errors for the coefficient estimates
of the propensity score model.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Returns a list of results from throughout the estimation
procedure. This includes all IV-like estimands; the propensity
score model; bounds on the treatment effect; the estimated
expectations of each term in the MTRs; the components and
results of the LP/QCQP problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

ivlikespecs &lt;- c(ey ~ d | z,
                 ey ~ d | factor(z),
                 ey ~ d,
                 ey ~ d | factor(z))
jvec &lt;- l(d, d, d, d)
svec &lt;- l(, , , z %in% c(2, 4))

ivmte(ivlike = ivlikespecs,
      data = dtm,
      components = jvec,
      propensity = d ~ z,
      subset = svec,
      m0 = ~  u + I(u ^ 2),
      m1 = ~  u + I(u ^ 2),
      uname = u,
      target = "att",
      m0.dec = TRUE,
      m1.dec = TRUE,
      bootstraps = 0,
      solver = "lpSolveAPI")

</code></pre>

<hr>
<h2 id='ivmteEstimate'>Single iteration of estimation procedure from Mogstad, Torgovitsky,
Santos (2018)</h2><span id='topic+ivmteEstimate'></span>

<h3>Description</h3>

<p>This function estimates the treatment effect parameters, following
the procedure described in Mogstad, Santos and Torgovitsky (2018)
(doi: <a href="https://doi.org/10.3982/ECTA15463">10.3982/ECTA15463</a>). A detailed description of the module and
its features can be found in
<a href="https://a-torgovitsky.github.io/shea-torgovitsky.pdf">Shea
and Torgovitsky (2021)</a>. However, this is not the main function of
the module. See <code><a href="#topic+ivmte">ivmte</a></code> for the main function. For
examples of how to use the package, see the vignette, which is
available on the module's
<a href="https://github.com/jkcshea/ivmte">GitHub</a> page.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivmteEstimate(
  data,
  target,
  late.Z,
  late.from,
  late.to,
  late.X,
  eval.X,
  genlate.lb,
  genlate.ub,
  target.weight0,
  target.weight1,
  target.knots0 = NULL,
  target.knots1 = NULL,
  m0,
  m1,
  uname = u,
  m1.ub,
  m0.ub,
  m1.lb,
  m0.lb,
  mte.ub,
  mte.lb,
  m0.dec,
  m0.inc,
  m1.dec,
  m1.inc,
  mte.dec,
  mte.inc,
  equal.coef,
  ivlike,
  components,
  subset,
  propensity,
  link = "logit",
  treat,
  solver,
  solver.options,
  solver.presolve,
  solver.options.criterion,
  solver.options.bounds,
  criterion.tol = 0.01,
  initgrid.nx = 20,
  initgrid.nu = 20,
  audit.nx = 2500,
  audit.nu = 25,
  audit.add = 100,
  audit.max = 25,
  audit.tol,
  audit.grid = NULL,
  rescale = TRUE,
  point = FALSE,
  point.eyeweight = FALSE,
  point.center = NULL,
  point.redundant = NULL,
  bootstrap = FALSE,
  count.moments = TRUE,
  orig.sset = NULL,
  orig.criterion = NULL,
  vars_y,
  vars_mtr,
  terms_mtr0,
  terms_mtr1,
  vars_data,
  splinesobj,
  splinesobj.equal,
  noisy = TRUE,
  smallreturnlist = FALSE,
  debug = FALSE,
  environments
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ivmteEstimate_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> or <code>data.table</code> used to estimate
the treatment effects.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_target">target</code></td>
<td>
<p>character, target parameter to be estimated. The
function allows for ATE (<code>'ate'</code>), ATT (<code>'att'</code>), ATU
(<code>'atu'</code>), LATE (<code>'late'</code>), and generalized LATE
(<code>'genlate'</code>).</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_late.z">late.Z</code></td>
<td>
<p>vector of variable names used to define the LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_late.from">late.from</code></td>
<td>
<p>baseline set of values of Z used to define the
LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_late.to">late.to</code></td>
<td>
<p>comparison set of values of Z used to define the
LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_late.x">late.X</code></td>
<td>
<p>vector of variable names of covariates to condition
on when defining the LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_eval.x">eval.X</code></td>
<td>
<p>numeric vector of the values to condition variables
in <code>late.X</code> on when estimating the LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_genlate.lb">genlate.lb</code></td>
<td>
<p>lower bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_genlate.ub">genlate.ub</code></td>
<td>
<p>upper bound value of unobservable <code>u</code> for
estimating the generalized LATE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_target.weight0">target.weight0</code></td>
<td>
<p>user-defined weight function for the control
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
<code>data</code>. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_target.weight1">target.weight1</code></td>
<td>
<p>user-defined weight function for the treated
group defining the target parameter. See <code>target.weight0</code>
for details.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_target.knots0">target.knots0</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the control group. The
arguments of the function should consist only of variable names
in <code>data</code>. If the knots are constant across all
observations, then the user can instead submit the vector of
knots instead of a function.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_target.knots1">target.knots1</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with spline weights for the treated group. See
<code>target.knots0</code> for details.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m0">m0</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the control group. Splines may also be
incorporated using the expression <code>uSpline</code>, e.g.
<code>uSpline(degree = 2, knots = c(0.4, 0.8), intercept =
TRUE)</code>. The <code>intercept</code> argument may be omitted, and is
set to <code>TRUE</code> by default.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m1">m1</code></td>
<td>
<p>one-sided formula for the marginal treatment response
function for the treated group. See <code>m0</code> for details.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_uname">uname</code></td>
<td>
<p>variable name for the unobservable used in declaring
the MTRs. The name can be provided with or without quotation
marks.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m1.ub">m1.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the treated
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m0.ub">m0.ub</code></td>
<td>
<p>numeric value for upper bound on MTR for the control
group. By default, this will be set to the largest value of the
observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m1.lb">m1.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the treated
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m0.lb">m0.lb</code></td>
<td>
<p>numeric value for lower bound on MTR for the control
group. By default, this will be set to the smallest value of
the observed outcome in the estimation sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_mte.ub">mte.ub</code></td>
<td>
<p>numeric value for upper bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_mte.lb">mte.lb</code></td>
<td>
<p>numeric value for lower bound on treatment effect
parameter of interest.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m0.dec">m0.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m0.inc">m0.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the control group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m1.dec">m1.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_m1.inc">m1.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal to
<code>TRUE</code> if the MTR for the treated group should be weakly
monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_mte.dec">mte.dec</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone decreasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_mte.inc">mte.inc</code></td>
<td>
<p>logical, set to <code>FALSE</code> by default. Set equal
to <code>TRUE</code> if the MTE should be weakly monotone increasing.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_equal.coef">equal.coef</code></td>
<td>
<p>one-sided formula to indicate which terms in
<code>m0</code> and <code>m1</code> should be constrained to have the same
coefficients. These terms therefore have no effect on the MTE.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_ivlike">ivlike</code></td>
<td>
<p>formula or vector of formulas specifying the
regressions for the IV-like estimands. Which coefficients to
use to define the constraints determining the treatment effect
bounds (alternatively, the moments determining the treatment
effect point estimate) can be selected in the argument
<code>components</code>. If no argument is passed, then a linear
regression will be performed to estimate the MTR coefficients.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_components">components</code></td>
<td>
<p>a list of vectors of the terms in the regression
specifications to include in the set of IV-like estimands. No
terms should be in quotes. To select the intercept term,
include the name <code>intercept</code>. If the factorized
counterpart of a variable is included in the IV-like
specifications, e.g. <code>factor(x)</code> where <code>x = 1, 2, 3</code>,
the user can select the coefficients for specific factors by
declaring the components <code>factor(x)-1, factor(x)-2,
factor(x)-3</code>. See <code><a href="#topic+l">l</a></code> on how to input the
argument. If no components for a IV specification are given,
then all coefficients from that IV specification will be used
to define constraints in the partially identified case, or to
define moments in the point identified case.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_subset">subset</code></td>
<td>
<p>a single subset condition or list of subset
conditions corresponding to each regression specified in
<code>ivlike</code>. The input must be logical. See <code><a href="#topic+l">l</a></code>
on how to input the argument. If the user wishes to select
specific rows, construct a binary variable in the data set, and
set the condition to use only those observations for which the
binary variable is 1, e.g. the binary variable is <code>use</code>,
and the subset condition is <code>use == 1</code>.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_propensity">propensity</code></td>
<td>
<p>formula or variable name corresponding to
propensity to take up treatment. If a formula is declared, then
the function estimates the propensity score according to the
formula and link specified in <code>link</code>. If a variable name
is declared, then the corresponding column in the data is taken
as the vector of propensity scores. A variable name can be
passed either as a string (e.g <code>propensity = 'p'</code>), a
variable (e.g. <code>propensity = p</code>), or a one-sided formula
(e.g. <code>propensity = ~p</code>).</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_link">link</code></td>
<td>
<p>character, name of link function to estimate propensity
score. Can be chosen from <code>'linear'</code>, <code>'probit'</code>, or
<code>'logit'</code>. Default is set to <code>'logit'</code>. The link
should be provided with quoation marks.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_treat">treat</code></td>
<td>
<p>variable name for treatment indicator. The name can be
provided with or without quotation marks.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_solver">solver</code></td>
<td>
<p>character, name of the programming package in R used
to obtain the bounds on the treatment effect. The function
supports <code>'gurobi'</code>, <code>'cplexapi'</code>, <code>rmosek</code>,
<code>'lpsolveapi'</code>. The name of the solver should be provided
with quotation marks.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should correspond
to an option specific to the solver selected.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_solver.presolve">solver.presolve</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. Set
this parameter to <code>FALSE</code> if presolve should be turned off
for the LP/QCQP problems.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_solver.options.criterion">solver.options.criterion</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the minimum criterion.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_solver.options.bounds">solver.options.bounds</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the solver selected. These
options are specific for finding the bounds.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>tolerance for the criterion function, and is
set to 1e-4 by default. The criterion measures how well the
IV-like moments/conditional means are matched using the
l1-norm. Statistical noise may prohibit the theoretical LP/QCQP
problem from being feasible. That is, there may not exist a set
of MTR coefficients that are able to match all the specified
moments. The function thus first estimates the minimum
criterion, which is reported in the output under the name
'minimum criterion', with a criterion of 0 meaning that all
moments were able to be matched. The function then relaxes the
constraints by tolerating a criterion up to <code>minimum
criterion * (1 + criterion.tol)</code>. Set <code>criterion.tol</code> to a
value greater than 0 to allow for more conservative bounds.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_initgrid.nx">initgrid.nx</code></td>
<td>
<p>integer determining the number of points of the
covariates used to form the initial constraint grid for
imposing shape restrictions on the MTRs.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_initgrid.nu">initgrid.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are
always a subset of the points defining the audit grid (see
<code>audit.nu</code>). These points are used to form the initial
constraint grid for imposing shape restrictions on the <code>u</code>
components of the MTRs.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.nx">audit.nx</code></td>
<td>
<p>integer determining the number of points on the
covariates space to audit in each iteration of the audit
procedure.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.nu">audit.nu</code></td>
<td>
<p>integer determining the number of points in the
open interval (0, 1) drawn from a Halton sequence. The end
points 0 and 1 are additionally included. These points are used
to audit whether the shape restrictions on the <code>u</code>
components of the MTRs are satisfied. The initial grid used to
impose the shape constraints in the LP/QCQP problem are
constructed from a subset of these points.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.add">audit.add</code></td>
<td>
<p>maximum number of points to add to the initial
constraint grid for imposing each kind of shape constraint. For
example, if there are 5 different kinds of shape constraints,
there can be at most <code>audit.add * 5</code> additional points
added to the constraint grid.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.max">audit.max</code></td>
<td>
<p>maximum number of iterations in the audit
procedure.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.tol">audit.tol</code></td>
<td>
<p>feasibility tolerance when performing the
audit. By default to set to be 1e-06, which is equal to the
default feasibility tolerances of Gurobi (<code>solver =
"gurobi"</code>), CPLEX (<code>solver = "cplexapi"</code>), and Rmosek
(<code>solver = "rmosek"</code>). This parameter should only be
changed if the feasibility tolerance of the solver is changed,
or if numerical issues result in discrepancies between the
solver's feasibility check and the audit.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_audit.grid">audit.grid</code></td>
<td>
<p>list, contains the <code>A</code> matrix used in the
audit for the original sample, as well as the RHS vector used
in the audit from the original sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> by default. This
rescalels the MTR components to improve stability in the
LP/QCQP optimization.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_point">point</code></td>
<td>
<p>boolean. Set to <code>TRUE</code> if it is believed that the
treatment effects are point identified. If set to <code>TRUE</code>
and IV-like formulas are passed, then a two-step GMM procedure
is implemented to estimate the treatment effects. Shape
constraints on the MTRs will be ignored under point
identification. If set to <code>TRUE</code> and the regression-based
criteria is used instead, then OLS will be used to estimate the
MTR coefficients used to estimate the treatment effect. If not
declared, then the function will determine whether or not the
target parameter is point identified.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_point.eyeweight">point.eyeweight</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> if the GMM point estimate should use the identity
weighting matrix (i.e. one-step GMM).</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_point.center">point.center</code></td>
<td>
<p>numeric, a vector of GMM moment conditions
evaluated at a solution. When bootstrapping, the moment
conditions from the original sample can be passed through this
argument to recenter the bootstrap distribution of the
J-statistic.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_point.redundant">point.redundant</code></td>
<td>
<p>vector of integers indicating which
components in the S-set are redundant.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_bootstrap">bootstrap</code></td>
<td>
<p>boolean, indicates whether the estimate is
for the bootstrap.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_count.moments">count.moments</code></td>
<td>
<p>boolean, indicate if number of linearly
independent moments should be counted.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_orig.sset">orig.sset</code></td>
<td>
<p>list, only used for bootstraps. The list contains
the gamma moments for each element in the S-set, as well as the
IV-like coefficients.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_orig.criterion">orig.criterion</code></td>
<td>
<p>numeric, only used for bootstraps. The scalar
corresponds to the minimum observational equivalence criterion
from the original sample.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_vars_y">vars_y</code></td>
<td>
<p>character, variable name of observed outcome
variable.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_vars_mtr">vars_mtr</code></td>
<td>
<p>character, vector of variables entering into
<code>m0</code> and <code>m1</code>.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_terms_mtr0">terms_mtr0</code></td>
<td>
<p>character, vector of terms entering into
<code>m0</code>.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_terms_mtr1">terms_mtr1</code></td>
<td>
<p>character, vector of terms entering into
<code>m1</code>.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_vars_data">vars_data</code></td>
<td>
<p>character, vector of variables that can be found
in the data.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_splinesobj">splinesobj</code></td>
<td>
<p>list of spline components in the MTRs for treated
and control groups. Spline terms are extracted using
<code><a href="#topic+removeSplines">removeSplines</a></code>. This object is supposed to be a
dictionary of splines, containing the original calls of each
spline in the MTRs, their specifications, and the index used
for naming each basis spline.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_splinesobj.equal">splinesobj.equal</code></td>
<td>
<p>list of spline components in the MTRs for
treated and control groups. The structure of
<code>splinesobj.equal</code> is the same as <code>splinesobj</code>,
except the splines are restricted to those whose MTR cofficients
should be constrained to be equal across treatment groups.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_noisy">noisy</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. If <code>TRUE</code>,
then messages are provided throughout the estimation
procedure. Set to <code>FALSE</code> to suppress all messages,
e.g. when performing the bootstrap.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_smallreturnlist">smallreturnlist</code></td>
<td>
<p>boolean, default set to <code>FALSE</code>. Set to
<code>TRUE</code> to exclude large intermediary components
(i.e. propensity score model, LP/QCQP model, bootstrap
iterations) from being included in the return list.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The option is only
applied when <code>solver = 'gurobi'</code> or <code>solver =
'rmosek'</code>. The output provided is the same as what the Gurobi
API would send to the console.</p>
</td></tr>
<tr><td><code id="ivmteEstimate_+3A_environments">environments</code></td>
<td>
<p>a list containing the environments of the MTR
formulas, the IV-like formulas, and the propensity score
formulas. If a formula is not provided, and thus no environment
can be found, then the parent.frame() is assigned by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The treatment effects parameters the user can choose from are the
ATE, ATT, ATU, LATE, and generalized LATE. The user is required to
provide a polynomial expression for the marginal treatment
responses (MTR), as well as a set of regressions.
</p>
<p>There are two approaches to estimating the treatment effect
parameters. The first approach restricts the set of MTR
coefficients on each term of the MTRs to be consistent with the
regression estimates from the specifications passed through
<code>ivlike</code>. The bounds on the treatment effect parameter
correspond to finding coefficients on the MTRs that maximize their
average difference. If the model is point identified, then GMM is
used for estimation. Otherwise, the function solves an LP
problem. The second approach restricts the set of MTR coefficients
to fit the conditional mean of the outcome variable. If the model
is point identified, then constrained least squares is used for
estimation. Otherwise, the function solves a QCQP.
</p>
<p>The estimation procedure relies on the propensity to take up
treatment. The propensity scores can either be estimated as part of
the estimation procedure, or the user can specify a variable in the
data set already containing the propensity scores.
</p>
<p>Constraints on the shape of the MTRs and marginal treatment effects
(MTE) can be imposed by the user. Specifically, bounds and
monotonicity restrictions are permitted. These constraints are
first enforced over a subset of points in the data. An iterative
audit procedure is then performed to ensure the constraints hold
more generally.
</p>


<h3>Value</h3>

<p>Returns a list of results from throughout the estimation
procedure. This includes all IV-like estimands; the propensity
score model; bounds on the treatment effect; the estimated
expectations of each term in the MTRs; the components and
results of the LP/QCQP problem.
</p>

<hr>
<h2 id='ivmteSimData'>ivmte Simulated Data</h2><span id='topic+ivmteSimData'></span>

<h3>Description</h3>

<p>ivmte Simulated Data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ivmteSimData
</code></pre>


<h3>Format</h3>

<p>A data frame with 5,000 rows and 14 columns.
</p>

<dl>
<dt>y</dt><dd><p>binary outcome variable</p>
</dd>
<dt>d</dt><dd><p>binary treatment variable</p>
</dd>
<dt>z</dt><dd><p>instrument that takes the value 0, 1, 2, or 3</p>
</dd>
<dt>x</dt><dd><p>covariate x that takes integer values from 1 to 10</p>
</dd>
</dl>



<h3>Source</h3>

<p>Simulated &mdash; see code in data/ivmteSimData.R.
</p>

<hr>
<h2 id='l'>Listing subsets and components</h2><span id='topic+l'></span>

<h3>Description</h3>

<p>This function allows the user to declare a list of variable names
in non-character form and subsetting conditions. This is used to
ensure clean entry of arguments into the <code>components</code> and
<code>subset</code> arguments of the function. When selecting components
to include in the S set, selecting the intercept term and factor
variables requires special treatment. To select the intercept term,
include in the vector of variable names, &lsquo;intercept&rsquo;. If the the
factorized counterpart of a variable <code>x = 1, 2, 3</code> is included
in the IV-like specifications via <code>factor(x)</code>, the user can
select the coefficients for specific factors by declaring the
components <code>factor(x)-1, factor(x)-2, factor(x)-3</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l_+3A_...">...</code></td>
<td>
<p>subset conditions or variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>components &lt;- l(d, x1, intercept, factor(x)-2)
subsets &lt;- l(, z %in% c(2, 4))

</code></pre>

<hr>
<h2 id='lpSetup'>Constructing LP problem</h2><span id='topic+lpSetup'></span>

<h3>Description</h3>

<p>If the user passes IV-like moments to the function, then the
function constructs the components of the LP problem. If no IV-like
moments are passed, then the function constructs the linear
constraints of the QCQP problem. Note that the LP/QCQP model will
be saved inside an environment variable, which is to be passed
through the argument <code>env</code>. This is done for efficient use of
memory. The environment <code>env</code> is supposed to already contain a
list under the entry <code>$mbobj</code> containing the matrices defining
the shape constraints. This list of shape constraints <code>$mbobj</code>
should contain three entries corresponding to a system of linear
equations of the form <code>Ax &lt;=&gt; b</code>: <code>mbA</code>, the matrix
defining the constraints, <code>A</code>; <code>mbs</code>, a vector indicating
whether a row in <code>mbA</code> is an equality or inequality constraint
(for Gurobi and MOSEK, use '&lt;=', '&gt;=', '='; for CPLEX,
use 'L', 'G', and 'E'); <code>mbrhs</code>, a vector of the right hand
side values defining the constraint of the form i.e. the vector
<code>b</code>. Depending on the linear programming solver used, this
function will return different output specific to the solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetup(
  env,
  sset,
  orig.sset = NULL,
  equal.coef0 = NULL,
  equal.coef1 = NULL,
  shape = TRUE,
  direct = FALSE,
  rescale = TRUE,
  solver
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetup_+3A_env">env</code></td>
<td>
<p>environment containing the matrices defining the LP/QCQP
problem.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_sset">sset</code></td>
<td>
<p>List of IV-like estimates and the corresponding gamma
terms.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_orig.sset">orig.sset</code></td>
<td>
<p>list, only used for bootstraps. The list contains
the gamma moments for each element in the S-set, as well as the
IV-like coefficients.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_equal.coef0">equal.coef0</code></td>
<td>
<p>character, name of terms in <code>m0</code> that
should have common coefficients with the corresponding terms in
<code>m1</code>.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_equal.coef1">equal.coef1</code></td>
<td>
<p>character, name of terms in <code>m1</code> that
should have common coefficients with the corresponding terms in
<code>m0</code>.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_shape">shape</code></td>
<td>
<p>boolean, default set to TRUE. Switch to determine
whether or not to include shape restrictions in the LP/QCQP
problem.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_direct">direct</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the direct MTR
regression is used.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QCQP
optimization.</p>
</td></tr>
<tr><td><code id="lpSetup_+3A_solver">solver</code></td>
<td>
<p>string, name of the package used to solve the LP/QCQP
problem.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices and vectors necessary to define an
LP/QCQP problem.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare empty list to be updated (in the event multiple IV like
## specifications are provided
sSet &lt;- list()

## Declare MTR formulas
formula0 = ~ 1 + u
formula1 = ~ 1 + u

## Construct object that separates out non-spline components of MTR
## formulas from the spline components. The MTR functions are
## obtained from this object by the function 'genSSet'.
splinesList = list(removeSplines(formula0), removeSplines(formula1))

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                          data = dtm,
                          uname = u,
                          as.function = FALSE)
polynomials1 &lt;- polyparse(formula = formula1,
                          data = dtm,
                          uname = u,
                           as.function = FALSE)

## Generate propensity score model
propensityObj &lt;- propensity(formula = d ~ z,
                            data = dtm,
                            link = "linear")

## Generate IV estimates
ivEstimates &lt;- ivEstimate(formula = ey ~ d | z,
                          data = dtm,
                          components = l(intercept, d),
                          treat = d,
                          list = FALSE)

## Generate target gamma moments
targetGamma &lt;- genTarget(treat = "d",
                         m0 = ~ 1 + u,
                         m1 = ~ 1 + u,
                         target = "atu",
                         data = dtm,
                         splinesobj = splinesList,
                         pmodobj = propensityObj,
                         pm0 = polynomials0,
                         pm1 = polynomials1)

## Construct S-set. which contains the coefficients and weights
## corresponding to various IV-like estimands
sSet &lt;- genSSet(data = dtm,
                sset = sSet,
                sest = ivEstimates,
                splinesobj = splinesList,
                pmodobj = propensityObj$phat,
                pm0 = polynomials0,
                pm1 = polynomials1,
                ncomponents = 2,
                scount = 1,
                yvar = "ey",
                dvar = "d",
                means = TRUE)
## Only the entry $sset is required
sSet &lt;- sSet$sset

## Define additional upper- and lower-bound constraints for the LP
## problem.  The code below imposes a lower bound of 0.2 and upper
## bound of 0.8 on the MTRs.
A &lt;- matrix(0, nrow = 22, ncol = 4)
A &lt;- cbind(A, rbind(cbind(1, seq(0, 1, 0.1)),
                    matrix(0, nrow = 11, ncol = 2)))
A &lt;- cbind(A, rbind(matrix(0, nrow = 11, ncol = 2),
                    cbind(1, seq(0, 1, 0.1))))
sense &lt;- c(rep("&gt;", 11), rep("&lt;", 11))
rhs &lt;- c(rep(0.2, 11), rep(0.8, 11))

## Construct LP object to be interpreted and solved by
## lpSolveAPI. Note that an environment has to be created for the LP
## object. The matrices defining the shape restrictions must be stored
## as a list under the entry \code{$mbobj} in the environment.
modelEnv &lt;- new.env()
modelEnv$mbobj &lt;- list(mbA = A,
                    mbs = sense,
                    mbrhs = rhs)
## Convert the matrices defining the shape constraints into a format
## that is suitable for the LP solver.
lpSetup(env = modelEnv,
        sset = sSet,
        solver = "lpsolveapi")
## Setup LP model so that it is solving for the bounds.
lpSetupBound(env = modelEnv,
             g0 = targetGamma$gstar0,
             g1 = targetGamma$gstar1,
             sset = sSet,
             criterion.tol = 0,
             criterion.min = 0,
             solver = "lpsolveapi")
## Declare any LP solver options as a list.
lpOptions &lt;- optionsLpSolveAPI(list(epslevel = "tight"))
## Obtain the bounds.
bounds &lt;- bound(env = modelEnv,
                sset = sSet,
                solver = "lpsolveapi",
                solver.options = lpOptions)
cat("The bounds are [",  bounds$min, ",", bounds$max, "].\n")

</code></pre>

<hr>
<h2 id='lpSetupBound'>Configure LP environment for obtaining the bounds</h2><span id='topic+lpSetupBound'></span>

<h3>Description</h3>

<p>This function sets up the LP model so that the bounds can be
obtained. The LP model must be passed as an environment variable,
under the entry <code>$model</code>. See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupBound(
  env,
  g0,
  g1,
  sset,
  criterion.tol,
  criterion.min,
  solver,
  setup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupBound_+3A_env">env</code></td>
<td>
<p>the environment containing the LP model.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_g0">g0</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_g1">g1</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_sset">sset</code></td>
<td>
<p>a list containing the point estimates and gamma
components associated with each element in the S-set. This
object is only used to determine the names of terms. If it is
no submitted, then no names are provided to the solution
vector.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>additional multiplicative factor for how much
more the solution is permitted to violate observational
equivalence of the IV-like estimands, i.e. <code>1 +
criterion.tol</code> will multiply <code>criterion.min</code> directly.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_criterion.min">criterion.min</code></td>
<td>
<p>minimum criterion, i.e. minimum deviation from
observational equivalence while satisfying shape constraints.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_solver">solver</code></td>
<td>
<p>string, name of the package used to solve the LP
problem.</p>
</td></tr>
<tr><td><code id="lpSetupBound_+3A_setup">setup</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function will modify the
LP environment so that the LP solver can obtain the bounds. If
<code>FALSE</code>, then it will undo the changes made by the
function if <code>setup = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='lpSetupCriterion'>Configure LP environment for minimizing the criterion</h2><span id='topic+lpSetupCriterion'></span>

<h3>Description</h3>

<p>This function sets up the objective function for minimizing the
criterion. The LP model must be passed as an environment variable,
under the entry <code>$model</code>. See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupCriterion(env, sset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupCriterion_+3A_env">env</code></td>
<td>
<p>The LP environment</p>
</td></tr>
<tr><td><code id="lpSetupCriterion_+3A_sset">sset</code></td>
<td>
<p>List of IV-like estimates and the corresponding gamma
terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='lpSetupCriterionBoot'>Configure LP environment for specification testing</h2><span id='topic+lpSetupCriterionBoot'></span>

<h3>Description</h3>

<p>This function re-centers various objects in the LP environment so
that a specification test can be performed via the bootstrap. The
LP model must be passed as an environment variable, under the entry
<code>$model</code>. See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupCriterionBoot(
  env,
  sset,
  orig.sset,
  orig.criterion,
  criterion.tol = 0,
  setup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupCriterionBoot_+3A_env">env</code></td>
<td>
<p>the LP environment</p>
</td></tr>
<tr><td><code id="lpSetupCriterionBoot_+3A_sset">sset</code></td>
<td>
<p>list of IV-like estimates and the corresponding gamma
terms.</p>
</td></tr>
<tr><td><code id="lpSetupCriterionBoot_+3A_orig.sset">orig.sset</code></td>
<td>
<p>list, only used for bootstraps. The list caontains
the gamma moments for each element in the S-set, as well as the
IV-like coefficients.</p>
</td></tr>
<tr><td><code id="lpSetupCriterionBoot_+3A_orig.criterion">orig.criterion</code></td>
<td>
<p>scalar, only used for bootstraps. This is the
minimum criterion from the original sample.</p>
</td></tr>
<tr><td><code id="lpSetupCriterionBoot_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>tolerance for violation of observational
equivalence, set to 0 by default.</p>
</td></tr>
<tr><td><code id="lpSetupCriterionBoot_+3A_setup">setup</code></td>
<td>
<p>boolean. If <code>TRUE</code>, the function will modify the
LP environment so that the LP solver can obtain the test
statistic for the specification test. If <code>FALSE</code>, then it
will undo the changes made by the function if <code>setup =
TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='lpSetupEqualCoef'>Generate equality constraints</h2><span id='topic+lpSetupEqualCoef'></span>

<h3>Description</h3>

<p>This function generates the linear constraints to ensure that
certain MTR coefficients are constant across the treatment and
control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupEqualCoef(equal.coef0, equal.coef1, ANames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupEqualCoef_+3A_equal.coef0">equal.coef0</code></td>
<td>
<p>character, name of terms in <code>m0</code> that
should have common coefficients with the corresponding terms in
<code>m1</code>.</p>
</td></tr>
<tr><td><code id="lpSetupEqualCoef_+3A_equal.coef1">equal.coef1</code></td>
<td>
<p>character, name of terms in <code>m1</code> that
should have common coefficients with the corresponding terms in
<code>m0</code>.</p>
</td></tr>
<tr><td><code id="lpSetupEqualCoef_+3A_anames">ANames</code></td>
<td>
<p>character, name of all terms in <code>m0</code> and
<code>m1</code>. The names of the terms corresponding to the
treatment and control groups should be distinguishable. For
example, all terms for <code>m0</code> may contain a prefix '[m0]',
and all terms for <code>m1</code> may contain a prefix '[m1]'. All
the terms in <code>equal.coef0</code> and <code>equal.coef1</code> should
be contained in <code>ANames</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the matrix of linear equality
constraints, a vector of equal signs, and a vector of 0s.
</p>

<hr>
<h2 id='lpSetupInfeasible'>Configure LP environment for diagnostics</h2><span id='topic+lpSetupInfeasible'></span>

<h3>Description</h3>

<p>This function separates the shape constraints from the LP
environment. That way, the model can be solved without any shape
constraints, which is the primary cause of infeasibility. This is
done in order to check which shape constraints are causing the
model to be infeasible. The LP model must be passed as an
environment variable, under the entry <code>$model</code>. See
<code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupInfeasible(env, sset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupInfeasible_+3A_env">env</code></td>
<td>
<p>The LP environment</p>
</td></tr>
<tr><td><code id="lpSetupInfeasible_+3A_sset">sset</code></td>
<td>
<p>List of IV-like estimates and the corresponding gamma
terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='lpSetupSolver'>Configure LP environment to be compatible with solvers</h2><span id='topic+lpSetupSolver'></span>

<h3>Description</h3>

<p>This alters the LP environment so the model will be compatible with
specific solvers. The LP model must be passed as an environment
variable, under the entry <code>$model</code>. See <code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpSetupSolver(env, solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpSetupSolver_+3A_env">env</code></td>
<td>
<p>The LP environment</p>
</td></tr>
<tr><td><code id="lpSetupSolver_+3A_solver">solver</code></td>
<td>
<p>Character, the LP solver.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='magnitude'>Check magnitude of real number</h2><span id='topic+magnitude'></span>

<h3>Description</h3>

<p>This function returns the order of magnitude of a a number.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>magnitude(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="magnitude_+3A_x">x</code></td>
<td>
<p>The number to be checked.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer indicating the order of magnitude.
</p>

<hr>
<h2 id='matrixTriplets'>Convert matrix into triplet form</h2><span id='topic+matrixTriplets'></span>

<h3>Description</h3>

<p>This function converts matrices into triplet form for Mosek.  This
is required in order to declare quadratic programming problems and
second-order cone programming problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixTriplets(mat, lower = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixTriplets_+3A_mat">mat</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="matrixTriplets_+3A_lower">lower</code></td>
<td>
<p>Boolean, set to <code>TRUE</code> if matrix is symmetric,
and only its lower triangle should be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing vectors of row and column indexes, and
matrix values.
</p>

<hr>
<h2 id='mInt'>Function to generate integral of m0 and m1</h2><span id='topic+mInt'></span>

<h3>Description</h3>

<p>Function carries out integral for a polynomial of degree 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mInt(ub, lb, coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mInt_+3A_ub">ub</code></td>
<td>
<p>scalar, upper bound of the integral.</p>
</td></tr>
<tr><td><code id="mInt_+3A_lb">lb</code></td>
<td>
<p>scalar, lower bound of the integral.</p>
</td></tr>
<tr><td><code id="mInt_+3A_coef">coef</code></td>
<td>
<p>vector, polynomial coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='modcall'>Auxiliary function: modifying calls</h2><span id='topic+modcall'></span>

<h3>Description</h3>

<p>This function can be used to modify calls in several ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modcall(call, newcall, newargs, keepargs, dropargs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modcall_+3A_call">call</code></td>
<td>
<p>Call object to be modified.</p>
</td></tr>
<tr><td><code id="modcall_+3A_newcall">newcall</code></td>
<td>
<p>New function to be called.</p>
</td></tr>
<tr><td><code id="modcall_+3A_newargs">newargs</code></td>
<td>
<p>List, new arguments and their values.</p>
</td></tr>
<tr><td><code id="modcall_+3A_keepargs">keepargs</code></td>
<td>
<p>List, arguments in original call to keep, with the
rest being dropped.</p>
</td></tr>
<tr><td><code id="modcall_+3A_dropargs">dropargs</code></td>
<td>
<p>List, arguments in original call to drop, with the
rest being kept.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New call object.
</p>

<hr>
<h2 id='momentMatrix'>Construct pre-meaned moment matrix</h2><span id='topic+momentMatrix'></span>

<h3>Description</h3>

<p>This function constructs the matrix to be fed into the GMM
estimator to construct the moment conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentMatrix(sset, gn0, gn1, subsetList = NULL, n = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="momentMatrix_+3A_sset">sset</code></td>
<td>
<p>a list of lists constructed from the function
<a href="#topic+genSSet">genSSet</a>. Each inner list should include a coefficient
corresponding to a term in an IV specification, a matrix of the
estimates of the gamma moments conditional on (X, Z) for d = 0,
and a matrix of the estimates of the gamma moments conditional
on (X, Z) for d = 1. The column means of the last two matrices
is what is used to generate the gamma moments.</p>
</td></tr>
<tr><td><code id="momentMatrix_+3A_gn0">gn0</code></td>
<td>
<p>integer, number of terms in the MTR for control group.</p>
</td></tr>
<tr><td><code id="momentMatrix_+3A_gn1">gn1</code></td>
<td>
<p>integer, number of terms in the MTR for treated group.</p>
</td></tr>
<tr><td><code id="momentMatrix_+3A_subsetlist">subsetList</code></td>
<td>
<p>list of subset indexes, one for each IV-like
specification.</p>
</td></tr>
<tr><td><code id="momentMatrix_+3A_n">n</code></td>
<td>
<p>number of observations in the data. This option is only
used when subsets are involved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix whose column means can be used to carry out the GMM
estimation.
</p>

<hr>
<h2 id='monoIntegral'>Integrating and evaluating monomials</h2><span id='topic+monoIntegral'></span>

<h3>Description</h3>

<p>Analytically integrates monomials and evalates them at a given
point. It is assumed that there is no constant multiplying the
monomial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monoIntegral(u, exp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monoIntegral_+3A_u">u</code></td>
<td>
<p>scalar, the point at which to evaluate the integral. If a
vector is passed, then the integral is evaluated at all the
elements of the vector.</p>
</td></tr>
<tr><td><code id="monoIntegral_+3A_exp">exp</code></td>
<td>
<p>The exponent of the monomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar or vector, depending on what <code>u</code> is.
</p>

<hr>
<h2 id='negationCheck'>Check if custom weights are negations of each other</h2><span id='topic+negationCheck'></span>

<h3>Description</h3>

<p>This function checks whether the user-declared weights for treated
and control groups are in fact negations of each other. This is
problematic for the GMM procedure when accounting for estimation
error of the target weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negationCheck(
  data,
  target.knots0,
  target.knots1,
  target.weight0,
  target.weight1,
  N = 20
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negationCheck_+3A_data">data</code></td>
<td>
<p>data set used for estimation. The comparisons are made
only on values in the support of the data set.</p>
</td></tr>
<tr><td><code id="negationCheck_+3A_target.knots0">target.knots0</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with splines weights for the control
group. The arguments of the function should consist only of
variable names in <code>data</code>. If the knot is constant across
all observations, then the user can instead submit the value of
the weight instead of a function.</p>
</td></tr>
<tr><td><code id="negationCheck_+3A_target.knots1">target.knots1</code></td>
<td>
<p>user-defined set of functions defining the
knots associated with splines weights for the treated
group. The arguments of the function should be variable names
in <code>data</code>. If the knot is constant across all
observations, then the user can instead submit the value of the
weight instead of a function.</p>
</td></tr>
<tr><td><code id="negationCheck_+3A_target.weight0">target.weight0</code></td>
<td>
<p>user-defined weight function for the control
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
<code>data</code>. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.</p>
</td></tr>
<tr><td><code id="negationCheck_+3A_target.weight1">target.weight1</code></td>
<td>
<p>user-defined weight function for the treated
group defining the target parameter. A list of functions can be
submitted if the weighting function is in fact a spline. The
arguments of the function should be variable names in
<code>data</code>. If the weight is constant across all observations,
then the user can instead submit the value of the weight
instead of a function.</p>
</td></tr>
<tr><td><code id="negationCheck_+3A_n">N</code></td>
<td>
<p>integer, default set to 20. This is the maxmimum number of
points between treated and control groups to compare and
determine whether or not the weights are indeed negations of
one another. If the data set contains fewer than <code>N</code>
unique values for a given set of variables, then all those
unique values are used for the comparison.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean. If the weights are negations of each other,
<code>TRUE</code> is returned.
</p>

<hr>
<h2 id='olsj'>OLS weights</h2><span id='topic+olsj'></span>

<h3>Description</h3>

<p>Function generating the S-weights for OLS estimand, with controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>olsj(X, X0, X1, components, treat, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="olsj_+3A_x">X</code></td>
<td>
<p>Matrix of covariates, including the treatment indicator.</p>
</td></tr>
<tr><td><code id="olsj_+3A_x0">X0</code></td>
<td>
<p>Matrix of covariates, once fixing treatment to be 0.</p>
</td></tr>
<tr><td><code id="olsj_+3A_x1">X1</code></td>
<td>
<p>Matrix of covariates, once fixing treatment to be 1.</p>
</td></tr>
<tr><td><code id="olsj_+3A_components">components</code></td>
<td>
<p>Vector of variable names of which user wants the
S-weights for.</p>
</td></tr>
<tr><td><code id="olsj_+3A_treat">treat</code></td>
<td>
<p>Variable name for the treatment indicator.</p>
</td></tr>
<tr><td><code id="olsj_+3A_order">order</code></td>
<td>
<p>integer, default set to <code>NULL</code>. This is simply an
index of which IV-like specification the estimate corresponds
to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two vectors: one is the weight for D = 0, the
other is the weight for D = 1.
</p>

<hr>
<h2 id='optionsCplexAPI'>Function to parse options for CPLEX</h2><span id='topic+optionsCplexAPI'></span>

<h3>Description</h3>

<p>This function constructs a list of options to be parsed when
<code>solver</code> is set to <code>cplexapi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsCplexAPI(options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsCplexAPI_+3A_options">options</code></td>
<td>
<p>list. The name of each item must be the name of the
function to set the option, and is case sensitive. The value
assigned to each item is the value to set the option to. The
<code>env</code> argument should always be omitted. If the option
accepts a list of parameters, then these parameters should be
passed as using a named vector (e.g.
<code>list(setLogFileNameCPLEX = c(filename = "cpx.log", mode =
"w"))</code>).  If the function to set the option can be used
multiple times, then the value submitted should be a a list,
with each entry being a named vector
(e.g. <code>list(setDblParmCPLEX = list(c(parm = 1016, value =
1e-04), c(parm = 1084, value = 2)))</code>). If the option only
requires the <code>env</code> parameter, then an <code>NA</code> should be
passed as the parameter value (e.g. <code>list(setDefaultParm
= NA)</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, each element being the command to evaluate to
implement an option.
</p>

<hr>
<h2 id='optionsCplexAPISingle'>Function to parse a single set of options for CPLEX</h2><span id='topic+optionsCplexAPISingle'></span>

<h3>Description</h3>

<p>This function constructs a string to be parsed when <code>solver</code>
is set to <code>cplexapi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsCplexAPISingle(name, vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsCplexAPISingle_+3A_name">name</code></td>
<td>
<p>string, name of the <code>cplexapi</code> function to call to
implement the option.</p>
</td></tr>
<tr><td><code id="optionsCplexAPISingle_+3A_vector">vector</code></td>
<td>
<p>a named vector, contains the argument names and
values of the options. The <code>env</code> argument in the
<code>cplexapi</code> documentation should always be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the command to be evaluated to implement a single
option.
</p>

<hr>
<h2 id='optionsCplexAPITol'>Function to extract feasibility tolerance from CPLEX options</h2><span id='topic+optionsCplexAPITol'></span>

<h3>Description</h3>

<p>This function parses through the user-submitted CPLEX options to
determine what the feasibility tolerance is. This tolerance can
then be used for the audit.  If the user does not set the CPLEX
feasibility tolerance, then a default value of <code>1e-06</code> is
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsCplexAPITol(options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsCplexAPITol_+3A_options">options</code></td>
<td>
<p>list, the set of options submitted by the user.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar, the level to set the audit tolerance at.
</p>

<hr>
<h2 id='optionsGurobi'>Function to parse options for Gurobi</h2><span id='topic+optionsGurobi'></span>

<h3>Description</h3>

<p>This function constructs a list of options to be parsed when
<code>solver</code> is set to <code>Gurobi</code>. This function really
implements some default values, and accounts for the <code>debug</code>
option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsGurobi(options, debug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsGurobi_+3A_options">options</code></td>
<td>
<p>list. The list should be structured the same way as
if one were using the <code>gurobi</code> library directly. That is,
the name of each item must be the name of the option, and is
case sensitive. The value assigned to each item is the value to
set the option to.</p>
</td></tr>
<tr><td><code id="optionsGurobi_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The output provided is
the same as what the Gurobi API would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, the set of options declared by the user, including
some additional default values (if not assigned by the user)
and accounting for <code>debug</code>.
</p>

<hr>
<h2 id='optionsLpSolveAPI'>Function to parse options for lp_solve</h2><span id='topic+optionsLpSolveAPI'></span>

<h3>Description</h3>

<p>This function constructs a list of options to be parsed when
<code>solver</code> is set to <code>lpsolveapi</code>. The options permitted
are those that can be set via <code>lpSolveAPI::lp.control</code>, and
should be passed as a named list (e.g. <code>list(epslevel =
"tight")</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsLpSolveAPI(options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsLpSolveAPI_+3A_options">options</code></td>
<td>
<p>list. The name of each item must be the name of the
option, and is case sensitive. The value assigned to each item
is the value to set the option to. The <code>lprec</code> argument
should always be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string, the command to be evaluated to implement the
options.
</p>

<hr>
<h2 id='optionsRmosek'>Function to parse options for Gurobi</h2><span id='topic+optionsRmosek'></span>

<h3>Description</h3>

<p>This function constructs a list of options to be parsed when
<code>solver</code> is set to <code>Rmosek</code>. This function really
implements the default feasibility tolerances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optionsRmosek(options, debug)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optionsRmosek_+3A_options">options</code></td>
<td>
<p>list. Each set of options should be passed as a
list, with the name of each entry being the name of the class
of options. For example, options for double parameters should
be contained in the entry<code>dparam = list(BASIS_TOL_X = 1e-06)</code>.</p>
</td></tr>
<tr><td><code id="optionsRmosek_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The output provided is
the same as what Mosek would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, the set of options declared by the user, including
some additional default values.
</p>

<hr>
<h2 id='parenthBoolean'>Correct boolean expressions in terms lists</h2><span id='topic+parenthBoolean'></span>

<h3>Description</h3>

<p>This function takes a vector of terms and places parentheses around
boolean expressions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parenthBoolean(termsList)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parenthBoolean_+3A_termslist">termsList</code></td>
<td>
<p>character vector, the vector of terms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector.
</p>

<hr>
<h2 id='permute'>Auxiliary function: generate all permutations of a vector</h2><span id='topic+permute'></span>

<h3>Description</h3>

<p>This function generates every permutation of the elements in a
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permute(vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permute_+3A_vector">vector</code></td>
<td>
<p>The vector whose elements are to be permuted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all the permutations of <code>vector</code>.
</p>

<hr>
<h2 id='permuteN'>Auxiliary function: generate all permutation orderings</h2><span id='topic+permuteN'></span>

<h3>Description</h3>

<p>This function generates every permutation of the first n natural
numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permuteN(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permuteN_+3A_n">n</code></td>
<td>
<p>integer, the first n natural numbers one wishes to
permute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of all the permutations of the first n natural
numbers.
</p>

<hr>
<h2 id='piv'>Obtaining IV-like estimands</h2><span id='topic+piv'></span>

<h3>Description</h3>

<p>This function performs TSLS to obtain the estimates for the IV-like
estimands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piv(
  Y,
  X,
  Z,
  lmcomponents = NULL,
  weights = NULL,
  order = NULL,
  excluded = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piv_+3A_y">Y</code></td>
<td>
<p>the vector of outcomes.</p>
</td></tr>
<tr><td><code id="piv_+3A_x">X</code></td>
<td>
<p>the matrix of covariates (includes endogenous and
exogenous covariates).</p>
</td></tr>
<tr><td><code id="piv_+3A_z">Z</code></td>
<td>
<p>the matrix of instruments (includes exogenous covariates
in the second stage).</p>
</td></tr>
<tr><td><code id="piv_+3A_lmcomponents">lmcomponents</code></td>
<td>
<p>vector of variable names from the second stage
that we want to include in the S-set of IV-like estimands. If
<code>NULL</code> is submitted, then all components will be included.</p>
</td></tr>
<tr><td><code id="piv_+3A_weights">weights</code></td>
<td>
<p>vector of weights.</p>
</td></tr>
<tr><td><code id="piv_+3A_order">order</code></td>
<td>
<p>integer, the counter for which IV-like specification
and component the regression is for.</p>
</td></tr>
<tr><td><code id="piv_+3A_excluded">excluded</code></td>
<td>
<p>boolean, to indicate whether or not the regression
involves excluded variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of select coefficient estimates.
</p>

<hr>
<h2 id='polyparse'>Parsing marginal treatment response formulas</h2><span id='topic+polyparse'></span>

<h3>Description</h3>

<p>This function takes in an MTR formula, and then parses the formula
such that it becomes a polynomial in the unobservable <code>u</code>. It
then breaks these polynomials into monomials, and then integrates
each of them with respect to <code>u</code>. Each integral corresponds to
E[md | D, X, Z].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyparse(
  formula,
  data,
  uname = "u",
  env = parent.frame(),
  as.function = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyparse_+3A_formula">formula</code></td>
<td>
<p>the MTR.</p>
</td></tr>
<tr><td><code id="polyparse_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> for which we obtain E[md | D, X, Z]
for each observation.</p>
</td></tr>
<tr><td><code id="polyparse_+3A_uname">uname</code></td>
<td>
<p>variable name for unobservable used in declaring the
MTR.</p>
</td></tr>
<tr><td><code id="polyparse_+3A_env">env</code></td>
<td>
<p>environment, the original environment in which
the formula was declared.</p>
</td></tr>
<tr><td><code id="polyparse_+3A_as.function">as.function</code></td>
<td>
<p>boolean, if <code>FALSE</code> then a list of the
polynomial terms are returned; if <code>TRUE</code> then a list of
functions corresponding to the polynomials are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list (of lists) of monomials corresponding to the
original MTR (for each observation); a list (of lists) of the
integrated monomials; a vector for the degree of each of the
original monomials in the MTR; and a vector for the names of
each variable entering into the MTR (note <code>x^2 + x</code> has
only one term, <code>x</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declare MTR functions
formula1 = ~ 1 + u
formula0 = ~ 1 + u

## Construct MTR polynomials
polynomials0 &lt;- polyparse(formula = formula0,
                          data = dtm,
                          uname = u,
                          as.function = FALSE)

polynomials1 &lt;- polyparse(formula = formula0,
                          data = dtm,
                          uname = u,
                          as.function = FALSE)

</code></pre>

<hr>
<h2 id='polyProduct'>Function to multiply polynomials</h2><span id='topic+polyProduct'></span>

<h3>Description</h3>

<p>This function takes in two vectors characterizing polynomials. It
then returns a vector characterizing the product of the two
polynomials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyProduct(poly1, poly2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyProduct_+3A_poly1">poly1</code></td>
<td>
<p>vector, characerizing a polynomial.</p>
</td></tr>
<tr><td><code id="polyProduct_+3A_poly2">poly2</code></td>
<td>
<p>vector, characerizing a polynomial.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, characterizing the product of the two polynomials
characterized <code>poly1</code> and <code>poly2</code>.
</p>

<hr>
<h2 id='popmean'>Calulating population mean</h2><span id='topic+popmean'></span>

<h3>Description</h3>

<p>Given a distribution, this function calculates the population mean
for each term in a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popmean(formula, distribution, density = "f")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popmean_+3A_formula">formula</code></td>
<td>
<p>formula, each term of which will have its mean
calculated.</p>
</td></tr>
<tr><td><code id="popmean_+3A_distribution">distribution</code></td>
<td>
<p>data.table, characterizing the distribution of
the variables entering into <code>formula</code>.</p>
</td></tr>
<tr><td><code id="popmean_+3A_density">density</code></td>
<td>
<p>string, name of the variable <code>data</code>
characterizing the density.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, the means for each term in <code>formula</code>.
</p>

<hr>
<h2 id='print.ivmte'>Print results</h2><span id='topic+print.ivmte'></span>

<h3>Description</h3>

<p>This function uses the print method on the ivmte return list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivmte'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ivmte_+3A_x">x</code></td>
<td>
<p>an object returned from '<code>ivmte</code>'.</p>
</td></tr>
<tr><td><code id="print.ivmte_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basic set of results.
</p>

<hr>
<h2 id='propensity'>Estimating propensity scores</h2><span id='topic+propensity'></span>

<h3>Description</h3>

<p>This function estimates the propensity of taking up treatment. The
user can choose from fitting a linear probability model, a logit
model, or a probit model. The function can also be used to generate
a table of propensity scores for a given set of covariates and
excluded variables. This was incorporated to account for the LATE
being a target parameter. Specifically, if the argument
<code>formula</code> is the name of a variable in <code>data</code>, but the
target parameter is not the LATE, then no propensity model is
returned. If the target parameter is the LATE, then then the
propensity model is simply the empirical distribution of propensity
scores in the data conditioned on the set of covariates declared in
<code>late.X</code> and <code>late.Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propensity(formula, data, link = "logit", late.Z, late.X, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propensity_+3A_formula">formula</code></td>
<td>
<p>Formula characterizing probability model. If a
variable in the data already contains the propensity scores,
input the variable as a one-sided formula. For example, if the
variable <code>pz</code> contains the propensity score, input
<code>formula = ~ pz</code>.</p>
</td></tr>
<tr><td><code id="propensity_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> with which to estimate the model.</p>
</td></tr>
<tr><td><code id="propensity_+3A_link">link</code></td>
<td>
<p>Link function with which to estimate probability
model. Can be chosen from &quot;linear&quot;, &quot;logit&quot;, or &quot;probit&quot;.</p>
</td></tr>
<tr><td><code id="propensity_+3A_late.z">late.Z</code></td>
<td>
<p>A vector of variable names of excluded
variables. This is required when the target parameter is the
LATE.</p>
</td></tr>
<tr><td><code id="propensity_+3A_late.x">late.X</code></td>
<td>
<p>A vector of variable names of non-excluded
variables. This is required when the target parameter is the
LATE, and the estimation procedure will condition on these
variables.</p>
</td></tr>
<tr><td><code id="propensity_+3A_env">env</code></td>
<td>
<p>environment, the environment for the original
propensity score formula.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of propensity scores for each observation, as well
as a 'model'. If the user inputs a formula characterizing the
model for taking up treatment, then the <code>lm</code>/<code>glm</code>
object is returned. If the user declares a variable in the data
set to be used as the propensity score, then a
<code>data.frame</code> containing the propensity score for each
value of the covariates in the probability model is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dtm &lt;- ivmte:::gendistMosquito()

## Declaring a probability model.
propensity(formula = d ~ z,
               data = dtm,
               link = "linear")

## Declaring a variable to be used instead
propensity(formula = ~ pz,
               data = dtm,
               link = "linear")

</code></pre>

<hr>
<h2 id='qpSetup'>Constructing QCQP problem</h2><span id='topic+qpSetup'></span>

<h3>Description</h3>

<p>This function is only used when the direct MTR regression procedure
is used. This function simply constructs the quadratic constraint,
and adds it to the LP problem defined by the linear optimization problem
for the bounds and the linear shape constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpSetup(env, sset, rescale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpSetup_+3A_env">env</code></td>
<td>
<p>environment containing the matrices defining the LP
problem.</p>
</td></tr>
<tr><td><code id="qpSetup_+3A_sset">sset</code></td>
<td>
<p>A list containing the covariats and outcome variable
for the direct MTR regression.</p>
</td></tr>
<tr><td><code id="qpSetup_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QP/QCP
optimization.</p>
</td></tr>
</table>

<hr>
<h2 id='qpSetupBound'>Constructing QCQP problem for bounding</h2><span id='topic+qpSetupBound'></span>

<h3>Description</h3>

<p>This function is only used when the direct MTR regression procedure
is used. This function simply constructs the quadratic constraint,
and adds it to the LP problem defined by the linear optimization problem
for the bounds and the linear shape constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpSetupBound(
  env,
  g0,
  g1,
  criterion.tol,
  criterion.min,
  rescale = FALSE,
  setup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpSetupBound_+3A_env">env</code></td>
<td>
<p>environment containing the matrices defining the LP
problem.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_g0">g0</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_g1">g1</code></td>
<td>
<p>set of expectations for each terms of the MTR for the
control group.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_criterion.tol">criterion.tol</code></td>
<td>
<p>non-negative scalar, determines how much the
quadratic constraint should be relaxed by. If set to 0, the
constraint is not relaxed at all.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_criterion.min">criterion.min</code></td>
<td>
<p>minimum of (SSR - SSY) of a linear regression
with shape constraints.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QP/QCP
optimization.</p>
</td></tr>
<tr><td><code id="qpSetupBound_+3A_setup">setup</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the QP problem should
be set up for solving the bounds, which includes the quadratic
constraint. Set to <code>FALSE</code> if the quadratic constraint
should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matrices and vectors necessary to define an LP
problem for Gurobi or MOSEK.
</p>

<hr>
<h2 id='qpSetupCriterion'>Configure QCQP problem to find minimum criterion</h2><span id='topic+qpSetupCriterion'></span>

<h3>Description</h3>

<p>This function sets up the objective function for minimizing the
criterion. The QCQP model must be passed as an environment variable,
under the entry <code>$model</code>. See <code><a href="#topic+qpSetup">qpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpSetupCriterion(env)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpSetupCriterion_+3A_env">env</code></td>
<td>
<p>The LP environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='qpSetupInfeasible'>Configure QP environment for diagnostics</h2><span id='topic+qpSetupInfeasible'></span>

<h3>Description</h3>

<p>This function separates the shape constraints from the QP
environment. That way, the model can be solved without any shape
constraints, which is the primary cause of infeasibility. This is
done in order to check which shape constraints are causing the
model to be infeasible. The QP model must be passed as an
environment variable, under the entry <code>$model</code>. See
<code><a href="#topic+lpSetup">lpSetup</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qpSetupInfeasible(env, rescale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qpSetupInfeasible_+3A_env">env</code></td>
<td>
<p>The LP environment</p>
</td></tr>
<tr><td><code id="qpSetupInfeasible_+3A_rescale">rescale</code></td>
<td>
<p>boolean, set to <code>TRUE</code> if the MTR components
should be rescaled to improve stability in the LP/QP/QCP
optimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, as this modifies an environment variable to save
memory.
</p>

<hr>
<h2 id='removeSplines'>Separating splines from MTR formulas</h2><span id='topic+removeSplines'></span>

<h3>Description</h3>

<p>This function separates out the function calls <code>uSpline()</code> and
<code>uSplines()</code> potentially embedded in the MTR formulas from the
rest of the formula. The terms involving splines are treated
separately from the terms that do not involve splines when creating
the gamma moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeSplines(formula, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="removeSplines_+3A_formula">formula</code></td>
<td>
<p>the formula that is to be parsed.</p>
</td></tr>
<tr><td><code id="removeSplines_+3A_env">env</code></td>
<td>
<p>environment in which to formulas. This is necessary as
splines may be declared using objects, e.g. <code>knots = x</code>,
where <code>x = c(0.3, 0.64, 0.9)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing two objects. One object is <code>formula</code>
but with the spline components removed. The second object is a
list. The name of each element is the
<code>uSpline()</code>/<code>uSplines()</code> command, and the elements
are a vector of the names of covariates that were interacted
with the <code>uSpline()</code>/<code>uSplines()</code> command.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Declare and MTR with a sline component.
m0 = ~ x1 + x1 : uSpline(degree = 2,
                          knots = c(0.2, 0.4)) +
            x2 : uSpline(degree = 2,
                          knots = c(0.2, 0.4)) +
            x1 : x2 : uSpline(degree = 2,
                               knots = c(0.2, 0.4)) +
            uSpline(degree = 3,
                     knots = c(0.2, 0.4),
                     intercept = FALSE)

## Now separate the spline component from the non-spline component
removeSplines(m0)

</code></pre>

<hr>
<h2 id='rescaleX'>Function to implement rescaling procedure</h2><span id='topic+rescaleX'></span>

<h3>Description</h3>

<p>This function rescales the matrix of covariates used in the direct
regression to improve the conditioning number and the stability of
the estimation procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescaleX(sset, dVec, drY, drN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescaleX_+3A_sset">sset</code></td>
<td>
<p>a list of lists constructed from the function
<a href="#topic+genSSet">genSSet</a>. In the case of a direct regression, 'sset'
contains only one inner list. This list contains the gamma
moment at the individual level.</p>
</td></tr>
<tr><td><code id="rescaleX_+3A_dvec">dVec</code></td>
<td>
<p>Vector of treatment statuses from the data.</p>
</td></tr>
<tr><td><code id="rescaleX_+3A_dry">drY</code></td>
<td>
<p>Vector of outcomes from the data.</p>
</td></tr>
<tr><td><code id="rescaleX_+3A_drn">drN</code></td>
<td>
<p>Scalar, number of observations in the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of rescaled covariates.
</p>

<hr>
<h2 id='restring'>Auxiliary function that converts an expression of variable names
into a vector of strings.</h2><span id='topic+restring'></span>

<h3>Description</h3>

<p>Auxiliary function that converts an expression of variable names
into a vector of strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restring(vector, substitute = TRUE, command = "c")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restring_+3A_vector">vector</code></td>
<td>
<p>An expression of a list of variable names.</p>
</td></tr>
<tr><td><code id="restring_+3A_substitute">substitute</code></td>
<td>
<p>Boolean option of whether or not we wish to use
the <code>substitute</code> command when implementing this
function. Note that this substitutes the argument of the
function. If <code>substitute = FALSE</code>, then the function will
instead treat the arguments as variables, and substitute in
their values.</p>
</td></tr>
<tr><td><code id="restring_+3A_command">command</code></td>
<td>
<p>character, the name of the function defining the
vector or list, e.g. &quot;c&quot;, &quot;list&quot;, &quot;l&quot;. This let's the function
determine how many characters in front to remove.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of variable names (strings).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 4
b &lt;- 5
ivmte:::restring(c(a, b), substitute = TRUE)
ivmte:::restring(c(a, b), substitute = FALSE)
</code></pre>

<hr>
<h2 id='rhalton'>Generate Halton sequence</h2><span id='topic+rhalton'></span>

<h3>Description</h3>

<p>This function generates a one dimensional Halton sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rhalton(n, base = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rhalton_+3A_n">n</code></td>
<td>
<p>Number of draws.</p>
</td></tr>
<tr><td><code id="rhalton_+3A_base">base</code></td>
<td>
<p>Base used for the Halton sequence, set to 2 by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sequence of randomly drawn numbers.
</p>

<hr>
<h2 id='runCplexAPI'>Running cplexAPI solver</h2><span id='topic+runCplexAPI'></span>

<h3>Description</h3>

<p>This function solves the LP problem using the cplexAPI package. The
object generated by <code><a href="#topic+lpSetup">lpSetup</a></code> is not compatible with
the <code>cplexAPI</code> functions. This function adapts the object to
solve the LP problem. See <code><a href="#topic+runGurobi">runGurobi</a></code> for additional
error code labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runCplexAPI(model, lpdir, solver.options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runCplexAPI_+3A_model">model</code></td>
<td>
<p>list of matrices and vectors defining the linear
programming problem.</p>
</td></tr>
<tr><td><code id="runCplexAPI_+3A_lpdir">lpdir</code></td>
<td>
<p>input either CPX_MAX or CPX_MIN, which sets the LP
problem as a maximization or minimization problem.</p>
</td></tr>
<tr><td><code id="runCplexAPI_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the LP solver selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the output from CPLEX. This includes the
objective value, the solution vector, and the optimization
status (status of <code>1</code> indicates successful optimization).
</p>

<hr>
<h2 id='runGurobi'>Running Gurobi solver</h2><span id='topic+runGurobi'></span>

<h3>Description</h3>

<p>This function solves the LP/QCQP problem using the Gurobi package. The
object generated by <code><a href="#topic+lpSetup">lpSetup</a></code> is compatible with the
<code>gurobi</code> function. See <code><a href="#topic+runCplexAPI">runCplexAPI</a></code> for
additional error code labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runGurobi(model, solver.options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runGurobi_+3A_model">model</code></td>
<td>
<p>list of matrices and vectors defining the linear
programming problem.</p>
</td></tr>
<tr><td><code id="runGurobi_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the LP solver selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the output from Gurobi. This includes the
objective value, the solution vector, and the optimization
status (status of <code>1</code> indicates successful optimization) .
</p>

<hr>
<h2 id='runLpSolveAPI'>Running lpSolveAPI</h2><span id='topic+runLpSolveAPI'></span>

<h3>Description</h3>

<p>This function solves the LP problem using the <code>lpSolveAPI</code>
package. The object generated by <code><a href="#topic+lpSetup">lpSetup</a></code> is not
compatible with the <code>lpSolveAPI</code> functions. This function
adapts the object to solve the LP problem. See
<code><a href="#topic+runGurobi">runGurobi</a></code> and <code><a href="#topic+runCplexAPI">runCplexAPI</a></code> for
additional error code labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runLpSolveAPI(model, modelsense, solver.options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runLpSolveAPI_+3A_model">model</code></td>
<td>
<p>list of matrices and vectors defining the linear
programming problem.</p>
</td></tr>
<tr><td><code id="runLpSolveAPI_+3A_modelsense">modelsense</code></td>
<td>
<p>input either 'max' or 'min' which sets the LP
problem as a maximization or minimization problem.</p>
</td></tr>
<tr><td><code id="runLpSolveAPI_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the LP solver selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the output from <code>lpSolveAPI</code>. This includes
the objective value, the solution vector, and the optimization
status (status of <code>1</code> indicates successful optimization).
</p>

<hr>
<h2 id='runMosek'>Running Rmosek</h2><span id='topic+runMosek'></span>

<h3>Description</h3>

<p>This function solves the LP/QCQP problem using the <code>Rmosek</code>
package. The object generated by <code><a href="#topic+lpSetup">lpSetup</a></code> is not
compatible with the <code>Rmosek</code> functions. This function
adapts the object to solve the LP problem. See
<code><a href="#topic+runGurobi">runGurobi</a></code> and <code><a href="#topic+runCplexAPI">runCplexAPI</a></code> for
additional error code labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMosek(model, modelsense, solver.options, debug = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runMosek_+3A_model">model</code></td>
<td>
<p>list of matrices and vectors defining the linear
programming problem.</p>
</td></tr>
<tr><td><code id="runMosek_+3A_modelsense">modelsense</code></td>
<td>
<p>input either 'max' or 'min' which sets the LP
problem as a maximization or minimization problem.</p>
</td></tr>
<tr><td><code id="runMosek_+3A_solver.options">solver.options</code></td>
<td>
<p>list, each item of the list should
correspond to an option specific to the LP solver selected.</p>
</td></tr>
<tr><td><code id="runMosek_+3A_debug">debug</code></td>
<td>
<p>boolean, indicates whether or not the function should
provide output when obtaining bounds. The output provided is
the same as what the Mosek would send to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of the output from <code>Rmosek</code>. This includes
the objective value, the solution vector, and the optimization
status (status of <code>1</code> indicates successful optimization).
</p>

<hr>
<h2 id='selectViolations'>Select points from audit grid to add to the constraint grid</h2><span id='topic+selectViolations'></span>

<h3>Description</h3>

<p>This function selects which points from the audit grid should be
included into the original grid. Both the constraint grid and audit
grid are represented as constraints in an LP/QCQP problem. This
function selects which points in the audit grid (i.e. which rows in
the audit constraint matrix) should be added to the constraint grid
(i.e. should be appended to the constraint matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectViolations(
  diffVec,
  audit.add,
  lb0seq,
  lb1seq,
  lbteseq,
  ub0seq,
  ub1seq,
  ubteseq,
  mono0seq,
  mono1seq,
  monoteseq,
  mbmap
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectViolations_+3A_diffvec">diffVec</code></td>
<td>
<p>numeric vector, with a positive value indicating a
violation of a shape constraint.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_audit.add">audit.add</code></td>
<td>
<p>integer, the number of points from the audit grid
to add to the initial for each constraint type. For instance, if
there are 5 different kinds of constraints imposed, and
<code>audit.add = 5</code>, then up to 30 points may be added to the
constraint grid.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_lb0seq">lb0seq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constraint matrix correspond to the lower bound for m0.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_lb1seq">lb1seq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constraint matrix correspond to the lower bound for m1.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_lbteseq">lbteseq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constriant matrix correspond to the lower bound for the
treatment effect.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_ub0seq">ub0seq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constraint matrix correspond to the upper bound for m0.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_ub1seq">ub1seq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constraint matrix correspond to the upper bound for m1.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_ubteseq">ubteseq</code></td>
<td>
<p>integer vector, indicates which rows in the audit
constriant matrix correspond to the upper bound for the
treatment effect.</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_mono0seq">mono0seq</code></td>
<td>
<p>integer matrix, indicates which rows in the audit
constraint matrix correspond to the monotonicity conditions for
m0, and whether the constraint is increasing (+1) or decreasing
(-1).</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_mono1seq">mono1seq</code></td>
<td>
<p>integer matrix, indicates which rows in the audit
constraint matrix correspond to the monotonicity conditions for
m1, and whether the constraint is increasing (+1) or decreasing
(-1).</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_monoteseq">monoteseq</code></td>
<td>
<p>integer matrix, indicates which rows in the audit
constraint matrix correspond to the monotonicity conditions for
the treatment effect, and whether the constraint is increasing
(+1) or decreasing (-1).</p>
</td></tr>
<tr><td><code id="selectViolations_+3A_mbmap">mbmap</code></td>
<td>
<p>integer vector, indexes the X-value associated with
each row in the audit constraint matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The audit grid is represented using a set of constraint
matrices. Each point in the audit grid corresponds to a set of
rows in the constraint matrices. The function simply returns
the vector of row numbers for the points from the audit grid
whose corresponding constraints should be added to the original
LP/QCQP problem (i.e. the points to add to the original grid).
</p>

<hr>
<h2 id='sOls1d'>IV-like weighting function, OLS specification 1</h2><span id='topic+sOls1d'></span>

<h3>Description</h3>

<p>IV-like weighting function for OLS specification 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sOls1d(d, exx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sOls1d_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control.</p>
</td></tr>
<tr><td><code id="sOls1d_+3A_exx">exx</code></td>
<td>
<p>the matrix E[XX']</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='sOls2d'>IV-like weighting function, OLS specification 2</h2><span id='topic+sOls2d'></span>

<h3>Description</h3>

<p>IV-like weighting function for OLS specification 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sOls2d(x, d, exx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sOls2d_+3A_x">x</code></td>
<td>
<p>vector, the value of the covariates other than the
intercept and the treatment indicator.</p>
</td></tr>
<tr><td><code id="sOls2d_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control.</p>
</td></tr>
<tr><td><code id="sOls2d_+3A_exx">exx</code></td>
<td>
<p>the matrix E[XX']</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='sOls3'>IV-like weighting function, OLS specification 3</h2><span id='topic+sOls3'></span>

<h3>Description</h3>

<p>IV-like weighting function for OLS specification 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sOls3(x, d, j, exx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sOls3_+3A_x">x</code></td>
<td>
<p>vector, the value of the covariates other than the
intercept and the treatment indicator.</p>
</td></tr>
<tr><td><code id="sOls3_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control.</p>
</td></tr>
<tr><td><code id="sOls3_+3A_j">j</code></td>
<td>
<p>scalar, position of the component one is interested in
constructing the IV-like weight for.</p>
</td></tr>
<tr><td><code id="sOls3_+3A_exx">exx</code></td>
<td>
<p>the matrix E[XX']</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='sOlsSplines'>IV-like weighting function, OLS specifications</h2><span id='topic+sOlsSplines'></span>

<h3>Description</h3>

<p>IV-like weighting function for OLS specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sOlsSplines(x = NULL, d, j, exx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sOlsSplines_+3A_x">x</code></td>
<td>
<p>vector, the value of the covariates other than the
intercept and the treatment indicator.</p>
</td></tr>
<tr><td><code id="sOlsSplines_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control.</p>
</td></tr>
<tr><td><code id="sOlsSplines_+3A_j">j</code></td>
<td>
<p>scalar, position of the component one is interested in
constructing the IV-like weight for.</p>
</td></tr>
<tr><td><code id="sOlsSplines_+3A_exx">exx</code></td>
<td>
<p>matrix corresponding to E[XX'].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='splineInt'>Integrating splines</h2><span id='topic+splineInt'></span>

<h3>Description</h3>

<p>This function simply integrates the splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineInt(ub, lb, knots, degree, intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineInt_+3A_ub">ub</code></td>
<td>
<p>scalar, upperbound of integral.</p>
</td></tr>
<tr><td><code id="splineInt_+3A_lb">lb</code></td>
<td>
<p>scalar, lowerbound of integral.</p>
</td></tr>
<tr><td><code id="splineInt_+3A_knots">knots</code></td>
<td>
<p>vector, knots of the spline.</p>
</td></tr>
<tr><td><code id="splineInt_+3A_degree">degree</code></td>
<td>
<p>scalar, degre of spline.</p>
</td></tr>
<tr><td><code id="splineInt_+3A_intercept">intercept</code></td>
<td>
<p>boolean, set to TRUE if spline basis should
include a component so that the basis sums to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, each component being the integral of a basis.
</p>

<hr>
<h2 id='splinesBasis'>Evaluating splines basis functions</h2><span id='topic+splinesBasis'></span>

<h3>Description</h3>

<p>This function evaluates the splines basis functions. Unlike the
<code>bSpline</code> in the <code>splines2</code> package, this function
returns the value of a single spline basis, rather than a vector of
values for all the spline basis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splinesBasis(x, knots, degree, intercept = TRUE, i, boundary.knots = c(0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splinesBasis_+3A_x">x</code></td>
<td>
<p>vector, the values at which to evaluate the basis
function.</p>
</td></tr>
<tr><td><code id="splinesBasis_+3A_knots">knots</code></td>
<td>
<p>vector, the internal knots.</p>
</td></tr>
<tr><td><code id="splinesBasis_+3A_degree">degree</code></td>
<td>
<p>integer, the degree of the splines.</p>
</td></tr>
<tr><td><code id="splinesBasis_+3A_intercept">intercept</code></td>
<td>
<p>boolean, default set to <code>TRUE</code>. This includes
an additional component to the basis splines so that the
splines are a partition of unity (i.e. the sum of all
components equal to 1).</p>
</td></tr>
<tr><td><code id="splinesBasis_+3A_i">i</code></td>
<td>
<p>integer, the basis component to be evaluated.</p>
</td></tr>
<tr><td><code id="splinesBasis_+3A_boundary.knots">boundary.knots</code></td>
<td>
<p>vector, default is <code>c(0, 1)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='splineUpdate'>Constructing higher order splines</h2><span id='topic+splineUpdate'></span>

<h3>Description</h3>

<p>This function recursively constructs the higher order splines
basis. Note that the function does not take into consideration the
order of the final basis function. The dimensions of the inputs
dicate this, and are updated in each iteration of the
recursion. The recursion ends once the row number of argument
<code>bmat</code> reaches 1. This function was coded in accordance to
Carl de Boor's set of notes on splines, &quot;B(asic)-Spline Basics&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splineUpdate(x, bmat, knots, i, current.order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splineUpdate_+3A_x">x</code></td>
<td>
<p>vector, the values at which to evaluate the basis
function.</p>
</td></tr>
<tr><td><code id="splineUpdate_+3A_bmat">bmat</code></td>
<td>
<p>matrix. Each column of <code>bmat</code> corresponds to an
element of argument <code>x</code>. Each row corresponds to the
evaluation of basis component <code>i</code>, <code>i + 1</code>, .... The
recursive nature of splines requires that we initially evaluate
the basis functions for components <code>i</code>, ..., <code>i +
degree of spline</code>. Each iteration of the recursion reduces the
row of <code>bmat</code> by 1. The recursion terminates once
<code>bmat</code> has only a single row.</p>
</td></tr>
<tr><td><code id="splineUpdate_+3A_knots">knots</code></td>
<td>
<p>vector, the internal knots.</p>
</td></tr>
<tr><td><code id="splineUpdate_+3A_i">i</code></td>
<td>
<p>integer, the basis component of interest.</p>
</td></tr>
<tr><td><code id="splineUpdate_+3A_current.order">current.order</code></td>
<td>
<p>integer, the current order associated with the
argument <code>bmat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector, the evaluation of the spline at each value in
vector <code>x</code>.
</p>

<hr>
<h2 id='statusString'>Convert status code to string</h2><span id='topic+statusString'></span>

<h3>Description</h3>

<p>This function returns the status code specific to a solver.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statusString(status, solver)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statusString_+3A_status">status</code></td>
<td>
<p>Status code.</p>
</td></tr>
<tr><td><code id="statusString_+3A_solver">solver</code></td>
<td>
<p>Name of solver, either 'gurobi', 'cplexapi', or
'lpsolveapi'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Status specific to solver, e.g. 'OPTIMAL (2)'.
</p>

<hr>
<h2 id='sTsls'>IV-like weighting function, TSLS specification</h2><span id='topic+sTsls'></span>

<h3>Description</h3>

<p>IV-like weighting function for TSLS specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sTsls(z, j, exz, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sTsls_+3A_z">z</code></td>
<td>
<p>vector, the value of the instrument.</p>
</td></tr>
<tr><td><code id="sTsls_+3A_j">j</code></td>
<td>
<p>scalar, position of the component one is interested in
constructing the IV-like weight for.</p>
</td></tr>
<tr><td><code id="sTsls_+3A_exz">exz</code></td>
<td>
<p>the matrix E[XZ']</p>
</td></tr>
<tr><td><code id="sTsls_+3A_pi">pi</code></td>
<td>
<p>the matrix E[XZ']E[ZZ']^-1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='sTslsSplines'>IV-like weighting function, TSLS specification</h2><span id='topic+sTslsSplines'></span>

<h3>Description</h3>

<p>IV-like weighting function for TSLS specification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sTslsSplines(z, d, j, exz, pi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sTslsSplines_+3A_z">z</code></td>
<td>
<p>vector, the value of the instrument.</p>
</td></tr>
<tr><td><code id="sTslsSplines_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control (redundant in this
function; included to exploit apply()).</p>
</td></tr>
<tr><td><code id="sTslsSplines_+3A_j">j</code></td>
<td>
<p>scalar, position of the component one is interested in
constructing the IV-like weight for.</p>
</td></tr>
<tr><td><code id="sTslsSplines_+3A_exz">exz</code></td>
<td>
<p>matrix, corresponds to E[XZ'].</p>
</td></tr>
<tr><td><code id="sTslsSplines_+3A_pi">pi</code></td>
<td>
<p>matrix, corresponds to E[XZ']E[ZZ']^-1, the first stage
regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='subsetclean'>Auxiliary function: remove extraneous spaces</h2><span id='topic+subsetclean'></span>

<h3>Description</h3>

<p>Auxiliary function to remove extraneous spaces from strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetclean(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetclean_+3A_string">string</code></td>
<td>
<p>the string object to be cleaned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string
</p>

<hr>
<h2 id='summary.ivmte'>Summarize results</h2><span id='topic+summary.ivmte'></span>

<h3>Description</h3>

<p>This function uses the summary method on the ivmte return list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ivmte'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ivmte_+3A_object">object</code></td>
<td>
<p>an object returned from '<code>ivmte</code>'.</p>
</td></tr>
<tr><td><code id="summary.ivmte_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>summarized results.
</p>

<hr>
<h2 id='sWald'>IV-like weighting function, Wald specification</h2><span id='topic+sWald'></span>

<h3>Description</h3>

<p>IV-like weighting function for OLS specification 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sWald(z, p.to, p.from, e.to, e.from)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sWald_+3A_z">z</code></td>
<td>
<p>vector, the value of the instrument.</p>
</td></tr>
<tr><td><code id="sWald_+3A_p.to">p.to</code></td>
<td>
<p>P[Z = z'], where z' is value of the instrument the
agent is switching to.</p>
</td></tr>
<tr><td><code id="sWald_+3A_p.from">p.from</code></td>
<td>
<p>P[Z = z], where z is the value of the instrument the
agent is switching from.</p>
</td></tr>
<tr><td><code id="sWald_+3A_e.to">e.to</code></td>
<td>
<p>E[D | Z = z'], where z' is the value of the instrument
the agent is switching to.</p>
</td></tr>
<tr><td><code id="sWald_+3A_e.from">e.from</code></td>
<td>
<p>E[D | Z = z], where z is the value of the instrument the
agent is switching from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='symat'>Generate symmetric matrix</h2><span id='topic+symat'></span>

<h3>Description</h3>

<p>Function takes in a vector of values, and constructs a symmetric
matrix from it. Diagonals must be included. The length of the
vector must also be consistent with the number of &quot;unique&quot; entries
in the symmetric matrix. Note that entries are filled in along the
columns (i.e. equivalent to byrow = FALSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symat(values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symat_+3A_values">values</code></td>
<td>
<p>vector, the values that enter into the symmetric
matrix. Dimensions will be determined automatically.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix.
</p>

<hr>
<h2 id='tsls'>TSLS weights, with controls</h2><span id='topic+tsls'></span>

<h3>Description</h3>

<p>Function generating the S-weights for TSLS estimand, with controls.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsls(X, Z, Z0, Z1, components, treat, order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsls_+3A_x">X</code></td>
<td>
<p>Matrix of covariates, including the treatment indicator.</p>
</td></tr>
<tr><td><code id="tsls_+3A_z">Z</code></td>
<td>
<p>Matrix of instruments.</p>
</td></tr>
<tr><td><code id="tsls_+3A_z0">Z0</code></td>
<td>
<p>Matrix of instruments, fixing treatment to 0.</p>
</td></tr>
<tr><td><code id="tsls_+3A_z1">Z1</code></td>
<td>
<p>Matrix of instruments, fixing treatment to 1.</p>
</td></tr>
<tr><td><code id="tsls_+3A_components">components</code></td>
<td>
<p>Vector of variable names of which user wants the
S-weights for.</p>
</td></tr>
<tr><td><code id="tsls_+3A_treat">treat</code></td>
<td>
<p>Variable name for the treatment indicator.</p>
</td></tr>
<tr><td><code id="tsls_+3A_order">order</code></td>
<td>
<p>integer, default set to <code>NULL</code>. This is simply an
index of which IV-like specification the estimate corresponds
to.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two vectors: one is the weight for D = 0, the
other is the weight for D = 1.
</p>

<hr>
<h2 id='unstring'>Auxiliary function that converts a vector of strings into an
expression containing variable names.</h2><span id='topic+unstring'></span>

<h3>Description</h3>

<p>Auxiliary function that converts a vector of strings into an
expression containing variable names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unstring(vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unstring_+3A_vector">vector</code></td>
<td>
<p>Vector of variable names (strings).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An expression for the list of variable names that are not
strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ivmte:::unstring(c("a", "b"))
</code></pre>

<hr>
<h2 id='uSplineBasis'>Spline basis function</h2><span id='topic+uSplineBasis'></span>

<h3>Description</h3>

<p>This function evaluates the splines that the user specifies when
declaring the MTRs. This is to be used for auditing, namely when
checking the boundedness and monotonicity conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uSplineBasis(x, knots, degree = 0, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uSplineBasis_+3A_x">x</code></td>
<td>
<p>the points to evaluate the integral of the the splines.</p>
</td></tr>
<tr><td><code id="uSplineBasis_+3A_knots">knots</code></td>
<td>
<p>the knots of the spline.</p>
</td></tr>
<tr><td><code id="uSplineBasis_+3A_degree">degree</code></td>
<td>
<p>the degree of the spline; default is set to 0
(constant splines).</p>
</td></tr>
<tr><td><code id="uSplineBasis_+3A_intercept">intercept</code></td>
<td>
<p>boolean, set to TRUE if intercept term is to be
included (i.e. an additional basis such that the sum of the
splines at every point in <code>x</code> is equal to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, the values of the integrated splines. Each row
corresponds to a value of <code>x</code>; each column corresponds to
a basis defined by the degrees and knots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Since the splines are declared as part of the MTR, you will need
## to have parsed out the spline command. Thus, this command will be
## called via eval(parse(text = .)). In the examples below, the
## commands are parsed from the object \code{splineslist} generated
## by \code{\link[MST]{removeSplines}}. The names of the elements in
## the list are the spline commands, and the elements themselves are
## the terms that interact with the splines.

## Declare MTR function
m0 = ~ x1 + x1 : uSpline(degree = 2,
                          knots = c(0.2, 0.4)) +
    x2 : uSpline(degree = 2,
                  knots = c(0.2, 0.4)) +
    x1 : x2 : uSpline(degree = 2,
                       knots = c(0.2, 0.4)) +
    uSpline(degree = 3,
             knots = c(0.2, 0.4),
             intercept = FALSE)

## Extract spline functions from MTR function
splineslist &lt;- removeSplines(m0)$splineslist

## Declare points at which we wish to evaluate the spline functions
x &lt;- seq(0, 1, 0.2)

## Evaluate the splines
eval(parse(text = gsub("uSpline\\(",
                       "ivmte:::uSplineBasis(x = x, ",
                        names(splineslist)[1])))

eval(parse(text = gsub("uSpline\\(",
                       "ivmte:::uSplineBasis(x = x, ",
                       names(splineslist)[2])))
</code></pre>

<hr>
<h2 id='uSplineInt'>Integrated splines</h2><span id='topic+uSplineInt'></span>

<h3>Description</h3>

<p>This function integrates out splines that the user specifies when
declaring the MTRs. This is to be used when generating the gamma
moments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uSplineInt(x, knots, degree = 0, intercept = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uSplineInt_+3A_x">x</code></td>
<td>
<p>the points to evaluate the integral of the the splines.</p>
</td></tr>
<tr><td><code id="uSplineInt_+3A_knots">knots</code></td>
<td>
<p>the knots of the spline.</p>
</td></tr>
<tr><td><code id="uSplineInt_+3A_degree">degree</code></td>
<td>
<p>the degree of the spline; default is set to 0
(constant splines).</p>
</td></tr>
<tr><td><code id="uSplineInt_+3A_intercept">intercept</code></td>
<td>
<p>boolean, set to TRUE if intercept term is to be
included (i.e. an additional basis such that the sum of the
splines at every point in <code>x</code> is equal to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix, the values of the integrated splines. Each row
corresponds to a value of <code>x</code>; each column corresponds to
a basis defined by the degrees and knots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Since the splines are declared as part of the MTR, you will need
## to have parsed out the spline command. Thus, this command will be
## called via eval(parse(text = .)). In the examples below, the
## commands are parsed from the object \code{splineslist} generated
## by \code{\link[MST]{removeSplines}}. The names of the elements in
## the list are the spline commands, and the elements themselves are
## the terms that interact with the splines.

## Declare MTR function
m0 = ~ x1 + x1 : uSpline(degree = 2,
                          knots = c(0.2, 0.4)) +
    x2 : uSpline(degree = 2,
                  knots = c(0.2, 0.4)) +
    x1 : x2 : uSpline(degree = 2,
                       knots = c(0.2, 0.4)) +
    uSpline(degree = 3,
             knots = c(0.2, 0.4),
             intercept = FALSE)

## Separate the spline components from the MTR function
splineslist &lt;- removeSplines(m0)$splineslist

## Delcare the points at which we wish to evaluate the integrals
x &lt;- seq(0, 1, 0.2)

## Evaluate the splines integrals
eval(parse(text = gsub("uSpline\\(",
                       "ivmte:::uSplineInt(x = x, ",
                       names(splineslist)[1])))


eval(parse(text = gsub("uSpline\\(",
                       "ivmte:::uSplineInt(x = x, ",
                       names(splineslist)[2])))
</code></pre>

<hr>
<h2 id='vecextract'>Auxiliary function: extracting elements from strings</h2><span id='topic+vecextract'></span>

<h3>Description</h3>

<p>This auxiliary function extracts the (string) element in the
<code>position</code> argument of the <code>vector</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecextract(vector, position, truncation = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vecextract_+3A_vector">vector</code></td>
<td>
<p>the vector from which we want to extract the
elements.</p>
</td></tr>
<tr><td><code id="vecextract_+3A_position">position</code></td>
<td>
<p>the position in <code>vector</code> to extract.</p>
</td></tr>
<tr><td><code id="vecextract_+3A_truncation">truncation</code></td>
<td>
<p>the number of characters from the front of the
element being extracted that should be dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A chracter/string.
</p>

<hr>
<h2 id='wate1'>Target weight for ATE</h2><span id='topic+wate1'></span>

<h3>Description</h3>

<p>Function generates the target weight for the ATE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wate1(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wate1_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> on which the estimation is performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bounds of integration over unobservable <code>u</code>, as
well as the multiplier in the weight.
</p>

<hr>
<h2 id='watt1'>Target weight for ATT</h2><span id='topic+watt1'></span>

<h3>Description</h3>

<p>Function generates the target weight for the ATT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watt1(data, expd1, propensity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watt1_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> on which the estimation is performed.</p>
</td></tr>
<tr><td><code id="watt1_+3A_expd1">expd1</code></td>
<td>
<p>Scalar, the probability that treatment is received.</p>
</td></tr>
<tr><td><code id="watt1_+3A_propensity">propensity</code></td>
<td>
<p>Vector of propensity to take up treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bounds of integration over unobservable <code>u</code>, as
well as the multiplier in the weight.
</p>

<hr>
<h2 id='wAttSplines'>Target weighting function, for ATT</h2><span id='topic+wAttSplines'></span>

<h3>Description</h3>

<p>Target weighting function, for the ATT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wAttSplines(z, d, ed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wAttSplines_+3A_z">z</code></td>
<td>
<p>vector, the value of the instrument (redundant in this
function; included to exploit apply()).</p>
</td></tr>
<tr><td><code id="wAttSplines_+3A_d">d</code></td>
<td>
<p>0 or 1, indicating treatment or control (redundant in this
function; included to exploit apply()).</p>
</td></tr>
<tr><td><code id="wAttSplines_+3A_ed">ed</code></td>
<td>
<p>scalar, unconditional probability of taking up treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='watu1'>Target weight for ATU</h2><span id='topic+watu1'></span>

<h3>Description</h3>

<p>Function generates the target weight for the ATT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>watu1(data, expd0, propensity)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="watu1_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> on which the estimation is performed.</p>
</td></tr>
<tr><td><code id="watu1_+3A_expd0">expd0</code></td>
<td>
<p>Scalar, the probability that treatment is not
recieved.</p>
</td></tr>
<tr><td><code id="watu1_+3A_propensity">propensity</code></td>
<td>
<p>Vector of propensity to take up treatment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bounds of integration over unobservable <code>u</code>, as
well as the multiplier in the weight.
</p>

<hr>
<h2 id='weights'>Generating splines weights</h2><span id='topic+weights'></span>

<h3>Description</h3>

<p>This function generates the weights required to construct splines
of higher order. This function was coded in accordance to Carl de
Boor's set of notes on splines, &quot;B(asic)-Spline Basics&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights(x, knots, i, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights_+3A_x">x</code></td>
<td>
<p>vector, the values at which to evaluate the basis
function.</p>
</td></tr>
<tr><td><code id="weights_+3A_knots">knots</code></td>
<td>
<p>vector, the internal knots.</p>
</td></tr>
<tr><td><code id="weights_+3A_i">i</code></td>
<td>
<p>integer, the basis component to be evaluated.</p>
</td></tr>
<tr><td><code id="weights_+3A_order">order</code></td>
<td>
<p>integer, the order of the basis. Do not confuse this
with the degree of the splines, i.e. order = degree + 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scalar.
</p>

<hr>
<h2 id='wgenlate1'>Target weight for generalized LATE</h2><span id='topic+wgenlate1'></span>

<h3>Description</h3>

<p>Function generates the target weight for the generalized LATE,
where the user can specify the interval of propensity scores
defining the compliers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wgenlate1(data, ulb, uub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wgenlate1_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> on which the estimation is performed.</p>
</td></tr>
<tr><td><code id="wgenlate1_+3A_ulb">ulb</code></td>
<td>
<p>Numeric, lower bound of interval.</p>
</td></tr>
<tr><td><code id="wgenlate1_+3A_uub">uub</code></td>
<td>
<p>Numeric, upper bound of interval.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bounds of integration over unobservable <code>u</code>, as
well as the multiplier in the weight.
</p>

<hr>
<h2 id='whichforlist'>Auxiliary function: <code>which</code> for lists</h2><span id='topic+whichforlist'></span>

<h3>Description</h3>

<p>Auxiliary function that makes it possible to use <code>which</code> with
a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whichforlist(vector, obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whichforlist_+3A_vector">vector</code></td>
<td>
<p>the vector for which we want to check the entries of</p>
</td></tr>
<tr><td><code id="whichforlist_+3A_obj">obj</code></td>
<td>
<p>the value for which we want the vector to match on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of positions where the elements in <code>vector</code>
are equal to <code>obj</code>.
</p>

<hr>
<h2 id='wlate1'>Target weight for LATE</h2><span id='topic+wlate1'></span>

<h3>Description</h3>

<p>Function generates the target weight for the LATE, conditioned on a
specific value of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlate1(data, from, to, Z, model, X, eval.X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlate1_+3A_data">data</code></td>
<td>
<p><code>data.frame</code> on which the estimation is performed.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_from">from</code></td>
<td>
<p>Vector of baseline values for the instruments.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_to">to</code></td>
<td>
<p>Vector of comparison values for the instruments.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_z">Z</code></td>
<td>
<p>Character vector of names of instruments.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_model">model</code></td>
<td>
<p>A <code>lm</code> or <code>glm</code> object, or a
<code>data.frame</code>, which can be used to estimate the propensity
to take up treatment for the specified values of the
instruments.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_x">X</code></td>
<td>
<p>Character vector of variable names for the non-excluded
variables the user wishes to condition the LATE on.</p>
</td></tr>
<tr><td><code id="wlate1_+3A_eval.x">eval.X</code></td>
<td>
<p>Vector of values the user wishes to condition the
<code>X</code> variables on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The bounds of integration over unobservable <code>u</code>, as
well as the multiplier in the weight.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
