<!DOCTYPE html><html><head><title>Help for package nvctr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nvctr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#along_track_distance'><p>Compute the along-track distance from a great circle arc</p></a></li>
<li><a href='#altitude_azimuth_distance'><p>Calculate the altitude, azimuth and distance of B from A</p></a></li>
<li><a href='#cross_track_distance'><p>Compute the cross-track distance from a great circle arc</p></a></li>
<li><a href='#cross_track_intersection'><p>Calculate cross-track intersection</p></a></li>
<li><a href='#deg'><p>Convert angle in radians to degrees</p></a></li>
<li><a href='#lat_lon2n_E'><p>Convert (geodetic) latitude and longitude to n-vector</p></a></li>
<li><a href='#n_E_and_wa2R_EL'><p>Find <code>R_EL</code> from n-vector and wander azimuth angle</p></a></li>
<li><a href='#n_E2lat_lon'><p>Convert n-vector to latitude and longitude</p></a></li>
<li><a href='#n_E2R_EN'><p>Find the rotation matrix R_EN from n-vector</p></a></li>
<li><a href='#n_EA_E_and_n_EB_E2p_AB_E'><p>Find the delta position from two positions A and B</p></a></li>
<li><a href='#n_EA_E_and_p_AB_E2n_EB_E'><p>Find position B from position A and delta</p></a></li>
<li><a href='#n_EB_E2p_EB_E'><p>Convert n-vector to cartesian position vector in meters</p></a></li>
<li><a href='#nvctr'><p>nvctr: non-singular geographical position calculations</p></a></li>
<li><a href='#p_EB_E2n_EB_E'><p>Convert cartesian position vector in meters to n-vector</p></a></li>
<li><a href='#R_Ee'><p>Select the axes of the coordinate frame E</p></a></li>
<li><a href='#R_EL2n_E'><p>Find n-vector from the rotation matrix (direction cosine matrix) <code>R_EL</code></p></a></li>
<li><a href='#R_EN2n_E'><p>Find n-vector from R_E</p></a></li>
<li><a href='#R2xyz'><p>Find the three rotation angles about new axes in the xyz order from a rotation matrix</p></a></li>
<li><a href='#R2zyx'><p>Find the three angles about new axes in the zyx order from a rotation matrix</p></a></li>
<li><a href='#rad'><p>Convert angle in degrees to radians.</p></a></li>
<li><a href='#unit'><p>Make input vector unit length, i.e. norm == 1</p></a></li>
<li><a href='#xyz2R'><p>Create a rotation matrix from 3 angles about new axes in the xyz order.</p></a></li>
<li><a href='#zyx2R'><p>Create a rotation matrix from 3 angles about new axes in the zyx order.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The n-vector Approach to Geographical Position Calculations
using an Ellipsoidal Model of Earth</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Enrico Spinielli &lt;enrico.spinielli@eurocontrol.int&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The n-vector framework uses the normal vector to
    the Earth ellipsoid (called n-vector) as a non-singular position
    representation that turns out to be very convenient for practical
    position calculations.  The n-vector is simple to use and gives exact
    answers for all global positions, and all distances, for both
    ellipsoidal and spherical Earth models.  This package is a translation
    of the 'Matlab' library from FFI, the Norwegian Defence Research
    Establishment, as described in Gade (2010)
    &lt;<a href="https://doi.org/10.1017%2FS0373463309990415">doi:10.1017/S0373463309990415</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/euctrl-pru/nvctr">https://github.com/euctrl-pru/nvctr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/euctrl-pru/nvctr/issues">https://github.com/euctrl-pru/nvctr/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>magrittr, pracma</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, covr, geosphere, knitr, png, rmarkdown, spelling,
testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-28 13:50:10 UTC; espin</td>
</tr>
<tr>
<td>Author:</td>
<td>Enrico Spinielli <a href="https://orcid.org/0000-0001-8584-9131"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  EUROCONTROL [cph, fnd]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-28 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic++25+3E+25">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='along_track_distance'>Compute the along-track distance from a great circle arc</h2><span id='topic+along_track_distance'></span>

<h3>Description</h3>

<p>Compute the along-track distances of a body, 'b' (for example a ground level projection
position of an aircraft), from two geographical coordinates,
&lsquo;a1' and 'a2' (for example an airport&rsquo;s runway thresholds), of a great circle arc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>along_track_distance(b, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="along_track_distance_+3A_b">b</code></td>
<td>
<p>the geographical coordinates (WGS84) of a body:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
<tr><td><code id="along_track_distance_+3A_a1">a1</code></td>
<td>
<p>the geographical coordinates (WGS84) of one end of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
<tr><td><code id="along_track_distance_+3A_a2">a2</code></td>
<td>
<p>the geographical coordinates (WGS84) of the other end of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the surface along-track distances from &lsquo;b'&rsquo;s cross-track intersection to 'a1' - 'a2'
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+altitude_azimuth_distance">altitude_azimuth_distance</a>()</code>,
<code><a href="#topic+cross_track_distance">cross_track_distance</a>()</code>,
<code><a href="#topic+cross_track_intersection">cross_track_intersection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
b &lt;- c(8.086135, 49.973942, 6401)
# EDDF: 07R (longitude, latitude, altitude)
a1 &lt;- c(8.53417, 50.0275, 328)
# EDDF: 25L
a2 &lt;- c(8.58653, 50.0401, 362)
along_track_distance(b, a1, a2)

## End(Not run)
</code></pre>

<hr>
<h2 id='altitude_azimuth_distance'>Calculate the altitude, azimuth and distance of B from A</h2><span id='topic+altitude_azimuth_distance'></span>

<h3>Description</h3>

<p>The altitude (elevation from the horizon), azimuth and distance of a point B from A
are the coordinates of the Topocentric Coordinate System as typically used in astronomy to
aim your telescope to a heavenly body.
It can be also of use to know where an airplane is in the sky with respect to an observer
on Earth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>altitude_azimuth_distance(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="altitude_azimuth_distance_+3A_a">a</code></td>
<td>
<p>the observer position: a vector of longitude, latitude (in decimal degrees) and
altitude (in meters) in WGS84</p>
</td></tr>
<tr><td><code id="altitude_azimuth_distance_+3A_b">b</code></td>
<td>
<p>the observed position: a vector of longitude, latitude (in decimal degrees) and
altitude (in meters) in WGS84</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the coordinates in North-East-Up of the observed, B, with respect to the
observer A.
A vector of <a href="https://en.wikipedia.org/wiki/Horizontal_coordinate_system">altitude</a>
(elevation from the horizon) in decimal degrees,
<a href="https://en.wikipedia.org/wiki/Azimuth">azimuth</a>) in decimal degrees and
distance in meters.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+along_track_distance">along_track_distance</a>()</code>,
<code><a href="#topic+cross_track_distance">cross_track_distance</a>()</code>,
<code><a href="#topic+cross_track_intersection">cross_track_intersection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# sensor (longitude, latitude, altitude)
a &lt;- c(49.47, 7.697, 274)
# aircraft (longitude, latitude, altitude)
b &lt;- c(49.52, 7.803, 6401)
altitude_azimuth_distance(a, b)

## End(Not run)
</code></pre>

<hr>
<h2 id='cross_track_distance'>Compute the cross-track distance from a great circle arc</h2><span id='topic+cross_track_distance'></span>

<h3>Description</h3>

<p>Compute the cross-track distance of a body, 'b' (for example a ground level projection
position of an aircraft), from a great circle arc determined by two geographical coordinates,
&lsquo;a1' and 'a2' (for example an airport&rsquo;s runway thresholds).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_track_distance(b, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_track_distance_+3A_b">b</code></td>
<td>
<p>the geographical coordinates (WGS84) of a body:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
<tr><td><code id="cross_track_distance_+3A_a1">a1</code></td>
<td>
<p>the geographical coordinates (WGS84) of one end of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
<tr><td><code id="cross_track_distance_+3A_a2">a2</code></td>
<td>
<p>the geographical coordinates (WGS84) of the other end of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and
eventually altitude (in meters)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the surface cross-track distance from 'b' to the arc 'a1' - 'a2'
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+along_track_distance">along_track_distance</a>()</code>,
<code><a href="#topic+altitude_azimuth_distance">altitude_azimuth_distance</a>()</code>,
<code><a href="#topic+cross_track_intersection">cross_track_intersection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
b &lt;- c(8.086135, 49.973942, 6401)
# EDDF: 07R (longitude, latitude, altitude)
a1 &lt;- c(8.53417, 50.0275, 328)
# EDDF: 25L
a2 &lt;- c(8.58653, 50.0401, 362)
cross_track_distance(b, a1, a2)

## End(Not run)
</code></pre>

<hr>
<h2 id='cross_track_intersection'>Calculate cross-track intersection</h2><span id='topic+cross_track_intersection'></span>

<h3>Description</h3>

<p>Calculate the cross-track intersection between the position of a body (i.e. an aircraft) and
a great circle arc as defined by two points (i.e. the runway's thresholds).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross_track_intersection(b, a1, a2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_track_intersection_+3A_b">b</code></td>
<td>
<p>coordinates of the body, b:
a vector of longitude, latitude (in decimal degrees) and altitude (in meters) in WGS84</p>
</td></tr>
<tr><td><code id="cross_track_intersection_+3A_a1">a1</code></td>
<td>
<p>first coordinate of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and elevation (in meters) in WGS84</p>
</td></tr>
<tr><td><code id="cross_track_intersection_+3A_a2">a2</code></td>
<td>
<p>second coordinate of a great circle arc:
a vector of longitude, latitude (in decimal degrees) and elevation (in meters) in WGS84</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-track intersection between the position of a body, B, (i.e. an aircraft) and
a great circle arc as defined by two points, A1 and A2, (i.e. the runway's thresholds)
is the intersection, X, of the above arc with the great circle arc passing through
the ground projection of B, G, and perpendicular to A1-A2.
</p>
<p><img src="../help/figures/cross-track.svg" width="80%" alt="cross-track intersection" />

</p>


<h3>Value</h3>

<p>a WGS84 vector with longitude and latitude (decimal degrees)
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+along_track_distance">along_track_distance</a>()</code>,
<code><a href="#topic+altitude_azimuth_distance">altitude_azimuth_distance</a>()</code>,
<code><a href="#topic+cross_track_distance">cross_track_distance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# aircraft (longitude, latitude, altitude)
b &lt;- c(8.086135, 49.973942, 6401)
# EDDF: 07R (longitude, latitude, altitude)
a1 &lt;- c(8.53417, 50.0275, 328)
# EDDF: 25L
a2 &lt;- c(8.58653, 50.0401, 362)
cross_track_intersection(b, a1, a2)

## End(Not run)
</code></pre>

<hr>
<h2 id='deg'>Convert angle in radians to degrees</h2><span id='topic+deg'></span>

<h3>Description</h3>

<p>Convert angle in radians to degrees
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg(radians)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg_+3A_radians">radians</code></td>
<td>
<p>angle in radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle in degrees.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rad">rad</a></code>.
</p>
<p>Other helpers: 
<code><a href="#topic+rad">rad</a>()</code>,
<code><a href="#topic+unit">unit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg(pi/2)
</code></pre>

<hr>
<h2 id='lat_lon2n_E'>Convert (geodetic) latitude and longitude to n-vector</h2><span id='topic+lat_lon2n_E'></span>

<h3>Description</h3>

<p>Convert (geodetic) latitude and longitude to n-vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lat_lon2n_E(latitude, longitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lat_lon2n_E_+3A_latitude">latitude</code></td>
<td>
<p>Geodetic latitude (rad)</p>
</td></tr>
<tr><td><code id="lat_lon2n_E_+3A_longitude">longitude</code></td>
<td>
<p>Geodetic longitude (rad)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n-vector decomposed in E (3x1 vector) (no unit)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_E2lat_lon">n_E2lat_lon</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat_lon2n_E(rad(1), rad(2))

</code></pre>

<hr>
<h2 id='n_E_and_wa2R_EL'>Find <code>R_EL</code> from n-vector and wander azimuth angle</h2><span id='topic+n_E_and_wa2R_EL'></span>

<h3>Description</h3>

<p>Calculate the rotation matrix (direction cosine matrix) <code>R_EL</code> using
n-vector (<code>n_E</code>) and the wander azimuth angle.
When <code>wander_azimuth = 0</code>, we have that N = L (See Table 2 in Gade (2010) for
details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_E_and_wa2R_EL(n_E, wander_azimuth)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_E_and_wa2R_EL_+3A_n_e">n_E</code></td>
<td>
<p>n-vector decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
<tr><td><code id="n_E_and_wa2R_EL_+3A_wander_azimuth">wander_azimuth</code></td>
<td>
<p>The angle between L's x-axis and north, positive about L's z-axis (rad)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting rotation matrix (3x3) (no unit)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R_EL2n_E">R_EL2n_E</a></code>, <code><a href="#topic+R_EN2n_E">R_EN2n_E</a></code> and <code><a href="#topic+n_E2R_EN">n_E2R_EN</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculates the rotation matrix (direction cosine matrix) R_EL
# using n-vector (n_E) and the wander azimuth angle.
n_E &lt;- c(1, 0, 0)
(R_EL &lt;-  n_E_and_wa2R_EL(n_E, wander_azimuth = pi / 2))

</code></pre>

<hr>
<h2 id='n_E2lat_lon'>Convert n-vector to latitude and longitude</h2><span id='topic+n_E2lat_lon'></span>

<h3>Description</h3>

<p>Convert n-vector to latitude and longitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_E2lat_lon(n_E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_E2lat_lon_+3A_n_e">n_E</code></td>
<td>
<p>n-vector decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of geodetic latitude and longitude (rad)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lat_lon2n_E">lat_lon2n_E</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_E2lat_lon(c(1, 0, 0))

</code></pre>

<hr>
<h2 id='n_E2R_EN'>Find the rotation matrix R_EN from n-vector</h2><span id='topic+n_E2R_EN'></span>

<h3>Description</h3>

<p>Find the rotation matrix R_EN from n-vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_E2R_EN(n_E)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_E2R_EN_+3A_n_e">n_E</code></td>
<td>
<p>n-vector decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The resulting rotation matrix (direction cosine matrix) (no unit)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R_EN2n_E">R_EN2n_E</a></code>, <code><a href="#topic+n_E_and_wa2R_EL">n_E_and_wa2R_EL</a></code> and <code><a href="#topic+R_EL2n_E">R_EL2n_E</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_E2R_EN(c(1, 0, 0))

</code></pre>

<hr>
<h2 id='n_EA_E_and_n_EB_E2p_AB_E'>Find the delta position from two positions A and B</h2><span id='topic+n_EA_E_and_n_EB_E2p_AB_E'></span>

<h3>Description</h3>

<p>Given the n-vectors for positions A (<code>n_EA_E</code>) and B (<code>n_EB_E</code>), the
output is the delta vector from A to B (<code>p_AB_E</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_EA_E_and_n_EB_E2p_AB_E(
  n_EA_E,
  n_EB_E,
  z_EA = 0,
  z_EB = 0,
  a = 6378137,
  f = 1/298.257223563
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_n_ea_e">n_EA_E</code></td>
<td>
<p>n-vector of position A, decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_n_eb_e">n_EB_E</code></td>
<td>
<p>n-vector of position B, decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_z_ea">z_EA</code></td>
<td>
<p>Depth of system A, relative to the ellipsoid (z_EA = -height) (m, default 0)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_z_eb">z_EB</code></td>
<td>
<p>Depth of system B, relative to the ellipsoid (z_EB = -height) (m, default 0)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_a">a</code></td>
<td>
<p>Semi-major axis of the Earth ellipsoid (m, default [WGS-84] 6378137)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_n_EB_E2p_AB_E_+3A_f">f</code></td>
<td>
<p>Flattening of the Earth ellipsoid (no unit, default [WGS-84] 1/298.257223563)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is exact, taking the ellipticity of the Earth into account.
It is also nonsingular as both n-vector and p-vector are nonsingular
(except for the center of the Earth).
The default ellipsoid model used is WGS-84, but other ellipsoids (or spheres) might be specified
via the optional parameters <code>a</code> and <code>f</code>.
</p>


<h3>Value</h3>

<p>Position vector from A to B, decomposed in E (3x1 vector)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_EA_E_and_p_AB_E2n_EB_E">n_EA_E_and_p_AB_E2n_EB_E</a></code>, <code><a href="#topic+p_EB_E2n_EB_E">p_EB_E2n_EB_E</a></code> and
<code><a href="#topic+n_EB_E2p_EB_E">n_EB_E2p_EB_E</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat_EA &lt;- rad(1); lon_EA &lt;- rad(2); z_EA   &lt;- 3
lat_EB &lt;- rad(4); lon_EB &lt;- rad(5); z_EB   &lt;- 6

n_EA_E &lt;- lat_lon2n_E(lat_EA, lon_EA)
n_EB_E &lt;- lat_lon2n_E(lat_EB, lon_EB)

n_EA_E_and_n_EB_E2p_AB_E(n_EA_E, n_EB_E, z_EA, z_EB)

</code></pre>

<hr>
<h2 id='n_EA_E_and_p_AB_E2n_EB_E'>Find position B from position A and delta</h2><span id='topic+n_EA_E_and_p_AB_E2n_EB_E'></span>

<h3>Description</h3>

<p>Given the n-vector for position A (<code>n_EA_E</code>) and the position-vector from position
A to position B (<code>p_AB_E</code>), the output is the n-vector of position
B (<code>n_EB_E</code>) and depth of B (<code>z_EB</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_EA_E_and_p_AB_E2n_EB_E(
  n_EA_E,
  p_AB_E,
  z_EA = 0,
  a = 6378137,
  f = 1/298.257223563
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_EA_E_and_p_AB_E2n_EB_E_+3A_n_ea_e">n_EA_E</code></td>
<td>
<p>n-vector of position A, decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_p_AB_E2n_EB_E_+3A_p_ab_e">p_AB_E</code></td>
<td>
<p>Position vector from A to B, decomposed in E (3x1 vector) (m)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_p_AB_E2n_EB_E_+3A_z_ea">z_EA</code></td>
<td>
<p>Depth of system A, relative to the ellipsoid (z_EA = -height) (m, default 0)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_p_AB_E2n_EB_E_+3A_a">a</code></td>
<td>
<p>Semi-major axis of the Earth ellipsoid (m, default [WGS-84] 6378137)</p>
</td></tr>
<tr><td><code id="n_EA_E_and_p_AB_E2n_EB_E_+3A_f">f</code></td>
<td>
<p>Flattening of the Earth ellipsoid (no unit, default [WGS-84] 1/298.257223563)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is exact, taking the ellipticity of the Earth into account.
</p>
<p>It is also nonsingular as both n-vector and p-vector are nonsingular
(except for the center of the Earth).
The default ellipsoid model used is WGS-84, but other ellipsoids (or spheres) might be specified.
</p>


<h3>Value</h3>

<p>a list with n-vector of position B, decomposed in E (3x1 vector) (no unit) and
the depth of system B, relative to the ellipsoid (z_EB = -height)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_EA_E_and_n_EB_E2p_AB_E">n_EA_E_and_n_EB_E2p_AB_E</a></code>, <code><a href="#topic+p_EB_E2n_EB_E">p_EB_E2n_EB_E</a></code> and
<code><a href="#topic+n_EB_E2p_EB_E">n_EB_E2p_EB_E</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_BC_B &lt;- c(3000, 2000, 100)

# Position and orientation of B is given:
n_EB_E &lt;- unit(c(1,2,3))  # unit to get unit length of vector
z_EB &lt;- -400
R_NB  &lt;- zyx2R(rad(10), rad(20), rad(30)) # yaw, pitch, and roll
R_EN &lt;- n_E2R_EN(n_EB_E)
R_EB &lt;- R_EN %*% R_NB

# Decompose the delta vector in E:
p_BC_E &lt;- (R_EB %*% p_BC_B) %&gt;% as.vector() # no transpose of R_EB, since the vector is in B

# Find the position of C, using the functions that goes from one
# position and a delta, to a new position:
(n_EB_E &lt;- n_EA_E_and_p_AB_E2n_EB_E(n_EB_E, p_BC_E, z_EB))

</code></pre>

<hr>
<h2 id='n_EB_E2p_EB_E'>Convert n-vector to cartesian position vector in meters</h2><span id='topic+n_EB_E2p_EB_E'></span>

<h3>Description</h3>

<p>The function converts the position of B (typically body) relative to E (typically Earth),
the n-vector <code>n_EB_E</code> to cartesian position vector (&quot;ECEF-vector&quot;), <code>p_EB_E</code>,
in meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_EB_E2p_EB_E(n_EB_E, z_EB = 0, a = 6378137, f = 1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_EB_E2p_EB_E_+3A_n_eb_e">n_EB_E</code></td>
<td>
<p>n-vector of position B, decomposed in E (3x1 vector) (no unit)</p>
</td></tr>
<tr><td><code id="n_EB_E2p_EB_E_+3A_z_eb">z_EB</code></td>
<td>
<p>Depth of system B, relative to the ellipsoid (z_EB = -height) (m, default 0)</p>
</td></tr>
<tr><td><code id="n_EB_E2p_EB_E_+3A_a">a</code></td>
<td>
<p>Semi-major axis of the Earth ellipsoid (m, default [WGS-84] 6378137)</p>
</td></tr>
<tr><td><code id="n_EB_E2p_EB_E_+3A_f">f</code></td>
<td>
<p>Flattening of the Earth ellipsoid (no unit, default [WGS-84] 1/298.257223563)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The calculation is exact, taking the ellipticity of the Earth into account.
</p>
<p>It is also nonsingular as both n-vector and p-vector are nonsingular
(except for the center of the Earth).
The default ellipsoid model used is WGS-84, but other ellipsoids (or spheres) might be specified
via the optional parameters <code>a</code> and <code>f</code>.
</p>


<h3>Value</h3>

<p>Cartesian position vector from E to B, decomposed in E (3x1 vector) (m)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+p_EB_E2n_EB_E">p_EB_E2n_EB_E</a></code>, <code><a href="#topic+n_EA_E_and_p_AB_E2n_EB_E">n_EA_E_and_p_AB_E2n_EB_E</a></code> and
<code><a href="#topic+n_EA_E_and_n_EB_E2p_AB_E">n_EA_E_and_n_EB_E2p_AB_E</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_EB_E  &lt;- lat_lon2n_E(rad(1), rad(2))
n_EB_E2p_EB_E(n_EB_E)

</code></pre>

<hr>
<h2 id='nvctr'>nvctr: non-singular geographical position calculations</h2><span id='topic+nvctr'></span><span id='topic+nvctr-package'></span>

<h3>Description</h3>

<p>nvctr provides functions to calculate geographical
positions for  both the ellipsoidal and spherical Earth models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Enrico Spinielli <a href="mailto:enrico.spinielli@eurocontrol.int">enrico.spinielli@eurocontrol.int</a> (<a href="https://orcid.org/0000-0001-8584-9131">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> EUROCONTROL [copyright holder, funder]
</p>
</li></ul>



<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/euctrl-pru/nvctr">https://github.com/euctrl-pru/nvctr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/euctrl-pru/nvctr/issues">https://github.com/euctrl-pru/nvctr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='p_EB_E2n_EB_E'>Convert cartesian position vector in meters to n-vector</h2><span id='topic+p_EB_E2n_EB_E'></span>

<h3>Description</h3>

<p>The position of B (typically body) relative to E (typically Earth) is given
as cartesian position vector p_EB_E, in meters (&quot;ECEF-vector&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_EB_E2n_EB_E(p_EB_E, a = 6378137, f = 1/298.257223563)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_EB_E2n_EB_E_+3A_p_eb_e">p_EB_E</code></td>
<td>
<p>Cartesian position vector from E to B, decomposed in E (3x1 vector) (m)</p>
</td></tr>
<tr><td><code id="p_EB_E2n_EB_E_+3A_a">a</code></td>
<td>
<p>Semi-major axis of the Earth ellipsoid (m, default [WGS-84] 6378137)</p>
</td></tr>
<tr><td><code id="p_EB_E2n_EB_E_+3A_f">f</code></td>
<td>
<p>Flattening of the Earth ellipsoid (no unit, default [WGS-84] 1/298.257223563)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function converts to n-vector, n_EB_E and its depth, z_EB.
</p>
<p>The calculation is exact, taking the ellipticity of the Earth into account.
It is also nonsingular as both n-vector and p-vector are nonsingular
(except for the center of the Earth).
The default ellipsoid model used is WGS-84, but other ellipsoids (or spheres) might be specified.
</p>


<h3>Value</h3>

<p>n-vector representation of position B, decomposed in E (3x1 vector) (no unit) and
depth of system B relative to the ellipsoid (z_EB = -height)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_EB_E2p_EB_E">n_EB_E2p_EB_E</a></code>, <code><a href="#topic+n_EA_E_and_p_AB_E2n_EB_E">n_EA_E_and_p_AB_E2n_EB_E</a></code> and
<code><a href="#topic+n_EA_E_and_n_EB_E2p_AB_E">n_EA_E_and_n_EB_E2p_AB_E</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p_EB_E &lt;- 6371e3 * c(0.9, -1, 1.1)
(n_EB_E &lt;- p_EB_E2n_EB_E(p_EB_E))

</code></pre>

<hr>
<h2 id='R_Ee'>Select the axes of the coordinate frame E</h2><span id='topic+R_Ee'></span>

<h3>Description</h3>

<p>This function returns the axes of the coordinate frame E (Earth-Centered,
Earth-Fixed, ECEF).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_Ee(axes = "e")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_Ee_+3A_axes">axes</code></td>
<td>
<p>Either 'e' or 'E'
</p>

<ul>
<li><p> 'e': z-axis points to the North Pole along the Earth's rotation axis,
x-axis points towards the point where latitude = longitude = 0.
This choice is very common in many fields.
</p>
</li>
<li><p> 'E': x-axis points to the North Pole along the Earth's rotation axis,
y-axis points towards longitude +90deg (east) and latitude = 0.
(the yz-plane coincides with the equatorial plane).
This choice of axis ensures that at zero latitude and longitude,
frame N (North-East-Down) has the same orientation as frame E.
If roll/pitch/yaw are zero, also frame B (forward-starboard-down)
has this orientation. In this manner, the axes of frame E is
chosen to correspond with the axes of frame N and B.
The functions in this library originally used this option.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two choices of E-axes that are described in Table 2 in Gade (2010):
</p>

<ul>
<li> <p><code>e</code>: z-axis points to the North Pole and x-axis points to the point where
latitude = longitude = 0. This choice is very common in many fields.
</p>
</li>
<li> <p><code>E</code>: x-axis points to the North Pole, y-axis points towards longitude +90deg
(east) and latitude = 0. This choice of axis directions ensures
that at zero latitude and longitude, N (North-East-Down) has the
same orientation as E. If roll/pitch/yaw are zero, also B (Body,
forward, starboard, down) has this orientation. In this manner, the
axes of E is chosen to correspond with the axes of N and B.
</p>
</li></ul>



<h3>Value</h3>

<p>rotation matrix defining the axes of the coordinate frame E as
described in Table 2 in Gade (2010)
</p>


<h3>References</h3>

<p>Kenneth Gade (2010) <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R_Ee()

</code></pre>

<hr>
<h2 id='R_EL2n_E'>Find n-vector from the rotation matrix (direction cosine matrix) <code>R_EL</code></h2><span id='topic+R_EL2n_E'></span>

<h3>Description</h3>

<p>Find n-vector from the rotation matrix (direction cosine matrix) <code>R_EL</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_EL2n_E(R_EL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_EL2n_E_+3A_r_el">R_EL</code></td>
<td>
<p>Rotation matrix (direction cosine matrix) (no unit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n-vector decomposed in E (3x1 vector) (no unit)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_E2R_EN">n_E2R_EN</a></code>, <code><a href="#topic+R_EL2n_E">R_EL2n_E</a></code> and <code><a href="#topic+n_E_and_wa2R_EL">n_E_and_wa2R_EL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R_EL &lt;- matrix(
   c(-1, 0,  0,
      0, 1,  0,
      0, 0, -1),
   nrow = 3, ncol = 3, byrow = TRUE)
R_EL2n_E(R_EL)

</code></pre>

<hr>
<h2 id='R_EN2n_E'>Find n-vector from R_E</h2><span id='topic+R_EN2n_E'></span>

<h3>Description</h3>

<p>Find n-vector from R_E
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R_EN2n_E(R_EN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R_EN2n_E_+3A_r_en">R_EN</code></td>
<td>
<p>Rotation matrix (direction cosine matrix) (no unit)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n-vector decomposed in E (3x1 vector) (no unit)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+n_E2R_EN">n_E2R_EN</a></code>, <code><a href="#topic+R_EL2n_E">R_EL2n_E</a></code> and <code><a href="#topic+n_E_and_wa2R_EL">n_E_and_wa2R_EL</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R_EN &lt;- matrix(
   c(-1, 0,  0,
      0, 1,  0,
      0, 0, -1),
   nrow = 3, ncol = 3, byrow = TRUE)
R_EL2n_E(R_EN)

</code></pre>

<hr>
<h2 id='R2xyz'>Find the three rotation angles about new axes in the xyz order from a rotation matrix</h2><span id='topic+R2xyz'></span>

<h3>Description</h3>

<p>The angles (called Euler angles or Tait–Bryan angles) are defined by the
following procedure of successive rotations:
Given two arbitrary coordinate frames A and B, consider a temporary frame
T that initially coincides with A. In order to make T align with B, we
first rotate T an angle x about its x-axis (common axis for both A and T).
Secondly, T is rotated an angle y about the NEW y-axis of T. Finally, T
is rotated an angle z about its NEWEST z-axis. The final orientation of
T now coincides with the orientation of B.
The signs of the angles are given by the directions of the axes and the
right hand rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2xyz(R_AB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2xyz_+3A_r_ab">R_AB</code></td>
<td>
<p>a 3x3 rotation matrix (direction cosine matrix) such that the
relation between a vector v decomposed in A and B is
given by: v_A = R_AB * v_B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x,y,z 	Angles of rotation about new axes (rad)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xyz2R">xyz2R</a></code>, <code><a href="#topic+R2zyx">R2zyx</a></code> and <code><a href="#topic+zyx2R">zyx2R</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  R_AB &lt;- matrix(
     c( 0.9980212 ,  0.05230407, -0.0348995 ,
       -0.05293623,  0.99844556, -0.01744177,
        0.03393297,  0.01925471,  0.99923861),
     nrow = 3, ncol = 3, byrow = TRUE)
R2xyz(R_AB)

</code></pre>

<hr>
<h2 id='R2zyx'>Find the three angles about new axes in the zyx order from a rotation matrix</h2><span id='topic+R2zyx'></span>

<h3>Description</h3>

<p>The 3 angles <code>z</code>, <code>y</code>, <code>x</code> about new axes (intrinsic) in the order z-y-x are
found from the rotation matrix <code>R_AB</code>. The angles (called Euler angles or
Tait–Bryan angles) are defined by the following procedure of successive rotations:
</p>

<ol>
<li><p> Given two arbitrary coordinate frames A and B, consider a temporary frame
T that initially coincides with A. In order to make T align with B, we
first rotate T an angle z about its z-axis (common axis for both A and T).
</p>
</li>
<li><p> Secondly, T is rotated an angle y about the NEW y-axis of T. Finally, T
is rotated an angle x about its NEWEST x-axis.
</p>
</li>
<li><p> The final orientation of T now coincides with the orientation of B.
</p>
</li></ol>

<p>The signs of the angles are given by the directions of the axes and the right hand rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>R2zyx(R_AB)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="R2zyx_+3A_r_ab">R_AB</code></td>
<td>
<p>a 3x3 rotation matrix (direction cosine matrix) such that the
relation between a vector v decomposed in A and B is
given by: v_A = R_AB * v_B</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if A is a north-east-down frame and B is a body frame, we
have that z=yaw, y=pitch and x=roll.
</p>


<h3>Value</h3>

<p>z,y,x angles of rotation about new axes (rad)
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+zyx2R">zyx2R</a></code>, <code><a href="#topic+xyz2R">xyz2R</a></code> and <code><a href="#topic+R2xyz">R2xyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zyx2R(rad(1), rad(-2), rad(-3))

</code></pre>

<hr>
<h2 id='rad'>Convert angle in degrees to radians.</h2><span id='topic+rad'></span>

<h3>Description</h3>

<p>Convert angle in degrees to radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rad(degrees)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rad_+3A_degrees">degrees</code></td>
<td>
<p>angle in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>angle in radians
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg">deg</a></code>.
</p>
<p>Other helpers: 
<code><a href="#topic+deg">deg</a>()</code>,
<code><a href="#topic+unit">unit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rad(30)
</code></pre>

<hr>
<h2 id='unit'>Make input vector unit length, i.e. norm == 1</h2><span id='topic+unit'></span>

<h3>Description</h3>

<p>Make input vector unit length, i.e. norm == 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit(vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_+3A_vector">vector</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a unit length vector
</p>


<h3>See Also</h3>

<p>Other helpers: 
<code><a href="#topic+deg">deg</a>()</code>,
<code><a href="#topic+rad">rad</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unit(c(1,2,3))

</code></pre>

<hr>
<h2 id='xyz2R'>Create a rotation matrix from 3 angles about new axes in the xyz order.</h2><span id='topic+xyz2R'></span>

<h3>Description</h3>

<p>The rotation matrix <code>R_AB</code> is created based on 3 angles <code>x</code>, <code>y</code> and <code>z</code>
about new axes (intrinsic) in the order x-y-z.
The angles (called Euler angles or Tait-Bryan angles) are defined by the following
procedure of successive rotations:
</p>

<ol>
<li><p> Given two arbitrary coordinate frames <code>A</code> and <code>B</code>, consider a temporary frame
<code>T</code> that initially coincides with <code>A</code>.
In order to make <code>T</code> align with <code>B</code>, we first rotate <code>T</code>
an angle <code>x</code> about its x-axis (common axis for both <code>A</code> and <code>T</code>).
</p>
</li>
<li><p> Secondly, <code>T</code> is rotated an angle <code>y</code> about the NEW y-axis of <code>T</code>.
</p>
</li>
<li><p> Finally, codeT is rotated an angle <code>z</code> about its NEWEST z-axis.
The final orientation of <code>T</code> now coincides with the orientation of <code>B</code>.
</p>
</li></ol>

<p>The signs of the angles are given by the directions of the axes and the right hand rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2R(x, y, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2R_+3A_x">x</code></td>
<td>
<p>Angle of rotation about new x axis (rad)</p>
</td></tr>
<tr><td><code id="xyz2R_+3A_y">y</code></td>
<td>
<p>Angle of rotation about new y axis (rad)</p>
</td></tr>
<tr><td><code id="xyz2R_+3A_z">z</code></td>
<td>
<p>Angle of rotation about new z axis (rad)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3x3 rotation matrix (direction cosine matrix) such that the relation between
a vector v decomposed in A and B is given by: v_A = R_AB * v_B
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R2xyz">R2xyz</a></code>, <code><a href="#topic+zyx2R">zyx2R</a></code> and <code><a href="#topic+R2zyx">R2zyx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz2R(rad(10), rad(20), rad(30))

</code></pre>

<hr>
<h2 id='zyx2R'>Create a rotation matrix from 3 angles about new axes in the zyx order.</h2><span id='topic+zyx2R'></span>

<h3>Description</h3>

<p>The rotation matrix <code>R_AB</code> is created based on 3 angles <code>z</code>, <code>y</code> and <code>x</code>
about new axes (intrinsic) in the order z-y-x.
The angles (called Euler angles or Tait–Bryan angles) are defined by the following procedure
of successive rotations:
</p>

<ol>
<li><p> Given two arbitrary coordinate frames A and B, consider a temporary frame
T that initially coincides with A. In order to make T align with B, we
first rotate T an angle z about its z-axis (common axis for both A and T).
</p>
</li>
<li><p> Secondly, T is rotated an angle y about the NEW y-axis of T.
</p>
</li>
<li><p> Finally, T is rotated an angle x about its NEWEST x-axis.
The final orientation of T now coincides with the orientation of B.
</p>
</li></ol>

<p>The signs of the angles are given by the directions of the axes and the right hand rule.
Note that if A is a north-east-down frame and B is a body frame, we
have that z=yaw, y=pitch and x=roll.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zyx2R(z, y, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zyx2R_+3A_z">z</code></td>
<td>
<p>Angle of rotation about new z axis</p>
</td></tr>
<tr><td><code id="zyx2R_+3A_y">y</code></td>
<td>
<p>Angle of rotation about new y axis</p>
</td></tr>
<tr><td><code id="zyx2R_+3A_x">x</code></td>
<td>
<p>Angle of rotation about new x axis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3x3 rotation matrix R_AB (direction cosine matrix) such that the
relation between a vector v decomposed in A and B is
given by: v_A = R_AB * v_B
</p>


<h3>References</h3>

<p>Kenneth Gade <a href="https://www.navlab.net/Publications/A_Nonsingular_Horizontal_Position_Representation.pdf">A Nonsingular Horizontal Position Representation</a>.
<em>The Journal of Navigation</em>, Volume 63, Issue 03, pp 395-417, July 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+R2zyx">R2zyx</a></code>, <code><a href="#topic+xyz2R">xyz2R</a></code> and <code><a href="#topic+R2xyz">R2xyz</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zyx2R(rad(30), rad(20), rad(10))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
