<!DOCTYPE html><html lang="en"><head><title>Help for package rater</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rater}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rater-package'><p>The 'rater' package.</p></a></li>
<li><a href='#anesthesia'><p>Anaesthetist ratings for patient suitability for surgery</p></a></li>
<li><a href='#as_mcmc.list'><p>Convert a rater_fit object to a coda <code>mcmc.list</code> object.</p></a></li>
<li><a href='#caries'><p>Dentist ratings of whether caries are healthy or not based on X-rays</p></a></li>
<li><a href='#class_probabilities'><p>Extract latent class probabilities from a rater fit object</p></a></li>
<li><a href='#get_stanfit'><p>Get the underlying <code>stanfit</code> object from a <code>rater_fit</code> object.</p></a></li>
<li><a href='#loo.rater_fit'><p>Compute the PSIS LOO CV - a measure of model fit - of a rater fit object.</p></a></li>
<li><a href='#make_complete_rating_design_sim_data'><p>Produce simulation data from a 'complete' rating design</p></a></li>
<li><a href='#make_theta'><p>Make a theta parameter</p></a></li>
<li><a href='#mcmc_diagnostics'><p>Retrieve MCMC convergence diagnostics for a rater fit</p></a></li>
<li><a href='#models'><p>Probabilistic models of repeated categorical rating</p></a></li>
<li><a href='#plot.rater_fit'><p>Plot a <code>rater_fit</code> object</p></a></li>
<li><a href='#point_estimate'><p>Extract point estimates of parameters from a fit object</p></a></li>
<li><a href='#posterior_interval.mcmc_fit'><p>Extract posterior intervals for parameters of the model</p></a></li>
<li><a href='#posterior_interval.optim_fit'><p>Extract posterior intervals for parameters of the model</p></a></li>
<li><a href='#posterior_predict.rater_fit'><p>Draw from the posterior predictive distribution</p></a></li>
<li><a href='#posterior_samples'><p>Extract posterior samples from a rater fit object</p></a></li>
<li><a href='#print.mcmc_fit'><p>Print a <code>mcmc_fit</code> object</p></a></li>
<li><a href='#print.optim_fit'><p>Print a <code>optim_fit</code> object</p></a></li>
<li><a href='#print.rater_model'><p>Print a <code>rater_model</code> object.</p></a></li>
<li><a href='#prior_summary.rater_fit'><p>Provide a summary of the priors specified in a <code>rater_fit</code> object.</p></a></li>
<li><a href='#rater'><p>Fit statistical models to repeated categorical rating data using Stan</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#simulate_dawid_skene_model'><p>Simulate data from the Dawid-Skene model</p></a></li>
<li><a href='#simulate_hier_dawid_skene_model'><p>Simulate data from the hierarchical Dawid-Skene model</p></a></li>
<li><a href='#summary.mcmc_fit'><p>Summarise a <code>mcmc_fit</code> object</p></a></li>
<li><a href='#summary.optim_fit'><p>Summarise an <code>optim_fit</code> object</p></a></li>
<li><a href='#summary.rater_model'><p>Summarise a <code>rater_model</code>.</p></a></li>
<li><a href='#waic.rater_fit'><p>Compute the WAIC - a measure of model fit - of a rater fit object.</p></a></li>
<li><a href='#wide_to_long'><p>Convert wide data to the long format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Statistical Models of Repeated Categorical Rating Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit statistical models based on the Dawid-Skene model - Dawid
    and Skene (1979) &lt;<a href="https://doi.org/10.2307%2F2346806">doi:10.2307/2346806</a>&gt; - to repeated categorical
    rating data.  Full Bayesian inference for these models is supported
    through the Stan modelling language. 'rater' also allows the user to
    extract and plot key parameters of these models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jeffreypullin.github.io/rater/">https://jeffreypullin.github.io/rater/</a>,
<a href="https://github.com/jeffreypullin/rater">https://github.com/jeffreypullin/rater</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jeffreypullin/rater/issues">https://github.com/jeffreypullin/rater/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.2.1), loo (&gt; 2.0.0), methods, Rcpp (&ge; 0.12.0),
RcppParallel (&ge; 5.0.1), rlang (&gt; 0.2.0), rstan (&ge; 2.26.0),
rstantools (&ge; 2.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>coda, covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>BH (&ge; 1.66.0), Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0),
RcppParallel (&ge; 5.0.1), rstan (&ge; 2.26.0), StanHeaders (&ge;
2.26.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-11 15:55:24 UTC; jeffreypullin</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeffrey Pullin <a href="https://orcid.org/0000-0003-3651-5471"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Damjan Vukcevic <a href="https://orcid.org/0000-0001-7780-9586"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lars MÃ¸lgaard Saxhaug
    <a href="https://orcid.org/0000-0001-5084-1578"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jeffrey Pullin &lt;jeffrey.pullin@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-11 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rater-package'>The 'rater' package.</h2><span id='topic+rater-package'></span>

<h3>Description</h3>

<p>Fit statistical models based on the Dawid-Skene model to repeated
categorical rating data. Full Bayesian inference for these models is
supported through the Stan modelling language. rater also allows the user to
extract and plot key parameters of these models.
</p>


<h3>References</h3>

<p>Stan Development Team (2018). RStan: the R interface to Stan. R package version 2.18.2. http://mc-stan.org
</p>

<hr>
<h2 id='anesthesia'>Anaesthetist ratings for patient suitability for surgery</h2><span id='topic+anesthesia'></span>

<h3>Description</h3>

<p>The data consist of ratings, on a 4-point scale, made by five anaesthetists
of patients' pre-operative health. The ratings were based on the
anaesthetists assessments of a standard form completed for all of the
patients. There are 45 patients (items) and five anaesthetists (raters) in
total. The first anaesthetist assessed the forms a total of three times,
spaced several weeks apart. The other anaesthetists each assessed the forms
once. The data is in 'long' format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anesthesia
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 315 rows and 3 columns:
</p>

<dl>
<dt>item</dt><dd><p>The item index - which item is being rated</p>
</dd>
<dt>rater</dt><dd><p>The rater index - which rater is doing the rating</p>
</dd>
<dt>rating</dt><dd><p>The rating given</p>
</dd>
</dl>



<h3>References</h3>

<p>Dawid, A. P., and A. M. Skene. &quot;Maximum Likelihood Estimation of Observer
Error-Rates Using the EM Algorithm.&quot; Applied Statistics 28, no. 1 (1979): 20.
</p>

<hr>
<h2 id='as_mcmc.list'>Convert a rater_fit object to a coda <code>mcmc.list</code> object.</h2><span id='topic+as_mcmc.list'></span>

<h3>Description</h3>

<p>Convert a rater_fit object to a coda <code>mcmc.list</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_mcmc.list(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_mcmc.list_+3A_fit">fit</code></td>
<td>
<p>A rater_fit object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A coda mcmc.list object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit a model using MCMC (the default).
mcmc_fit &lt;- rater(anesthesia, "dawid_skene")

# Convert it to an mcmc.list
rater_mcmc_list &lt;- as_mcmc.list(mcmc_fit)



</code></pre>

<hr>
<h2 id='caries'>Dentist ratings of whether caries are healthy or not based on X-rays</h2><span id='topic+caries'></span>

<h3>Description</h3>

<p>It consists of binary ratings, made by 5 dentists, of whether a given tooth
was healthy (sound) or had caries, also known as cavities. The ratings were
performed using X-ray only, which was thought to be more error-prone than
visual/tactile assessment of each tooth. In total 3,689 ratings were made.
This data is in 'grouped' format. Each row is one of the 'pattern' with
the final columns being a tally of how many times that pattern occurs in
the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caries
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 6 columns and 32 rows.
</p>

<dl>
<dt>rater_1</dt><dd><p>The rating of the dentist 1</p>
</dd>
<dt>rater_2</dt><dd><p>The rating of the dentist 2</p>
</dd>
<dt>rater_3</dt><dd><p>The rating of the dentist 3</p>
</dd>
<dt>rater_4</dt><dd><p>The rating of the dentist 4</p>
</dd>
<dt>rater_5</dt><dd><p>The rating of the dentist 5</p>
</dd>
<dt>n</dt><dd><p>The number of times the rating pattern appears in the dataset</p>
</dd>
</dl>



<h3>References</h3>

<p>Espeland, Mark A., and Stanley L. Handelman. âUsing Latent Class Models to
Characterize and Assess Relative Error in Discrete Measurements.â
Biometrics 45, no. 2 (1989): 587â99.
</p>

<hr>
<h2 id='class_probabilities'>Extract latent class probabilities from a rater fit object</h2><span id='topic+class_probabilities'></span><span id='topic+class_probabilities.mcmc_fit'></span><span id='topic+class_probabilities.optim_fit'></span>

<h3>Description</h3>

<p>Extract latent class probabilities from a rater fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>class_probabilities(fit, ...)

## S3 method for class 'mcmc_fit'
class_probabilities(fit, ...)

## S3 method for class 'optim_fit'
class_probabilities(fit, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="class_probabilities_+3A_fit">fit</code></td>
<td>
<p>A rater fit object.</p>
</td></tr>
<tr><td><code id="class_probabilities_+3A_...">...</code></td>
<td>
<p>Extra arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The latent class probabilities are obtained by marginalising out
the latent class and then calculating, for each draw of pi and theta, the
conditional probability of the latent class given the other parameters
and the data. Averaging these conditional probabilities gives the
(unconditional) latent class probabilities retuned by this function.
</p>


<h3>Value</h3>

<p>A I * K matrix where each element is the probably of item i being
of class k. (I is the number of items and K the number of classes).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene")
class_probabilities(fit)



</code></pre>

<hr>
<h2 id='get_stanfit'>Get the underlying <code>stanfit</code> object from a <code>rater_fit</code> object.</h2><span id='topic+get_stanfit'></span>

<h3>Description</h3>

<p>Get the underlying <code>stanfit</code> object from a <code>rater_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_stanfit(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_stanfit_+3A_fit">fit</code></td>
<td>
<p>A <code>rater_fit</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>stanfit</code> object from rstan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE)

stan_fit &lt;- get_stanfit(fit)
stan_fit



</code></pre>

<hr>
<h2 id='loo.rater_fit'>Compute the PSIS LOO CV - a measure of model fit - of a rater fit object.</h2><span id='topic+loo.rater_fit'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>Compute the PSIS LOO CV - a measure of model fit - of a rater fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_fit'
loo(x, ..., cores = getOption("mc.cores", 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo.rater_fit_+3A_x">x</code></td>
<td>
<p>A <code>rater_fit</code> object. All model types are currently supported
except the basic Dawid-Skene model fit with grouped data.</p>
</td></tr>
<tr><td><code id="loo.rater_fit_+3A_...">...</code></td>
<td>
<p>Other arguments passed.</p>
</td></tr>
<tr><td><code id="loo.rater_fit_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use when calling the underlying
functions. By default the value of the <code>mc.cores</code> option.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is somewhat experimental; model comparison is always
difficult and choosing between variants of the Dawid-Skene model should
be largely guided by considerations of data size and what is known about
the characteristics of the raters. loo is, however, one of the leading
methods for Bayesian model comparison and should provide a helpful guide
in many situations.
</p>
<p>When calculating loo we always use the relative effective
sample size, calculated using <code>loo::relaive_eff</code> to improve the estimates
of the PSIS effective sample sizes and Monte Carlo error.
</p>
<p>For further information about the details of loo and PSIS please consult
the provided references.
</p>


<h3>Value</h3>

<p>A loo object.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017a). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432. doi:10.1007/s11222-016-9696-4
(<a href="https://link.springer.com/article/10.1007/s11222-016-9696-4">journal version</a>,
<a href="https://arxiv.org/abs/1507.04544">preprint arXiv:1507.04544</a>).
</p>
<p>Vehtari, A., Simpson, D., Gelman, A., Yao, Y., and Gabry, J. (2019).
Pareto smoothed importance sampling.
<a href="https://arxiv.org/abs/1507.02646">preprint arXiv:1507.02646</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit_ds &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE, chains = 1)
fit_ccds &lt;- rater(anesthesia, "class_conditional_dawid_skene",
                  verbose = FALSE, chains = 1)

loo_ds &lt;- loo(fit_ds)
loo_ccds &lt;- loo(fit_ccds)

# To compare the loos easily we can use the loo_compare function from the
# loo package:
library(loo)

loo_compare(loo_ds, loo_ccds)

# The documentation of the loo package contains more information about how
# the output should be interpreted.


</code></pre>

<hr>
<h2 id='make_complete_rating_design_sim_data'>Produce simulation data from a 'complete' rating design</h2><span id='topic+make_complete_rating_design_sim_data'></span>

<h3>Description</h3>

<p>Produce simulation data from a 'complete' rating design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_complete_rating_design_sim_data(I, J, N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_complete_rating_design_sim_data_+3A_i">I</code></td>
<td>
<p>The number of items.</p>
</td></tr>
<tr><td><code id="make_complete_rating_design_sim_data_+3A_j">J</code></td>
<td>
<p>The number of raters.</p>
</td></tr>
<tr><td><code id="make_complete_rating_design_sim_data_+3A_n">N</code></td>
<td>
<p>The number of times each rater rates each item.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A 'complete' rating design is situation where every rater rates
each item the same number of times. In this function the number of times
each rater rates each item is <code>N</code>.
</p>


<h3>Value</h3>

<p>Simulation data in the format required by
<code><a href="#topic+simulate_dawid_skene_model">simulate_dawid_skene_model()</a></code> or <code><a href="#topic+simulate_hier_dawid_skene_model">simulate_hier_dawid_skene_model()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_complete_rating_design_sim_data(100, 5, 2)

</code></pre>

<hr>
<h2 id='make_theta'>Make a theta parameter</h2><span id='topic+make_theta'></span>

<h3>Description</h3>

<p>Make a theta parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_theta(diag_values, J, K)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="make_theta_+3A_diag_values">diag_values</code></td>
<td>
<p>The diagonal entries of each error matrix.</p>
</td></tr>
<tr><td><code id="make_theta_+3A_j">J</code></td>
<td>
<p>The number of raters (The umber matrices in 3D array).</p>
</td></tr>
<tr><td><code id="make_theta_+3A_k">K</code></td>
<td>
<p>The number of latent classes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>diag_values</code> argument can either be a numeric vector of length
1 or J. If it is length J, the jth element is the diagonal values of the
error matrix for the jth rater. If it is length 1 all raters have the same
diagonal values.
</p>


<h3>Value</h3>

<p>A c(J, K, K) array; the theta parameter
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
theta &lt;- make_theta(0.7, 5, 4)
theta[1, , ]

</code></pre>

<hr>
<h2 id='mcmc_diagnostics'>Retrieve MCMC convergence diagnostics for a rater fit</h2><span id='topic+mcmc_diagnostics'></span>

<h3>Description</h3>

<p>Retrieve MCMC convergence diagnostics for a rater fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_diagnostics(fit, pars = c("pi", "theta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_diagnostics_+3A_fit">fit</code></td>
<td>
<p>An rater <code>mcmc_fit</code> object.</p>
</td></tr>
<tr><td><code id="mcmc_diagnostics_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names to return. By default
<code>c("pi", "theta")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MCMC diagnostics cannot be calculate for the z due to the
marginalisation used to fit the models.
</p>
<p>These MCMC diagnostics are intended as basic sanity check of the quality
of the MCMC samples returned. Users who want more in depth diagnostics
should consider using <code><a href="#topic+as_mcmc.list">as_mcmc.list()</a></code> to convert the samples to a
<code><a href="coda.html#topic+mcmc.list">coda::mcmc.list()</a></code> object, or <code><a href="#topic+get_stanfit">get_stanfit()</a></code> to extract the underlying
stanfit object.
</p>


<h3>Value</h3>

<p>A matrix where the columns represent different diagnostics and the
rows are different parameters. Currently the first column contains
the Rhat statistic and the second bulk effective samples size. The
rownames contain the parameter names.
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian BÃ¼rkner (2019). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of
MCMC. <em>arXiv preprint</em> <code>arXiv:1903.08008</code>.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+Rhat">rstan::Rhat()</a></code>, <code><a href="rstan.html#topic+Rhat">rstan::ess_bulk()</a></code> <code><a href="#topic+as_mcmc.list">as_mcmc.list()</a></code>,
<code><a href="#topic+get_stanfit">get_stanfit()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene")

# Calculate the diagnostics for all parameters.
mcmc_diagnostics(fit)

# Calculate the diagnostics just for the pi parameter.
mcmc_diagnostics(fit, pars = "pi")



</code></pre>

<hr>
<h2 id='models'>Probabilistic models of repeated categorical rating</h2><span id='topic+models'></span><span id='topic+dawid_skene'></span><span id='topic+hier_dawid_skene'></span><span id='topic+class_conditional_dawid_skene'></span>

<h3>Description</h3>

<p>Functions to set up models and change their prior
parameters for use in <code><a href="#topic+rater">rater()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dawid_skene(alpha = NULL, beta = NULL)

hier_dawid_skene(alpha = NULL)

class_conditional_dawid_skene(alpha = NULL, beta_1 = NULL, beta_2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="models_+3A_alpha">alpha</code></td>
<td>
<p>prior parameter for pi</p>
</td></tr>
<tr><td><code id="models_+3A_beta">beta</code></td>
<td>
<p>prior parameter for theta. This can either be a K * K matrix, in
which case it is interpreted as the prior parameter of all of the J
raters, or a J by K by K array in which case it is the fully specified
prior parameter for all raters. (Here K is the number of categories in the
data and J is the number of raters in the data.)</p>
</td></tr>
<tr><td><code id="models_+3A_beta_1">beta_1</code></td>
<td>
<p>First on diagonal prior probability parameter</p>
</td></tr>
<tr><td><code id="models_+3A_beta_2">beta_2</code></td>
<td>
<p>Second on diagonal prior probability parameter for theta</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rater model object that can be passed to <code><a href="#topic+rater">rater()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Model with default prior parameters:
default_m &lt;- dawid_skene()

# Changing alpha:
set_alpha_m &lt;- dawid_skene(alpha = c(2, 2, 2))

# Changing beta, single matrix:
# (See details for how this is interpreted.)
beta_mat &lt;- matrix(1, nrow = 4, ncol = 4)
diag(beta_mat) &lt;- 4
beta_mat_m &lt;- dawid_skene()

# The above is equivalent (when the model is fit - see details) to:
beta_array &lt;- array(NA, dim = c(2, 4, 4))
for (i in 1:2) {
  beta_array[i, , ] &lt;- beta_mat
}
beta_array_m &lt;- dawid_skene(beta = beta_array)

# But you can also specify an array where each slice is different.
# (Again, see details for how this is interpreted.)
beta_array[1, , ] &lt;- matrix(1, nrow = 4, ncol = 4)
beta_array_m &lt;- dawid_skene(beta = beta_array)

# Default:
hier_dawid_skene()

# Changing alpha
hier_dawid_skene(alpha = c(2, 2))

# Default:
class_conditional_dawid_skene()

# Not default:
class_conditional_dawid_skene(
  alpha = c(2, 2),
  beta_1 = c(4, 4),
  beta_2 = c(2, 2)
)

</code></pre>

<hr>
<h2 id='plot.rater_fit'>Plot a <code>rater_fit</code> object</h2><span id='topic+plot.rater_fit'></span>

<h3>Description</h3>

<p>Plot a <code>rater_fit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_fit'
plot(
  x,
  pars = "theta",
  prob = 0.9,
  rater_index = NULL,
  item_index = NULL,
  theta_plot_type = "matrix",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rater_fit_+3A_x">x</code></td>
<td>
<p>An object of class <code>rater_fit</code>.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_pars">pars</code></td>
<td>
<p>A length one character vector specifying the parameter to plot.
By default <code>"theta"</code>.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_prob">prob</code></td>
<td>
<p>The coverage of the credible intervals shown in the <code>"pi"</code> plot.
If not plotting pi this argument will be ignored. By default <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_rater_index">rater_index</code></td>
<td>
<p>The indexes of the raters shown in the <code style="white-space: pre;">&#8288;"theta&#8288;</code> plot.
If not plotting theta this argument will be ignored. By default <code>NULL</code>
which means that all raters will be plotted.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_item_index">item_index</code></td>
<td>
<p>The indexes of the items shown in the class probabilities
plot. If not plotting the class probabilities this argument will be
ignored. By default <code>NULL</code> which means that all items will be plotted.
This argument is particularly useful to focus the subset of items with
substantial uncertainty in their class assignments.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_theta_plot_type">theta_plot_type</code></td>
<td>
<p>The type of plot of the &quot;theta&quot; parameter. Can be
either <code>"matrix"</code> or <code>"points"</code>. If <code>"matrix"</code> (the default) the plot
will show the point estimates of the individual rater error matrices,
visualised as tile plots. If <code>"points"</code>, the elements of the theta
parameter will be displayed as points, with associated credible intervals.
Overall, the <code>"matrix"</code> type is likely more intuitive, but the <code>"points"</code>
type can also visualise the uncertainty in the parameter estimates.</p>
</td></tr>
<tr><td><code id="plot.rater_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The use of <code>pars</code> to refer to only one parameter is for backwards
compatibility and consistency with the rest of the interface.
</p>


<h3>Value</h3>

<p>A ggplot2 object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene")

# By default will just plot the theta plot
plot(fit)

# Select which parameter to plot.
plot(fit, pars = "pi")

# Plot the theta parameter for rater 1, showing uncertainty.
plot(fit, pars = "theta", theta_plot_type = "points", rater_index = 1)



</code></pre>

<hr>
<h2 id='point_estimate'>Extract point estimates of parameters from a fit object</h2><span id='topic+point_estimate'></span>

<h3>Description</h3>

<p>Extract point estimates of parameters from a fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>point_estimate(fit, pars = c("pi", "theta", "z"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="point_estimate_+3A_fit">fit</code></td>
<td>
<p>A rater fit object</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names to return. By default
<code>c("pi", "theta", "z")</code>.</p>
</td></tr>
<tr><td><code id="point_estimate_+3A_...">...</code></td>
<td>
<p>Extra arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the passed fit object was fit using MCMC then the posterior
means are returned. If it was fit through optimisation the maximum a
priori (MAP) estimates are returned. The z parameter returned is the
value of class probabilities which is largest. To return the full
posterior distributions of the latent class use <code>class_probabilities()</code>.
</p>
<p>For the class conditional model the 'full' theta parameterisation (i.e.
appearing to have the same number of parameters as the standard
Dawid-Skene model) is calculated and returned. This is designed to allow
easier comparison with the full Dawid-Skene model.
</p>


<h3>Value</h3>

<p>A named list of the parameter estimates.
</p>


<h3>See Also</h3>

<p><code>class_probabilities()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# A model fit using MCMC.
mcmc_fit &lt;- rater(anesthesia, "dawid_skene")

# This will return the posterior mean (except for z)
post_mean_estimate &lt;- point_estimate(mcmc_fit)

# A model fit using optimisation.
optim_fit &lt;- rater(anesthesia, dawid_skene(), method = "optim")

# This will output MAP estimates of the parameters.
map_estimate &lt;- point_estimate(optim_fit)



</code></pre>

<hr>
<h2 id='posterior_interval.mcmc_fit'>Extract posterior intervals for parameters of the model</h2><span id='topic+posterior_interval.mcmc_fit'></span><span id='topic+posterior_interval'></span>

<h3>Description</h3>

<p>Extract posterior intervals for parameters of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc_fit'
posterior_interval(object, prob = 0.9, pars = c("pi", "theta"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_interval.mcmc_fit_+3A_object">object</code></td>
<td>
<p>A rater <code>mcmc_fit</code> object.</p>
</td></tr>
<tr><td><code id="posterior_interval.mcmc_fit_+3A_prob">prob</code></td>
<td>
<p>A single probability. The size of the credible interval
returned. By default <code>0.9</code>.</p>
</td></tr>
<tr><td><code id="posterior_interval.mcmc_fit_+3A_pars">pars</code></td>
<td>
<p>The parameters to calculate the intervals for</p>
</td></tr>
<tr><td><code id="posterior_interval.mcmc_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior intervals can only be calculated for models fit with
MCMC. In addition, posterior intervals are not meaningful for the latent
class (and indeed cannot be calculated). The <em>full</em> posterior distribution
of the latent class can be extracted using <a href="#topic+class_probabilities">class_probabilities</a>
</p>
<p>For the class conditional model the 'full' theta parameterisation (i.e.
appearing to have the same number of parameters as the standard
Dawid-Skene model) is calculated and returned. This is designed to allow
easier comparison with the full Dawid-Skene model.
</p>


<h3>Value</h3>

<p>A matrix with 2 columns. The first column is the lower bound of
of the credible interval and the second is the upper bound. Each row
corresponds to one individuals parameters. The rownames are the parameter
names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE, chains = 1)

intervals &lt;- posterior_interval(fit)
head(intervals)



</code></pre>

<hr>
<h2 id='posterior_interval.optim_fit'>Extract posterior intervals for parameters of the model</h2><span id='topic+posterior_interval.optim_fit'></span>

<h3>Description</h3>

<p>Extract posterior intervals for parameters of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optim_fit'
posterior_interval(object, prob = 0.9, pars = c("pi", "theta"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_interval.optim_fit_+3A_object">object</code></td>
<td>
<p>A rater optim_fit object</p>
</td></tr>
<tr><td><code id="posterior_interval.optim_fit_+3A_prob">prob</code></td>
<td>
<p>A probability</p>
</td></tr>
<tr><td><code id="posterior_interval.optim_fit_+3A_pars">pars</code></td>
<td>
<p>The parameters to calculate the intervals for</p>
</td></tr>
<tr><td><code id="posterior_interval.optim_fit_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>

<hr>
<h2 id='posterior_predict.rater_fit'>Draw from the posterior predictive distribution</h2><span id='topic+posterior_predict.rater_fit'></span><span id='topic+posterior_predict'></span>

<h3>Description</h3>

<p>Draw from the posterior predictive distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_fit'
posterior_predict(object, new_data, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_predict.rater_fit_+3A_object">object</code></td>
<td>
<p>A <code>rater_fit</code> object.</p>
</td></tr>
<tr><td><code id="posterior_predict.rater_fit_+3A_new_data">new_data</code></td>
<td>
<p>New data for the model to be fit to. The must be in the form
used in <code>rater()</code> except without the 'rating' column.</p>
</td></tr>
<tr><td><code id="posterior_predict.rater_fit_+3A_seed">seed</code></td>
<td>
<p>An optional random seed to use.</p>
</td></tr>
<tr><td><code id="posterior_predict.rater_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of raters implied by the entries in the rater column
must match the number of raters in the fitted model.
</p>


<h3>Value</h3>

<p>The passed <code>new_data</code> augmented with a column 'z' containing the
latent class of each item and 'rating' containing the simulated rating.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE)
new_data &lt;- data.frame(item = rep(1:2, each = 5), rater = rep(1:5, 2))

predictions &lt;- posterior_predict(fit, new_data)
predictions



</code></pre>

<hr>
<h2 id='posterior_samples'>Extract posterior samples from a rater fit object</h2><span id='topic+posterior_samples'></span>

<h3>Description</h3>

<p>Extract posterior samples from a rater fit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posterior_samples(fit, pars = c("pi", "theta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_samples_+3A_fit">fit</code></td>
<td>
<p>A rater fit object.</p>
</td></tr>
<tr><td><code id="posterior_samples_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names to return. By default
<code>c("pi", "theta")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior samples can only be returned for models fitting using
MCMC not optimisation. In addition, posterior samples cannot be returned
for the latent class due to the marginalisation technique used internally.
</p>
<p>For the class conditional model the 'full' theta parameterisation (i.e.
appearing to have the same number of parameters as the standard
Dawid-Skene model) is calculated and returned. This is designed to allow
easier comparison with the full Dawid-Skene model.
</p>


<h3>Value</h3>

<p>A named list of the posterior samples for each parameters. For each
parameter the samples are in the form returned by <code><a href="rstan.html#topic+stanfit-method-extract">rstan::extract()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene")

samples &lt;- posterior_samples(fit)

# Look at first 6 samples for each of the pi parameters
head(samples$pi)

# Look at the first 6 samples for the theta[1, 1, 1] parameter
head(samples$theta[, 1, 1, 1])

# Only get the samples for the pi parameter:
pi_samples &lt;- posterior_samples(fit, pars = "pi")



</code></pre>

<hr>
<h2 id='print.mcmc_fit'>Print a <code>mcmc_fit</code> object</h2><span id='topic+print.mcmc_fit'></span>

<h3>Description</h3>

<p>Print a <code>mcmc_fit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mcmc_fit_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcmc_fit</code>.</p>
</td></tr>
<tr><td><code id="print.mcmc_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

# Suppress sampling output.
mcmc_fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE)
print(mcmc_fit)



</code></pre>

<hr>
<h2 id='print.optim_fit'>Print a <code>optim_fit</code> object</h2><span id='topic+print.optim_fit'></span>

<h3>Description</h3>

<p>Print a <code>optim_fit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optim_fit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.optim_fit_+3A_x">x</code></td>
<td>
<p>An object of class <code>optim_fit</code>.</p>
</td></tr>
<tr><td><code id="print.optim_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

optim_fit &lt;- rater(anesthesia, "dawid_skene", method = "optim")
print(optim_fit)



</code></pre>

<hr>
<h2 id='print.rater_model'>Print a <code>rater_model</code> object.</h2><span id='topic+print.rater_model'></span>

<h3>Description</h3>

<p>Print a <code>rater_model</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rater_model_+3A_x">x</code></td>
<td>
<p>A <code>rater_model</code> object.</p>
</td></tr>
<tr><td><code id="print.rater_model_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- dawid_skene()
print(mod)

</code></pre>

<hr>
<h2 id='prior_summary.rater_fit'>Provide a summary of the priors specified in a <code>rater_fit</code> object.</h2><span id='topic+prior_summary.rater_fit'></span><span id='topic+prior_summary'></span>

<h3>Description</h3>

<p>Provide a summary of the priors specified in a <code>rater_fit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_fit'
prior_summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prior_summary.rater_fit_+3A_object">object</code></td>
<td>
<p>A <code>rater_fit</code> object.</p>
</td></tr>
<tr><td><code id="prior_summary.rater_fit_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit a model using MCMC (the default).
fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE)

# Summarise the priors (and model) specified in the fit.
prior_summary(fit)



</code></pre>

<hr>
<h2 id='rater'>Fit statistical models to repeated categorical rating data using Stan</h2><span id='topic+rater'></span>

<h3>Description</h3>

<p>This functions allows the user to fit statistical models of noisy
categorical rating, based on the Dawid-Skene model, using Bayesian
inference. A variety of data formats and models are supported. Inference
is done using Stan, allowing models to be fit efficiently, using both
optimisation and Markov Chain Monte Carlo (MCMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rater(
  data,
  model,
  method = "mcmc",
  data_format = "long",
  long_data_colnames = c(item = "item", rater = "rater", rating = "rating"),
  inits = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rater_+3A_data">data</code></td>
<td>
<p>A 2D data object: data.frame, matrix, tibble etc. with data in
either long or grouped format.</p>
</td></tr>
<tr><td><code id="rater_+3A_model">model</code></td>
<td>
<p>Model to fit to data - must be rater_model or a character
string - the name of the model. If the character string is used, the
prior parameters will be set to their default values.</p>
</td></tr>
<tr><td><code id="rater_+3A_method">method</code></td>
<td>
<p>A length 1 character vector, either <code>"mcmc"</code> or <code>"optim"</code>.
This will be fitting method used by Stan. By default <code>"mcmc"</code></p>
</td></tr>
<tr><td><code id="rater_+3A_data_format">data_format</code></td>
<td>
<p>A length 1 character vector, <code>"long"</code>, <code>"wide"</code> and
<code>"grouped"</code>. The format that the passed data is in. Defaults to <code>"long"</code>.
See <code style="white-space: pre;">&#8288;vignette("data-formats)&#8288;</code> for details.</p>
</td></tr>
<tr><td><code id="rater_+3A_long_data_colnames">long_data_colnames</code></td>
<td>
<p>A 3-element named character vector that specifies
the names of the three required columns in the long data format. The vector
must have the required names:
* item: the name of the column containing the item indexes,
* rater: the name of the column containing the rater indexes,
* rating: the name of the column containing the ratings.
By default, the names of the columns are the same as the names of the
vector: <code>"item"</code>, <code>"rater"</code>, and <code>"rating"</code> respectively. This argument is
ignored when the <code>data_format</code> argument is either <code>"wide"</code> or <code>"grouped"</code>.</p>
</td></tr>
<tr><td><code id="rater_+3A_inits">inits</code></td>
<td>
<p>The initialization points of the fitting algorithm</p>
</td></tr>
<tr><td><code id="rater_+3A_verbose">verbose</code></td>
<td>
<p>Should <code>rater()</code> produce information about the progress
of the chains while using the MCMC algorithm. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="rater_+3A_...">...</code></td>
<td>
<p>Extra parameters which are passed to the Stan fitting interface.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default MCMC algorithm used by Stan is No U Turn Sampling
(NUTS) and the default optimisation method is LGFGS. For MCMC 4 chains
are run be default with 2000 iterations in total each.
</p>


<h3>Value</h3>

<p>An object of class rater_fit containing the fitted parameters.
</p>


<h3>See Also</h3>

<p><code><a href="rstan.html#topic+stanmodel-method-sampling">rstan::sampling()</a></code>, <code><a href="rstan.html#topic+stanmodel-method-optimizing">rstan::optimizing()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Fit a model using MCMC (the default).
mcmc_fit &lt;- rater(anesthesia, "dawid_skene")

# Fit a model using optimisation.
optim_fit &lt;- rater(anesthesia, dawid_skene(), method = "optim")

# Fit a model using passing data grouped data.
grouped_fit &lt;- rater(caries, dawid_skene(), data_format = "grouped")



</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+loo_compare'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>loo</dt><dd><p><code><a href="loo.html#topic+loo_compare">loo_compare</a></code></p>
</dd>
</dl>

<hr>
<h2 id='simulate_dawid_skene_model'>Simulate data from the Dawid-Skene model</h2><span id='topic+simulate_dawid_skene_model'></span>

<h3>Description</h3>

<p>Simulate data from the Dawid-Skene model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_dawid_skene_model(pi, theta, sim_data, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_dawid_skene_model_+3A_pi">pi</code></td>
<td>
<p>The pi parameter of the Dawid-Skene model.</p>
</td></tr>
<tr><td><code id="simulate_dawid_skene_model_+3A_theta">theta</code></td>
<td>
<p>The theta parameter of the Dawid-Skene model.</p>
</td></tr>
<tr><td><code id="simulate_dawid_skene_model_+3A_sim_data">sim_data</code></td>
<td>
<p>Data to guide the simulation. The data must be in the long
data format used in <code>rater()</code> except without the 'rating' column. The data
specifies:
</p>

<ul>
<li><p> the number of items in the data, and
</p>
</li>
<li><p> which raters rate each item and how many times they do so.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_dawid_skene_model_+3A_seed">seed</code></td>
<td>
<p>An optional random seed to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of raters implied by the entries in the rater column
must match the number of raters implied by the passed theta parameter.
</p>
<p>This function can also be used to simulate from the class-conditional
Dawid-Skene model by specifying theta in the required form (i.e where
all off-diagonal entries of the error matrices are equal.)
</p>


<h3>Value</h3>

<p>The passed <code>sim_data</code> augmented with columns:
</p>

<ul>
<li> <p><code>"z"</code> containing the latent class of each item,
</p>
</li>
<li> <p><code>"rating"</code> containing the simulated ratings.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


J &lt;- 5
K &lt;- 4
pi &lt;- rep(1 / K, K)
theta &lt;- make_theta(0.7, J, K)
sim_data &lt;- data.frame(item = rep(1:2, each = 5), rater = rep(1:5, 2))

simulations &lt;- simulate_dawid_skene_model(pi, theta, sim_data)
simulations



</code></pre>

<hr>
<h2 id='simulate_hier_dawid_skene_model'>Simulate data from the hierarchical Dawid-Skene model</h2><span id='topic+simulate_hier_dawid_skene_model'></span>

<h3>Description</h3>

<p>Simulate data from the hierarchical Dawid-Skene model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_hier_dawid_skene_model(pi, mu, sigma, sim_data, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_hier_dawid_skene_model_+3A_pi">pi</code></td>
<td>
<p>The pi parameter of the hierarchical Dawid-Skene model.</p>
</td></tr>
<tr><td><code id="simulate_hier_dawid_skene_model_+3A_mu">mu</code></td>
<td>
<p>The mu parameter of the hierarchical Dawid-Skene model.</p>
</td></tr>
<tr><td><code id="simulate_hier_dawid_skene_model_+3A_sigma">sigma</code></td>
<td>
<p>The sigma parameter of the hierarchical Dawid-Skene model.</p>
</td></tr>
<tr><td><code id="simulate_hier_dawid_skene_model_+3A_sim_data">sim_data</code></td>
<td>
<p>Data to guide the simulation. The data must be in the long
data format used in <code>rater()</code> except without the 'rating' column. The data
specifies:
</p>

<ul>
<li><p> the number of items in the data, and
</p>
</li>
<li><p> which raters rate each item and how many times they do so.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate_hier_dawid_skene_model_+3A_seed">seed</code></td>
<td>
<p>An optional random seed to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of raters implied by the entries in the rater column
must match the number of raters implied by the passed theta parameter.
</p>


<h3>Value</h3>

<p>The passed <code>sim_data</code> augmented with columns:
</p>

<ul>
<li> <p><code>"z"</code> containing the latent class of each item,
</p>
</li>
<li> <p><code>"rating"</code> containing the simulated rating.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>


J &lt;- 5
K &lt;- 4

pi &lt;- rep(1 / K, K)

mu &lt;- matrix(0, nrow = K, ncol = K)
diag(mu) &lt;- 5

sigma &lt;- matrix(sqrt(2) / sqrt(pi), nrow = K, ncol = K)

sim_data &lt;- data.frame(item = rep(1:2, each = 5), rater = rep(1:5, 2))

sim_result &lt;- simulate_hier_dawid_skene_model(pi, mu, sigma, sim_data)

sim_result$sim
sim_result$theta



</code></pre>

<hr>
<h2 id='summary.mcmc_fit'>Summarise a <code>mcmc_fit</code> object</h2><span id='topic+summary.mcmc_fit'></span>

<h3>Description</h3>

<p>Summarise a <code>mcmc_fit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcmc_fit'
summary(object, n_pars = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mcmc_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>mcmc_fit</code>.</p>
</td></tr>
<tr><td><code id="summary.mcmc_fit_+3A_n_pars">n_pars</code></td>
<td>
<p>The number of pi/theta parameters and z 'items' to display.</p>
</td></tr>
<tr><td><code id="summary.mcmc_fit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the class conditional model the 'full' theta parameterisation
(i.e. appearing to have the same number of parameters as the standard
Dawid-Skene model) is calculated and returned. This is designed to allow
easier comparison with the full Dawid-Skene model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE)

summary(fit)



</code></pre>

<hr>
<h2 id='summary.optim_fit'>Summarise an <code>optim_fit</code> object</h2><span id='topic+summary.optim_fit'></span>

<h3>Description</h3>

<p>Summarise an <code>optim_fit</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optim_fit'
summary(object, n_pars = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.optim_fit_+3A_object">object</code></td>
<td>
<p>An object of class <code>optim_fit</code>.</p>
</td></tr>
<tr><td><code id="summary.optim_fit_+3A_n_pars">n_pars</code></td>
<td>
<p>The number of pi/theta parameters and z 'items' to display.</p>
</td></tr>
<tr><td><code id="summary.optim_fit_+3A_...">...</code></td>
<td>
<p>Other arguments passed to function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the class conditional model the 'full' theta parameterisation
(i.e. appearing to have the same number of parameters as the standard
Dawid-Skene model) is calculated and returned. This is designed to allow
easier comparison with the full Dawid-Skene model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit &lt;- rater(anesthesia, "dawid_skene", method = "optim")

summary(fit)



</code></pre>

<hr>
<h2 id='summary.rater_model'>Summarise a <code>rater_model</code>.</h2><span id='topic+summary.rater_model'></span>

<h3>Description</h3>

<p>Summarise a <code>rater_model</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_model'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rater_model_+3A_object">object</code></td>
<td>
<p>A <code>rater_model</code> object.</p>
</td></tr>
<tr><td><code id="summary.rater_model_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- dawid_skene()
summary(mod)

</code></pre>

<hr>
<h2 id='waic.rater_fit'>Compute the WAIC - a measure of model fit - of a rater fit object.</h2><span id='topic+waic.rater_fit'></span><span id='topic+waic'></span>

<h3>Description</h3>

<p>Compute the WAIC - a measure of model fit - of a rater fit object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rater_fit'
waic(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="waic.rater_fit_+3A_x">x</code></td>
<td>
<p>A <code>rater_fit</code> object. All model types are currently supported
except the basic Dawid-Skene model fit with grouped data.</p>
</td></tr>
<tr><td><code id="waic.rater_fit_+3A_...">...</code></td>
<td>
<p>Other arguments passed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides provides an additional method for model
comparison, on top of the <code>loo()</code> function. In general we recommend that
<code>loo()</code> is preferred: see the documentation of the loo package for details.
Also, note the comments regarding model selection the the details section
of <code>loo()</code>.
</p>


<h3>Value</h3>

<p>A waic/loo object.
</p>


<h3>References</h3>

<p>Watanabe, S. (2010). Asymptotic equivalence of Bayes cross validation and
widely application information criterion in singular learning theory.
<em>Journal of Machine Learning Research</em> 11, 3571-3594.
</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017a). Practical Bayesian model
evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413&ndash;1432. doi:10.1007/s11222-016-9696-4
(<a href="https://link.springer.com/article/10.1007/s11222-016-9696-4">journal version</a>,
<a href="https://arxiv.org/abs/1507.04544">preprint arXiv:1507.04544</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

fit_ds &lt;- rater(anesthesia, "dawid_skene", verbose = FALSE, chains = 1)
fit_ccds &lt;- rater(anesthesia, "class_conditional_dawid_skene",
                  verbose = FALSE, chains = 1)

waic(fit_ds)
waic(fit_ccds)


</code></pre>

<hr>
<h2 id='wide_to_long'>Convert wide data to the long format</h2><span id='topic+wide_to_long'></span>

<h3>Description</h3>

<p>Convert wide data to the long format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wide_to_long(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wide_to_long_+3A_data">data</code></td>
<td>
<p>Data in a wide format. Must be 2D data object which can be
converted to a data.frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wide data refers to a way of laying out categorical rating data
where each item is one row and each column represents the ratings of each
rater. Elements of the data can be <code>NA</code>, indicating that an item wasn't
rated by a rater. Wide data cannot represent the same rater rating an item
multiple times.
</p>
<p>Currently any column names of the data are ignored and the raters are
labelled by their column position (1 indexed, left to right). Only numeric
ratings are currently supported.
</p>


<h3>Value</h3>

<p>The data converted into long format. A data.frame with three columns
item, rater and rating.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>wide_data &lt;- data.frame(dater_1 = c(3, 2, 2), rater_2 = c(4, 2, 2))
wide_data

long_data &lt;- wide_to_long(wide_data)
long_data


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
