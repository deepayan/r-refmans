<!DOCTYPE html><html><head><title>Help for package gustave</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gustave}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add_zero'><p>Expand a matrix or a data.frame with zeros based on rownames matching</p></a></li>
<li><a href='#define_statistic_wrapper'><p>Define a statistic wrapper</p></a></li>
<li><a href='#define_variance_wrapper'><p>Define a variance estimation wrapper</p></a></li>
<li><a href='#ict_pop'><p>Sampling frame of the Information and communication technologies (ICT)</p>
survey</a></li>
<li><a href='#ict_sample'><p>Sample of the Information and communication technologies (ICT)</p>
survey</a></li>
<li><a href='#ict_survey'><p>Survey data of the Information and communication technologies (ICT)</p>
survey</a></li>
<li><a href='#lfs_samp_area'><p>Sample of areas in the Labour force survey</p></a></li>
<li><a href='#lfs_samp_dwel'><p>Sample of dwellings in the Labour force survey</p></a></li>
<li><a href='#lfs_samp_ind'><p>Sample of individuals in the Labour force survey</p></a></li>
<li><a href='#qvar'><p>Quickly perform a variance estimation in common cases</p></a></li>
<li><a href='#res_cal'><p>Linear Regression Residuals Calculation</p></a></li>
<li><a href='#standard_statistic_wrapper'><p>Standard statistic wrappers</p></a></li>
<li><a href='#sum_by'><p>Efficient by-group (weighted) summation</p></a></li>
<li><a href='#var_pois'><p>Variance estimator for a Poisson sampling design</p></a></li>
<li><a href='#varDT'><p>Variance approximation with Deville-Tillé (2005) formula</p></a></li>
<li><a href='#varSYG'><p>Sen-Yates-Grundy variance estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A User-Oriented Statistical Toolkit for Analytical Variance
Estimation</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.2.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, utils, stats, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, sampling, magrittr, tibble, dplyr, data.table</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/InseeFr/gustave">https://github.com/InseeFr/gustave</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/InseeFr/gustave/issues">https://github.com/InseeFr/gustave/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a toolkit for analytical variance estimation in survey sampling. Apart from the implementation of standard variance estimators, its main feature is to help the sampling expert produce easy-to-use variance estimation "wrappers", where systematic operations (linearization, domain estimation) are handled in a consistent and transparent way.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Collate:</td>
<td>'data.R' 'utils.R' 'define_variance_wrapper.R'
'variance_function.R' 'define_statistic_wrapper.R'
'standard_statistic_wrapper.R' 'qvar.R'</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-17 09:16:29 UTC; mc</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Chevalier [aut] (Creator),
  Khaled Larbi [cre],
  Institut national de la statistique et des études économiques [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Khaled Larbi &lt;khaled.larbi@insee.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-17 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add_zero'>Expand a matrix or a data.frame with zeros based on rownames matching</h2><span id='topic+add_zero'></span>

<h3>Description</h3>

<p>For a given two-dimensional object with rownames and a character
vector, <code>add_zero</code> produces a corresponding object whose rownames match
the character vector, with zeros on the additional rows.
</p>
<p>This function is an easy-to-use and reliable way to reintroduce
non-responding units in the variance estimation process (after the
non-response phase is taken into account).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_zero(y, rownames, remove = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_zero_+3A_y">y</code></td>
<td>
<p>A (sparse) matrix or a data.frame. The object to add zeros to.</p>
</td></tr>
<tr><td><code id="add_zero_+3A_rownames">rownames</code></td>
<td>
<p>A character vector (other types are coerced to character).
The character vector giving the rows of the produced object.</p>
</td></tr>
<tr><td><code id="add_zero_+3A_remove">remove</code></td>
<td>
<p>Should rows of <code>y</code> whose name do not appear in the rownames
argument be removed ? TRUE by default, a warning is shown when rows are
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (sparse) matrix or data.frame depending on the type of <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data generation
set.seed(1)
n &lt;- 10
p &lt;- 2
y &lt;- matrix(1:(n*p), ncol = p, dimnames = list(sample(letters, n)))
y[c(3, 8, 12)] &lt;- NA
rownames &lt;- letters

# Standard use
add_zero(y, rownames)

# Use when rownames in y do not match
# any element in the rownames argument
rownames(y)[1:3] &lt;- toupper(rownames(y)[1:3])
add_zero(y, rownames)
add_zero(y, rownames, remove = FALSE)

</code></pre>

<hr>
<h2 id='define_statistic_wrapper'>Define a statistic wrapper</h2><span id='topic+define_statistic_wrapper'></span>

<h3>Description</h3>

<p><code>define_statistic_wrapper</code> defines 
statistic <em>wrappers</em> to be used together with
<code><a href="#topic+define_variance_wrapper">variance estimation wrappers</a></code>. 
A statistic wrapper produces both the point estimator and the 
linearized variable associated with a given statistic to estimate 
variance on (Deville, 1999). <code>define_statistic_wrapper</code> is intended 
for <strong>advanced use only</strong>, standard statistic wrappers are included 
in the gustave package (see <code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_statistic_wrapper(
  statistic_function,
  arg_type,
  arg_not_affected_by_domain = NULL,
  display_function = standard_display
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_statistic_wrapper_+3A_statistic_function">statistic_function</code></td>
<td>
<p>An R function specific to the statistic to
calculate. It should produce at least the point estimator and the
linearized variable associated with the statistic (see Details).</p>
</td></tr>
<tr><td><code id="define_statistic_wrapper_+3A_arg_type">arg_type</code></td>
<td>
<p>A named list with three character vectors describing 
the type of each argument of <code>statistic_function</code> (see Details).</p>
</td></tr>
<tr><td><code id="define_statistic_wrapper_+3A_arg_not_affected_by_domain">arg_not_affected_by_domain</code></td>
<td>
<p>A character vector indicating the
arguments which should not be affected by domain-splitting. Such parameters
may appear in some complex linearization formula, for instance when the 
At-Risk of Poverty Rate (ARPR) is estimated by region but with a poverty 
line calculated at the national level.</p>
</td></tr>
<tr><td><code id="define_statistic_wrapper_+3A_display_function">display_function</code></td>
<td>
<p>An R function which produces, for each variance 
estimation, the data.frame to be displayed by the variance estimation 
wrapper. The default display function (<code>standard_display</code>) uses 
standard metadata to display usual variance indicator (point estimate, 
variance, standard  deviation, coefficient of variation, confidence interval) 
broken down by statistic wrapper, domain (if any) and level (if the variable 
is a factor).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the statistic to estimate is not a total, the application of 
analytical variance estimation formulae developed for the estimator of a total 
is not straightforward (Deville, 1999). An asymptotically unbiased variance 
estimator can nonetheless be obtained if the estimation of variance is performed
on a variable obtained from the original data through a linearization step. 
</p>
<p><code>define_statistic_wrapper</code> is the function used to create, for a 
given statistic, an easy-to-use function which calculates both the point
estimator and the linearized variable associated with the statistic. These
operations are implemented by the <code>statistic_function</code>, which can have
any needed input (for example <code>num</code> and <code>denom</code> for a ratio
estimator) and should output a list with at least two named elements: </p>

<ul>
<li> <p><code>point</code>: the point estimator of the statistic
</p>
</li>
<li> <p><code>lin</code>: the linearized variable to be passed on to the variance
estimation formula. If several variables are to be associated with
the statistics, <code>lin</code> can be a list itself.
</p>
</li></ul>

<p>All other named elements in the output of <code>define_statistic_wrapper</code> are 
treated as metadata (that may be used later on by <code>display_function</code>).
</p>
<p><code>arg_type</code> is a named list of three elements that describes the nature 
of the argument of <code>statistic_function</code>: </p>

<ul>
<li> <p><code>data</code>: data argument(s), numerical vector(s) to be used 
to calculate the point estimate and the linearized variable associated
with the statistic 
</p>
</li>
<li> <p><code>weight</code>: weight argument, numerical vector to be used 
as row weights
</p>
</li>
<li> <p><code>param</code>: parameters, non-data arguments to be used to 
control some aspect of the computation</p>
</li></ul>

<p>Statistic wrappers are quite flexible tools to apply a variance function 
to an estimator requiring a linearization step (e.g. all estimators except 
the estimator of a total) with virtually no  additional complexity for the
end-user. 
</p>
<p><code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code> 
are included within the gustave package and automatically added 
to the variance estimation wrappers. New statistic wrappers can be defined
using the <code>define_statistic_wrapper</code> and then explicitly added to the 
variance estimation wrappers using the <code>objects_to_include</code> argument.
</p>
<p>Note: To some extent, statistic wrappers can be seen as ggplot2
<code>geom_</code> and <code>stat_</code> functions: they help the end-user in writing 
down what he or she wants without having to go too  deep into the details 
of the corresponding layers.
</p>


<h3>Value</h3>

<p>A function to be used within a variance estimation wrapper to estimate
a specific statistic (see examples). Its formals are the ones of 
<code>statistic_function</code> with the addition of <code>by</code> and <code>where</code> 
(for domain estimation, set to <code>NULL</code> by default).
</p>


<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Deville J.-C. (1999), &quot;Variance estimation for complex statistics and 
estimators: linearization and residual techniques&quot;, <em>Survey Methodology</em>, 
25:193–203
</p>


<h3>See Also</h3>

<p><code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>, <code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from the Information and communication technologies (ICT) survey

# Let's define a variance wrapper asfor the ICT survey 
# as in the examples of the qvar function: 
precision_ict &lt;- qvar(
  data = ict_sample,
  dissemination_dummy = "dissemination",
  dissemination_weight = "w_calib",
  id = "firm_id",
  scope_dummy = "scope",
  sampling_weight = "w_sample", 
  strata = "strata",
  nrc_weight = "w_nrc", 
  response_dummy = "resp", 
  hrg = "hrg",
  calibration_weight = "w_calib",
  calibration_var = c(paste0("N_", 58:63), paste0("turnover_", 58:63)),
  define = TRUE
)
precision_ict(ict_survey, mean(speed_quanti))

# Let's now redefine the mean statistic wrapper
mean2 &lt;- define_statistic_wrapper(
  statistic_function = function(y, weight){
    point &lt;- sum(y * weight) / sum(weight)
    lin &lt;- (y - point) / sum(weight)
    list(point = point, lin = lin, metadata = list(n = length(y)))
  },
  arg_type = list(data = "y", weight = "weight")
)

# mean2 can now be used inside precision_ict (and yields
# the same results as the mean statistic wrapper)
precision_ict(ict_survey, mean(speed_quanti), mean2(speed_quanti))

</code></pre>

<hr>
<h2 id='define_variance_wrapper'>Define a variance estimation wrapper</h2><span id='topic+define_variance_wrapper'></span>

<h3>Description</h3>

<p>Given a variance estimation <em>function</em> (specific to a 
survey), <code>define_variance_wrapper</code> defines a variance estimation 
<em>wrapper</em> easier to use (e.g. automatic domain estimation, 
linearization).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_variance_wrapper(
  variance_function,
  reference_id,
  reference_weight,
  default_id = NULL,
  technical_data = NULL,
  technical_param = NULL,
  objects_to_include = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_variance_wrapper_+3A_variance_function">variance_function</code></td>
<td>
<p>An R function. It is the methodological workhorse of 
the variance estimation: from a set of arguments including the variables 
of interest (see below), it should return a vector of estimated variances.
See Details.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_reference_id">reference_id</code></td>
<td>
<p>A vector containing the ids of all the responding units
of the survey. It can also be an unevaluated expression (enclosed in 
<code>quote()</code>) to be evaluated within the execution environment of the wrapper.
It is compared with <code>default$id</code> (see below) to check whether 
some observations are missing in the survey file. The matrix of variables 
of interest passed on to <code>variance_function</code> has <code>reference_id</code> 
as rownames and is ordered according to its values.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_reference_weight">reference_weight</code></td>
<td>
<p>A vector containing the reference weight of the survey. 
It can also be an unevaluated expression (enclosed in <code>quote()</code>) to 
be evaluated within the execution environment of the wrapper.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_default_id">default_id</code></td>
<td>
<p>A character vector of length 1, the name of the default 
identifying variable in the survey file. It can also be an unevaluated 
expression (enclosed in <code>quote()</code>) to be evaluated within the survey file.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_technical_data">technical_data</code></td>
<td>
<p>A named list of technical data needed to perform 
the variance estimation (e.g. sampling strata, first- or second-order 
probabilities of inclusion, estimated response probabilities, calibration 
variables). Its names should match the names of the corresponding arguments 
in <code>variance_function</code>.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_technical_param">technical_param</code></td>
<td>
<p>A named list of technical parameters used to control 
some aspect of the variance estimation process (e.g. alternative methodology).
Its names should match the names of the corresponding arguments in <code>variance_function</code>.</p>
</td></tr>
<tr><td><code id="define_variance_wrapper_+3A_objects_to_include">objects_to_include</code></td>
<td>
<p>(Advanced use) A character vector indicating the name of 
additional R objects to include within the variance wrapper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Defining variance estimation wrappers is the <strong>key feature</strong> of
the <code>gustave</code> package. It is the workhorse of the ready-to-use 
<code><a href="#topic+qvar">qvar</a></code> function and should be used directly to handle more complex
cases (e.g. surveys with several stages or balanced sampling).
</p>
<p>Analytical variance estimation is often difficult to carry out by 
non-specialists owing to the complexity of the underlying sampling 
and estimation methodology. This complexity yields complex <em>variance 
estimation functions</em> which are most often only used by the sampling expert 
who actually wrote them. A <em>variance estimation wrapper</em> is an 
intermediate function that is &quot;wrapped around&quot; the (complex) variance 
estimation function in order to provide the non-specialist with 
user-friendly features (see examples): </p>

<ul>
<li><p> calculation of complex statistics (see 
<code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>)
</p>
</li>
<li><p> domain estimation 
</p>
</li>
<li><p> handy evaluation and factor discretization
</p>
</li></ul>

<p><code>define_variance_wrapper</code> allows the sampling expert to define a 
variance estimation wrapper around a given variance estimation function and
set its default parameters. The produced variance estimation wrapper is 
standalone in the sense that it contains all technical data necessary
to carry out the estimation (see <code>technical_data</code>).
</p>
<p>The arguments of the <code>variance_function</code> fall into three types: </p>

<ul>
<li><p> the data argument (mandatory, only one allowed): the numerical matrix of 
variables of interest to apply the variance estimation formula on
</p>
</li>
<li><p> technical data arguments (optional, one or more allowed): technical 
and methodological information used by the variance estimation function
(e.g. sampling strata, first- or second-order probabilities of inclusion, 
estimated response probabilities, calibration variables)
</p>
</li>
<li><p> technical parameters (optional, one or more allowed): non-data arguments 
to be used to control some aspect of the variance estimation (e.g. alternative
methodology)</p>
</li></ul>

<p><code>technical_data</code> and <code>technical_param</code> are used to determine
which arguments of <code>variance_function</code> relate to technical information, 
the only remaining argument is considered as the data argument.
</p>


<h3>Value</h3>

<p>An R function that makes the estimation of variance based on the
provided variance function easier. Its parameters are: </p>
 <ul>
<li>
<p><code>data</code>: one or more calls to a statistic wrapper (e.g. <code>total()</code>,
<code>mean()</code>, <code>ratio()</code>). See examples and
<code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>) and
<code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>)
</p>
</li>
<li> <p><code>where</code>: a logical vector indicating a domain on which the
variance estimation is to be performed </p>
</li>
<li> <p><code>by</code>: q qualitative
variable whose levels are used to define domains on which the variance
estimation is performed </p>
</li>
<li> <p><code>alpha</code>: a numeric vector of length 1
indicating the threshold for confidence interval derivation (<code>0.05</code> by
default) </p>
</li>
<li> <p><code>display</code>: a logical verctor of length 1 indicating
whether the result of the estimation should be displayed or not </p>
</li>
<li>
<p><code>id</code>: a character vector of size 1 containing the name of the
identifying variable in the survey file. Its default value depends on the
value of <code>default_id</code> in <code>define_variance_wrapper</code> </p>
</li>
<li>
<p><code>envir</code>: an environment containing a binding to <code>data</code></p>
</li></ul>



<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Rao, J.N.K (1975), &quot;Unbiased variance estimation for multistage designs&quot;,
<em>Sankhya</em>, C n°37
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qvar">qvar</a></code>, <code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code>, <code><a href="#topic+varDT">varDT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from the Labour force survey (LFS)

# The (simulated) Labour force survey (LFS) has the following characteristics:
# - first sampling stage: balanced sampling of 4 areas (each corresponding to 
#   about 120 dwellings) on first-order probability of inclusion (proportional to 
#   the number of dwellings in the area) and total annual income in the area.
# - second sampling stage: in each sampled area, simple random sampling of 20 
#   dwellings
# - neither non-response nor calibration

# As this is a multi-stage sampling design with balanced sampling at the first
# stage, the qvar function does not apply. A variance wrapper can nonetheless
# be defined using the core define_variance_wrapper function.

# Step 1 : Definition of the variance function and the corresponding technical data

# In this context, the variance estimation function specific to the LFS 
# survey can be defined as follows:

var_lfs &lt;- function(y, ind, dwel, area){
  
  variance &lt;- list()
  
  # Variance associated with the sampling of the dwellings
  y &lt;- sum_by(y, ind$id_dwel)
  variance[["dwel"]] &lt;- var_srs(
    y = y, pik = dwel$pik_dwel, strata = dwel$id_area, 
    w = (1 / dwel$pik_area^2 - dwel$q_area)
  )
  
  # Variance associated with the sampling of the areas
  y &lt;- sum_by(y = y, by = dwel$id_area, w = 1 / dwel$pik_dwel) 
  variance[["area"]] &lt;- varDT(y = y, precalc = area)
  
  Reduce(`+`, variance)
  
}

# where y is the matrix of variables of interest and ind, dwel and area the technical data:

technical_data_lfs &lt;- list()

# Technical data at the area level
# The varDT function allows for the pre-calculation of 
# most of the methodological quantities needed.
technical_data_lfs$area &lt;- varDT(
  y = NULL, 
  pik = lfs_samp_area$pik_area, 
  x = as.matrix(lfs_samp_area[c("pik_area", "income")]),
  id = lfs_samp_area$id_area
)

# Technical data at the dwelling level
# In order to implement Rao (1975) formula for two-stage samples,
# we associate each dwelling with the diagonal term corresponding 
# to its area in the first-stage variance estimator: 
lfs_samp_dwel$q_area &lt;- with(technical_data_lfs$area, setNames(diago, id))[lfs_samp_dwel$id_area]
technical_data_lfs$dwel &lt;- lfs_samp_dwel[c("id_dwel", "pik_dwel", "id_area", "pik_area", "q_area")]

# Technical data at the individual level
technical_data_lfs$ind &lt;- lfs_samp_ind[c("id_ind", "id_dwel", "sampling_weight")]

# Test of the variance function var_lfs
y &lt;- matrix(as.numeric(lfs_samp_ind$unemp), ncol = 1, dimnames = list(lfs_samp_ind$id_ind))
with(technical_data_lfs, var_lfs(y = y, ind = ind, dwel = dwel, area = area))


# Step 2 : Definition of the variance wrapper

# Call of define_variance_wrapper
precision_lfs &lt;- define_variance_wrapper(
  variance_function = var_lfs,
  technical_data = technical_data_lfs, 
  reference_id = technical_data_lfs$ind$id_ind,
  reference_weight = technical_data_lfs$ind$sampling_weight,
  default_id = "id_ind"
)

# Test
precision_lfs(lfs_samp_ind, unemp)

# The variance wrapper precision_lfs has the same features
# as variance wrappers produced by the qvar function (see
# qvar examples for more details).

</code></pre>

<hr>
<h2 id='ict_pop'>Sampling frame of the Information and communication technologies (ICT)
survey</h2><span id='topic+ict_pop'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing basic identification information and
auxiliary variables for the sampling of the Information and communication
technologies (ICT) survey in the information and communication sector 
(NACE rev 2 J section).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ict_pop
</code></pre>


<h3>Format</h3>

<p>A data frame with 7670 observations and 5 variables:
</p>

<dl>
<dt>firm_id</dt><dd><p>identifier of the firm</p>
</dd>
<dt>division</dt><dd><p>identifier of the economic sub-sector</p>
</dd>
<dt>employees</dt><dd><p>number of employees</p>
</dd>
<dt>turnover</dt><dd><p>firm turnover, in thousand euros</p>
</dd>
<dt>strata</dt><dd><p>stratification variable</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+qvar">qvar</a></code>, <code><a href="#topic+ict_sample">ict_sample</a></code>, <code><a href="#topic+ict_survey">ict_survey</a></code>
</p>

<hr>
<h2 id='ict_sample'>Sample of the Information and communication technologies (ICT)
survey</h2><span id='topic+ict_sample'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing sampling information about the sample 
of the Information and communication technologies (ICT)
survey in the information and communication sector (NACE rev 2 J section)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ict_sample
</code></pre>


<h3>Format</h3>

<p>A data frame with 650 observations and 8 variables:
</p>

<dl>
<dt>firm_id</dt><dd><p>identifier of the firm</p>
</dd>
<dt>division</dt><dd><p>identifier of the economic sub-sector</p>
</dd>
<dt>employees</dt><dd><p>number of employees</p>
</dd>
<dt>turnover</dt><dd><p>firm turnover, in euros</p>
</dd>
<dt>strata</dt><dd><p>stratification variable</p>
</dd>
<dt>w_sample</dt><dd><p>sampling weight</p>
</dd>
<dt>scope</dt><dd><p>boolean indicating whether the firm did belong to the scope of the survey or not</p>
</dd>
<dt>resp</dt><dd><p>boolean indicating whether the firm did respond to the survey or not</p>
</dd>
<dt>nrc</dt><dd><p>boolean indicating whether the firm did take part in the non-response correction process or not</p>
</dd>
<dt>hrg</dt><dd><p>homogeneous response group used for the non-response correction</p>
</dd>
<dt>response_prob_est</dt><dd><p>response probability of the unit estimated using homogeneous response groups</p>
</dd>
<dt>w_nrc</dt><dd><p>weight after unit non-response correction</p>
</dd>
<dt>calib</dt><dd><p>boolean indicating whether the firm was integrated in the calibration process or not (<code>TRUE</code> for all responding units)</p>
</dd>
<dt>N_58, N_59, N_60, N_61, N_62, N_63, turnover_58, turnover_59, turnover_60, turnover_61, turnover_62, turnover_63</dt><dd><p>calibration variables (number of firms and turnover broken down by economic sub-sector)</p>
</dd>
<dt>w_calib</dt><dd><p>calibrated weight</p>
</dd>
<dt>dissemination</dt><dd><p>boolean indicating whether the unit appears in the dissemination file</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+qvar">qvar</a></code>, <code><a href="#topic+ict_pop">ict_pop</a></code>, <code><a href="#topic+ict_survey">ict_survey</a></code>
</p>

<hr>
<h2 id='ict_survey'>Survey data of the Information and communication technologies (ICT)
survey</h2><span id='topic+ict_survey'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing calibration and survey variables of the respondents 
to the Information and communication technologies (ICT)
survey in the information and communication sector (NACE rev 2 J section)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ict_survey
</code></pre>


<h3>Format</h3>

<p>A data frame with 612 observations and 11 variables:
</p>

<dl>
<dt>firm_id</dt><dd><p>identifier of the firm</p>
</dd>
<dt>division</dt><dd><p>identifier of the economic sub-sector</p>
</dd>
<dt>employees</dt><dd><p>number of employees</p>
</dd>
<dt>turnover</dt><dd><p>firm turnover, in euros</p>
</dd>
<dt>w_calib</dt><dd><p>calibrated weight</p>
</dd>
<dt>speed_quanti, speed_quanti_NA</dt><dd><p>internet connection speed of the firm in Mbps, without or with missing values</p>
</dd>
<dt>speed_quali, speed_quali_NA</dt><dd><p>internet connection speed of the firm recoded in classes, without or with missing values</p>
</dd>
<dt>big_data, big_data_NA</dt><dd><p>use of big data analytics within the firm, without or with missing values</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+qvar">qvar</a></code>, <code><a href="#topic+ict_pop">ict_pop</a></code>, <code><a href="#topic+ict_sample">ict_sample</a></code>
</p>

<hr>
<h2 id='lfs_samp_area'>Sample of areas in the Labour force survey</h2><span id='topic+lfs_samp_area'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing information about 4 geographical 
areas (about 120 dwellings each) sampled for the labour force survey.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfs_samp_area
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 observations and 3 variables:
</p>

<dl>
<dt>id_area</dt><dd><p>identifier of the area</p>
</dd>
<dt>income</dt><dd><p>total annual income of the area in thousand euros (from income registry)</p>
</dd>
<dt>pik_area</dt><dd><p>first-order inclusion probability of the area (proportional to the number of dwellings in the area)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>, <code><a href="#topic+lfs_samp_dwel">lfs_samp_dwel</a></code>, <code><a href="#topic+lfs_samp_ind">lfs_samp_ind</a></code>
</p>

<hr>
<h2 id='lfs_samp_dwel'>Sample of dwellings in the Labour force survey</h2><span id='topic+lfs_samp_dwel'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing information about 80 dwellings
sampled for the Labour force survey (in the 4 areas described
in <code><a href="#topic+lfs_samp_area">lfs_samp_area</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfs_samp_dwel
</code></pre>


<h3>Format</h3>

<p>A data frame with 80 observations and 6 variables:
</p>

<dl>
<dt>id_dwel</dt><dd><p>identifier of the dwelling</p>
</dd>
<dt>id_area</dt><dd><p>identifier of the area</p>
</dd>
<dt>income</dt><dd><p>total annual income of the dwelling in thousand euros (from income registry)</p>
</dd>
<dt>pik_area</dt><dd><p>first-order inclusion probability of the area</p>
</dd>
<dt>pik_dwel</dt><dd><p>first-order inclusion probability of the dwelling within the area (20 dwelling sampled per area)</p>
</dd>
<dt>pik</dt><dd><p>first-order inclusion probability of the dwelling</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>, <code><a href="#topic+lfs_samp_area">lfs_samp_area</a></code>, <code><a href="#topic+lfs_samp_ind">lfs_samp_ind</a></code>
</p>

<hr>
<h2 id='lfs_samp_ind'>Sample of individuals in the Labour force survey</h2><span id='topic+lfs_samp_ind'></span>

<h3>Description</h3>

<p>A (simulated) dataset containing information about 157 individuals
sampled for the Labour force survey (all members of the 80 dwellings
described in <code><a href="#topic+lfs_samp_dwel">lfs_samp_dwel</a></code>). It also contains the 
unemployment status extracted from the survey file (no non-response).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfs_samp_ind
</code></pre>


<h3>Format</h3>

<p>A data frame with 157 observations and 5 variables:
</p>

<dl>
<dt>id_ind</dt><dd><p>identifier of the individual</p>
</dd>
<dt>id_dwel</dt><dd><p>identifier of the dwelling</p>
</dd>
<dt>income</dt><dd><p>total annual income of the individual in thousand euros (from income registry)</p>
</dd>
<dt>unemp</dt><dd><p>unemployment status</p>
</dd>
<dt>sampling_weight</dt><dd><p>sampling weight of the individual (inverse of the first-order inclusion probability of the dwelling)</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>, <code><a href="#topic+lfs_samp_area">lfs_samp_area</a></code>, <code><a href="#topic+lfs_samp_dwel">lfs_samp_dwel</a></code>
</p>

<hr>
<h2 id='qvar'>Quickly perform a variance estimation in common cases</h2><span id='topic+qvar'></span>

<h3>Description</h3>

<p><code>qvar</code> (for &quot;quick variance estimation&quot;) is a function
performing analytical variance estimation in most common cases, that is:
</p>
<ul>
<li><p> stratified simple random sampling </p>
</li>
<li><p> non-response
correction (if any) through reweighting </p>
</li>
<li><p> calibration (if any)</p>
</li></ul>

<p>Used with <code>define = TRUE</code>, it defines a so-called variance wrapper, that 
is a standalone ready-to-use function that can be applied to the survey dataset 
without having to specify the methodological characteristics of the survey
(see <code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qvar(
  data,
  ...,
  by = NULL,
  where = NULL,
  alpha = 0.05,
  display = TRUE,
  id,
  dissemination_dummy,
  dissemination_weight,
  sampling_weight,
  strata = NULL,
  scope_dummy = NULL,
  nrc_weight = NULL,
  response_dummy = NULL,
  nrc_dummy = NULL,
  calibration_weight = NULL,
  calibration_dummy = NULL,
  calibration_var = NULL,
  define = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qvar_+3A_data">data</code></td>
<td>
<p>The <code>data.frame</code> containing all the technical information
required to prepare the variance estimation process (see other arguments 
below). Note that this file should contain all the units sampled, 
including the out-of-scope and non-responding units. If a variance
estimation is to be performed right away (when <code>define = FALSE</code>),
it should also contain the variables of interest.</p>
</td></tr>
<tr><td><code id="qvar_+3A_...">...</code></td>
<td>
<p>One or more calls to a statistic wrapper (e.g. <code>total()</code>, 
<code>mean()</code>, <code>ratio()</code>). See examples and 
<code><a href="#topic+standard_statistic_wrapper">standard statistic wrappers</a></code></p>
</td></tr>
<tr><td><code id="qvar_+3A_by">by</code></td>
<td>
<p>A qualitative variable whose levels are used to define domains
on which the variance estimation is performed.</p>
</td></tr>
<tr><td><code id="qvar_+3A_where">where</code></td>
<td>
<p>A logical vector indicating a domain on which the variance 
estimation is to be performed.</p>
</td></tr>
<tr><td><code id="qvar_+3A_alpha">alpha</code></td>
<td>
<p>A numeric vector of length 1 indicating the threshold
for confidence interval derivation (<code>0.05</code> by default).</p>
</td></tr>
<tr><td><code id="qvar_+3A_display">display</code></td>
<td>
<p>A logical verctor of length 1 indicating whether
the result of the estimation should be displayed or not.</p>
</td></tr>
<tr><td><code id="qvar_+3A_id">id</code></td>
<td>
<p>The identification variable of the units in <code>data</code>. 
It should be unique for each row in <code>data</code> and not contain any 
missing values.</p>
</td></tr>
<tr><td><code id="qvar_+3A_dissemination_dummy">dissemination_dummy</code></td>
<td>
<p>A character vector of length 1, the name
of the logical variable in <code>data</code> indicating whether the unit
does appear in the disseminated file and should be used for point
estimates. It should not contain any missing values.</p>
</td></tr>
<tr><td><code id="qvar_+3A_dissemination_weight">dissemination_weight</code></td>
<td>
<p>A character vector of length 1, the name
of the numerical variable in <code>data</code> corresponding to the 
dissemination weight of the survey. It should not contain any missing 
values.</p>
</td></tr>
<tr><td><code id="qvar_+3A_sampling_weight">sampling_weight</code></td>
<td>
<p>A character vector of length 1, the name of the 
numeric variable in <code>data</code> corresponding to the sampling weights 
of the survey. It should not contain any missing values.</p>
</td></tr>
<tr><td><code id="qvar_+3A_strata">strata</code></td>
<td>
<p>A character vector of length 1, the name of the factor 
variable in <code>data</code> whose level match the stratification
used in the survey. Character variables are coerced to factor.
If defined, it should not contain any missing value. If <code>NULL</code>,
the variance estimation process does not take any stratification
into account.</p>
</td></tr>
<tr><td><code id="qvar_+3A_scope_dummy">scope_dummy</code></td>
<td>
<p>A character vector of length 1, the name of the logical 
variable in <code>data</code> indicating whether the unit belongs to the
scope of the survey or not. Numerical variables are coerced to logical.
If defined, it should not contain any missing value. If <code>NULL</code>,
all units are supposed to be within the scope of the survey.</p>
</td></tr>
<tr><td><code id="qvar_+3A_nrc_weight">nrc_weight</code></td>
<td>
<p>A character vector of length 1, the name of the 
numerical variable in <code>data</code> corresponding to the weights
after non-response correction. If defined, all responding units 
should have a non-missing value. If <code>NULL</code>, all
units are supposed to be responding and the variance estimation
process does not include a second phase in order to take non-response
into account.</p>
</td></tr>
<tr><td><code id="qvar_+3A_response_dummy">response_dummy</code></td>
<td>
<p>A character vector of length 1, the name of of the logical 
variable in <code>data</code> indicating whether the unit is a responding 
unit or not. Numerical variables are coerced to logical. <code>response_dummy</code>
should be defined as long as a <code>nrc_weight</code> is provided. All units 
in the scope of the survey should have a non-missing value.</p>
</td></tr>
<tr><td><code id="qvar_+3A_nrc_dummy">nrc_dummy</code></td>
<td>
<p>A character vector of length 1, the name of
the logical variable in <code>data</code> indicating whether the
units did take part in the non-response correction process. 
All units in the scope of the survey should have a non-missing 
value.</p>
</td></tr>
<tr><td><code id="qvar_+3A_calibration_weight">calibration_weight</code></td>
<td>
<p>A character vector of length 1, the name of the 
numerical variable in <code>data</code> corresponding to the calibrated
weights. If defined, all responding units should have 
a non-missing value. If <code>NULL</code>, the variance estimation
process does not take any calibration step into account.</p>
</td></tr>
<tr><td><code id="qvar_+3A_calibration_dummy">calibration_dummy</code></td>
<td>
<p>A character vector of length 1, the name of of the logical 
variable in <code>data</code> indicating whether the unit did take part
in the calibration process or not. Numerical variables are coerced to 
logical. If defined, all responding units should have a non-missing
value. If <code>NULL</code>, calibration is supposed to have been performed
on all responding units.</p>
</td></tr>
<tr><td><code id="qvar_+3A_calibration_var">calibration_var</code></td>
<td>
<p>A character vector, the name of the variable(s) used in
the calibration process. Logical variables are coerced to numeric. 
Character and factor variables are automatically discretized. 
<code>calibration_var</code> should be defined as long as a <code>calibration_weight</code> is 
provided. All units taking part in the calibration process should have
only non-missing values for all variables in <code>calibration_var</code>.</p>
</td></tr>
<tr><td><code id="qvar_+3A_define">define</code></td>
<td>
<p>Logical vector of lentgh 1. Should a variance wrapper
be defined instead of performing a variance estimation (see details
and examples)?</p>
</td></tr>
<tr><td><code id="qvar_+3A_envir">envir</code></td>
<td>
<p>An environment containing a binding to <code>data</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qvar</code> performs not only technical but also 
methodological checks in order to ensure that the standard variance 
estimation methodology does apply (e.g. equal probability of 
inclusion within strata, number of units per stratum).
</p>
<p>Used with <code>define = TRUE</code>, the function returns a variance
estimation <em>wrapper</em>, that is a ready-to-use function that
implements the described variance estimation methodology and
contains all necessary data to do so (see examples).
</p>
<p>Note: To some extent, <code>qvar</code> is analogous to the <code>qplot</code> function
in the ggplot2 package, as it is an easier-to-use function for common
cases. More complex cases are to be handled by using the core functions of
the gustave package, e.g. <code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>, <code><a href="#topic+standard_statistic_wrapper">standard_statistic_wrapper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Example from the Information and communication technologies (ICT) survey

# The (simulated) Information and communication technologies (ICT) survey 
# has the following characteristics: 
# - stratified one-stage sampling design
# - non-response correction through reweighting in homogeneous response groups
# - calibration on margins.

# The ict_survey data.frame is a (simulated) subset of the ICT 
# survey file containing the variables of interest for the 612
# responding firms.

# The ict_sample data.frame is the (simulated) sample of 650
# firms corresponding to the ict_survey file. It contains all
# technical information necessary to estimate a variance with
# the qvar() function.

## Methodological description of the survey

# Direct call of qvar()
qvar(

  # Sample file
  data = ict_sample,
  
  # Dissemination and identification information
  dissemination_dummy = "dissemination",
  dissemination_weight = "w_calib",
  id = "firm_id",
  
  # Scope
  scope_dummy = "scope",
  
  # Sampling design
  sampling_weight = "w_sample", 
  strata = "strata",
  
  # Non-response correction
  nrc_weight = "w_nrc", 
  response_dummy = "resp", 
  hrg = "hrg",
  
  # Calibration
  calibration_weight = "w_calib",
  calibration_var = c(paste0("N_", 58:63), paste0("turnover_", 58:63)),
  
  # Statistic(s) and variable(s) of interest
  mean(employees)
 
)

# Definition of a variance estimation wrapper
precision_ict &lt;- qvar(

  # As before
  data = ict_sample,
  dissemination_dummy = "dissemination",
  dissemination_weight = "w_calib",
  id = "firm_id",
  scope_dummy = "scope",
  sampling_weight = "w_sample", 
  strata = "strata",
  nrc_weight = "w_nrc", 
  response_dummy = "resp", 
  hrg = "hrg",
  calibration_weight = "w_calib",
  calibration_var = c(paste0("N_", 58:63), paste0("turnover_", 58:63)),
  
  # Replacing the variables of interest by define = TRUE
  define = TRUE
  
)

# Use of the variance estimation wrapper
precision_ict(ict_sample, mean(employees))

# The variance estimation wrapper can also be used on the survey file
precision_ict(ict_survey, mean(speed_quanti))

## Features of the variance estimation wrapper

# Several statistics in one call (with optional labels)
precision_ict(ict_survey, 
  "Mean internet speed in Mbps" = mean(speed_quanti), 
  "Turnover per employee" = ratio(turnover, employees)
)

# Domain estimation with where and by arguments
precision_ict(ict_survey, 
  mean(speed_quanti), 
  where = employees &gt;= 50
)
precision_ict(ict_survey, 
  mean(speed_quanti), 
  by = division
)

# Domain may differ from one estimator to another
precision_ict(ict_survey, 
  "Mean turnover, firms with 50 employees or more" = mean(turnover, where = employees &gt;= 50),
  "Mean turnover, firms with 100 employees or more" = mean(turnover, where = employees &gt;= 100)
)

# On-the-fly evaluation (e.g. discretization)
precision_ict(ict_survey, mean(speed_quanti &gt; 100))

# Automatic discretization for qualitative (character or factor) variables
precision_ict(ict_survey, mean(speed_quali))

# Standard evaluation capabilities
variables_of_interest &lt;- c("speed_quanti", "speed_quali")
precision_ict(ict_survey, mean(variables_of_interest))

# Integration with %&gt;% and dplyr
library(magrittr)
library(dplyr)
ict_survey %&gt;% 
  precision_ict("Internet speed above 100 Mbps" = mean(speed_quanti &gt; 100)) %&gt;% 
  select(label, est, lower, upper)

</code></pre>

<hr>
<h2 id='res_cal'>Linear Regression Residuals Calculation</h2><span id='topic+res_cal'></span>

<h3>Description</h3>

<p><code>res_cal</code> calculates linear regression residuals in an 
efficient way : handling several dependent variables at a time, using 
Matrix::TsparseMatrix capabilities and allowing for pre-calculation of 
the matrix inverse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>res_cal(y = NULL, x, w = NULL, by = NULL, precalc = NULL, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="res_cal_+3A_y">y</code></td>
<td>
<p>A (sparse) numerical matrix of dependent variable(s).</p>
</td></tr>
<tr><td><code id="res_cal_+3A_x">x</code></td>
<td>
<p>A (sparse) numerical matrix of independent variable(s).</p>
</td></tr>
<tr><td><code id="res_cal_+3A_w">w</code></td>
<td>
<p>An optional numerical vector of row weights.</p>
</td></tr>
<tr><td><code id="res_cal_+3A_by">by</code></td>
<td>
<p>An optional categorical vector (factor or character)
when residuals calculation is to be conducted within by-groups 
(see Details).</p>
</td></tr>
<tr><td><code id="res_cal_+3A_precalc">precalc</code></td>
<td>
<p>A list of pre-calculated results (see Details).</p>
</td></tr>
<tr><td><code id="res_cal_+3A_id">id</code></td>
<td>
<p>A vector of identifiers of the units used in the calculation.
Useful when <code>precalc = TRUE</code> in order to assess whether the ordering of the
<code>y</code> data matrix matches the one used at the precalculation step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the context of the <code>gustave</code> package, linear 
regression residual calculation is solely used to take into account 
the effect of calibration on variance estimation. Independent variables 
are therefore most likely to be the same from one variance estimation 
to another, hence the inversion of the matrix 
<code>t(x) %*% Diagonal(x = w) %*% x</code> can be done once and for all 
at a pre-calculation step.
</p>
<p>The parameters <code>y</code> and <code>precalc</code> determine whether a list of 
pre-calculated data should be used in order to speed up the regression 
residuals computation at execution time:
</p>

<ul>
<li><p> if <code>y</code> not <code>NULL</code> and <code>precalc</code> <code>NULL</code> : 
on-the-fly calculation of the matrix inverse and the regression residuals 
(no pre-calculation).
</p>
</li>
<li><p> if <code>y</code> <code>NULL</code> and <code>precalc</code> <code>NULL</code> : 
pre-calculation of the matrix inverse which is stored in a list of 
pre-calculated data.
</p>
</li>
<li><p> if <code>y</code> not <code>NULL</code> and <code>precalc</code> not <code>NULL</code> : 
calculation of the regression residuals using the list of pre-calculated 
data.
</p>
</li></ul>

<p>The <code>by</code> parameter allows for calculation within by-groups : all 
calculation are made separately for each by-group (when calibration was 
conducted separately on several subsamples), but in an efficient way using 
Matrix::TsparseMatrix capabilities (especially when the matrix inverse is 
pre-calculated).
</p>


<h3>Value</h3>

 <ul>
<li><p> if <code>y</code> is not <code>NULL</code> (calculation step) : a
numerical matrix with same structure (regular base::matrix or
Matrix::TsparseMatrix) and dimensions as <code>y</code>. </p>
</li>
<li><p> if <code>y</code> is
<code>NULL</code> (pre-calculation step) : a list containing pre-calculated data.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating random data
set.seed(1)
n &lt;- 100
H &lt;- 5
y &lt;- matrix(rnorm(2*n), nrow = n)
x &lt;- matrix(rnorm(10*n), nrow = n)
by &lt;- letters[sample(1:H, n, replace = TRUE)]

# Direct calculation
res_cal(y, x)

# Calculation with pre-calculated data
precalc &lt;- res_cal(y = NULL, x)
res_cal(y, precalc = precalc)
identical(res_cal(y, x), res_cal(y, precalc = precalc))

# Matrix::TsparseMatrix capability
require(Matrix)
X &lt;- as(x, "TsparseMatrix")
Y &lt;- as(y, "TsparseMatrix")
identical(res_cal(y, x), as.matrix(res_cal(Y, X)))

# by parameter for within by-groups calculation
res_cal(Y, X, by = by)
all.equal(
 res_cal(Y, X, by = by)[by == "a", ],
  res_cal(Y[by == "a", ], X[by == "a", ])
)

</code></pre>

<hr>
<h2 id='standard_statistic_wrapper'>Standard statistic wrappers</h2><span id='topic+standard_statistic_wrapper'></span><span id='topic+total'></span><span id='topic+ratio'></span><span id='topic+mean'></span><span id='topic+diff_of_ratio'></span><span id='topic+ratio_of_ratio'></span>

<h3>Description</h3>

<p>Functions to be used within variance estimation 
wrappers in order to specify which statistic is to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>total(y, by = NULL, where = NULL)

ratio(num, denom, by = NULL, where = NULL)

mean(y, by = NULL, where = NULL)

diff_of_ratio(num1, denom1, num2, denom2, by = NULL, where = NULL)

ratio_of_ratio(num1, denom1, num2, denom2, by = NULL, where = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standard_statistic_wrapper_+3A_y">y</code></td>
<td>
<p>A vector corresponding to the variable to calculate the statitic on.
If not numeric (character or factor), it is automatically discretized.</p>
</td></tr>
<tr><td><code id="standard_statistic_wrapper_+3A_by">by</code></td>
<td>
<p>Factor vector (character vectors are coerced to factors) whose levels are used
to break down the estimation by domains.</p>
</td></tr>
<tr><td><code id="standard_statistic_wrapper_+3A_where">where</code></td>
<td>
<p>Logical vector indicating the domain to perform variance estimation on.</p>
</td></tr>
<tr><td><code id="standard_statistic_wrapper_+3A_num">num</code>, <code id="standard_statistic_wrapper_+3A_num1">num1</code>, <code id="standard_statistic_wrapper_+3A_num2">num2</code></td>
<td>
<p>Numerical vector(s) corresponding to the numerator(s) 
to be used in the estimation.</p>
</td></tr>
<tr><td><code id="standard_statistic_wrapper_+3A_denom">denom</code>, <code id="standard_statistic_wrapper_+3A_denom1">denom1</code>, <code id="standard_statistic_wrapper_+3A_denom2">denom2</code></td>
<td>
<p>Numerical vector(s) corresponding to the denominator(s) 
to be used in the estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the estimator is not the estimator of a total, the application of 
analytical variance estimation formulae developed for the estimator of a total 
is not straightforward (Deville, 1999). An asymptotically unbiased variance 
estimator can nonetheless be obtained if the estimation of variance is performed
on a variable obtained from the original data through a linerization step. 
</p>
<p>The <code>ratio</code>, <code>mean</code>, <code>diff_of_ratio</code> and <code>ratio_of_ratio</code> 
functions produce the point estimate of the statistic and derive the 
corresponding linearized variable which is later on passed on to the variance
estimation function within the variance estimation wrapper. 
</p>
<p>Note: The <code>total</code> function does not perform any linearization
(as none is needed for the estimator of a total) and solely produces the 
corresponding point estimator.
</p>


<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Caron N. (1998), &quot;Le logiciel Poulpe : aspects méthodologiques&quot;, <em>Actes 
des Journées de méthodologie statistique</em> <a href="http://jms-insee.fr/jms1998s03_1/">http://jms-insee.fr/jms1998s03_1/</a>
</p>
<p>Deville J.-C. (1999), &quot;Variance estimation for complex statistics and 
estimators: linearization and residual techniques&quot;, <em>Survey Methodology</em>, 
25:193–203
</p>


<h3>See Also</h3>

<p><code><a href="#topic+define_statistic_wrapper">define_statistic_wrapper</a></code>, <code><a href="#topic+define_variance_wrapper">define_variance_wrapper</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See qvar examples

</code></pre>

<hr>
<h2 id='sum_by'>Efficient by-group (weighted) summation</h2><span id='topic+sum_by'></span>

<h3>Description</h3>

<p><code>sum_by</code> performs an efficient and optionally weighted 
by-group summation by using linear algebra and the Matrix package 
capabilities. The by-group summation is performed through matrix cross-product
of the <code>y</code> parameter (coerced to a matrix if needed) with a (very) sparse
matrix built up using the <code>by</code> and the (optional) <code>w</code> parameters. 
</p>
<p>Compared to base R, dplyr or data.table alternatives, this implementation 
aims at being easier to use in a matrix-oriented context and can yield 
efficiency gains when the number of columns becomes high.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_by(y, by, w = NULL, na_rm = TRUE, keep_sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_by_+3A_y">y</code></td>
<td>
<p>A (sparse) vector, a (sparse) matrix or a data.frame. 
The object to perform by-group summation on.</p>
</td></tr>
<tr><td><code id="sum_by_+3A_by">by</code></td>
<td>
<p>The factor variable defining the by-groups. Character variables
are coerced to factors.</p>
</td></tr>
<tr><td><code id="sum_by_+3A_w">w</code></td>
<td>
<p>The optional row weights to be used in the summation.</p>
</td></tr>
<tr><td><code id="sum_by_+3A_na_rm">na_rm</code></td>
<td>
<p>Should <code>NA</code> values in <code>y</code> be removed (ie treated as 0 in the summation) ? 
Similar to <code>na.rm</code> argument in <code><a href="base.html#topic+sum">sum</a></code>, but <code>TRUE</code> by default. 
If <code>FALSE</code>, <code>NA</code> values in <code>y</code> produce <code>NA</code> values in the result.</p>
</td></tr>
<tr><td><code id="sum_by_+3A_keep_sparse">keep_sparse</code></td>
<td>
<p>When <code>y</code> is a sparse vector or a sparse matrix, should the result
also be sparse ? <code>FALSE</code> by default. As <code><a href="Matrix.html#topic+sparseVector-class">sparseVector-class</a></code> does
not have a name attribute, when <code>y</code> is a sparseVector the result does not have any
name (and a warning is cast).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector, a matrix or a data.frame depending on the type of <code>y</code>. If <code>y</code> is
sparse and <code>keep_sparse = TRUE</code>, then the result is also sparse (without names
when it is a sparse vector, see keep_sparse argument for details).
</p>


<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Data generation
set.seed(1)
n &lt;- 100
p &lt;- 10
H &lt;- 3
y &lt;- matrix(rnorm(n*p), ncol = p, dimnames = list(NULL, paste0("var", 1:10)))
y[1, 1] &lt;- NA
by &lt;- letters[sample.int(H, n, replace = TRUE)]
w &lt;- rep(1, n)
w[by == "a"] &lt;- 2

# Standard use
sum_by(y, by)

# Keeping the NAs
sum_by(y, by, na_rm = FALSE)

# With a weight
sum_by(y, by, w = w)

</code></pre>

<hr>
<h2 id='var_pois'>Variance estimator for a Poisson sampling design</h2><span id='topic+var_pois'></span>

<h3>Description</h3>

<p><code>var_pois</code> estimates the variance of the estimator 
of a total for a Poisson sampling design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_pois(y, pik, w = rep(1, length(pik)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_pois_+3A_y">y</code></td>
<td>
<p>A (sparse) numerical matrix of the variable(s) whose variance of their total
is to be estimated.</p>
</td></tr>
<tr><td><code id="var_pois_+3A_pik">pik</code></td>
<td>
<p>A numerical vector of first-order inclusion probabilities.</p>
</td></tr>
<tr><td><code id="var_pois_+3A_w">w</code></td>
<td>
<p>An optional numerical vector of row weights (see Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>w</code> is a row weight used at the final summation step. It is useful
when <code>var_pois</code> is used on the second stage of a two-stage sampling
design applying the Rao (1975) formula.
</p>


<h3>Value</h3>

<p>The estimated variances as a numerical vector of size the number of 
columns of <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Rao, J.N.K (1975), &quot;Unbiased variance estimation for multistage designs&quot;,
<em>Sankhya</em>, C n°37
</p>

<hr>
<h2 id='varDT'>Variance approximation with Deville-Tillé (2005) formula</h2><span id='topic+varDT'></span><span id='topic+var_srs'></span>

<h3>Description</h3>

<p><code>varDT</code> estimates the variance of the estimator of a total
in the case of a balanced sampling design with equal or unequal probabilities 
using Deville-Tillé (2005) formula. Without balancing variables, it falls back 
to Deville's (1993) classical approximation. Without balancing variables and 
with equal probabilities, it falls back to the classical Horvitz-Thompson 
variance estimator for the total in the case of simple random sampling. 
Stratification is natively supported.
</p>
<p><code>var_srs</code> is a convenience wrapper for the (stratified) simple random
sampling case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varDT(
  y = NULL,
  pik,
  x = NULL,
  strata = NULL,
  w = NULL,
  precalc = NULL,
  id = NULL
)

var_srs(y, pik, strata = NULL, w = NULL, precalc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varDT_+3A_y">y</code></td>
<td>
<p>A (sparse) numerical matrix of the variable(s) whose variance of their total
is to be estimated.</p>
</td></tr>
<tr><td><code id="varDT_+3A_pik">pik</code></td>
<td>
<p>A numerical vector of first-order inclusion probabilities.</p>
</td></tr>
<tr><td><code id="varDT_+3A_x">x</code></td>
<td>
<p>An optional (sparse) numerical matrix of balancing variable(s).</p>
</td></tr>
<tr><td><code id="varDT_+3A_strata">strata</code></td>
<td>
<p>An optional categorical vector (factor or character) when
variance estimation is to be conducted within strata.</p>
</td></tr>
<tr><td><code id="varDT_+3A_w">w</code></td>
<td>
<p>An optional numerical vector of row weights (see Details).</p>
</td></tr>
<tr><td><code id="varDT_+3A_precalc">precalc</code></td>
<td>
<p>A list of pre-calculated results (see Details).</p>
</td></tr>
<tr><td><code id="varDT_+3A_id">id</code></td>
<td>
<p>A vector of identifiers of the units used in the calculation.
Useful when <code>precalc = TRUE</code> in order to assess whether the ordering of the
<code>y</code> data matrix matches the one used at the pre-calculation step.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>varDT</code> aims at being the workhorse of most variance estimation conducted
with the <code>gustave</code> package. It may be used to estimate the variance
of the estimator of a total in the case of (stratified) simple random sampling, 
(stratified) unequal probability sampling and (stratified) balanced sampling. 
The native integration of stratification based on Matrix::TsparseMatrix allows 
for significant performance gains compared to higher level vectorizations
(<code>*apply</code> especially).
</p>
<p>Several time-consuming operations (e.g. collinearity-check, matrix
inversion) can be pre-calculated in order to speed up the estimation at
execution time. This is determined by the value of the parameters <code>y</code>
and <code>precalc</code>: </p>
 <ul>
<li><p> if <code>y</code> not <code>NULL</code> and
<code>precalc</code> <code>NULL</code> : on-the-fly calculation (no pre-calculation). 
</p>
</li>
<li><p> if <code>y</code> <code>NULL</code> and <code>precalc</code> <code>NULL</code> :
pre-calculation whose results are stored in a list of pre-calculated data. 
</p>
</li>
<li><p> if <code>y</code> not <code>NULL</code> and <code>precalc</code> not <code>NULL</code> :
calculation using the list of pre-calculated data. </p>
</li></ul>

<p><code>w</code> is a row weight used at the final summation step. It is useful
when <code>varDT</code> or <code>var_srs</code> are used on the second stage of a 
two-stage sampling design applying the Rao (1975) formula.
</p>


<h3>Value</h3>

 <ul>
<li><p> if <code>y</code> is not <code>NULL</code> (calculation step) : 
the estimated variances as a numerical vector of size the number of 
columns of y. </p>
</li>
<li><p> if <code>y</code> is <code>NULL</code> (pre-calculation step) : a list 
containing pre-calculated data.</p>
</li></ul>



<h3>Difference with <code>varest</code> from package <code>sampling</code></h3>

<p><code>varDT</code> differs from <code>sampling::varest</code> in several ways: 
</p>
 <ul>
<li><p> The formula implemented in <code>varDT</code> is more general and
encompasses balanced sampling. </p>
</li>
<li><p> Even in its reduced
form (without balancing variables), the formula implemented in <code>varDT</code>
slightly differs from the one implemented in <code>sampling::varest</code>.
Caron (1998, pp. 178-179) compares the two estimators
(<code>sampling::varest</code> implements V_2, <code>varDT</code> implements V_1). 
</p>
</li>
<li> <p><code>varDT</code> introduces several optimizations: </p>
 <ul>
<li>
<p>matrixwise operations allow to estimate variance on several interest
variables at once </p>
</li>
<li><p> Matrix::TsparseMatrix capability and the native
integration of stratification yield significant performance gains. </p>
</li>
<li>
<p>the ability to pre-calculate some time-consuming operations speeds up the
estimation at execution time. </p>
</li></ul>
 </li>
<li> <p><code>varDT</code> does not natively
implements the calibration estimator (i.e. the sampling variance estimator
that takes into account the effect of calibration). In the context of the
<code>gustave</code> package, <code><a href="#topic+res_cal">res_cal</a></code> should be called before 
<code>varDT</code> in order to achieve the same result.</p>
</li></ul>



<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>References</h3>

<p>Caron N. (1998), &quot;Le logiciel Poulpe : aspects méthodologiques&quot;, <em>Actes 
des Journées de méthodologie statistique</em> <a href="http://jms-insee.fr/jms1998s03_1/">http://jms-insee.fr/jms1998s03_1/</a>
Deville, J.-C. (1993), <em>Estimation de la variance pour les enquêtes en
deux phases</em>, Manuscript, INSEE, Paris.
</p>
<p>Deville, J.-C., Tillé, Y. (2005), &quot;Variance approximation under balanced
sampling&quot;, <em>Journal of Statistical Planning and Inference</em>, 128, issue
2 569-591
</p>
<p>Rao, J.N.K (1975), &quot;Unbiased variance estimation for multistage designs&quot;,
<em>Sankhya</em>, C n°37
</p>


<h3>See Also</h3>

<p><code><a href="#topic+res_cal">res_cal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sampling)
set.seed(1)

# Simple random sampling case
N &lt;- 1000
n &lt;- 100
y &lt;- rnorm(N)[as.logical(srswor(n, N))]
pik &lt;- rep(n/N, n)
varDT(y, pik)
sampling::varest(y, pik = pik)
N^2 * (1 - n/N) * var(y) / n

# Unequal probability sampling case
N &lt;- 1000
n &lt;- 100
pik &lt;- runif(N)
s &lt;- as.logical(UPsystematic(pik))
y &lt;- rnorm(N)[s]
pik &lt;- pik[s]
varDT(y, pik)
varest(y, pik = pik)
# The small difference is expected (see Details).

# Balanced sampling case
N &lt;- 1000
n &lt;- 100
pik &lt;- runif(N)
x &lt;- matrix(rnorm(N*3), ncol = 3)
s &lt;- as.logical(samplecube(x, pik))
y &lt;- rnorm(N)[s]
pik &lt;- pik[s]
x &lt;- x[s, ]
varDT(y, pik, x)

# Balanced sampling case (variable of interest
# among the balancing variables)
N &lt;- 1000
n &lt;- 100
pik &lt;- runif(N)
y &lt;- rnorm(N)
x &lt;- cbind(matrix(rnorm(N*3), ncol = 3), y)
s &lt;- as.logical(samplecube(x, pik))
y &lt;- y[s]
pik &lt;- pik[s]
x &lt;- x[s, ]
varDT(y, pik, x)
# As expected, the total of the variable of interest is perfectly estimated.

# strata argument
n &lt;- 100
H &lt;- 2
pik &lt;- runif(n)
y &lt;- rnorm(n)
strata &lt;- letters[sample.int(H, n, replace = TRUE)]
all.equal(
 varDT(y, pik, strata = strata),
 varDT(y[strata == "a"], pik[strata == "a"]) + varDT(y[strata == "b"], pik[strata == "b"])
)

# precalc argument
n &lt;- 1000
H &lt;- 50
pik &lt;- runif(n)
y &lt;- rnorm(n)
strata &lt;- sample.int(H, n, replace = TRUE)
precalc &lt;- varDT(y = NULL, pik, strata = strata)
identical(
 varDT(y, precalc = precalc),
 varDT(y, pik, strata = strata)
)

</code></pre>

<hr>
<h2 id='varSYG'>Sen-Yates-Grundy variance estimator</h2><span id='topic+varSYG'></span>

<h3>Description</h3>

<p><code>varSYG</code> computes the Sen-Yates-Grundy 
variance estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varSYG(y = NULL, pikl, precalc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varSYG_+3A_y">y</code></td>
<td>
<p>A (sparse) numerical matrix of the variable(s) whose variance of their total
is to be estimated.</p>
</td></tr>
<tr><td><code id="varSYG_+3A_pikl">pikl</code></td>
<td>
<p>A numerical matrix of second-order inclusion probabilities.</p>
</td></tr>
<tr><td><code id="varSYG_+3A_precalc">precalc</code></td>
<td>
<p>A list of pre-calculated results (analogous to the one used by 
<code><a href="#topic+varDT">varDT</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>varSYG</code> aims at being an efficient implementation of the 
Sen-Yates-Grundy variance estimator for sampling designs with fixed sample 
size. It should be especially useful when several variance estimations are
to be conducted, as it relies on (sparse) matrix linear algebra.
</p>
<p>Moreover, in order to be consistent with <code><a href="#topic+varDT">varDT</a></code>, <code>varSYG</code>
has a <code>precalc</code> argument allowing for the re-use of intermediary
results calculated once and for all in a pre-calculation step (see 
<code><a href="#topic+varDT">varDT</a></code> for details).
</p>


<h3>Value</h3>

 <ul>
<li><p> if <code>y</code> is not <code>NULL</code> (calculation step) : a
numerical vector of size the number of columns of y. </p>
</li>
<li><p> if <code>y</code> is
<code>NULL</code> (pre-calculation step) : a list containing pre-calculated data 
(analogous to the one used by <code><a href="#topic+varDT">varDT</a></code>).</p>
</li></ul>



<h3>Difference with <code>varHT</code> from package <code>sampling</code></h3>

<p><code>varSYG</code> differs from <code>sampling::varHT</code> in several ways: 
</p>
 <ul>
<li><p> The formula implemented in <code>varSYG</code> is solely
the Sen-Yates-Grundy estimator, which is the one calculated 
by <code>varHT</code> when method = 2.
</p>
</li>
<li> <p><code>varSYG</code> introduces several optimizations: </p>
 <ul>
<li>
<p>matrixwise operations allow to estimate variance on several interest
variables at once </p>
</li>
<li><p> Matrix::TsparseMatrix capability yields significant 
performance gains.</p>
</li></ul>
</li></ul>



<h3>Author(s)</h3>

<p>Martin Chevalier
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sampling)
set.seed(1)

# Simple random sampling case
N &lt;- 1000
n &lt;- 100
y &lt;- rnorm(N)[as.logical(srswor(n, N))]
pikl &lt;- matrix(rep((n*(n-1))/(N*(N-1)), n*n), nrow = n)
diag(pikl) &lt;- rep(n/N, n)
varSYG(y, pikl)
sampling::varHT(y = y, pikl = pikl, method = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
