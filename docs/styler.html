<!DOCTYPE html><html><head><title>Help for package styler</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {styler}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#styler-package'><p>styler: Non-Invasive Pretty Printing of R Code</p></a></li>
<li><a href='#add_cache_block'><p>Add the block id to a parse table</p></a></li>
<li><a href='#add_id_and_short'><p>Add column <code>pos_id</code> and <code>short</code></p></a></li>
<li><a href='#add_roxygen_mask'><p>Add the roxygen mask to code</p></a></li>
<li><a href='#add_spaces_or_newlines'><p>Concentrate newlines or spaces in a string</p></a></li>
<li><a href='#add_stylerignore'><p>Adds the stylerignore column</p></a></li>
<li><a href='#add_token_terminal'><p>Add information about previous / next token to each terminal</p></a></li>
<li><a href='#alignment_col1_all_named'><p>Checks if all arguments of column 1 are named</p></a></li>
<li><a href='#alignment_drop_comments'><p>Remove all comment tokens</p></a></li>
<li><a href='#alignment_drop_last_expr'><p>Remove last expression</p></a></li>
<li><a href='#alignment_ensure_no_closing_brace'><p>Ensure the closing brace of the call is removed</p></a></li>
<li><a href='#alignment_ensure_trailing_comma'><p>Ensure last pd has a trailing comma</p></a></li>
<li><a href='#alignment_has_correct_spacing_around_comma'><p>Check if spacing around comma is correct</p></a></li>
<li><a href='#alignment_has_correct_spacing_around_eq_sub'><p>Check if spacing around <code>=</code> is correct</p></a></li>
<li><a href='#alignment_serialize'><p>Serialize text from a parse table</p></a></li>
<li><a href='#alignment_serialize_column'><p>Serialize all lines for a given column</p></a></li>
<li><a href='#alignment_serialize_line'><p>Serialize one line for a column</p></a></li>
<li><a href='#apply_ref_indention'><p>Apply reference indention to tokens</p></a></li>
<li><a href='#apply_ref_indention_one'><p>Applying reference indention of a target token</p></a></li>
<li><a href='#apply_stylerignore'><p>Ensure correct positional information for stylerignore expressions</p></a></li>
<li><a href='#apply_transformers'><p>Apply transformers to a parse table</p></a></li>
<li><a href='#assert_filetype'><p>Make sure all supplied file types are allowed</p></a></li>
<li><a href='#assert_text'><p>Assert text to be of positive length and replace it with the empty</p>
string otherwise.</a></li>
<li><a href='#assert_tokens'><p>Check token validity</p></a></li>
<li><a href='#assert_transformers'><p>Assert the transformers</p></a></li>
<li><a href='#bind_with_child'><p>Bind a parse table with one of its children</p></a></li>
<li><a href='#cache_activate'><p>Activate or deactivate the styler cache</p></a></li>
<li><a href='#cache_by_expression'><p>Cache text</p></a></li>
<li><a href='#cache_clear'><p>Clear the cache</p></a></li>
<li><a href='#cache_find_block'><p>Find the groups of expressions that should be processed together</p></a></li>
<li><a href='#cache_find_path'><p>Where is the cache?</p></a></li>
<li><a href='#cache_info'><p>Show information about the styler cache</p></a></li>
<li><a href='#cache_is_activated'><p>Check if a cache is activated</p></a></li>
<li><a href='#cache_make_key'><p>Make a key for <code>R.cache</code></p></a></li>
<li><a href='#cache_more_specs'><p>Create more specs</p></a></li>
<li><a href='#cache_write'><p>Write to the cache</p></a></li>
<li><a href='#caching'><p>Remember the past to be quicker in the future</p></a></li>
<li><a href='#calls_sys'><p>Invoke a system command</p></a></li>
<li><a href='#catch_style_file_output'><p>Capture and post-process the output of <code>style_file</code> without causing side</p>
effects</a></li>
<li><a href='#choose_indention'><p>Choose the indention method for the tokens</p></a></li>
<li><a href='#combine_children'><p>Combine child and internal child</p></a></li>
<li><a href='#communicate_summary'><p>Communicate the summary of styling</p></a></li>
<li><a href='#communicate_warning'><p>Communicate a warning if necessary</p></a></li>
<li><a href='#compute_indent_indices'><p>Compute the indices that need indention</p></a></li>
<li><a href='#compute_parse_data_nested'><p>Obtain a nested parse table from a character vector</p></a></li>
<li><a href='#construct_out'><p>Construct *-out.R from a *-in.R</p></a></li>
<li><a href='#construct_tree'><p>Construct paths of a tree object given the paths of *-in.R files</p></a></li>
<li><a href='#construct_vertical'><p>Construct an object of class vertical</p></a></li>
<li><a href='#contains_else_expr_that_needs_braces'><p>Check whether an else expression needs braces</p></a></li>
<li><a href='#context_to_terminals'><p>Propagate context to terminals</p></a></li>
<li><a href='#context_towards_terminals'><p>Update the a parse table given outer context</p></a></li>
<li><a href='#convert_newlines_to_linebreaks'><p>Replace the newline character with a line break</p></a></li>
<li><a href='#copy_to_tempdir'><p>Copy a file to a temporary directory</p></a></li>
<li><a href='#create_node_from_nested'><p>Create node from nested parse data</p></a></li>
<li><a href='#create_node_from_nested_root'><p>Convert a nested data frame into a node tree</p></a></li>
<li><a href='#create_pos_ids'><p>Create valid pos_ids if possible</p></a></li>
<li><a href='#create_style_guide'><p>Create a style guide</p></a></li>
<li><a href='#create_tokens'><p>Create a terminal token</p></a></li>
<li><a href='#create_tree'><p>Create a tree from text</p></a></li>
<li><a href='#default_style_guide_attributes'><p>Initialize default style guide attributes</p></a></li>
<li><a href='#delete_if_cache_directory'><p>Delete a cache or temp directory</p></a></li>
<li><a href='#dir_without_.'><p><code>dir()</code>, but without dot-prefix and different defaults</p></a></li>
<li><a href='#dir_without_._one'><p><code>dir()</code>, but with full names, ignored case, and included hidden files and</p>
recursive.</a></li>
<li><a href='#emulate_rd'><p>Convert roxygen comments to Rd code</p></a></li>
<li><a href='#enhance_mapping_special'><p>Enhance the mapping of text to the token &quot;SPECIAL&quot;</p></a></li>
<li><a href='#enrich_terminals'><p>Enrich flattened parse table</p></a></li>
<li><a href='#ensure_correct_txt'><p>Ensure a correct <code>text</code> of all strings and numeric constants</p></a></li>
<li><a href='#ensure_last_n_empty'><p>Ensure there is one (and only one) blank line at the end of a vector</p></a></li>
<li><a href='#env_add_stylerignore'><p>Add positional information of token to next terminal</p></a></li>
<li><a href='#env_current'><p>The elements that are added to this environment are:</p></a></li>
<li><a href='#expressions_are_identical'><p>Check whether two expressions are identical</p></a></li>
<li><a href='#extend_if_comment'><p>Find the index of the last comment in the sequence of comments-only tokens</p>
after the token that has position <code>pos</code> in <code>pd</code>.</a></li>
<li><a href='#extract_terminals'><p>Extract terminal tokens</p></a></li>
<li><a href='#finalize_raw_chunks'><p>Drop start / stop, when formatting is turned off</p></a></li>
<li><a href='#find_blank_lines_to_next_block'><p>Number of lines between cache blocks</p></a></li>
<li><a href='#find_blank_lines_to_next_expr'><p>Find blank lines</p></a></li>
<li><a href='#find_dont_seqs'><p>Find <code>dontrun</code> and friend sequences</p></a></li>
<li><a href='#find_line_break_position_in_multiline_call'><p>Find index of the token before which the line should be broken</p></a></li>
<li><a href='#find_pos_id_to_keep'><p>Find the pos ids to keep</p></a></li>
<li><a href='#find_start_pos_id'><p>Find legit starting value for a new positional id</p></a></li>
<li><a href='#find_tokens_to_update'><p>Find the tokens to update when applying a reference indention</p></a></li>
<li><a href='#fix_quotes'><p>Replace single quotes with double quotes</p></a></li>
<li><a href='#flatten_operators'><p>Flatten some token in the nested parse table based on operators</p></a></li>
<li><a href='#flatten_operators_one'><p>Flatten one level of nesting with its child</p></a></li>
<li><a href='#flatten_pd'><p>Flatten a parse table</p></a></li>
<li><a href='#generate_test_samples'><p>Generate a comprehensive collection test cases for comment / insertion</p>
interaction
Test consist of if / if-else / if-else-if-else cases, paired with various
line-break and comment configurations. Used for internal testing.</a></li>
<li><a href='#get_addins_style_transformer_name'><p>Return the style function or name</p></a></li>
<li><a href='#get_engine_pattern'><p>What's the engine pattern for rmd code chunks?</p></a></li>
<li><a href='#get_knitr_pattern'><p>Get chunk pattern</p></a></li>
<li><a href='#get_parse_data'><p>Obtain robust parse data</p></a></li>
<li><a href='#has_crlf_as_first_line_sep'><p>Check if a string uses CRLF EOLs</p></a></li>
<li><a href='#hash_standardize'><p>Standardize text for hashing</p></a></li>
<li><a href='#identify_raw_chunks'><p>Identifies raw Rmd or Rnw code chunks</p></a></li>
<li><a href='#identify_start_to_stop_of_roxygen_examples_from_text'><p>Figure out where code examples start and stop</p></a></li>
<li><a href='#if_for_while_part_requires_braces'><p>Check if if, for or while loop expression require a braces.</p></a></li>
<li><a href='#initialize_attributes'><p>Initialize attributes</p></a></li>
<li><a href='#invalid_utf8'><p>Drop-in replacement for <code>xfun:::invalid_utf8()</code></p></a></li>
<li><a href='#is_cached'><p>Check if text is cached</p></a></li>
<li><a href='#is_code_chunk_header_or_xaringan_or_code_output'><p>Identify spinning code chunk header or xaringan</p></a></li>
<li><a href='#is_double_indent_function_declaration'><p>Is the function declaration double indented?</p></a></li>
<li><a href='#is_insufficiently_parsed_string'><p>Identify strings that were not fully parsed</p></a></li>
<li><a href='#is_shebang'><p>Identify comments that are shebangs</p></a></li>
<li><a href='#local_test_setup'><p>Establish testing setup for current environment</p></a></li>
<li><a href='#lookup_new_special'><p>Lookup which new tokens were created from &quot;SPECIAL&quot;</p></a></li>
<li><a href='#lookup_tokens'><p>Lookup all tokens that have a unique token-text mapping</p></a></li>
<li><a href='#make_transformer'><p>Closure to return a transformer function</p></a></li>
<li><a href='#map_filetype_to_pattern'><p>Map the file type to a corresponding regular expression</p></a></li>
<li><a href='#match_stop_to_start'><p>Match a stop candidate to a start</p></a></li>
<li><a href='#math_token_spacing'><p>Specify spacing around math tokens</p></a></li>
<li><a href='#n_times_faster_with_cache'><p>Times two function calls with temporarily enabled cache</p></a></li>
<li><a href='#needs_indention'><p>Check whether indention is needed</p></a></li>
<li><a href='#needs_indention_one'><p>Check whether indention is needed</p></a></li>
<li><a href='#needs_rd_emulation'><p>Check if rd emulation is required with <code>roxygen2::roc_proc_text()</code></p></a></li>
<li><a href='#nest_parse_data'><p>Nest a flat parse table</p></a></li>
<li><a href='#next_non_comment'><p>Find the index of the next or previous non-comment in a parse table.</p></a></li>
<li><a href='#next_terminal'><p>Tell me what the next terminal is</p></a></li>
<li><a href='#option_read'><p>Get the value of an option</p></a></li>
<li><a href='#parse_roxygen'><p>Parse roxygen comments into text</p></a></li>
<li><a href='#parse_safely'><p>Save parsing from text</p></a></li>
<li><a href='#parse_transform_serialize_r'><p>Parse, transform and serialize text</p></a></li>
<li><a href='#parse_transform_serialize_r_block'><p>Parse, transform and serialize a nested parse table</p></a></li>
<li><a href='#parse_transform_serialize_roxygen'><p>Parse, transform and serialize roxygen comments</p></a></li>
<li><a href='#parse_tree_must_be_identical'><p>Check whether a round trip verification can be carried out</p></a></li>
<li><a href='#parser_version_set'><p>Work with parser versions</p></a></li>
<li><a href='#pd_is'><p>What is a parse table representing?</p></a></li>
<li><a href='#pd_is_multi_line'><p>Check whether a parse table is a multi-line token</p></a></li>
<li><a href='#post_parse_roxygen'><p>Changing the line definition</p></a></li>
<li><a href='#prettify_any'><p>Prettify R code in current working directory</p></a></li>
<li><a href='#prettify_pkg'><p>Prettify a package</p></a></li>
<li><a href='#print.vertical'><p>Print styled code</p></a></li>
<li><a href='#read_utf8'><p>Read UTF-8</p></a></li>
<li><a href='#read_utf8_bare'><p>Drop-in replacement for <code>xfun::read_utf8()</code>, with an optional <code>warn</code></p>
argument.</a></li>
<li><a href='#reindention'><p>Specify what is re-indented how</p></a></li>
<li><a href='#remove_dont_mask'><p>Remove dont* mask</p></a></li>
<li><a href='#remove_roxygen_header'><p>Remove roxygen header</p></a></li>
<li><a href='#rep_char'><p>Repeat elements of a character vector <code>times</code> times and collapse it</p></a></li>
<li><a href='#roxygen_remove_extra_brace'><p>Fix <code>tools::parse_Rd()</code> output</p></a></li>
<li><a href='#save_after_styling_is_active'><p>Heuristic to see if a file styled with the addin should be saved or not.</p></a></li>
<li><a href='#scope_normalize'><p>Convert the styling scope to its lower-level representation</p></a></li>
<li><a href='#separate_chunks'><p>Separate chunks within Rmd and Rnw contents</p></a></li>
<li><a href='#serialize_parse_data_flattened'><p>Serialize flattened parse data</p></a></li>
<li><a href='#set_and_assert_arg_filetype'><p>Set the file type argument</p></a></li>
<li><a href='#set_arg_paths'><p>Standardize paths in root</p></a></li>
<li><a href='#set_arg_write_tree'><p>Set the write_tree argument</p></a></li>
<li><a href='#set_line_break_after_opening_if_call_is_multi_line'><p>Sets line break after opening parenthesis</p></a></li>
<li><a href='#set_line_break_around_curly_curly'><p>Styling around <code style="white-space: pre;">&#8288;\{\{&#8288;</code></p></a></li>
<li><a href='#set_line_break_before_curly_opening'><p>Set line break before a curly brace</p></a></li>
<li><a href='#set_line_break_if_call_is_multi_line'><p>Set line break for multi-line function calls</p></a></li>
<li><a href='#set_multi_line'><p>Set the multi-line column</p></a></li>
<li><a href='#set_regex_indention'><p>Set indention of tokens that match regex</p></a></li>
<li><a href='#set_space_around_op'><p>Set spaces around operators</p></a></li>
<li><a href='#set_space_between_eq_sub_and_comma'><p>Set space between <code>EQ_SUB</code> and <code>"','"</code></p></a></li>
<li><a href='#set_space_between_levels'><p>Set space between levels of nesting</p></a></li>
<li><a href='#set_spaces'><p>Helper for setting spaces</p></a></li>
<li><a href='#set_style_transformers'><p>Asks the user to supply a style</p></a></li>
<li><a href='#set_unindention_child'><p>Unindent a child if necessary</p></a></li>
<li><a href='#shallowify'><p>Shallowify the parse table</p></a></li>
<li><a href='#specify_transformers_drop'><p>Specify which tokens must be absent for a transformer to be dropped</p></a></li>
<li><a href='#split_roxygen_segments'><p>Split text into roxygen and non-roxygen example segments</p></a></li>
<li><a href='#start_comments_with_space'><p>Start comments with a space</p></a></li>
<li><a href='#style_active_pkg'><p>Wrapper around <code>style_pkg()</code> for access via Addin.</p></a></li>
<li><a href='#style_dir'><p>Prettify arbitrary R code</p></a></li>
<li><a href='#style_file'><p>Style files with R source code</p></a></li>
<li><a href='#style_guides'><p>Style guides</p></a></li>
<li><a href='#style_pkg'><p>Prettify R source code</p></a></li>
<li><a href='#style_roxygen_code_example'><p>Style a roxygen code example that may contain dontrun and friends</p></a></li>
<li><a href='#style_roxygen_code_example_one'><p>Style a roxygen code example with exactly one <code style="white-space: pre;">&#8288;@example&#8288;</code> or <code style="white-space: pre;">&#8288;@exampleIf&#8288;</code></p></a></li>
<li><a href='#style_roxygen_code_example_segment'><p>Style a roxygen code example segment</p></a></li>
<li><a href='#style_roxygen_example_snippet'><p>Given a code snippet is dont* or run, style it</p></a></li>
<li><a href='#style_selection'><p>Styles the highlighted selection in a <code>.R</code> or <code>.Rmd</code> file.</p></a></li>
<li><a href='#style_space_around_math_token'><p>Style spacing around math tokens</p></a></li>
<li><a href='#style_space_around_token'><p>Set spacing of token to a certain level</p></a></li>
<li><a href='#style_text'><p>Style a string</p></a></li>
<li><a href='#style_text_without_curly_curly'><p><code>style_text()</code> without rules for <code style="white-space: pre;">&#8288;\{\{&#8288;</code></p></a></li>
<li><a href='#styler_addins'><p>Stylers for RStudio Addins</p></a></li>
<li><a href='#stylerignore'><p>Turn off styling for parts of the code</p></a></li>
<li><a href='#stylerignore_consolidate_col'><p>Consolidate columns after a merge</p></a></li>
<li><a href='#test_collection'><p>Run a collection of tests</p></a></li>
<li><a href='#test_dry'><p>Test the dry argument</p></a></li>
<li><a href='#test_transformer'><p>Transforming test input with a transformer function</p></a></li>
<li><a href='#test_transformers_drop'><p>Test <code>transformers_drop</code> for consistency</p></a></li>
<li><a href='#testthat_file'><p>Create the path to a test that file</p></a></li>
<li><a href='#text_to_flat_pd'><p>Creates a flat parse table with minimal initialization</p></a></li>
<li><a href='#tidyverse_style'><p>The tidyverse style</p></a></li>
<li><a href='#token_is_on_aligned_line'><p>Check if tokens are aligned</p></a></li>
<li><a href='#tokenize'><p>Obtain token table from text</p></a></li>
<li><a href='#transform_and_check'><p>Transform a file an check the result</p></a></li>
<li><a href='#transform_code'><p>Transform code from R, Rmd or Rnw files</p></a></li>
<li><a href='#transform_file'><p>Transform a file and output a customized message</p></a></li>
<li><a href='#transform_files'><p>Transform files with transformer functions</p></a></li>
<li><a href='#transform_mixed'><p>Transform mixed contents</p></a></li>
<li><a href='#transform_mixed_non_empty'><p>Ensure for <code>.Rmd</code> and friends that a code chunk without code is formatted as</p>
a code chunk without any lines.</a></li>
<li><a href='#transform_utf8'><p>Apply a function to the contents of a file</p></a></li>
<li><a href='#transform_utf8_one'><p>Potentially transform a file</p></a></li>
<li><a href='#transformers_drop'><p>Remove transformers that are not needed</p></a></li>
<li><a href='#try_transform_as_r_file'><p>Style a file as if it was an .R file</p></a></li>
<li><a href='#unindent_child'><p>Unindent a child</p></a></li>
<li><a href='#unindent_fun_dec'><p>Revert the indention of function declaration header</p></a></li>
<li><a href='#update_indention'><p>Update indention information of parse data</p></a></li>
<li><a href='#update_indention_ref'><p>Update the indention reference</p></a></li>
<li><a href='#update_newlines'><p>Update the newlines attribute</p></a></li>
<li><a href='#validate_new_pos_ids'><p>Validate sequence of new position ids</p></a></li>
<li><a href='#verify_roundtrip'><p>Verify the styling</p></a></li>
<li><a href='#visit'><p>Visit'em all</p></a></li>
<li><a href='#visit_one'><p>Transform a flat parse table with a list of transformers</p></a></li>
<li><a href='#wrap_else_multiline_curly'><p>Add curly braces to else</p></a></li>
<li><a href='#wrap_expr_in_curly'><p>Wrap an expression in curly braces</p></a></li>
<li><a href='#wrap_expr_in_expr'><p>Wrap an expression into an expression</p></a></li>
<li><a href='#wrap_if_else_while_for_fun_multi_line_in_curly'><p>Wrap if-else, while and for statements in curly braces</p></a></li>
<li><a href='#wrap_multiline_curly'><p>Wrap a multi-line statement in curly braces</p></a></li>
<li><a href='#wrap_subexpr_in_curly'><p>Wrap a sub-expression in curly braces</p></a></li>
<li><a href='#write_utf8'><p>Drop-in replacement for <code>xfun::write_utf8()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Invasive Pretty Printing of R Code</td>
</tr>
<tr>
<td>Version:</td>
<td>1.10.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Pretty-prints R code without changing the user's formatting
    intent.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/styler">https://github.com/r-lib/styler</a>, <a href="https://styler.r-lib.org">https://styler.r-lib.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/styler/issues">https://github.com/r-lib/styler/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli (&ge; 3.1.1), magrittr (&ge; 2.0.0), purrr (&ge; 0.2.3), R.cache
(&ge; 0.15.0), rlang (&ge; 1.0.0), rprojroot (&ge; 1.1), tools, vctrs
(&ge; 0.4.1), withr (&ge; 2.3.0),</td>
</tr>
<tr>
<td>Suggests:</td>
<td>data.tree (&ge; 0.1.6), digest, here, knitr, prettycode,
rmarkdown, roxygen2, rstudioapi (&ge; 0.7), tibble (&ge; 1.4.2),
testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Collate:</td>
<td>'addins.R' 'communicate.R' 'compat-dplyr.R' 'compat-tidyr.R'
'detect-alignment-utils.R' 'detect-alignment.R'
'environments.R' 'expr-is.R' 'indent.R' 'initialize.R' 'io.R'
'nest.R' 'nested-to-tree.R' 'parse.R' 'reindent.R'
'token-define.R' 'relevel.R' 'roxygen-examples-add-remove.R'
'roxygen-examples-find.R' 'roxygen-examples-parse.R'
'roxygen-examples.R' 'rules-indention.R' 'rules-line-breaks.R'
'rules-spaces.R' 'rules-tokens.R' 'serialize.R'
'set-assert-args.R' 'style-guides.R' 'styler-package.R'
'stylerignore.R' 'testing-mocks.R' 'testing-public-api.R'
'ui-caching.R' 'testing.R' 'token-create.R' 'transform-block.R'
'transform-code.R' 'transform-files.R' 'ui-styling.R'
'unindent.R' 'utils-cache.R' 'utils-files.R'
'utils-navigate-nest.R' 'utils-strings.R' 'utils.R'
'vertical.R' 'visit.R' 'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-07 19:04:20 UTC; lorenz</td>
</tr>
<tr>
<td>Author:</td>
<td>Kirill Müller <a href="https://orcid.org/0000-0002-1416-3412"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Lorenz Walthert [cre, aut],
  Indrajeet Patil <a href="https://orcid.org/0000-0003-1995-6531"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (@patilindrajeets)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lorenz Walthert &lt;lorenz.walthert@icloud.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-07 23:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='styler-package'>styler: Non-Invasive Pretty Printing of R Code</h2><span id='topic+styler'></span><span id='topic+styler-package'></span>

<h3>Description</h3>

<p>styler allows you to format <code>.qmd</code>, <code>.R</code>, <code>.Rmd</code>, <code>.Rmarkdown</code>,
<code>.Rnw</code>, and/or <code>.Rprofile</code> files, R packages, or entire R source trees
according to a style guide.
The following functions can be used for styling:
</p>

<ul>
<li> <p><code><a href="#topic+style_text">style_text()</a></code> to style a character vector.
</p>
</li>
<li> <p><code><a href="#topic+style_file">style_file()</a></code> to style a single file.
</p>
</li>
<li> <p><code><a href="#topic+style_dir">style_dir()</a></code> to style all files in a directory.
</p>
</li>
<li> <p><code><a href="#topic+style_pkg">style_pkg()</a></code> to style the source files of an R package.
</p>
</li>
<li> <p><a href="#topic+styler_addins">RStudio Addins</a> to style either selected code or the
active file.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Lorenz Walthert <a href="mailto:lorenz.walthert@icloud.com">lorenz.walthert@icloud.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Kirill Müller <a href="mailto:kirill@cynkra.com">kirill@cynkra.com</a> (<a href="https://orcid.org/0000-0002-1416-3412">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Indrajeet Patil <a href="mailto:patilindrajeet.science@gmail.com">patilindrajeet.science@gmail.com</a> (<a href="https://orcid.org/0000-0003-1995-6531">ORCID</a>) (@patilindrajeets) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/styler">https://github.com/r-lib/styler</a>
</p>
</li>
<li> <p><a href="https://styler.r-lib.org">https://styler.r-lib.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/styler/issues">https://github.com/r-lib/styler/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>style_text("call( 1)")
style_text("1    + 1", strict = FALSE)
style_text("a%&gt;%b", scope = "spaces")
style_text("a%&gt;%b; a", scope = "line_breaks")
style_text("a%&gt;%b; a", scope = "tokens")
</code></pre>

<hr>
<h2 id='add_cache_block'>Add the block id to a parse table</h2><span id='topic+add_cache_block'></span>

<h3>Description</h3>

<p>Must be after <code><a href="#topic+nest_parse_data">nest_parse_data()</a></code> because requires a nested parse table as
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_cache_block(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_cache_block_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A top-level nest.</p>
</td></tr>
</table>

<hr>
<h2 id='add_id_and_short'>Add column <code>pos_id</code> and <code>short</code></h2><span id='topic+add_id_and_short'></span>

<h3>Description</h3>

<p>Adds column <code>pos_id</code> and <code>short</code> to a flat parse table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_id_and_short(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_id_and_short_+3A_pd">pd</code></td>
<td>
<p>A flat parse table</p>
</td></tr>
</table>

<hr>
<h2 id='add_roxygen_mask'>Add the roxygen mask to code</h2><span id='topic+add_roxygen_mask'></span>

<h3>Description</h3>

<p>This function compares <code>text</code> with <code>initial_text</code> to make sure a mask is only
added to roxygen comments, not ordinary comments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_roxygen_mask(text, initial_text, example_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_roxygen_mask_+3A_text">text</code></td>
<td>
<p>Character vector with code.</p>
</td></tr>
<tr><td><code id="add_roxygen_mask_+3A_initial_text">initial_text</code></td>
<td>
<p>The roxygen code example to style with mask and
potentially ordinary comments.</p>
</td></tr>
<tr><td><code id="add_roxygen_mask_+3A_example_type">example_type</code></td>
<td>
<p>Either 'examples' or 'examplesIf'.</p>
</td></tr>
</table>

<hr>
<h2 id='add_spaces_or_newlines'>Concentrate newlines or spaces in a string</h2><span id='topic+add_spaces_or_newlines'></span><span id='topic+add_newlines'></span><span id='topic+add_spaces'></span>

<h3>Description</h3>

<p>Concentrate newlines or spaces in a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_newlines(n)

add_spaces(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_spaces_or_newlines_+3A_n">n</code></td>
<td>
<p>Scalar indicating how many characters should be concentrated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string.
</p>

<hr>
<h2 id='add_stylerignore'>Adds the stylerignore column</h2><span id='topic+add_stylerignore'></span>

<h3>Description</h3>

<p>If a token should be ignored, the column is set to <code>TRUE</code>,
otherwise to <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_stylerignore(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_stylerignore_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A token is ignored iff one of the two conditions hold:
</p>

<ul>
<li><p> it falls between a start and a stop marker whereas the markers are on
their own line. Which tokens are recognized as markers is controlled with
the R options <code>styler.ignore_start</code> and <code>styler.ignore_stop</code>.
</p>
</li>
<li><p> it is not a comment, but the last token on the line is a marker.
</p>
</li></ul>

<p>See examples in <a href="#topic+stylerignore">stylerignore</a>. Note that you should reuse the stylerignore
column to compute switch points or similar and not a plain
<code>pd$text %in% option_read("styler.ignore_start")</code> because that will fail to
give correct switch points in the case stylerignore sequences are invalid.
</p>

<hr>
<h2 id='add_token_terminal'>Add information about previous / next token to each terminal</h2><span id='topic+add_token_terminal'></span><span id='topic+add_terminal_token_after'></span><span id='topic+add_terminal_token_before'></span><span id='topic+add_attributes_caching'></span>

<h3>Description</h3>

<p>Note that this does function must be called in <code><a href="#topic+compute_parse_data_nested">compute_parse_data_nested()</a></code>
and we cannot wait to initialize this attribute until <code><a href="#topic+apply_transformers">apply_transformers()</a></code>,
where all other attributes are initialized with
<code><a href="#topic+default_style_guide_attributes">default_style_guide_attributes()</a></code> (when using <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>) because
for cached code, we don't build up the nested structure and leave it shallow
(to speed up things), see also <code><a href="#topic+shallowify">shallowify()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_terminal_token_after(pd_flat)

add_terminal_token_before(pd_flat)

add_attributes_caching(pd_flat, transformers, more_specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_token_terminal_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table.</p>
</td></tr>
<tr><td><code id="add_token_terminal_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="add_token_terminal_+3A_more_specs">more_specs</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>add_attributes_caching()</code>: Initializes <code>newlines</code> and <code>lag_newlines</code>.
</p>
</li></ul>

<hr>
<h2 id='alignment_col1_all_named'>Checks if all arguments of column 1 are named</h2><span id='topic+alignment_col1_all_named'></span>

<h3>Description</h3>

<p>Checks if all arguments of column 1 are named
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_col1_all_named(relevant_pd_by_line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_col1_all_named_+3A_relevant_pd_by_line">relevant_pd_by_line</code></td>
<td>
<p>A list with parse tables of a multi-line call,
excluding first and last column.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_drop_comments'>Remove all comment tokens</h2><span id='topic+alignment_drop_comments'></span>

<h3>Description</h3>

<p>Must be after split by line because it invalidates (lag)newlines, which are
used for splitting by line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_drop_comments(pd_by_line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_drop_comments_+3A_pd_by_line">pd_by_line</code></td>
<td>
<p>A list, each element corresponding to a potentially
incomplete parse table that represents all token from one line.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_drop_last_expr'>Remove last expression</h2><span id='topic+alignment_drop_last_expr'></span>

<h3>Description</h3>

<p>In a <em>nest</em>, if the last token is an <code>expr</code>, the <em>nest</em> represents either
an if, while or for statement or a function call. We don't call about that
part, in fact it's important to remove it for alignment. See 'Examples'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_drop_last_expr(pds_by_line)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
call(
  x = 12,
  y =  3,
)

function(a = 33,
         qq = 4) {
  # we don't care about this part for alignment detection
}

</code></pre>

<hr>
<h2 id='alignment_ensure_no_closing_brace'>Ensure the closing brace of the call is removed</h2><span id='topic+alignment_ensure_no_closing_brace'></span>

<h3>Description</h3>

<p>Must be after dropping comments because the closing brace is only guaranteed
to be the last token in that case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_ensure_no_closing_brace(pd_by_line, last_line_droped_early)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_ensure_no_closing_brace_+3A_pd_by_line">pd_by_line</code></td>
<td>
<p>A list, each element corresponding to a potentially
incomplete parse table that represents all token from one line.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_ensure_trailing_comma'>Ensure last pd has a trailing comma</h2><span id='topic+alignment_ensure_trailing_comma'></span>

<h3>Description</h3>

<p>Must be after <code><a href="#topic+alignment_ensure_no_closing_brace">alignment_ensure_no_closing_brace()</a></code> because if it comes after
<code><a href="#topic+alignment_ensure_trailing_comma">alignment_ensure_trailing_comma()</a></code>, the last expression would not be a
brace, which would make removal complicated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_ensure_trailing_comma(pd_by_line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_ensure_trailing_comma_+3A_pd_by_line">pd_by_line</code></td>
<td>
<p>A list, each element corresponding to a potentially
incomplete parse table that represents all token from one line.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_has_correct_spacing_around_comma'>Check if spacing around comma is correct</h2><span id='topic+alignment_has_correct_spacing_around_comma'></span>

<h3>Description</h3>

<p>At least one space after comma, none before, for all but the last comma on
the line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_has_correct_spacing_around_comma(pd_sub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_has_correct_spacing_around_comma_+3A_pd_sub">pd_sub</code></td>
<td>
<p>The subset of a parse table corresponding to one line.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_has_correct_spacing_around_eq_sub'>Check if spacing around <code>=</code> is correct</h2><span id='topic+alignment_has_correct_spacing_around_eq_sub'></span>

<h3>Description</h3>

<p>At least one space around <code>EQ_SUB</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_has_correct_spacing_around_eq_sub(pd_sub)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_has_correct_spacing_around_eq_sub_+3A_pd_sub">pd_sub</code></td>
<td>
<p>The subset of a parse table corresponding to one line.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_serialize'>Serialize text from a parse table</h2><span id='topic+alignment_serialize'></span>

<h3>Description</h3>

<p>Line breaks are ignored as they are expected to be checked in
<code><a href="#topic+token_is_on_aligned_line">token_is_on_aligned_line()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_serialize(pd_sub)
</code></pre>

<hr>
<h2 id='alignment_serialize_column'>Serialize all lines for a given column</h2><span id='topic+alignment_serialize_column'></span>

<h3>Description</h3>

<p>Serialize all lines for a given column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_serialize_column(relevant_pd_by_line, column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_serialize_column_+3A_relevant_pd_by_line">relevant_pd_by_line</code></td>
<td>
<p>A list with parse tables of a multi-line call,
excluding first and last column.</p>
</td></tr>
<tr><td><code id="alignment_serialize_column_+3A_column">column</code></td>
<td>
<p>The index of the column to serialize.</p>
</td></tr>
</table>

<hr>
<h2 id='alignment_serialize_line'>Serialize one line for a column</h2><span id='topic+alignment_serialize_line'></span>

<h3>Description</h3>

<p>Serialize one line for a column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignment_serialize_line(relevant_pd_by_line, column)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignment_serialize_line_+3A_relevant_pd_by_line">relevant_pd_by_line</code></td>
<td>
<p>A list with parse tables of a multi-line call,
excluding first and last column.</p>
</td></tr>
<tr><td><code id="alignment_serialize_line_+3A_column">column</code></td>
<td>
<p>The index of the column to serialize.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_ref_indention'>Apply reference indention to tokens</h2><span id='topic+apply_ref_indention'></span>

<h3>Description</h3>

<p>Applies the reference indention created with functions
<code><a href="#topic+update_indention_ref">update_indention_ref()</a></code> to the flattened parse table. The indention
is applied to all token that inherit from a reference token sequentially,
i.e. by looping over the target tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_ref_indention(flattened_pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_ref_indention_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table</p>
</td></tr>
</table>

<hr>
<h2 id='apply_ref_indention_one'>Applying reference indention of a target token</h2><span id='topic+apply_ref_indention_one'></span>

<h3>Description</h3>

<p>Applies the indention level of <code>target_token</code> to all tokens that have
<code>target_token</code> as a reference. This includes adding spaces to the first
tokens on a line and updating the column <code>col1</code> and <code>col2</code> for all tokens
on that line so they are kept updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_ref_indention_one(flattened_pd, target_token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_ref_indention_one_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table</p>
</td></tr>
<tr><td><code id="apply_ref_indention_one_+3A_target_token">target_token</code></td>
<td>
<p>The index of the token from which the indention level
should be applied to other tokens.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_stylerignore'>Ensure correct positional information for stylerignore expressions</h2><span id='topic+apply_stylerignore'></span>

<h3>Description</h3>

<p>Ensure correct positional information for stylerignore expressions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_stylerignore(flattened_pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_stylerignore_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Get the positional information for tokens with a stylerignore tag from
<code>env_current</code>, which recorded that information from the input text.
</p>
</li>
<li><p> Replace the computed lag_newlines and lag_spaces information in the parse
table with this information.
</p>
</li>
<li><p> Because we may remove or add tokens when applying the transformers, it is
not save to merge via the pos_id of each token in a stylerignore sequence.
We assume that the start and stop markers are the same after styling, so we
join all tokens that were initially in a stylerignore sequence via the
first pos_id in that stylerignore sequence.
</p>
</li></ul>


<hr>
<h2 id='apply_transformers'>Apply transformers to a parse table</h2><span id='topic+apply_transformers'></span>

<h3>Description</h3>

<p>The column <code>multi_line</code> is updated (after the line break information is
modified) and the rest of the transformers are applied afterwards,
The former requires two pre visits and one post visit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_transformers(pd_nested, transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_transformers_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="apply_transformers_+3A_transformers">transformers</code></td>
<td>
<p>A list of <em>named</em> transformer functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The order of the transformations is:
</p>

<ul>
<li><p> Initialization (must be first).
</p>
</li>
<li><p> Line breaks (must be before spacing due to indention).
</p>
</li>
<li><p> Update of newline and multi-line attributes (must not change afterwards,
hence line breaks must be modified first).
</p>
</li>
<li><p> spacing rules (must be after line-breaks and updating newlines and
multi-line).
</p>
</li>
<li><p> indention.
</p>
</li>
<li><p> token manipulation / replacement (is last since adding and removing tokens
will invalidate columns token_after and token_before).
</p>
</li>
<li><p> Update indention reference (must be after line breaks).
</p>
</li></ul>


<hr>
<h2 id='assert_filetype'>Make sure all supplied file types are allowed</h2><span id='topic+assert_filetype'></span>

<h3>Description</h3>

<p>Make sure all supplied file types are allowed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_filetype(lowercase_filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_filetype_+3A_lowercase_filetype">lowercase_filetype</code></td>
<td>
<p>A vector with file types to check, all lower case.</p>
</td></tr>
</table>

<hr>
<h2 id='assert_text'>Assert text to be of positive length and replace it with the empty
string otherwise.</h2><span id='topic+assert_text'></span>

<h3>Description</h3>

<p>Assert text to be of positive length and replace it with the empty
string otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_text(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_text_+3A_text">text</code></td>
<td>
<p>The input to style.</p>
</td></tr>
</table>

<hr>
<h2 id='assert_tokens'>Check token validity</h2><span id='topic+assert_tokens'></span>

<h3>Description</h3>

<p>Check whether one or more tokens exist and have a unique token-text mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_tokens(tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_tokens_+3A_tokens">tokens</code></td>
<td>
<p>Tokens to check.</p>
</td></tr>
</table>

<hr>
<h2 id='assert_transformers'>Assert the transformers</h2><span id='topic+assert_transformers'></span>

<h3>Description</h3>

<p>Actually only assert name and version of style guide in order to make sure
caching works correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_transformers(transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_transformers_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions that operate on flat
parse tables.</p>
</td></tr>
</table>

<hr>
<h2 id='bind_with_child'>Bind a parse table with one of its children</h2><span id='topic+bind_with_child'></span>

<h3>Description</h3>

<p>Bind a parse table with one of its children and return parse table, ordered
according to the appearance of the tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_with_child(pd_nested, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_with_child_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="bind_with_child_+3A_pos">pos</code></td>
<td>
<p>The position of the child to bind.</p>
</td></tr>
</table>

<hr>
<h2 id='cache_activate'>Activate or deactivate the styler cache</h2><span id='topic+cache_activate'></span><span id='topic+cache_deactivate'></span>

<h3>Description</h3>

<p>Helper functions to control the behavior of caching. Simple wrappers around
<code><a href="base.html#topic+options">base::options()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_activate(cache_name = NULL, verbose = !getOption("styler.quiet", FALSE))

cache_deactivate(verbose = !getOption("styler.quiet", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_activate_+3A_cache_name">cache_name</code></td>
<td>
<p>The name of the styler cache to use. If
<code>NULL</code>, the option &quot;styler.cache_name&quot; is considered which defaults to
the version of styler used.</p>
</td></tr>
<tr><td><code id="cache_activate_+3A_verbose">verbose</code></td>
<td>
<p>Whether or not to print an informative message about what the
function is doing.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cache managers: 
<code><a href="#topic+cache_clear">cache_clear</a>()</code>,
<code><a href="#topic+cache_info">cache_info</a>()</code>,
<code><a href="#topic+caching">caching</a></code>
</p>

<hr>
<h2 id='cache_by_expression'>Cache text</h2><span id='topic+cache_by_expression'></span>

<h3>Description</h3>

<p>Splits <code>text</code> into expressions and adds these to the cache. Note that
top-level comments are <strong>not</strong> cached because caching and in particular
checking  if they are cached is too expensive. Comments may be cached as part
of the whole text (as opposed to on an expression by expression basis) using
<code>cache_write()</code> directly. Also, we must not cache stylerignore sequence,
because we might see the same expression that does not comply with the style
guide outside a stylerignore sequence and wrongly think we should leave it as
is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_by_expression(text, transformers, more_specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_by_expression_+3A_text">text</code></td>
<td>
<p>A character vector with one or more expressions.</p>
</td></tr>
<tr><td><code id="cache_by_expression_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions, because we can only
know if text is already correct if we know which transformer function it
should be styled with.</p>
</td></tr>
<tr><td><code id="cache_by_expression_+3A_more_specs">more_specs</code></td>
<td>
<p>A named vector coercible to character that determines the
styling but are style guide independent, such as <code>include_roxygen_examples</code>
or <code>base_indention</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='cache_clear'>Clear the cache</h2><span id='topic+cache_clear'></span>

<h3>Description</h3>

<p>Clears the cache that stores which files are already styled. You won't be
able to undo this. Note that the file corresponding to the cache (a folder
on your file system) won't be deleted, but it will be empty after calling
<code>cache_clear</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_clear(cache_name = NULL, ask = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_clear_+3A_cache_name">cache_name</code></td>
<td>
<p>The name of the styler cache to use. If
<code>NULL</code>, the option &quot;styler.cache_name&quot; is considered which defaults to
the version of styler used.</p>
</td></tr>
<tr><td><code id="cache_clear_+3A_ask">ask</code></td>
<td>
<p>Whether or not to interactively ask the user again.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each version of styler has its own cache by default, because styling is
potentially different with different versions of styler.
</p>


<h3>See Also</h3>

<p>Other cache managers: 
<code><a href="#topic+cache_activate">cache_activate</a>()</code>,
<code><a href="#topic+cache_info">cache_info</a>()</code>,
<code><a href="#topic+caching">caching</a></code>
</p>

<hr>
<h2 id='cache_find_block'>Find the groups of expressions that should be processed together</h2><span id='topic+cache_find_block'></span>

<h3>Description</h3>

<p>Find the groups of expressions that should be processed together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_find_block(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_find_block_+3A_pd">pd</code></td>
<td>
<p>A top-level nest.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We want blocks to be formed according to these rules:
</p>

<ul>
<li><p> Blocks should contain either cached or uncached expressions only. If a
block contains cached expressions only, it does not have to be processed
and can be returned immediately. If a block contains uncached expressions,
it makes sense to put as many uncached expression in it, since processing
one bigger block has less overhead than processing many smaller blocks.
</p>
</li>
<li><p> Multiple expressions can sit on one row, e.g. in-line comment and commands
separated with &quot;;&quot;. This creates a problem when processing each expression
separately because when putting them together, we need complicated handling
of line breaks between them, as it is not <em>a priori</em> clear that there is a
line break separating them. To avoid this, we put top-level expressions
that sit on the same line into one block, so the assumption that there is a
line break between each block of expressions holds.
</p>
</li>
<li><p> All expressions in a stylerignore sequence must be in the same block. If
that's not the case, the first expression in a block might not be a
top-level terminal, but another top-level expression.
<code><a href="#topic+apply_stylerignore">apply_stylerignore()</a></code>  joins <code>env_current$stylerignore</code>, which contains
only terminals, with the first expression in a stylerignore sequence, based
on the first <code>pos_id</code> in that stylerignore sequence
(<code>first_pos_id_in_segment</code>).
</p>
</li></ul>


<hr>
<h2 id='cache_find_path'>Where is the cache?</h2><span id='topic+cache_find_path'></span>

<h3>Description</h3>

<p>Finds the path to the cache and creates it if it does not exist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_find_path(cache_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_find_path_+3A_cache_name">cache_name</code></td>
<td>
<p>The name of the styler cache to use. If
<code>NULL</code>, the option &quot;styler.cache_name&quot; is considered which defaults to
the version of styler used.</p>
</td></tr>
</table>

<hr>
<h2 id='cache_info'>Show information about the styler cache</h2><span id='topic+cache_info'></span>

<h3>Description</h3>

<p>Gives information about the cache. Note that the size consumed by the cache
will always be displayed as zero because all the cache does is creating an
empty file of size 0 bytes for every cached expression. The inode is
excluded from this displayed size but negligible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_info(cache_name = NULL, format = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_info_+3A_cache_name">cache_name</code></td>
<td>
<p>The name of the cache for which to show details. If
<code>NULL</code>, the active cache is used. If none is active the cache corresponding
to the installed styler version is used.</p>
</td></tr>
<tr><td><code id="cache_info_+3A_format">format</code></td>
<td>
<p>Either &quot;lucid&quot; for a summary emitted with <code><a href="base.html#topic+cat">base::cat()</a></code>,
&quot;tabular&quot; for a tabular summary from <code><a href="base.html#topic+file.info">base::file.info()</a></code> or &quot;both&quot; for
both.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other cache managers: 
<code><a href="#topic+cache_activate">cache_activate</a>()</code>,
<code><a href="#topic+cache_clear">cache_clear</a>()</code>,
<code><a href="#topic+caching">caching</a></code>
</p>

<hr>
<h2 id='cache_is_activated'>Check if a cache is activated</h2><span id='topic+cache_is_activated'></span>

<h3>Description</h3>

<p>Check if a cache is activated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_is_activated(cache_name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_is_activated_+3A_cache_name">cache_name</code></td>
<td>
<p>The name of the cache to check. If <code>NULL</code>, we check if
any cache is activated. If not <code>NULL</code>, we check if a specific cache is
activated.</p>
</td></tr>
</table>

<hr>
<h2 id='cache_make_key'>Make a key for <code>R.cache</code></h2><span id='topic+cache_make_key'></span>

<h3>Description</h3>

<p>This is used to determine if caching already corresponds to a style guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_make_key(text, transformers, more_specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_make_key_+3A_text">text</code></td>
<td>
<p>Code to create a cache for. This should be styled text, as the
approach used by styler does not cache input, but styled code.</p>
</td></tr>
<tr><td><code id="cache_make_key_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions, because we can only
know if text is already correct if we know which transformer function it
should be styled with.</p>
</td></tr>
<tr><td><code id="cache_make_key_+3A_more_specs">more_specs</code></td>
<td>
<p>A named vector coercible to character that determines the
styling but are style guide independent, such as <code>include_roxygen_examples</code>
or <code>base_indention</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We need to compare:
</p>

<ul>
<li><p> text to style. Will be passed to hash function as is.
</p>
</li>
<li><p> styler version. Not an issue because for every version of styler, we build
a new cache.
</p>
</li>
<li><p> transformers. Cannot easily hash them because two environments won't be
identical even if they contain the same objects (see 'Experiments'). Simple
<code>as.character(transformers)</code> will not consider infinitively recursive
code dependencies.
To fix this, transformers must have names and version number as described
in <code><a href="#topic+create_style_guide">create_style_guide()</a></code>. Now, the only way to fool the cache invalidation
is to replace a transformer with the same function body (but changing
the function definition of the functions called in that body) interactively
without changing version number of name at the same time.
Remaining problem: <code>purrr::partial()</code> calls will render generic code, e.g.
see <code>as.character(list(purrr::partial(sum, x = 4)))</code>. For that reason,
all arguments passed to a <code>purrr::partial()</code> call must be put in the
style guide under <code>more_specs_style_guide</code>.
</p>
</li></ul>



<h3>Experiments</h3>

<p>There is unexplainable behavior in conjunction with hashing and
environments:
</p>

<ul>
<li><p> Functions created with <code>purrr::partial()</code> are not identical when compared
with <code>identical()</code>
(<a href="https://stackoverflow.com/questions/58656033/when-are-purrrpartial-ized-functions-identical">StackOverflow</a>)
</p>
</li>
<li><p> except when they have the exact same parent environment, which must be an
object created and then passed to <code>purrr::partial(.env = ...)</code>, not
created in-place.
</p>
</li>
<li> <p><code>purrr::partial()</code> seems to ignore <code>.env</code> after version 0.2.5, so until
this is fixed, we'd have to work with version 0.2.5.
</p>
</li>
<li><p> Our caching backend package, <code>R.cache</code>, uses
<code>R.cache:::getChecksum.default</code> (which uses <code>digest::digest()</code>) to hash the
input. The latter does not seem to care if the environments are exactly
equal (see 'Examples').
</p>
</li>
<li><p> However, under some circumstances, it does: Commit 9c94c022 (if not
overwritten / rebased by now) contains a reprex. Otherwise, search for
43219ixmypi in commit messages and restore this commit to reproduce the
behavior.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>add &lt;- function(x, y) {
  x + y
}
add1 &lt;- purrr::partial(add, x = 1)
add2 &lt;- purrr::partial(add, x = 1)
identical(add1, add2)
identical(digest::digest(add1), digest::digest(add2))
identical(digest::digest(styler::tidyverse_style()), digest::digest(styler::tidyverse_style()))
</code></pre>

<hr>
<h2 id='cache_more_specs'>Create more specs</h2><span id='topic+cache_more_specs'></span>

<h3>Description</h3>

<p>Syntactic sugar for creating more specs. This is useful when we want to add
more arguments (because we can search for this function in the source code).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_more_specs(include_roxygen_examples, base_indention)
</code></pre>

<hr>
<h2 id='cache_write'>Write to the cache</h2><span id='topic+cache_write'></span>

<h3>Description</h3>

<p>Write to the cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cache_write(text, transformers, more_specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cache_write_+3A_text">text</code></td>
<td>
<p>Code to create a cache for. This should be styled text, as the
approach used by styler does not cache input, but styled code.</p>
</td></tr>
<tr><td><code id="cache_write_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions, because we can only
know if text is already correct if we know which transformer function it
should be styled with.</p>
</td></tr>
<tr><td><code id="cache_write_+3A_more_specs">more_specs</code></td>
<td>
<p>A named vector coercible to character that determines the
styling but are style guide independent, such as <code>include_roxygen_examples</code>
or <code>base_indention</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='caching'>Remember the past to be quicker in the future</h2><span id='topic+caching'></span>

<h3>Description</h3>

<p>Caching makes styler faster on repeated styling and is shared across all APIs
(e.g. <code>style_text()</code> and Addin). That means if you style code that already
complies to a style guide and you have previously styled that code, it will
be quicker.
</p>


<h3>Configuring the cache</h3>

<p>To comply with the CRAN policy, {styler} will by default clean up cache files
that are older than 6 days. This implies that you loose the benefit of the cache
for the files not styled in the last 6 days.
</p>
<p>If you want to avoid this, i.e., if you want the cache to last longer, you can use the
R option <code>styler.cache_root</code> to opt for an indefinitely long-lived cache by setting it to
<code>options(styler.cache_root = "styler-perm")</code>.
</p>
<p>If you are happy with the cache being cleared after 6 days, you can confirm the default and
silence this message by setting it instead to <code>options(styler.cache_root = "styler")</code>.
</p>
<p>You can make this change in your <code>.Rprofile</code> using <code>usethis::edit_r_profile()</code>.
</p>


<h3>Manage the cache</h3>

<p>See <code><a href="#topic+cache_info">cache_info()</a></code>,<code><a href="#topic+cache_activate">cache_activate()</a></code> or <code><a href="#topic+cache_clear">cache_clear()</a></code> for utilities to
manage the cache. You can deactivate it altogether with <code><a href="#topic+cache_deactivate">cache_deactivate()</a></code>.
Since we leverage <code>{R.cache}</code> to manage the cache, you can also use any
<code>{R.cache}</code> functionality to manipulate it.
</p>
<p>In some cases, you want to use a non-standard cache location. In
that situation, you can set the path to the cache with the R option
<code>R.cache.rootPath</code> or the environment variable <code>R_CACHE_ROOTPATH</code> to an
existent path before you call the styler API.
</p>


<h3>Invalidation</h3>

<p>The cache is specific to a version of styler by default, because different
versions potentially format code differently. This means after upgrading
styler or a style guide you use, the cache will be re-built.
</p>


<h3>Mechanism and size</h3>

<p>The cache works by storing hashed output code as a whole and by expression,
which is why it takes zero space on disk (the cache is a directory with
empty files which have the hash of output code as name).
</p>
<p>The cache literally takes zero space on your disk, only the inode, and you
can always manually clean up with <code><a href="#topic+cache_clear">cache_clear()</a></code> or just go to the
directory where the cache lives (find it with <code><a href="#topic+cache_info">cache_info()</a></code>) and manually
delete files.
</p>


<h3>Using a cache for styler in CI/CD</h3>

<p>If you want to set up caching in a CI/CD pipeline, we suggest to set the
<code>{R.cache}</code> root path to a directory for which you have the cache enabled.
This can often be set in config files of CI/CD tools, e.g. see the
<a href="https://docs.travis-ci.com/user/caching">Travis documentation on caching</a>.
</p>


<h3>See Also</h3>

<p>Other cache managers: 
<code><a href="#topic+cache_activate">cache_activate</a>()</code>,
<code><a href="#topic+cache_clear">cache_clear</a>()</code>,
<code><a href="#topic+cache_info">cache_info</a>()</code>
</p>

<hr>
<h2 id='calls_sys'>Invoke a system command</h2><span id='topic+calls_sys'></span>

<h3>Description</h3>

<p>Wraps a system command into <code><a href="base.html#topic+shell">shell()</a></code> or <code><a href="base.html#topic+system">system()</a></code>, depending on the
operating system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calls_sys(sys_call, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calls_sys_+3A_sys_call">sys_call</code></td>
<td>
<p>The call to be executed.</p>
</td></tr>
<tr><td><code id="calls_sys_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+shell">shell()</a></code> or <code><a href="base.html#topic+system">system()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='catch_style_file_output'>Capture and post-process the output of <code>style_file</code> without causing side
effects</h2><span id='topic+catch_style_file_output'></span>

<h3>Description</h3>

<p>Capture and post-process the output of <code>style_file</code> without causing side
effects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catch_style_file_output(file_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="catch_style_file_output_+3A_file_in">file_in</code></td>
<td>
<p>A vector with paths relative to <code>tests/testthat</code> the path
to the reference file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list. Each element is a character vector with the captured output of
<code><a href="#topic+style_file">style_file()</a></code> called on
<code>file_in</code> ran in a temp dir to avoid side effects on the input file (because
the next time the test would ran, the file would not need styling). The
styling is carried out with a temporary working directory change to keep
filenames relative and avoid portability issues in the exact output
comparison which is needed when the system that runs the unit testing (CI)
is a different system than the one that created the reference value.
This also implies that the ruler width, which depend on the path
length, will again have the same width on all systems and is independent of
how many characters the path of the temporary directory has.
</p>

<hr>
<h2 id='choose_indention'>Choose the indention method for the tokens</h2><span id='topic+choose_indention'></span>

<h3>Description</h3>

<p>Either use the raw indention, which is just the spaces computed between
the first token on a new line and the token before it, or use the indention
computed according to the transformer used, which is stored in the column
<code>indention</code>.
All indention information will be combined with the space information for
the first token on a new line.
If <code>use_raw_indention</code> is set, information in the column <code>indention</code> will
be discarded anyways. If it is not set, the first token on a new line will
&quot;inherit&quot; the indention of the whole line.
The column <code>indention</code> will be removed since all information necessary is
contained in the spacing information of the first token on a new line and
the position of the tokens will not be changed anymore at this stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>choose_indention(flattened_pd, use_raw_indention)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="choose_indention_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A nested parse table that was turned into a flat parse
table using <code><a href="#topic+extract_terminals">extract_terminals()</a></code>.</p>
</td></tr>
<tr><td><code id="choose_indention_+3A_use_raw_indention">use_raw_indention</code></td>
<td>
<p>Boolean indicating whether or not the raw indention
should be used.</p>
</td></tr>
</table>

<hr>
<h2 id='combine_children'>Combine child and internal child</h2><span id='topic+combine_children'></span>

<h3>Description</h3>

<p>Binds two parse tables together and arranges them so that the tokens are in
the correct order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_children(child, internal_child)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_children_+3A_child">child</code></td>
<td>
<p>A parse table or <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="combine_children_+3A_internal_child">internal_child</code></td>
<td>
<p>A parse table or <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Essentially, this is a wrapper around vctrs::vec_rbind()], but
returns <code>NULL</code> if the result of vctrs::vec_rbind()] is a data frame with
zero rows.
</p>

<hr>
<h2 id='communicate_summary'>Communicate the summary of styling</h2><span id='topic+communicate_summary'></span>

<h3>Description</h3>

<p>Communicate the summary of styling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communicate_summary(changed, ruler_width)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communicate_summary_+3A_changed">changed</code></td>
<td>
<p>Boolean with indicating for each file whether or not it has
been changed.</p>
</td></tr>
<tr><td><code id="communicate_summary_+3A_ruler_width">ruler_width</code></td>
<td>
<p>Integer used to determine the width of the ruler.</p>
</td></tr>
</table>

<hr>
<h2 id='communicate_warning'>Communicate a warning if necessary</h2><span id='topic+communicate_warning'></span>

<h3>Description</h3>

<p>If round trip verification was not possible, issue a warning to review the
changes carefully.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>communicate_warning(changed, transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="communicate_warning_+3A_changed">changed</code></td>
<td>
<p>Boolean with indicating for each file whether or not it has
been changed.</p>
</td></tr>
<tr><td><code id="communicate_warning_+3A_transformers">transformers</code></td>
<td>
<p>The list of transformer functions used for styling.
Needed for reverse engineering the scope.</p>
</td></tr>
</table>

<hr>
<h2 id='compute_indent_indices'>Compute the indices that need indention</h2><span id='topic+compute_indent_indices'></span>

<h3>Description</h3>

<p>Based on <code>token</code>, find the rows in <code>pd</code> that need to be indented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_indent_indices(pd, token_opening, token_closing = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_indent_indices_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="compute_indent_indices_+3A_token_opening">token_opening</code></td>
<td>
<p>A character vector with tokens that could induce
indention for subsequent tokens.</p>
</td></tr>
<tr><td><code id="compute_indent_indices_+3A_token_closing">token_closing</code></td>
<td>
<p>A character vector with tokens that could terminate
indention for previous tokens. If <code>NULL</code> (the default), indention should
end with the last token in the parse table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two cases are fundamentally different:
</p>

<ul>
<li><p> Indention based on operators (e.g '+'), where all subsequent tokens should
be indented.
</p>
</li>
<li><p> Indention based on braces (e.g. '('), where just the tokens between the
opening and the closing brace have to be indented.
</p>
</li></ul>

<p>To cover the second case, we need <code>token_closing</code> because it cannot be taken
for granted that <code>token_closing</code> is always the last token in <code>pd</code>. For
example in if-else expressions, this is not the case and indenting
everything between '(' and the penultimate token would result in the wrong
formatting.
</p>


<h3>Handing of <code>[[</code></h3>

<p>Since text <code>[[</code> has token <code>"LBB"</code> and text <code style="white-space: pre;">&#8288;]]&#8288;</code> is parsed as two independent
<code style="white-space: pre;">&#8288;]&#8288;</code> (see 'Examples'), indention has to stop at the first <code style="white-space: pre;">&#8288;]&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::parse_text("a[1]")
styler:::parse_text("a[[1\n]]")
</code></pre>

<hr>
<h2 id='compute_parse_data_nested'>Obtain a nested parse table from a character vector</h2><span id='topic+compute_parse_data_nested'></span>

<h3>Description</h3>

<p>Parses <code>text</code> to a flat parse table and subsequently changes its
representation into a nested parse table with <code><a href="#topic+nest_parse_data">nest_parse_data()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_parse_data_nested(
  text,
  transformers = tidyverse_style(),
  more_specs = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_parse_data_nested_+3A_text">text</code></td>
<td>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="compute_parse_data_nested_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="compute_parse_data_nested_+3A_more_specs">more_specs</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested parse table. See <code><a href="#topic+tokenize">tokenize()</a></code> for details on the columns
of the parse table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- "
ab     &lt;- 1L # some comment
abcdef &lt;- 2L
"
writeLines(code)
compute_parse_data_nested(code)
</code></pre>

<hr>
<h2 id='construct_out'>Construct *-out.R from a *-in.R</h2><span id='topic+construct_out'></span>

<h3>Description</h3>

<p>Multiple *-in.R files can have the same *-out.R file since to create the
*-out.R file, everything after the first dash is replaced by *-out.R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_out(in_paths)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_out_+3A_in_paths">in_paths</code></td>
<td>
<p>A character vector that denotes paths to *-in.R files.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::construct_out(c(
  "path/to/file/first-in.R",
  "path/to/file/first-extended-in.R"
))
</code></pre>

<hr>
<h2 id='construct_tree'>Construct paths of a tree object given the paths of *-in.R files</h2><span id='topic+construct_tree'></span>

<h3>Description</h3>

<p>Construct paths of a tree object given the paths of *-in.R files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_tree(in_paths, suffix = "_tree")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_tree_+3A_in_paths">in_paths</code></td>
<td>
<p>Character vector of *-in.R files.</p>
</td></tr>
<tr><td><code id="construct_tree_+3A_suffix">suffix</code></td>
<td>
<p>Suffix for the tree object.</p>
</td></tr>
</table>

<hr>
<h2 id='construct_vertical'>Construct an object of class vertical</h2><span id='topic+construct_vertical'></span>

<h3>Description</h3>

<p>Sole purpose of the class vertical is to have a print method that
aligns the output vertically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>construct_vertical(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="construct_vertical_+3A_x">x</code></td>
<td>
<p>A character vector or an object of class &quot;vertical&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='contains_else_expr_that_needs_braces'>Check whether an else expression needs braces</h2><span id='topic+contains_else_expr_that_needs_braces'></span>

<h3>Description</h3>

<p>Checks whether an else expression in a nest needs braces. Note that for
if-else-if expressions, there is no need to add braces since the if in
else-if will be visited separately with the visitor. This applies to all
conditional statements with more than one alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_else_expr_that_needs_braces(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_else_expr_that_needs_braces_+3A_pd">pd</code></td>
<td>
<p>A parse table</p>
</td></tr>
</table>

<hr>
<h2 id='context_to_terminals'>Propagate context to terminals</h2><span id='topic+context_to_terminals'></span>

<h3>Description</h3>

<p>Implements a very specific pre-visiting scheme, namely to propagate
indention, spaces and lag_newlines to inner token to terminals. This means
that information regarding indention, line breaks and spaces (which is
relative in <code>pd_nested</code>) will be converted into absolute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>context_to_terminals(
  pd_nested,
  outer_lag_newlines,
  outer_indent,
  outer_spaces,
  outer_indention_refs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_to_terminals_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="context_to_terminals_+3A_outer_lag_newlines">outer_lag_newlines</code></td>
<td>
<p>The lag_newlines to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_to_terminals_+3A_outer_indent">outer_indent</code></td>
<td>
<p>The indention depth to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_to_terminals_+3A_outer_spaces">outer_spaces</code></td>
<td>
<p>The number of spaces to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_to_terminals_+3A_outer_indention_refs">outer_indention_refs</code></td>
<td>
<p>The reference pos id that should be propagated
inwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated parse table.
</p>


<h3>See Also</h3>

<p>context_towards_terminals visitors
</p>

<hr>
<h2 id='context_towards_terminals'>Update the a parse table given outer context</h2><span id='topic+context_towards_terminals'></span>

<h3>Description</h3>

<p><code>outer_lag_newlines</code> are added to the first token in <code>pd</code>,
<code>outer_indent</code> is added to all tokens in <code>pd</code>, <code>outer_spaces</code> is added to the
last token in <code>pd</code>. <code><a href="#topic+context_to_terminals">context_to_terminals()</a></code> calls this function repeatedly,
which means the propagation of the parse information to the terminal tokens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>context_towards_terminals(
  pd_nested,
  outer_lag_newlines,
  outer_indent,
  outer_spaces,
  outer_indention_refs
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="context_towards_terminals_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="context_towards_terminals_+3A_outer_lag_newlines">outer_lag_newlines</code></td>
<td>
<p>The lag_newlines to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_towards_terminals_+3A_outer_indent">outer_indent</code></td>
<td>
<p>The indention depth to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_towards_terminals_+3A_outer_spaces">outer_spaces</code></td>
<td>
<p>The number of spaces to be propagated inwards.</p>
</td></tr>
<tr><td><code id="context_towards_terminals_+3A_outer_indention_refs">outer_indention_refs</code></td>
<td>
<p>The reference pos id that should be propagated
inwards.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An updated parse table.
</p>


<h3>See Also</h3>

<p>context_to_terminals
</p>

<hr>
<h2 id='convert_newlines_to_linebreaks'>Replace the newline character with a line break</h2><span id='topic+convert_newlines_to_linebreaks'></span>

<h3>Description</h3>

<p>Replace the newline character with a line break
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_newlines_to_linebreaks(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_newlines_to_linebreaks_+3A_text">text</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::convert_newlines_to_linebreaks("x\n2")
# a simple strsplit approach does not cover both cases
unlist(strsplit("x\n\n2", "\n", fixed = TRUE))
unlist(strsplit(c("x", "", "2"), "\n", fixed = TRUE))
styler:::convert_newlines_to_linebreaks(c("x", "2"))
</code></pre>

<hr>
<h2 id='copy_to_tempdir'>Copy a file to a temporary directory</h2><span id='topic+copy_to_tempdir'></span>

<h3>Description</h3>

<p>Takes the path to a file as input and returns the path where the temporary
file is stored. Don't forget to unlink once you are done.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_to_tempdir(path_perm = testthat_file())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copy_to_tempdir_+3A_path_perm">path_perm</code></td>
<td>
<p>The path of the file to copy.</p>
</td></tr>
</table>

<hr>
<h2 id='create_node_from_nested'>Create node from nested parse data</h2><span id='topic+create_node_from_nested'></span>

<h3>Description</h3>

<p>Create node from nested parse data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_node_from_nested(pd_nested, parent, structure_only)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_node_from_nested_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested data frame.</p>
</td></tr>
<tr><td><code id="create_node_from_nested_+3A_parent">parent</code></td>
<td>
<p>The parent of the node to be created.</p>
</td></tr>
<tr><td><code id="create_node_from_nested_+3A_structure_only">structure_only</code></td>
<td>
<p>Whether or not create a tree that represents the
structure of the expression without any information on the tokens. Useful
to check whether two structures are identical.</p>
</td></tr>
</table>

<hr>
<h2 id='create_node_from_nested_root'>Convert a nested data frame into a node tree</h2><span id='topic+create_node_from_nested_root'></span>

<h3>Description</h3>

<p>This function is convenient to display all nesting levels of a nested data frame
at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_node_from_nested_root(pd_nested, structure_only)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_node_from_nested_root_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested data frame.</p>
</td></tr>
<tr><td><code id="create_node_from_nested_root_+3A_structure_only">structure_only</code></td>
<td>
<p>Whether or not create a tree that represents the
structure of the expression without any information on the tokens. Useful
to check whether two structures are identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;Node&quot; and &quot;R6&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("data.tree")) {
  withr::with_options(
    list(styler.cache_name = NULL), # temporarily deactivate cache
    {
      code &lt;- "a &lt;- function(x) { if(x &gt; 1) { 1+1 } else {x} }"
      nested_pd &lt;- compute_parse_data_nested(code)
      initialized &lt;- styler:::pre_visit_one(
        nested_pd, default_style_guide_attributes
      )
      styler:::create_node_from_nested_root(initialized,
        structure_only = FALSE
      )
    }
  )
}
</code></pre>

<hr>
<h2 id='create_pos_ids'>Create valid pos_ids if possible</h2><span id='topic+create_pos_ids'></span>

<h3>Description</h3>

<p>Create valid pos_ids if possible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_pos_ids(pd, pos, by = 0.1, after = FALSE, n = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_pos_ids_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="create_pos_ids_+3A_pos">pos</code></td>
<td>
<p>The position where the new id should be inserted.</p>
</td></tr>
<tr><td><code id="create_pos_ids_+3A_by">by</code></td>
<td>
<p>By how much the reference <code>pos_id</code> should be increased / decreased
to create a new id.</p>
</td></tr>
<tr><td><code id="create_pos_ids_+3A_after">after</code></td>
<td>
<p>Boolean indicating whether it should be inserted after or before
<code>pos</code>.</p>
</td></tr>
<tr><td><code id="create_pos_ids_+3A_n">n</code></td>
<td>
<p>Number of ids to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a valid sequences of pos_ids or an error if it was not possible to
create one. The validation is done with <code><a href="#topic+validate_new_pos_ids">validate_new_pos_ids()</a></code>
</p>


<h3>See Also</h3>

<p>Other token creators: 
<code><a href="#topic+create_tokens">create_tokens</a>()</code>,
<code><a href="#topic+validate_new_pos_ids">validate_new_pos_ids</a>()</code>
</p>

<hr>
<h2 id='create_style_guide'>Create a style guide</h2><span id='topic+create_style_guide'></span>

<h3>Description</h3>

<p>This is a helper function to create a style guide, which is technically
speaking a named list of groups of transformer functions where each
transformer function corresponds to one styling rule. The output of this
function can be used as an argument for <code>style</code> in top-level functions
like <code><a href="#topic+style_text">style_text()</a></code> and friends. Note that for caching to work properly,
unquote all inputs to the transformer function if possible with rlang's <code style="white-space: pre;">&#8288;!!&#8288;</code>,
otherwise, they will be passed as references (generic variable names) instead
of literals and <code>styler:::is_cached()</code> won't pick up changes. See how it's
done in <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> with <code>indent_by</code> and other arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_style_guide(
  initialize = default_style_guide_attributes,
  line_break = NULL,
  space = NULL,
  token = NULL,
  indention = NULL,
  use_raw_indention = FALSE,
  reindention = tidyverse_reindention(),
  style_guide_name = NULL,
  style_guide_version = NULL,
  more_specs_style_guide = NULL,
  transformers_drop = specify_transformers_drop(),
  indent_character = " "
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_style_guide_+3A_initialize">initialize</code></td>
<td>
<p>The bare name of a function that initializes various
variables on each level of nesting.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_line_break">line_break</code></td>
<td>
<p>A list of transformer functions that manipulate line_break
information.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_space">space</code></td>
<td>
<p>A list of transformer functions that manipulate spacing
information.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_token">token</code></td>
<td>
<p>A list of transformer functions that manipulate token text.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_indention">indention</code></td>
<td>
<p>A list of transformer functions that manipulate indention.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_use_raw_indention">use_raw_indention</code></td>
<td>
<p>Boolean indicating whether or not the raw indention
should be used.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_reindention">reindention</code></td>
<td>
<p>A list of parameters for regex re-indention, most
conveniently constructed using <code><a href="#topic+specify_reindention">specify_reindention()</a></code>.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_style_guide_name">style_guide_name</code></td>
<td>
<p>The name of the style guide. Used as a meta attribute
inside the created style guide, for example for caching. By convention,
this is the style guide qualified by the package namespace plus the
location of the style guide, separated by <code>@</code>. For example,
<code>"styler::tidyverse_style@https://github.com/r-lib"</code>.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_style_guide_version">style_guide_version</code></td>
<td>
<p>The version of the style guide. Used as a meta
attribute inside the created style guide, for example for caching. This
should correspond to the version of the R package that exports the
style guide.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_more_specs_style_guide">more_specs_style_guide</code></td>
<td>
<p>Named vector (coercible to character)
with all arguments passed to the style guide and used for cache
invalidation. You can easily capture them in your style guide function
declaration with <code>as.list(environment())</code> (compare source code of
<code>tidyverse_style()</code>).</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_transformers_drop">transformers_drop</code></td>
<td>
<p>A list specifying under which conditions
transformer functions can be dropped since they have no effect on the
code to format, most easily constructed with
<code><a href="#topic+specify_transformers_drop">specify_transformers_drop()</a></code>. This is argument experimental and may
change in future releases without prior notification. It was mainly
introduced to improve speed. Listing transformers here that occur almost
always in code does not make sense because the process of excluding them
also takes some time.</p>
</td></tr>
<tr><td><code id="create_style_guide_+3A_indent_character">indent_character</code></td>
<td>
<p>The character that is used for indention. We strongly
advise for using spaces as indention characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set_line_break_before_curly_opening &lt;- function(pd_flat) {
  op &lt;- pd_flat$token %in% "'{'"
  pd_flat$lag_newlines[op] &lt;- 1L
  pd_flat
}
set_line_break_before_curly_opening_style &lt;- function() {
  create_style_guide(
    line_break = list(set_line_break_before_curly_opening),
    style_guide_name = "some-style-guide",
    style_guide_version = "some-version"
  )
}
style_text(
  "a &lt;- function(x) { x }",
  style = set_line_break_before_curly_opening_style
)
</code></pre>

<hr>
<h2 id='create_tokens'>Create a terminal token</h2><span id='topic+create_tokens'></span>

<h3>Description</h3>

<p>Creates a terminal token represented as (a row of) a parse table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tokens(
  tokens,
  texts,
  lag_newlines = 0L,
  spaces = 0L,
  pos_ids,
  token_before = NA,
  token_after = NA,
  indention_ref_pos_ids = NA,
  indents,
  terminal = TRUE,
  child = NULL,
  stylerignore,
  block = NA,
  is_cached = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tokens_+3A_tokens">tokens</code></td>
<td>
<p>Character vector with tokens to create.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_texts">texts</code></td>
<td>
<p>Character vector with texts of the token to create.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_lag_newlines">lag_newlines</code></td>
<td>
<p>Character vector with lag_newlines corresponding to the
tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_spaces">spaces</code></td>
<td>
<p>Character vector with spaces corresponding to the tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_pos_ids">pos_ids</code></td>
<td>
<p>Character vector with positional id corresponding to the
tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_token_before">token_before</code></td>
<td>
<p>Character vector corresponding to the columns
<code>token_before</code>.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_token_after">token_after</code></td>
<td>
<p>Character vector corresponding to the columns
<code>token_after</code>.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_indention_ref_pos_ids">indention_ref_pos_ids</code></td>
<td>
<p>Character vector with indention ref ids
corresponding to the tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_indents">indents</code></td>
<td>
<p>Vector with indents corresponding to the tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_terminal">terminal</code></td>
<td>
<p>Boolean vector indicating whether a token is a terminal or
not.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_child">child</code></td>
<td>
<p>The children of the tokens.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_stylerignore">stylerignore</code></td>
<td>
<p>Boolean to indicate if the line should be ignored by
styler. Must take value from token before, can't have a default.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_block">block</code></td>
<td>
<p>The block (of caching) to which the token belongs. An integer.</p>
</td></tr>
<tr><td><code id="create_tokens_+3A_is_cached">is_cached</code></td>
<td>
<p>Whether the token is cached already.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other token creators: 
<code><a href="#topic+create_pos_ids">create_pos_ids</a>()</code>,
<code><a href="#topic+validate_new_pos_ids">validate_new_pos_ids</a>()</code>
</p>

<hr>
<h2 id='create_tree'>Create a tree from text</h2><span id='topic+create_tree'></span>

<h3>Description</h3>

<p>Create a tree representation from a text.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_tree(text, structure_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_tree_+3A_text">text</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="create_tree_+3A_structure_only">structure_only</code></td>
<td>
<p>Whether or not create a tree that represents the
structure of the expression without any information on the tokens. Useful
to check whether two structures are identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='default_style_guide_attributes'>Initialize default style guide attributes</h2><span id='topic+default_style_guide_attributes'></span>

<h3>Description</h3>

<p>This function initializes and removes various variables from the parse
table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_style_guide_attributes(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_style_guide_attributes_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>withr::with_options(
  list(styler.cache_name = NULL), # temporarily deactivate cache
  {
    string_to_format &lt;- "call( 3)"
    pd &lt;- compute_parse_data_nested(string_to_format)
    styler:::pre_visit_one(pd, default_style_guide_attributes)
  }
)
</code></pre>

<hr>
<h2 id='delete_if_cache_directory'>Delete a cache or temp directory</h2><span id='topic+delete_if_cache_directory'></span>

<h3>Description</h3>

<p>For safety, <code>path</code> is only deleted if it is a sub-directory of a temporary
directory or user cache. Since this function relies on <code>tools::R_user_dir()</code>,
it early returns <code>FALSE</code> on <code style="white-space: pre;">&#8288;R &lt; 4.0.0&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete_if_cache_directory(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_if_cache_directory_+3A_path">path</code></td>
<td>
<p>Absolute path to a directory to delete.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if anything was deleted, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='dir_without_.'><code>dir()</code>, but without dot-prefix and different defaults</h2><span id='topic+dir_without_.'></span>

<h3>Description</h3>

<p>When using <code>dir()</code>, you can set <code>full.names = FALSE</code>, but then you can only
pass a character vector of length one as <code>path</code> to not loose the information
about where the files are. This function solves that case. It's needed when
one wants to standardize paths to use set operations on them, i.e. when the
user supplied input does not have a dot prefix. See 'Examples'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_without_.(path, recursive = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir_without_._+3A_path">path</code></td>
<td>
<p>A path.</p>
</td></tr>
<tr><td><code id="dir_without_._+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="base.html#topic+list.files">base::dir()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For different defaults, see <code>dir_without_._one</code>.
</p>


<h3>See Also</h3>

<p>set_and_assert_arg_paths
</p>


<h3>Examples</h3>

<pre><code class='language-R'>setdiff("./file.R", "file.R") # you want to standardize first.
</code></pre>

<hr>
<h2 id='dir_without_._one'><code>dir()</code>, but with full names, ignored case, and included hidden files and
recursive.</h2><span id='topic+dir_without_._one'></span>

<h3>Description</h3>

<p><code>dir()</code>, but with full names, ignored case, and included hidden files and
recursive.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_without_._one(path, recursive, ...)
</code></pre>

<hr>
<h2 id='emulate_rd'>Convert roxygen comments to Rd code</h2><span id='topic+emulate_rd'></span>

<h3>Description</h3>

<p>We leverage roxygen2 workhorse function <code><a href="roxygen2.html#topic+roc_proc_text">roxygen2::roc_proc_text()</a></code> if
our input contains character that have to be escaped. Since this is an
expensive operation, we opt out of it and perform a simple
<code>remove_roxygen_mask()</code> when there are no characters to escape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>emulate_rd(roxygen)
</code></pre>

<hr>
<h2 id='enhance_mapping_special'>Enhance the mapping of text to the token &quot;SPECIAL&quot;</h2><span id='topic+enhance_mapping_special'></span>

<h3>Description</h3>

<p>Map text corresponding to the token &quot;SPECIAL&quot; to a (more) unique token
description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enhance_mapping_special(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enhance_mapping_special_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='enrich_terminals'>Enrich flattened parse table</h2><span id='topic+enrich_terminals'></span>

<h3>Description</h3>

<p>Enriches a flattened parse table with terminals only. In particular, it is
possible to compute the exact position a token will have (line and column)
when it will be serialized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enrich_terminals(flattened_pd, use_raw_indention = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enrich_terminals_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A nested parse table that was turned into a flat parse
table using <code><a href="#topic+extract_terminals">extract_terminals()</a></code>.</p>
</td></tr>
<tr><td><code id="enrich_terminals_+3A_use_raw_indention">use_raw_indention</code></td>
<td>
<p>Boolean indicating whether or not the raw indention
should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Since we have only terminal tokens now, the line on which a token starts we
also be the line on which it ends. We call <code>line1</code> the line on which the
token starts. <code>line1</code> has the same meaning as <code>line1</code> that can be found in a
flat parse table (see <code><a href="#topic+tokenize">tokenize()</a></code>), just that the <code>line1</code> created by
<code>enrich_terminals()</code> is the updated version of the former <code>line1</code>. The same
applies for <code>col1</code> and <code>col2</code>. Note that this function does remove the
columns <code>indent</code> and <code>spaces.</code> All information of the former is stored in
<code>lag_spaces</code> now. The later was removed because it is redundant after adding
the column <code>lag_spaces</code>, which is more convenient to work with, in particular
when serializing the parse table.
</p>

<hr>
<h2 id='ensure_correct_txt'>Ensure a correct <code>text</code> of all strings and numeric constants</h2><span id='topic+ensure_correct_txt'></span>

<h3>Description</h3>

<p>Make sure <code>text</code> of the tokens <code>STR_CONST</code> and <code>NUM_CONST</code> is correct and
adapt if necessary. We replace offending <code>text</code> in the terminal expressions
with the text of their parents if their line / col position matches and
return an error otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_correct_txt(pd, text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ensure_correct_txt_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='ensure_last_n_empty'>Ensure there is one (and only one) blank line at the end of a vector</h2><span id='topic+ensure_last_n_empty'></span>

<h3>Description</h3>

<p>Ensure there is one (and only one) blank line at the end of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensure_last_n_empty(x, n = 1L)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::ensure_last_n_empty("")
styler:::ensure_last_n_empty(letters)
styler:::ensure_last_n_empty(c(letters, "", "", ""))
</code></pre>

<hr>
<h2 id='env_add_stylerignore'>Add positional information of token to next terminal</h2><span id='topic+env_add_stylerignore'></span>

<h3>Description</h3>

<p>This is needed because at serialization time, we also have terminals only
and positional argument of non-terminals were already propagated to terminals
with <code><a href="#topic+context_to_terminals">context_to_terminals()</a></code>. Because tokens can be added or removed during
styling, we must not only keep the pos_id, but rather we must remember the
pos_id of the first token in the stylerignore sequence (the marker, or the
first token on a line if the stylerignore marker is an inline marker), for
which we know it will still be there, and join these markers later with all
tokens in the stylerignore sequence (this is a one to many join, i.e. one
start marker can have many tokens).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_add_stylerignore(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="env_add_stylerignore_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='env_current'>The elements that are added to this environment are:</h2><span id='topic+env_current'></span>

<h3>Description</h3>

<p>The elements that are added to this environment are:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>env_current
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 0.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>parser_version</code>: Needed to dispatch between parser versions, see
<code><a href="#topic+parser_version_set">parser_version_set()</a></code> for details.
</p>
</li>
<li> <p><code>stylerignore</code>: A data frame with parse data containing tokens that fall within
a stylerignore sequence. This is used after serializing the flattened
parse table to apply the initial formatting to these tokens. See
<a href="#topic+stylerignore">stylerignore</a> for details.
</p>
</li>
<li> <p><code>any_stylerignore</code>: Whether there is any stylerignore marker. The idea is
to check early in the runtime if this is the case and then if so, take
as many short-cuts as possible. See <a href="#topic+stylerignore">stylerignore</a> for details.
</p>
</li></ul>


<hr>
<h2 id='expressions_are_identical'>Check whether two expressions are identical</h2><span id='topic+expressions_are_identical'></span>

<h3>Description</h3>

<p>Check whether two expressions are identical
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expressions_are_identical(old_text, new_text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expressions_are_identical_+3A_old_text">old_text</code></td>
<td>
<p>The initial expression in its character representation.</p>
</td></tr>
<tr><td><code id="expressions_are_identical_+3A_new_text">new_text</code></td>
<td>
<p>The styled expression in its character representation.</p>
</td></tr>
</table>

<hr>
<h2 id='extend_if_comment'>Find the index of the last comment in the sequence of comments-only tokens
after the token that has position <code>pos</code> in <code>pd</code>.</h2><span id='topic+extend_if_comment'></span>

<h3>Description</h3>

<p>Find the index of the last comment in the sequence of comments-only tokens
after the token that has position <code>pos</code> in <code>pd</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extend_if_comment(pd, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extend_if_comment_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="extend_if_comment_+3A_pos">pos</code></td>
<td>
<p>The position of the token to start the search from.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_terminals'>Extract terminal tokens</h2><span id='topic+extract_terminals'></span>

<h3>Description</h3>

<p>Turns a nested parse table into a flat parse table and extracts <em>all</em>
attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_terminals(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_terminals_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='finalize_raw_chunks'>Drop start / stop, when formatting is turned off</h2><span id='topic+finalize_raw_chunks'></span>

<h3>Description</h3>

<p>If <code>tidy = FALSE</code> (the knitr code chunk default), code is not styled upon
knitting. If it is explicitly added to a code chunk, the code chunk is in
addition not styled with styler when formatting the document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finalize_raw_chunks(start, end, filetype, lines)
</code></pre>

<hr>
<h2 id='find_blank_lines_to_next_block'>Number of lines between cache blocks</h2><span id='topic+find_blank_lines_to_next_block'></span>

<h3>Description</h3>

<p>This is relevant when putting expressions together into a block and preserve
blank lines between them. Note that because code does not need to start on
line 1, the first element of the output is the number of lines until the
first block.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_blank_lines_to_next_block(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_blank_lines_to_next_block_+3A_pd">pd</code></td>
<td>
<p>A top-level nest.</p>
</td></tr>
</table>

<hr>
<h2 id='find_blank_lines_to_next_expr'>Find blank lines</h2><span id='topic+find_blank_lines_to_next_expr'></span>

<h3>Description</h3>

<p>What number of line breaks lay between the expressions?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_blank_lines_to_next_expr(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_blank_lines_to_next_expr_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The line number on which the first token occurs.
</p>

<hr>
<h2 id='find_dont_seqs'>Find <code>dontrun</code> and friend sequences</h2><span id='topic+find_dont_seqs'></span>

<h3>Description</h3>

<p>Returns the indices of the lines that correspond to a <code>dontrun</code> or
friends sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_dont_seqs(bare)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_dont_seqs_+3A_bare">bare</code></td>
<td>
<p>Bare code.</p>
</td></tr>
</table>

<hr>
<h2 id='find_line_break_position_in_multiline_call'>Find index of the token before which the line should be broken</h2><span id='topic+find_line_break_position_in_multiline_call'></span>

<h3>Description</h3>

<p>Given a multi-line function call parse table, this function finds the
position of the first named argument and breaks returns the index of it.
If there is no named argument, the line is broken right after the opening
parenthesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_line_break_position_in_multiline_call(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_line_break_position_in_multiline_call_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='find_pos_id_to_keep'>Find the pos ids to keep</h2><span id='topic+find_pos_id_to_keep'></span>

<h3>Description</h3>

<p>To make a parse table shallow, we must know which ids to keep.
<code>split(cumsum(pd_parent_first$parent == 0L))</code> above puts comments with
negative parents in the same block as proceeding expressions (but also with
positive).
<code>find_pos_id_to_keep()</code> must hence always keep negative comments. We did not
use <code>split(cumsum(pd_parent_first$parent &lt; 1L))</code> because then every top-level
comment is an expression on its own and processing takes much longer for
typical roxygen annotated code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_pos_id_to_keep(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_pos_id_to_keep_+3A_pd">pd</code></td>
<td>
<p>A temporary top-level nest where the first expression is always a
top-level expression, potentially cached.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that top-level comments <strong>above</strong> code have negative parents
(the negative value of the parent of the code expression that follows after,
another comment might be in the way though), all comments that are not top
level have positive ids. All comments for which no code follows afterwards
have parent 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::get_parse_data(c("#", "1"))
styler:::get_parse_data(c("c(#", "1)"))
styler:::get_parse_data(c("", "c(#", "1)", "#"))
</code></pre>

<hr>
<h2 id='find_start_pos_id'>Find legit starting value for a new positional id</h2><span id='topic+find_start_pos_id'></span>

<h3>Description</h3>

<p>Looks at the current nest as well as into its children (if necessary) to make
sure the right id is returned. Otherwise, ordering of tokens might not be
preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_start_pos_id(pd, pos, by, direction, after, candidates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_start_pos_id_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="find_start_pos_id_+3A_pos">pos</code></td>
<td>
<p>The position where the new id should be inserted.</p>
</td></tr>
<tr><td><code id="find_start_pos_id_+3A_by">by</code></td>
<td>
<p>By how much the reference <code>pos_id</code> should be increased / decreased
to create a new id.</p>
</td></tr>
<tr><td><code id="find_start_pos_id_+3A_direction">direction</code></td>
<td>
<p>Derived from <code>after</code>. <code>1</code> if <code>after = TRUE</code>, <code>-1</code> otherwise.</p>
</td></tr>
<tr><td><code id="find_start_pos_id_+3A_after">after</code></td>
<td>
<p>Boolean indicating whether it should be inserted after or before
<code>pos</code>.</p>
</td></tr>
<tr><td><code id="find_start_pos_id_+3A_candidates">candidates</code></td>
<td>
<p>The <code>pos_ids</code> of the candidates that origin from other
nests.</p>
</td></tr>
</table>

<hr>
<h2 id='find_tokens_to_update'>Find the tokens to update when applying a reference indention</h2><span id='topic+find_tokens_to_update'></span>

<h3>Description</h3>

<p>Given a target token and a flattened parse table, the token for which the
spacing information needs to be updated are computed. Since indention is
already embedded in the column <code>lag_spaces</code>, only tokens at the beginning of
a line are of concern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_tokens_to_update(flattened_pd, target_token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_tokens_to_update_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table.</p>
</td></tr>
<tr><td><code id="find_tokens_to_update_+3A_target_token">target_token</code></td>
<td>
<p>The index of the token from which the indention level
should be applied to other tokens.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>apply_ref_indention_one()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("function(a =
b,
dd
) {}", scope = "indention")
style_text("function(a,
b,
dd
) {}", scope = "indention")
</code></pre>

<hr>
<h2 id='fix_quotes'>Replace single quotes with double quotes</h2><span id='topic+fix_quotes'></span>

<h3>Description</h3>

<p>We do not use <code>deparse()</code> as in previous implementations but <code>paste0()</code> since
the former approach escapes the reverse backslash in the line break character
<code style="white-space: pre;">&#8288;\\n&#8288;</code> whereas the solution with <code>paste0()</code> does not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix_quotes(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix_quotes_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("'here
is a string
'")
</code></pre>

<hr>
<h2 id='flatten_operators'>Flatten some token in the nested parse table based on operators</h2><span id='topic+flatten_operators'></span>

<h3>Description</h3>

<p>Certain tokens are not placed optimally in the nested parse data with
<code><a href="#topic+compute_parse_data_nested">compute_parse_data_nested()</a></code>. For example, the token of arithmetic
operations 1 + 1 + 1 should all be on the same level of nesting since the
indention is the same for all but the first two terminals. Setting the
indention correctly is easier to achieve if they are put on the same level of
nesting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_operators(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_operators_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table to partially flatten.</p>
</td></tr>
</table>

<hr>
<h2 id='flatten_operators_one'>Flatten one level of nesting with its child</h2><span id='topic+flatten_operators_one'></span>

<h3>Description</h3>

<p>Flattening is done in two ways. We can flatten a parse table by moving the
left hand token of an operator one level up. Or doing that with the right
hand token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_operators_one(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_operators_one_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='flatten_pd'>Flatten a parse table</h2><span id='topic+flatten_pd'></span>

<h3>Description</h3>

<p>Flattens a parse table if certain tokens occur in this table or its child,
either flattening from left or from right. If one of <code>token</code> is present in
<code>pd_nested</code>  and one of <code>child_token</code> is present in one of the children next
to <code>token</code> in <code>pd_nested</code>, the nested parse table is flattened. Otherwise, it
is returned unmodified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_pd(pd_nested, token, child_token = token, left = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_pd_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="flatten_pd_+3A_token">token</code></td>
<td>
<p>A character vector with tokens of which at least one has to
occur in <code>pd_nested</code> in order to flatten it.</p>
</td></tr>
<tr><td><code id="flatten_pd_+3A_child_token">child_token</code></td>
<td>
<p>A character vector of tokens of which at least one has to
occur in the child in order to flatten the parse table.</p>
</td></tr>
<tr><td><code id="flatten_pd_+3A_left">left</code></td>
<td>
<p>Flag that indicates whether the parse table should be flattened
from left or from right.</p>
</td></tr>
</table>

<hr>
<h2 id='generate_test_samples'>Generate a comprehensive collection test cases for comment / insertion
interaction
Test consist of if / if-else / if-else-if-else cases, paired with various
line-break and comment configurations. Used for internal testing.</h2><span id='topic+generate_test_samples'></span>

<h3>Description</h3>

<p>Generate a comprehensive collection test cases for comment / insertion
interaction
Test consist of if / if-else / if-else-if-else cases, paired with various
line-break and comment configurations. Used for internal testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_test_samples()
</code></pre>


<h3>Value</h3>

<p>The function is called for its side effects, i.e. to write the
test cases to *-in.R files that can be tested with <code><a href="#topic+test_collection">test_collection()</a></code>. Note
that a few of the test cases are invalid and need to be removed / commented
out manually.
</p>

<hr>
<h2 id='get_addins_style_transformer_name'>Return the style function or name</h2><span id='topic+get_addins_style_transformer_name'></span><span id='topic+get_addins_style_transformer'></span>

<h3>Description</h3>

<p>Return the style function or name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_addins_style_transformer_name()

get_addins_style_transformer()
</code></pre>

<hr>
<h2 id='get_engine_pattern'>What's the engine pattern for rmd code chunks?</h2><span id='topic+get_engine_pattern'></span>

<h3>Description</h3>

<p>The function returns the regular expression pattern that identifies
all r engines in Rmd chunks. Defaults to <code style="white-space: pre;">&#8288;[Rr]&#8288;</code>. You probably only want to
change this if you create a knitr engine that processes R code but is not
the default engine <code>r</code>.
The pattern must be followed by a space (in the case the chunk is given
a name), a comma (if no name is given but further options are passed to the
engine) or a closing curly brace (in case no option and no name is given to
the chunk).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_engine_pattern()
</code></pre>

<hr>
<h2 id='get_knitr_pattern'>Get chunk pattern</h2><span id='topic+get_knitr_pattern'></span>

<h3>Description</h3>

<p>Determine a regex pattern for identifying R code chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_knitr_pattern(filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_knitr_pattern_+3A_filetype">filetype</code></td>
<td>
<p>A string indicating the filetype - either 'Rmd' or 'Rnw'.</p>
</td></tr>
</table>

<hr>
<h2 id='get_parse_data'>Obtain robust parse data</h2><span id='topic+get_parse_data'></span>

<h3>Description</h3>

<p>Wrapper around <code>utils::getParseData(parse(text = text))</code> that returns a flat
parse table. When caching information should be added, make sure that
the cache is activated with <code>cache_activate()</code> and both <code>transformers</code> and
<code>cache_dir</code> are non-<code>NULL</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parse_data(text, include_text = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parse_data_+3A_text">text</code></td>
<td>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="get_parse_data_+3A_include_text">include_text</code></td>
<td>
<p>Passed to <code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code> as <code>includeText</code>.</p>
</td></tr>
<tr><td><code id="get_parse_data_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='has_crlf_as_first_line_sep'>Check if a string uses CRLF EOLs</h2><span id='topic+has_crlf_as_first_line_sep'></span>

<h3>Description</h3>

<p>Check if a string uses CRLF EOLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_crlf_as_first_line_sep(message, initial_text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_crlf_as_first_line_sep_+3A_message">message</code></td>
<td>
<p>A message returned with <code>tryCatch()</code>.</p>
</td></tr>
<tr><td><code id="has_crlf_as_first_line_sep_+3A_initial_text">initial_text</code></td>
<td>
<p>The initial text to style.</p>
</td></tr>
</table>

<hr>
<h2 id='hash_standardize'>Standardize text for hashing</h2><span id='topic+hash_standardize'></span>

<h3>Description</h3>

<p>Make sure text after styling results in the same hash as text before styling
if it is indeed identical. This function expects trailing blank lines in
<code>text</code> were removed prior to passing it to this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hash_standardize(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hash_standardize_+3A_text">text</code></td>
<td>
<p>A character vector.</p>
</td></tr>
</table>

<hr>
<h2 id='identify_raw_chunks'>Identifies raw Rmd or Rnw code chunks</h2><span id='topic+identify_raw_chunks'></span>

<h3>Description</h3>

<p>Raw in the sense that these chunks don't contain pure R code, but they
contain a header and footer of markdown. Only code chunks that have an engine
whose name matches <code>engine-pattern</code> are considered as R code.
For every opening, we match the next closing. If there are not the same
amount of closing and openings after this matching, we throw an error.
Similarly, if there are two openings before a closing, the closing gets
matched twice, on which we throw an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_raw_chunks(lines, filetype, engine_pattern = get_engine_pattern())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_raw_chunks_+3A_lines">lines</code></td>
<td>
<p>A character vector of lines from an Rmd or Rnw file.</p>
</td></tr>
<tr><td><code id="identify_raw_chunks_+3A_filetype">filetype</code></td>
<td>
<p>A string indicating the filetype - either 'Rmd' or 'Rnw'.</p>
</td></tr>
<tr><td><code id="identify_raw_chunks_+3A_engine_pattern">engine_pattern</code></td>
<td>
<p>A regular expression that must match the engine name.</p>
</td></tr>
</table>

<hr>
<h2 id='identify_start_to_stop_of_roxygen_examples_from_text'>Figure out where code examples start and stop</h2><span id='topic+identify_start_to_stop_of_roxygen_examples_from_text'></span>

<h3>Description</h3>

<p>Finds the sequence from start to stop of the lines in <code>text</code> that are
code examples in roxygen comments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_start_to_stop_of_roxygen_examples_from_text(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_start_to_stop_of_roxygen_examples_from_text_+3A_text">text</code></td>
<td>
<p>A text consisting of code and/or roxygen comments.</p>
</td></tr>
</table>

<hr>
<h2 id='if_for_while_part_requires_braces'>Check if if, for or while loop expression require a braces.</h2><span id='topic+if_for_while_part_requires_braces'></span>

<h3>Description</h3>

<p>This is the case if they are multi-line and not yet wrapped into curly
braces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>if_for_while_part_requires_braces(pd, key_token)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="if_for_while_part_requires_braces_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="if_for_while_part_requires_braces_+3A_key_token">key_token</code></td>
<td>
<p>The token that comes right before the token that contains
the expression to be wrapped (ignoring comments). For if and while loops,
this is the closing &quot;')'&quot;, for a for-loop it's &quot;forcond&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='initialize_attributes'>Initialize attributes</h2><span id='topic+initialize_attributes'></span><span id='topic+initialize_newlines'></span><span id='topic+initialize_spaces'></span><span id='topic+initialize_multi_line'></span><span id='topic+initialize_indention_ref_pos_id'></span><span id='topic+initialize_indent'></span><span id='topic+validate_parse_data'></span>

<h3>Description</h3>

<p>Initialize attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initialize_newlines(pd_flat)

initialize_spaces(pd_flat)

initialize_multi_line(pd_flat)

initialize_indention_ref_pos_id(pd_flat)

initialize_indent(pd_flat)

validate_parse_data(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="initialize_attributes_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>initialize_newlines()</code>: Initializes <code>newlines</code> and <code>lag_newlines</code>.
</p>
</li>
<li> <p><code>initialize_spaces()</code>: Initializes <code>spaces</code>.
</p>
</li>
<li> <p><code>initialize_multi_line()</code>: Initializes <code>multi_line</code>.
</p>
</li>
<li> <p><code>initialize_indention_ref_pos_id()</code>: Initializes <code>indention_ref_ind</code>.
</p>
</li>
<li> <p><code>initialize_indent()</code>: Initializes <code>indent</code>.
</p>
</li>
<li> <p><code>validate_parse_data()</code>: validates the parse data.
</p>
</li></ul>

<hr>
<h2 id='invalid_utf8'>Drop-in replacement for <code>xfun:::invalid_utf8()</code></h2><span id='topic+invalid_utf8'></span>

<h3>Description</h3>

<p>Drop-in replacement for <code>xfun:::invalid_utf8()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invalid_utf8(x)
</code></pre>

<hr>
<h2 id='is_cached'>Check if text is cached</h2><span id='topic+is_cached'></span>

<h3>Description</h3>

<p>This boils down to check if the hash exists at the caching dir as a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_cached(text, transformers, more_specs, cache_dir = get_cache_dir())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_cached_+3A_text">text</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="is_cached_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="is_cached_+3A_more_specs">more_specs</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="is_cached_+3A_cache_dir">cache_dir</code></td>
<td>
<p>The caching directory relative to the <code>.Rcache</code> root to
look for a cached value.</p>
</td></tr>
</table>

<hr>
<h2 id='is_code_chunk_header_or_xaringan_or_code_output'>Identify spinning code chunk header or xaringan</h2><span id='topic+is_code_chunk_header_or_xaringan_or_code_output'></span>

<h3>Description</h3>

<p>Wrongly identifies a comment without a preceding line break as a code chunk
header.
See https://yihui.name/knitr/demo/stitch/#spin-comment-out-texts for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_code_chunk_header_or_xaringan_or_code_output(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_code_chunk_header_or_xaringan_or_code_output_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>style_text(c(
  "# title",
  "some_code &lt;- function() {}",
  "#+ chunk-label, opt1=value1",
  "call(3, 2, c(3:2))",
  "#&gt; 99"
))
</code></pre>

<hr>
<h2 id='is_double_indent_function_declaration'>Is the function declaration double indented?</h2><span id='topic+is_double_indent_function_declaration'></span>

<h3>Description</h3>

<p>Assumes you already checked if it's a function with
<code>is_function_declaration</code>. It is double indented if the first token
after the first line break that is a <code>"SYMBOL_FORMALS"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_double_indent_function_declaration(pd, indent_by = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_double_indent_function_declaration_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="is_double_indent_function_declaration_+3A_indent_by">indent_by</code></td>
<td>
<p>How many spaces of indention should be inserted after
operators such as '('.</p>
</td></tr>
</table>

<hr>
<h2 id='is_insufficiently_parsed_string'>Identify strings that were not fully parsed</h2><span id='topic+is_insufficiently_parsed_string'></span>

<h3>Description</h3>

<p>Identifies strings that were not fully parsed due to their vast length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_insufficiently_parsed_string(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_insufficiently_parsed_string_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The meaning of the variable <code>is_problematic_string</code> in the source code
changes from &quot;all strings&quot; to &quot;all problematic strings&quot;, is partly
misleading and this approach was chosen for performance reasons only.
</p>

<hr>
<h2 id='is_shebang'>Identify comments that are shebangs</h2><span id='topic+is_shebang'></span>

<h3>Description</h3>

<p>Shebangs should be preserved and no space should be inserted between
<code style="white-space: pre;">&#8288;#&#8288;</code> and <code>!</code>. A comment is a shebang if it is the first top-level token
(identified with <code>pos_id</code>) and if it starts with <code style="white-space: pre;">&#8288;#!&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_shebang(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_shebang_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("#!/usr/bin/env Rscript")
</code></pre>

<hr>
<h2 id='local_test_setup'>Establish testing setup for current environment</h2><span id='topic+local_test_setup'></span>

<h3>Description</h3>

<p>Establish testing setup for current environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_test_setup(cache = FALSE, .local_envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_test_setup_+3A_cache">cache</code></td>
<td>
<p>Whether or not to create and activate a cache in a temporary
directory.</p>
</td></tr>
<tr><td><code id="local_test_setup_+3A_.local_envir">.local_envir</code></td>
<td>
<p>The environment to use for scoping.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> make styler quiet.
</p>
</li></ul>


<hr>
<h2 id='lookup_new_special'>Lookup which new tokens were created from &quot;SPECIAL&quot;</h2><span id='topic+lookup_new_special'></span>

<h3>Description</h3>

<p>Lookup which new tokens were created from &quot;SPECIAL&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_new_special(regex = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_new_special_+3A_regex">regex</code></td>
<td>
<p>A regular expression pattern to search for.</p>
</td></tr>
</table>

<hr>
<h2 id='lookup_tokens'>Lookup all tokens that have a unique token-text mapping</h2><span id='topic+lookup_tokens'></span>

<h3>Description</h3>

<p>Lookup all tokens that have a unique token-text mapping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lookup_tokens()
</code></pre>

<hr>
<h2 id='make_transformer'>Closure to return a transformer function</h2><span id='topic+make_transformer'></span>

<h3>Description</h3>

<p>This function takes a list of transformer functions as input and
returns a function that can be applied to character strings
that should be transformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_transformer(
  transformers,
  include_roxygen_examples,
  base_indention,
  warn_empty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_transformer_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions that operate on flat
parse tables.</p>
</td></tr>
<tr><td><code id="make_transformer_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="make_transformer_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="make_transformer_+3A_warn_empty">warn_empty</code></td>
<td>
<p>Whether or not a warning should be displayed when <code>text</code>
does not contain any tokens.</p>
</td></tr>
</table>

<hr>
<h2 id='map_filetype_to_pattern'>Map the file type to a corresponding regular expression</h2><span id='topic+map_filetype_to_pattern'></span>

<h3>Description</h3>

<p>Map the file type to a corresponding regular expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_filetype_to_pattern(filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_filetype_to_pattern_+3A_filetype">filetype</code></td>
<td>
<p>The file type to map to a regex.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::map_filetype_to_pattern(c(".rMd", "R"))
</code></pre>

<hr>
<h2 id='match_stop_to_start'>Match a stop candidate to a start</h2><span id='topic+match_stop_to_start'></span>

<h3>Description</h3>

<p>Match a stop candidate to a start
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_stop_to_start(start, stop_candidates)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_stop_to_start_+3A_start">start</code></td>
<td>
<p>An integer.</p>
</td></tr>
<tr><td><code id="match_stop_to_start_+3A_stop_candidates">stop_candidates</code></td>
<td>
<p>Potential stop candidates.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::match_stop_to_start(1, c(3, 4, 5))
</code></pre>

<hr>
<h2 id='math_token_spacing'>Specify spacing around math tokens</h2><span id='topic+math_token_spacing'></span><span id='topic+specify_math_token_spacing'></span><span id='topic+tidyverse_math_token_spacing'></span>

<h3>Description</h3>

<p>Helper function to create the input for the argument <code>math_token_spacing</code>  in
<code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_math_token_spacing(zero = "'^'", one = c("'+'", "'-'", "'*'", "'/'"))

tidyverse_math_token_spacing()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="math_token_spacing_+3A_zero">zero</code></td>
<td>
<p>Character vector of tokens that should be surrounded with zero
spaces.</p>
</td></tr>
<tr><td><code id="math_token_spacing_+3A_one">one</code></td>
<td>
<p>Character vector with tokens that should be surrounded by at
least one space (depending on <code>strict = TRUE</code> in the styling functions
<code><a href="#topic+style_text">style_text()</a></code> and friends). See 'Examples'.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>specify_math_token_spacing()</code>: Allows to fully specify the math token
spacing.
</p>
</li>
<li> <p><code>tidyverse_math_token_spacing()</code>: Simple forwarder to
<code>specify_math_token_spacing</code> with spacing around math tokens according to the
tidyverse style guide.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>style_text(
  "1+1   -3",
  math_token_spacing = specify_math_token_spacing(zero = "'+'"),
  strict = FALSE
)
style_text(
  "1+1   -3",
  math_token_spacing = specify_math_token_spacing(zero = "'+'"),
  strict = TRUE
)
style_text(
  "1+1   -3",
  math_token_spacing = tidyverse_math_token_spacing(),
  strict = FALSE
)
style_text(
  "1+1   -3",
  math_token_spacing = tidyverse_math_token_spacing(),
  strict = TRUE
)
</code></pre>

<hr>
<h2 id='n_times_faster_with_cache'>Times two function calls with temporarily enabled cache</h2><span id='topic+n_times_faster_with_cache'></span>

<h3>Description</h3>

<p>This can be helpful for benchmarking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_times_faster_with_cache(
  x1,
  x2 = x1,
  ...,
  fun = styler::style_text,
  n = 3L,
  clear = "always"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_times_faster_with_cache_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>fun</code>.</p>
</td></tr>
<tr><td><code id="n_times_faster_with_cache_+3A_fun">fun</code></td>
<td>
<p>The function that should be timed.</p>
</td></tr>
<tr><td><code id="n_times_faster_with_cache_+3A_n">n</code></td>
<td>
<p>The number of times the experiment should be repeated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar indicating the relative difference of the second compared to the
first run.
</p>

<hr>
<h2 id='needs_indention'>Check whether indention is needed</h2><span id='topic+needs_indention'></span>

<h3>Description</h3>

<p>Checks for each potential trigger token in <code>pd</code> whether it actually should
cause indention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needs_indention(pd, potential_triggers_pos, other_trigger_tokens = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="needs_indention_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="needs_indention_+3A_potential_triggers_pos">potential_triggers_pos</code></td>
<td>
<p>A vector with indices of the potential trigger
tokens in <code>pd</code>.</p>
</td></tr>
<tr><td><code id="needs_indention_+3A_other_trigger_tokens">other_trigger_tokens</code></td>
<td>
<p>Other tokens that are going to cause indention
if on the same line as the token corresponding to <code>potential_trigger</code> and
directly followed by a line break.</p>
</td></tr>
</table>

<hr>
<h2 id='needs_indention_one'>Check whether indention is needed</h2><span id='topic+needs_indention_one'></span>

<h3>Description</h3>

<p>Determine whether the tokens corresponding to <code>potential_trigger_pos</code> should
cause indention, considering that there might be other potential triggers
<code>other_trigger_tokens</code> that are going to cause indention.
Indention is needed if the two conditions apply:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needs_indention_one(pd, potential_trigger_pos, other_trigger_tokens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="needs_indention_one_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="needs_indention_one_+3A_potential_trigger_pos">potential_trigger_pos</code></td>
<td>
<p>the index of the token in the parse table
for which it should be checked whether it should trigger indention.</p>
</td></tr>
<tr><td><code id="needs_indention_one_+3A_other_trigger_tokens">other_trigger_tokens</code></td>
<td>
<p>Other tokens that are going to cause indention
if on the same line as the token corresponding to <code>potential_trigger</code> and
directly followed by a line break.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> there is no multi-line token between the trigger and the first line break.
</p>
</li>
<li><p> there is no other token between the potential trigger and the first line
break that is going to cause indention. Note that such an other trigger
only causes indention if there is a line break after that other triggering
token, not otherwise. If it causes indention, it is said to be an active
trigger, if it does not, it is called an inactive trigger.
See 'Details' for an example where there is an other trigger token, but
since the next token is on the same line as the other trigger,
the trigger is passive.
</p>
</li></ul>



<h3>Value</h3>

<p>Returns <code>TRUE</code> if indention is needed, <code>FALSE</code> otherwise.
</p>
<p><code>TRUE</code> if indention is needed, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>style_text(c(
  "call(named = c,",
  "named = b)"
), strict = FALSE)
</code></pre>

<hr>
<h2 id='needs_rd_emulation'>Check if rd emulation is required with <code><a href="roxygen2.html#topic+roc_proc_text">roxygen2::roc_proc_text()</a></code></h2><span id='topic+needs_rd_emulation'></span>

<h3>Description</h3>

<p>Check if rd emulation is required with <code><a href="roxygen2.html#topic+roc_proc_text">roxygen2::roc_proc_text()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>needs_rd_emulation(roxygen)
</code></pre>

<hr>
<h2 id='nest_parse_data'>Nest a flat parse table</h2><span id='topic+nest_parse_data'></span>

<h3>Description</h3>

<p><code>nest_parse_data</code> groups <code>pd_flat</code> into a parse table with tokens that are
a parent to other tokens (called internal) and such that are not (called
child). Then, the token in child are joined to their parents in internal
and all token information of the children is nested into a column &quot;child&quot;.
This is done recursively until we are only left with a nested data frame that
contains one row: The nested parse table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_parse_data(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_parse_data_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table including both terminals and non-terminals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested parse table.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+compute_parse_data_nested">compute_parse_data_nested()</a></code>
</p>

<hr>
<h2 id='next_non_comment'>Find the index of the next or previous non-comment in a parse table.</h2><span id='topic+next_non_comment'></span><span id='topic+previous_non_comment'></span>

<h3>Description</h3>

<p>Find the index of the next or previous non-comment in a parse table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_non_comment(pd, pos)

previous_non_comment(pd, pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_non_comment_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="next_non_comment_+3A_pos">pos</code></td>
<td>
<p>The position of the token to start the search from.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other third-party style guide helpers: 
<code><a href="#topic+pd_is">pd_is</a></code>,
<code><a href="#topic+scope_normalize">scope_normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- "a &lt;- # hi \n x %&gt;% b()"
writeLines(code)
pd &lt;- compute_parse_data_nested(code)
child &lt;- pd$child[[1]]
previous_non_comment(child, 4L)
next_non_comment(child, 2L)
</code></pre>

<hr>
<h2 id='next_terminal'>Tell me what the next terminal is</h2><span id='topic+next_terminal'></span>

<h3>Description</h3>

<p>If the first is a terminal, return it. If not, go inside it and search the
next terminal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>next_terminal(
  pd,
  stack = FALSE,
  vars = c("pos_id", "token", "text"),
  tokens_exclude = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="next_terminal_+3A_pd">pd</code></td>
<td>
<p>A nest.</p>
</td></tr>
<tr><td><code id="next_terminal_+3A_stack">stack</code></td>
<td>
<p>Whether or not to also return information on the tokens that
are between <code>pd</code> and the first terminal, so the returned data frame can be
understood as a transition path from <code>pd</code> to the next terminal, instead of
the information at the terminal only. The order is inside-out,
i.e. the first non-terminal on top, the terminal last.</p>
</td></tr>
<tr><td><code id="next_terminal_+3A_vars">vars</code></td>
<td>
<p>The variables to return.</p>
</td></tr>
<tr><td><code id="next_terminal_+3A_tokens_exclude">tokens_exclude</code></td>
<td>
<p>A vector with tokens to exclude. This can be helpful if
one wants to find the next token that is not a comment for example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a data frame (which is <strong>not</strong> a valid parse table for
<code>stack = TRUE</code>), with <code>vars</code> and another variable <code>position</code> that denotes
the index each element in the transition. This can be helpful in conjunction
with <code><a href="purrr.html#topic+pluck">purrr::pluck()</a></code> or <code><a href="purrr.html#topic+modify_in">purrr::modify_in()</a></code> to reach the terminal in the
nested structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>withr::with_options(
  list(styler.cache_name = NULL), # temporarily deactivate cache
  {
    pd &lt;- compute_parse_data_nested("if (TRUE) f()")
    styler:::next_terminal(pd)
  }
)
</code></pre>

<hr>
<h2 id='option_read'>Get the value of an option</h2><span id='topic+option_read'></span>

<h3>Description</h3>

<p>Basically a <code>getOptions()</code> that fails fast by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>option_read(x, default = NULL, error_if_not_found = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="option_read_+3A_x">x</code></td>
<td>
<p>a character string holding an option name.</p>
</td></tr>
<tr><td><code id="option_read_+3A_default">default</code></td>
<td>
<p>if the specified option is not set in the options list,
this value is returned.  This facilitates retrieving an option and
checking whether it is set and setting it separately if not.</p>
</td></tr>
<tr><td><code id="option_read_+3A_error_if_not_found">error_if_not_found</code></td>
<td>
<p>Whether or not an error should be returned if the
option was not set.</p>
</td></tr>
</table>

<hr>
<h2 id='parse_roxygen'>Parse roxygen comments into text</h2><span id='topic+parse_roxygen'></span>

<h3>Description</h3>

<p>Used to parse roxygen code examples. Removes line break before
<code style="white-space: pre;">&#8288;\\dontrun{...}&#8288;</code> and friends because it does not occur for segments other
than <code style="white-space: pre;">&#8288;\\dont{...}&#8288;</code> and friends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_roxygen(roxygen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_roxygen_+3A_roxygen">roxygen</code></td>
<td>
<p>Roxygen comments.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::parse_roxygen(c(
  "#' @examples",
  "#' 1+  1"
))
styler:::parse_roxygen(c(
  "#' @examples 33",
  "#'1+  1"
))
</code></pre>

<hr>
<h2 id='parse_safely'>Save parsing from text</h2><span id='topic+parse_safely'></span>

<h3>Description</h3>

<p>Parses text safely, i.e. throws an informative error if EOL style does not
match LF or indicates the exact position where the parsing failed. Note
that we can only detect wrong EOL style if it occurs on the first line
already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_safely(text, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_safely_+3A_text">text</code></td>
<td>
<p>Text to parse.</p>
</td></tr>
<tr><td><code id="parse_safely_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="base.html#topic+parse">base::parse()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>try(styler:::parse_safely("a + 3 -4 -&gt; x\r\n glück + 1"))
# This cannot be detected as a EOL style problem because the first
# line ends as expected with \n
try(styler:::parse_safely("a + 3 -4 -&gt; x\nx + 2\r\n glück + 1"))

styler:::parse_safely("a + 3 -4 -&gt; \n glück + 1")
</code></pre>

<hr>
<h2 id='parse_transform_serialize_r'>Parse, transform and serialize text</h2><span id='topic+parse_transform_serialize_r'></span>

<h3>Description</h3>

<p>Wrapper function for the common three operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_transform_serialize_r(
  text,
  transformers,
  base_indention,
  warn_empty = TRUE,
  is_roxygen_code_example = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_transform_serialize_r_+3A_text">text</code></td>
<td>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_+3A_warn_empty">warn_empty</code></td>
<td>
<p>Whether or not a warning should be displayed when <code>text</code>
does not contain any tokens.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_+3A_is_roxygen_code_example">is_roxygen_code_example</code></td>
<td>
<p>Is code a roxygen examples block?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>
</p>

<hr>
<h2 id='parse_transform_serialize_r_block'>Parse, transform and serialize a nested parse table</h2><span id='topic+parse_transform_serialize_r_block'></span>

<h3>Description</h3>

<p>We process blocks of nested parse tables for speed. See <code><a href="#topic+cache_find_block">cache_find_block()</a></code>
for details on how a top-level nest is split into blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_transform_serialize_r_block(
  pd_nested,
  start_line,
  transformers,
  base_indention
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_transform_serialize_r_block_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A block of the nested parse table.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_block_+3A_start_line">start_line</code></td>
<td>
<p>The line number on which the code starts.</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_block_+3A_transformers">transformers</code></td>
<td>
<p>A list of <em>named</em> transformer functions</p>
</td></tr>
<tr><td><code id="parse_transform_serialize_r_block_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>text_in &lt;- 'x&lt;- function()
"here
is"
NULL
1+ 1
'
style_text(text_in, base_indention = 3)
# not equal to the naive approach
styler:::construct_vertical(
  paste0(styler:::add_spaces(3), style_text(text_in), sep = "")
)
</code></pre>

<hr>
<h2 id='parse_transform_serialize_roxygen'>Parse, transform and serialize roxygen comments</h2><span id='topic+parse_transform_serialize_roxygen'></span>

<h3>Description</h3>

<p>Splits <code>text</code> into roxygen code examples and non-roxygen code examples and
then maps over these examples by applying
<code><a href="#topic+style_roxygen_code_example">style_roxygen_code_example()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_transform_serialize_roxygen(text, transformers, base_indention)
</code></pre>


<h3>Hierarchy</h3>

<p>Styling involves splitting roxygen example code into segments, and segments
into snippets. This describes the process for input of
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>:
</p>

<ul>
<li><p> Splitting code into roxygen example code and other code. Downstream,
we are only concerned about roxygen code. See
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>.
</p>
</li>
<li><p> Every roxygen example code can have zero or more
dontrun / dontshow / donttest sequences. We next create segments of roxygen
code examples that contain at most one of these. See
<code><a href="#topic+style_roxygen_code_example">style_roxygen_code_example()</a></code>.
</p>
</li>
<li><p> We further split the segment that contains at most one dont* sequence into
snippets that are either don* or not. See
<code><a href="#topic+style_roxygen_code_example_segment">style_roxygen_code_example_segment()</a></code>.
</p>
</li></ul>

<p>Finally, that we have roxygen code snippets that are either dont* or not,
we style them in <code><a href="#topic+style_roxygen_example_snippet">style_roxygen_example_snippet()</a></code> using
<code><a href="#topic+parse_transform_serialize_r">parse_transform_serialize_r()</a></code>.
</p>

<hr>
<h2 id='parse_tree_must_be_identical'>Check whether a round trip verification can be carried out</h2><span id='topic+parse_tree_must_be_identical'></span>

<h3>Description</h3>

<p>If scope was set to &quot;line_breaks&quot; or lower (compare <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>),
we can compare the expression before and after styling and return an error if
it is not the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_tree_must_be_identical(transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_tree_must_be_identical_+3A_transformers">transformers</code></td>
<td>
<p>The list of transformer functions used for styling.
Needed for reverse engineering the scope.</p>
</td></tr>
</table>

<hr>
<h2 id='parser_version_set'>Work with parser versions</h2><span id='topic+parser_version_set'></span><span id='topic+parser_version_get'></span><span id='topic+parser_version_find'></span>

<h3>Description</h3>

<p>The structure of the parse data affects many operations in styler. There was
unexpected behavior of the parser that styler was initially designed to work
around. Examples are <a href="https://github.com/r-lib/styler/issues/187">#187</a>,
<a href="https://github.com/r-lib/styler/issues/216">#216</a>,
<a href="https://github.com/r-lib/styler/issues/100">#100</a> and others. With
<a href="https://github.com/r-lib/styler/issues/419">#419</a>, the structure of the
parse data changes and we need to dispatch for older versions. As it is
inconvenient to pass a parser version down in the call stack in various
places, the environment <code>env_current</code> is used to store the current version
<em>globally</em> but internally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parser_version_set(version)

parser_version_get()

parser_version_find(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parser_version_set_+3A_version">version</code></td>
<td>
<p>The version of the parser to be used.</p>
</td></tr>
<tr><td><code id="parser_version_set_+3A_pd">pd</code></td>
<td>
<p>A parse table such as the output from
<code>utils::getParseData(parse(text = text))</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We version the parser as follows:
</p>

<ul>
<li><p> version 1: Before fix mentioned in #419. R &lt; 3.6
</p>
</li>
<li><p> version 2: After #419. R &gt;= 3.6
</p>
</li></ul>



<h3>version 3: After #582. R &gt;= 4.0</h3>

<p>The following utilities are available:
</p>

<ul>
<li> <p><code>parser_version_set()</code> sets the parser version in the environment
<code>env_current</code>.
</p>
</li>
<li> <p><code>parser_version_get()</code> retrieves the parser version from the
environment <code>env_current</code>.
</p>
</li>
<li> <p><code>parser_version_find()</code> determines the version of the parser from parse
data. This does not necessarily mean that the version found is the
actual version, but it <em>behaves</em> like it. For example, code that does not
contain <code>EQ_ASSIGN</code> is parsed the same way with version 1 and 2. If the
behavior is identical, the version is set to 1.
</p>
</li></ul>


<hr>
<h2 id='pd_is'>What is a parse table representing?</h2><span id='topic+pd_is'></span><span id='topic+is_curly_expr'></span><span id='topic+is_for_expr'></span><span id='topic+is_conditional_expr'></span><span id='topic+is_while_expr'></span><span id='topic+is_function_call'></span><span id='topic+is_function_declaration'></span><span id='topic+is_comment'></span><span id='topic+is_tilde_expr'></span><span id='topic+is_asymmetric_tilde_expr'></span><span id='topic+is_symmetric_tilde_expr'></span>

<h3>Description</h3>

<p>Check whether a parse table corresponds to a certain expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_curly_expr(pd)

is_for_expr(pd)

is_conditional_expr(pd)

is_while_expr(pd)

is_function_call(pd)

is_function_declaration(pd)

is_comment(pd)

is_tilde_expr(pd, tilde_pos = c(1L, 2L))

is_asymmetric_tilde_expr(pd)

is_symmetric_tilde_expr(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_is_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="pd_is_+3A_tilde_pos">tilde_pos</code></td>
<td>
<p>Integer vector indicating row-indices that should be
checked for tilde. See 'Details'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A tilde is on the top row in the parse table if it is an asymmetric tilde
expression (like <code>~column</code>), in the second row if it is a symmetric tilde
expression (like <code>a~b</code>).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is_curly_expr()</code>: Checks whether <code>pd</code> contains an expression wrapped in curly brackets.
</p>
</li>
<li> <p><code>is_for_expr()</code>: Checks whether <code>pd</code> contains a <code>for</code> loop.
</p>
</li>
<li> <p><code>is_conditional_expr()</code>: Checks whether <code>pd</code> contains is a conditional expression.
</p>
</li>
<li> <p><code>is_while_expr()</code>: Checks whether <code>pd</code> contains a <code>while</code> loop.
</p>
</li>
<li> <p><code>is_function_call()</code>: Checks whether <code>pd</code> is a function call.
</p>
</li>
<li> <p><code>is_function_declaration()</code>: Checks whether <code>pd</code> is a function declaration.
</p>
</li>
<li> <p><code>is_comment()</code>: Checks for every token whether or not it is a comment.
</p>
</li>
<li> <p><code>is_tilde_expr()</code>: Checks whether <code>pd</code> contains a tilde.
</p>
</li>
<li> <p><code>is_asymmetric_tilde_expr()</code>: If <code>pd</code> contains a tilde, checks whether it is asymmetrical.
</p>
</li>
<li> <p><code>is_symmetric_tilde_expr()</code>: If <code>pd</code> contains a tilde, checks whether it is symmetrical.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other third-party style guide helpers: 
<code><a href="#topic+next_non_comment">next_non_comment</a>()</code>,
<code><a href="#topic+scope_normalize">scope_normalize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>code &lt;- "if (TRUE) { 1 }"
pd &lt;- compute_parse_data_nested(code)
is_curly_expr(pd)
child_of_child &lt;- pd$child[[1]]$child[[5]]
is_curly_expr(child_of_child)

code &lt;- "for (i in 1:5) print(1:i)"
pd &lt;- compute_parse_data_nested(code)
is_for_expr(pd)
is_for_expr(pd$child[[1]])

code &lt;- "if (TRUE) x &lt;- 1 else x &lt;- 0"
pd &lt;- compute_parse_data_nested(code)
is_conditional_expr(pd)
is_conditional_expr(pd$child[[1]])

code &lt;- "x &lt;- list(1:3)"
pd &lt;- compute_parse_data_nested(code)
is_function_call(pd)
child_of_child &lt;- pd$child[[1]]$child[[3]]
is_function_call(child_of_child)

code &lt;- "foo &lt;- function() NULL"
pd &lt;- compute_parse_data_nested(code)
is_function_declaration(pd)
child_of_child &lt;- pd$child[[1]]$child[[3]]
is_function_declaration(child_of_child)

code &lt;- "x &lt;- 1 # TODO: check value"
pd &lt;- compute_parse_data_nested(code)
is_comment(pd)

code &lt;- "lm(wt ~ mpg, mtcars)"
pd &lt;- compute_parse_data_nested(code)
is_tilde_expr(pd$child[[1]]$child[[3]])
is_symmetric_tilde_expr(pd$child[[1]]$child[[3]])
is_asymmetric_tilde_expr(pd$child[[1]]$child[[3]])

</code></pre>

<hr>
<h2 id='pd_is_multi_line'>Check whether a parse table is a multi-line token</h2><span id='topic+pd_is_multi_line'></span>

<h3>Description</h3>

<p>A token is a multi-line expression if and only if:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pd_is_multi_line(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pd_is_multi_line_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> it contains a line break.
</p>
</li>
<li><p> it has at least one child that is a multi-line expression itself.
</p>
</li></ul>


<hr>
<h2 id='post_parse_roxygen'>Changing the line definition</h2><span id='topic+post_parse_roxygen'></span>

<h3>Description</h3>

<p>Input: New line denoted with <code style="white-space: pre;">&#8288;\\n&#8288;</code>. Lines can span across elements.
Output: Each element in the vector is one line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>post_parse_roxygen(raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="post_parse_roxygen_+3A_raw">raw</code></td>
<td>
<p>Raw code to post-process.</p>
</td></tr>
</table>

<hr>
<h2 id='prettify_any'>Prettify R code in current working directory</h2><span id='topic+prettify_any'></span>

<h3>Description</h3>

<p>This is a helper function for style_dir.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettify_any(
  transformers,
  filetype,
  recursive,
  exclude_files,
  exclude_dirs,
  include_roxygen_examples,
  base_indention = 0L,
  dry
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettify_any_+3A_transformers">transformers</code></td>
<td>
<p>A set of transformer functions. This argument is most
conveniently constructed via the <code>style</code> argument and <code>...</code>. See
'Examples'.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_filetype">filetype</code></td>
<td>
<p>Vector of file extensions indicating which file types should
be styled. Case is ignored, and the <code>.</code> is optional, e.g. <code>c(".R",".Rmd")</code>,
or <code>c("r", "rmd")</code>. Supported values (after standardization) are:
&quot;qmd&quot;, &quot;r&quot;, &quot;rmd&quot;, &quot;rmarkdown&quot;, &quot;rnw&quot;, and &quot;rprofile&quot;.
Rmarkdown is treated as Rmd.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_recursive">recursive</code></td>
<td>
<p>A logical value indicating whether or not files in
subdirectories should be styled as well.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_exclude_files">exclude_files</code></td>
<td>
<p>Character vector with regular expressions to files
that should be excluded from styling.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_exclude_dirs">exclude_dirs</code></td>
<td>
<p>Character vector with directories to exclude
(recursively). Note that the default values were set for consistency with
<code><a href="#topic+style_dir">style_dir()</a></code> and as these directories are anyways not styled.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="prettify_any_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='prettify_pkg'>Prettify a package</h2><span id='topic+prettify_pkg'></span>

<h3>Description</h3>

<p>Prettify a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prettify_pkg(
  transformers,
  filetype,
  exclude_files,
  exclude_dirs,
  include_roxygen_examples,
  base_indention,
  dry
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prettify_pkg_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions that operate on flat
parse tables.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_filetype">filetype</code></td>
<td>
<p>Vector of file extensions indicating which file types should
be styled. Case is ignored, and the <code>.</code> is optional, e.g. <code>c(".R",".Rmd")</code>,
or <code>c("r", "rmd")</code>. Supported values (after standardization) are:
&quot;qmd&quot;, &quot;r&quot;, &quot;rmd&quot;, &quot;rmarkdown&quot;, &quot;rnw&quot;, and &quot;rprofile&quot;.
Rmarkdown is treated as Rmd.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_exclude_files">exclude_files</code></td>
<td>
<p>Character vector with regular expressions to files
that should be excluded from styling.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_exclude_dirs">exclude_dirs</code></td>
<td>
<p>Character vector with directories to exclude
(recursively). Note that the default values were set for consistency with
<code><a href="#topic+style_dir">style_dir()</a></code> and as these directories are anyways not styled.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="prettify_pkg_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='print.vertical'>Print styled code</h2><span id='topic+print.vertical'></span>

<h3>Description</h3>

<p>Print styled code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'vertical'
print(
  x,
  ...,
  colored = getOption("styler.colored_print.vertical"),
  style = prettycode::default_style()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.vertical_+3A_x">x</code></td>
<td>
<p>A character vector, one element corresponds to one line of code.</p>
</td></tr>
<tr><td><code id="print.vertical_+3A_...">...</code></td>
<td>
<p>Not currently used.</p>
</td></tr>
<tr><td><code id="print.vertical_+3A_colored">colored</code></td>
<td>
<p>Whether or not the output should be colored with
<code>prettycode::highlight()</code>.</p>
</td></tr>
<tr><td><code id="print.vertical_+3A_style">style</code></td>
<td>
<p>Passed to <code>prettycode::highlight()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='read_utf8'>Read UTF-8</h2><span id='topic+read_utf8'></span>

<h3>Description</h3>

<p>Reads an UTF-8 file, returning the content and whether or not the final line
was blank. This information is required higher up in the call stack because
we should write back if contents changed or if there is no blank line at the
EOF. A perfectly styled file with no EOF blank line will gain such a line
with this implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_utf8(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_utf8_+3A_path">path</code></td>
<td>
<p>A path to a file to read.</p>
</td></tr>
</table>

<hr>
<h2 id='read_utf8_bare'>Drop-in replacement for <code>xfun::read_utf8()</code>, with an optional <code>warn</code>
argument.</h2><span id='topic+read_utf8_bare'></span>

<h3>Description</h3>

<p>Drop-in replacement for <code>xfun::read_utf8()</code>, with an optional <code>warn</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_utf8_bare(con, warn = TRUE)
</code></pre>

<hr>
<h2 id='reindention'>Specify what is re-indented how</h2><span id='topic+reindention'></span><span id='topic+specify_reindention'></span><span id='topic+tidyverse_reindention'></span>

<h3>Description</h3>

<p>This function returns a list that can be used as an input for the argument
<code>reindention</code> of the function <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>. It features sensible
defaults, so the user can specify deviations from them conveniently without
the need of setting all arguments explicitly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_reindention(regex_pattern = NULL, indention = 0L, comments_only = TRUE)

tidyverse_reindention()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reindention_+3A_regex_pattern">regex_pattern</code></td>
<td>
<p>Character vector with regular expression patterns that
are to be re-indented with spaces, <code>NULL</code> if no reindention needed.</p>
</td></tr>
<tr><td><code id="reindention_+3A_indention">indention</code></td>
<td>
<p>The indention tokens should have if they match
<code>regex_pattern</code>.</p>
</td></tr>
<tr><td><code id="reindention_+3A_comments_only">comments_only</code></td>
<td>
<p>Whether the <code>regex_reindention_pattern</code> should only be
matched against comments or against all tokens. Mainly added for
performance.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>specify_reindention()</code>: Allows to specify which tokens are reindented and
how.
</p>
</li>
<li> <p><code>tidyverse_reindention()</code>: Simple forwarder to
<code>specify_reindention</code> with reindention according to the tidyverse style
guide.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("a &lt;- xyz", reindention = specify_reindention(
  regex_pattern = "xyz", indention = 4, comments_only = FALSE
))
style_text("a &lt;- xyz", reindention = tidyverse_reindention())
</code></pre>

<hr>
<h2 id='remove_dont_mask'>Remove dont* mask</h2><span id='topic+remove_dont_mask'></span>

<h3>Description</h3>

<p>Remove dont* mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_dont_mask(roxygen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_dont_mask_+3A_roxygen">roxygen</code></td>
<td>
<p>Roxygen code examples that contains a dont* segment only.</p>
</td></tr>
</table>

<hr>
<h2 id='remove_roxygen_header'>Remove roxygen header</h2><span id='topic+remove_roxygen_header'></span>

<h3>Description</h3>

<p>Can't simply remove the element with the regex because it may happen that
the roxygen tag is on the same line as its contents start.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_roxygen_header(text)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>#' @examples c(1, 2)
</code></pre>

<hr>
<h2 id='rep_char'>Repeat elements of a character vector <code>times</code> times and collapse it</h2><span id='topic+rep_char'></span>

<h3>Description</h3>

<p>Repeat elements of a character vector <code>times</code> times and collapse it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_char(char, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_char_+3A_char">char</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="rep_char_+3A_times">times</code></td>
<td>
<p>an integer giving the number of repetitions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector.
</p>

<hr>
<h2 id='roxygen_remove_extra_brace'>Fix <code><a href="tools.html#topic+parse_Rd">tools::parse_Rd()</a></code> output</h2><span id='topic+roxygen_remove_extra_brace'></span>

<h3>Description</h3>

<p>Since <code><a href="tools.html#topic+parse_Rd">tools::parse_Rd()</a></code> treats braces in quotes as literal braces when
determining brace symmetry, a brace might be added in error to the parsed
data (at the end). We'll remove one at the time, check if output is parsable
until no braces are left. If we end up with no braces left, we signal a
parsing error, otherwise, we return the initial (not parsable input due to
<em>dont</em> sequence) with the trailing braces removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roxygen_remove_extra_brace(parsed)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::parse_roxygen(
  c(
    "#' @examples",
    "#' x &lt;- '{'",
    "#' \\dontrun{",
    "#' fu(x = 3)",
    "#' }"
  )
)
styler:::parse_roxygen(
  c(
    "#' @examples",
    "#' x &lt;- '{'",
    "#' \\dontrun{",
    "#' c('{', \"'{{{\" ,\"[\")",
    "#' }"
  )
)
</code></pre>

<hr>
<h2 id='save_after_styling_is_active'>Heuristic to see if a file styled with the addin should be saved or not.</h2><span id='topic+save_after_styling_is_active'></span>

<h3>Description</h3>

<p>Using the R option <code>"styler.save_after_styling"</code> and if unset, checks legacy
method via environment variable <code>save_after_styling</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_after_styling_is_active()
</code></pre>

<hr>
<h2 id='scope_normalize'>Convert the styling scope to its lower-level representation</h2><span id='topic+scope_normalize'></span>

<h3>Description</h3>

<p>If <code>scope</code> is of class <code>character</code> and of length one, the value of the
argument and all less-invasive levels are included too (e.g.
styling tokens includes styling spaces). If
<code>scope</code> is of class <code>AsIs</code>, every level to be included has to be declared
individually. See compare <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> for the possible levels and
their order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scope_normalize(scope, name = substitute(scope))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scope_normalize_+3A_scope">scope</code></td>
<td>
<p>A character vector of length one or a vector of class <code>AsIs</code>.</p>
</td></tr>
<tr><td><code id="scope_normalize_+3A_name">name</code></td>
<td>
<p>The name of the character vector to be displayed if the
construction of the factor fails.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other third-party style guide helpers: 
<code><a href="#topic+next_non_comment">next_non_comment</a>()</code>,
<code><a href="#topic+pd_is">pd_is</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scope_normalize(I("tokens"))
scope_normalize(I(c("indention", "tokens")))
</code></pre>

<hr>
<h2 id='separate_chunks'>Separate chunks within Rmd and Rnw contents</h2><span id='topic+separate_chunks'></span>

<h3>Description</h3>

<p>Identifies and separates the code and text chunks (the latter includes non-R
code) within an Rmd or Rnw file, and returns these separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_chunks(lines, filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="separate_chunks_+3A_lines">lines</code></td>
<td>
<p>A character vector of lines from an Rmd or Rnw file.</p>
</td></tr>
<tr><td><code id="separate_chunks_+3A_filetype">filetype</code></td>
<td>
<p>A string indicating the filetype - either 'Rmd' or 'Rnw'.</p>
</td></tr>
</table>

<hr>
<h2 id='serialize_parse_data_flattened'>Serialize flattened parse data</h2><span id='topic+serialize_parse_data_flattened'></span>

<h3>Description</h3>

<p>Collapses a flattened parse table into character vector representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>serialize_parse_data_flattened(flattened_pd, indent_character = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="serialize_parse_data_flattened_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table.</p>
</td></tr>
<tr><td><code id="serialize_parse_data_flattened_+3A_indent_character">indent_character</code></td>
<td>
<p>The character that is used for indention. We strongly
advise for using spaces as indention characters.</p>
</td></tr>
</table>

<hr>
<h2 id='set_and_assert_arg_filetype'>Set the file type argument</h2><span id='topic+set_and_assert_arg_filetype'></span>

<h3>Description</h3>

<p>Sets and asserts the file type argument to a standard format for further internal
processing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_and_assert_arg_filetype(filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_and_assert_arg_filetype_+3A_filetype">filetype</code></td>
<td>
<p>A character vector with file types to convert to the internal
standard format.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::set_and_assert_arg_filetype("rMd")
try(styler:::set_and_assert_arg_filetype("xyz"))
</code></pre>

<hr>
<h2 id='set_arg_paths'>Standardize paths in root</h2><span id='topic+set_arg_paths'></span>

<h3>Description</h3>

<p>Standardization required to use <code>setdiff()</code> with paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_arg_paths(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_arg_paths_+3A_path">path</code></td>
<td>
<p>A path.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>dir_without_.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::set_arg_paths(c("./file.R", "file.R", "../another-file.R"))
</code></pre>

<hr>
<h2 id='set_arg_write_tree'>Set the write_tree argument</h2><span id='topic+set_arg_write_tree'></span>

<h3>Description</h3>

<p>Sets the argument <code>write_tree</code> in <code><a href="#topic+test_collection">test_collection()</a></code> to be <code>TRUE</code> for R
versions higher or equal to 3.2, and <code>FALSE</code> otherwise since the second-level
dependency <code>DiagrammeR</code> from <code>data.tree</code> is not available for R &lt; 3.2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_arg_write_tree(write_tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_arg_write_tree_+3A_write_tree">write_tree</code></td>
<td>
<p>Whether or not to write tree.</p>
</td></tr>
</table>

<hr>
<h2 id='set_line_break_after_opening_if_call_is_multi_line'>Sets line break after opening parenthesis</h2><span id='topic+set_line_break_after_opening_if_call_is_multi_line'></span>

<h3>Description</h3>

<p>Sets line break after opening parenthesis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_line_break_after_opening_if_call_is_multi_line(
  pd,
  except_token_after = NULL,
  except_text_before = NULL,
  force_text_before = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_line_break_after_opening_if_call_is_multi_line_+3A_pd">pd</code></td>
<td>
<p>The parse table.</p>
</td></tr>
<tr><td><code id="set_line_break_after_opening_if_call_is_multi_line_+3A_except_token_after">except_token_after</code></td>
<td>
<p>The tokens after the token that cause an exception.</p>
</td></tr>
<tr><td><code id="set_line_break_after_opening_if_call_is_multi_line_+3A_except_text_before">except_text_before</code></td>
<td>
<p>A character vector with text before a token that
does not cause a line break.</p>
</td></tr>
<tr><td><code id="set_line_break_after_opening_if_call_is_multi_line_+3A_force_text_before">force_text_before</code></td>
<td>
<p>A character vector with text before &quot;'('&quot; that
forces a line break after every argument in the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In general, every call that is multi-line has a line break after the opening
parenthesis. Exceptions:
</p>

<ul>
<li><p> The token right after the parenthesis is a comment, then, the line should
be broken after the comment only. Governed by <code>except_token_after</code>.
</p>
</li>
<li><p> The name of the function called is <code>ifelse()</code> or similar, where we can
allow the condition on the same line as the function name, and we don't
impose rules on the line breaks for the subsequent arguments. Governed
by <code>except_text_before</code>.
</p>
</li>
<li><p> Some calls like <code>switch()</code> statements are always forced to become multi-
line. Governed by <code>force_text_before</code>.
</p>
</li></ul>


<hr>
<h2 id='set_line_break_around_curly_curly'>Styling around <code style="white-space: pre;">&#8288;\{\{&#8288;</code></h2><span id='topic+set_line_break_around_curly_curly'></span><span id='topic+set_space_in_curly_curly'></span>

<h3>Description</h3>

<p>With {rlang} version 0.4, a new syntactic sugar is introduced, the
curly-curly operator. It interprets this code in a special way:
<code style="white-space: pre;">&#8288;call(\{\{ x \}\})&#8288;</code>. See this
<a href="https://www.tidyverse.org/blog/2019/06/rlang-0-4-0/">blog post</a>
on the topic. Here, the curly-curly sugar is understood as two opening
curly braces, followed by an expression followed by two closing curly braces,
e.g. <code style="white-space: pre;">&#8288;\{\{1\}\}&#8288;</code>. <code style="white-space: pre;">&#8288;\{\{1\} + 1\}&#8288;</code> does not contain the curly-curly syntactic
sugar according to the above definition. On the other hand <code style="white-space: pre;">&#8288;\{\{ x + y \}\}&#8288;</code>
is recognized by styler as containing it (and is parsable code)
but will most likely give an error at runtime because the way the syntactic
sugar is defined in rlang is to use a single token within curly-curly. In
addition, because rlang parses <code style="white-space: pre;">&#8288;\{\{&#8288;</code> in a special way (just as <code style="white-space: pre;">&#8288;!!&#8288;</code>), the
expression <code style="white-space: pre;">&#8288;\{\{ x \}\}&#8288;</code> will give a runtime error when used outside of a
context that is capable of handling it, e.g. on the top-level (that is, not
within function call like <code style="white-space: pre;">&#8288;rlang_fun(\{\{ x \}\})&#8288;</code>) or within a base R
function such as <code><a href="base.html#topic+c">c()</a></code>. However, these differences are assumed to be
irrelevant for styling curly-curly, as much as they were for styling <code style="white-space: pre;">&#8288;!!&#8288;</code>.
curly-curly affects styling of line break and spaces, namely:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_line_break_around_curly_curly(pd)

set_space_in_curly_curly(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_line_break_around_curly_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> No line break after first or second <code style="white-space: pre;">&#8288;\{&#8288;</code>, before third and fourth <code style="white-space: pre;">&#8288;\{&#8288;</code>.
</p>
</li>
<li><p> No space after first and third <code style="white-space: pre;">&#8288;\{&#8288;</code>, one space after second and before
third <code style="white-space: pre;">&#8288;\}&#8288;</code>.
</p>
</li>
<li><p> No line breaks within curly-curly, e.g. <code style="white-space: pre;">&#8288;\{\{ x \}\}&#8288;</code> can only contain line
breaks after the last brace or before the first brace. But these are not
dependent on curly-curly specifically.
</p>
</li></ul>



<h3>See Also</h3>

<p>style_text_without_curly_curly
</p>

<hr>
<h2 id='set_line_break_before_curly_opening'>Set line break before a curly brace</h2><span id='topic+set_line_break_before_curly_opening'></span>

<h3>Description</h3>

<p>Rule:
</p>

<ul>
<li><p> Principle: Function arguments that consist of a braced expression always
need to start on a new line
</p>
</li>
<li><p> Exception: <a href="base.html#topic+...">...</a> unless it's the last argument and all other
arguments fit on the line of the function call
</p>
</li>
<li><p> Exception: <a href="base.html#topic+...">...</a> or they are named.
</p>
</li>
<li><p> Extension: Also, expressions following on braced expressions also cause a
line trigger.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>set_line_break_before_curly_opening(pd)
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>
tryCatch(
  {
    f(8)
  },
  error = function(e) NULL
)
# last-argument case
testthat("braces braces are cool", {
  code(to = execute)
})
call2(
  x = 2, {
    code(to = execute)
  },
  c = {
    # this is the named case
    g(x = 7)
  }
)
tryGugus(
  {
    g5(k = na)
  },
  a + b # line break also here because
  # preceded by brace expression
)

# brace expressions go on new line if part of a pipe, in function call...
c(
  data %&gt;%
    filter(bar) %&gt;%
    {
      cor(.$col1, .$col2, use = "complete.obs")
    }
)
# ... or outside
data %&gt;%
  filter(bar) %&gt;%
  {
    cor(.$col1, .$col2, use = "complete.obs")
  }

</code></pre>

<hr>
<h2 id='set_line_break_if_call_is_multi_line'>Set line break for multi-line function calls</h2><span id='topic+set_line_break_if_call_is_multi_line'></span><span id='topic+set_line_break_before_closing_call'></span><span id='topic+remove_line_break_in_fun_call'></span>

<h3>Description</h3>

<p>Set line break for multi-line function calls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_line_break_before_closing_call(pd, except_token_before)

remove_line_break_in_fun_call(pd, strict)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_line_break_if_call_is_multi_line_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="set_line_break_if_call_is_multi_line_+3A_except_token_before">except_token_before</code></td>
<td>
<p>A character vector with tokens that do
not cause a line break after them.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>set_line_break_before_closing_call()</code>: Sets line break before
closing parenthesis.
</p>
</li>
<li> <p><code>remove_line_break_in_fun_call()</code>: Remove line breaks in
function calls.
</p>
</li></ul>

<hr>
<h2 id='set_multi_line'>Set the multi-line column</h2><span id='topic+set_multi_line'></span>

<h3>Description</h3>

<p>Sets the column <code>multi_line</code> in <code>pd</code> by checking row-wise whether any child
of a token is a multi-line token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_multi_line(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_multi_line_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='set_regex_indention'>Set indention of tokens that match regex</h2><span id='topic+set_regex_indention'></span>

<h3>Description</h3>

<p>Force the level of indention of tokens whose text matches a regular
expression pattern to be a certain amount of spaces. The rule
is only active for the first tokens on a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_regex_indention(
  flattened_pd,
  pattern,
  target_indention = 0L,
  comments_only = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_regex_indention_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table.</p>
</td></tr>
<tr><td><code id="set_regex_indention_+3A_pattern">pattern</code></td>
<td>
<p>A character  with regular expressions to match against the
token in <code>flattened_pd</code>.</p>
</td></tr>
<tr><td><code id="set_regex_indention_+3A_target_indention">target_indention</code></td>
<td>
<p>The desired level of indention of the tokens that
match <code>pattern</code>.</p>
</td></tr>
<tr><td><code id="set_regex_indention_+3A_comments_only">comments_only</code></td>
<td>
<p>Boolean indicating whether only comments should be
checked or all tokens.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flattened parse table with indention set to <code>target_indention</code> for
the tokens that match <code>regex.</code>
</p>

<hr>
<h2 id='set_space_around_op'>Set spaces around operators</h2><span id='topic+set_space_around_op'></span>

<h3>Description</h3>

<p>Alignment is kept, if detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_space_around_op(pd_flat, strict)
</code></pre>

<hr>
<h2 id='set_space_between_eq_sub_and_comma'>Set space between <code>EQ_SUB</code> and <code>"','"</code></h2><span id='topic+set_space_between_eq_sub_and_comma'></span>

<h3>Description</h3>

<p>Set space between <code>EQ_SUB</code> and <code>"','"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_space_between_eq_sub_and_comma(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_space_between_eq_sub_and_comma_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='set_space_between_levels'>Set space between levels of nesting</h2><span id='topic+set_space_between_levels'></span>

<h3>Description</h3>

<p>With the nested approach, certain rules do not have an effect anymore because
of the nature of the nested structure. Setting spacing before curly
brackets in for / if / while statements and function declarations will be
such a case since a curly bracket is always at the first position in a parse
table, so spacing cannot be set after the previous token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_space_between_levels(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_space_between_levels_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='set_spaces'>Helper for setting spaces</h2><span id='topic+set_spaces'></span>

<h3>Description</h3>

<p>Helper for setting spaces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_spaces(spaces_after_prefix, force_one)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_spaces_+3A_spaces_after_prefix">spaces_after_prefix</code></td>
<td>
<p>An integer vector with the number of spaces
after the prefix.</p>
</td></tr>
<tr><td><code id="set_spaces_+3A_force_one">force_one</code></td>
<td>
<p>Whether spaces_after_prefix should be set to one in all
cases.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer vector of length spaces_after_prefix, which is either
one (if <code>force_one = TRUE</code>) or <code>space_after_prefix</code> with all values
below one set to one.
</p>
<p>Numeric vector indicating the number of spaces.
</p>

<hr>
<h2 id='set_style_transformers'>Asks the user to supply a style</h2><span id='topic+set_style_transformers'></span>

<h3>Description</h3>

<p>Asks the user to supply a style
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_style_transformers()
</code></pre>

<hr>
<h2 id='set_unindention_child'>Unindent a child if necessary</h2><span id='topic+set_unindention_child'></span>

<h3>Description</h3>

<p>check whether any of the children of <code>pd</code> has <code>token</code> on the same line as the
closing <code>token</code> of pd. If so, unindent that token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_unindention_child(pd, token = "')'", unindent_by)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_unindention_child_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="set_unindention_child_+3A_token">token</code></td>
<td>
<p>The token the unindention should be based on.</p>
</td></tr>
<tr><td><code id="set_unindention_child_+3A_unindent_by">unindent_by</code></td>
<td>
<p>By how many spaces one level of indention is reversed.</p>
</td></tr>
</table>

<hr>
<h2 id='shallowify'>Shallowify the parse table</h2><span id='topic+shallowify'></span>

<h3>Description</h3>

<p>Cached expressions don't need to be transformed with <code>transformers</code> in
<code><a href="#topic+parse_transform_serialize_r_block">parse_transform_serialize_r_block()</a></code>, we simply return <code>text</code> for the
top-level token.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shallowify(pd)
</code></pre>


<h3>Details</h3>

<p>Expressions that are cached are already styled correctly. We can make the
parse table shallow at these locations, fully relying on the <code>text</code> column:
</p>

<ul>
<li><p> remove all children, as they are not needed anymore.
</p>
</li>
<li><p> mark the expression as a terminal.
</p>
</li></ul>



<h3>Top-level comments</h3>

<p>Note that we do not cache top-level comments. Because package code has a lot
of roxygen comments and each of them is a top-level expression, checking is
very expensive. More expensive than styling, because comments are always
terminals. This will also yield large speed improvements in
<code><a href="#topic+compute_parse_data_nested">compute_parse_data_nested()</a></code> because nesting is expensive and will not be
done for cached expressions.
</p>


<h3>Implementation</h3>

<p>Because the structure of the parse table is not always &quot;top-level expression
first, then children&quot;, this function creates a temporary parse table that has
this property and then extract the ids and subset the original parse table so
it is shallow in the right places.
</p>

<hr>
<h2 id='specify_transformers_drop'>Specify which tokens must be absent for a transformer to be dropped</h2><span id='topic+specify_transformers_drop'></span>

<h3>Description</h3>

<p><code>{styler}</code> can remove transformer functions safely removed from the list of
transformers to be applied on every <em>nest</em> with <code><a href="#topic+transformers_drop">transformers_drop()</a></code> if the
tokens that trigger a manipulation of the parse data are absent in the text
to style. <code>specify_transformers_drop()</code> helps you specify these
conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>specify_transformers_drop(
  spaces = NULL,
  indention = NULL,
  line_breaks = NULL,
  tokens = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="specify_transformers_drop_+3A_spaces">spaces</code>, <code id="specify_transformers_drop_+3A_indention">indention</code>, <code id="specify_transformers_drop_+3A_line_breaks">line_breaks</code>, <code id="specify_transformers_drop_+3A_tokens">tokens</code></td>
<td>
<p>Each a list (or <code>NULL</code>) where
the name of each element is the concerning transformer, the value is an
unnamed vector with tokens that match the rule. See 'Examples'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the negative formulation (must be absent in order to be dropped)
means that when you add a new rule and you forget
to add a rule for when to drop it, it will not be dropped. If we required to
specify the complement (which tokens must be present for the transformer to
be kept), the transformer would be silently removed, which is less save.
</p>


<h3>Warning</h3>

<p>It is the responsibility of the developer to ensure expected behavior, in
particular that:
</p>

<ul>
<li><p> the name of the supplied dropping criteria matches the name of the
transformer function.
</p>
</li>
<li><p> the dropping criteria (name + token) reflects correctly under which
circumstances the transformer does not have an impact on styling and can
therefore be safely removed without affecting the styling outcome.
</p>
</li></ul>

<p>You can use the unexported function <code><a href="#topic+test_transformers_drop">test_transformers_drop()</a></code> for some
checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dropping &lt;- specify_transformers_drop(
  spaces = c(remove_space_after_excl = "'!'")
)
style_guide &lt;- create_style_guide(
  space = list(remove_space_after_excl = styler:::remove_space_after_excl),
  transformers_drop = dropping
)
# transformers_drop() will remove the transformer when the code does not
# contain an exclamation mark
style_guide_with_some_transformers_dropped &lt;- styler:::transformers_drop(
  "x &lt;- 3;2", style_guide
)
setdiff(
  names(style_guide$space),
  names(style_guide_with_some_transformers_dropped)
)
# note that dropping all transformers of a scope means that this scope
# has an empty named list for this scope
style_guide_with_some_transformers_dropped$space
# this is not the same as if this scope was never specified.
tidyverse_style(scope = "none")$space
# Hence, styler should check for length 0 to decide if a scope is present or
# not, not via `is.null()` and we can use the `is.null()` check to see if
# this scope was initially required by the user.
</code></pre>

<hr>
<h2 id='split_roxygen_segments'>Split text into roxygen and non-roxygen example segments</h2><span id='topic+split_roxygen_segments'></span>

<h3>Description</h3>

<p>Split text into roxygen and non-roxygen example segments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_roxygen_segments(text, roxygen_examples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_roxygen_segments_+3A_text">text</code></td>
<td>
<p>Roxygen comments</p>
</td></tr>
<tr><td><code id="split_roxygen_segments_+3A_roxygen_examples">roxygen_examples</code></td>
<td>
<p>Integer sequence that indicates which lines in <code>text</code>
are roxygen examples. Most conveniently obtained with
<a href="#topic+identify_start_to_stop_of_roxygen_examples_from_text">identify_start_to_stop_of_roxygen_examples_from_text</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements:
</p>

<ul>
<li><p> A list that contains elements grouped into roxygen and non-roxygen
sections. This list is named <code>separated</code>.
</p>
</li>
<li><p> An integer vector with the indices that correspond to roxygen code
examples in <code>separated</code>.
</p>
</li></ul>


<hr>
<h2 id='start_comments_with_space'>Start comments with a space</h2><span id='topic+start_comments_with_space'></span>

<h3>Description</h3>

<p>Forces comments to start with a space, that is, after the regular expression
<code style="white-space: pre;">&#8288;#+['\\*]&#8288;</code>, at least one space must follow if the comment is <em>non-empty</em>, i.e
there is not just spaces within the comment. Multiple spaces may be legit for
indention in some situations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_comments_with_space(pd, force_one = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_comments_with_space_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="start_comments_with_space_+3A_force_one">force_one</code></td>
<td>
<p>Whether or not to force one space or allow multiple spaces.</p>
</td></tr>
</table>


<h3>Exceptions</h3>

<p>Spaces won't be added to comments when they are:
</p>

<ul>
<li><p> shebangs
</p>
</li>
<li><p> code chunk headers
</p>
</li>
<li><p> xaringan markers
</p>
</li></ul>


<hr>
<h2 id='style_active_pkg'>Wrapper around <code><a href="#topic+style_pkg">style_pkg()</a></code> for access via Addin.</h2><span id='topic+style_active_pkg'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="#topic+style_pkg">style_pkg()</a></code> for access via Addin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_active_pkg()
</code></pre>

<hr>
<h2 id='style_dir'>Prettify arbitrary R code</h2><span id='topic+style_dir'></span>

<h3>Description</h3>

<p>Performs various substitutions in all <code>.R</code>, <code>.Rmd</code>, <code>.Rmarkdown</code>, <code>qmd</code>
and/or <code>.Rnw</code> files in a directory (by default only <code>.R</code> files are styled -
see <code>filetype</code> argument).
Carefully examine the results after running this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_dir(
  path = ".",
  ...,
  style = tidyverse_style,
  transformers = style(...),
  filetype = c("R", "Rprofile", "Rmd", "Rmarkdown", "Rnw", "Qmd"),
  recursive = TRUE,
  exclude_files = NULL,
  exclude_dirs = c("packrat", "renv"),
  include_roxygen_examples = TRUE,
  base_indention = 0L,
  dry = "off"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_dir_+3A_path">path</code></td>
<td>
<p>Path to a directory with files to transform.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>style</code> function,
see <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> for the default argument.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_style">style</code></td>
<td>
<p>A function that creates a style guide to use, by default
<code><a href="#topic+tidyverse_style">tidyverse_style</a></code>. Not used
further except to construct the argument <code>transformers</code>. See
<code><a href="#topic+style_guides">style_guides()</a></code> for details.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_transformers">transformers</code></td>
<td>
<p>A set of transformer functions. This argument is most
conveniently constructed via the <code>style</code> argument and <code>...</code>. See
'Examples'.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_filetype">filetype</code></td>
<td>
<p>Vector of file extensions indicating which file types should
be styled. Case is ignored, and the <code>.</code> is optional, e.g. <code>c(".R",".Rmd")</code>,
or <code>c("r", "rmd")</code>. Supported values (after standardization) are:
&quot;qmd&quot;, &quot;r&quot;, &quot;rmd&quot;, &quot;rmarkdown&quot;, &quot;rnw&quot;, and &quot;rprofile&quot;.
Rmarkdown is treated as Rmd.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_recursive">recursive</code></td>
<td>
<p>A logical value indicating whether or not files in
sub directories of <code>path</code> should be styled as well.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_exclude_files">exclude_files</code></td>
<td>
<p>Character vector with regular expressions to files
that should be excluded from styling.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_exclude_dirs">exclude_dirs</code></td>
<td>
<p>Character vector with directories to exclude
(recursively).</p>
</td></tr>
<tr><td><code id="style_dir_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="style_dir_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a data frame that indicates for each file considered for
styling whether or not it was actually changed (or would be changed when
<code>dry</code> is not &quot;off&quot;).
</p>


<h3>Warning</h3>

<p>This function overwrites files (if styling results in a change of the
code to be formatted and <code>dry = "off"</code>). It is strongly suggested to only
style files that are under version control or to create a backup copy.
</p>
<p>We suggest to first style with <code>scope &lt; "tokens"</code> and inspect and commit
changes, because these changes are guaranteed to leave the abstract syntax
tree (AST) unchanged. See section 'Round trip validation' for details.
</p>
<p>Then, we suggest to style with <code>scope = "tokens"</code> (if desired) and carefully
inspect the changes to make sure the AST is not changed in an unexpected way
that invalidates code.
</p>


<h3>Round trip validation</h3>

<p>The following section describes when and how styling is guaranteed to
yield correct code.
</p>
<p>If tokens are not in the styling scope (as specified with the <code>scope</code>
argument), no tokens are changed and the abstract syntax tree (AST) should
not change.
Hence, it is possible to validate the styling by comparing whether the parsed
expression before and after styling have the same AST.
This comparison omits roxygen code examples and comments. styler throws an
error if the AST has changed through styling.
</p>
<p>Note that if tokens are to be styled, such a comparison is not conducted because
the AST might well change and such a change is intended. There is no way
styler can validate styling, that is why we inform the user to carefully
inspect the changes.
</p>
<p>See section 'Warning' for a good strategy to apply styling safely.
</p>


<h3>See Also</h3>

<p>Other stylers: 
<code><a href="#topic+style_file">style_file</a>()</code>,
<code><a href="#topic+style_pkg">style_pkg</a>()</code>,
<code><a href="#topic+style_text">style_text</a>()</code>,
<code><a href="#topic+styler_addins">styler_addins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
style_dir("path/to/dir", filetype = c("rmd", ".R"))

# the following is identical (because of ... and defaults)
# but the first is most convenient:
style_dir(strict = TRUE)
style_dir(style = tidyverse_style, strict = TRUE)
style_dir(transformers = tidyverse_style(strict = TRUE))

</code></pre>

<hr>
<h2 id='style_file'>Style files with R source code</h2><span id='topic+style_file'></span>

<h3>Description</h3>

<p>Performs various substitutions in the files specified.
Carefully examine the results after running this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_file(
  path,
  ...,
  style = tidyverse_style,
  transformers = style(...),
  include_roxygen_examples = TRUE,
  base_indention = 0L,
  dry = "off"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_file_+3A_path">path</code></td>
<td>
<p>A character vector with paths to files to style. Supported
extensions: <code>.R</code>, <code>.Rmd</code>, <code>.Rmarkdown</code>, <code>.qmd</code> and <code>.Rnw</code>.</p>
</td></tr>
<tr><td><code id="style_file_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>style</code> function,
see <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> for the default argument.</p>
</td></tr>
<tr><td><code id="style_file_+3A_style">style</code></td>
<td>
<p>A function that creates a style guide to use, by default
<code><a href="#topic+tidyverse_style">tidyverse_style</a></code>. Not used
further except to construct the argument <code>transformers</code>. See
<code><a href="#topic+style_guides">style_guides()</a></code> for details.</p>
</td></tr>
<tr><td><code id="style_file_+3A_transformers">transformers</code></td>
<td>
<p>A set of transformer functions. This argument is most
conveniently constructed via the <code>style</code> argument and <code>...</code>. See
'Examples'.</p>
</td></tr>
<tr><td><code id="style_file_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="style_file_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="style_file_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>


<h3>Encoding</h3>

<p>UTF-8 encoding is assumed. Please convert your code to UTF-8 if necessary
before applying styler.
</p>


<h3>Value</h3>

<p>Invisibly returns a data frame that indicates for each file considered for
styling whether or not it was actually changed (or would be changed when
<code>dry</code> is not &quot;off&quot;).
</p>


<h3>Warning</h3>

<p>This function overwrites files (if styling results in a change of the
code to be formatted and <code>dry = "off"</code>). It is strongly suggested to only
style files that are under version control or to create a backup copy.
</p>
<p>We suggest to first style with <code>scope &lt; "tokens"</code> and inspect and commit
changes, because these changes are guaranteed to leave the abstract syntax
tree (AST) unchanged. See section 'Round trip validation' for details.
</p>
<p>Then, we suggest to style with <code>scope = "tokens"</code> (if desired) and carefully
inspect the changes to make sure the AST is not changed in an unexpected way
that invalidates code.
</p>


<h3>Round trip validation</h3>

<p>The following section describes when and how styling is guaranteed to
yield correct code.
</p>
<p>If tokens are not in the styling scope (as specified with the <code>scope</code>
argument), no tokens are changed and the abstract syntax tree (AST) should
not change.
Hence, it is possible to validate the styling by comparing whether the parsed
expression before and after styling have the same AST.
This comparison omits roxygen code examples and comments. styler throws an
error if the AST has changed through styling.
</p>
<p>Note that if tokens are to be styled, such a comparison is not conducted because
the AST might well change and such a change is intended. There is no way
styler can validate styling, that is why we inform the user to carefully
inspect the changes.
</p>
<p>See section 'Warning' for a good strategy to apply styling safely.
</p>


<h3>See Also</h3>

<p>Other stylers: 
<code><a href="#topic+style_dir">style_dir</a>()</code>,
<code><a href="#topic+style_pkg">style_pkg</a>()</code>,
<code><a href="#topic+style_text">style_text</a>()</code>,
<code><a href="#topic+styler_addins">styler_addins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- tempfile("styler", fileext = ".R")
writeLines("1++1", file)

# the following is identical (because of ... and defaults),
# but the first is most convenient:
style_file(file, strict = TRUE)
style_file(file, style = tidyverse_style, strict = TRUE)
style_file(file, transformers = tidyverse_style(strict = TRUE))

# only style indention and less invasive  levels (i.e. spaces)
style_file(file, scope = "indention", strict = TRUE)
# name levels explicitly to not style less invasive levels
style_file(file, scope = I(c("tokens", "spaces")), strict = TRUE)

readLines(file)
unlink(file)
</code></pre>

<hr>
<h2 id='style_guides'>Style guides</h2><span id='topic+style_guides'></span>

<h3>Description</h3>

<p>Format code according to a style guide. Style guides are the input to the
argument <code>style</code> in <code><a href="#topic+style_file">style_file()</a></code> and friends.
The available style guides are:
</p>

<ul>
<li><p> the tidyverse style guide (see <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>).
</p>
</li></ul>


<hr>
<h2 id='style_pkg'>Prettify R source code</h2><span id='topic+style_pkg'></span>

<h3>Description</h3>

<p>Performs various substitutions in all <code>.R</code> files in a package
(code and tests), <code>.Rmd</code>, <code>.Rmarkdown</code> and/or
<code>.qmd</code>, <code>.Rnw</code> files (vignettes and readme).
Carefully examine the results after running this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_pkg(
  pkg = ".",
  ...,
  style = tidyverse_style,
  transformers = style(...),
  filetype = c("R", "Rprofile", "Rmd", "Rmarkdown", "Rnw", "qmd"),
  exclude_files = c("R/RcppExports\\.R", "R/cpp11\\.R",
    "R/import-standalone.*\\.R"),
  exclude_dirs = c("packrat", "renv"),
  include_roxygen_examples = TRUE,
  base_indention = 0L,
  dry = "off"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_pkg_+3A_pkg">pkg</code></td>
<td>
<p>Path to a (subdirectory of an) R package.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>style</code> function,
see <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> for the default argument.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_style">style</code></td>
<td>
<p>A function that creates a style guide to use, by default
<code><a href="#topic+tidyverse_style">tidyverse_style</a></code>. Not used
further except to construct the argument <code>transformers</code>. See
<code><a href="#topic+style_guides">style_guides()</a></code> for details.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_transformers">transformers</code></td>
<td>
<p>A set of transformer functions. This argument is most
conveniently constructed via the <code>style</code> argument and <code>...</code>. See
'Examples'.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_filetype">filetype</code></td>
<td>
<p>Vector of file extensions indicating which file types should
be styled. Case is ignored, and the <code>.</code> is optional, e.g. <code>c(".R",".Rmd")</code>,
or <code>c("r", "rmd")</code>. Supported values (after standardization) are:
&quot;qmd&quot;, &quot;r&quot;, &quot;rmd&quot;, &quot;rmarkdown&quot;, &quot;rnw&quot;, and &quot;rprofile&quot;.
Rmarkdown is treated as Rmd.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_exclude_files">exclude_files</code></td>
<td>
<p>Character vector with regular expressions to files
that should be excluded from styling.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_exclude_dirs">exclude_dirs</code></td>
<td>
<p>Character vector with directories to exclude
(recursively). Note that the default values were set for consistency with
<code><a href="#topic+style_dir">style_dir()</a></code> and as these directories are anyways not styled.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="style_pkg_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This function overwrites files (if styling results in a change of the
code to be formatted and <code>dry = "off"</code>). It is strongly suggested to only
style files that are under version control or to create a backup copy.
</p>
<p>We suggest to first style with <code>scope &lt; "tokens"</code> and inspect and commit
changes, because these changes are guaranteed to leave the abstract syntax
tree (AST) unchanged. See section 'Round trip validation' for details.
</p>
<p>Then, we suggest to style with <code>scope = "tokens"</code> (if desired) and carefully
inspect the changes to make sure the AST is not changed in an unexpected way
that invalidates code.
</p>


<h3>Round trip validation</h3>

<p>The following section describes when and how styling is guaranteed to
yield correct code.
</p>
<p>If tokens are not in the styling scope (as specified with the <code>scope</code>
argument), no tokens are changed and the abstract syntax tree (AST) should
not change.
Hence, it is possible to validate the styling by comparing whether the parsed
expression before and after styling have the same AST.
This comparison omits roxygen code examples and comments. styler throws an
error if the AST has changed through styling.
</p>
<p>Note that if tokens are to be styled, such a comparison is not conducted because
the AST might well change and such a change is intended. There is no way
styler can validate styling, that is why we inform the user to carefully
inspect the changes.
</p>
<p>See section 'Warning' for a good strategy to apply styling safely.
</p>


<h3>Value</h3>

<p>Invisibly returns a data frame that indicates for each file considered for
styling whether or not it was actually changed (or would be changed when
<code>dry</code> is not &quot;off&quot;).
</p>


<h3>See Also</h3>

<p>Other stylers: 
<code><a href="#topic+style_dir">style_dir</a>()</code>,
<code><a href="#topic+style_file">style_file</a>()</code>,
<code><a href="#topic+style_text">style_text</a>()</code>,
<code><a href="#topic+styler_addins">styler_addins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# the following is identical (because of ... and defaults)
# but the first is most convenient:
style_pkg(strict = TRUE)
style_pkg(style = tidyverse_style, strict = TRUE)
style_pkg(transformers = tidyverse_style(strict = TRUE))

# more options from `tidyverse_style()`
style_pkg(
  scope = "line_breaks",
  math_token_spacing = specify_math_token_spacing(zero = "'+'")
)

# don't write back and fail if input is not already styled
style_pkg("/path/to/pkg/", dry = "fail")

</code></pre>

<hr>
<h2 id='style_roxygen_code_example'>Style a roxygen code example that may contain dontrun and friends</h2><span id='topic+style_roxygen_code_example'></span>

<h3>Description</h3>

<p>Parses roxygen2 comments into code, breaks it into dont* (dontrun, donttest,
dontshow) and run sections and processes each segment individually using
<code><a href="#topic+style_roxygen_example_snippet">style_roxygen_example_snippet()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_roxygen_code_example(example, transformers, base_indention)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_roxygen_code_example_+3A_example">example</code></td>
<td>
<p>Roxygen example code.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>


<h3>Hierarchy</h3>

<p>Styling involves splitting roxygen example code into segments, and segments
into snippets. This describes the process for input of
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>:
</p>

<ul>
<li><p> Splitting code into roxygen example code and other code. Downstream,
we are only concerned about roxygen code. See
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>.
</p>
</li>
<li><p> Every roxygen example code can have zero or more
dontrun / dontshow / donttest sequences. We next create segments of roxygen
code examples that contain at most one of these. See
<code><a href="#topic+style_roxygen_code_example">style_roxygen_code_example()</a></code>.
</p>
</li>
<li><p> We further split the segment that contains at most one dont* sequence into
snippets that are either don* or not. See
<code><a href="#topic+style_roxygen_code_example_segment">style_roxygen_code_example_segment()</a></code>.
</p>
</li></ul>

<p>Finally, that we have roxygen code snippets that are either dont* or not,
we style them in <code><a href="#topic+style_roxygen_example_snippet">style_roxygen_example_snippet()</a></code> using
<code><a href="#topic+parse_transform_serialize_r">parse_transform_serialize_r()</a></code>.
</p>

<hr>
<h2 id='style_roxygen_code_example_one'>Style a roxygen code example with exactly one <code style="white-space: pre;">&#8288;@example&#8288;</code> or <code style="white-space: pre;">&#8288;@exampleIf&#8288;</code></h2><span id='topic+style_roxygen_code_example_one'></span>

<h3>Description</h3>

<p>Style a roxygen code example with exactly one <code style="white-space: pre;">&#8288;@example&#8288;</code> or <code style="white-space: pre;">&#8288;@exampleIf&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_roxygen_code_example_one(example_one, transformers, base_indention)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_roxygen_code_example_one_+3A_example_one">example_one</code></td>
<td>
<p>A character vector, one element per line, that contains in
total at most one example tag.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_one_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_one_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>

<hr>
<h2 id='style_roxygen_code_example_segment'>Style a roxygen code example segment</h2><span id='topic+style_roxygen_code_example_segment'></span>

<h3>Description</h3>

<p>A roxygen code example segment corresponds to roxygen example code that
contains at most one <code style="white-space: pre;">&#8288;\\dontrun{...}&#8288;</code> or friends.
We drop all newline characters first because otherwise the code segment
passed to this function was previously parsed with <code><a href="#topic+parse_roxygen">parse_roxygen()</a></code> and
line-breaks in and after the <code style="white-space: pre;">&#8288;\\dontrun{...}&#8288;</code> are expressed with <code>"\n"</code>,
which contradicts to the definition used elsewhere in this package, where
every element in a vector corresponds to a line. These line-breaks don't get
eliminated because they move to the front of a <code>code_segment</code> and
<code>style_text("\n1")</code> gives <code>"\n1"</code>, i.e. trailing newlines are not
eliminated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_roxygen_code_example_segment(one_dont, transformers, base_indention)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_roxygen_code_example_segment_+3A_one_dont">one_dont</code></td>
<td>
<p>Bare R code containing at most one <code style="white-space: pre;">&#8288;\\dontrun{...}&#8288;</code> or
friends.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_segment_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="style_roxygen_code_example_segment_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>


<h3>Hierarchy</h3>

<p>Styling involves splitting roxygen example code into segments, and segments
into snippets. This describes the process for input of
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>:
</p>

<ul>
<li><p> Splitting code into roxygen example code and other code. Downstream,
we are only concerned about roxygen code. See
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>.
</p>
</li>
<li><p> Every roxygen example code can have zero or more
dontrun / dontshow / donttest sequences. We next create segments of roxygen
code examples that contain at most one of these. See
<code><a href="#topic+style_roxygen_code_example">style_roxygen_code_example()</a></code>.
</p>
</li>
<li><p> We further split the segment that contains at most one dont* sequence into
snippets that are either don* or not. See
<code><a href="#topic+style_roxygen_code_example_segment">style_roxygen_code_example_segment()</a></code>.
</p>
</li></ul>

<p>Finally, that we have roxygen code snippets that are either dont* or not,
we style them in <code><a href="#topic+style_roxygen_example_snippet">style_roxygen_example_snippet()</a></code> using
<code><a href="#topic+parse_transform_serialize_r">parse_transform_serialize_r()</a></code>.
</p>

<hr>
<h2 id='style_roxygen_example_snippet'>Given a code snippet is dont* or run, style it</h2><span id='topic+style_roxygen_example_snippet'></span>

<h3>Description</h3>

<p>Given a code snippet is dont* or run, style it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_roxygen_example_snippet(
  code_snippet,
  transformers,
  is_dont,
  base_indention
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_roxygen_example_snippet_+3A_code_snippet">code_snippet</code></td>
<td>
<p>A character vector with code to style.</p>
</td></tr>
<tr><td><code id="style_roxygen_example_snippet_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="style_roxygen_example_snippet_+3A_is_dont">is_dont</code></td>
<td>
<p>Whether the snippet to process is a dontrun, dontshow,
donttest segment or not.</p>
</td></tr>
<tr><td><code id="style_roxygen_example_snippet_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>


<h3>Hierarchy</h3>

<p>Styling involves splitting roxygen example code into segments, and segments
into snippets. This describes the process for input of
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>:
</p>

<ul>
<li><p> Splitting code into roxygen example code and other code. Downstream,
we are only concerned about roxygen code. See
<code><a href="#topic+parse_transform_serialize_roxygen">parse_transform_serialize_roxygen()</a></code>.
</p>
</li>
<li><p> Every roxygen example code can have zero or more
dontrun / dontshow / donttest sequences. We next create segments of roxygen
code examples that contain at most one of these. See
<code><a href="#topic+style_roxygen_code_example">style_roxygen_code_example()</a></code>.
</p>
</li>
<li><p> We further split the segment that contains at most one dont* sequence into
snippets that are either don* or not. See
<code><a href="#topic+style_roxygen_code_example_segment">style_roxygen_code_example_segment()</a></code>.
</p>
</li></ul>

<p>Finally, that we have roxygen code snippets that are either dont* or not,
we style them in <code><a href="#topic+style_roxygen_example_snippet">style_roxygen_example_snippet()</a></code> using
<code><a href="#topic+parse_transform_serialize_r">parse_transform_serialize_r()</a></code>.
</p>

<hr>
<h2 id='style_selection'>Styles the highlighted selection in a <code>.R</code> or <code>.Rmd</code> file.</h2><span id='topic+style_selection'></span>

<h3>Description</h3>

<p>Styles the highlighted selection in a <code>.R</code> or <code>.Rmd</code> file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_selection()
</code></pre>

<hr>
<h2 id='style_space_around_math_token'>Style spacing around math tokens</h2><span id='topic+style_space_around_math_token'></span>

<h3>Description</h3>

<p>Style spacing around math tokens
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_space_around_math_token(strict, zero, one, pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_space_around_math_token_+3A_strict">strict</code></td>
<td>
<p>Whether the rules should be applied strictly or not.</p>
</td></tr>
<tr><td><code id="style_space_around_math_token_+3A_zero">zero</code></td>
<td>
<p>Character vector of tokens that should be surrounded with zero
spaces.</p>
</td></tr>
<tr><td><code id="style_space_around_math_token_+3A_one">one</code></td>
<td>
<p>Character vector with tokens that should be surrounded by at
least one space (depending on <code>strict = TRUE</code> in the styling functions
<code><a href="#topic+style_text">style_text()</a></code> and friends). See 'Examples'.</p>
</td></tr>
<tr><td><code id="style_space_around_math_token_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A nest or a flat parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='style_space_around_token'>Set spacing of token to a certain level</h2><span id='topic+style_space_around_token'></span>

<h3>Description</h3>

<p>Set the spacing of all <code>tokens</code> in <code>pd_flat</code> to <code>level</code> if <code>strict = TRUE</code> or
to at least to <code>level</code> if <code>strict = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_space_around_token(
  pd_flat,
  strict,
  tokens,
  level_before,
  level_after = level_before
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_space_around_token_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A nest or a flat parse table.</p>
</td></tr>
<tr><td><code id="style_space_around_token_+3A_strict">strict</code></td>
<td>
<p>Whether the rules should be applied strictly or not.</p>
</td></tr>
<tr><td><code id="style_space_around_token_+3A_tokens">tokens</code></td>
<td>
<p>Character vector with tokens that should be styled.</p>
</td></tr>
<tr><td><code id="style_space_around_token_+3A_level_before">level_before</code>, <code id="style_space_around_token_+3A_level_after">level_after</code></td>
<td>
<p>Scalar indicating the amount of spaces that
should be inserted around the <code>tokens</code> on the left and right position
respectively.</p>
</td></tr>
</table>

<hr>
<h2 id='style_text'>Style a string</h2><span id='topic+style_text'></span>

<h3>Description</h3>

<p>Styles a character vector. Each element of the character vector corresponds
to one line of code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_text(
  text,
  ...,
  style = tidyverse_style,
  transformers = style(...),
  include_roxygen_examples = TRUE,
  base_indention = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="style_text_+3A_text">text</code></td>
<td>
<p>A character vector with text to style.</p>
</td></tr>
<tr><td><code id="style_text_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the <code>style</code> function,
see <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> for the default argument.</p>
</td></tr>
<tr><td><code id="style_text_+3A_style">style</code></td>
<td>
<p>A function that creates a style guide to use, by default
<code><a href="#topic+tidyverse_style">tidyverse_style</a></code>. Not used
further except to construct the argument <code>transformers</code>. See
<code><a href="#topic+style_guides">style_guides()</a></code> for details.</p>
</td></tr>
<tr><td><code id="style_text_+3A_transformers">transformers</code></td>
<td>
<p>A set of transformer functions. This argument is most
conveniently constructed via the <code>style</code> argument and <code>...</code>. See
'Examples'.</p>
</td></tr>
<tr><td><code id="style_text_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="style_text_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other stylers: 
<code><a href="#topic+style_dir">style_dir</a>()</code>,
<code><a href="#topic+style_file">style_file</a>()</code>,
<code><a href="#topic+style_pkg">style_pkg</a>()</code>,
<code><a href="#topic+styler_addins">styler_addins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("call( 1)")
style_text("1    + 1", strict = FALSE)

# the following is identical (because of ... and defaults)
# but the first is most convenient:
style_text("a&lt;-3++1", strict = TRUE)
style_text("a&lt;-3++1", style = tidyverse_style, strict = TRUE)
style_text("a&lt;-3++1", transformers = tidyverse_style(strict = TRUE))

# more invasive scopes include less invasive scopes by default
style_text("a%&gt;%b", scope = "spaces")
style_text("a%&gt;%b; a", scope = "line_breaks")
style_text("a%&gt;%b; a", scope = "tokens")

# opt out with I() to only style specific levels
style_text("a%&gt;%b; a", scope = I("tokens"))
</code></pre>

<hr>
<h2 id='style_text_without_curly_curly'><code>style_text()</code> without rules for <code style="white-space: pre;">&#8288;\{\{&#8288;</code></h2><span id='topic+style_text_without_curly_curly'></span>

<h3>Description</h3>

<p>This function mocks <code><a href="#topic+style_text">style_text()</a></code>, but without taking into consideration the
rules for the curly-curly syntactic sugar (introduced in rlang 0.4).
This function (<code>style_text_without_curly_curly()</code>) is needed for testing
only, namely to test indention
with multiple curly braces in a sequence. It is important to maintain testing
for indention rules even as the curly-curly expression is always kept on the
same line in the tidyverse style guide because we should
ensure the underlying mechanics for indention work correctly. When
indention mechanisms are changed later, e.g. by simplifying
<code><a href="#topic+compute_indent_indices">compute_indent_indices()</a></code>, we must have
a way of testing this without the interaction of <code style="white-space: pre;">&#8288;\{\{&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_text_without_curly_curly(
  text,
  ...,
  style = tidyverse_style,
  transformers = style(...),
  include_roxygen_examples = TRUE
)
</code></pre>


<h3>See Also</h3>

<p>set_line_break_around_curly_curly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::style_text_without_curly_curly("rlang::list2({{ x }} := 2L)")
styler:::style_text("rlang::list2({{ x }} := 3)")
</code></pre>

<hr>
<h2 id='styler_addins'>Stylers for RStudio Addins</h2><span id='topic+styler_addins'></span>

<h3>Description</h3>

<p>Helper functions for styling via RStudio Addins.
</p>


<h3>Addins</h3>


<ul>
<li><p> Set style: Select the style transformers to use. For flexibility, the user
input is passed to the <code>transformers</code> argument, not the <code>style</code> argument,
so entering <code>styler::tidyverse_style(scope = "spaces")</code> in the Addin is
equivalent to <code>styler::style_text("1+1", scope = "spaces")</code> and
<code>styler::style_text("1+1", transformers = styler::tidyverse_style(scope = "spaces"))</code>
if the text to style is <code>1+1</code>. The style transformers are memorized
within an R session via the R option <code>styler.addins_style_transformer</code> so
if you want it to persist over sessions, set the option
<code>styler.addins_style_transformer</code> in your <code>.Rprofile</code>.
</p>
</li>
<li><p> Style active file: Styles the active file, by default with
<code><a href="#topic+tidyverse_style">tidyverse_style()</a></code> or the value of the option
<code>styler.addins_style_transformer</code> if specified.
</p>
</li>
<li><p> Style selection: Same as <em>Style active file</em>, but styles the highlighted
code instead of the whole file.
</p>
</li></ul>



<h3>Auto-Save Option</h3>

<p>By default, both of the RStudio Addins will apply styling to the (selected)
file contents without saving changes. Automatic saving can be enabled by
setting the R option <code>styler.save_after_styling</code> to <code>TRUE</code>.
Consider setting this in your <code>.Rprofile</code> file if you want to persist
this setting across multiple sessions. Untitled files will always need to be
saved manually after styling.
</p>


<h3>Life cycle</h3>

<p>The way of specifying the style in the Addin as well as the auto-save option
(see below) are experimental. We are currently considering letting the user
specify the defaults for other style APIs like <code><a href="#topic+style_text">style_text()</a></code>,
either via R options, config files or other ways as well.
See <a href="https://github.com/r-lib/styler/issues/319">r-lib/styler#319</a> for
the current status of this.
</p>


<h3>See Also</h3>

<p>Other stylers: 
<code><a href="#topic+style_dir">style_dir</a>()</code>,
<code><a href="#topic+style_file">style_file</a>()</code>,
<code><a href="#topic+style_pkg">style_pkg</a>()</code>,
<code><a href="#topic+style_text">style_text</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# save after styling when using the Addin
options(styler.save_after_styling = TRUE)
# only style with scope = "spaces" when using the Addin
val &lt;- "styler::tidyverse_style(scope = 'spaces')"
options(
  styler.addins_style_transformer = val
)

## End(Not run)
</code></pre>

<hr>
<h2 id='stylerignore'>Turn off styling for parts of the code</h2><span id='topic+stylerignore'></span>

<h3>Description</h3>

<p>Using stylerignore markers, you can temporarily turn off styler. Beware that
for <code style="white-space: pre;">&#8288;styler &gt; 1.2.0&#8288;</code>, some alignment is
<a href="https://styler.r-lib.org/articles/detect-alignment.html">detected by styler</a>,
making stylerignore redundant. See a few illustrative examples below.
</p>


<h3>Details</h3>

<p>Styling is on for all lines by default when you run styler.
</p>

<ul>
<li><p> To mark the start of a sequence where you want to turn styling off, use
<code style="white-space: pre;">&#8288;# styler: off&#8288;</code>.
</p>
</li>
<li><p> To mark the end of this sequence, put <code style="white-space: pre;">&#8288;# styler: on&#8288;</code> in your code. After
that line, styler will again format your code.
</p>
</li>
<li><p> To ignore an inline statement (i.e. just one line), place <code style="white-space: pre;">&#8288;# styler: off&#8288;</code>
at the end of the line.
To use something else as start and stop markers, set the R options
<code>styler.ignore_start</code> and
<code>styler.ignore_stop</code> using <code><a href="base.html#topic+options">options()</a></code>. For styler version &gt; 1.6.2, the
option supports character vectors longer than one and the marker are not
exactly matched, but using a  regular expression, which means you can have
multiple marker on one line, e.g. <code style="white-space: pre;">&#8288;# nolint start styler: off&#8288;</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># as long as the order of the markers is correct, the lines are ignored.
style_text(
  "
  1+1
  # styler: off
  1+1
  # styler: on
  1+1
  "
)

# if there is a stop marker before a start marker, styler won't be able
# to figure out which lines you want to ignore and won't ignore anything,
# issuing a warning.
## Not run: 
style_text(
  "
  1+1
  # styler: off
  1+1
  # styler: off
  1+1
  "
)

## End(Not run)
# some alignment of code is detected, so you don't need to use stylerignore
style_text(
  "call(
    xyz =  3,
    x   = 11
  )"
)
</code></pre>

<hr>
<h2 id='stylerignore_consolidate_col'>Consolidate columns after a merge</h2><span id='topic+stylerignore_consolidate_col'></span>

<h3>Description</h3>

<p>After <code><a href="base.html#topic+merge">base::merge()</a></code>, all non-id columns that were present in <code>x</code> and <code>y</code>
do get a suffix <code>.x</code> and <code>.y</code>. If the <code>y</code> value is missing, use the <code>x</code>
value (because the information for this token was not stylerignored),
otherwise the <code>y</code> value (i.e. the styled value).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stylerignore_consolidate_col(
  flattened_pd,
  col,
  col_x = paste0(col, ".x"),
  col_y = paste0(col, ".y")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stylerignore_consolidate_col_+3A_flattened_pd">flattened_pd</code></td>
<td>
<p>A flattened parse table.</p>
</td></tr>
<tr><td><code id="stylerignore_consolidate_col_+3A_col">col</code></td>
<td>
<p>A string indicating the name of the column that should be
consolidated.</p>
</td></tr>
<tr><td><code id="stylerignore_consolidate_col_+3A_col_x">col_x</code>, <code id="stylerignore_consolidate_col_+3A_col_y">col_y</code></td>
<td>
<p>The name of the column from the left (right) parent to
consolidate.</p>
</td></tr>
</table>

<hr>
<h2 id='test_collection'>Run a collection of tests</h2><span id='topic+test_collection'></span>

<h3>Description</h3>

<p>Run transformations on all *-in.R files in a test directory and compare them
with their *-out.R counterpart.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_collection(
  test,
  sub_test = NULL,
  dry = "off",
  write_tree = NA,
  transformer,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_collection_+3A_test">test</code></td>
<td>
<p>The test to run. It corresponds to a folder name in
tests/testthat.</p>
</td></tr>
<tr><td><code id="test_collection_+3A_sub_test">sub_test</code></td>
<td>
<p>A regex pattern to further reduce the amount of test files
to be tested in the test. <code>sub_test</code> must match the beginning of file
names in tests/testthat. <code>NULL</code> matches all files.</p>
</td></tr>
<tr><td><code id="test_collection_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
<tr><td><code id="test_collection_+3A_write_tree">write_tree</code></td>
<td>
<p>Whether or not the tree structure of the test should be
computed and written to a file. Note that this needs R &gt;= 3.2
(see <code><a href="#topic+set_arg_write_tree">set_arg_write_tree()</a></code>). If the argument is set to <code>NA</code>, the function
determines whether R &gt;= 3.2 is in use and if so, trees will be written.</p>
</td></tr>
<tr><td><code id="test_collection_+3A_transformer">transformer</code></td>
<td>
<p>A function to apply to the content of <code>in_item</code>.</p>
</td></tr>
<tr><td><code id="test_collection_+3A_...">...</code></td>
<td>
<p>Parameters passed to transformer function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each file name that matches <code>test</code> and <code>sub_test</code> and ends with
&quot;-in.R&quot; is considered as an input to test. Its counterpart,
the reference to compare it against is the *-out.R file. It is constructed
by taking the substring of the *-in.R file before the
last dash and adding -out.R. In contrast to older versions of this
function, every *-out.R file has just one in file.
</p>

<hr>
<h2 id='test_dry'>Test the dry argument</h2><span id='topic+test_dry'></span>

<h3>Description</h3>

<p>Test the dry argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_dry(path, styler, styled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_dry_+3A_path">path</code></td>
<td>
<p>A path to pass to the <code>styler</code>.</p>
</td></tr>
<tr><td><code id="test_dry_+3A_styler">styler</code></td>
<td>
<p>A function that takes <code>path</code>, typically a user exposed styler
function that has side effects, like <code><a href="#topic+style_file">style_file()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='test_transformer'>Transforming test input with a transformer function</h2><span id='topic+test_transformer'></span><span id='topic+style_empty'></span><span id='topic+style_op'></span>

<h3>Description</h3>

<p>These functions can be used as inputs for <code><a href="#topic+test_collection">test_collection()</a></code> and
<code><a href="#topic+transform_and_check">transform_and_check()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>style_empty(text, base_indention = 0L)

style_op(text, base_indention = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_transformer_+3A_text">text</code></td>
<td>
<p>A character vector to transform.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As inputs for <code><a href="#topic+test_collection">test_collection()</a></code>, we can also use top-level functions such
as <code><a href="#topic+style_text">style_text()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>style_empty()</code>: Nest and unnest <code>text</code> without applying any
transformations but remove EOL spaces and indention due to the way the
serialization is set up.
</p>
</li>
<li> <p><code>style_op()</code>: Transformations for indention based on operators
</p>
</li></ul>

<hr>
<h2 id='test_transformers_drop'>Test <code>transformers_drop</code> for consistency</h2><span id='topic+test_transformers_drop'></span>

<h3>Description</h3>

<p>Check if the argument <code>transformers_drop</code> in <code><a href="#topic+create_style_guide">create_style_guide()</a></code> is
consistent with the transformers specified in that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_transformers_drop(transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_transformers_drop_+3A_transformers">transformers</code></td>
<td>
<p>The output of <code><a href="#topic+create_style_guide">create_style_guide()</a></code> we want to test.</p>
</td></tr>
</table>

<hr>
<h2 id='testthat_file'>Create the path to a test that file</h2><span id='topic+testthat_file'></span>

<h3>Description</h3>

<p>Create the path to a test that file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testthat_file(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="testthat_file_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+file.path">file.path()</a></code> to construct the path after
&quot;.../tests/testthat/&quot;</p>
</td></tr>
</table>

<hr>
<h2 id='text_to_flat_pd'>Creates a flat parse table with minimal initialization</h2><span id='topic+text_to_flat_pd'></span>

<h3>Description</h3>

<p>Creates a flat parse table with minimal initialization and makes the parse
table shallow where appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>text_to_flat_pd(text, transformers, more_specs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="text_to_flat_pd_+3A_text">text</code></td>
<td>
<p>The text to parse.</p>
</td></tr>
<tr><td><code id="text_to_flat_pd_+3A_transformers">transformers</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
<tr><td><code id="text_to_flat_pd_+3A_more_specs">more_specs</code></td>
<td>
<p>Passed to <code><a href="#topic+cache_make_key">cache_make_key()</a></code> to generate a key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This includes:
</p>

<ul>
<li><p> token before and after.
</p>
</li>
<li><p> stylerignore attribute.
</p>
</li>
<li><p> caching attributes.
</p>
</li></ul>

<p>Note that the parse table might be shallow if caching is enabled and some
values are cached.
</p>

<hr>
<h2 id='tidyverse_style'>The tidyverse style</h2><span id='topic+tidyverse_style'></span>

<h3>Description</h3>

<p>Style code according to the tidyverse style guide.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidyverse_style(
  scope = "tokens",
  strict = TRUE,
  indent_by = 2L,
  start_comments_with_one_space = FALSE,
  reindention = tidyverse_reindention(),
  math_token_spacing = tidyverse_math_token_spacing()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidyverse_style_+3A_scope">scope</code></td>
<td>
<p>The extent of manipulation. Can range from &quot;none&quot; (least
invasive) to &quot;tokens&quot; (most invasive). See 'Details'. This argument is a
string or a vector of class <code>AsIs</code>.</p>
</td></tr>
<tr><td><code id="tidyverse_style_+3A_strict">strict</code></td>
<td>
<p>A logical value indicating whether a set of strict
or not so strict transformer functions should be returned. Compare the
functions returned with or without <code>strict = TRUE</code>. For example,
<code>strict = TRUE</code> means force <em>one</em> space e.g. after &quot;,&quot; and <em>one</em> line break
e.g. after a closing curly brace. <code>strict = FALSE</code> means to set spaces and
line breaks to one if there is none and leave the code untouched otherwise.
See 'Examples'.</p>
</td></tr>
<tr><td><code id="tidyverse_style_+3A_indent_by">indent_by</code></td>
<td>
<p>How many spaces of indention should be inserted after
operators such as '('.</p>
</td></tr>
<tr><td><code id="tidyverse_style_+3A_start_comments_with_one_space">start_comments_with_one_space</code></td>
<td>
<p>Whether or not comments should start
with only one space (see <code><a href="#topic+start_comments_with_space">start_comments_with_space()</a></code>).</p>
</td></tr>
<tr><td><code id="tidyverse_style_+3A_reindention">reindention</code></td>
<td>
<p>A list of parameters for regex re-indention, most
conveniently constructed using <code><a href="#topic+specify_reindention">specify_reindention()</a></code>.</p>
</td></tr>
<tr><td><code id="tidyverse_style_+3A_math_token_spacing">math_token_spacing</code></td>
<td>
<p>A list of parameters that define spacing around
math token, conveniently constructed using <code><a href="#topic+specify_math_token_spacing">specify_math_token_spacing()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following levels for <code>scope</code> are available:
</p>

<ul>
<li><p> &quot;none&quot;: Performs no transformation at all.
</p>
</li>
<li><p> &quot;spaces&quot;: Manipulates spacing between token on the same line.
</p>
</li>
<li><p> &quot;indention&quot;: Manipulates the indention, i.e. number of spaces at the
beginning of each line.
</p>
</li>
<li><p> &quot;line_breaks&quot;: Manipulates line breaks between tokens.
</p>
</li>
<li><p> &quot;tokens&quot;: manipulates tokens.
</p>
</li></ul>

<p><code>scope</code> can be specified in two ways:
</p>

<ul>
<li><p> As a string: In this case all less invasive scope levels are implied, e.g.
&quot;line_breaks&quot; includes &quot;indention&quot;, &quot;spaces&quot;. This is brief and what most
users need.
</p>
</li>
<li><p> As vector of class <code>AsIs</code>: Each level has to be listed explicitly by
wrapping one ore more levels of the scope in <code><a href="base.html#topic+I">I()</a></code>. This offers more
granular control at the expense of more verbosity.
</p>
</li></ul>

<p>See 'Examples' for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>style_text("call( 1)", style = tidyverse_style, scope = "spaces")
style_text("call( 1)", transformers = tidyverse_style(strict = TRUE))
style_text(c("ab &lt;- 3", "a  &lt;-3"), strict = FALSE) # keeps alignment of "&lt;-"
style_text(c("ab &lt;- 3", "a  &lt;-3"), strict = TRUE) # drops alignment of "&lt;-"

# styling line breaks only without spaces
style_text(c("ab &lt;- 3", "a =3"), strict = TRUE, scope = I(c("line_breaks", "tokens")))
</code></pre>

<hr>
<h2 id='token_is_on_aligned_line'>Check if tokens are aligned</h2><span id='topic+token_is_on_aligned_line'></span>

<h3>Description</h3>

<p>If all tokens are aligned, <code>TRUE</code> is returned, otherwise <code>FALSE</code>. The
function only checks for alignment of function calls. This can be
recycled conveniently later if needed as a vector with length &gt; 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>token_is_on_aligned_line(pd_flat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="token_is_on_aligned_line_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple lines are called aligned if the following conditions hold for all
but the first line of the expression:
</p>

<ul>
<li><p> lag spaces of column 1 must agree.
</p>
</li>
<li><p> spacing around comma (0 before, &gt; 1 after) and spacing around <code>=</code> (at least
one around).
</p>
</li>
<li><p> all positions of commas of col &gt; 2 must agree (needs recursive creation of
<code>text</code>).
</p>
</li></ul>

<p>Because of the last requirement, this function is very expensive to run. For
this reason, the following approach is taken:
</p>

<ul>
<li><p> Only invoke the function when certain that alignment is possible.
</p>
</li>
<li><p> Check the cheap conditions first.
</p>
</li>
<li><p> For the recursive creation of text, greedily check column by column to make
sure we can stop as soon as we found that columns are not aligned.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("magrittr")
withr::with_options(
  list(styler.cache_name = NULL), # temporarily deactivate cache
  {
    transformers &lt;- tidyverse_style()
    pd_nested &lt;- compute_parse_data_nested(c(
      "call(",
      "  ab = 1L,",
      "  a  = 2",
      ")"
    )) %&gt;%
      styler:::post_visit(transformers$initialize)
    nest &lt;- pd_nested$child[[1L]]
    styler:::token_is_on_aligned_line(nest)
  }
)
</code></pre>

<hr>
<h2 id='tokenize'>Obtain token table from text</h2><span id='topic+tokenize'></span>

<h3>Description</h3>

<p><code><a href="utils.html#topic+getParseData">utils::getParseData()</a></code> is used to obtain a flat parse table from <code>text</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tokenize(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tokenize_+3A_text">text</code></td>
<td>
<p>The text to parse.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Apart from the columns provided by <code>utils::getParseData()</code>, the following
columns are added:
</p>

<ul>
<li><p> A column &quot;short&quot; with the first five characters of &quot;text&quot;.
</p>
</li>
<li><p> A column &quot;pos_id&quot; for (positional id) which can be used for sorting
(because &quot;id&quot; cannot be used in general). Note that the nth value of this
column corresponds to n as long as no tokens are inserted.
</p>
</li>
<li><p> A column &quot;child&quot; that contains <em>nest</em>s.
</p>
</li></ul>



<h3>Value</h3>

<p>A flat parse table
</p>

<hr>
<h2 id='transform_and_check'>Transform a file an check the result</h2><span id='topic+transform_and_check'></span>

<h3>Description</h3>

<p>Transform an file and check whether it is identical to a reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_and_check(
  in_item,
  out_item,
  in_name = in_item,
  out_name = out_item,
  transformer,
  dry,
  write_tree = NA,
  out_tree = "_tree",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_and_check_+3A_in_item">in_item</code></td>
<td>
<p>An path to an file to transform.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_out_item">out_item</code></td>
<td>
<p>The path to a file that contains the expected result.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_in_name">in_name</code></td>
<td>
<p>The label of the in_item, defaults to <code>in_item</code>.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_out_name">out_name</code></td>
<td>
<p>The label of the out_item, defaults to <code>out_item</code>.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_transformer">transformer</code></td>
<td>
<p>A function to apply to the content of <code>in_item</code>.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_write_tree">write_tree</code></td>
<td>
<p>Whether or not the tree structure of the test should be
computed and written to a file. Note that this needs R &gt;= 3.2
(see <code><a href="#topic+set_arg_write_tree">set_arg_write_tree()</a></code>). If the argument is set to <code>NA</code>, the function
determines whether R &gt;= 3.2 is in use and if so, trees will be written.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_out_tree">out_tree</code></td>
<td>
<p>Name of tree file if written out.</p>
</td></tr>
<tr><td><code id="transform_and_check_+3A_...">...</code></td>
<td>
<p>Parameters passed to transformer function.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_code'>Transform code from R, Rmd or Rnw files</h2><span id='topic+transform_code'></span>

<h3>Description</h3>

<p>A wrapper which initiates the styling of
either R, Rmd or Rnw files by passing the relevant transformer function for
each case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_code(path, fun, ..., dry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_code_+3A_path">path</code></td>
<td>
<p>A vector with file paths to transform.</p>
</td></tr>
<tr><td><code id="transform_code_+3A_fun">fun</code></td>
<td>
<p>A function that returns a character vector.</p>
</td></tr>
<tr><td><code id="transform_code_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+transform_utf8">transform_utf8()</a></code>.</p>
</td></tr>
<tr><td><code id="transform_code_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_file'>Transform a file and output a customized message</h2><span id='topic+transform_file'></span>

<h3>Description</h3>

<p>Transforms file contents and outputs customized messages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_file(
  path,
  fun,
  max_char_path,
  message_before = "",
  message_after = " [DONE]",
  message_after_if_changed = " *",
  ...,
  dry
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_file_+3A_path">path</code></td>
<td>
<p>A vector with file paths to transform.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_fun">fun</code></td>
<td>
<p>A function that returns a character vector.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_max_char_path">max_char_path</code></td>
<td>
<p>The number of characters of the longest path. Determines
the indention level of <code>message_after</code>.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_message_before">message_before</code></td>
<td>
<p>The message to print before the path.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_message_after">message_after</code></td>
<td>
<p>The message to print after the path.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_message_after_if_changed">message_after_if_changed</code></td>
<td>
<p>The message to print after <code>message_after</code> if
any file was transformed.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+transform_utf8">transform_utf8()</a></code>.</p>
</td></tr>
<tr><td><code id="transform_file_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_files'>Transform files with transformer functions</h2><span id='topic+transform_files'></span>

<h3>Description</h3>

<p><code>transform_files</code> applies transformations to file contents and writes back
the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_files(
  files,
  transformers,
  include_roxygen_examples,
  base_indention,
  dry
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_files_+3A_files">files</code></td>
<td>
<p>A character vector with paths to the file that should be
transformed.</p>
</td></tr>
<tr><td><code id="transform_files_+3A_transformers">transformers</code></td>
<td>
<p>A list of transformer functions that operate on flat
parse tables.</p>
</td></tr>
<tr><td><code id="transform_files_+3A_include_roxygen_examples">include_roxygen_examples</code></td>
<td>
<p>Whether or not to style code in roxygen
examples.</p>
</td></tr>
<tr><td><code id="transform_files_+3A_base_indention">base_indention</code></td>
<td>
<p>Integer scalar indicating by how many spaces the whole
output text should be indented. Note that this is not the same as splitting
by line and add a <code>base_indention</code> spaces before the code in the case
multi-line strings are present. See 'Examples'.</p>
</td></tr>
<tr><td><code id="transform_files_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns a data frame that indicates for each file considered for
styling whether or not it was actually changed (or would be changed when
<code>dry</code> is not &quot;off&quot;).
</p>

<hr>
<h2 id='transform_mixed'>Transform mixed contents</h2><span id='topic+transform_mixed'></span>

<h3>Description</h3>

<p>Applies the supplied transformer function to code chunks identified within
an Rmd or Rnw file and recombines the resulting (styled) code chunks with the
text chunks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_mixed(lines, transformer_fun, filetype)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_mixed_+3A_lines">lines</code></td>
<td>
<p>A character vector of lines from an Rmd or Rnw file.</p>
</td></tr>
<tr><td><code id="transform_mixed_+3A_transformer_fun">transformer_fun</code></td>
<td>
<p>A styler transformer function.</p>
</td></tr>
<tr><td><code id="transform_mixed_+3A_filetype">filetype</code></td>
<td>
<p>A string indicating the filetype - either 'Rmd' or 'Rnw'.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_mixed_non_empty'>Ensure for <code>.Rmd</code> and friends that a code chunk without code is formatted as
a code chunk without any lines.</h2><span id='topic+transform_mixed_non_empty'></span>

<h3>Description</h3>

<p>Ensure for <code>.Rmd</code> and friends that a code chunk without code is formatted as
a code chunk without any lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_mixed_non_empty(r_chunk, transformer_fun)
</code></pre>

<hr>
<h2 id='transform_utf8'>Apply a function to the contents of a file</h2><span id='topic+transform_utf8'></span>

<h3>Description</h3>

<p>Transforms a file with a function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_utf8(path, fun, dry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_utf8_+3A_path">path</code></td>
<td>
<p>A vector with file paths to transform.</p>
</td></tr>
<tr><td><code id="transform_utf8_+3A_fun">fun</code></td>
<td>
<p>A function that returns a character vector.</p>
</td></tr>
<tr><td><code id="transform_utf8_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='transform_utf8_one'>Potentially transform a file</h2><span id='topic+transform_utf8_one'></span>

<h3>Description</h3>

<p>Potentially transform a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_utf8_one(path, fun, dry)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_utf8_one_+3A_path">path</code></td>
<td>
<p>A vector with file paths to transform.</p>
</td></tr>
<tr><td><code id="transform_utf8_one_+3A_fun">fun</code></td>
<td>
<p>A function that returns a character vector.</p>
</td></tr>
<tr><td><code id="transform_utf8_one_+3A_dry">dry</code></td>
<td>
<p>To indicate whether styler should run in <em>dry</em> mode, i.e. refrain
from writing back to files .<code>"on"</code> and <code>"fail"</code> both don't write back, the
latter returns an error if the input code is not identical to the result
of styling. &quot;off&quot;, the default, writes back if the input and output of
styling are not identical.</p>
</td></tr>
</table>

<hr>
<h2 id='transformers_drop'>Remove transformers that are not needed</h2><span id='topic+transformers_drop'></span>

<h3>Description</h3>

<p>The goal is to speed up styling by removing all rules that are only
applicable in contexts that don't occur often, e.g. for most code, we don't
expect &quot;;&quot; to be in it, so we don't need to apply <code>resolve_semicolon()</code> on
every <em>nest</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transformers_drop(text, transformers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transformers_drop_+3A_text">text</code></td>
<td>
<p>Text to parse. Can also be the column <code>text</code> of the output of
<code><a href="#topic+compute_parse_data_nested">compute_parse_data_nested()</a></code>, where each element is a token (instead of a
line).</p>
</td></tr>
<tr><td><code id="transformers_drop_+3A_transformers">transformers</code></td>
<td>
<p>the transformers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>specify_transformers_drop
</p>

<hr>
<h2 id='try_transform_as_r_file'>Style a file as if it was an .R file</h2><span id='topic+try_transform_as_r_file'></span>

<h3>Description</h3>

<p>If not successful, the file is most
likely not a .R file, so saving the file and try styling again will work if
the file is an .Rmd file. Otherwise, we can throw an error that the file must
be a .R or .Rmd file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>try_transform_as_r_file(context, transformer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="try_transform_as_r_file_+3A_context">context</code></td>
<td>
<p>The context from <code>styler:::get_rstudio_context()</code>.</p>
</td></tr>
<tr><td><code id="try_transform_as_r_file_+3A_transformer">transformer</code></td>
<td>
<p>A transformer function most conveniently constructed with
<code><a href="#topic+make_transformer">make_transformer()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='unindent_child'>Unindent a child</h2><span id='topic+unindent_child'></span>

<h3>Description</h3>

<p>Unindent a child
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unindent_child(pd, token = c("')'", "'}'"), unindent_by = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unindent_child_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="unindent_child_+3A_token">token</code></td>
<td>
<p>The token the unindention should be based on.</p>
</td></tr>
<tr><td><code id="unindent_child_+3A_unindent_by">unindent_by</code></td>
<td>
<p>By how many spaces one level of indention is reversed.</p>
</td></tr>
</table>

<hr>
<h2 id='unindent_fun_dec'>Revert the indention of function declaration header</h2><span id='topic+unindent_fun_dec'></span>

<h3>Description</h3>

<p>Necessary for consistent indention of the function declaration header.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unindent_fun_dec(pd, indent_by = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unindent_fun_dec_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="unindent_fun_dec_+3A_indent_by">indent_by</code></td>
<td>
<p>How many spaces of indention should be inserted after
operators such as '('.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>set_unindention_child update_indention_ref_fun_dec
</p>

<hr>
<h2 id='update_indention'>Update indention information of parse data</h2><span id='topic+update_indention'></span><span id='topic+indent_without_paren_for_while_fun'></span><span id='topic+indent_without_paren_if_else'></span><span id='topic+indent_braces'></span><span id='topic+indent_op'></span><span id='topic+indent_eq_sub'></span><span id='topic+indent_without_paren'></span>

<h3>Description</h3>

<p>Update indention information of parse data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indent_without_paren_for_while_fun(pd, indent_by)

indent_without_paren_if_else(pd, indent_by)

indent_braces(pd, indent_by)

indent_op(
  pd,
  indent_by,
  token = c(math_token, logical_token, special_token, "PIPE", "LEFT_ASSIGN", "EQ_ASSIGN",
    "'$'", "'~'")
)

indent_eq_sub(pd, indent_by, token = c("EQ_SUB", "EQ_FORMALS"))

indent_without_paren(pd, indent_by = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_indention_+3A_pd">pd</code></td>
<td>
<p>A nested or flat parse table that is already enhanced with
line break and space information via <code><a href="#topic+default_style_guide_attributes">default_style_guide_attributes()</a></code>.</p>
</td></tr>
<tr><td><code id="update_indention_+3A_indent_by">indent_by</code></td>
<td>
<p>How many spaces should be added after the token of interest.</p>
</td></tr>
<tr><td><code id="update_indention_+3A_token">token</code></td>
<td>
<p>The token the indention should be based on.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>indent_without_paren_for_while_fun()</code>: Is used to indent for and statements and
function definitions without parenthesis.
</p>
</li>
<li> <p><code>indent_without_paren_if_else()</code>: Is used to indent if and if-else statements.
</p>
</li>
<li> <p><code>indent_braces()</code>: Inserts indention based on round, square and
curly brackets.
</p>
</li>
<li> <p><code>indent_op()</code>: Indents <em>all</em> tokens after <code>token</code> - including
the last token.
</p>
</li>
<li> <p><code>indent_eq_sub()</code>: Updates indention for token EQ_SUB. Only differs
from <code><a href="#topic+indent_op">indent_op()</a></code> in the sense that not all subsequent tokens in the parse
table are necessarily indented, as <code>EQ_SUB</code> and <code>EQ_FORMALS</code> can occur
multiple times in a parse table.
occurs is not indented (see<code><a href="#topic+compute_indent_indices">compute_indent_indices()</a></code>)
</p>
</li>
<li> <p><code>indent_without_paren()</code>: Is used to indent for / while / if / if-else
statements that do not have curly parenthesis.
</p>
</li></ul>

<hr>
<h2 id='update_indention_ref'>Update the indention reference</h2><span id='topic+update_indention_ref'></span><span id='topic+update_indention_ref_fun_dec'></span>

<h3>Description</h3>

<p>Update the indention reference
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_indention_ref_fun_dec(pd_nested)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_indention_ref_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>update_indention_ref_fun_dec()</code>: Updates the reference pos_id for all
tokens in <code>pd_nested</code> if <code>pd_nested</code> contains a function declaration.
Tokens inside a function declaration are are re-indented,
that is, they are indented up to the level at which the token FUNCTION
ends in terms of col2.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
a &lt;- function(x,
              y) {
  x + y
}

## End(Not run)

</code></pre>

<hr>
<h2 id='update_newlines'>Update the newlines attribute</h2><span id='topic+update_newlines'></span>

<h3>Description</h3>

<p>As we work only with the <code>lag_newlines</code> attribute for setting the line
breaks (<code>R/rules-line_breaks.R</code>), but we need <code>newlines</code> to determine
whether or not to set <code>spaces</code> (<code>R/rules-spaces.R</code>), we have to update the
attribute. We cannot simply use <code>dplyr::lead(pd$lag_newlines)</code> since we would
lose information for the last token. <code>spaces</code> is left as is in
R/rules-spacing.R for tokens at the end of a line since this allows styling
without touching indention.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_newlines(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_newlines_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A parse table with synchronized <code>lag_newlines</code> and <code>newlines</code>
columns.
</p>


<h3>See Also</h3>

<p>choose_indention
</p>

<hr>
<h2 id='validate_new_pos_ids'>Validate sequence of new position ids</h2><span id='topic+validate_new_pos_ids'></span>

<h3>Description</h3>

<p>Ids created with <code>after = TRUE</code> can have <code>pos_id</code> values between x.0 and
x.5 and ids created with <code>after = FALSE</code> can have <code>pos_id</code> values between
1+ x.0 and 1 + x.5 where x is the <code>pos_id</code> integer which was used as a
reference to create the new <code>pos_ids</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_new_pos_ids(new_ids, after)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_new_pos_ids_+3A_new_ids">new_ids</code></td>
<td>
<p>A vector with new ids</p>
</td></tr>
<tr><td><code id="validate_new_pos_ids_+3A_after">after</code></td>
<td>
<p>Whether the ids are created with <code>after = TRUE</code> (and hence
should be in the range x.0-x.45) or not.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other token creators: 
<code><a href="#topic+create_pos_ids">create_pos_ids</a>()</code>,
<code><a href="#topic+create_tokens">create_tokens</a>()</code>
</p>

<hr>
<h2 id='verify_roundtrip'>Verify the styling</h2><span id='topic+verify_roundtrip'></span>

<h3>Description</h3>

<p>If scope was set to &quot;line_breaks&quot; or lower (compare <code><a href="#topic+tidyverse_style">tidyverse_style()</a></code>),
we can compare the expression before and after styling and return an error if
it is not the same.
If that's not possible, a weaker guarantee that we want to give is that the
resulting code is parsable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verify_roundtrip(old_text, new_text, parsable_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="verify_roundtrip_+3A_old_text">old_text</code></td>
<td>
<p>The initial expression in its character representation.</p>
</td></tr>
<tr><td><code id="verify_roundtrip_+3A_new_text">new_text</code></td>
<td>
<p>The styled expression in its character representation.</p>
</td></tr>
<tr><td><code id="verify_roundtrip_+3A_parsable_only">parsable_only</code></td>
<td>
<p>If we should only check for the code to be parsable.</p>
</td></tr>
</table>


<h3>Limitation</h3>

<p>Note that this method ignores roxygen code examples and
comments and no verification can be conducted if tokens are in the styling
scope.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>styler:::verify_roundtrip("a+1", "a + 1")
styler:::verify_roundtrip("a+1", "a + 1 # comments are dropped")
try(styler:::verify_roundtrip("a+1", "b - 3"))
</code></pre>

<hr>
<h2 id='visit'>Visit'em all</h2><span id='topic+visit'></span><span id='topic+pre_visit'></span><span id='topic+pre_visit_one'></span><span id='topic+post_visit'></span><span id='topic+post_visit_one'></span>

<h3>Description</h3>

<p>Apply a list of functions to each level in a nested parse table.
<code>pre_visit()</code> applies <code>funs</code> before it proceeds to the children,
(that is, starts from the outermost level of nesting progressing
to the innermost level), <code>post_visit()</code> proceeds to its children
before applying the functions (meaning it first applies the functions
to the innermost level of nesting first and then going outwards).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pre_visit(pd_nested, funs)

pre_visit_one(pd_nested, fun)

post_visit(pd_nested, funs)

post_visit_one(pd_nested, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visit_+3A_pd_nested">pd_nested</code></td>
<td>
<p>A nested parse table.</p>
</td></tr>
<tr><td><code id="visit_+3A_funs">funs</code></td>
<td>
<p>A list of transformer functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other visitors: 
<code><a href="#topic+visit_one">visit_one</a>()</code>
</p>

<hr>
<h2 id='visit_one'>Transform a flat parse table with a list of transformers</h2><span id='topic+visit_one'></span>

<h3>Description</h3>

<p>Uses <code><a href="base.html#topic+Reduce">Reduce()</a></code> to apply each function of <code>funs</code> sequentially to
<code>pd_flat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visit_one(pd_flat, funs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visit_one_+3A_pd_flat">pd_flat</code></td>
<td>
<p>A flat parse table.</p>
</td></tr>
<tr><td><code id="visit_one_+3A_funs">funs</code></td>
<td>
<p>A list of transformer functions.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other visitors: 
<code><a href="#topic+visit">visit</a></code>
</p>

<hr>
<h2 id='wrap_else_multiline_curly'>Add curly braces to else</h2><span id='topic+wrap_else_multiline_curly'></span>

<h3>Description</h3>

<p>Wrap the else part of a conditional expression into curly braces if not
already wrapped into a such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_else_multiline_curly(pd, indent_by = 2L, space_after = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_else_multiline_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="wrap_else_multiline_curly_+3A_indent_by">indent_by</code></td>
<td>
<p>The amount of spaces used to indent an expression in curly
braces. Used for unindention.</p>
</td></tr>
<tr><td><code id="wrap_else_multiline_curly_+3A_space_after">space_after</code></td>
<td>
<p>How many spaces should be inserted after the closing brace.</p>
</td></tr>
</table>

<hr>
<h2 id='wrap_expr_in_curly'>Wrap an expression in curly braces</h2><span id='topic+wrap_expr_in_curly'></span>

<h3>Description</h3>

<p>Adds curly braces to an expression (represented as a parse table) if there
are none.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_expr_in_curly(pd, stretch_out = c(FALSE, FALSE), space_after = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_expr_in_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="wrap_expr_in_curly_+3A_stretch_out">stretch_out</code></td>
<td>
<p>Whether or not to create a line break after the opening
curly brace and before the closing curly brace.</p>
</td></tr>
<tr><td><code id="wrap_expr_in_curly_+3A_space_after">space_after</code></td>
<td>
<p>How many spaces should be inserted after the closing brace.</p>
</td></tr>
</table>

<hr>
<h2 id='wrap_expr_in_expr'>Wrap an expression into an expression</h2><span id='topic+wrap_expr_in_expr'></span>

<h3>Description</h3>

<p>Takes a parse table and wraps it in a new parse table that contains the
expression as a child.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_expr_in_expr(pd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_expr_in_expr_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
</table>

<hr>
<h2 id='wrap_if_else_while_for_fun_multi_line_in_curly'>Wrap if-else, while and for statements in curly braces</h2><span id='topic+wrap_if_else_while_for_fun_multi_line_in_curly'></span>

<h3>Description</h3>

<p>Wrap statements in curly braces if it is not already wrapped in a such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_if_else_while_for_fun_multi_line_in_curly(pd, indent_by = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_if_else_while_for_fun_multi_line_in_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="wrap_if_else_while_for_fun_multi_line_in_curly_+3A_indent_by">indent_by</code></td>
<td>
<p>The amount of spaces used to indent an expression in curly
braces. Used for unindention.</p>
</td></tr>
</table>

<hr>
<h2 id='wrap_multiline_curly'>Wrap a multi-line statement in curly braces</h2><span id='topic+wrap_multiline_curly'></span>

<h3>Description</h3>

<p>Wrap a multi-line statement in curly braces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_multiline_curly(pd, indent_by, key_token, space_after = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_multiline_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="wrap_multiline_curly_+3A_indent_by">indent_by</code></td>
<td>
<p>The amount of spaces used to indent an expression in curly
braces. Used for unindention.</p>
</td></tr>
<tr><td><code id="wrap_multiline_curly_+3A_key_token">key_token</code></td>
<td>
<p>The token that comes right before the token that contains
the expression to be wrapped (ignoring comments). For if and while loops,
this is the closing &quot;')'&quot;, for a for-loop it's &quot;forcond&quot;.</p>
</td></tr>
<tr><td><code id="wrap_multiline_curly_+3A_space_after">space_after</code></td>
<td>
<p>How many spaces should be inserted after the closing brace.</p>
</td></tr>
</table>

<hr>
<h2 id='wrap_subexpr_in_curly'>Wrap a sub-expression in curly braces</h2><span id='topic+wrap_subexpr_in_curly'></span>

<h3>Description</h3>

<p>Wraps some rows of a parse table into a sub-expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_subexpr_in_curly(pd, ind_to_be_wrapped, indent_by, space_after)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_subexpr_in_curly_+3A_pd">pd</code></td>
<td>
<p>A parse table.</p>
</td></tr>
<tr><td><code id="wrap_subexpr_in_curly_+3A_ind_to_be_wrapped">ind_to_be_wrapped</code></td>
<td>
<p>The indices of the rows that should be wrapped
into a new expression.</p>
</td></tr>
<tr><td><code id="wrap_subexpr_in_curly_+3A_space_after">space_after</code></td>
<td>
<p>How many spaces should be inserted after the closing brace.</p>
</td></tr>
</table>

<hr>
<h2 id='write_utf8'>Drop-in replacement for <code>xfun::write_utf8()</code></h2><span id='topic+write_utf8'></span>

<h3>Description</h3>

<p>Drop-in replacement for <code>xfun::write_utf8()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_utf8(text, con, ...)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
