<!DOCTYPE html><html><head><title>Help for package wsyn</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wsyn}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addranks'><p>Adds rank information to a <code>coh</code> or <code>wlmtest</code> object</p></a></li>
<li><a href='#addwmfs'><p>Adds wavelet mean field information to a <code>clust</code> object</p></a></li>
<li><a href='#addwpmfs'><p>Adds wavelet phasor mean field information to a <code>clust</code> object</p></a></li>
<li><a href='#bandtest'><p>Aggregate significance across a timescale band</p></a></li>
<li><a href='#bctrans'><p>The one-parameter family of Box-Cox transformations</p></a></li>
<li><a href='#cleandat'><p>Clean (spatio)temporal data matrices to make them ready for analyses using the <code>wsyn</code> package</p></a></li>
<li><a href='#cluseigen'><p>Community structure detection in networks</p></a></li>
<li><a href='#clust'><p>Detection and description of clusters of synchronous locations</p></a></li>
<li><a href='#clust_methods'><p>Basic methods for the <code>clust</code> class</p></a></li>
<li><a href='#coh'><p>Coherence</p></a></li>
<li><a href='#coh_methods'><p>Basic methods for the <code>coh</code> class</p></a></li>
<li><a href='#errcheck_stdat'><p>Error check for appropriate spatio-temporal data</p></a></li>
<li><a href='#errcheck_times'><p>Error check <code>times</code></p></a></li>
<li><a href='#errcheck_tsdat'><p>Error check for appropriate temporal data</p></a></li>
<li><a href='#errcheck_tts'><p>Error check whether inputs are suitable for a tts object</p></a></li>
<li><a href='#errcheck_wavparam'><p>Error check wavelet transform parameters</p></a></li>
<li><a href='#fastcohtest'><p>Fast algorithm for significance testing coherence using Fourier surrogates</p></a></li>
<li><a href='#fftsurrog'><p>Surrogate time series using Fourier surrogates</p></a></li>
<li><a href='#is.connected'><p>Tests if a graph is connected</p></a></li>
<li><a href='#makeunweighted'><p>For converting certain synchrony matrices to unweighted versions</p></a></li>
<li><a href='#mnphase'><p>Mean phase of coherence</p></a></li>
<li><a href='#modularity'><p>Modularity of a community structure of a graph</p></a></li>
<li><a href='#normforcoh'><p>Normalization for the <code>coh</code> function</p></a></li>
<li><a href='#plotmag'><p>For plotting the magnitude of values in <code>tts</code>, <code>coh</code> and <code>wlmtest</code> objects</p></a></li>
<li><a href='#plotmap'><p>Map clusters from a <code>clust</code> object</p></a></li>
<li><a href='#plotphase'><p>For plotting the phases of values in <code>tts</code> and <code>coh</code> objects</p></a></li>
<li><a href='#plotrank'><p>Plots <code>ranks</code> slot for <code>coh</code> and <code>wlmtest</code> objects</p></a></li>
<li><a href='#power'><p>Power of a <code>tts</code> object</p></a></li>
<li><a href='#predsync'><p>Predicted synchrony of a wavelet linear model</p></a></li>
<li><a href='#print.summary_wsyn'><p>Print method for <code>summary_wsyn</code> class</p></a></li>
<li><a href='#set_adj'><p>Set and get methods for classes in the <code>wsyn</code> package</p></a></li>
<li><a href='#setmints'><p>Shifts a vector according to the argument mints</p></a></li>
<li><a href='#surrog'><p>Creates surrogate time series, either Fourier surrogates or amplitude adjusted</p>
Fourier surrogates</a></li>
<li><a href='#syncexpl'><p>Amount of synchrony explained, and related quantities</p></a></li>
<li><a href='#synmat'><p>Synchrony matrices</p></a></li>
<li><a href='#tts'><p>Creator function for the <code>tts</code> class</p></a></li>
<li><a href='#tts_methods'><p>Basic methods for the <code>tts</code> class</p></a></li>
<li><a href='#warray'><p>Creates an array of wavelet transforms from input timeseries</p></a></li>
<li><a href='#wavmatwork'><p>Facilitates the computations in synmat for coherence and ReXWT methods</p></a></li>
<li><a href='#wlm'><p>Wavelet linear models</p></a></li>
<li><a href='#wlm_methods'><p>Basic methods for the <code>wlm</code> class</p></a></li>
<li><a href='#wlmfit'><p>Fits a wavelet linear model</p></a></li>
<li><a href='#wlmtest'><p>Statistical comparison of wavelet linear models</p></a></li>
<li><a href='#wlmtest_methods'><p>Basic methods for the <code>wlmtest</code> class</p></a></li>
<li><a href='#wmf'><p>Computes the wavelet mean field from a matrix of spatiotemporal data. Also the</p>
creator function for the <code>wmf</code> class.</a></li>
<li><a href='#wmf_methods'><p>Basic methods for the <code>wmf</code> class</p></a></li>
<li><a href='#wpmf'><p>Wavelet phasor mean field</p></a></li>
<li><a href='#wpmf_methods'><p>Basic methods for the <code>wpmf</code> class</p></a></li>
<li><a href='#wt'><p>Computes the wavelet transform of a timeseries. Also the creator function for the</p>
<code>wt</code> class.</a></li>
<li><a href='#wt_methods'><p>Basic methods for the <code>wt</code> class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet Approaches to Studies of Synchrony in Ecology and Other
Fields</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for a wavelet-based approach to analyzing spatial synchrony, principally in ecological data. Some tools will be useful for studying community synchrony. See, for instance, Sheppard et al (2016) &lt;<a href="https://doi.org/10.1038%2FNCLIMATE2991">doi:10.1038/NCLIMATE2991</a>&gt;, Sheppard et al (2017) &lt;<a href="https://doi.org/10.1051%2Fepjnbp%2F2017000">doi:10.1051/epjnbp/2017000</a>&gt;, Sheppard et al (2019) &lt;<a href="https://doi.org/10.1371%2Fjournal.pcbi.1006744">doi:10.1371/journal.pcbi.1006744</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>fields (&ge; 9.6), graphics (&ge; 3.4.4), grDevices (&ge; 3.4.4),
MASS (&ge; 7.3-47), stats (&ge; 3.4.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, mvtnorm, rmarkdown, testthat, vdiffr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown, mvtnorm</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-06-18 19:26:41 UTC; dreuman</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel C. Reuman [aut, cre],
  Thomas L. Anderson [aut],
  Jonathan A. Walter [aut],
  Lei Zhao [aut],
  Lawrence W. Sheppard [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel C. Reuman &lt;reuman@ku.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-06-18 21:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addranks'>Adds rank information to a <code>coh</code> or <code>wlmtest</code> object</h2><span id='topic+addranks'></span>

<h3>Description</h3>

<p>When a <code>coh</code> or <code>wlmtets</code> object is created, the <code>ranks</code> slot is NA. 
This function fills it in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addranks(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addranks_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>coh</code> or <code>wlmtest</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>addranks</code> returns another <code>coh</code> or <code>wlmtest</code> object with ranks 
slot now included. If  <code>obj$ranks</code> was not NA, the object is returned as is.
</p>


<h3>Note</h3>

<p>Internal function, no error checking performed
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+bandtest">bandtest</a></code>, <code>browseVignettes("wsyn")</code>
</p>

<hr>
<h2 id='addwmfs'>Adds wavelet mean field information to a <code>clust</code> object</h2><span id='topic+addwmfs'></span>

<h3>Description</h3>

<p>When a <code>clust</code> object is created, the <code>wmfs</code> slot is NA. This function fills it in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addwmfs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addwmfs_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>clust</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the values of <code>scale.min</code>, <code>scale.max.input</code>, 
<code>sigma</code> and <code>f0</code> stored in <code>obj$methodspecs</code>. It is possible to create 
a <code>clust</code> object with bad values for these slots. This function throws an error in that 
case. You can use a correlation-based method for calculating the synchrony matrix and 
still pass values of <code>scale.min</code>, <code>scale.max.input</code>, <code>sigma</code> and <code>f0</code> 
to <code>clust</code> (in fact, this happens by default) - they won't be used by <code>clust</code>, 
but they will be there for later use by <code>addwmfs</code> and <code>addwpmfs</code>.
</p>


<h3>Value</h3>

<p><code>addwmfs</code> returns another <code>clust</code> object with <code>wmfs</code> slot now included. 
If  <code>obj$wmfs</code> was not NA, the object is returned as is.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code><a href="#topic+addwpmfs">addwpmfs</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig&lt;-matrix(.8,5,5)
diag(sig)&lt;-1
lents&lt;-50
if (requireNamespace("mvtnorm",quietly=TRUE))
{
  dat1&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
  dat2&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
}else
{
  dat1&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
  dat2&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
}
dat&lt;-rbind(dat1,dat2)
times&lt;-1:lents
dat&lt;-cleandat(dat,times,clev=1)$cdat
coords&lt;-data.frame(Y=rep(0,10),X=1:10)
method&lt;-"coh.sig.fast"
clustobj&lt;-clust(dat,times,coords,method,nsurrogs = 100)
res&lt;-addwmfs(clustobj)

</code></pre>

<hr>
<h2 id='addwpmfs'>Adds wavelet phasor mean field information to a <code>clust</code> object</h2><span id='topic+addwpmfs'></span>

<h3>Description</h3>

<p>When a <code>clust</code> object is created, the <code>wpmfs</code> slot is NA. This function fills it in, 
or adds to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addwpmfs(
  obj,
  level = 1:length(obj$clusters),
  sigmethod = "quick",
  nrand = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addwpmfs_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>clust</code></p>
</td></tr>
<tr><td><code id="addwpmfs_+3A_level">level</code></td>
<td>
<p>The clustering level(s) to use. 1 corresponds to no clustering. The default is all 
levels of clustering.</p>
</td></tr>
<tr><td><code id="addwpmfs_+3A_sigmethod">sigmethod</code></td>
<td>
<p>Method for significance testing the <code>wpmf</code>, one of <code>quick</code>, <code>fft</code>, 
<code>aaft</code> (see details of the <code>wpmf</code> function)</p>
</td></tr>
<tr><td><code id="addwpmfs_+3A_nrand">nrand</code></td>
<td>
<p>The number of randomizations to be used for significance testing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the values of <code>scale.min</code>, <code>scale.max.input</code>, 
<code>sigma</code> and <code>f0</code> stored in <code>obj$methodspecs</code>. It is possible to create 
a clust object with bad values for these slots. This function throws an error in that 
case. You can use a correlation-based method for calculating the synchrony matrix and 
still pass values of <code>scale.min</code>, <code>scale.max.input</code>, <code>sigma</code> and <code>f0</code> 
to <code>clust</code> (in fact, this happens by default) - they won't be used by <code>clust</code>, 
but they will be there for later use by <code>addwmfs</code> and <code>addwpmfs</code>.
</p>


<h3>Value</h3>

<p><code>addwpmfs</code> returns another <code>clust</code> object with <code>wpmfs</code> slot now included,
or more filled in than it was previously. With values of <code>sigmethod</code> other than 
<code>"quick"</code>, this function can be slow, particularly with large <code>nrand</code>. So in that
case the user may want to set <code>level</code> equal only to one clustering level of interest.
Unlike <code>wmf</code>, old values in <code>obj$wpmfs</code> are overwritten.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code><a href="#topic+addwmfs">addwmfs</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig&lt;-matrix(.8,5,5)
diag(sig)&lt;-1
lents&lt;-50
if (requireNamespace("mvtnorm",quietly=TRUE))
{
  dat1&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
  dat2&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
}else
{
  dat1&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
  dat2&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
}
dat&lt;-rbind(dat1,dat2)
times&lt;-1:lents
dat&lt;-cleandat(dat,times,clev=1)$cdat
coords&lt;-data.frame(Y=rep(0,10),X=1:10)
method&lt;-"coh.sig.fast"
clustobj&lt;-clust(dat,times,coords,method,nsurrogs = 100)
res&lt;-addwpmfs(clustobj)

</code></pre>

<hr>
<h2 id='bandtest'>Aggregate significance across a timescale band</h2><span id='topic+bandtest'></span><span id='topic+bandtest.default'></span><span id='topic+bandtest.coh'></span><span id='topic+bandtest.wlmtest'></span>

<h3>Description</h3>

<p>Computes the aggregate significance of coherence (<code>coh</code>) or of a wavelet linear model test object
(<code>wlmtest</code>) across a timescale band, accounting for non-independence of timescales. Also gets the 
average phase across the band, in the case of coherence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandtest(object, ...)

## Default S3 method:
bandtest(object, ...)

## S3 method for class 'coh'
bandtest(object, band, ...)

## S3 method for class 'wlmtest'
bandtest(object, band, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bandtest_+3A_object">object</code></td>
<td>
<p>An object of class <code>coh</code> or <code>wlmtest</code>, must have a non-<code>NA</code> 
<code>signif</code> slot</p>
</td></tr>
<tr><td><code id="bandtest_+3A_...">...</code></td>
<td>
<p>Passed from the generic to specific methods. Not currently used.</p>
</td></tr>
<tr><td><code id="bandtest_+3A_band">band</code></td>
<td>
<p>A length-two numeric vector indicating a timescale band</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>bandtest</code> returns an object of the same class as its first input but with a
<code>bandp</code> slot added. Or if there was already a <code>bandp</code> slot, the output has a 
<code>bandp</code> slot with an additional row. For a <code>coh</code> object, the <code>bandp</code> slot 
is a data frame with four columns, the first two indicating the timescale band and the third 
an associated p-value for the test of coherence over that band. The fourth column is the 
average phase over the band. For a <code>wlmtest</code> object, the result is only the first three
of the above columns.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+wlm">wlm</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example for a coh object
times&lt;-(-3:100)
ts1&lt;-sin(2*pi*times/10)
ts2&lt;-5*sin(2*pi*times/3)
artsig_x&lt;-matrix(NA,11,length(times)) #the driver
for (counter in 1:11)
{
  artsig_x[counter,]=ts1+ts2+rnorm(length(times),mean=0,sd=1.5)
}
times&lt;-0:100
artsig_y&lt;-matrix(NA,11,length(times)) #the driven
for (counter1 in 1:11)
{
  for (counter2 in 1:101)
  {
    artsig_y[counter1,counter2]&lt;-mean(artsig_x[counter1,counter2:(counter2+2)])
  }
}
artsig_y&lt;-artsig_y+matrix(rnorm(length(times)*11,mean=0,sd=3),11,length(times))
artsig_x&lt;-artsig_x[,4:104]
artsig_x&lt;-cleandat(artsig_x,times,1)$cdat
artsig_y&lt;-cleandat(artsig_y,times,1)$cdat
cohobj&lt;-coh(dat1=artsig_x,dat2=artsig_y,times=times,norm="powall",sigmethod="fast",nrand=1000,
            f0=0.5,scale.max.input=28)
cohobj&lt;-bandtest(cohobj,c(2,4))
  
#Example for a wlmtest object - see vignette
  
</code></pre>

<hr>
<h2 id='bctrans'>The one-parameter family of Box-Cox transformations</h2><span id='topic+bctrans'></span>

<h3>Description</h3>

<p>The one-parameter family of Box-Cox transformations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bctrans(y, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bctrans_+3A_y">y</code></td>
<td>
<p>A numeric, positive values assumed</p>
</td></tr>
<tr><td><code id="bctrans_+3A_lambda">lambda</code></td>
<td>
<p>The Box-Cox parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Internal function. No error checking done. It is assumed the entries of y are positive.
</p>


<h3>Value</h3>

<p><code>bctrans</code> gives <code>((y^lambda)-1)/lambda</code> for <code>lambda</code> not 0 or <code>ln(y)</code> for <code>lambda</code> equal to 0.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Box, GEP and Cox, DR (1964) An analysis of transformations (with discussion). Journal of the Royal Statistical Society B, 26, 211–252.
</p>
<p>Venables, WN and Ripley, BD (2002) Modern Applied Statistics with S. Fourth edition. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cleandat">cleandat</a></code>, <code>browseVignettes("wsyn")</code>
</p>

<hr>
<h2 id='cleandat'>Clean (spatio)temporal data matrices to make them ready for analyses using the <code>wsyn</code> package</h2><span id='topic+cleandat'></span>

<h3>Description</h3>

<p>A data cleaning function for optimal Box-Cox transformation, detrending, standarizing variance, 
de-meaning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleandat(dat, times, clev, lambdas = seq(-10, 10, by = 0.01), mints = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleandat_+3A_dat">dat</code></td>
<td>
<p>A locations x time data matrix, or a time series vector (for 1 location)</p>
</td></tr>
<tr><td><code id="cleandat_+3A_times">times</code></td>
<td>
<p>The times of measurement, spacing 1</p>
</td></tr>
<tr><td><code id="cleandat_+3A_clev">clev</code></td>
<td>
<p>The level of cleaning to do, 1 through 5. See details.</p>
</td></tr>
<tr><td><code id="cleandat_+3A_lambdas">lambdas</code></td>
<td>
<p>A vector of lambdas to test for optimal Box-Cox transformation, if Box-Cox is 
performed. Ignored for <code>clev&lt;4</code>. Defaults to seq(-10,10, by=0.01). See details.</p>
</td></tr>
<tr><td><code id="cleandat_+3A_mints">mints</code></td>
<td>
<p>If <code>clev</code> is 4 or 5, then time series are shifted to have this minimum value 
before Box-Cox transformation. Default NA means use the smallest difference between consecutive, 
distinct sorted values. NaN means perform no shift.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NAs, Infs, etc. in <code>dat</code> trigger an error. If <code>clev==1</code>, time series are (individually) 
de-meaned. If <code>clev==2</code>, time series are (individually) linearly detrended and de-meaned. If <code>clev==3</code>, 
time series are (individually) linearly detrended and de-meaned, and variances are standardized to 1. If 
<code>clev==4</code>, an optimal Box-Cox normalization procedure is applied jointly to all time series (so the same
Box-Cox transformation is applied to all time series after they are individually shifted depending on the value
of <code>mints</code>). Transformed time series are then individually linearly detrended, de-meaned, and variances are
standardized to 1. If <code>clev==5</code>, an optimal Box-Cox normalization procedure is applied to each time series 
individually (again after individually shifting according to <code>mints</code>), and transformed time series are then 
individually linearly detrended, de-meaned, and variances are standardized to 1. Constant time series and perfect 
linear trends trigger an error for <code>clev&gt;=3</code>. If <code>clev&gt;=4</code> and the optimal <code>lambda</code> for one or 
more time series is a boundary case or if there is more than one optimal lambda, it triggers a warning. A wider 
range of <code>lambda</code> should be considered in the former case.
</p>


<h3>Value</h3>

<p><code>cleandat</code> returns a list containing the cleaned data, <code>clev</code>, and the optimal 
lambdas from the Box-Cox procedure (<code>NA</code> for <code>clev&lt;4</code>, see details).
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; 
Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>; Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>
</p>


<h3>References</h3>

<p>Box, GEP and Cox, DR (1964) An analysis of transformations (with discussion). Journal of the Royal Statistical Society B, 26, 211–252.
</p>
<p>Venables, WN and Ripley, BD (2002) Modern Applied Statistics with S. Fourth edition. Springer.
</p>
<p>Sheppard, LW, et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>, <code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+wlm">wlm</a></code>, 
<code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+clust">clust</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:100
dat&lt;-rnorm(100)
res1&lt;-cleandat(dat,times,1) #this removes the mean
res2&lt;-cleandat(dat,times,2) #detrends and removes the mean
res3&lt;-cleandat(dat,times,3) #variances also standardized
res4&lt;-cleandat(dat,times,4) #also joint Box-Cox applied
res5&lt;-cleandat(dat,times,5) #1-3, also indiv Box-Cox

</code></pre>

<hr>
<h2 id='cluseigen'>Community structure detection in networks</h2><span id='topic+cluseigen'></span>

<h3>Description</h3>

<p>Community structure detection in networks based on the leading eigenvector of the 
community matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluseigen(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cluseigen_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix. Should be symmetric with diagonal containing zeros.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between this function and the algorithm described
by Newman is that this function can be used on an adjacency matrix with 
negative elements, which is very common for correlation matrices and other 
measures of pairwise synchrony of time series.
</p>


<h3>Value</h3>

<p><code>cluseigen</code> returns a list with one element for each of the splits 
performed by the clustering algorithm. Each element is a vector with entries 
corresponding to rows and columns of adj and indicating the module membership
of the node, following the split. The last element of the list is the final 
clustering determined by the algorithm when its halting condition is satisfied.
The first element is always a vector of all 1s (corresponding to before any 
splits are performed).
</p>


<h3>Author(s)</h3>

<p>Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Gomez S., Jensen P. &amp; Arenas A. (2009). Analysis of community structure 
in networks of correlated data. Phys Rev E, 80, 016114. 
</p>
<p>Newman M.E.J. (2006). Finding community structure in networks using the eigenvectors of 
matrices. Phys Rev E, 74, 036104.
</p>
<p>Newman M.E.J. (2006) Modularity and community structure in networks. PNAS 103, 8577-8582.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code><a href="#topic+modularity">modularity</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj&lt;-matrix(0, 10, 10) # create a fake adjacency matrix
adj[lower.tri(adj)]&lt;-runif(10*9/2, -1, 1)
adj&lt;-adj+t(adj)
colnames(adj)&lt;-letters[1:10]
z&lt;-cluseigen(adj)

</code></pre>

<hr>
<h2 id='clust'>Detection and description of clusters of synchronous locations</h2><span id='topic+clust'></span>

<h3>Description</h3>

<p>Generator function for the <code>clust</code> S3 class, which supports tools for detecting clusters
(aka, modules, sub-networks, communities, etc.) of especially synchronous locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clust(
  dat,
  times,
  coords,
  method,
  tsrange = c(0, Inf),
  nsurrogs = 1000,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1,
  weighted = TRUE,
  sigthresh = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix of measurements</p>
</td></tr>
<tr><td><code id="clust_+3A_times">times</code></td>
<td>
<p>The times at which measurements were made, spacing 1</p>
</td></tr>
<tr><td><code id="clust_+3A_coords">coords</code></td>
<td>
<p>A data frame containing X,Y coordinates of locations in <code>data</code>, with column
names either <code>X</code> and <code>Y</code> or <code>lon</code> and <code>lat</code> or <code>longitude</code> and 
<code>latitude</code>. The data frame may contain other columns with additional metainformation 
about the sites.</p>
</td></tr>
<tr><td><code id="clust_+3A_method">method</code></td>
<td>
<p>Method for synchrony calculation. See details.</p>
</td></tr>
<tr><td><code id="clust_+3A_tsrange">tsrange</code></td>
<td>
<p>A vector containing the min and max of the focal timescale range. Defaults 
to all timescales that are valid given choices for scale.min, scale.max.input, f0, sigma.
Only used for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_nsurrogs">nsurrogs</code></td>
<td>
<p>Number of surrogates for significance test. Defaults to 1000. Only used
for surrogate-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2. Used 
only for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined. Only used 
for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be 
greater than 1. Only used for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope. Only used for 
wavelet-based methods.</p>
</td></tr>
<tr><td><code id="clust_+3A_weighted">weighted</code></td>
<td>
<p>If <code>TRUE</code>, create a weighted network. If <code>FALSE</code>, create a binary 
network using statistical significance. Binary networks are only allowed for networks based
on significance.</p>
</td></tr>
<tr><td><code id="clust_+3A_sigthresh">sigthresh</code></td>
<td>
<p>Significance threshold needed, if <code>weighted</code> is false, for a network
link to be realized. Typically 0.95, 0.99, or 0.999, etc. Only used if <code>weighted</code> is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following values are valid for <code>method</code>: 
<code>"pearson"</code>, <code>"pearson.sig.std"</code>, <code>"pearson.sig.fft"</code>, 
<code>"pearson.sig.aaft"</code>, 
<code>"spearman"</code>, <code>"spearman.sig.std"</code>, <code>"spearman.sig.fft"</code>, 
<code>"spearman.sig.aaft"</code>, 
<code>"kendall"</code>, <code>"kendall.sig.std"</code>, <code>"kendall.sig.fft"</code>, 
<code>"kendall.sig.aaft"</code>, 
<code>"ReXWT"</code>, <code>"ReXWT.sig.fft"</code>, <code>"ReXWT.sig.aaft"</code>, <code>"ReXWT.sig.fast"</code>, 
<code>"coh"</code>, <code>"coh.sig.fft"</code>, <code>"coh.sig.aaft"</code>, <code>"coh.sig.fast"</code>,
<code>"phasecoh"</code>, <code>"phasecoh.sig.fft"</code>, and <code>"phasecoh.sig.aaft"</code>.
The first portions of these identifiers correspond to the Pearson, Spearman, and Kendall 
correlations, the real part of the cross-wavelet transform, the wavelet coherence, and the 
wavelet phase coherence. The second portions of these identifiers, when present, indicates
that significance of the measure specified in the first portion of the identifies is to
be used for establishing the synchrony matrix. Otherwise the value itself is used. The
third part of the <code>method</code> identifier indicates what type of significance is used.
</p>
<p>Significance testing is performed using standard approaches (<code>method</code> flag containg
<code>std</code>; for correlation coefficients, 
although these are inappropriate for autocorrelated data), or surrogates generated using the 
Fourier (<code>method</code> flag containing <code>"fft"</code>) or amplitude adjusted Fourier 
surrogates (<code>"aaft"</code>). For 
<code>"coh"</code> and <code>"ReXWT"</code>, the fast testing algorithm of Sheppard et al. (2017) is also
implemented (<code>"fast"</code>). That method uses implicit Fourier surrogates. The choice of 
wavelet coherence (method flag containing <code>"coh"</code>) or the real part of 
the cross-wavelet 
transform (method flag containing <code>"ReXWT"</code>) depends mainly 
on treatment of out-of-phase 
relationships. The <code>"ReXWT"</code> is more akin to a correlation coefficient in that 
strong in-phase relationships approach 1 and strong antiphase relationships approach -1. 
Wavelet coherence allows any phase relationship and ranges from 0 to 1. Power normalization
is applied for <code>"coh"</code> and for <code>"ReXWT"</code>. All significance tests are one-tailed. 
Synchrony matrices for significance-based methods when <code>weighted</code> is <code>TRUE</code> 
contain 1 minus the p-values. 
</p>
<p>Clustering is performed using the the eigenvector-based modularity method of 
Newman (2006).
</p>


<h3>Value</h3>

<p><code>clust</code> returns an object of class <code>clust</code>. Slots are:
</p>
<table>
<tr><td><code>dat</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>coords</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>methodspecs</code></td>
<td>
<p>A list with elements specifying the method used, and methodological 
parameters that were in the input.</p>
</td></tr>
<tr><td><code>adj</code></td>
<td>
<p>The adjacency matrix that defines the synchrony network</p>
</td></tr>
<tr><td><code>clusters</code></td>
<td>
<p>A list with one element for each successive split of the networks into 
subcomponents carried out by the clustering algorithm. Each element is a vector of length equal
to the number of nodes in the original network, giving cluster membership of the nodes. The 
first element is a vector of all 1s, corresponding to before the first clustering split was
performed.</p>
</td></tr>
<tr><td><code>modres</code></td>
<td>
<p>A list of the same length as <code>clusters</code>, with each element containing the 
results of calling <code>modularity</code> on the network split to that level.</p>
</td></tr>
<tr><td><code>mns</code></td>
<td>
<p>Mean time series for modules. A list of the same length as <code>clusters</code>.</p>
</td></tr>
<tr><td><code>wmfs</code></td>
<td>
<p>Wavelet mean fields for modules. <code>NA</code> when <code>clust</code> is first called, but 
<code>addwmfs</code> causes this entry to be added. It is a list. See documentation for the method 
<code>addwmfs</code>.</p>
</td></tr>
<tr><td><code>wpmfs</code></td>
<td>
<p>Wavelet phasor mean fields for modules. <code>NA</code> when <code>clust</code> is first 
called, but <code>addwpmfs</code> causes this entry to be added. It is a list. See documentation for 
the method <code>addwpmfs</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>; 
Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>
</p>


<h3>References</h3>

<p>Walter, J. A., et al. (2017) The geography of spatial synchrony. Ecology Letters. 
doi: 10.1111/ele.12782
</p>
<p>Newman M.E.J. (2006). Finding community structure in networks using the eigenvectors of 
matrices. Phys Rev E, 74, 036104.
</p>
<p>Newman M.E.J. (2006) Modularity and community structure in networks. PNAS 103, 8577-8582.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluseigen">cluseigen</a></code>, <code><a href="#topic+modularity">modularity</a></code>, <code><a href="#topic+addwmfs">addwmfs</a></code>, 
<code><a href="#topic+addwpmfs">addwpmfs</a></code>,<code><a href="#topic+clust_methods">clust_methods</a></code>, <code><a href="#topic+synmat">synmat</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig&lt;-matrix(.8,5,5)
diag(sig)&lt;-1
lents&lt;-50
if (requireNamespace("mvtnorm",quietly=TRUE))
{
  dat1&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
  dat2&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
}else
{
  dat1&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
  dat2&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
}
dat&lt;-rbind(dat1,dat2)
times&lt;-1:lents
dat&lt;-cleandat(dat,times,clev=1)$cdat
coords&lt;-data.frame(Y=rep(0,10),X=1:10)
method&lt;-"coh.sig.fast"
res&lt;-clust(dat,times,coords,method,nsurrogs = 50)
#nsurrogs should be much higher for a real application

</code></pre>

<hr>
<h2 id='clust_methods'>Basic methods for the <code>clust</code> class</h2><span id='topic+clust_methods'></span><span id='topic+summary.clust'></span><span id='topic+print.clust'></span><span id='topic+set_times.clust'></span><span id='topic+set_adj.clust'></span><span id='topic+set_clusters.clust'></span><span id='topic+set_modres.clust'></span><span id='topic+set_mns.clust'></span><span id='topic+set_dat.clust'></span><span id='topic+set_coords.clust'></span><span id='topic+set_methodspecs.clust'></span><span id='topic+set_wmfs.clust'></span><span id='topic+set_wpmfs.clust'></span><span id='topic+get_times.clust'></span><span id='topic+get_adj.clust'></span><span id='topic+get_clusters.clust'></span><span id='topic+get_modres.clust'></span><span id='topic+get_mns.clust'></span><span id='topic+get_dat.clust'></span><span id='topic+get_coords.clust'></span><span id='topic+get_methodspec.clust'></span><span id='topic+get_wmfs.clust'></span><span id='topic+get_wpmfs.clust'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>clust</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'clust'
summary(object, ...)

## S3 method for class 'clust'
print(x, ...)

## S3 method for class 'clust'
set_times(obj, newval)

## S3 method for class 'clust'
set_adj(obj, newval)

## S3 method for class 'clust'
set_clusters(obj, newval)

## S3 method for class 'clust'
set_modres(obj, newval)

## S3 method for class 'clust'
set_mns(obj, newval)

## S3 method for class 'clust'
set_dat(obj, newval)

## S3 method for class 'clust'
set_coords(obj, newval)

## S3 method for class 'clust'
set_methodspecs(obj, newval)

## S3 method for class 'clust'
set_wmfs(obj, newval)

## S3 method for class 'clust'
set_wpmfs(obj, newval)

## S3 method for class 'clust'
get_times(obj)

## S3 method for class 'clust'
get_adj(obj)

## S3 method for class 'clust'
get_clusters(obj)

## S3 method for class 'clust'
get_modres(obj)

## S3 method for class 'clust'
get_mns(obj)

## S3 method for class 'clust'
get_dat(obj)

## S3 method for class 'clust'
get_coords(obj)

## S3 method for class 'clust'
get_methodspec(obj)

## S3 method for class 'clust'
get_wmfs(obj)

## S3 method for class 'clust'
get_wpmfs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clust_methods_+3A_object">object</code>, <code id="clust_methods_+3A_x">x</code>, <code id="clust_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>clust</code></p>
</td></tr>
<tr><td><code id="clust_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="clust_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.clust</code> produces a summary of a <code>clust</code> object.
A <code>print.clust</code> method is also available. For <code>clust</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots (see
the documentation for <code>clust</code> for a list). The <code>set_*</code> methods 
just throw an error, to prevent breaking the consistency between the 
slots of a <code>clust</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig&lt;-matrix(.8,5,5)
diag(sig)&lt;-1
lents&lt;-50
if (requireNamespace("mvtnorm",quietly=TRUE))
{
  dat1&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
  dat2&lt;-t(mvtnorm::rmvnorm(lents,mean=rep(0,5),sigma=sig))
}else
{
  dat1&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
  dat2&lt;-t(matrix(rep(rnorm(lents),times=5),lents,5))
}
dat&lt;-rbind(dat1,dat2)
times&lt;-1:lents
dat&lt;-cleandat(dat,times,clev=1)$cdat
coords&lt;-data.frame(Y=rep(0,10),X=1:10)
method&lt;-"coh.sig.fast"
h&lt;-clust(dat,times,coords,method,nsurrogs = 50)
#nsurrogs should be much higher for a real application
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='coh'>Coherence</h2><span id='topic+coh'></span>

<h3>Description</h3>

<p>Wavelet coherence and wavelet phase coherence, spatial or for single time series.
Also the generator function for the <code>coh</code> class, which inherits from the <code>list</code>
class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coh(
  dat1,
  dat2,
  times,
  norm,
  sigmethod = "none",
  nrand = 1000,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coh_+3A_dat1">dat1</code></td>
<td>
<p>A locations (rows) x time (columns) matrix (for spatial coherence), or a single time series</p>
</td></tr>
<tr><td><code id="coh_+3A_dat2">dat2</code></td>
<td>
<p>Same format as dat1, same locations and times</p>
</td></tr>
<tr><td><code id="coh_+3A_times">times</code></td>
<td>
<p>The times at which measurements were made, spacing 1</p>
</td></tr>
<tr><td><code id="coh_+3A_norm">norm</code></td>
<td>
<p>The normalization of wavelet transforms to use. Controls the version of the coherence that is 
performed. One of &quot;none&quot;, &quot;phase&quot;, &quot;powall&quot;, &quot;powind&quot;. See details.</p>
</td></tr>
<tr><td><code id="coh_+3A_sigmethod">sigmethod</code></td>
<td>
<p>The method for significance testing. One of &quot;none&quot;, &quot;fftsurrog1&quot;, &quot;fftsurrog2&quot;, &quot;fftsurrog12&quot;, 
&quot;aaftsurrog1&quot;, &quot;aaftsurrog2&quot;, &quot;aaftsurrog12&quot;, &quot;fast&quot;. See details.</p>
</td></tr>
<tr><td><code id="coh_+3A_nrand">nrand</code></td>
<td>
<p>Number of surrogate randomizations to use for significance testing.</p>
</td></tr>
<tr><td><code id="coh_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="coh_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined</p>
</td></tr>
<tr><td><code id="coh_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be greater than 1.</p>
</td></tr>
<tr><td><code id="coh_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the dimensions of <code>dat1</code> and <code>dat2</code> are <code class="reqn">N</code> by <code class="reqn">T</code> 
(<code class="reqn">N</code> is 1 for 
vector <code>dat1</code> and <code>dat2</code>), and if the wavelet transform of the <code class="reqn">n</code>th row
of <code>dati</code> is denoted <code class="reqn">W_{i,n,\sigma}(t)</code>, then the coherence is the 
average, over all 
locations <code class="reqn">n</code> and times <code class="reqn">t</code> for which wavelet transforms are 
available, of the quantity 
<code class="reqn">w_{1,n,\sigma}(t)w_{2,n,\sigma}(t)^{*}</code>, where the <code class="reqn">*</code> represents 
complex conjugation and
<code class="reqn">w_{i,n,\sigma}(t)</code> is a normalization of the wavelet 
transform. The normalization used depends 
on <code>norm</code>. If <code>norm</code> is &quot;<code>none</code>&quot; then raw wavelet transforms are used. 
If <code>norm</code> is &quot;<code>phase</code>&quot; then 
<code class="reqn">w_{i,n,\sigma}(t)=W_{i,n,\sigma}(t)/|W_{i,n,\sigma}(t)|</code>,
which gives the wavelet phase coherence, or the spatial wavelet phase coherence if <code class="reqn">N&gt;1</code>. 
If <code>norm</code> is &quot;<code>powall</code>&quot; then the normalization is that descibed in the &quot;Wavelet 
mean field&quot; section of the Methods of Sheppard et al. (2016), giving the version of the 
coherence that was there called simply the wavelet coherence, or the spatial wavelet 
coherence if <code class="reqn">N&gt;1</code>. If <code>norm</code> is &quot;<code>powind</code>&quot;, 
then <code class="reqn">w_{i,n,\sigma}(t)</code> is obtained
by dividing <code class="reqn">W_{i,n,\sigma}(t)</code> by the square root of the average of 
<code class="reqn">W_{i,n,\sigma}(t)W_{i,n,\sigma}(t)^{*}</code> over the times for 
which it is defined; this is done 
separately for each <code class="reqn">i</code> and <code class="reqn">n</code>.
</p>
<p>The slot <code>signif</code> is <code>NA</code> if <code>sigmethod</code> is &quot;<code>none</code>&quot;. Otherwise, and
if <code>sigmethod</code> is not &quot;<code>fast</code>&quot;, then <code>signif$coher</code> is the same as 
<code>coher</code>, and <code>signif$scoher</code> is a matrix of dimensions <code>nrand</code> by 
<code>length(coher)</code> with rows with magnitudes equal to coherences of surrogate 
datasets, computed using
the normalization specified by <code>norm</code>. The type of surrogate used (Fourier surrogates 
or amplitude adjusted Fourier surrogates, see <code>surrog</code>), as well as which of the 
datasets surrogates are computed on (<code>dat1</code>, <code>dat2</code>, or both) is determined by 
<code>sigmethod</code>. The first part of the value of <code>sigmethod</code> specifies the
type of surrogate used, and the numbers in the second part (1, 2, or 12) specify 
whether surrogates are applied to <code>dat1</code>, <code>dat2</code>, or both, respectively.
Synchrony-preserving surrogates are used. A variety of 
statements of significance (or lack thereof) can be made
by comparing <code>signif$coher</code> with <code>signif$scoher</code> (see the <code>plotmag</code>, 
<code>plotrank</code>, and <code>bandtest</code> methods
for the <code>coh</code> class). If <code>sigmethod</code> is 
&quot;<code>fast</code>&quot;, the fast algorithm of Sheppard et al. (2017) is used. In that case
<code>signif$coher</code> can be compared to <code>signif$scoher</code> to make significance 
statements about the coherence in exactly the same way, but <code>signif$coher</code> will no
longer precisely equal <code>coher</code>, and <code>coher</code> should not be compared 
directly to <code>signif$scoher</code>. Statements about significance of the coherence 
should be made using <code>signif$coher</code> and <code>signif$scoher</code>, whereas <code>coher</code>
should be used whenever the actual value of the coherence is needed. No fast algorithm
exists for <code>norm</code> equal to &quot;<code>phase</code>&quot; (the phase coherence; Sheppard et al, 2017),
so if <code>norm</code> is &quot;<code>phase</code>&quot; and <code>sigmethod</code> is &quot;<code>fast</code>&quot;, the function
throws an error.
</p>
<p>The slots <code>ranks</code> and <code>bandp</code> are empty on an initial call to <code>coh</code>. 
They are made to compute and hold 
aggregate significance results over any timescale band of choice. These are filled in
when needed by other methods, see <code>plotrank</code> and <code>bandtest</code>. 
</p>
<p>Regardless of what the variables represent, the normalized transform of dat1 is multiplied 
by the conjugate of the normalized transform of dat2. Thus, a positive phase of the coherence 
indicates dat1 would be leading dat2.
</p>


<h3>Value</h3>

<p><code>coh</code> returns an object of class <code>coh</code>. Slots are:
</p>
<table>
<tr><td><code>dat1</code>, <code>dat2</code></td>
<td>
<p>The input data</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The times associated with the data</p>
</td></tr>
<tr><td><code>sigmethod</code></td>
<td>
<p>The method for significance testing, as inputted.</p>
</td></tr> 
<tr><td><code>norm</code></td>
<td>
<p>The normalization of the wavelet transforms that will be used in computing the coherence. Different 
values result in different versions of the coherence. One of &quot;none&quot;, &quot;phase&quot;, &quot;powall&quot;, &quot;powind&quot;. See details.</p>
</td></tr>
<tr><td><code>wtopt</code></td>
<td>
<p>The inputted wavelet transform options scale.min, scale.max.input, sigma, f0 in a list</p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales associated with the coherence</p>
</td></tr>
<tr><td><code>coher</code></td>
<td>
<p>The complex magnitude of this quantity is the coherence, calculated in the usual way (which depends 
on <code>norm</code>, see details), and with scalloping of the transforms.</p>
</td></tr> 
<tr><td><code>signif</code></td>
<td>
<p>A list with information from the significance testing. Elements are <code>coher</code> and <code>scoher</code>. 
See details.</p>
</td></tr>
<tr><td><code>ranks</code></td>
<td>
<p>A list with ranking information for <code>signif</code>. <code>NA</code> until <code>plotrank</code> is called, see 
documentation for <code>plotrank</code>.</p>
</td></tr>
<tr><td><code>bandp</code></td>
<td>
<p>A data frame containing results of computing significances of the coherence across timescale bands. 
Empty on an initial call to <code>coh</code>, filled in by the function <code>bandtest</code>. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>
<p>Sheppard, L.W., et al. (2017) Rapid surrogate testing of wavelet coherences. European Physical 
Journal, Nonlinear and Biomedical Physics, 5, 1. DOI: 10.1051/epjnbp/2017000
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cleandat">cleandat</a></code>, <code><a href="#topic+coh_methods">coh_methods</a></code>, <code><a href="#topic+bandtest">bandtest</a></code>, <code><a href="#topic+plotmag">plotmag</a></code>, 
<code><a href="#topic+plotphase">plotphase</a></code>, <code><a href="#topic+plotrank">plotrank</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:100
dat1&lt;-matrix(rnorm(1000),10,100)
dat2&lt;-matrix(rnorm(1000),10,100)
dat1&lt;-cleandat(dat1,times,1)$cdat
dat2&lt;-cleandat(dat2,times,1)$cdat
norm&lt;-"powall"
sigmethod&lt;-"fast"
nrand&lt;-10
res&lt;-coh(dat1,dat2,times,norm,sigmethod,nrand)
#for real applications, use a much bigger nrand

</code></pre>

<hr>
<h2 id='coh_methods'>Basic methods for the <code>coh</code> class</h2><span id='topic+coh_methods'></span><span id='topic+summary.coh'></span><span id='topic+print.coh'></span><span id='topic+set_times.coh'></span><span id='topic+set_timescales.coh'></span><span id='topic+set_coher.coh'></span><span id='topic+set_dat1.coh'></span><span id='topic+set_dat2.coh'></span><span id='topic+set_wtopt.coh'></span><span id='topic+set_norm.coh'></span><span id='topic+set_sigmethod.coh'></span><span id='topic+set_signif.coh'></span><span id='topic+set_ranks.coh'></span><span id='topic+set_bandp.coh'></span><span id='topic+get_times.coh'></span><span id='topic+get_timescales.coh'></span><span id='topic+get_coher.coh'></span><span id='topic+get_dat1.coh'></span><span id='topic+get_dat2.coh'></span><span id='topic+get_wtopt.coh'></span><span id='topic+get_norm.coh'></span><span id='topic+get_sigmethod.coh'></span><span id='topic+get_signif.coh'></span><span id='topic+get_ranks.coh'></span><span id='topic+get_bandp.coh'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>coh</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'coh'
summary(object, ...)

## S3 method for class 'coh'
print(x, ...)

## S3 method for class 'coh'
set_times(obj, newval)

## S3 method for class 'coh'
set_timescales(obj, newval)

## S3 method for class 'coh'
set_coher(obj, newval)

## S3 method for class 'coh'
set_dat1(obj, newval)

## S3 method for class 'coh'
set_dat2(obj, newval)

## S3 method for class 'coh'
set_wtopt(obj, newval)

## S3 method for class 'coh'
set_norm(obj, newval)

## S3 method for class 'coh'
set_sigmethod(obj, newval)

## S3 method for class 'coh'
set_signif(obj, newval)

## S3 method for class 'coh'
set_ranks(obj, newval)

## S3 method for class 'coh'
set_bandp(obj, newval)

## S3 method for class 'coh'
get_times(obj)

## S3 method for class 'coh'
get_timescales(obj)

## S3 method for class 'coh'
get_coher(obj)

## S3 method for class 'coh'
get_dat1(obj)

## S3 method for class 'coh'
get_dat2(obj)

## S3 method for class 'coh'
get_wtopt(obj)

## S3 method for class 'coh'
get_norm(obj)

## S3 method for class 'coh'
get_sigmethod(obj)

## S3 method for class 'coh'
get_signif(obj)

## S3 method for class 'coh'
get_ranks(obj)

## S3 method for class 'coh'
get_bandp(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coh_methods_+3A_object">object</code>, <code id="coh_methods_+3A_x">x</code>, <code id="coh_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>coh</code></p>
</td></tr>
<tr><td><code id="coh_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="coh_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.coh</code> produces a summary of a <code>coh</code> object.
A <code>print.coh</code> method is also available. For <code>coh</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots (see
the documentation for <code>coh</code> for a list). The <code>set_*</code> methods 
just throw an error, to prevent breaking the consistency between the 
slots of a <code>coh</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coh">coh</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:100
dat1&lt;-matrix(rnorm(1000),10,100)
dat2&lt;-matrix(rnorm(1000),10,100)
dat1&lt;-cleandat(dat1,times,1)$cdat
dat2&lt;-cleandat(dat2,times,1)$cdat
norm&lt;-"powall"
sigmethod&lt;-"fast"
nrand&lt;-10
h&lt;-coh(dat1,dat2,times,norm,sigmethod,nrand)
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='errcheck_stdat'>Error check for appropriate spatio-temporal data</h2><span id='topic+errcheck_stdat'></span>

<h3>Description</h3>

<p>Error checking whether a times vector and a matrix with each row a time
series make a legitimate spatio-temporal data set for wavelet analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errcheck_stdat(times, dat, callfunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errcheck_stdat_+3A_times">times</code></td>
<td>
<p>the times of measurement, spacing 1</p>
</td></tr>
<tr><td><code id="errcheck_stdat_+3A_dat">dat</code></td>
<td>
<p>each row is a time series - must have at least two rows</p>
</td></tr>
<tr><td><code id="errcheck_stdat_+3A_callfunc">callfunc</code></td>
<td>
<p>the function calling this one, for error tracking</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>errcheck_stdat</code> returns nothing but throws and error if inputs not appropriate
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='errcheck_times'>Error check <code>times</code></h2><span id='topic+errcheck_times'></span>

<h3>Description</h3>

<p>Error check whether a vector can represent times at which data suitable 
for wavelet transforms were measured
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errcheck_times(times, callfunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errcheck_times_+3A_times">times</code></td>
<td>
<p>Tests whether this is a numeric vector with unit-spaced increasing values</p>
</td></tr>
<tr><td><code id="errcheck_times_+3A_callfunc">callfunc</code></td>
<td>
<p>Function calling this one, for better error messaging</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>errcheck_times</code> returns nothing but throws and error if the conditions are not met
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='errcheck_tsdat'>Error check for appropriate temporal data</h2><span id='topic+errcheck_tsdat'></span>

<h3>Description</h3>

<p>Error checking whether a times vector and t.series vector make a 
legitimate time series for wavelet analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errcheck_tsdat(times, t.series, callfunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errcheck_tsdat_+3A_times">times</code></td>
<td>
<p>times of measurement, spacing 1</p>
</td></tr>
<tr><td><code id="errcheck_tsdat_+3A_t.series">t.series</code></td>
<td>
<p>the measurements</p>
</td></tr>
<tr><td><code id="errcheck_tsdat_+3A_callfunc">callfunc</code></td>
<td>
<p>the function from which this one was called, for error tracking</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>errcheck_tsdat</code> returns nothing but throws and error if inputs not appropriate
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='errcheck_tts'>Error check whether inputs are suitable for a tts object</h2><span id='topic+errcheck_tts'></span>

<h3>Description</h3>

<p>Error check whether inputs are suitable for a tts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errcheck_tts(times, timescales, values, callfunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errcheck_tts_+3A_times">times</code></td>
<td>
<p>times of measurement, spacing 1</p>
</td></tr>
<tr><td><code id="errcheck_tts_+3A_timescales">timescales</code></td>
<td>
<p>timescales of analysis</p>
</td></tr>
<tr><td><code id="errcheck_tts_+3A_values">values</code></td>
<td>
<p>a times by timescales matrix</p>
</td></tr>
<tr><td><code id="errcheck_tts_+3A_callfunc">callfunc</code></td>
<td>
<p>the function from which this one was called, for error tracking</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>errcheck_tts</code> returns nothing but throws and error if inputs not appropriate
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='errcheck_wavparam'>Error check wavelet transform parameters</h2><span id='topic+errcheck_wavparam'></span>

<h3>Description</h3>

<p>Error check the parameters <code>scale.min</code>, <code>scale.max.input</code>, <code>sigma</code>, <code>f0</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errcheck_wavparam(scale.min, scale.max.input, sigma, f0, times, callfunc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="errcheck_wavparam_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="errcheck_wavparam_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation that is guaranteed to be examined</p>
</td></tr>
<tr><td><code id="errcheck_wavparam_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be greater than 1.</p>
</td></tr>
<tr><td><code id="errcheck_wavparam_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope. Defaults to 1.</p>
</td></tr>
<tr><td><code id="errcheck_wavparam_+3A_times">times</code></td>
<td>
<p>The times data were measured at, spacing 1</p>
</td></tr>
<tr><td><code id="errcheck_wavparam_+3A_callfunc">callfunc</code></td>
<td>
<p>Function calling this one, for better error messaging</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>errcheck_wavparam</code> returns nothing but throws and error if the conditions are not met
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='fastcohtest'>Fast algorithm for significance testing coherence using Fourier surrogates</h2><span id='topic+fastcohtest'></span>

<h3>Description</h3>

<p>This is the algorithm of Sheppard et al. (2017) (see references).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastcohtest(
  dat1,
  dat2,
  scale.min,
  scale.max.input,
  sigma,
  f0,
  nrand,
  randnums,
  randbits,
  norm
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastcohtest_+3A_dat1">dat1</code></td>
<td>
<p>A locations (rows) x time (columns) matrix (for spatial coherence), or a single time series</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_dat2">dat2</code></td>
<td>
<p>Same format as <code>dat1</code>, same locations and times</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be greater than 1.</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_nrand">nrand</code></td>
<td>
<p>Number of surrogate randomizations to use for significance testing</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_randnums">randnums</code></td>
<td>
<p>A bunch of independent random numbers uniformly distributed on (0,1).
There must be <code>nrand*floor((dim(dat1)[2]-1)/2)</code> of these.</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_randbits">randbits</code></td>
<td>
<p>A bunch of random bits (0 or 1). There must be <code>nrand</code> of these if time
series are of odd length and <code>2*nrand</code> if even length. You may pass more than this, so,
in particular, you may pass <code>2*nrand</code> for even or odd length.</p>
</td></tr>
<tr><td><code id="fastcohtest_+3A_norm">norm</code></td>
<td>
<p>The normalization of wavelet transforms to use. Controls the version of the 
coherence that is performed. One of &quot;none&quot;, &quot;powall&quot;, &quot;powind&quot;. See details in
the documentation of <code>coh</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fastcohtest</code> returns a list with these elements:
</p>
<table>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales used</p>
</td></tr>
<tr><td><code>coher</code></td>
<td>
<p>The magnitude of this is the fast-algorithm version of the coherence between
the two datasets, for comparison with <code>scoher</code></p>
</td></tr>
<tr><td><code>scoher</code></td>
<td>
<p>A matrix with <code>nrand</code> rows, the magnitude of each one is the 
fast-algorithm version of the coherence for a surrogate</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Internal function, minimal error checking.
</p>


<h3>Author(s)</h3>

<p>Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2017) Rapid surrogate testing of wavelet coherences. European Physical 
Journal, Nonlinear and Biomedical Physics, 5, 1. DOI: 10.1051/epjnbp/2017000
</p>

<hr>
<h2 id='fftsurrog'>Surrogate time series using Fourier surrogates</h2><span id='topic+fftsurrog'></span>

<h3>Description</h3>

<p>Creates surrogate time series using Fourier surrogates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fftsurrog(dat, nsurrogs, syncpres)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftsurrog_+3A_dat">dat</code></td>
<td>
<p>A locations x time matrix of observations</p>
</td></tr>
<tr><td><code id="fftsurrog_+3A_nsurrogs">nsurrogs</code></td>
<td>
<p>The number of surrogates to produce</p>
</td></tr>
<tr><td><code id="fftsurrog_+3A_syncpres">syncpres</code></td>
<td>
<p>Logical. TRUE for &quot;synchrony preserving&quot; surrogates (same phase randomizations used for all 
time series). FALSE leads to independent phase randomizations for all time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>fftsurrog</code> returns a list of nsurrogs surrogate datasets
</p>


<h3>Note</h3>

<p>For internal use, no error checking
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; 
Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW, et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>
<p>Schreiber, T and Schmitz, A (2000) Surrogate time series. Physica D 142, 346-382.
</p>
<p>Prichard, D and Theiler, J (1994) Generating surrogate data for time series with several simultaneously measured variables. Physical Review Letters 73, 951-954.
</p>

<hr>
<h2 id='is.connected'>Tests if a graph is connected</h2><span id='topic+is.connected'></span>

<h3>Description</h3>

<p>Tests if a graph represented by an adjacency matrix is connected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.connected(adj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.connected_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix. Must be a numeric matrix with non-negative entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Idea by Ed Scheinerman, circa 2006. 
Source: http://www.ams.jhu.edu/~ers/matgraph/; routine: 
matgraph/@graph/isconnected.m
</p>


<h3>Value</h3>

<p><code>is.connected</code> returns <code>TRUE</code> or <code>FALSE</code> depending on whether
the graph represented in <code>adj</code> is a connected graph.
</p>


<h3>Author(s)</h3>

<p>Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluseigen">cluseigen</a></code>, <code><a href="#topic+clust">clust</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g1&lt;-matrix(c(0,0,0,1,1,0,0,0,0,1,0,0,0,0,1,0),4,4)
is.connected(g1)
g2&lt;-matrix(c(0,1,0,0,1,0,0,0,0,0,0,1,0,0,1,0),4,4)
is.connected(g2)

</code></pre>

<hr>
<h2 id='makeunweighted'>For converting certain synchrony matrices to unweighted versions</h2><span id='topic+makeunweighted'></span>

<h3>Description</h3>

<p>Convenience function for converting certain synchrony matrices to unweighted versions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeunweighted(mat, sigthresh)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeunweighted_+3A_mat">mat</code></td>
<td>
<p>A synchrony matrix based on significance testing</p>
</td></tr>
<tr><td><code id="makeunweighted_+3A_sigthresh">sigthresh</code></td>
<td>
<p>Significance threshold to use</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>makeunweighted</code> converts to an unweighted version of the input. Entries of
<code>mat</code> less than <code>sigthresh</code> become a 1, other entries become a 0. The diagonal
is <code>NA</code>.
</p>


<h3>Note</h3>

<p>Internal function, no error checking
</p>


<h3>Author(s)</h3>

<p>Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>, Daniel Reuman <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='mnphase'>Mean phase of coherence</h2><span id='topic+mnphase'></span>

<h3>Description</h3>

<p>Gets the mean phase of a bunch of complex numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mnphase(nums)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mnphase_+3A_nums">nums</code></td>
<td>
<p>A vector of complex numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mnphase</code> returns the mean phase
</p>


<h3>Note</h3>

<p>Internal funcion, no error catching
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='modularity'>Modularity of a community structure of a graph</h2><span id='topic+modularity'></span>

<h3>Description</h3>

<p>Computes the modularity of partitioning of a graph into sub-graphs. Similar to the
<code>modularity</code> function in the <code>igraph</code> package, but allows negative
edge weights.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modularity(adj, membership, decomp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modularity_+3A_adj">adj</code></td>
<td>
<p>An adjacency matrix, which should be symmetric with zeros on the diagonal.</p>
</td></tr>
<tr><td><code id="modularity_+3A_membership">membership</code></td>
<td>
<p>Vector of length equal to the number of graph nodes (columns/rows 
of <code>adj</code>) indicating the cluster/sub-graph each nodes belongs to.</p>
</td></tr>
<tr><td><code id="modularity_+3A_decomp">decomp</code></td>
<td>
<p>Logical. If <code>TRUE</code>, calculate the decomposition of modularity
by modules and nodes. Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The difference between this function and the function <code>modularity</code> 
in the package <code>igraph</code> is that this function can be used with an adjacency 
matrix with negative elements. This is a common case for matrices arrising from a 
for correlation matrix or another synchrony matrix. If the matrix is non-negative, 
the result of this function should be exactly the same as the result from 
<code>modularity</code> in the <code>igraph</code> package.
</p>


<h3>Value</h3>

<p><code>modularity</code> returns a list containing the following:
</p>
<table>
<tr><td><code>totQ</code></td>
<td>
<p>The total modularity. This is the only output if <code>decomp=FALSE</code></p>
</td></tr>
<tr><td><code>modQ</code></td>
<td>
<p>The contribution of each module to the total modularity</p>
</td></tr>
<tr><td><code>nodeQ</code></td>
<td>
<p>The contribution of each node to the total modularity</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Adapted from code developed by Robert J. Fletcher, Jr.
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jonathan.walter@ku.edu">jonathan.walter@ku.edu</a>; Lei Zhao, 
<a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Fletcher Jr., R.J., et al. (2013) Network modularity reveals critical scales 
for connectivity in ecology and evolution. Nature Communications. doi: 10.1038//ncomms3572.
</p>
<p>Gomez S., Jensen P. &amp; Arenas A. (2009). Analysis of community structure in networks 
of correlated data. Phys Rev E, 80, 016114.
</p>
<p>Newman M.E. (2006). Finding community structure in networks using the eigenvectors 
of matrices. Phys Rev E, 74, 036104.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code><a href="#topic+cluseigen">cluseigen</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adj&lt;-matrix(0, 10, 10) # create a fake adjacency matrix
adj[lower.tri(adj)]&lt;-runif(10*9/2, -1, 1)
adj&lt;-adj+t(adj)
colnames(adj)&lt;-letters[1:10]
m&lt;-cluseigen(adj)
z&lt;-modularity(adj, m[[length(m)]], decomp=TRUE)

</code></pre>

<hr>
<h2 id='normforcoh'>Normalization for the <code>coh</code> function</h2><span id='topic+normforcoh'></span>

<h3>Description</h3>

<p>A convenience function for performing the normalization step for the <code>coh</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normforcoh(W, norm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normforcoh_+3A_w">W</code></td>
<td>
<p>An array of wavelet transforms, locations by times by timescales</p>
</td></tr>
<tr><td><code id="normforcoh_+3A_norm">norm</code></td>
<td>
<p>The normalization of wavelet transforms to use. Controls the version of the coherence that is performed. One of &quot;none&quot;, &quot;phase&quot;, &quot;powall&quot;, &quot;powind&quot;. See details section of the documentation for <code>coh</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>normforcoh</code> returns an array the same dimensions as W of normalized transforms
</p>


<h3>Note</h3>

<p>Internal function, no error checking
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='plotmag'>For plotting the magnitude of values in <code>tts</code>, <code>coh</code> and <code>wlmtest</code> objects</h2><span id='topic+plotmag'></span><span id='topic+plotmag.tts'></span><span id='topic+plotmag.wt'></span><span id='topic+plotmag.wmf'></span><span id='topic+plotmag.wpmf'></span><span id='topic+plotmag.coh'></span><span id='topic+plotmag.wlmtest'></span><span id='topic+plotmag.default'></span>

<h3>Description</h3>

<p>For plotting the magnitude of values in <code>tts</code> objects (and derived classes) 
against time and timescale, and <code>coh</code> and <code>wlmtest</code> objects against timescale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmag(object, ...)

## S3 method for class 'tts'
plotmag(
  object,
  zlims = NULL,
  neat = TRUE,
  colorfill = NULL,
  colorbar = TRUE,
  title = NULL,
  filename = NA,
  ...
)

## S3 method for class 'wt'
plotmag(
  object,
  zlims = NULL,
  neat = TRUE,
  colorfill = NULL,
  colorbar = TRUE,
  title = NULL,
  filename = NA,
  ...
)

## S3 method for class 'wmf'
plotmag(
  object,
  zlims = NULL,
  neat = TRUE,
  colorfill = NULL,
  colorbar = TRUE,
  title = NULL,
  filename = NA,
  ...
)

## S3 method for class 'wpmf'
plotmag(
  object,
  zlims = NULL,
  neat = TRUE,
  colorfill = NULL,
  sigthresh = 0.95,
  colorbar = TRUE,
  title = NULL,
  filename = NA,
  ...
)

## S3 method for class 'coh'
plotmag(
  object,
  sigthresh = c(0.95, 0.99),
  bandprows = "all",
  filename = NA,
  ...
)

## S3 method for class 'wlmtest'
plotmag(
  object,
  sigthresh = c(0.95, 0.99),
  bandprows = "all",
  filename = NA,
  ...
)

## Default S3 method:
plotmag(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmag_+3A_object">object</code></td>
<td>
<p>An object of class <code>tts</code> or some class that inherits from <code>tts</code> or 
of class <code>coh</code> or <code>wlmtest</code></p>
</td></tr>
<tr><td><code id="plotmag_+3A_...">...</code></td>
<td>
<p>Additional graphics parameters passed to <code>image</code> (<code>graphics</code> package) 
if <code>colorbar==FALSE</code>, or to <code>image.plot</code> (<code>fields</code> package) if 
<code>colorbar==TRUE</code> (for <code>tts</code> objects)</p>
</td></tr>
<tr><td><code id="plotmag_+3A_zlims">zlims</code></td>
<td>
<p>z axis limits. If specified, must encompass the range of 
<code>Mod(get_values(object))</code>. Default NULL uses this range.</p>
</td></tr>
<tr><td><code id="plotmag_+3A_neat">neat</code></td>
<td>
<p>Logical. Should timescales with no values be trimmed?</p>
</td></tr>
<tr><td><code id="plotmag_+3A_colorfill">colorfill</code></td>
<td>
<p>Color spectrum to use, set through colorRampPalette. Default value NULL 
produces jet colors from Matlab.</p>
</td></tr>
<tr><td><code id="plotmag_+3A_colorbar">colorbar</code></td>
<td>
<p>Logical. Should a colorbar legend be plotted?</p>
</td></tr>
<tr><td><code id="plotmag_+3A_title">title</code></td>
<td>
<p>Title for the top of the plot.</p>
</td></tr>
<tr><td><code id="plotmag_+3A_filename">filename</code></td>
<td>
<p>Filename (without extension), for saving as pdf. Default value NA saves no 
file and uses the default graphics device.</p>
</td></tr>
<tr><td><code id="plotmag_+3A_sigthresh">sigthresh</code></td>
<td>
<p>Significance threshold(s). Numeric vector with values between 0 and 1. 
Typically 0.95, 0.99, 0.999, etc. For <code>wpmf</code> objects, contours are plotted at these 
values; for <code>coh</code> and <code>wlmtest</code> objects the threshholds are plotted on coherence 
plots.</p>
</td></tr>
<tr><td><code id="plotmag_+3A_bandprows">bandprows</code></td>
<td>
<p>The rows of <code>object$bandp</code> for which to display results in <code>coh</code> plots</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>coh</code> (respectively, <code>wlmtest</code>) objects, the modulus of 
object$coher (respectively, object$wlmobj$coher) is plotted using a solid red line, and 
the modulus of object$signif$coher is plotted using a dashed red line. The two coherences 
agree except for <code>sigmethod="fast"</code>, for which they are close. The dashed line is what 
should be compared to the distribution of surrogate coherences (black lines, which only appear 
for <code>coh</code> objects if <code>signif</code> is not <code>NA</code>). Horizontal axis ticks are labeled 
as timescales, but are spaced on the axis as log(1/timescale), i.e., log frequencies.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>
<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>, <code><a href="#topic+coh">coh</a></code>,
<code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+plotphase">plotphase</a></code>, <code><a href="#topic+bandtest">bandtest</a></code>, <code><a href="#topic+plotrank">plotrank</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For a wt object
time1&lt;-1:100
time2&lt;-101:200
ts1p1&lt;-sin(2*pi*time1/15)
ts1p2&lt;-0*time1
ts2p1&lt;-0*time2
ts2p2&lt;-sin(2*pi*time2/8)
ts1&lt;-ts1p1+ts1p2
ts2&lt;-ts2p1+ts2p2
ts&lt;-c(ts1,ts2)
ra&lt;-rnorm(200,mean=0,sd=0.5)
t.series&lt;-ts+ra
t.series&lt;-t.series-mean(t.series)
times&lt;-c(time1,time2)
res&lt;-wt(t.series, times)
plotmag(res)

#For a wmf object
x1&lt;-0:50
x2&lt;-51:100
x&lt;-c(x1,x2)
ts1&lt;-c(sin(2*pi*x1/10),sin(2*pi*x2/5))+1.1
dat&lt;-matrix(NA,11,length(x))
for (counter in 1:dim(dat)[1])
{
  ts2&lt;-3*sin(2*pi*x/3+2*pi*runif(1))+3.1
  ts3&lt;-rnorm(length(x),0,1.5)
  dat[counter,]&lt;-ts1+ts2+ts3    
  dat[counter,]&lt;-dat[counter,]-mean(dat[counter,])
}
times&lt;-x
res&lt;-wmf(dat,times)
plotmag(res)

#similar calls for wpmf, coh, wlm, wlmtest objects
#see documentation 

</code></pre>

<hr>
<h2 id='plotmap'>Map clusters from a <code>clust</code> object</h2><span id='topic+plotmap'></span>

<h3>Description</h3>

<p>Produces a map of the locations of sampling for a <code>clust</code> object, with colors indicating 
module (cluster) identity.
The sizes of nodes (locations) are scaled according to the strength of membership in its module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(
  inclust,
  spltlvl = length(inclust$clusters),
  nodesize = c(1, 3),
  filename = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmap_+3A_inclust">inclust</code></td>
<td>
<p>A <code>clust</code> object, as created with <code>wsyn::clust</code></p>
</td></tr>
<tr><td><code id="plotmap_+3A_spltlvl">spltlvl</code></td>
<td>
<p>The split level in the clustering to use. This is the index of inclust$clusters.
Default the final split.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_nodesize">nodesize</code></td>
<td>
<p>A length = 2 vector giving the minimum and maximum node size for plotting. Defaults to c(1,3).</p>
</td></tr>
<tr><td><code id="plotmap_+3A_filename">filename</code></td>
<td>
<p>a filename, possibly including path info, but without a file extension. If present,
exports the plot as a .pdf using the specified filename. Default <code>NA</code> uses the default plotting
device.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plotmap</code> produces a map.
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>
</p>


<h3>References</h3>

<p>Walter, J. A., et al. (2017) The geography of spatial synchrony. Ecology Letters. 
doi: 10.1111/ele.12782
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Tmax&lt;-500
tim&lt;-1:Tmax
ts1&lt;-sin(2*pi*tim/5)
ts1s&lt;-sin(2*pi*tim/5+pi/2)
ts2&lt;-sin(2*pi*tim/12)
ts2s&lt;-sin(2*pi*tim/12+pi/2)
gp1A&lt;-1:2
gp1B&lt;-3:4
gp2A&lt;-5:6
gp2B&lt;-7:8
d&lt;-matrix(NA,Tmax,8)
d[,c(gp1A,gp1B)]&lt;-ts1
d[,c(gp2A,gp2B)]&lt;-ts1s
d[,c(gp1A,gp2A)]&lt;-d[,c(gp1A,gp2A)]+matrix(ts2,Tmax,4)
d[,c(gp1B,gp2B)]&lt;-d[,c(gp1B,gp2B)]+matrix(ts2s,Tmax,4)
d&lt;-d+matrix(rnorm(Tmax*8,0,2),Tmax,8)
d&lt;-t(d)
d&lt;-cleandat(d,1:Tmax,1)$cdat
coords&lt;-data.frame(X=c(rep(1,4),rep(2,4)),Y=rep(c(1:2,4:5),times=2))
cl5&lt;-clust(dat=d,times=1:Tmax,coords=coords,method="ReXWT",tsrange=c(4,6))
plotmap(cl5)
cl12&lt;-clust(dat=d,times=1:Tmax,coords=coords,method="ReXWT",tsrange=c(11,13))
plotmap(cl12)

</code></pre>

<hr>
<h2 id='plotphase'>For plotting the phases of values in <code>tts</code> and <code>coh</code> objects</h2><span id='topic+plotphase'></span><span id='topic+plotphase.tts'></span><span id='topic+plotphase.wt'></span><span id='topic+plotphase.wmf'></span><span id='topic+plotphase.wpmf'></span><span id='topic+plotphase.coh'></span><span id='topic+plotphase.default'></span>

<h3>Description</h3>

<p>For plotting the phases of values in <code>tts</code> objects (and derived classes) 
against time and timescale, and <code>coh</code> objects against timescale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotphase(object, ...)

## S3 method for class 'tts'
plotphase(object, filename = NA, ...)

## S3 method for class 'wt'
plotphase(object, filename = NA, ...)

## S3 method for class 'wmf'
plotphase(object, filename = NA, ...)

## S3 method for class 'wpmf'
plotphase(object, filename = NA, ...)

## S3 method for class 'coh'
plotphase(object, bandprows = "all", filename = NA, ...)

## Default S3 method:
plotphase(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotphase_+3A_object">object</code></td>
<td>
<p>A <code>coh</code> object.</p>
</td></tr>
<tr><td><code id="plotphase_+3A_...">...</code></td>
<td>
<p>Passed from the generic to specific methods. The plotphase.tss method passes it to 
fields::image.plot.</p>
</td></tr>
<tr><td><code id="plotphase_+3A_filename">filename</code></td>
<td>
<p>Filename (without extension), for saving as pdf. Default value NA saves no file 
and uses the default graphics device.</p>
</td></tr>
<tr><td><code id="plotphase_+3A_bandprows">bandprows</code></td>
<td>
<p>The rows of <code>object$bandp</code> for which to display p-value results in the plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; 
Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>, <code><a href="#topic+coh">coh</a></code>, 
<code><a href="#topic+plotmag">plotmag</a></code>, <code><a href="#topic+plotrank">plotrank</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For a tts object
times&lt;-1:100
timescales&lt;-1:100
cplx&lt;-complex(modulus=1,argument=seq(from=-pi,to=pi,length.out=100))
values1&lt;-matrix(cplx,length(times),length(timescales))
tts1&lt;-tts(times,timescales,values1)  
plotphase(tts1)

#For a coh oject
times&lt;-(-3:100)
ts1&lt;-sin(2*pi*times/10)
ts2&lt;-5*sin(2*pi*times/3)
artsig_x&lt;-matrix(NA,11,length(times)) #the driver
for (counter in 1:11)
{
  artsig_x[counter,]=ts1+ts2+rnorm(length(times),mean=0,sd=1.5)
}
times&lt;-0:100
artsig_y&lt;-matrix(NA,11,length(times)) #the driven
for (counter1 in 1:11)
{
  for (counter2 in 1:101)
  {
    artsig_y[counter1,counter2]&lt;-mean(artsig_x[counter1,counter2:(counter2+2)])
  }
}
artsig_y&lt;-artsig_y+matrix(rnorm(length(times)*11,mean=0,sd=3),11,length(times))
artsig_x&lt;-artsig_x[,4:104]
artsig_x&lt;-cleandat(artsig_x,times,1)$cdat
artsig_y&lt;-cleandat(artsig_y,times,1)$cdat
res&lt;-coh(dat1=artsig_x,dat2=artsig_y,times=times,norm="powall",sigmethod="fast",nrand=50,
         f0=0.5,scale.max.input=28)
res&lt;-bandtest(res,c(2,4))
res&lt;-bandtest(res,c(4,30))
res&lt;-bandtest(res,c(8,12))
plotphase(res)

</code></pre>

<hr>
<h2 id='plotrank'>Plots <code>ranks</code> slot for <code>coh</code> and <code>wlmtest</code> objects</h2><span id='topic+plotrank'></span><span id='topic+plotrank.coh'></span><span id='topic+plotrank.wlmtest'></span><span id='topic+plotrank.default'></span>

<h3>Description</h3>

<p>Plots the <code>ranks</code> slot for <code>coh</code> and <code>wlmtest</code> objects to help identify statistical 
significance of coherence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotrank(object, ...)

## S3 method for class 'coh'
plotrank(object, sigthresh = 0.95, bandprows = "all", filename = NA, ...)

## S3 method for class 'wlmtest'
plotrank(object, sigthresh = 0.95, bandprows = "all", filename = NA, ...)

## Default S3 method:
plotrank(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotrank_+3A_object">object</code></td>
<td>
<p>A <code>coh</code> or <code>wlmtest</code> object. Must have a non-<code>NA</code> <code>signif</code> slot.</p>
</td></tr>
<tr><td><code id="plotrank_+3A_...">...</code></td>
<td>
<p>Passed from the generic to specific methods. Not currently used.</p>
</td></tr>
<tr><td><code id="plotrank_+3A_sigthresh">sigthresh</code></td>
<td>
<p>Significance threshold(s). Numeric vector with values between 0 and 1. Typically 
0.95, 0.99, 0.999, etc. The threshhold(s) are plotted on the rank plot as dashed horizontal line(s).</p>
</td></tr>
<tr><td><code id="plotrank_+3A_bandprows">bandprows</code></td>
<td>
<p>The rows of <code>object$bandp</code> for which to display p-value results in the plot</p>
</td></tr>
<tr><td><code id="plotrank_+3A_filename">filename</code></td>
<td>
<p>Filename (without extension), for saving as pdf. Default value NA saves no file and 
uses the default graphics device.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plot shows the modulus of <code>object$ranks$coher</code> versus <code>log(1/object$timescales)</code>.
Horizontal axis ticks are labeled as timescales, but are spaced on the axis as 
log(1/timescale), i.e., log frequencies. p-values from <code>object$bandp</code> are displayed
above the rank plot.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>
<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+bandtest">bandtest</a></code>, <code><a href="#topic+plotphase">plotphase</a></code>,
<code><a href="#topic+plotmag">plotmag</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#For a coh object
times&lt;-(-3:100)
ts1&lt;-sin(2*pi*times/10)
ts2&lt;-5*sin(2*pi*times/3)
artsig_x&lt;-matrix(NA,11,length(times)) #the driver
for (counter in 1:11)
{
  artsig_x[counter,]=ts1+ts2+rnorm(length(times),mean=0,sd=1.5)
}
times&lt;-0:100
artsig_y&lt;-matrix(NA,11,length(times)) #the driven
for (counter1 in 1:11)
{
  for (counter2 in 1:101)
  {
    artsig_y[counter1,counter2]&lt;-mean(artsig_x[counter1,counter2:(counter2+2)])
  }
}
artsig_y&lt;-artsig_y+matrix(rnorm(length(times)*11,mean=0,sd=3),11,length(times))
artsig_x&lt;-artsig_x[,4:104]
artsig_x&lt;-cleandat(artsig_x,times,1)$cdat
artsig_y&lt;-cleandat(artsig_y,times,1)$cdat
res&lt;-coh(dat1=artsig_x,dat2=artsig_y,times=times,norm="powall",sigmethod="fast",
nrand=100,f0=0.5,scale.max.input=28)
#use larger nrand for a real application
res&lt;-bandtest(res,c(2,4))
res&lt;-bandtest(res,c(8,12))
plotrank(res)
  
#For a wlmtest object, see vignette

</code></pre>

<hr>
<h2 id='power'>Power of a <code>tts</code> object</h2><span id='topic+power'></span><span id='topic+power.tts'></span>

<h3>Description</h3>

<p>Returns the power of a <code>tts</code> object, i.e., the mean over
time of the squared magnitude (which is a function of timescale)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power(object)

## S3 method for class 'tts'
power(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="power_+3A_object">object</code></td>
<td>
<p>A <code>tts</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>power</code> returns a data frame with columns timescales and power
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:10
timescales&lt;-1:10
values&lt;-matrix(rep(complex(modulus=1,argument=2*pi*c(0:9)/10),times=10),10,10)
ttsobj&lt;-tts(times,timescales,values)
res&lt;-power(ttsobj)
 
</code></pre>

<hr>
<h2 id='predsync'>Predicted synchrony of a wavelet linear model</h2><span id='topic+predsync'></span><span id='topic+predsync.wlm'></span>

<h3>Description</h3>

<p>Predicted synchrony of a <code>wlm</code> object. This is described in the
first paragraph of Appendix S15 of Sheppard et al (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predsync(wlmobj)

## S3 method for class 'wlm'
predsync(wlmobj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predsync_+3A_wlmobj">wlmobj</code></td>
<td>
<p>A <code>wlm</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>predsync</code> returns a <code>tts</code> object. Plotting the magnitude
(see <code>plotmag</code>) displays a picture of predicted synchrony versus time and
timescale that is comparable with the wavelet mean field (see <code>wmf</code>) of
the response variable of the model. Calling the <code>power</code> function on that 
<code>tts</code> object should give the same results as one of the columns of output
of <code>syncexpl</code>. Only <code>norm="powall"</code> implemented so far.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlm">wlm</a></code>, <code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+plotmag">plotmag</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+power">power</a></code>,
<code><a href="#topic+syncexpl">syncexpl</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-(-3:100)
ts1&lt;-sin(2*pi*times/10)
ts2&lt;-5*sin(2*pi*times/3)
artsig_x&lt;-matrix(NA,11,length(times)) #the driver
for (counter in 1:11)
{
  artsig_x[counter,]&lt;-ts1+ts2+rnorm(length(times),mean=0,sd=.5)
}
times&lt;-0:100
artsig_y&lt;-matrix(NA,11,length(times)) #the driven
for (counter1 in 1:11)
{
  for (counter2 in 1:101)
  {
    artsig_y[counter1,counter2]&lt;-mean(artsig_x[counter1,counter2:(counter2+2)])
  }
}
artsig_y&lt;-artsig_y+matrix(rnorm(length(times)*11,mean=0,sd=1),11,length(times))
artsig_x&lt;-artsig_x[,4:104]
artsig_i&lt;-matrix(rnorm(11*length(times)),11,length(times)) #the irrelevant
artsig_x&lt;-cleandat(artsig_x,times,1)$cdat
artsig_y&lt;-cleandat(artsig_y,times,1)$cdat
artsig_i&lt;-cleandat(artsig_i,times,1)$cdat
dat&lt;-list(driven=artsig_y,driver=artsig_x,irrelevant=artsig_i)
resp&lt;-1
pred&lt;-2:3
norm&lt;-"powall"
wlmobj&lt;-wlm(dat,times,resp,pred,norm)

res&lt;-predsync(wlmobj)

</code></pre>

<hr>
<h2 id='print.summary_wsyn'>Print method for <code>summary_wsyn</code> class</h2><span id='topic+print.summary_wsyn'></span>

<h3>Description</h3>

<p>Print method for <code>summary_wsyn</code> class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_wsyn'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_wsyn_+3A_x">x</code></td>
<td>
<p>A <code>summary_wsyn</code> object</p>
</td></tr>
<tr><td><code id="print.summary_wsyn_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>print.summary_wsyn</code> is called for its effect of
printing to the screen.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts_methods">tts_methods</a></code>, <code><a href="#topic+wt_methods">wt_methods</a></code>, <code><a href="#topic+wmf_methods">wmf_methods</a></code>, <code><a href="#topic+wpmf_methods">wpmf_methods</a></code>, 
<code><a href="#topic+coh_methods">coh_methods</a></code>, <code><a href="#topic+wlm_methods">wlm_methods</a></code>, <code><a href="#topic+wlmtest_methods">wlmtest_methods</a></code>, <code><a href="#topic+clust_methods">clust_methods</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:10
timescales&lt;-1/c(1:10)
values&lt;-matrix(1,length(times),length(timescales))
h&lt;-tts(times,timescales,values)
print(summary(h))

</code></pre>

<hr>
<h2 id='set_adj'>Set and get methods for classes in the <code>wsyn</code> package</h2><span id='topic+set_adj'></span><span id='topic+set_adj.default'></span><span id='topic+set_clusters'></span><span id='topic+set_clusters.default'></span><span id='topic+set_modres'></span><span id='topic+set_modres.default'></span><span id='topic+set_mns'></span><span id='topic+set_mns.default'></span><span id='topic+set_coords'></span><span id='topic+set_coords.default'></span><span id='topic+set_methodspecs'></span><span id='topic+set_methodspecs.default'></span><span id='topic+set_wmfs'></span><span id='topic+set_wmfs.default'></span><span id='topic+set_wpmfs'></span><span id='topic+set_wpmfs.default'></span><span id='topic+get_adj'></span><span id='topic+get_adj.default'></span><span id='topic+get_clusters'></span><span id='topic+get_clusters.default'></span><span id='topic+get_modres'></span><span id='topic+get_modres.default'></span><span id='topic+get_mns'></span><span id='topic+get_mns.default'></span><span id='topic+get_coords'></span><span id='topic+get_coords.default'></span><span id='topic+get_methodspec'></span><span id='topic+get_methodspec.default'></span><span id='topic+get_wmfs'></span><span id='topic+get_wmfs.default'></span><span id='topic+get_wpmfs'></span><span id='topic+get_wpmfs.default'></span><span id='topic+set_coher'></span><span id='topic+set_coher.default'></span><span id='topic+set_dat1'></span><span id='topic+set_dat1.default'></span><span id='topic+set_dat2'></span><span id='topic+set_dat2.default'></span><span id='topic+set_norm'></span><span id='topic+set_norm.default'></span><span id='topic+set_sigmethod'></span><span id='topic+set_sigmethod.default'></span><span id='topic+set_ranks'></span><span id='topic+set_ranks.default'></span><span id='topic+set_bandp'></span><span id='topic+set_bandp.default'></span><span id='topic+get_coher'></span><span id='topic+get_coher.default'></span><span id='topic+get_dat1'></span><span id='topic+get_dat1.default'></span><span id='topic+get_dat2'></span><span id='topic+get_dat2.default'></span><span id='topic+get_norm'></span><span id='topic+get_norm.default'></span><span id='topic+get_sigmethod'></span><span id='topic+get_sigmethod.default'></span><span id='topic+get_ranks'></span><span id='topic+get_ranks.default'></span><span id='topic+get_bandp'></span><span id='topic+get_bandp.default'></span><span id='topic+setget_methods'></span><span id='topic+set_times'></span><span id='topic+set_times.default'></span><span id='topic+set_timescales'></span><span id='topic+set_timescales.default'></span><span id='topic+set_values'></span><span id='topic+set_values.default'></span><span id='topic+get_times'></span><span id='topic+get_times.default'></span><span id='topic+get_timescales'></span><span id='topic+get_timescales.default'></span><span id='topic+get_values'></span><span id='topic+get_values.default'></span><span id='topic+set_coefs'></span><span id='topic+set_coefs.default'></span><span id='topic+set_modval'></span><span id='topic+set_modval.default'></span><span id='topic+set_wts'></span><span id='topic+set_wts.default'></span><span id='topic+get_coefs'></span><span id='topic+get_coefs.default'></span><span id='topic+get_modval'></span><span id='topic+get_modval.default'></span><span id='topic+get_wts'></span><span id='topic+get_wts.default'></span><span id='topic+set_wlmobj'></span><span id='topic+set_wlmobj.default'></span><span id='topic+set_drop'></span><span id='topic+set_drop.default'></span><span id='topic+get_wlmobj'></span><span id='topic+get_wlmobj.default'></span><span id='topic+get_drop'></span><span id='topic+get_drop.default'></span><span id='topic+set_signif'></span><span id='topic+set_signif.default'></span><span id='topic+get_signif'></span><span id='topic+get_signif.default'></span><span id='topic+set_dat'></span><span id='topic+set_dat.default'></span><span id='topic+set_wtopt'></span><span id='topic+set_wtopt.default'></span><span id='topic+get_dat'></span><span id='topic+get_dat.default'></span><span id='topic+get_wtopt'></span><span id='topic+get_wtopt.default'></span>

<h3>Description</h3>

<p>Set and get methods for classes in the <code>wsyn</code> package. There
are methods for each slot of each class, named <code>set_*</code> and
<code>get_*</code> for <code>*</code> the slot name. Below are listed function
specs for the generics and the default methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_adj(obj, newval)

## Default S3 method:
set_adj(obj, newval)

set_clusters(obj, newval)

## Default S3 method:
set_clusters(obj, newval)

set_modres(obj, newval)

## Default S3 method:
set_modres(obj, newval)

set_mns(obj, newval)

## Default S3 method:
set_mns(obj, newval)

set_coords(obj, newval)

## Default S3 method:
set_coords(obj, newval)

set_methodspecs(obj, newval)

## Default S3 method:
set_methodspecs(obj, newval)

set_wmfs(obj, newval)

## Default S3 method:
set_wmfs(obj, newval)

set_wpmfs(obj, newval)

## Default S3 method:
set_wpmfs(obj, newval)

get_adj(obj)

## Default S3 method:
get_adj(obj)

get_clusters(obj)

## Default S3 method:
get_clusters(obj)

get_modres(obj)

## Default S3 method:
get_modres(obj)

get_mns(obj)

## Default S3 method:
get_mns(obj)

get_coords(obj)

## Default S3 method:
get_coords(obj)

get_methodspec(obj)

## Default S3 method:
get_methodspec(obj)

get_wmfs(obj)

## Default S3 method:
get_wmfs(obj)

get_wpmfs(obj)

## Default S3 method:
get_wpmfs(obj)

set_coher(obj, newval)

## Default S3 method:
set_coher(obj, newval)

set_dat1(obj, newval)

## Default S3 method:
set_dat1(obj, newval)

set_dat2(obj, newval)

## Default S3 method:
set_dat2(obj, newval)

set_norm(obj, newval)

## Default S3 method:
set_norm(obj, newval)

set_sigmethod(obj, newval)

## Default S3 method:
set_sigmethod(obj, newval)

set_ranks(obj, newval)

## Default S3 method:
set_ranks(obj, newval)

set_bandp(obj, newval)

## Default S3 method:
set_bandp(obj, newval)

get_coher(obj)

## Default S3 method:
get_coher(obj)

get_dat1(obj)

## Default S3 method:
get_dat1(obj)

get_dat2(obj)

## Default S3 method:
get_dat2(obj)

get_norm(obj)

## Default S3 method:
get_norm(obj)

get_sigmethod(obj)

## Default S3 method:
get_sigmethod(obj)

get_ranks(obj)

## Default S3 method:
get_ranks(obj)

get_bandp(obj)

## Default S3 method:
get_bandp(obj)

set_times(obj, newval)

## Default S3 method:
set_times(obj, newval)

set_timescales(obj, newval)

## Default S3 method:
set_timescales(obj, newval)

set_values(obj, newval)

## Default S3 method:
set_values(obj, newval)

get_times(obj)

## Default S3 method:
get_times(obj)

get_timescales(obj)

## Default S3 method:
get_timescales(obj)

get_values(obj)

## Default S3 method:
get_values(obj)

set_coefs(obj, newval)

## Default S3 method:
set_coefs(obj, newval)

set_modval(obj, newval)

## Default S3 method:
set_modval(obj, newval)

set_wts(obj, newval)

## Default S3 method:
set_wts(obj, newval)

get_coefs(obj)

## Default S3 method:
get_coefs(obj)

get_modval(obj)

## Default S3 method:
get_modval(obj)

get_wts(obj)

## Default S3 method:
get_wts(obj)

set_wlmobj(obj, newval)

## Default S3 method:
set_wlmobj(obj, newval)

set_drop(obj, newval)

## Default S3 method:
set_drop(obj, newval)

get_wlmobj(obj)

## Default S3 method:
get_wlmobj(obj)

get_drop(obj)

## Default S3 method:
get_drop(obj)

set_signif(obj, newval)

## Default S3 method:
set_signif(obj, newval)

get_signif(obj)

## Default S3 method:
get_signif(obj)

set_dat(obj, newval)

## Default S3 method:
set_dat(obj, newval)

set_wtopt(obj, newval)

## Default S3 method:
set_wtopt(obj, newval)

get_dat(obj)

## Default S3 method:
get_dat(obj)

get_wtopt(obj)

## Default S3 method:
get_wtopt(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_adj_+3A_obj">obj</code></td>
<td>
<p>An object of one of the classes defined in the package</p>
</td></tr>
<tr><td><code id="set_adj_+3A_newval">newval</code></td>
<td>
<p>A newvalue of the slot in question, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are methods for the <code>tts</code>, <code>wt</code>, <code>wmf</code>,
<code>wpmf</code>, <code>coh</code>, <code>wlm</code>, <code>wlmtest</code>, and <code>clust</code>
classes. See documentation for the generator functions for these classes
(which in all cases have the same name as the class) for lists of slots
for each class.
</p>


<h3>Value</h3>

<p><code>set_*</code> methods throw an error - setting of individual
slots is not allowed, as it breaks consistency with the other slots.
<code>get_*</code> just returns the value in question.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:10
timescales&lt;-1/c(1:10)
values&lt;-matrix(1,length(times),length(timescales))
h&lt;-tts(times,timescales,values)
get_times(h)

</code></pre>

<hr>
<h2 id='setmints'>Shifts a vector according to the argument mints</h2><span id='topic+setmints'></span>

<h3>Description</h3>

<p>Shifts a vector according to the argument mints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setmints(ts, mints)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setmints_+3A_ts">ts</code></td>
<td>
<p>A vector of numeric values representing a time series</p>
</td></tr>
<tr><td><code id="setmints_+3A_mints">mints</code></td>
<td>
<p>The time series is shifted to have this minimum value. Default NA means use the smallest difference 
between consecutive, distinct sorted values of the time series. NaN means perform no shift.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setmints</code> returns the shifted vector.
</p>
<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>Note</h3>

<p>This is an internal function, and no error checking is done.
</p>

<hr>
<h2 id='surrog'>Creates surrogate time series, either Fourier surrogates or amplitude adjusted 
Fourier surrogates</h2><span id='topic+surrog'></span>

<h3>Description</h3>

<p>For significance testing wavelet coherence and other purposes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surrog(dat, nsurrogs, surrtype, syncpres)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surrog_+3A_dat">dat</code></td>
<td>
<p>A locations x time matrix of observations (for multiple-time series input), or a single vector</p>
</td></tr>
<tr><td><code id="surrog_+3A_nsurrogs">nsurrogs</code></td>
<td>
<p>The number of surrogates to produce</p>
</td></tr>
<tr><td><code id="surrog_+3A_surrtype">surrtype</code></td>
<td>
<p>Either &quot;fft&quot; (for Fourier surrogates) or &quot;aaft&quot; (for amplitude adjusted Fourier surrogates). 
Fourier surrogates are appropriate for time series with normal marginals; otherwise consider aaft surrogates.</p>
</td></tr>
<tr><td><code id="surrog_+3A_syncpres">syncpres</code></td>
<td>
<p>Logical. TRUE for &quot;synchrony preserving&quot; surrogates (same phase randomizations used for all time 
series). FALSE leads to independent phase randomizations for all time series.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fourier surrogates are somewhat faster than <code>aaft</code> surrogates, and may be much faster when 
some of the time series in the data have ties. Prenormalization (e.g., using <code>cleandat</code>) can 
make it possible to use <code>fft</code> surrogates.
</p>


<h3>Value</h3>

<p><code>surrog</code> returns a list of nsurrogs surrogate datasets
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; 
Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW, et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid pests. Nature Climate 
Change. DOI: 10.1038/nclimate2881
</p>
<p>Schreiber, T and Schmitz, A (2000) Surrogate time series. Physica D 142, 346-382.
</p>
<p>Prichard, D and Theiler, J (1994) Generating surrogate data for time series with several simultaneously measured 
variables. Physical Review Letters 73, 951-954.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpmf">wpmf</a></code>, <code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+synmat">synmat</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:100
dat&lt;-sin(2*pi*times/10)
nsurrogs&lt;-10
surrtype&lt;-"fft"
syncpres&lt;-TRUE
res&lt;-surrog(dat,nsurrogs,surrtype,syncpres)

</code></pre>

<hr>
<h2 id='syncexpl'>Amount of synchrony explained, and related quantities</h2><span id='topic+syncexpl'></span><span id='topic+syncexpl.wlm'></span>

<h3>Description</h3>

<p>Gives amount of synchrony explained by a wavelet linear model, as a function of 
timescale, and related quantities (see details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>syncexpl(object)

## S3 method for class 'wlm'
syncexpl(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="syncexpl_+3A_object">object</code></td>
<td>
<p>A <code>wlm</code> object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only works for <code>norm="powall"</code> at present. See
Sheppard et al (2018) for details of the meaning and computation of the 
columns.
</p>


<h3>Value</h3>

<p><code>syncexpl</code> returns a data frame with columns for <code>timescales</code>,
<code>sync</code> (the time-averaged square magnitude of the wavelet mean field of the
response transforms), <code>syncexpl</code> (synchrony explained by the model 
predictors), columns named for each predictor (synchrony explained by that 
predictor), <code>interactions</code> (synchrony explained by all interaction effects),
columns named for each pair of predictors (synchrony explained by individual
pairwise interactions). There are also columns for <code>crossterms</code> and 
<code>resids</code> (residuals). The cross terms must be small for a given timescale band for
the other results to be meaningful. All columns are functions of timescales.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlm">wlm</a></code>, <code><a href="#topic+predsync">predsync</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-(-3:100)
ts1&lt;-sin(2*pi*times/10)
ts2&lt;-5*sin(2*pi*times/3)
artsig_x&lt;-matrix(NA,11,length(times)) #the driver
for (counter in 1:11)
{
  artsig_x[counter,]=ts1+ts2+rnorm(length(times),mean=0,sd=1.5)
}
times&lt;-0:100
artsig_y&lt;-matrix(NA,11,length(times)) #the driven
for (counter1 in 1:11)
{
  for (counter2 in 1:101)
  {
    artsig_y[counter1,counter2]&lt;-mean(artsig_x[counter1,counter2:(counter2+2)])
  }
}
artsig_y&lt;-artsig_y+matrix(rnorm(length(times)*11,mean=0,sd=3),11,length(times))
artsig_x&lt;-artsig_x[,4:104]
artsig_i&lt;-matrix(rnorm(11*length(times)),11,length(times)) #the irrelevant
artsig_x&lt;-cleandat(artsig_x,times,1)$cdat
artsig_y&lt;-cleandat(artsig_y,times,1)$cdat
artsig_i&lt;-cleandat(artsig_i,times,1)$cdat

dat&lt;-list(driven=artsig_y,driver=artsig_x,irrelevant=artsig_i)
resp&lt;-1
pred&lt;-2:3
norm&lt;-"powall"
wlmobj&lt;-wlm(dat,times,resp,pred,norm)

res&lt;-syncexpl(wlmobj)
 
</code></pre>

<hr>
<h2 id='synmat'>Synchrony matrices</h2><span id='topic+synmat'></span>

<h3>Description</h3>

<p>Calculate synchrony matrices using a variety of methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>synmat(
  dat,
  times,
  method,
  tsrange = c(0, Inf),
  nsurrogs = 1000,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1,
  weighted = TRUE,
  sigthresh = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="synmat_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix of measurements</p>
</td></tr>
<tr><td><code id="synmat_+3A_times">times</code></td>
<td>
<p>The times at which measurements were made, spacing 1</p>
</td></tr>
<tr><td><code id="synmat_+3A_method">method</code></td>
<td>
<p>Method for synchrony calculation. See details.</p>
</td></tr>
<tr><td><code id="synmat_+3A_tsrange">tsrange</code></td>
<td>
<p>A vector containing the min and max of the focal timescale range. Defaults 
to all timescales that are valid given choices for scale.min, scale.max.input, f0, sigma.
Only used for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_nsurrogs">nsurrogs</code></td>
<td>
<p>Number of surrogates for significance test. Defaults to 1000. Only used
for surrogate-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2. Used 
only for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined. Only used 
for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be 
greater than 1. Only used for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope. Only used for 
wavelet-based methods.</p>
</td></tr>
<tr><td><code id="synmat_+3A_weighted">weighted</code></td>
<td>
<p>If <code>TRUE</code>, create a weighted network. If <code>FALSE</code>, create a binary 
network using statistical significance. Binary networks are only allowed for networks based
on significance.</p>
</td></tr>
<tr><td><code id="synmat_+3A_sigthresh">sigthresh</code></td>
<td>
<p>Significance threshold needed, if <code>weighted</code> is false, for a network
link to be realized. Typically 0.95, 0.99, or 0.999, etc. Only used if <code>weighted</code> is
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following values are valid for <code>method</code>: 
<code>"pearson"</code>, <code>"pearson.sig.std"</code>, <code>"pearson.sig.fft"</code>, 
<code>"pearson.sig.aaft"</code>, 
<code>"spearman"</code>, <code>"spearman.sig.std"</code>, <code>"spearman.sig.fft"</code>, 
<code>"spearman.sig.aaft"</code>, 
<code>"kendall"</code>, <code>"kendall.sig.std"</code>, <code>"kendall.sig.fft"</code>, 
<code>"kendall.sig.aaft"</code>, 
<code>"ReXWT"</code>, <code>"ReXWT.sig.fft"</code>, <code>"ReXWT.sig.aaft"</code>, <code>"ReXWT.sig.fast"</code>, 
<code>"coh"</code>, <code>"coh.sig.fft"</code>, <code>"coh.sig.aaft"</code>, <code>"coh.sig.fast"</code>,
<code>"phasecoh"</code>, <code>"phasecoh.sig.fft"</code>, and <code>"phasecoh.sig.aaft"</code>.
The first portions of these identifiers correspond to the Pearson, Spearman, and Kendall 
correlations, the real part of the cross-wavelet transform, the wavelet coherence, and the 
wavelet phase coherence. The second portions of these identifiers, when present, indicates
that significance of the measure specified in the first portion of the identifies is to
be used for establishing the synchrony matrix. Otherwise the value itself is used. The
third part of the <code>method</code> identifier indicates what type of significance is used.
</p>
<p>Significance testing is performed using standard approaches (<code>method</code> flag containg
<code>std</code>; for correlation coefficients, 
although these are inappropriate for autocorrelated data), or surrogates generated using the 
Fourier (<code>method</code> flag containing <code>"fft"</code>) or amplitude adjusted Fourier 
surrogates (<code>"aaft"</code>). For 
<code>"coh"</code> and <code>"ReXWT"</code>, the fast testing algorithm of Sheppard et al. (2017) is also
implemented (<code>"fast"</code>). That method uses implicit Fourier surrogates. The choice of 
wavelet coherence (method flag containing <code>"coh"</code>) or the real part of 
the cross-wavelet 
transform (method flag containing <code>"ReXWT"</code>) depends mainly 
on treatment of out-of-phase 
relationships. The <code>"ReXWT"</code> is more akin to a correlation coefficient in that 
strong in-phase relationships approach 1 and strong antiphase relationships approach -1. 
Wavelet coherence allows any phase relationship and ranges from 0 to 1. Power normalization
is applied for <code>"coh"</code> and for <code>"ReXWT"</code>. All significance tests are one-tailed. 
Synchrony matrices for significance-based methods when <code>weighted</code> is <code>TRUE</code> 
contain 1 minus the p-values.
</p>


<h3>Value</h3>

<p><code>synmat</code> returns a synchrony matrix, of type depending on the <code>method</code>
argument. See details. Diagonal entries are left as <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>;
Lei Zhao, <a href="mailto:lei.zhao@cau.edu.cn">lei.zhao@cau.edu.cn</a>
</p>


<h3>References</h3>

<p>Walter, J. A., et al. (2017) The geography of spatial synchrony. Ecology 
Letters. doi: 10.1111/ele.12782
</p>


<h3>See Also</h3>

<p><code><a href="#topic+clust">clust</a></code>, <code><a href="#topic+coh">coh</a></code>, <code><a href="#topic+surrog">surrog</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sig&lt;-matrix(.9,5,5)
diag(sig)&lt;-1
if (requireNamespace("mvtnorm",quietly=TRUE))
{
  dat1&lt;-t(mvtnorm::rmvnorm(30,mean=rep(0,5),sigma=sig))
  dat2&lt;-t(mvtnorm::rmvnorm(30,mean=rep(0,5),sigma=sig))
}else
{
  dat1&lt;-t(matrix(rep(rnorm(30),times=5),30,5))
  dat2&lt;-t(matrix(rep(rnorm(30),times=5),30,5))
}
dat&lt;-rbind(dat1,dat2)
times&lt;-1:30
dat&lt;-cleandat(dat,times,clev=2)$cdat
method&lt;-"pearson.sig.fft"
res&lt;-synmat(dat,times,method,nsurrogs=100,weighted=FALSE,
            sigthresh=0.95)
  
</code></pre>

<hr>
<h2 id='tts'>Creator function for the <code>tts</code> class</h2><span id='topic+tts'></span>

<h3>Description</h3>

<p>The <code>tts</code> (time/timescale) class is for matrices for which the rows correspond 
to times and the columns correspond to timescales. This is a general class from 
which other classes inherit (e.g., <code>wt</code>, <code>wmf</code>, <code>wpmf</code>). <code>tts</code> 
inherits from the <code>list</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tts(times, timescales, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tts_+3A_times">times</code></td>
<td>
<p>A numeric vector of increasing real values, spacing 1</p>
</td></tr>
<tr><td><code id="tts_+3A_timescales">timescales</code></td>
<td>
<p>A numeric vector with positive entries</p>
</td></tr>
<tr><td><code id="tts_+3A_values">values</code></td>
<td>
<p>A complex or numeric matrix of dimensions <code>length(times)</code> by 
<code>length(timescales)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>tts</code> returns an object of class <code>tts</code>. Slots are: 
</p>
<table>
<tr><td><code>times</code></td>
<td>
<p>a numeric vector of evenly spaced times</p>
</td></tr> 
<tr><td><code>timescales</code></td>
<td>
<p>a numeric vector of positive timescales</p>
</td></tr>
<tr><td><code>values</code></td>
<td>
<p>a complex or numeric matrix of dimensions <code>length(times)</code> by <code>length(timescales)</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts_methods">tts_methods</a></code>, <code><a href="#topic+wt">wt</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:10
timescales&lt;-1/c(1:10)
values&lt;-matrix(1,length(times),length(timescales))
h&lt;-tts(times,timescales,values)

</code></pre>

<hr>
<h2 id='tts_methods'>Basic methods for the <code>tts</code> class</h2><span id='topic+tts_methods'></span><span id='topic+summary.tts'></span><span id='topic+print.tts'></span><span id='topic+set_times.tts'></span><span id='topic+set_timescales.tts'></span><span id='topic+set_values.tts'></span><span id='topic+get_times.tts'></span><span id='topic+get_timescales.tts'></span><span id='topic+get_values.tts'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>tts</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tts'
summary(object, ...)

## S3 method for class 'tts'
print(x, ...)

## S3 method for class 'tts'
set_times(obj, newval)

## S3 method for class 'tts'
set_timescales(obj, newval)

## S3 method for class 'tts'
set_values(obj, newval)

## S3 method for class 'tts'
get_times(obj)

## S3 method for class 'tts'
get_timescales(obj)

## S3 method for class 'tts'
get_values(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tts_methods_+3A_object">object</code>, <code id="tts_methods_+3A_x">x</code>, <code id="tts_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>tts</code></p>
</td></tr>
<tr><td><code id="tts_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="tts_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.tts</code> produces a summary of a <code>tts</code> object.
A <code>print.tts</code> method is also available. For <code>tts</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots,
i.e., <code>*</code> equal to <code>times</code>, <code>timescales</code>, and 
<code>values</code>. The <code>set_*</code> methods just throw an error. Although
class <code>tts</code> is flexible enough that setting of individual slots
could have been allowed, because <code>wt</code> and other classes are 
based on it and because individual slots of those classes should not 
be changed, for consistency the same is forced for the <code>tts</code> 
class.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tts">tts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:10
timescales&lt;-1/c(1:10)
values&lt;-matrix(1,length(times),length(timescales))
h&lt;-tts(times,timescales,values)
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='warray'>Creates an array of wavelet transforms from input timeseries</h2><span id='topic+warray'></span>

<h3>Description</h3>

<p>Creates an array of wavelet transforms from input timeseries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>warray(dat, times, scale.min = 2, scale.max.input = NULL, sigma = 1.05, f0 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="warray_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix</p>
</td></tr>
<tr><td><code id="warray_+3A_times">times</code></td>
<td>
<p>A vector of timestep values (e.g. years), spacing 1</p>
</td></tr>
<tr><td><code id="warray_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="warray_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation that will be examined. Note that if this is set too high 
relative to the length of the timeseries it will be truncated.</p>
</td></tr>
<tr><td><code id="warray_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Greater than 1.</p>
</td></tr>
<tr><td><code id="warray_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>warray</code> returns a list containing: 
</p>
<table>
<tr><td><code>wavarray</code></td>
<td>
<p>locations x time x timescales array of wavelet transforms</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>the time steps specified (e.g., years)</p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>the timescales (1/frequency) computed for the wavelet transforms</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Important for interpreting the phase: the phases grow through time, i.e., they 
turn anti-clockwise. This function is internal, no error checking.
</p>


<h3>Author(s)</h3>

<p>Lauren Hallett, <a href="mailto:hallett@uoregon.edu">hallett@uoregon.edu</a>; Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>;
Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='wavmatwork'>Facilitates the computations in synmat for coherence and ReXWT methods</h2><span id='topic+wavmatwork'></span>

<h3>Description</h3>

<p>Worker/utility function serving the analysis carried out in synmat for methods based
on coherence or real part of the cross-wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wavmatwork(dat, times, scale.min, scale.max.input, sigma, f0, norm, treatment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wavmatwork_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix of measurements</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_times">times</code></td>
<td>
<p>The times at which measurements were made, spacing 1</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2. Used 
only for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined. Only used 
for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be 
greater than 1. Only used for wavelet-based methods.</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope. Only used for 
wavelet-based methods.</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_norm">norm</code></td>
<td>
<p>The normalization of wavelet transforms to be used. One of &quot;none&quot;, &quot;phase&quot;, 
&quot;powind&quot;.</p>
</td></tr>
<tr><td><code id="wavmatwork_+3A_treatment">treatment</code></td>
<td>
<p>Either &quot;Mod&quot; or &quot;Re&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wavmatwork</code> returns a list consisting of:
</p>
<table>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales of analysis</p>
</td></tr> 
<tr><td><code>wavarray</code></td>
<td>
<p>An array, locations by locations by timescales, containing either the 
coherences (for <code>treatment="Mod"</code>) or the real parts of the cross-wavelet transforms
(for <code>treatment="Re"</code>) between locations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Internal function, no error checking done.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>

<hr>
<h2 id='wlm'>Wavelet linear models</h2><span id='topic+wlm'></span>

<h3>Description</h3>

<p>Fits wavelet linear models. Also the generator function of the <code>wlm</code> class, which
inherits from the <code>list</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlm(
  dat,
  times,
  resp,
  pred,
  norm,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlm_+3A_dat">dat</code></td>
<td>
<p>A list of matrices representing the data (or in the case of one location, a list of
vectors). All the same dimensions (respectively, lengths)</p>
</td></tr>
<tr><td><code id="wlm_+3A_times">times</code></td>
<td>
<p>The times at which measurements were made, spacing 1</p>
</td></tr>
<tr><td><code id="wlm_+3A_resp">resp</code></td>
<td>
<p>Index in dat for the response variable of the model</p>
</td></tr>
<tr><td><code id="wlm_+3A_pred">pred</code></td>
<td>
<p>Vector of indices in dat for the predictor variables of the model; must differ from <code>resp</code></p>
</td></tr>
<tr><td><code id="wlm_+3A_norm">norm</code></td>
<td>
<p>The normalization of wavelet transforms to use. One of &quot;none&quot;, &quot;powall&quot;, &quot;powind&quot;. See details.</p>
</td></tr>
<tr><td><code id="wlm_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="wlm_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation that will be examined. Note that if this is set too high relative to the length of the timeseries it will be truncated.</p>
</td></tr>
<tr><td><code id="wlm_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Greater than 1.</p>
</td></tr>
<tr><td><code id="wlm_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalization is as specified in the documentation for <code>coh</code>, HOWEVER, only
the &quot;<code>powall</code>&quot; option is currently implemented, other choices throw an error. Details 
are specified in appendices S7 and S9 of Sheppard et al, 2018. The output <code>modval</code>
is v in appendix S7, and <code>coefs</code> are the betas in equation 12 in that appendix.
</p>


<h3>Value</h3>

<p><code>wlm</code> returns an object of class <code>wlm</code>. Slots are:
</p>
<table>
<tr><td><code>dat</code></td>
<td>
<p>The input data list, but reordered and subsetted so the response is first and only used predictors are included</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The times associated with the data</p>
</td></tr>
<tr><td><code>norm</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>wtopt</code></td>
<td>
<p>The inputted wavelet transform options scale.min, scale.max.input, sigma, f0 in a list</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>List of transforms, normalized as specified in <code>norm</code>. Same length as the output <code>dat</code>, each entry a locations x time x timescales array of transforms.</p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales associated with the wavelet transforms of the data</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>A list (data frame, actually) of complex vectors, each of length the same 
as <code>timescales</code>. These are the model coefficients (which depend on timescale), and 
correspond to the <code>wts</code>.</p>
</td></tr>
<tr><td><code>modval</code></td>
<td>
<p>The model values.</p>
</td></tr>
<tr><td><code>coher</code></td>
<td>
<p>Appropriately normalized version of coherence of the model and response transforms. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlm_methods">wlm_methods</a></code>, <code><a href="#topic+wlmtest">wlmtest</a></code>, <code><a href="#topic+syncexpl">syncexpl</a></code>, <code><a href="#topic+predsync">predsync</a></code>, 
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30
dat&lt;-list(v1=matrix(rnorm(300),10,30),v2=matrix(rnorm(300),10,30),v3=matrix(rnorm(300),10,30),
          v4=matrix(rnorm(300),10,30),v5=matrix(rnorm(300),10,30))
dat&lt;-lapply(FUN=function(x){cleandat(x,times,1)$cdat},X=dat)
resp&lt;-2
pred&lt;-c(1,3,4)
norm&lt;-"powall"
res&lt;-wlm(dat,times,resp,pred,norm)

</code></pre>

<hr>
<h2 id='wlm_methods'>Basic methods for the <code>wlm</code> class</h2><span id='topic+wlm_methods'></span><span id='topic+summary.wlm'></span><span id='topic+print.wlm'></span><span id='topic+set_times.wlm'></span><span id='topic+set_timescales.wlm'></span><span id='topic+set_coefs.wlm'></span><span id='topic+set_modval.wlm'></span><span id='topic+set_coher.wlm'></span><span id='topic+set_dat.wlm'></span><span id='topic+set_wtopt.wlm'></span><span id='topic+set_norm.wlm'></span><span id='topic+set_wts.wlm'></span><span id='topic+get_times.wlm'></span><span id='topic+get_timescales.wlm'></span><span id='topic+get_coefs.wlm'></span><span id='topic+get_modval.wlm'></span><span id='topic+get_coher.wlm'></span><span id='topic+get_dat.wlm'></span><span id='topic+get_wtopt.wlm'></span><span id='topic+get_norm.wlm'></span><span id='topic+get_wts.wlm'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>wlm</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wlm'
summary(object, ...)

## S3 method for class 'wlm'
print(x, ...)

## S3 method for class 'wlm'
set_times(obj, newval)

## S3 method for class 'wlm'
set_timescales(obj, newval)

## S3 method for class 'wlm'
set_coefs(obj, newval)

## S3 method for class 'wlm'
set_modval(obj, newval)

## S3 method for class 'wlm'
set_coher(obj, newval)

## S3 method for class 'wlm'
set_dat(obj, newval)

## S3 method for class 'wlm'
set_wtopt(obj, newval)

## S3 method for class 'wlm'
set_norm(obj, newval)

## S3 method for class 'wlm'
set_wts(obj, newval)

## S3 method for class 'wlm'
get_times(obj)

## S3 method for class 'wlm'
get_timescales(obj)

## S3 method for class 'wlm'
get_coefs(obj)

## S3 method for class 'wlm'
get_modval(obj)

## S3 method for class 'wlm'
get_coher(obj)

## S3 method for class 'wlm'
get_dat(obj)

## S3 method for class 'wlm'
get_wtopt(obj)

## S3 method for class 'wlm'
get_norm(obj)

## S3 method for class 'wlm'
get_wts(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlm_methods_+3A_object">object</code>, <code id="wlm_methods_+3A_x">x</code>, <code id="wlm_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>wlm</code></p>
</td></tr>
<tr><td><code id="wlm_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="wlm_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.wlm</code> produces a summary of a <code>wlm</code> object.
A <code>print.wlm</code> method is also available. For <code>wlm</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots (see
the documentation for <code>wlm</code> for a list). The <code>set_*</code> methods 
just throw an error, to prevent breaking the consistency between the 
slots of a <code>wlm</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlm">wlm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30
dat&lt;-list(v1=matrix(rnorm(300),10,30),v2=matrix(rnorm(300),10,30),v3=matrix(rnorm(300),10,30),
          v4=matrix(rnorm(300),10,30),v5=matrix(rnorm(300),10,30))
dat&lt;-lapply(FUN=function(x){cleandat(x,times,1)$cdat},X=dat)
resp&lt;-2
pred&lt;-c(1,3,4)
norm&lt;-"powall"
h&lt;-wlm(dat,times,resp,pred,norm)
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='wlmfit'>Fits a wavelet linear model</h2><span id='topic+wlmfit'></span>

<h3>Description</h3>

<p>Stripped down internal function for doing the fitting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlmfit(wts, norm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlmfit_+3A_wts">wts</code></td>
<td>
<p>List of normalized transforms, normalized as specified in <code>norm</code>. Each entry a locations x time x timescales array of transforms. The first is the response variable, others are the predictors.</p>
</td></tr>
<tr><td><code id="wlmfit_+3A_norm">norm</code></td>
<td>
<p>The normalization that was used. One of &quot;none&quot;, &quot;powall&quot;, &quot;powind&quot;. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only <code>norm="powall"</code> works now, other options throw an error.
</p>


<h3>Value</h3>

<p><code>wlmfit</code> returns a list with these elements:
</p>
<table>
<tr><td><code>coefs</code></td>
<td>
<p>Model coefficients</p>
</td></tr>
<tr><td><code>modval</code></td>
<td>
<p>The right had side of the model</p>
</td></tr>
<tr><td><code>coher</code></td>
<td>
<p>Appropriately normalized coherence of the model and response variable</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Internal function, no error checking done.
</p>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>

<hr>
<h2 id='wlmtest'>Statistical comparison of wavelet linear models</h2><span id='topic+wlmtest'></span>

<h3>Description</h3>

<p>Compares a wavelet linear model with a nested model. Also the generator function for 
the <code>wlmtest</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wlmtest(wlmobj, drop, sigmethod, nrand = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlmtest_+3A_wlmobj">wlmobj</code></td>
<td>
<p>A <code>wlm</code> object</p>
</td></tr>
<tr><td><code id="wlmtest_+3A_drop">drop</code></td>
<td>
<p>Either names or indices of variables in <code>wlmobj$dat</code> that are being 
dropped to form the simpler, nested model. The first variable in <code>wlmobj$dat</code>, 
which is the response, is not allowed here.</p>
</td></tr>
<tr><td><code id="wlmtest_+3A_sigmethod">sigmethod</code></td>
<td>
<p>Method for significance testing. One of &quot;<code>fft</code>&quot;, &quot;<code>aaft</code>&quot;, &quot;<code>fast</code>&quot;. See details.</p>
</td></tr>
<tr><td><code id="wlmtest_+3A_nrand">nrand</code></td>
<td>
<p>The number of randomizations to do for significance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The slot <code>signif</code> provides the core information on significance. 
If <code>sigmethod</code> is not &quot;<code>fast</code>&quot;, then <code>signif$coher</code> is the same as 
<code>wlmobj$coher</code>, and <code>signif$scoher</code> is a matrix of dimensions <code>nrand</code> by 
<code>length(signif$coher)</code> with rows equal to coherences between refitted models and the 
response-variable transforms, for datasets where the variables specified in <code>drop</code> have
been replaced by surrogates. Normalization as specified in <code>norm</code> is used. The type 
of surrogate used (Fourier surrogates or amplitude adjusted Fourier surrogates, see 
<code>surrog</code>) is determined by <code>sigmethod</code> (&quot;<code>fft</code>&quot; or &quot;<code>aaft</code>&quot;). 
Synchrony-preserving surrogates are used. A variety of statements of significance (or lack 
thereof) can be made by comparing <code>signif$coher</code> with <code>signif$scoher</code> (see the 
<code>plotmag</code>, <code>plotrank</code>, and <code>bandtest</code> methods
for the <code>wlmtest</code> class). If <code>sigmethod</code> is 
&quot;<code>fast</code>&quot;, a fast algorithm of Lawrence Sheppard is used which is a generalization 
to wavelet linear models of the fast algorithm for coherence described in Sheppard et al (2017). 
In that case
<code>signif$coher</code> can be compared to <code>signif$scoher</code> to make significance 
statements about the coherence in exactly the same way, but <code>signif$coher</code> will no
longer precisely equal <code>wlmobj$coher</code>, and <code>wlmobj$coher</code> should not be compared 
directly to <code>signif$scoher</code>. Statements about significance of the coherence 
should be made using <code>signif$coher</code> and <code>signif$scoher</code>, whereas <code>wlmobj$coher</code>
should be used whenever the actual value of the coherence is needed. 
</p>
<p>The slots <code>ranks</code> and <code>bandp</code> are empty on an initial call to <code>wlmtest</code>. 
They are made to compute and hold 
aggregate significance results over any timescale band of choice. These are filled in
when needed by other methods, see <code>plotrank</code> and <code>bandtest</code>.
</p>


<h3>Value</h3>

<p><code>wlmtest</code> returns an object of class <code>wlmtest</code>. Slots are:
</p>
<table>
<tr><td><code>wlmobj</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>drop</code></td>
<td>
<p>The input</p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>A list with information from the significance testing. Elements are 
<code>sigmethod</code> (the input), <code>coher</code> and <code>scoher</code>. See details.</p>
</td></tr>
<tr><td><code>ranks</code></td>
<td>
<p>A list with ranking information for <code>signif</code>. <code>NA</code> until 
<code>plotrank</code> or <code>bandtest</code> is called.</p>
</td></tr>
<tr><td><code>bandp</code></td>
<td>
<p>A data frame containing results of computing significances across 
timescale bands. Empty on an initial call to <code>wlmtest</code>, filled in by the function 
<code>bandtest</code>. See details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>
<p>Sheppard, L.W., et al. (2017) Rapid surrogate testing of wavelet coherences. European Physical 
Journal, Nonlinear and Biomedical Physics, 5, 1. DOI: 10.1051/epjnbp/2017000
</p>
<p>Sheppard, LW et al. (2019) Synchrony is more than its top-down and climatic parts: interacting 
Moran effects on phytoplankton in British seas. Plos Computational Biology 15, e1006744. doi: 10.1371/journal.pcbi.1006744
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlm">wlm</a></code>, <code><a href="#topic+plotrank">plotrank</a></code>, <code><a href="#topic+bandtest">bandtest</a></code>, <code><a href="#topic+coh">coh</a></code>, 
<code><a href="#topic+wlmtest_methods">wlmtest_methods</a></code>, <code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30
dat&lt;-list(v1=matrix(rnorm(300),10,30),v2=matrix(rnorm(300),10,30),v3=matrix(rnorm(300),10,30),
          v4=matrix(rnorm(300),10,30),v5=matrix(rnorm(300),10,30))
dat&lt;-lapply(FUN=function(x){cleandat(x,times,1)$cdat},X=dat)
resp&lt;-1
pred&lt;-2:3
norm&lt;-"powall"
wlmobj&lt;-wlm(dat,times,resp,pred,norm)
drop&lt;-3
sigmethod&lt;-"fft"
res&lt;-wlmtest(wlmobj,drop,sigmethod,nrand=10)

</code></pre>

<hr>
<h2 id='wlmtest_methods'>Basic methods for the <code>wlmtest</code> class</h2><span id='topic+wlmtest_methods'></span><span id='topic+summary.wlmtest'></span><span id='topic+print.wlmtest'></span><span id='topic+set_wlmobj.wlmtest'></span><span id='topic+set_drop.wlmtest'></span><span id='topic+set_signif.wlmtest'></span><span id='topic+set_ranks.wlmtest'></span><span id='topic+set_bandp.wlmtest'></span><span id='topic+get_wlmobj.wlmtest'></span><span id='topic+get_drop.wlmtest'></span><span id='topic+get_signif.wlmtest'></span><span id='topic+get_ranks.wlmtest'></span><span id='topic+get_bandp.wlmtest'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>wlmtest</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wlmtest'
summary(object, ...)

## S3 method for class 'wlmtest'
print(x, ...)

## S3 method for class 'wlmtest'
set_wlmobj(obj, newval)

## S3 method for class 'wlmtest'
set_drop(obj, newval)

## S3 method for class 'wlmtest'
set_signif(obj, newval)

## S3 method for class 'wlmtest'
set_ranks(obj, newval)

## S3 method for class 'wlmtest'
set_bandp(obj, newval)

## S3 method for class 'wlmtest'
get_wlmobj(obj)

## S3 method for class 'wlmtest'
get_drop(obj)

## S3 method for class 'wlmtest'
get_signif(obj)

## S3 method for class 'wlmtest'
get_ranks(obj)

## S3 method for class 'wlmtest'
get_bandp(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wlmtest_methods_+3A_object">object</code>, <code id="wlmtest_methods_+3A_x">x</code>, <code id="wlmtest_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>wlmtest</code></p>
</td></tr>
<tr><td><code id="wlmtest_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="wlmtest_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.wlmtest</code> produces a summary of a <code>wlmtest</code> object.
A <code>print.wlmtest</code> method is also available. For <code>wlmtest</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots (see
the documentation for <code>wlmtest</code> for a list). The <code>set_*</code> methods 
just throw an error, to prevent breaking the consistency between the 
slots of a <code>wlmtest</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wlmtest">wlmtest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30
dat&lt;-list(v1=matrix(rnorm(300),10,30),v2=matrix(rnorm(300),10,30),v3=matrix(rnorm(300),10,30),
          v4=matrix(rnorm(300),10,30),v5=matrix(rnorm(300),10,30))
dat&lt;-lapply(FUN=function(x){cleandat(x,times,1)$cdat},X=dat)
resp&lt;-1
pred&lt;-2:3
norm&lt;-"powall"
wlmobj&lt;-wlm(dat,times,resp,pred,norm)
drop&lt;-3
sigmethod&lt;-"fft"
h&lt;-wlmtest(wlmobj,drop,sigmethod,nrand=10)
get_times(get_wlmobj(h))
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='wmf'>Computes the wavelet mean field from a matrix of spatiotemporal data. Also the
creator function for the <code>wmf</code> class.</h2><span id='topic+wmf'></span>

<h3>Description</h3>

<p>Computes the wavelet mean field from a matrix of spatiotemporal data. Also the
creator function for the <code>wmf</code> class. The <code>wmf</code> class inherits from the 
<code>tts</code> class, which inherits from the <code>list</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmf(dat, times, scale.min = 2, scale.max.input = NULL, sigma = 1.05, f0 = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmf_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix</p>
</td></tr>
<tr><td><code id="wmf_+3A_times">times</code></td>
<td>
<p>A vector of time step values (e.g., years), spacing 1</p>
</td></tr>
<tr><td><code id="wmf_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="wmf_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation that will be examined. Note that if this is set too high relative to the length of the timeseries it will be truncated.</p>
</td></tr>
<tr><td><code id="wmf_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Greater than 1.</p>
</td></tr>
<tr><td><code id="wmf_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wmf</code> returns an object of class <code>wmf</code>. Slots are:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>A matrix of complex numbers containing the wavelet mean field, of dimensions <code>length(times)</code> 
by the number of timescales. Entries not considered reliable (longer timescales, near the edges of the time span) 
are set to NA.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The time steps specified (e.g., years)</p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales (1/frequency) computed for the wavelet transforms</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>The data matrix (locations by time) from which the wmf was computed</p>
</td></tr>
<tr><td><code>wtopt</code></td>
<td>
<p>The inputted wavelet transform options scale.min, scale.max.input, sigma, f0 in a list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; 
Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid pests. 
Nature Climate Change. DOI: 10.1038/nclimate2881
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wmf_methods">wmf_methods</a></code>, <code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+wpmf">wpmf</a></code>, <code><a href="#topic+plotmag">plotmag</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30 #generate time steps
#generate fake count data for 20 locations
dat&lt;-matrix(rpois(20*length(times),20),nrow=20,ncol=length(times)) 
dat&lt;-cleandat(dat=dat,times=times,clev=2)$cdat #detrend and demean
wmf&lt;-wmf(dat,times)

</code></pre>

<hr>
<h2 id='wmf_methods'>Basic methods for the <code>wmf</code> class</h2><span id='topic+wmf_methods'></span><span id='topic+summary.wmf'></span><span id='topic+print.wmf'></span><span id='topic+set_times.wmf'></span><span id='topic+set_timescales.wmf'></span><span id='topic+set_values.wmf'></span><span id='topic+set_dat.wmf'></span><span id='topic+set_wtopt.wmf'></span><span id='topic+get_times.wmf'></span><span id='topic+get_timescales.wmf'></span><span id='topic+get_values.wmf'></span><span id='topic+get_dat.wmf'></span><span id='topic+get_wtopt.wmf'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>wmf</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wmf'
summary(object, ...)

## S3 method for class 'wmf'
print(x, ...)

## S3 method for class 'wmf'
set_times(obj, newval)

## S3 method for class 'wmf'
set_timescales(obj, newval)

## S3 method for class 'wmf'
set_values(obj, newval)

## S3 method for class 'wmf'
set_dat(obj, newval)

## S3 method for class 'wmf'
set_wtopt(obj, newval)

## S3 method for class 'wmf'
get_times(obj)

## S3 method for class 'wmf'
get_timescales(obj)

## S3 method for class 'wmf'
get_values(obj)

## S3 method for class 'wmf'
get_dat(obj)

## S3 method for class 'wmf'
get_wtopt(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmf_methods_+3A_object">object</code>, <code id="wmf_methods_+3A_x">x</code>, <code id="wmf_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>wmf</code></p>
</td></tr>
<tr><td><code id="wmf_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="wmf_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.wmf</code> produces a summary of a <code>wmf</code> object.
A <code>print.wmf</code> method is also available. For <code>wmf</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots,
i.e., <code>*</code> equal to <code>times</code>, <code>timescales</code>, <code>wtopt</code>, 
<code>values</code>, and <code>dat</code>. The <code>set_*</code> methods just throw an 
error, to prevent breaking the consistency between the slots of a 
<code>wmf</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wmf">wmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30 #generate time steps
#generate fake count data for 20 locations
dat&lt;-matrix(rpois(20*length(times),20),nrow=20,ncol=length(times)) 
dat&lt;-cleandat(dat=dat,times=times,clev=2)$cdat #detrend and demean
h&lt;-wmf(dat,times)
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='wpmf'>Wavelet phasor mean field</h2><span id='topic+wpmf'></span>

<h3>Description</h3>

<p>Computes the wavelet phasor mean field from a matrix of spatiotemporal data. Also the
creator function for the <code>wpmf</code> class. The <code>wpmf</code> class inherits from the 
<code>tts</code> class, which inherits from the <code>list</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wpmf(
  dat,
  times,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1,
  sigmethod = "none",
  nrand = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpmf_+3A_dat">dat</code></td>
<td>
<p>A locations (rows) x time (columns) matrix</p>
</td></tr>
<tr><td><code id="wpmf_+3A_times">times</code></td>
<td>
<p>A vector of time step values, spacing 1</p>
</td></tr>
<tr><td><code id="wpmf_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="wpmf_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation guaranteed to be examined</p>
</td></tr>
<tr><td><code id="wpmf_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be greater than 1.</p>
</td></tr>
<tr><td><code id="wpmf_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelop</p>
</td></tr>
<tr><td><code id="wpmf_+3A_sigmethod">sigmethod</code></td>
<td>
<p>Method for significance testing the wmpf, one of <code>quick</code>, <code>fft</code>, <code>aaft</code> (see details)</p>
</td></tr>
<tr><td><code id="wpmf_+3A_nrand">nrand</code></td>
<td>
<p>The number of randomizations to be used for significance testing</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>sigmethod</code> equal to <code>quick</code>, the empirical wpmf is compared to a distribution of 
magnitudes of sums of random phasors, using the same number of phasors as there are time series. The <code>signif</code>
output is a list with first element &quot;<code>quick</code>&quot; and second element a vector of <code>nrand</code> magnitudes of sums 
of random phasors. For <code>sigmethod</code> equal to <code>fft</code>, the empirical wpmf is compared to wmpfs of 
Fourier surrogate datasets. The <code>signif</code> output is a list with first element &quot;<code>fft</code>&quot;, second element 
equal to <code>nrand</code>, and third element the fraction of surrogate-based wpmf magnitudes that the empirical wpmf 
magnitude is greater than (times by timescales matrix). For <code>sigmethod</code> equal to <code>aaft</code>, <code>aaft</code> 
surrogates are used instead. Output has similar format to the <code>fft</code> case. Values other than <code>quick</code>, 
<code>fft</code>, and <code>aaft</code> for <code>sigmethod</code> result in no significance testing.
</p>


<h3>Value</h3>

<p><code>wpmf</code> returns an object of class <code>wpmf</code>. Slots are:
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>A matrix of complex numbers containing the wavelet phasor mean field, of dimensions <code>length(times)</code> by the number of timescales. Entries not considered reliable (longer timescales, near the edges of the time span) are set to NA.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The times associated with the data and the <code>wpmf</code></p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales associated with the <code>wpmf</code></p>
</td></tr>
<tr><td><code>signif</code></td>
<td>
<p>A list with information from the significance testing. Format depends on <code>sigmethod</code> (see details).</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>The data matrix (locations by time) from which the <code>wpmf</code> was computed</p>
</td></tr>
<tr><td><code>wtopt</code></td>
<td>
<p>The inputted wavelet transform options scale.min, scale.max.input, sigma, f0 in a list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thomas Anderson, <a href="mailto:anderstl@gmail.com">anderstl@gmail.com</a>, Jon Walter, <a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>; Lawrence 
Sheppard, <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>; Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>References</h3>

<p>Sheppard, L.W., et al. (2016) Changes in large-scale climate alter spatial synchrony of aphid 
pests. Nature Climate Change. DOI: 10.1038/nclimate2881
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpmf_methods">wpmf_methods</a></code>, <code><a href="#topic+wmf">wmf</a></code>, <code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+plotmag">plotmag</a></code>, 
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30 #generate time steps
#generate fake count data for 20 locations
dat&lt;-matrix(rpois(20*length(times),20),nrow=20,ncol=length(times)) 
dat&lt;-cleandat(dat=dat,times=times,clev=2)$cdat #detrend and demean
res&lt;-wpmf(dat,times)

</code></pre>

<hr>
<h2 id='wpmf_methods'>Basic methods for the <code>wpmf</code> class</h2><span id='topic+wpmf_methods'></span><span id='topic+summary.wpmf'></span><span id='topic+print.wpmf'></span><span id='topic+set_times.wpmf'></span><span id='topic+set_timescales.wpmf'></span><span id='topic+set_values.wpmf'></span><span id='topic+set_dat.wpmf'></span><span id='topic+set_wtopt.wpmf'></span><span id='topic+set_signif.wpmf'></span><span id='topic+get_times.wpmf'></span><span id='topic+get_timescales.wpmf'></span><span id='topic+get_values.wpmf'></span><span id='topic+get_dat.wpmf'></span><span id='topic+get_wtopt.wpmf'></span><span id='topic+get_signif.wpmf'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>wpmf</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wpmf'
summary(object, ...)

## S3 method for class 'wpmf'
print(x, ...)

## S3 method for class 'wpmf'
set_times(obj, newval)

## S3 method for class 'wpmf'
set_timescales(obj, newval)

## S3 method for class 'wpmf'
set_values(obj, newval)

## S3 method for class 'wpmf'
set_dat(obj, newval)

## S3 method for class 'wpmf'
set_wtopt(obj, newval)

## S3 method for class 'wpmf'
set_signif(obj, newval)

## S3 method for class 'wpmf'
get_times(obj)

## S3 method for class 'wpmf'
get_timescales(obj)

## S3 method for class 'wpmf'
get_values(obj)

## S3 method for class 'wpmf'
get_dat(obj)

## S3 method for class 'wpmf'
get_wtopt(obj)

## S3 method for class 'wpmf'
get_signif(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wpmf_methods_+3A_object">object</code>, <code id="wpmf_methods_+3A_x">x</code>, <code id="wpmf_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>wpmf</code></p>
</td></tr>
<tr><td><code id="wpmf_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="wpmf_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.wpmf</code> produces a summary of a <code>wpmf</code> object.
A <code>print.wpmf</code> method is also available. For <code>wpmf</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots,
i.e., <code>*</code> equal to <code>times</code>, <code>timescales</code>, <code>wtopt</code>, 
<code>values</code>, <code>dat</code>, and <code>signif</code>. The <code>set_*</code> methods just throw an 
error, to prevent breaking the consistency between the slots of a 
<code>wpmf</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wpmf">wpmf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>times&lt;-1:30 #generate time steps
#generate fake count data for 20 locations
dat&lt;-matrix(rpois(20*length(times),20),nrow=20,ncol=length(times)) 
dat&lt;-cleandat(dat=dat,times=times,clev=2)$cdat #detrend and demean
h&lt;-wpmf(dat,times)
get_times(h)
summary(h)
print(h)

</code></pre>

<hr>
<h2 id='wt'>Computes the wavelet transform of a timeseries. Also the creator function for the
<code>wt</code> class.</h2><span id='topic+wt'></span>

<h3>Description</h3>

<p>Computes the wavelet transform of a timeseries. Also the creator function for the
<code>wt</code> class. The <code>wt</code> class inherits from the <code>tts</code> class, which
inherits from the <code>list</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wt(
  t.series,
  times,
  scale.min = 2,
  scale.max.input = NULL,
  sigma = 1.05,
  f0 = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt_+3A_t.series">t.series</code></td>
<td>
<p>A timeseries of real values</p>
</td></tr>
<tr><td><code id="wt_+3A_times">times</code></td>
<td>
<p>A vector of time step values (e.g., years), spacing 1</p>
</td></tr>
<tr><td><code id="wt_+3A_scale.min">scale.min</code></td>
<td>
<p>The smallest scale of fluctuation that will be examined. At least 2.</p>
</td></tr>
<tr><td><code id="wt_+3A_scale.max.input">scale.max.input</code></td>
<td>
<p>The largest scale of fluctuation that is guaranteed to be examined</p>
</td></tr>
<tr><td><code id="wt_+3A_sigma">sigma</code></td>
<td>
<p>The ratio of each time scale examined relative to the next timescale. Should be greater than 1.</p>
</td></tr>
<tr><td><code id="wt_+3A_f0">f0</code></td>
<td>
<p>The ratio of the period of fluctuation to the width of the envelope. Defaults to 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>wt</code> returns an object of class <code>wt</code>.  Slots are: 
</p>
<table>
<tr><td><code>values</code></td>
<td>
<p>A matrix of complex numbers, of dimensions <code>length(t.series)</code> by the number of timescales. Entries not considered reliable (longer timescales, near the edges of the time span) are set to NA.</p>
</td></tr>
<tr><td><code>times</code></td>
<td>
<p>The time steps specified (e.g. years)</p>
</td></tr>
<tr><td><code>wtopt</code></td>
<td>
<p>The inputted wavelet transform options scale.min, scale.max.input, sigma, f0 in a list</p>
</td></tr>
<tr><td><code>timescales</code></td>
<td>
<p>The timescales (1/frequency) computed for the wavelet transform</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>The data vector from which the transform was computed</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Important for interpreting the phase: the phases grow through time, i.e., they turn anti-clockwise.
</p>


<h3>Author(s)</h3>

<p>Lawrence Sheppard <a href="mailto:lwsheppard@ku.edu">lwsheppard@ku.edu</a>, Jonathan Walter 
<a href="mailto:jaw3es@virginia.edu">jaw3es@virginia.edu</a>, Daniel Reuman <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt_methods">wt_methods</a></code>, <code><a href="#topic+tts">tts</a></code>, <code><a href="#topic+plotmag">plotmag</a></code>, <code><a href="#topic+plotphase">plotphase</a></code>,
<code>browseVignettes("wsyn")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time1&lt;-1:100
time2&lt;-101:200
ts1p1&lt;-sin(2*pi*time1/15)
ts1p2&lt;-0*time1
ts2p1&lt;-0*time2
ts2p2&lt;-sin(2*pi*time2/8)
ts1&lt;-ts1p1+ts1p2
ts2&lt;-ts2p1+ts2p2
ts&lt;-c(ts1,ts2)
ra&lt;-rnorm(200,mean=0,sd=0.5)
t.series&lt;-ts+ra
t.series&lt;-t.series-mean(t.series)
times&lt;-c(time1,time2)
res&lt;-wt(t.series, times)

</code></pre>

<hr>
<h2 id='wt_methods'>Basic methods for the <code>wt</code> class</h2><span id='topic+wt_methods'></span><span id='topic+summary.wt'></span><span id='topic+print.wt'></span><span id='topic+set_times.wt'></span><span id='topic+set_timescales.wt'></span><span id='topic+set_values.wt'></span><span id='topic+set_dat.wt'></span><span id='topic+set_wtopt.wt'></span><span id='topic+get_times.wt'></span><span id='topic+get_timescales.wt'></span><span id='topic+get_values.wt'></span><span id='topic+get_dat.wt'></span><span id='topic+get_wtopt.wt'></span>

<h3>Description</h3>

<p>Set, get, summary, and print methods for the <code>wt</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wt'
summary(object, ...)

## S3 method for class 'wt'
print(x, ...)

## S3 method for class 'wt'
set_times(obj, newval)

## S3 method for class 'wt'
set_timescales(obj, newval)

## S3 method for class 'wt'
set_values(obj, newval)

## S3 method for class 'wt'
set_dat(obj, newval)

## S3 method for class 'wt'
set_wtopt(obj, newval)

## S3 method for class 'wt'
get_times(obj)

## S3 method for class 'wt'
get_timescales(obj)

## S3 method for class 'wt'
get_values(obj)

## S3 method for class 'wt'
get_dat(obj)

## S3 method for class 'wt'
get_wtopt(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wt_methods_+3A_object">object</code>, <code id="wt_methods_+3A_x">x</code>, <code id="wt_methods_+3A_obj">obj</code></td>
<td>
<p>An object of class <code>wt</code></p>
</td></tr>
<tr><td><code id="wt_methods_+3A_...">...</code></td>
<td>
<p>Not currently used. Included for argument consistency
with existing generics.</p>
</td></tr>
<tr><td><code id="wt_methods_+3A_newval">newval</code></td>
<td>
<p>A new value, for the <code>set_*</code> methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.wt</code> produces a summary of a <code>wt</code> object.
A <code>print.wt</code> method is also available. For <code>wt</code> objects, 
<code>set_*</code> and <code>get_*</code> methods are available for all slots,
i.e., <code>*</code> equal to <code>times</code>, <code>timescales</code>, <code>wtopt</code>, 
<code>values</code>, and <code>dat</code>. The <code>set_*</code> methods just throw an 
error, to prevent breaking the consistency between the slots of a 
<code>wt</code> object.
</p>


<h3>Author(s)</h3>

<p>Daniel Reuman, <a href="mailto:reuman@ku.edu">reuman@ku.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wt">wt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>time1&lt;-1:100
time2&lt;-101:200
ts1p1&lt;-sin(2*pi*time1/15)
ts1p2&lt;-0*time1
ts2p1&lt;-0*time2
ts2p2&lt;-sin(2*pi*time2/8)
ts1&lt;-ts1p1+ts1p2
ts2&lt;-ts2p1+ts2p2
ts&lt;-c(ts1,ts2)
ra&lt;-rnorm(200,mean=0,sd=0.5)
t.series&lt;-ts+ra
t.series&lt;-t.series-mean(t.series)
times&lt;-c(time1,time2)
h&lt;-wt(t.series, times)
get_times(h)
summary(h)
print(h)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
