<!DOCTYPE html><html lang="en"><head><title>Help for package templr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {templr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ask_dX'><p>ask&amp;tell component function to 'ask' where objective function gradient evaluation is required.</p></a></li>
<li><a href='#ask_dY'><p>ask&amp;tell component function to 'ask' objective function gradient evaluation using finite difference.</p></a></li>
<li><a href='#ask_X'><p>ask&amp;tell component function to 'ask' where objective function evaluation is required.</p></a></li>
<li><a href='#ask_Y'><p>ask&amp;tell component function to 'ask' objective function evaluation.</p></a></li>
<li><a href='#from01'><p>Helper function to scale from [0,1] to [min,max]</p></a></li>
<li><a href='#import'><p>Dependencies loader, supports many protocols like github:, gitlab:, ... using remotes::instal_...</p>
Will create a local '.lib' directory to store packages installed</a></li>
<li><a href='#list.results'><p>Parse algorithm string result in R list</p></a></li>
<li><a href='#max_input'><p>Helper function to get $max from 'input' list</p></a></li>
<li><a href='#min_input'><p>Helper function to get $min from 'input' list</p></a></li>
<li><a href='#parse.algorithm'><p>Parse algorithm file and returns its (header) indos and methods</p></a></li>
<li><a href='#read.algorithm'><p>Read algorithm file and returns one header info</p></a></li>
<li><a href='#run.algorithm'><p>Apply a template algorithm file to an objective function</p></a></li>
<li><a href='#tell_dY'><p>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.</p></a></li>
<li><a href='#tell_Y'><p>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.</p></a></li>
<li><a href='#to01'><p>Helper function to scale from [min,max] to [0,1]</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MASCOTNUM Algorithms Template Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2-0</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-10-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Yann Richet <a href="https://orcid.org/0000-0002-5677-8458"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yann Richet &lt;yann.richet@irsn.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Helper functions for MASCOTNUM algorithm template, for design of numerical experiments practice:
    algorithm template parser to support MASCOTNUM specification <a href="https://www.gdr-mascotnum.fr/template.html">https://www.gdr-mascotnum.fr/template.html</a>, 
    'ask &amp; tell' decoupling injection (inspired by <a href="https://search.r-project.org/CRAN/refmans/sensitivity/html/decoupling.html">https://search.r-project.org/CRAN/refmans/sensitivity/html/decoupling.html</a>) 
    to use "crimped" algorithms (like uniroot(), optim(), ...) from outside R,
    basic template examples: Brent algorithm for 1 dim root finding and L-BFGS-B from base optim().</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, stats, remotes, xml2, jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, future</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MASCOTNUM/templr">https://github.com/MASCOTNUM/templr</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-25 15:40:56 UTC; richet</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-25 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ask_dX'>ask&amp;tell component function to 'ask' where objective function gradient evaluation is required.</h2><span id='topic+ask_dX'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'ask' where objective function gradient evaluation is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ask_dX(
  id = 0,
  dX.tmp = "dX.todo",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  sleep_step = 0.1,
  sleep_init = 0,
  timeout = 360000,
  trace = function(...) cat(paste0(..., "\n")),
  clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ask_dX_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_dx.tmp">dX.tmp</code></td>
<td>
<p>temporary &quot;X&quot; values file (default: &quot;dX.todo&quot;)</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_sleep_step">sleep_step</code></td>
<td>
<p>delay between checking X.tmp and Y.tmp (default: 0.1 sec.)</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_sleep_init">sleep_init</code></td>
<td>
<p>initial delay before checking X.tmp and Y.tmp  (default: 0 sec.)</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_timeout">timeout</code></td>
<td>
<p>maximum delay before breaking loop if X.tmp or Y.tmp doesn't appear (default: 36000 sec. = 10 min.) .</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="ask_dX_+3A_clean">clean</code></td>
<td>
<p>should we cleanup temporary files after reading ? (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>input values of objective function to compute externally
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_dY(x=123)
## In another R session
  ask_dX() # returns 123
  tell_dY(y=456)
## Then ask_dY in main R session returns with value '456'

## End(Not run)
</code></pre>

<hr>
<h2 id='ask_dY'>ask&amp;tell component function to 'ask' objective function gradient evaluation using finite difference.</h2><span id='topic+ask_dY'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'ask' objective function gradient evaluation using finite difference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ask_dY(
  x,
  dX = 0.001,
  id = 0,
  dX.tmp = "dX.todo",
  dY.tmp = "dY.done",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  sleep_step = 0.1,
  sleep_init = 0,
  timeout = 360000,
  trace = function(...) cat(paste0(..., "\n")),
  clean = TRUE,
  force_cleanup = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ask_dY_+3A_x">x</code></td>
<td>
<p>input values of objective function gradient to compute</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_dx">dX</code></td>
<td>
<p>finite difference applied to input values to compute gradient</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_dx.tmp">dX.tmp</code></td>
<td>
<p>temporary &quot;X&quot; values file (default: &quot;dX.todo&quot;)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_dy.tmp">dY.tmp</code></td>
<td>
<p>temporary &quot;Y&quot; values file (default: &quot;dY.done&quot;)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_sleep_step">sleep_step</code></td>
<td>
<p>delay between checking X.tmp and Y.tmp (default: 0.1 sec.)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_sleep_init">sleep_init</code></td>
<td>
<p>initial delay before checking X.tmp and Y.tmp  (default: 0 sec.)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_timeout">timeout</code></td>
<td>
<p>maximum delay before breaking loop if X.tmp or Y.tmp doesn't appear (default: 36000 sec. = 10 min.) .</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_clean">clean</code></td>
<td>
<p>should we cleanup temporary files after reading ? (default: TRUE)</p>
</td></tr>
<tr><td><code id="ask_dY_+3A_force_cleanup">force_cleanup</code></td>
<td>
<p>should we cleanup temporary files before writing (possible conflicting asktell calls) ? (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>output value of objective function gradient, as given by tell_dY() call in parallel session
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_dY(x=123)
## In another R session
  ask_dX() # returns 123
  tell_dY(y=456)
## Then ask_dY in main R session returns with value '456'

## End(Not run)
</code></pre>

<hr>
<h2 id='ask_X'>ask&amp;tell component function to 'ask' where objective function evaluation is required.</h2><span id='topic+ask_X'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'ask' where objective function evaluation is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ask_X(
  id = 0,
  X.tmp = "X.todo",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  sleep_step = 0.1,
  sleep_init = 0.1,
  timeout = 360000,
  trace = function(...) cat(paste0(..., "\n")),
  clean = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ask_X_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="ask_X_+3A_x.tmp">X.tmp</code></td>
<td>
<p>temporary &quot;X&quot; values file (default: &quot;X.todo&quot;)</p>
</td></tr>
<tr><td><code id="ask_X_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="ask_X_+3A_sleep_step">sleep_step</code></td>
<td>
<p>delay between checking X.tmp and Y.tmp (default: 0.1 sec.)</p>
</td></tr>
<tr><td><code id="ask_X_+3A_sleep_init">sleep_init</code></td>
<td>
<p>initial delay before checking X.tmp and Y.tmp  (default: 0 sec.)</p>
</td></tr>
<tr><td><code id="ask_X_+3A_timeout">timeout</code></td>
<td>
<p>maximum delay before breaking loop if X.tmp or Y.tmp doesn't appear (default: 36000 sec. = 10 min.) .</p>
</td></tr>
<tr><td><code id="ask_X_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="ask_X_+3A_clean">clean</code></td>
<td>
<p>should we cleanup temporary files after reading ? (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>input value of objective function to compute externally
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_Y(x=123)
## In another R session
  ask_X() # returns 123
  tell_Y(y=456)
## Then ask_dY in main R session returns with value '456'

## End(Not run)
</code></pre>

<hr>
<h2 id='ask_Y'>ask&amp;tell component function to 'ask' objective function evaluation.</h2><span id='topic+ask_Y'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'ask' objective function evaluation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ask_Y(
  x,
  id = 0,
  X.tmp = "X.todo",
  Y.tmp = "Y.done",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  sleep_step = 0.1,
  sleep_init = 0,
  timeout = 360000,
  trace = function(...) cat(paste0(..., "\n")),
  clean = TRUE,
  force_cleanup = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ask_Y_+3A_x">x</code></td>
<td>
<p>input values of objective function to compute</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_x.tmp">X.tmp</code></td>
<td>
<p>temporary &quot;X&quot; values file (default: &quot;X.todo&quot;)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_y.tmp">Y.tmp</code></td>
<td>
<p>temporary &quot;Y&quot; values file (default: &quot;Y.done&quot;)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_sleep_step">sleep_step</code></td>
<td>
<p>delay between checking X.tmp and Y.tmp (default: 0.1 sec.)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_sleep_init">sleep_init</code></td>
<td>
<p>initial delay before checking X.tmp and Y.tmp  (default: 0 sec.)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_timeout">timeout</code></td>
<td>
<p>maximum delay before breaking loop if X.tmp or Y.tmp doesn't appear (default: 36000 sec. = 10 min.) .</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_clean">clean</code></td>
<td>
<p>should we cleanup temporary files after reading ? (default: TRUE)</p>
</td></tr>
<tr><td><code id="ask_Y_+3A_force_cleanup">force_cleanup</code></td>
<td>
<p>should we cleanup temporary files before writing (possible conflicting asktell calls) ? (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>output value of objective function, as given by tell_Y() call in parallel session
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_Y(x=123)
## In another R session
  ask_X() # returns 123
  tell_Y(y=456)
## Then ask_Y in main R session returns with value '456'

## End(Not run)
</code></pre>

<hr>
<h2 id='from01'>Helper function to scale from [0,1] to [min,max]</h2><span id='topic+from01'></span>

<h3>Description</h3>

<p>Helper function to scale from [0,1] to [min,max]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>from01(X, inp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="from01_+3A_x">X</code></td>
<td>
<p>values to scale</p>
</td></tr>
<tr><td><code id="from01_+3A_inp">inp</code></td>
<td>
<p>list containing 'min' and 'max' values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X scaled in [inp$min, inp$max]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from01(data.frame(x=matrix(runif(10))),list(x=list(min=10,max=20)))
</code></pre>

<hr>
<h2 id='import'>Dependencies loader, supports many protocols like github:, gitlab:, ... using remotes::instal_...
Will create a local '.lib' directory to store packages installed</h2><span id='topic+import'></span>

<h3>Description</h3>

<p>Dependencies loader, supports many protocols like github:, gitlab:, ... using remotes::instal_...
Will create a local '.lib' directory to store packages installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(..., lib.loc = NULL, trace = function(...) cat(paste0(..., "\n")))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_+3A_...">...</code></td>
<td>
<p>dependencies/libraries/packages to load</p>
</td></tr>
<tr><td><code id="import_+3A_lib.loc">lib.loc</code></td>
<td>
<p>use to setup a dedicated libPath directory to install packages</p>
</td></tr>
<tr><td><code id="import_+3A_trace">trace</code></td>
<td>
<p>display info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list of) load status of packages (TRUE/FALSE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  import('VGAM')
}
</code></pre>

<hr>
<h2 id='list.results'>Parse algorithm string result in R list</h2><span id='topic+list.results'></span>

<h3>Description</h3>

<p>Parse algorithm string result in R list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.results(result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list.results_+3A_result">result</code></td>
<td>
<p>templated algorithm result string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of string parsed: extract XML or JSON content
</p>


<h3>Examples</h3>

<pre><code class='language-R'> list.results(paste0(
  "&lt;HTML name='minimum'&gt;minimum is 0.523431237543406 found at ...&lt;/HTML&gt;",
  "&lt;min&gt; 0.523431237543406 &lt;/min&gt;",
  "&lt;argmin&gt;[ 0.543459029033452,0.173028395040855 ]&lt;/argmin&gt;"))
</code></pre>

<hr>
<h2 id='max_input'>Helper function to get $max from 'input' list</h2><span id='topic+max_input'></span>

<h3>Description</h3>

<p>Helper function to get $max from 'input' list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_input(inp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_input_+3A_inp">inp</code></td>
<td>
<p>lst of objects containing 'max' field (as list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of inp$...$max values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>max_input(list(x1=list(min=0,max=1),x2=list(min=2,max=3)))
</code></pre>

<hr>
<h2 id='min_input'>Helper function to get $min from 'input' list</h2><span id='topic+min_input'></span>

<h3>Description</h3>

<p>Helper function to get $min from 'input' list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_input(inp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_input_+3A_inp">inp</code></td>
<td>
<p>lst of objects containing 'min' field (as list)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of inp$...$min values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>min_input(list(x1=list(min=0,max=1),x2=list(min=2,max=3)))
</code></pre>

<hr>
<h2 id='parse.algorithm'>Parse algorithm file and returns its (header) indos and methods</h2><span id='topic+parse.algorithm'></span>

<h3>Description</h3>

<p>Parse algorithm file and returns its (header) indos and methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse.algorithm(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse.algorithm_+3A_file">file</code></td>
<td>
<p>Template algorithm file to parse</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of header infos and environment containing methods &lt;constructor&gt;,getInitialDesign,getNextDesign,displayResults
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse.algorithm(system.file("Brent.R", package="templr"))
</code></pre>

<hr>
<h2 id='read.algorithm'>Read algorithm file and returns one header info</h2><span id='topic+read.algorithm'></span>

<h3>Description</h3>

<p>Read algorithm file and returns one header info
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.algorithm(file, info = "help")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.algorithm_+3A_file">file</code></td>
<td>
<p>Template algorithm file to read</p>
</td></tr>
<tr><td><code id="read.algorithm_+3A_info">info</code></td>
<td>
<p>header info to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of header infos
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read.algorithm(system.file("Brent.R", package="templr"),"help")
</code></pre>

<hr>
<h2 id='run.algorithm'>Apply a template algorithm file to an objective function</h2><span id='topic+run.algorithm'></span>

<h3>Description</h3>

<p>Apply a template algorithm file to an objective function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run.algorithm(
  algorithm_file,
  objective_function,
  input,
  output = NULL,
  options = NULL,
  work_dir = ".",
  trace = function(...) cat(paste0(..., "\n")),
  silent = FALSE,
  save_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="run.algorithm_+3A_algorithm_file">algorithm_file</code></td>
<td>
<p>templated algorithm file</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_objective_function">objective_function</code></td>
<td>
<p>function to apply algorithm on</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_input">input</code></td>
<td>
<p>list of input arguments of function (eg. list(x1=list(min=0,max=1),x2=list(min=10,max=20)))</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_output">output</code></td>
<td>
<p>list of output names</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_options">options</code></td>
<td>
<p>algorithm options to overload default ones</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_work_dir">work_dir</code></td>
<td>
<p>working directory to run algorithm. will store output files, images, ..</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_trace">trace</code></td>
<td>
<p>display running info</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_silent">silent</code></td>
<td>
<p>quietness</p>
</td></tr>
<tr><td><code id="run.algorithm_+3A_save_data">save_data</code></td>
<td>
<p>enable (by default) saving of data (in .Rds) along algorithm iterations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>algorithm result (and algorithm object &amp; files as attributes)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>run.algorithm(
  system.file("Brent.R", package="templr"),
  function(x) sin(x)-0.75,
  list(x=list(min=0,max=pi/2)),
  work_dir=tempdir()
  )
</code></pre>

<hr>
<h2 id='tell_dY'>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.</h2><span id='topic+tell_dY'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tell_dY(
  dy,
  id = 0,
  dY.tmp = "dY.done",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  trace = function(...) cat(paste0(..., "\n")),
  force_cleanup = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tell_dY_+3A_dy">dy</code></td>
<td>
<p>output value of objective function gradient to return</p>
</td></tr>
<tr><td><code id="tell_dY_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="tell_dY_+3A_dy.tmp">dY.tmp</code></td>
<td>
<p>temporary &quot;Y&quot; values file (default: &quot;dY.done&quot;)</p>
</td></tr>
<tr><td><code id="tell_dY_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="tell_dY_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="tell_dY_+3A_force_cleanup">force_cleanup</code></td>
<td>
<p>should we cleanup temporary files before writing (possible conflicting asktell calls) ? (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>input value of objective function to compute externally
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_dY(x=123)
## In another R session
  ask_dX() # returns c(123, 123.123)
  tell_dY(dy=c(456,456.123))
## Then ask_dY in main R session returns with value '1'

## End(Not run)
</code></pre>

<hr>
<h2 id='tell_Y'>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.</h2><span id='topic+tell_Y'></span>

<h3>Description</h3>

<p>ask&amp;tell component function to 'tell' objective function value to waiting 'ask_Y' call in another R session.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tell_Y(
  y,
  id = 0,
  Y.tmp = "Y.done",
  tmp_path = file.path(tempdir(), "..", "asktell.tmp"),
  trace = function(...) cat(paste0(..., "\n")),
  force_cleanup = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tell_Y_+3A_y">y</code></td>
<td>
<p>output value of objective function to return</p>
</td></tr>
<tr><td><code id="tell_Y_+3A_id">id</code></td>
<td>
<p>unique identifier for this asktell loop (default: &quot;0&quot;)</p>
</td></tr>
<tr><td><code id="tell_Y_+3A_y.tmp">Y.tmp</code></td>
<td>
<p>temporary &quot;Y&quot; values file (default: &quot;Y.done&quot;)</p>
</td></tr>
<tr><td><code id="tell_Y_+3A_tmp_path">tmp_path</code></td>
<td>
<p>temporary directory to store X.tmp &amp; Y.tmp (default: 'tempdir()/../asktell.tmp')</p>
</td></tr>
<tr><td><code id="tell_Y_+3A_trace">trace</code></td>
<td>
<p>function to display asktell loop status (default : 'cat')</p>
</td></tr>
<tr><td><code id="tell_Y_+3A_force_cleanup">force_cleanup</code></td>
<td>
<p>should we cleanup temporary files before writing (possible conflicting asktell calls) ? (default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'ask&amp;tell' injection loop to call an external objective function within an inline algorithm (like optim(...))
Main idea: pass 'ask_Y' as objectve function argument of algorithm, which will wait until you call 'tell_Y' in another R process.
In this secondary process, you can read what X is called using 'ask_X', and when you know what values returns from the external objective, 
just call 'tell_Y' to give it.
</p>


<h3>Value</h3>

<p>input value of objective function to compute externally
</p>


<h3>Author(s)</h3>

<p>Y. Richet, discussions with D. Sinoquet. Async IO principle was defined by G. Pujol.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run:  ### Assumes you can use two independent R sessions
## In main R session
  ask_Y(x=123)
## In another R session
  ask_X() # returns 123
  tell_Y(y=456)
## Then ask_dY in main R session returns with value '456'

## End(Not run)
</code></pre>

<hr>
<h2 id='to01'>Helper function to scale from [min,max] to [0,1]</h2><span id='topic+to01'></span>

<h3>Description</h3>

<p>Helper function to scale from [min,max] to [0,1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to01(X, inp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to01_+3A_x">X</code></td>
<td>
<p>values to scale</p>
</td></tr>
<tr><td><code id="to01_+3A_inp">inp</code></td>
<td>
<p>list containing 'min' and 'max' values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X scaled in [0,1]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>to01(10+10*data.frame(x=matrix(runif(10))),list(x=list(min=10,max=20)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
