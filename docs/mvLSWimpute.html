<!DOCTYPE html><html><head><title>Help for package mvLSWimpute</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvLSWimpute}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#correct_per'><p>Function to smooth the raw wavelet periodogram</p></a></li>
<li><a href='#form_lacv_forward'><p>Function to form the local autocovariance array for the forecasting / backcasting step.</p></a></li>
<li><a href='#haarWT'><p>Function to apply the (univariate) Haar wavelet transform</p></a></li>
<li><a href='#mv_impute'><p>Function to apply the mvLSWimpute method and impute missing values in a multivariate locally stationary time series</p></a></li>
<li><a href='#mvLSWimpute-package'>
<p>Imputation Methods for Multivariate Locally Stationary Time Series</p></a></li>
<li><a href='#pdef'><p>Function to regularise the LWS matrix.</p></a></li>
<li><a href='#pred_eq_forward'><p>Function to form the prediction equations for the forecasting / backcasting step.</p></a></li>
<li><a href='#smooth_per'><p>Function to smooth the raw wavelet periodogram using the default <code>mvLSW</code> routine.</p></a></li>
<li><a href='#spec_estimation'><p>Function to estimate the Local Wavelet Spectral matrix for a multivariate locally stationary time series containing missing values</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Imputation Methods for Multivariate Locally Stationary Time
Series</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-08-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Rebecca Wilson [aut],
  Matt Nunes [aut, cre],
  Idris Eckley [ctb, ths],
  Tim Park [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementation of imputation techniques based on locally stationary wavelet time series forecasting methods from Wilson, R. E. et al. (2021) &lt;<a href="https://doi.org/10.1007%2Fs11222-021-09998-2">doi:10.1007/s11222-021-09998-2</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>wavethresh, mvLSW</td>
</tr>
<tr>
<td>Imports:</td>
<td>binhf, xts, zoo, imputeTS, utils</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-15 14:32:45 UTC; matt</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-16 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='correct_per'>Function to smooth the raw wavelet periodogram</h2><span id='topic+correct_per'></span>

<h3>Description</h3>

<p>This function corrects the raw wavelet periodogram, similar to the <code>mvEWS</code> function in the <span class="pkg">mvLSW</span> package, except acting on the raw periodogram directly.  See
<code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code> for more details.  Note: this function is not really intended to be used separately, but internally within the <code>spec_estimation</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correct_per(RawPer)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correct_per_+3A_rawper">RawPer</code></td>
<td>
<p>Raw wavelet periodogram that is to be corrected, can be either a 4D array or a <code>mvLSW</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The raw wavelet periodogram as an estimator for the local wavelet spectrum (LWS) is biased, and thus needs to be corrected.  This is done using a correction (debiasing) matrix, formed from the inner product of autocorrelation wavelets, see Park et al. (2014), Taylor et al. (2019) for more details.  This function performs this bias-correction.
</p>


<h3>Value</h3>

<p>Returns a <code>mvLSW</code> object containing the smoothed EWS of a multivariate locally stationary time series.
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate locally stationary wavelet analysis with the mvLSW R package.
_Journal of Statistical Software_ *90*(11) pp. 1-16, doi:10.18637/jss.v090.i11.<br /><br />
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating time-evolving partial coherence between signals via multivariate
locally stationary wavelet processes. _IEEE Transactions on Signal Processing_ *62*(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+spec_estimation">spec_estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample bivariate locally stationary time series

set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# form periodogram, reshaping array as necessary

tmp = apply(X, 2, function(x){haarWT(x)$D})
D = array(t(tmp), dim = c(2, 2^8, 8))

RawPer = array(apply(D, c(2, 3), tcrossprod), dim = c(2, 2, 2^8, 8))
RawPer = aperm(RawPer, c(1, 2, 4, 3))
# now correct

correctedper = correct_per(RawPer)

</code></pre>

<hr>
<h2 id='form_lacv_forward'>Function to form the local autocovariance array for the forecasting / backcasting step.</h2><span id='topic+form_lacv_forward'></span><span id='topic+form_lacv_backward'></span>

<h3>Description</h3>

<p>This function generates the local autocovariance (LACV) array that is used in the forecasting / backcasting step to form the prediction equations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>form_lacv_forward(spectrum, index, p.len = 2)
form_lacv_backward(spectrum, index, p.len = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="form_lacv_forward_+3A_spectrum">spectrum</code></td>
<td>
<p>Local wavelet spectral matrix for which we wish to form the local autocovariance array.</p>
</td></tr>
<tr><td><code id="form_lacv_forward_+3A_index">index</code></td>
<td>
<p>Time index of the missing data which we wish to impute.</p>
</td></tr>
<tr><td><code id="form_lacv_forward_+3A_p.len">p.len</code></td>
<td>
<p>Number of terms to include in the clipped predictor when forecasting / backcasting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to form the one-step ahead predictor for use in the imputation algorithm of Wilson et al. (2021), one needs the local autocovariance (LACV).  This is computed using the relationship between the LACV and the local wavelet spectrum (LWS).  See equations (4) and (5) in Wilson et al. (2021) for more details.
</p>


<h3>Value</h3>

<p>Returns the local autocovariance array that can be used as an input to the <code>pred_eq_forward</code> or <code>pred_eq_backward</code> function.
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Wilson, R. E., Eckley, I. A., Nunes, M. A. and Park, T. (2021) A wavelet-based approach for imputation in nonstationary multivariate time series.
_Statistics and Computing_ *31* Article 18, doi:10.1007/s11222-021-09998-2.<br /><br />
</p>
<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate locally stationary wavelet analysis with the mvLSW R package.
_Journal of Statistical Software_ *90*(11) pp. 1-16, doi:10.18637/jss.v090.i11.<br /><br />
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating time-evolving partial coherence between signals via multivariate
locally stationary wavelet processes. _IEEE Transactions on Signal Processing_ *62*(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pred_eq_forward">pred_eq_forward</a></code>, <code><a href="#topic+pred_eq_backward">pred_eq_backward</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample bivariate locally stationary time series

set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# create some missing values, taking care to provide some data at the start of the series 

missing.index = sort(sample(10:2^8, 30))

X[missing.index, ] &lt;-NA

# estimate the spectrum

spec = spec_estimation(X)

out &lt;- form_lacv_forward(spec$spectrum, missing.index[1], p.len=2)

</code></pre>

<hr>
<h2 id='haarWT'>Function to apply the (univariate) Haar wavelet transform</h2><span id='topic+haarWT'></span>

<h3>Description</h3>

<p>This function applies the (univariate) Haar wavelet transform. For a time series containing missing values, the wavelet coefficients are generating and any NAs remain intact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haarWT(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haarWT_+3A_data">data</code></td>
<td>
<p>Input univariate time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<table>
<tr><td><code>C</code></td>
<td>
<p>Matrix containing the smooth coefficients for the transform.</p>
</td></tr>
<tr><td><code>D</code></td>
<td>
<p>Matrix containing the detail coefficients for the transform.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# compute the haar wavelet coefficients of the first time series component:

Xwt1 = haarWT(X[, 1])
</code></pre>

<hr>
<h2 id='mv_impute'>Function to apply the mvLSWimpute method and impute missing values in a multivariate locally stationary time series</h2><span id='topic+mv_impute'></span>

<h3>Description</h3>

<p>This function applies the mvLSWimpute method to impute missing values in a multivariate locally stationary time series. The imputation can be based on forecasts only or use information from both a forecasting and backcasting step.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mv_impute(data, p = 2, type = "forward", index = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mv_impute_+3A_data">data</code></td>
<td>
<p>Input multivariate time series, matrix of dimension TxP where P is the number of channels and T is the length of the series.</p>
</td></tr>
<tr><td><code id="mv_impute_+3A_p">p</code></td>
<td>
<p>The number of terms to include in the clipped predictor when carrying out one step ahead forecasting/backcasting.</p>
</td></tr>
<tr><td><code id="mv_impute_+3A_type">type</code></td>
<td>
<p>The type of imputation to carry out, either <code>"forward"</code> or <code>"forward-backward"</code> </p>
</td></tr>
<tr><td><code id="mv_impute_+3A_index">index</code></td>
<td>
<p>The set of time indices containing missing values, this is <code>NULL</code> by default and will be determined from the input series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<table>
<tr><td><code>ImputedData</code></td>
<td>
<p>Matrix containing the imputed time series.</p>
</td></tr>
<tr><td><code>missing.index</code></td>
<td>
<p>Vector containing the set of time indices that have missing values.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>As with other time series imputation methods, <code>mv_impute</code> requires some data values at the start of the series.  In this case, we need 5 time points.
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Wilson, R. E., Eckley, I. A., Nunes, M. A. and Park, T. (2021) A wavelet-based approach	for imputation in nonstationary multivariate time series.
_Statistics and Computing_ *31* Article 18, doi:10.1007/s11222-021-09998-2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# create some fake missing data, taking care not to have missingness hear the start of the series
missing.index = sort(sample(10:2^8, 30))

X[missing.index, ] &lt;- NA

newdata = mv_impute(X)

</code></pre>

<hr>
<h2 id='mvLSWimpute-package'>
Imputation Methods for Multivariate Locally Stationary Time Series
</h2><span id='topic+mvLSWimpute-package'></span><span id='topic+mvLSWimpute'></span>

<h3>Description</h3>

<p>Implementation of imputation techniques based on locally stationary wavelet time series forecasting methods from Wilson, R. E. et al. (2021) &lt;doi:10.1007/s11222-021-09998-2&gt;.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mvLSWimpute</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Imputation Methods for Multivariate Locally Stationary Time Series</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-15</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Rebecca Wilson [aut], Matt Nunes [aut, cre], Idris Eckley [ctb, ths], Tim Park [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Rebecca", "Wilson", role = "aut"), person("Matt", "Nunes", role=c("aut","cre"), email="nunesrpackages@gmail.com"), person("Idris", "Eckley", role=c("ctb","ths")), person("Tim","Park", role="ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Matt Nunes &lt;nunesrpackages@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Implementation of imputation techniques based on locally stationary wavelet time series forecasting methods from Wilson, R. E. et al. (2021) &lt;doi:10.1007/s11222-021-09998-2&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> wavethresh, mvLSW</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> binhf, xts, zoo, imputeTS, utils</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
correct_per             Function to smooth the raw wavelet periodogram
form_lacv_forward       Function to form the local autocovariance array
                        for the forecasting / backcasting step.
haarWT                  Function to apply the (univariate) Haar wavelet
                        transform
mvLSWimpute-package     Imputation Methods for Multivariate Locally
                        Stationary Time Series
mv_impute               Function to apply the mvLSWimpute method and
                        impute missing values in a multivariate locally
                        stationary time series
pdef                    Function to regularise the LWS matrix.
pred_eq_forward         Function to form the prediction equations for
                        the forecasting / backcasting step.
smooth_per              Function to smooth the raw wavelet periodogram
                        using the default 'mvLSW' routine.
spec_estimation         Function to estimate the Local Wavelet Spectral
                        matrix for a multivariate locally stationary
                        time series containing missing values
</pre>
<p>The main routine of the package is <code><a href="#topic+mv_impute">mv_impute</a></code> which performs forward or forward and backward imputation of locally stationary multivariate time series, using one-step ahead forecasting (and backcasting).  
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson [aut], Matt Nunes [aut, cre], Idris Eckley [ctb, ths], Tim Park [ctb]
</p>
<p>Maintainer: Matt Nunes &lt;nunesrpackages@gmail.com&gt;
</p>


<h3>References</h3>

<p>Wilson, R. E., Eckley, I. A., Nunes, M. A. and Park, T. (2021) A wavelet-based approach for imputation in nonstationary multivariate time series.
_Statistics and Computing_ *31* Article 18, doi:10.1007/s11222-021-09998-2.
</p>

<hr>
<h2 id='pdef'>Function to regularise the LWS matrix.</h2><span id='topic+pdef'></span>

<h3>Description</h3>

<p>This function regularises each EWS matrix to ensure that they are strictly positive definite, similar to the <code>mvEWS</code> function in the <span class="pkg">mvLSW</span> package, except acting on a (bias-corrected) periodogram directly.  See
<code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code> for more details.  Note: this function is not really intended to be used separately, but internally within the <code>spec_estimation</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdef(spec, W = 1e-10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdef_+3A_spec">spec</code></td>
<td>
<p>EWS matrix that is to be regularised, can be either a 4D array or a <code>mvLSW</code> object.</p>
</td></tr>
<tr><td><code id="pdef_+3A_w">W</code></td>
<td>
<p>Tolerance in applying matrix regularisation to ensure each EWS matrix to be strictly positive definite. This is <code>1e-10</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>mvLSW</code> object containing the regularised EWS of a multivariate locally stationary time series.
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate locally stationary wavelet analysis with the mvLSW R package.
_Journal of Statistical Software_ *90*(11) pp. 1-16, doi:10.18637/jss.v090.i11.<br /><br />
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating time-evolving partial coherence between signals via multivariate
locally stationary wavelet processes. _IEEE Transactions on Signal Processing_ *62*(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+spec_estimation">spec_estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# form periodogram
tmp = apply(X, 2, function(x){haarWT(x)$D})

D = array(t(tmp), dim = c(2, 2^8, 8))

RawPer = array(apply(D, c(2, 3), tcrossprod), dim = c(2, 2, 2^8, 8))
RawPer = aperm(RawPer, c(1, 2, 4, 3))

# now correct

correctedper = correct_per(RawPer)

# now regularize

newper = pdef(correctedper)
</code></pre>

<hr>
<h2 id='pred_eq_forward'>Function to form the prediction equations for the forecasting / backcasting step.</h2><span id='topic+pred_eq_forward'></span><span id='topic+pred_eq_backward'></span>

<h3>Description</h3>

<p>This function generates the prediction equations (B matrix and RHS matrix) for one step ahead prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_eq_forward(lacv.array, p = 2, index)
pred_eq_forward(lacv.array, p = 2, index)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_eq_forward_+3A_lacv.array">lacv.array</code></td>
<td>
<p>The local autocovariance array from which we want to form the prediction equations, can be obtained as the output of the <code>form_lacv_forward</code> or <code>form_lacv_backward</code> functions.</p>
</td></tr>
<tr><td><code id="pred_eq_forward_+3A_p">p</code></td>
<td>
<p>Number of terms to include in the clipped predictor when forecasting / backcasting.</p>
</td></tr>
<tr><td><code id="pred_eq_forward_+3A_index">index</code></td>
<td>
<p>Time index of the missing data which we wish to impute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The one-step ahead predictor is formed as a linear combination of the time series.  The coefficients involved in optimal predictor (in the sense of minimising the mean square prediction error) are obtained by
solving a matrix equation formed using parts of the (estimated) local autocovariance array.  This function forms the matrices involved in the equation used to find the optimal linear predictor.  See equation (6) in Wilson et al. (2021) or Section 3.3 in Fryzlewicz et al. (2003) for more details. 
</p>


<h3>Value</h3>

<p>Returns a list containing the following elements:
</p>
<table>
<tr><td><code>B</code></td>
<td>
<p>The left-hand side of the matrix equation to compute the optimal one-step ahead predictor, which is essentially used to approximate the MSPE for a particular set of coefficients used in a predictor.</p>
</td></tr>
<tr><td><code>RHS</code></td>
<td>
<p>The right hand side of the matrix equation used to compute the optimal one-step ahead predictor.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Wilson, R. E., Eckley, I. A., Nunes, M. A. and Park, T. (2021) A wavelet-based approach for imputation in nonstationary multivariate time series.
_Statistics and Computing_ *31* Article 18, doi:10.1007/s11222-021-09998-2.<br /><br />
</p>
<p>Fryzlewicz, P. van Bellegem, S. and von Sachs, R. (2003) Forecasting non-stationary time series by wavelet process modelling. _Annals of the Institute of Statistical Mathematics_ *55* (4), pp. 737-764.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+form_lacv_forward">form_lacv_forward</a></code>, <code><a href="#topic+pred_eq_backward">pred_eq_backward</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample bivariate locally stationary time series

set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# create some missing values, taking care to provide some data at the start of the series 

missing.index = sort(sample(10:2^8, 30))

X[missing.index, ] &lt;-NA

# estimate the spectrum

spec = spec_estimation(X)

# obtain the LACV

lacvfor &lt;- form_lacv_forward(spec$spectrum, missing.index[1], p.len = 2)

# form matrix equation terms
mspeterms = pred_eq_forward(lacvfor, p = 2, missing.index[1])

# compute the optimal coefficients in the linear predictor:
predcoeffs = solve(mspeterms$B, mspeterms$RHS)

</code></pre>

<hr>
<h2 id='smooth_per'>Function to smooth the raw wavelet periodogram using the default <code>mvLSW</code> routine.</h2><span id='topic+smooth_per'></span>

<h3>Description</h3>

<p>This function smooths the raw wavelet periodogram, similar to the <code>mvEWS</code> function in the <span class="pkg">mvLSW</span> package, except acting on the raw periodogram directly.  See
<code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code> for more details.  Note: this function is not really intended to be used separately, but internally within the <code>spec_estimation</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_per(RawPer, type = "all", kernel.name="daniell", optimize = FALSE, kernel.param =
                 NULL, smooth.Jset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_per_+3A_rawper">RawPer</code></td>
<td>
<p>Raw wavelet periodogram that is to be smoothed, can be either a 4D array or a <code>mvLSW</code> object.</p>
</td></tr>
<tr><td><code id="smooth_per_+3A_type">type</code></td>
<td>
<p>Determines the type of smoothing to be performed, if <code>"all"</code> then the same smoothing kernel is applied to all levels, if <code>"by.level"</code> then a different smoothing kernel is applied to each level.</p>
</td></tr>
<tr><td><code id="smooth_per_+3A_kernel.name">kernel.name</code></td>
<td>
<p>Name of the smoothing kernel to be applied.</p>
</td></tr>
<tr><td><code id="smooth_per_+3A_optimize">optimize</code></td>
<td>
<p>Should the smoothing be optimized. If <code>FALSE</code> then smoothing is carried out with <code>kernel.name</code> and <code>kernel.param</code>.</p>
</td></tr>
<tr><td><code id="smooth_per_+3A_kernel.param">kernel.param</code></td>
<td>
<p>Value of the smoothing kernel parameter to be applied.</p>
</td></tr>
<tr><td><code id="smooth_per_+3A_smooth.jset">smooth.Jset</code></td>
<td>
<p>Vector indicating which levels should be used in the calculation of the optimal kernel parameter. By default all levels are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>mvLSW</code> object containing the smoothed EWS of a multivariate locally stationary time series.
</p>


<h3>Author(s)</h3>

<p>Rebecca Wilson
</p>


<h3>References</h3>

<p>Taylor, S.A.C., Park, T.A. and Eckley, I. (2019) Multivariate locally stationary wavelet analysis with the mvLSW R package.
_Journal of Statistical Software_ *90*(11) pp. 1-16, doi:10.18637/jss.v090.i11.<br /><br />
</p>
<p>Park, T., Eckley, I. and Ombao, H.C. (2014) Estimating time-evolving partial coherence between signals via multivariate
locally stationary wavelet processes. _IEEE Transactions on Signal Processing_ *62*(20) pp. 5240-5250.
</p>


<h3>See Also</h3>

<p><code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code>, <code><a href="#topic+spec_estimation">spec_estimation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Sample bivariate locally stationary time series

set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# form periodogram
tmp = apply(X, 2, function(x){haarWT(x)$D})
D = array(t(tmp), dim = c(2, 2^8, 8))

#sqrv &lt;- function(d) return( d %*% t(d) )

#RawPer = array(apply(D, c(2, 3), sqrv), dim = c(2, 2, 2^8, 8))
RawPer = array(apply(D, c(2, 3), tcrossprod), dim = c(2, 2, 2^8, 8))
RawPer = aperm(RawPer, c(1, 2, 4, 3))

# now smooth

smoothper = smooth_per(RawPer)

</code></pre>

<hr>
<h2 id='spec_estimation'>Function to estimate the Local Wavelet Spectral matrix for a multivariate locally stationary time series containing missing values</h2><span id='topic+spec_estimation'></span>

<h3>Description</h3>

<p>This function estimates the LWS matrix for a multivariate locally stationary time series containing missing values. If the input time series does not contain missing values then spectral estimation is carried out using routines from the <span class="pkg">mvLSW</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_estimation(data, interp = "linear")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_estimation_+3A_data">data</code></td>
<td>
<p>Input multivariate time series, matrix of dimension TxP where P is the number of channels and T is the length of the series.</p>
</td></tr>
<tr><td><code id="spec_estimation_+3A_interp">interp</code></td>
<td>
<p>Method of interpolation of NAs in spectrum.  Can be <code>"linear"</code> or <code>"spline"</code>; see <code><a href="imputeTS.html#topic+na_interpolation">na_interpolation</a></code> for more detals.  See also note below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>mvLSW</code> object containing the estimated LWS matrix.
</p>


<h3>Note</h3>

<p>For some series with a lot of missing values, the linear interpolation will result in zero periodogram values (due to the form of the Haar filters).  This may not be desirable, so a higher order (spline) interpolation function may be better. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correct_per">correct_per</a></code>, <code><a href="#topic+smooth_per">smooth_per</a></code>, <code><a href="mvLSW.html#topic+mvEWS">mvEWS</a></code>, <code><a href="imputeTS.html#topic+na_interpolation">na_interpolation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample bivariate locally stationary time series

set.seed(1)
X &lt;- matrix(rnorm(2 * 2^8), ncol = 2)
X[1:2^7, 2] &lt;- 3 * (X[1:2^7, 2] + 0.95 * X[1:2^7, 1])
X[-(1:2^7), 2] &lt;- X[-(1:2^7), 2] - 0.95 * X[-(1:2^7), 1]
X[-(1:2^7), 1] &lt;- X[-(1:2^7), 1] * 4
X &lt;- as.ts(X)

# create some missing values, taking care to provide some data at the start of the series 

missing.index = sort(sample(10:2^8, 30))

X[missing.index, ] &lt;-NA

# estimate the spectrum

spec = spec_estimation(X)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
