<!DOCTYPE html><html><head><title>Help for package disk.frame</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {disk.frame}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[[.disk.frame'><p>[[ interface for disk.frame using fst backend</p></a></li>
<li><a href='#add_chunk'><p>Add a chunk to the disk.frame</p></a></li>
<li><a href='#anti_join.disk.frame'><p>Performs join/merge for disk.frames</p></a></li>
<li><a href='#as.data.frame.disk.frame'><p>Convert disk.frame to data.frame by collecting all chunks</p></a></li>
<li><a href='#as.data.table.disk.frame'><p>Convert disk.frame to data.table by collecting all chunks</p></a></li>
<li><a href='#as.disk.frame'><p>Make a data.frame into a disk.frame</p></a></li>
<li><a href='#bind_rows.disk.frame'><p>Bind rows</p></a></li>
<li><a href='#chunk_summarize'><p>#' @export</p>
#' @importFrom dplyr add_count
#' @rdname dplyr_verbs
add_count.disk.frame &lt;- create_chunk_mapper(dplyr::add_count)
#' @export
#' @importFrom dplyr add_tally
#' @rdname dplyr_verbs
add_tally.disk.frame &lt;- create_chunk_mapper(dplyr::add_tally)</a></li>
<li><a href='#cmap'><p>Apply the same function to all chunks</p></a></li>
<li><a href='#cmap2'><p>'cmap2' a function to two disk.frames</p></a></li>
<li><a href='#collect.disk.frame'><p>Bring the disk.frame into R</p></a></li>
<li><a href='#colnames'><p>Return the column names of the disk.frame</p></a></li>
<li><a href='#compute.disk.frame'><p>Force computations. The results are stored in a folder.</p></a></li>
<li><a href='#create_chunk_mapper'><p>Create function that applies to each chunk if disk.frame</p></a></li>
<li><a href='#csv_to_disk.frame'><p>Convert CSV file(s) to disk.frame format</p></a></li>
<li><a href='#delete'><p>Delete a disk.frame</p></a></li>
<li><a href='#df_ram_size'><p>Get the size of RAM in gigabytes</p></a></li>
<li><a href='#disk.frame'><p>Create a disk.frame from a folder</p></a></li>
<li><a href='#disk.frame_to_parquet'><p>A function to convert a disk.frame to parquet format</p></a></li>
<li><a href='#evalparseglue'><p>Helper function to evalparse some 'glue::glue' string</p></a></li>
<li><a href='#find_globals_recursively'><p>Find globals in an expression by searching through the chain</p></a></li>
<li><a href='#foverlaps.disk.frame'><p>Apply data.table's foverlaps to the disk.frame</p></a></li>
<li><a href='#gen_datatable_synthetic'><p>Generate synthetic dataset for testing</p></a></li>
<li><a href='#get_chunk'><p>Obtain one chunk by chunk id</p></a></li>
<li><a href='#get_chunk_ids'><p>Get the chunk IDs and files names</p></a></li>
<li><a href='#get_partition_paths'><p>Get the partitioning structure of a folder</p></a></li>
<li><a href='#groups.disk.frame'><p>The shard keys of the disk.frame</p></a></li>
<li><a href='#head.disk.frame'><p>Head and tail of the disk.frame</p></a></li>
<li><a href='#is_disk.frame'><p>Checks if a folder is a disk.frame</p></a></li>
<li><a href='#merge.disk.frame'><p>Merge function for disk.frames</p></a></li>
<li><a href='#move_to'><p>Move or copy a disk.frame to another location</p></a></li>
<li><a href='#nchunks'><p>Returns the number of chunks in a disk.frame</p></a></li>
<li><a href='#nrow'><p>Number of rows or columns</p></a></li>
<li><a href='#overwrite_check'><p>Check if the outdir exists or not</p></a></li>
<li><a href='#partition_filter'><p>Filter the dataset based on folder partitions</p></a></li>
<li><a href='#play'><p>Play the recorded lazy operations</p></a></li>
<li><a href='#print.disk.frame'><p>Print disk.frame</p></a></li>
<li><a href='#pull.disk.frame'><p>Pull a column from table similar to 'dplyr::pull'.</p></a></li>
<li><a href='#purrr_as_mapper'><p>Used to convert a function to purrr syntax if needed</p></a></li>
<li><a href='#rbindlist.disk.frame'><p>rbindlist disk.frames together</p></a></li>
<li><a href='#rechunk'><p>Increase or decrease the number of chunks in the disk.frame</p></a></li>
<li><a href='#recommend_nchunks'><p>Recommend number of chunks based on input size</p></a></li>
<li><a href='#remove_chunk'><p>Removes a chunk from the disk.frame</p></a></li>
<li><a href='#sample_frac.disk.frame'><p>Sample n rows from a disk.frame</p></a></li>
<li><a href='#select.disk.frame'><p>The dplyr verbs implemented for disk.frame</p></a></li>
<li><a href='#setup_disk.frame'><p>Set up disk.frame environment</p></a></li>
<li><a href='#shard'><p>Shard a data.frame/data.table or disk.frame into chunk and saves it into a disk.frame</p></a></li>
<li><a href='#shardkey'><p>Returns the shardkey (not implemented yet)</p></a></li>
<li><a href='#shardkey_equal'><p>Compare two disk.frame shardkeys</p></a></li>
<li><a href='#show_ceremony'><p>Show the code to setup disk.frame</p></a></li>
<li><a href='#split_string_into_df'><p>Turn a string of the form /partion1=val/partion2=val2 into data.frame</p></a></li>
<li><a href='#srckeep'><p>Keep only the variables from the input listed in selections</p></a></li>
<li><a href='#summarise.grouped_disk.frame'><p>A function to parse the summarize function</p></a></li>
<li><a href='#tbl_vars.disk.frame'><p>Column names for RStudio auto-complete</p></a></li>
<li><a href='#var_df.chunk_agg.disk.frame'><p>One Stage function</p></a></li>
<li><a href='#write_disk.frame'><p>Write disk.frame to disk</p></a></li>
<li><a href='#zip_to_disk.frame'><p>'zip_to_disk.frame' is used to read and convert every CSV file within the zip</p>
file to disk.frame format</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Larger-than-RAM Disk-Based Data Manipulation Framework</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dai ZJ &lt;zhuojia.dai@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A disk-based data manipulation tool for working with 
  large-than-RAM datasets. Aims to lower the barrier-to-entry for 
  manipulating large datasets by adhering closely to popular and 
  familiar data manipulation paradigms like 'dplyr' verbs and 
  'data.table' syntax.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), glue (&ge; 1.3.1), future.apply (&ge; 1.3.0),
fs (&ge; 1.3.1), jsonlite (&ge; 1.6), pryr (&ge; 0.1.4), stringr (&ge;
1.4.0), fst (&ge; 0.8.0), future (&ge; 1.14.0), data.table (&ge;
1.12.2), crayon (&ge; 1.3.4), bigreadr (&ge; 0.2.0), bit64,
benchmarkme, purrr (&ge; 0.3.2), globals, rlang, arrow</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), dplyr (&ge; 1.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nycflights13, magrittr, shiny, LaF, readr, rstudioapi, broom,
ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://diskframe.com">https://diskframe.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DiskFrame/disk.frame/issues">https://github.com/DiskFrame/disk.frame/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 14:39:09 UTC; RTX2080</td>
</tr>
<tr>
<td>Author:</td>
<td>Dai ZJ [aut, cre],
  Jacky Poon [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 16:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B+5B.disk.frame'>[[ interface for disk.frame using fst backend</h2><span id='topic++5B+5B.disk.frame'></span>

<h3>Description</h3>

<p>[[ interface for disk.frame using fst backend
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'

  df[[
  ...,
  keep = NULL,
  rbind = TRUE,
  use.names = TRUE,
  fill = FALSE,
  idcol = NULL
]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_...">...</code></td>
<td>
<p>same as data.table</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_keep">keep</code></td>
<td>
<p>the columns to srckeep</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_rbind">rbind</code></td>
<td>
<p>Whether to rbind the chunks. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_use.names">use.names</code></td>
<td>
<p>Same as in data.table::rbindlist</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_fill">fill</code></td>
<td>
<p>Same as in data.table::rbindlist</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.disk.frame_+3A_idcol">idcol</code></td>
<td>
<p>Same as in data.table::rbindlist</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
speed_limit = 50
cars.df[[speed &lt; speed_limit ,.N, cut(dist, pretty(dist))]]

# clean up
delete(cars.df)
</code></pre>

<hr>
<h2 id='add_chunk'>Add a chunk to the disk.frame</h2><span id='topic+add_chunk'></span>

<h3>Description</h3>

<p>If no chunk_id is specified, then the chunk is added at the end as the
largest numbered file, &quot;n.fst&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_chunk(df, chunk, chunk_id = NULL, full.names = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_chunk_+3A_df">df</code></td>
<td>
<p>the disk.frame to add a chunk to</p>
</td></tr>
<tr><td><code id="add_chunk_+3A_chunk">chunk</code></td>
<td>
<p>a data.frame to be added as a chunk</p>
</td></tr>
<tr><td><code id="add_chunk_+3A_chunk_id">chunk_id</code></td>
<td>
<p>a numeric number indicating the id of the chunk. If NULL it
will be set to the largest chunk_id + 1</p>
</td></tr>
<tr><td><code id="add_chunk_+3A_full.names">full.names</code></td>
<td>
<p>whether the chunk_id name match should be to the full file
path not just the file name</p>
</td></tr>
<tr><td><code id="add_chunk_+3A_...">...</code></td>
<td>
<p>Passed in the write_fst. E.g. compress</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is the preferred way to add a chunk to a disk.frame. It
performs checks on the types to make sure that the new chunk doesn't have
different types to the disk.frame.
</p>


<h3>Value</h3>

<p>disk.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a disk.frame
df_path = file.path(tempdir(), "tmp_add_chunk")
diskf = disk.frame(df_path)

# add a chunk to diskf
add_chunk(diskf, cars)
add_chunk(diskf, cars)

nchunks(diskf) # 2

df2 = disk.frame(file.path(tempdir(), "tmp_add_chunk2"))

# add chunks by specifying the chunk_id number; this is especially useful if
# you wish to add multiple chunk in parralel

add_chunk(df2, data.frame(chunk=1), 1)
add_chunk(df2, data.frame(chunk=2), 3)

nchunks(df2) # 2

dir(attr(df2, "path", exact=TRUE))
# [1] "1.fst" "3.fst"

# clean up
delete(diskf)
delete(df2)
</code></pre>

<hr>
<h2 id='anti_join.disk.frame'>Performs join/merge for disk.frames</h2><span id='topic+anti_join.disk.frame'></span><span id='topic+full_join.disk.frame'></span><span id='topic+inner_join.disk.frame'></span><span id='topic+left_join.disk.frame'></span><span id='topic+semi_join.disk.frame'></span>

<h3>Description</h3>

<p>Performs join/merge for disk.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
anti_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  outdir = tempfile("tmp_disk_frame_anti_join"),
  merge_by_chunk_id = FALSE,
  overwrite = TRUE,
  .progress = FALSE
)

## S3 method for class 'disk.frame'
full_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  outdir = tempfile("tmp_disk_frame_full_join"),
  overwrite = TRUE,
  merge_by_chunk_id,
  .progress = FALSE
)

## S3 method for class 'disk.frame'
inner_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  outdir = tempfile("tmp_disk_frame_inner_join"),
  merge_by_chunk_id = NULL,
  overwrite = TRUE,
  .progress = FALSE
)

## S3 method for class 'disk.frame'
left_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE,
  outdir = tempfile("tmp_disk_frame_left_join"),
  merge_by_chunk_id = FALSE,
  overwrite = TRUE,
  .progress = FALSE
)

## S3 method for class 'disk.frame'
semi_join(
  x,
  y,
  by = NULL,
  copy = FALSE,
  ...,
  outdir = tempfile("tmp_disk_frame_semi_join"),
  merge_by_chunk_id = FALSE,
  overwrite = TRUE,
  .progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anti_join.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_y">y</code></td>
<td>
<p>a data.frame or disk.frame. If data.frame then returns lazily; if disk.frame it performs the join eagerly and return a disk.frame</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_by">by</code></td>
<td>
<p>join by</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_copy">copy</code></td>
<td>
<p>same as dplyr::anti_join</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_...">...</code></td>
<td>
<p>same as dplyr's joins</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>output directory for disk.frame</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_merge_by_chunk_id">merge_by_chunk_id</code></td>
<td>
<p>the merge is performed by chunk id</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite output directory</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_.progress">.progress</code></td>
<td>
<p>Show progress or not. Defaults to FALSE</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_suffix">suffix</code></td>
<td>
<p>see dplyr::XXX_join</p>
</td></tr>
<tr><td><code id="anti_join.disk.frame_+3A_keep">keep</code></td>
<td>
<p>see dplyr::XXX_join</p>
</td></tr>
</table>


<h3>Value</h3>

<p>disk.frame or data.frame/data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df.df = as.disk.frame(data.frame(x = 1:3, y = 4:6), overwrite = TRUE)
df2.df = as.disk.frame(data.frame(x = 1:2, z = 10:11), overwrite = TRUE)

anti_joined.df = anti_join(df.df, df2.df) 

anti_joined.df %&gt;% collect

anti_joined.data.frame = anti_join(df.df, data.frame(x = 1:2, z = 10:11))

# clean up
delete(df.df)
delete(df2.df)
delete(anti_joined.df)
cars.df = as.disk.frame(cars)

join.df = full_join(cars.df, cars.df, merge_by_chunk_id = TRUE)

# clean up cars.df
delete(cars.df)
delete(join.df)
cars.df = as.disk.frame(cars)

join.df = inner_join(cars.df, cars.df, merge_by_chunk_id = TRUE)

# clean up cars.df
delete(cars.df)
delete(join.df)
cars.df = as.disk.frame(cars)

join.df = left_join(cars.df, cars.df)

# clean up cars.df
delete(cars.df)
delete(join.df)
cars.df = as.disk.frame(cars)

join.df = semi_join(cars.df, cars.df)

# clean up cars.df
delete(cars.df)
delete(join.df)
</code></pre>

<hr>
<h2 id='as.data.frame.disk.frame'>Convert disk.frame to data.frame by collecting all chunks</h2><span id='topic+as.data.frame.disk.frame'></span>

<h3>Description</h3>

<p>Convert disk.frame to data.frame by collecting all chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="as.data.frame.disk.frame_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.disk.frame_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column names (to syntactic names: see make.names) is optional. Note that all of R's base package as.data.frame() methods use optional only for column names treatment, basically with the meaning of data.frame(*, check.names = !optional). See also the make.names argument of the matrix method.</p>
</td></tr>
<tr><td><code id="as.data.frame.disk.frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
as.data.frame(cars.df)

# clean up
delete(cars.df)
</code></pre>

<hr>
<h2 id='as.data.table.disk.frame'>Convert disk.frame to data.table by collecting all chunks</h2><span id='topic+as.data.table.disk.frame'></span>

<h3>Description</h3>

<p>Convert disk.frame to data.table by collecting all chunks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
as.data.table(x, keep.rownames = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.table.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="as.data.table.disk.frame_+3A_keep.rownames">keep.rownames</code></td>
<td>
<p>passed to as.data.table</p>
</td></tr>
<tr><td><code id="as.data.table.disk.frame_+3A_...">...</code></td>
<td>
<p>passed to as.data.table</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)
cars.df = as.disk.frame(cars)
as.data.table(cars.df)

# clean up
delete(cars.df)
</code></pre>

<hr>
<h2 id='as.disk.frame'>Make a data.frame into a disk.frame</h2><span id='topic+as.disk.frame'></span>

<h3>Description</h3>

<p>Make a data.frame into a disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.disk.frame(
  df,
  outdir = tempfile(fileext = ".df"),
  nchunks = recommend_nchunks(df),
  overwrite = FALSE,
  shardby = NULL,
  compress = 50,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.disk.frame_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>the output directory</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_nchunks">nchunks</code></td>
<td>
<p>number of chunks</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>if TRUE the outdir will be overwritten, if FALSE it will throw an error if the directory is not empty</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_shardby">shardby</code></td>
<td>
<p>The shardkey</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_compress">compress</code></td>
<td>
<p>the compression level 0-100; 100 is highest</p>
</td></tr>
<tr><td><code id="as.disk.frame_+3A_...">...</code></td>
<td>
<p>passed to output_disk.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># write to temporary location
cars.df = as.disk.frame(cars) 

# specify a different path in the temporary folder, you are free to choose a different folder
cars_new_location.df = as.disk.frame(cars, outdir = file.path(tempdir(), "some_path.df"))

# specify a different number of chunks
# this writes to tempdir() by default
cars_chunks.df = as.disk.frame(cars, nchunks = 4, overwrite = TRUE) 

# clean up
delete(cars.df)
delete(cars_new_location.df)
delete(cars_chunks.df)
</code></pre>

<hr>
<h2 id='bind_rows.disk.frame'>Bind rows</h2><span id='topic+bind_rows.disk.frame'></span>

<h3>Description</h3>

<p>Bind rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_rows.disk.frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_rows.disk.frame_+3A_...">...</code></td>
<td>
<p>disk.frame to be row bound</p>
</td></tr>
</table>

<hr>
<h2 id='chunk_summarize'>#' @export
#' @importFrom dplyr add_count
#' @rdname dplyr_verbs
add_count.disk.frame &lt;- create_chunk_mapper(dplyr::add_count)
#' @export
#' @importFrom dplyr add_tally
#' @rdname dplyr_verbs
add_tally.disk.frame &lt;- create_chunk_mapper(dplyr::add_tally)</h2><span id='topic+chunk_summarize'></span><span id='topic+chunk_summarise'></span><span id='topic+chunk_group_by'></span><span id='topic+chunk_ungroup'></span>

<h3>Description</h3>

<p>The disk.frame group by operation perform group WITHIN each chunk. This is
often used for performance reasons. If the user wishes to perform group-by,
they may choose to use the 'hard_group_by' function which is expensive as it
reorganizes the chunks by the shard key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chunk_summarize(.data, ...)

chunk_summarise(.data, ...)

chunk_group_by(.data, ...)

chunk_ungroup(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chunk_summarize_+3A_.data">.data</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="chunk_summarize_+3A_...">...</code></td>
<td>
<p>passed to dplyr::group_by</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>hard_group_by group_by
</p>

<hr>
<h2 id='cmap'>Apply the same function to all chunks</h2><span id='topic+cmap'></span><span id='topic+cmap.disk.frame'></span><span id='topic+cmap_dfr'></span><span id='topic+cmap_dfr.disk.frame'></span><span id='topic+cimap'></span><span id='topic+cimap.disk.frame'></span><span id='topic+cimap_dfr'></span><span id='topic+cimap_dfr.disk.frame'></span><span id='topic+lazy'></span><span id='topic+lazy.disk.frame'></span><span id='topic+delayed'></span><span id='topic+clapply'></span>

<h3>Description</h3>

<p>Apply the same function to all chunks
</p>
<p>'cimap.disk.frame' accepts a two argument function where the first argument is a data.frame and the 
second is the chunk ID
</p>
<p>'lazy' is convenience function to apply '.f' to every chunk
</p>
<p>'delayed' is an alias for lazy and is consistent with the naming in Dask and Dagger.jl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmap(.x, .f, ...)

## S3 method for class 'disk.frame'
cmap(.x, .f, ...)

cmap_dfr(.x, .f, ..., .id = NULL)

## S3 method for class 'disk.frame'
cmap_dfr(.x, .f, ..., .id = NULL, use.names = fill, fill = FALSE, idcol = NULL)

cimap(.x, .f, ...)

## S3 method for class 'disk.frame'
cimap(
  .x,
  .f,
  outdir = NULL,
  keep = NULL,
  lazy = TRUE,
  overwrite = FALSE,
  compress = 50,
  ...
)

cimap_dfr(.x, .f, ..., .id = NULL)

## S3 method for class 'disk.frame'
cimap_dfr(
  .x,
  .f,
  ...,
  .id = NULL,
  use.names = fill,
  fill = FALSE,
  idcol = NULL
)

lazy(.x, .f, ...)

## S3 method for class 'disk.frame'
lazy(.x, .f, ...)

delayed(.x, .f, ...)

clapply(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmap_+3A_.x">.x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="cmap_+3A_.f">.f</code></td>
<td>
<p>a function to apply to each of the chunks</p>
</td></tr>
<tr><td><code id="cmap_+3A_...">...</code></td>
<td>
<p>Passed to 'collect' and 'write_disk.frame'</p>
</td></tr>
<tr><td><code id="cmap_+3A_.id">.id</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="cmap_+3A_use.names">use.names</code></td>
<td>
<p>for cmap_dfr's call to data.table::rbindlist. See data.table::rbindlist</p>
</td></tr>
<tr><td><code id="cmap_+3A_fill">fill</code></td>
<td>
<p>for cmap_dfr's call to data.table::rbindlist. See data.table::rbindlist</p>
</td></tr>
<tr><td><code id="cmap_+3A_idcol">idcol</code></td>
<td>
<p>for cmap_dfr's call to data.table::rbindlist. See data.table::rbindlist</p>
</td></tr>
<tr><td><code id="cmap_+3A_outdir">outdir</code></td>
<td>
<p>the output directory</p>
</td></tr>
<tr><td><code id="cmap_+3A_keep">keep</code></td>
<td>
<p>The columns to keep at source</p>
</td></tr>
<tr><td><code id="cmap_+3A_lazy">lazy</code></td>
<td>
<p>if TRUE then do this lazily</p>
</td></tr>
<tr><td><code id="cmap_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite any files in the output directory</p>
</td></tr>
<tr><td><code id="cmap_+3A_compress">compress</code></td>
<td>
<p>The compression setting. 0-100</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# return the first row of each chunk lazily
# 
cars2 = cmap(cars.df, function(chunk) {
 chunk[,1]
})

collect(cars2)

# same as above but using purrr 
cars2 = cmap(cars.df, ~.x[1,])

collect(cars2)

# return the first row of each chunk eagerly as list
cmap(cars.df, ~.x[1,], lazy = FALSE)

# return the first row of each chunk eagerly as data.table/data.frame by row-binding
cmap_dfr(cars.df, ~.x[1,])

# lazy and delayed are just an aliases for cmap(..., lazy = TRUE)
collect(lazy(cars.df, ~.x[1,]))
collect(delayed(cars.df, ~.x[1,]))

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='cmap2'>'cmap2' a function to two disk.frames</h2><span id='topic+cmap2'></span><span id='topic+map_by_chunk_id'></span>

<h3>Description</h3>

<p>Perform a function on both disk.frames .x and .y, each chunk of .x and .y
gets run by .f(x.chunk, y.chunk)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cmap2(.x, .y, .f, ...)

map_by_chunk_id(.x, .y, .f, ..., outdir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cmap2_+3A_.x">.x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="cmap2_+3A_.y">.y</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="cmap2_+3A_.f">.f</code></td>
<td>
<p>a function to be called on each chunk of x and y matched by
chunk_id</p>
</td></tr>
<tr><td><code id="cmap2_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="cmap2_+3A_outdir">outdir</code></td>
<td>
<p>output directory</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

cars2.df = cmap2(cars.df, cars.df, ~data.table::rbindlist(list(.x, .y)))
collect(cars2.df)

# clean up cars.df
delete(cars.df)
delete(cars2.df)
</code></pre>

<hr>
<h2 id='collect.disk.frame'>Bring the disk.frame into R</h2><span id='topic+collect.disk.frame'></span><span id='topic+collect_list'></span><span id='topic+collect.summarized_disk.frame'></span>

<h3>Description</h3>

<p>Bring the disk.frame into RAM by loading the data and running all lazy
operations as data.table/data.frame or as a list
</p>
<p>Bring the disk.frame into RAM by loading the data and running all lazy
operations as data.table/data.frame or as a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
collect(x, ..., parallel = !is.null(attr(x, "recordings")))

collect_list(
  x,
  simplify = FALSE,
  parallel = !is.null(attr(x, "recordings")),
  ...
)

## S3 method for class 'summarized_disk.frame'
collect(x, ..., parallel = !is.null(attr(x, "recordings")))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collect.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="collect.disk.frame_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="collect.disk.frame_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE the collection is performed in parallel. By default
if there are delayed/lazy steps then it will be parallel, otherwise it will
not be in parallel. This is because parallel requires transferring data
from background R session to the current R session and if there is no
computation then it's better to avoid transferring data between session,
hence parallel = FALSE is a better choice</p>
</td></tr>
<tr><td><code id="collect.disk.frame_+3A_simplify">simplify</code></td>
<td>
<p>Should the result be simplified to array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collect return a data.frame/data.table
</p>
<p>collect_list returns a list
</p>
<p>collect return a data.frame/data.table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
# use collect to bring the data into RAM as a data.table/data.frame
collect(cars.df)

# clean up
delete(cars.df)
cars.df = as.disk.frame(cars)

# returns the result as a list
collect_list(cmap(cars.df, ~1))

# clean up
delete(cars.df)
cars.df = as.disk.frame(cars)
# use collect to bring the data into RAM as a data.table/data.frame
collect(cars.df)

# clean up
delete(cars.df)
</code></pre>

<hr>
<h2 id='colnames'>Return the column names of the disk.frame</h2><span id='topic+colnames'></span><span id='topic+names.disk.frame'></span><span id='topic+colnames.disk.frame'></span><span id='topic+colnames.default'></span>

<h3>Description</h3>

<p>The returned column names are from the source. So if you have lazy operations
then the <code>colnames</code> here does not reflects the results of those
operations. Note: if you have expensive lazy function then this operation
might take some time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colnames(x, ...)

## S3 method for class 'disk.frame'
names(x, ...)

## S3 method for class 'disk.frame'
colnames(x, ...)

## Default S3 method:
colnames(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colnames_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="colnames_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='compute.disk.frame'>Force computations. The results are stored in a folder.</h2><span id='topic+compute.disk.frame'></span>

<h3>Description</h3>

<p>Perform the computation; same as calling cmap without .f and lazy = FALSE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
compute(x, name = NULL, outdir = tempfile("tmp_df_", fileext = ".df"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="compute.disk.frame_+3A_name">name</code></td>
<td>
<p>If not NULL then used as outdir prefix.</p>
</td></tr>
<tr><td><code id="compute.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>the output directory</p>
</td></tr>
<tr><td><code id="compute.disk.frame_+3A_...">...</code></td>
<td>
<p>Passed to 'write_disk.frame'</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
cars.df2 = cars.df %&gt;% cmap(~.x)
# the computation is performed and the data is now stored elsewhere
cars.df3 = compute(cars.df2)

# clean up
delete(cars.df)
delete(cars.df3)
</code></pre>

<hr>
<h2 id='create_chunk_mapper'>Create function that applies to each chunk if disk.frame</h2><span id='topic+create_chunk_mapper'></span>

<h3>Description</h3>

<p>A function to make it easier to create functions like <code>filter</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_chunk_mapper(chunk_fn, warning_msg = NULL, as.data.frame = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_chunk_mapper_+3A_chunk_fn">chunk_fn</code></td>
<td>
<p>The dplyr function to create a mapper for</p>
</td></tr>
<tr><td><code id="create_chunk_mapper_+3A_warning_msg">warning_msg</code></td>
<td>
<p>The warning message to display when invoking the mapper</p>
</td></tr>
<tr><td><code id="create_chunk_mapper_+3A_as.data.frame">as.data.frame</code></td>
<td>
<p>force the input chunk of a data.frame; needed for dtplyr</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
filter = create_chunk_mapper(dplyr::filter)

#' example: creating a function that keeps only the first and last n row
first_and_last &lt;- function(chunk, n, ...) {
  nr = nrow(chunk)
  print(nr-n+1:nr)
  chunk[c(1:n, (nr-n+1):nr), ]
}

#' create the function for use with disk.frame
first_and_last_df = create_chunk_mapper(first_and_last)

mtcars.df = as.disk.frame(mtcars)

#' the operation is lazy
lazy_mtcars.df = mtcars.df %&gt;%
  first_and_last_df(2)

#' bring into R
collect(lazy_mtcars.df)

#' clean up
delete(mtcars.df)

</code></pre>

<hr>
<h2 id='csv_to_disk.frame'>Convert CSV file(s) to disk.frame format</h2><span id='topic+csv_to_disk.frame'></span>

<h3>Description</h3>

<p>Convert CSV file(s) to disk.frame format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>csv_to_disk.frame(
  infile,
  outdir = tempfile(fileext = ".df"),
  inmapfn = base::I,
  nchunks = recommend_nchunks(sum(file.size(infile))),
  in_chunk_size = NULL,
  shardby = NULL,
  compress = 50,
  overwrite = TRUE,
  header = TRUE,
  .progress = TRUE,
  backend = c("data.table", "readr", "LaF"),
  chunk_reader = c("bigreadr", "data.table", "readr", "readLines"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="csv_to_disk.frame_+3A_infile">infile</code></td>
<td>
<p>The input CSV file or files</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>The directory to output the disk.frame to</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_inmapfn">inmapfn</code></td>
<td>
<p>A function to be applied to the chunk read in from CSV before
the chunk is being written out. Commonly used to perform simple
transformations. Defaults to the identity function (ie. no transformation)</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_nchunks">nchunks</code></td>
<td>
<p>Number of chunks to output</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_in_chunk_size">in_chunk_size</code></td>
<td>
<p>When reading in the file, how many lines to read in at
once. This is different to nchunks which controls how many chunks are
output</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_shardby">shardby</code></td>
<td>
<p>The column(s) to shard the data by. For example suppose
'shardby = c(&quot;col1&quot;,&quot;col2&quot;)'  then every row where the values 'col1' and
'col2' are the same will end up in the same chunk; this will allow merging
by 'col1' and 'col2' to be more efficient</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_compress">compress</code></td>
<td>
<p>For fst backends it's a number between 0 and 100 where 100 is
the highest compression ratio.</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>Whether to overwrite the existing directory</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_header">header</code></td>
<td>
<p>Whether the files have header. Defaults to TRUE</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_.progress">.progress</code></td>
<td>
<p>A logical, for whether or not to show progress</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_backend">backend</code></td>
<td>
<p>The CSV reader backend to choose: &quot;data.table&quot; or &quot;readr&quot;. 
disk.frame does not have its own CSV reader. It uses either
data.table::fread or readr::read_delimited. It is worth noting that
data.table::fread does not detect dates and all dates are imported as
strings, and you are encouraged to use fasttime to convert the strings to
date. You can use the 'inmapfn' to do that. However, if you want automatic
date detection, then backend=&quot;readr&quot; may suit your needs. However, readr
is often slower than data.table, hence data.table is chosen as the default.</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_chunk_reader">chunk_reader</code></td>
<td>
<p>Even if you choose a backend there can still be multiple
strategies on how to approach the CSV reads. For example, data.table::fread
tries to mmap the whole file which can cause the whole read process to
fail. In that case we can change the chunk_reader to &quot;readLines&quot; which uses the
readLines function to read chunk by chunk and still use data.table::fread
to process the chunks. There are currently no strategies for readr backend,
except the default one.</p>
</td></tr>
<tr><td><code id="csv_to_disk.frame_+3A_...">...</code></td>
<td>
<p>passed to data.table::fread, disk.frame::as.disk.frame,
disk.frame::shard</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other ingesting data: 
<code><a href="#topic+zip_to_disk.frame">zip_to_disk.frame</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpfile = tempfile()
write.csv(cars, tmpfile)
tmpdf = tempfile(fileext = ".df")
df = csv_to_disk.frame(tmpfile, outdir = tmpdf, overwrite = TRUE)

# clean up
fs::file_delete(tmpfile)
delete(df)
</code></pre>

<hr>
<h2 id='delete'>Delete a disk.frame</h2><span id='topic+delete'></span>

<h3>Description</h3>

<p>Delete a disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delete(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delete_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
delete(cars.df)
</code></pre>

<hr>
<h2 id='df_ram_size'>Get the size of RAM in gigabytes</h2><span id='topic+df_ram_size'></span>

<h3>Description</h3>

<p>Get the size of RAM in gigabytes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_ram_size()
</code></pre>


<h3>Value</h3>

<p>integer of RAM in gigabyte (GB)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns the RAM size in gigabyte (GB)
df_ram_size() 
</code></pre>

<hr>
<h2 id='disk.frame'>Create a disk.frame from a folder</h2><span id='topic+disk.frame'></span>

<h3>Description</h3>

<p>Create a disk.frame from a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disk.frame(path, backend = "fst")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disk.frame_+3A_path">path</code></td>
<td>
<p>The path to store the output file or to a directory</p>
</td></tr>
<tr><td><code id="disk.frame_+3A_backend">backend</code></td>
<td>
<p>The only available backend is fst at the moment</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>path = file.path(tempdir(),"cars")
as.disk.frame(cars, outdir=path, overwrite = TRUE, nchunks = 2)
df = disk.frame(path)
head(df)
nchunks(df)
# clean up
delete(df)
</code></pre>

<hr>
<h2 id='disk.frame_to_parquet'>A function to convert a disk.frame to parquet format</h2><span id='topic+disk.frame_to_parquet'></span>

<h3>Description</h3>

<p>A function to convert a disk.frame to parquet format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disk.frame_to_parquet(df, outdir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disk.frame_to_parquet_+3A_df">df</code></td>
<td>
<p>a disk.frame or a path to a disk.frame</p>
</td></tr>
<tr><td><code id="disk.frame_to_parquet_+3A_outdir">outdir</code></td>
<td>
<p>the path to save the parquet files</p>
</td></tr>
</table>

<hr>
<h2 id='evalparseglue'>Helper function to evalparse some 'glue::glue' string</h2><span id='topic+evalparseglue'></span>

<h3>Description</h3>

<p>Helper function to evalparse some 'glue::glue' string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evalparseglue(code, env = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evalparseglue_+3A_code">code</code></td>
<td>
<p>the code in character(string) format to evaluate</p>
</td></tr>
<tr><td><code id="evalparseglue_+3A_env">env</code></td>
<td>
<p>the environment in which to evaluate the code</p>
</td></tr>
</table>

<hr>
<h2 id='find_globals_recursively'>Find globals in an expression by searching through the chain</h2><span id='topic+find_globals_recursively'></span>

<h3>Description</h3>

<p>Find globals in an expression by searching through the chain
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_globals_recursively(code, envir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_globals_recursively_+3A_code">code</code></td>
<td>
<p>An expression to search for globals</p>
</td></tr>
<tr><td><code id="find_globals_recursively_+3A_envir">envir</code></td>
<td>
<p>The environment from which to begin the search</p>
</td></tr>
</table>

<hr>
<h2 id='foverlaps.disk.frame'>Apply data.table's foverlaps to the disk.frame</h2><span id='topic+foverlaps.disk.frame'></span>

<h3>Description</h3>

<p>EXPERIMENTAL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foverlaps.disk.frame(
  df1,
  df2,
  by.x = if (identical(shardkey(df1)$shardkey, "")) shardkey(df1)$shardkey else
    shardkey(df2)$shardkey,
  by.y = shardkey(df2)$shardkey,
  ...,
  outdir = tempfile("df_foverlaps_tmp", fileext = ".df"),
  merge_by_chunk_id = FALSE,
  compress = 50,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="foverlaps.disk.frame_+3A_df1">df1</code></td>
<td>
<p>A disk.frame</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_df2">df2</code></td>
<td>
<p>A disk.frame or a data.frame</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_by.x">by.x</code></td>
<td>
<p>character/string vector. by.x used in foverlaps</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_by.y">by.y</code></td>
<td>
<p>character/string vector. by.x used in foverlaps</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_...">...</code></td>
<td>
<p>passed to data.table::foverlaps and disk.frame::cmap.disk.frame</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>The output directory of the disk.frame</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_merge_by_chunk_id">merge_by_chunk_id</code></td>
<td>
<p>If TRUE then the merges will happen for chunks in df1 and df2 with the same chunk id which speed up processing. Otherwise every chunk of df1 is merged with every chunk of df2. Ignored with df2 is not a disk.frame</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_compress">compress</code></td>
<td>
<p>The compression ratio for fst</p>
</td></tr>
<tr><td><code id="foverlaps.disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite existing directory</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

## simple example:
x = as.disk.frame(data.table(start=c(5,31,22,16), end=c(8,50,25,18), val2 = 7:10))
y = as.disk.frame(data.table(start=c(10, 20, 30), end=c(15, 35, 45), val1 = 1:3))
byxy = c("start", "end")
xy.df = foverlaps.disk.frame(
   x, y, by.x = byxy, by.y = byxy,
  merge_by_chunk_id = TRUE, overwrite = TRUE)
# clean up
delete(x)
delete(y)
delete(xy.df)
</code></pre>

<hr>
<h2 id='gen_datatable_synthetic'>Generate synthetic dataset for testing</h2><span id='topic+gen_datatable_synthetic'></span>

<h3>Description</h3>

<p>Generate synthetic dataset for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_datatable_synthetic(N = 2e+08, K = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_datatable_synthetic_+3A_n">N</code></td>
<td>
<p>number of rows. Defaults to 200 million</p>
</td></tr>
<tr><td><code id="gen_datatable_synthetic_+3A_k">K</code></td>
<td>
<p>controls the number of unique values for id. Some ids will have K distinct values while others have N/K distinct values</p>
</td></tr>
</table>

<hr>
<h2 id='get_chunk'>Obtain one chunk by chunk id</h2><span id='topic+get_chunk'></span><span id='topic+get_chunk.disk.frame'></span>

<h3>Description</h3>

<p>Obtain one chunk by chunk id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_chunk(...)

## S3 method for class 'disk.frame'
get_chunk(df, n, keep = NULL, full.names = FALSE, ..., partitioned_info = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_chunk_+3A_...">...</code></td>
<td>
<p>passed to fst::read_fst or whichever read function is used in the backend</p>
</td></tr>
<tr><td><code id="get_chunk_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="get_chunk_+3A_n">n</code></td>
<td>
<p>the chunk id. If numeric then matches by number, if character then returns the chunk with the same name as n</p>
</td></tr>
<tr><td><code id="get_chunk_+3A_keep">keep</code></td>
<td>
<p>the columns to keep</p>
</td></tr>
<tr><td><code id="get_chunk_+3A_full.names">full.names</code></td>
<td>
<p>whether n is the full path to the chunks or just a relative path file name. Ignored if n is numeric</p>
</td></tr>
<tr><td><code id="get_chunk_+3A_partitioned_info">partitioned_info</code></td>
<td>
<p>for internal use only. It's a data.frame used to help with filtering by partitions</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars, nchunks = 2)
get_chunk(cars.df, 1)
get_chunk(cars.df, 2)
get_chunk(cars.df, 1, keep = "speed")

# if full.names = TRUE then the full path to the chunk need to be provided
get_chunk(cars.df, file.path(attr(cars.df, "path"), "1.fst"), full.names = TRUE)

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='get_chunk_ids'>Get the chunk IDs and files names</h2><span id='topic+get_chunk_ids'></span>

<h3>Description</h3>

<p>Get the chunk IDs and files names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_chunk_ids(df, ..., full.names = FALSE, strip_extension = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_chunk_ids_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="get_chunk_ids_+3A_...">...</code></td>
<td>
<p>passed to list.files</p>
</td></tr>
<tr><td><code id="get_chunk_ids_+3A_full.names">full.names</code></td>
<td>
<p>If TRUE returns the full path to the file, Defaults to FALSE</p>
</td></tr>
<tr><td><code id="get_chunk_ids_+3A_strip_extension">strip_extension</code></td>
<td>
<p>If TRUE then the file extension in the chunk_id is removed. Defaults to TRUE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# return the integer-string chunk IDs
get_chunk_ids(cars.df)

# return the file name chunk IDs
get_chunk_ids(cars.df, full.names = TRUE)

# return the file name chunk IDs with file extension
get_chunk_ids(cars.df, strip_extension = FALSE)

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='get_partition_paths'>Get the partitioning structure of a folder</h2><span id='topic+get_partition_paths'></span>

<h3>Description</h3>

<p>Get the partitioning structure of a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_partition_paths(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_partition_paths_+3A_df">df</code></td>
<td>
<p>a disk.frame whose paths will be used to determine if it's
folder-partitioned disk.frame</p>
</td></tr>
</table>

<hr>
<h2 id='groups.disk.frame'>The shard keys of the disk.frame</h2><span id='topic+groups.disk.frame'></span>

<h3>Description</h3>

<p>The shard keys of the disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
groups(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="groups.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character
</p>

<hr>
<h2 id='head.disk.frame'>Head and tail of the disk.frame</h2><span id='topic+head.disk.frame'></span><span id='topic+tail.disk.frame'></span>

<h3>Description</h3>

<p>Head and tail of the disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
head(x, n = 6L, ...)

## S3 method for class 'disk.frame'
tail(x, n = 6L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="head.disk.frame_+3A_n">n</code></td>
<td>
<p>number of rows to include</p>
</td></tr>
<tr><td><code id="head.disk.frame_+3A_...">...</code></td>
<td>
<p>passed to base::head or base::tail</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)
head(cars.df)
tail(cars.df)

# clean up 
delete(cars.df)
</code></pre>

<hr>
<h2 id='is_disk.frame'>Checks if a folder is a disk.frame</h2><span id='topic+is_disk.frame'></span>

<h3>Description</h3>

<p>Checks if a folder is a disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_disk.frame(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_disk.frame_+3A_df">df</code></td>
<td>
<p>a disk.frame or directory to check</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

is_disk.frame(cars) # FALSE
is_disk.frame(cars.df) # TRUE

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='merge.disk.frame'>Merge function for disk.frames</h2><span id='topic+merge.disk.frame'></span>

<h3>Description</h3>

<p>Merge function for disk.frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
merge(
  x,
  y,
  by,
  outdir = tempfile(fileext = ".df"),
  ...,
  merge_by_chunk_id = FALSE,
  overwrite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_y">y</code></td>
<td>
<p>a disk.frame or data.frame</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_by">by</code></td>
<td>
<p>the merge by keys</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>The output directory for the disk.frame</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_...">...</code></td>
<td>
<p>passed to merge and cmap.disk.frame</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_merge_by_chunk_id">merge_by_chunk_id</code></td>
<td>
<p>if TRUE then only chunks in df1 and df2 with the same chunk id will get merged</p>
</td></tr>
<tr><td><code id="merge.disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite the outdir or not</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>b = as.disk.frame(data.frame(a = 51:150, b = 1:100))
d = as.disk.frame(data.frame(a = 151:250, b = 1:100))
bd.df = merge(b, d, by = "b", merge_by_chunk_id = TRUE)

# clean up cars.df
delete(b)
delete(d)
delete(bd.df)
</code></pre>

<hr>
<h2 id='move_to'>Move or copy a disk.frame to another location</h2><span id='topic+move_to'></span><span id='topic+copy_df_to'></span>

<h3>Description</h3>

<p>Move or copy a disk.frame to another location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>move_to(df, outdir, ..., copy = FALSE)

copy_df_to(df, outdir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="move_to_+3A_df">df</code></td>
<td>
<p>The disk.frame</p>
</td></tr>
<tr><td><code id="move_to_+3A_outdir">outdir</code></td>
<td>
<p>The new location</p>
</td></tr>
<tr><td><code id="move_to_+3A_...">...</code></td>
<td>
<p>NOT USED</p>
</td></tr>
<tr><td><code id="move_to_+3A_copy">copy</code></td>
<td>
<p>Merely copy and not move</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a disk.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

cars_copy.df = copy_df_to(cars.df, outdir = tempfile(fileext=".df"))

cars2.df = move_to(cars.df, outdir = tempfile(fileext=".df"))

# clean up
delete(cars_copy.df)
delete(cars2.df)
</code></pre>

<hr>
<h2 id='nchunks'>Returns the number of chunks in a disk.frame</h2><span id='topic+nchunks'></span><span id='topic+nchunk'></span><span id='topic+nchunk.disk.frame'></span><span id='topic+nchunks.disk.frame'></span>

<h3>Description</h3>

<p>Returns the number of chunks in a disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchunks(df, ...)

nchunk(df, ...)

## S3 method for class 'disk.frame'
nchunk(df, ...)

## S3 method for class 'disk.frame'
nchunks(df, skip.ready.check = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchunks_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="nchunks_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="nchunks_+3A_skip.ready.check">skip.ready.check</code></td>
<td>
<p>NOT implemented</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# return the number of chunks
nchunks(cars.df)
nchunk(cars.df)

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='nrow'>Number of rows or columns</h2><span id='topic+nrow'></span><span id='topic+nrow.disk.frame'></span><span id='topic+ncol'></span><span id='topic+ncol.disk.frame'></span>

<h3>Description</h3>

<p>Number of rows or columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nrow(df, ...)

## S3 method for class 'disk.frame'
nrow(df, ...)

ncol(df)

## S3 method for class 'disk.frame'
ncol(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nrow_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="nrow_+3A_...">...</code></td>
<td>
<p>passed to base::nrow</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# return total number of column and rows
ncol(cars.df)
nrow(cars.df)

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='overwrite_check'>Check if the outdir exists or not</h2><span id='topic+overwrite_check'></span>

<h3>Description</h3>

<p>If the overwrite is TRUE then the folder will be deleted, otherwise the folder will be created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overwrite_check(outdir, overwrite)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overwrite_check_+3A_outdir">outdir</code></td>
<td>
<p>the output directory</p>
</td></tr>
<tr><td><code id="overwrite_check_+3A_overwrite">overwrite</code></td>
<td>
<p>TRUE or FALSE if 'outdir&ldquo; exists and overwrite = FALSE then throw an error</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tf = tempfile()
overwrite_check(tf, overwrite = FALSE)
overwrite_check(tf, overwrite = TRUE)

# clean up
fs::dir_delete(tf)
</code></pre>

<hr>
<h2 id='partition_filter'>Filter the dataset based on folder partitions</h2><span id='topic+partition_filter'></span>

<h3>Description</h3>

<p>Filter the dataset based on folder partitions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partition_filter(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partition_filter_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="partition_filter_+3A_...">...</code></td>
<td>
<p>filtering conditions for filtering the disk.frame at (folder) partition level</p>
</td></tr>
</table>

<hr>
<h2 id='play'>Play the recorded lazy operations</h2><span id='topic+play'></span>

<h3>Description</h3>

<p>Play the recorded lazy operations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play(dataframe, recordings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play_+3A_dataframe">dataframe</code></td>
<td>
<p>A data.frame</p>
</td></tr>
<tr><td><code id="play_+3A_recordings">recordings</code></td>
<td>
<p>A recording the expression, globals and packages using create_chunk_mapper</p>
</td></tr>
</table>

<hr>
<h2 id='print.disk.frame'>Print disk.frame</h2><span id='topic+print.disk.frame'></span>

<h3>Description</h3>

<p>a new print method for disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.disk.frame_+3A_x">x</code></td>
<td>
<p>disk.frame</p>
</td></tr>
<tr><td><code id="print.disk.frame_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>

<hr>
<h2 id='pull.disk.frame'>Pull a column from table similar to 'dplyr::pull'.</h2><span id='topic+pull.disk.frame'></span>

<h3>Description</h3>

<p>Pull a column from table similar to 'dplyr::pull'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
pull(.data, var = -1, name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pull.disk.frame_+3A_.data">.data</code></td>
<td>
<p>The disk.frame</p>
</td></tr>
<tr><td><code id="pull.disk.frame_+3A_var">var</code></td>
<td>
<p>can be an positive or negative integer or a character/string. See dplyr::pull documentation</p>
</td></tr>
<tr><td><code id="pull.disk.frame_+3A_name">name</code></td>
<td>
<p>See dplyr::pull documentation</p>
</td></tr>
<tr><td><code id="pull.disk.frame_+3A_...">...</code></td>
<td>
<p>Not used, kept for compatibility with 'dplyr::pull'</p>
</td></tr>
</table>

<hr>
<h2 id='purrr_as_mapper'>Used to convert a function to purrr syntax if needed</h2><span id='topic+purrr_as_mapper'></span>

<h3>Description</h3>

<p>Used to convert a function to purrr syntax if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>purrr_as_mapper(.f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="purrr_as_mapper_+3A_.f">.f</code></td>
<td>
<p>a normal function or purrr syntax function i.e. '~ ...code...'</p>
</td></tr>
</table>

<hr>
<h2 id='rbindlist.disk.frame'>rbindlist disk.frames together</h2><span id='topic+rbindlist.disk.frame'></span>

<h3>Description</h3>

<p>rbindlist disk.frames together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbindlist.disk.frame(
  df_list,
  outdir = tempfile(fileext = ".df"),
  by_chunk_id = TRUE,
  parallel = TRUE,
  compress = 50,
  overwrite = TRUE,
  .progress = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbindlist.disk.frame_+3A_df_list">df_list</code></td>
<td>
<p>A list of disk.frames</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>Output directory of the row-bound disk.frames</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_by_chunk_id">by_chunk_id</code></td>
<td>
<p>If TRUE then only the chunks with the same chunk IDs will be bound</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_parallel">parallel</code></td>
<td>
<p>if TRUE then bind multiple disk.frame simultaneously, Defaults to TRUE</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_compress">compress</code></td>
<td>
<p>0-100, 100 being the highest compression rate.</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite the output directory</p>
</td></tr>
<tr><td><code id="rbindlist.disk.frame_+3A_.progress">.progress</code></td>
<td>
<p>A logical, for whether or not to show progress.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# row-bind two disk.frames
cars2.df = rbindlist.disk.frame(list(cars.df, cars.df))

# clean up cars.df
delete(cars.df)
delete(cars2.df)
</code></pre>

<hr>
<h2 id='rechunk'>Increase or decrease the number of chunks in the disk.frame</h2><span id='topic+rechunk'></span>

<h3>Description</h3>

<p>Increase or decrease the number of chunks in the disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rechunk(
  df,
  nchunks = disk.frame::nchunks(df),
  outdir = attr(df, "path", exact = TRUE),
  shardby = NULL,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rechunk_+3A_df">df</code></td>
<td>
<p>the disk.frame to rechunk</p>
</td></tr>
<tr><td><code id="rechunk_+3A_nchunks">nchunks</code></td>
<td>
<p>number of chunks</p>
</td></tr>
<tr><td><code id="rechunk_+3A_outdir">outdir</code></td>
<td>
<p>the output directory</p>
</td></tr>
<tr><td><code id="rechunk_+3A_shardby">shardby</code></td>
<td>
<p>the shardkeys</p>
</td></tr>
<tr><td><code id="rechunk_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite the output directory</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># create a disk.frame with 2 chunks in tempdir()
cars.df = as.disk.frame(cars, nchunks = 2)

# re-chunking cars.df to 3 chunks, done "in-place" to the same folder as cars.df
rechunk(cars.df, 3)

new_path = tempfile(fileext = ".df")
# re-chunking cars.df to 4 chunks, shard by speed, and done "out-of-place" to a new directory
cars2.df = rechunk(cars.df, 4, outdir=new_path, shardby = "speed")

# clean up cars.df
delete(cars.df)
delete(cars2.df)
</code></pre>

<hr>
<h2 id='recommend_nchunks'>Recommend number of chunks based on input size</h2><span id='topic+recommend_nchunks'></span>

<h3>Description</h3>

<p>Computes the recommended number of chunks to break a data.frame
into. It can accept filesizes in bytes (as integer) or a data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recommend_nchunks(
  df,
  type = "csv",
  minchunks = data.table::getDTthreads(),
  conservatism = 8,
  ram_size = df_ram_size()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recommend_nchunks_+3A_df">df</code></td>
<td>
<p>a disk.frame or the file size in bytes of a CSV file holding the
data</p>
</td></tr>
<tr><td><code id="recommend_nchunks_+3A_type">type</code></td>
<td>
<p>only = &quot;csv&quot; is supported. It indicates the file type
corresponding to file size 'df'</p>
</td></tr>
<tr><td><code id="recommend_nchunks_+3A_minchunks">minchunks</code></td>
<td>
<p>the minimum number of chunks. Defaults to the number of CPU
cores (without hyper-threading)</p>
</td></tr>
<tr><td><code id="recommend_nchunks_+3A_conservatism">conservatism</code></td>
<td>
<p>a multiplier to the recommended number of chunks. The
more chunks the smaller the chunk size and more likely that each chunk can
fit into RAM</p>
</td></tr>
<tr><td><code id="recommend_nchunks_+3A_ram_size">ram_size</code></td>
<td>
<p>The amount of RAM available which is usually computed. Except on RStudio with R3.6+</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># recommend nchunks based on data.frame
recommend_nchunks(cars)

# recommend nchunks based on file size ONLY CSV is implemented at the moment
recommend_nchunks(1024^3)
</code></pre>

<hr>
<h2 id='remove_chunk'>Removes a chunk from the disk.frame</h2><span id='topic+remove_chunk'></span>

<h3>Description</h3>

<p>Removes a chunk from the disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_chunk(df, chunk_id, full.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_chunk_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="remove_chunk_+3A_chunk_id">chunk_id</code></td>
<td>
<p>the chunk ID of the chunk to remove. If it's a number then return number.fst</p>
</td></tr>
<tr><td><code id="remove_chunk_+3A_full.names">full.names</code></td>
<td>
<p>TRUE or FALSE. Defaults to FALSE. If true then chunk_id is the full path to the chunk otherwise it's the relative path</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># TODO add these to tests
cars.df = as.disk.frame(cars, nchunks = 4)

# removes 3rd chunk
remove_chunk(cars.df, 3)
nchunks(cars.df) # 3

# removes 4th chunk
remove_chunk(cars.df, "4.fst")
nchunks(cars.df) # 3

# removes 2nd chunk
remove_chunk(cars.df, file.path(attr(cars.df, "path", exact=TRUE), "2.fst"), full.names = TRUE)
nchunks(cars.df) # 1

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='sample_frac.disk.frame'>Sample n rows from a disk.frame</h2><span id='topic+sample_frac.disk.frame'></span>

<h3>Description</h3>

<p>Sample n rows from a disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
sample_frac(tbl, size = 1, replace = FALSE, weight = NULL, .env = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_frac.disk.frame_+3A_tbl">tbl</code></td>
<td>
<p>A data.frame.</p>
</td></tr>
<tr><td><code id="sample_frac.disk.frame_+3A_size">size</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt;
For <code>sample_n()</code>, the number of rows to select.
For <code>sample_frac()</code>, the fraction of rows to select.
If <code>tbl</code> is grouped, <code>size</code> applies to each group.</p>
</td></tr>
<tr><td><code id="sample_frac.disk.frame_+3A_replace">replace</code></td>
<td>
<p>Sample with or without replacement?</p>
</td></tr>
<tr><td><code id="sample_frac.disk.frame_+3A_weight">weight</code></td>
<td>
<p>&lt;<code><a href="dplyr.html#topic+dplyr_tidy_select">tidy-select</a></code>&gt; Sampling weights.
This must evaluate to a vector of non-negative numbers the same length as
the input. Weights are automatically standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="sample_frac.disk.frame_+3A_.env">.env</code></td>
<td>
<p>DEPRECATED.</p>
</td></tr>
<tr><td><code id="sample_frac.disk.frame_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

collect(sample_frac(cars.df, 0.5))

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='select.disk.frame'>The dplyr verbs implemented for disk.frame</h2><span id='topic+select.disk.frame'></span><span id='topic+rename.disk.frame'></span><span id='topic+filter.disk.frame'></span><span id='topic+mutate.disk.frame'></span><span id='topic+transmute.disk.frame'></span><span id='topic+arrange.disk.frame'></span><span id='topic+chunk_arrange'></span><span id='topic+distinct.disk.frame'></span><span id='topic+chunk_distinct'></span><span id='topic+glimpse.disk.frame'></span>

<h3>Description</h3>

<p>Please see the dplyr document for their usage. Please note
'chunk_arrange' performs the actions within each chunk
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
select(.data, ...)

## S3 method for class 'disk.frame'
rename(.data, ...)

## S3 method for class 'disk.frame'
filter(.data, ...)

## S3 method for class 'disk.frame'
mutate(.data, ...)

## S3 method for class 'disk.frame'
transmute(.data, ...)

## S3 method for class 'disk.frame'
arrange(.data, ...)

chunk_arrange(.data, ...)

## S3 method for class 'disk.frame'
distinct(...)

chunk_distinct(.data, ...)

## S3 method for class 'disk.frame'
glimpse(x, width = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.disk.frame_+3A_.data">.data</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="select.disk.frame_+3A_...">...</code></td>
<td>
<p>Same as the dplyr functions</p>
</td></tr>
<tr><td><code id="select.disk.frame_+3A_x">x</code></td>
<td>
<p>'dplyr::glimpse' parameter</p>
</td></tr>
<tr><td><code id="select.disk.frame_+3A_width">width</code></td>
<td>
<p>'dplyr::glimpse' parameter</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
cars.df = as.disk.frame(cars)
mult = 2

# use all any of the supported dplyr
cars2 = cars.df %&gt;% 
  select(speed) %&gt;% 
  mutate(speed2 = speed * mult) %&gt;% 
  filter(speed &lt; 50) %&gt;% 
  rename(speed1 = speed) %&gt;% 
  collect

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='setup_disk.frame'>Set up disk.frame environment</h2><span id='topic+setup_disk.frame'></span>

<h3>Description</h3>

<p>Set up disk.frame environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup_disk.frame(
  workers = data.table::getDTthreads(),
  future_backend = future::multisession,
  ...,
  gui = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_disk.frame_+3A_workers">workers</code></td>
<td>
<p>the number of workers (background R processes in the</p>
</td></tr>
<tr><td><code id="setup_disk.frame_+3A_future_backend">future_backend</code></td>
<td>
<p>which future backend to use for parallelization</p>
</td></tr>
<tr><td><code id="setup_disk.frame_+3A_...">...</code></td>
<td>
<p>passed to 'future::plan'</p>
</td></tr>
<tr><td><code id="setup_disk.frame_+3A_gui">gui</code></td>
<td>
<p>Whether to use a Graphical User Interface (GUI) for selecting the options. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
  # setup disk.frame to use multiple workers these may use more than two
  # cores, and is therefore not allowed on CRAN. Hence it's set to run only in
  # interactive session
  setup_disk.frame()
  
  # use a Shiny GUI to adjust settings
  # only run in interactive()
  setup_disk.frame(gui = TRUE)
}

# set the number workers to 2
setup_disk.frame(2)

# if you do not wish to use multiple workers you can set it to sequential
setup_disk.frame(future_backend=future::sequential)
</code></pre>

<hr>
<h2 id='shard'>Shard a data.frame/data.table or disk.frame into chunk and saves it into a disk.frame</h2><span id='topic+shard'></span><span id='topic+distribute'></span>

<h3>Description</h3>

<p>Shard a data.frame/data.table or disk.frame into chunk and saves it into a disk.frame
</p>
<p>'distribute' is an alias for 'shard'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shard(
  df,
  shardby,
  outdir = tempfile(fileext = ".df"),
  ...,
  nchunks = recommend_nchunks(df),
  overwrite = FALSE
)

distribute(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shard_+3A_df">df</code></td>
<td>
<p>A data.frame/data.table or disk.frame. If disk.frame, then rechunk(df, ...) is run</p>
</td></tr>
<tr><td><code id="shard_+3A_shardby">shardby</code></td>
<td>
<p>The column(s) to shard the data by.</p>
</td></tr>
<tr><td><code id="shard_+3A_outdir">outdir</code></td>
<td>
<p>The output directory of the disk.frame</p>
</td></tr>
<tr><td><code id="shard_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="shard_+3A_nchunks">nchunks</code></td>
<td>
<p>The number of chunks</p>
</td></tr>
<tr><td><code id="shard_+3A_overwrite">overwrite</code></td>
<td>
<p>If TRUE then the chunks are overwritten</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# shard the cars data.frame by speed so that rows with the same speed are in the same chunk
iris.df = shard(iris, "Species")

# clean up cars.df
delete(iris.df)
</code></pre>

<hr>
<h2 id='shardkey'>Returns the shardkey (not implemented yet)</h2><span id='topic+shardkey'></span>

<h3>Description</h3>

<p>Returns the shardkey (not implemented yet)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shardkey(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shardkey_+3A_df">df</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
</table>

<hr>
<h2 id='shardkey_equal'>Compare two disk.frame shardkeys</h2><span id='topic+shardkey_equal'></span>

<h3>Description</h3>

<p>Compare two disk.frame shardkeys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shardkey_equal(sk1, sk2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shardkey_equal_+3A_sk1">sk1</code></td>
<td>
<p>shardkey1</p>
</td></tr>
<tr><td><code id="shardkey_equal_+3A_sk2">sk2</code></td>
<td>
<p>shardkey2</p>
</td></tr>
</table>

<hr>
<h2 id='show_ceremony'>Show the code to setup disk.frame</h2><span id='topic+show_ceremony'></span><span id='topic+ceremony_text'></span><span id='topic+show_boilerplate'></span><span id='topic+insert_ceremony'></span>

<h3>Description</h3>

<p>Show the code to setup disk.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>show_ceremony()

ceremony_text()

show_boilerplate()

insert_ceremony()
</code></pre>

<hr>
<h2 id='split_string_into_df'>Turn a string of the form /partion1=val/partion2=val2 into data.frame</h2><span id='topic+split_string_into_df'></span>

<h3>Description</h3>

<p>Turn a string of the form /partion1=val/partion2=val2 into data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_string_into_df(path_strs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_string_into_df_+3A_path_strs">path_strs</code></td>
<td>
<p>The paths in string form to break into partition format</p>
</td></tr>
</table>

<hr>
<h2 id='srckeep'>Keep only the variables from the input listed in selections</h2><span id='topic+srckeep'></span>

<h3>Description</h3>

<p>Keep only the variables from the input listed in selections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>srckeep(diskf, selections, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="srckeep_+3A_diskf">diskf</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="srckeep_+3A_selections">selections</code></td>
<td>
<p>The list of variables to keep from the input source</p>
</td></tr>
<tr><td><code id="srckeep_+3A_...">...</code></td>
<td>
<p>not yet used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# when loading cars's chunks into RAM, load only the column speed
collect(srckeep(cars.df, "speed"))

# clean up cars.df
delete(cars.df)
</code></pre>

<hr>
<h2 id='summarise.grouped_disk.frame'>A function to parse the summarize function</h2><span id='topic+summarise.grouped_disk.frame'></span><span id='topic+summarize.grouped_disk.frame'></span><span id='topic+group_by.disk.frame'></span><span id='topic+summarize.disk.frame'></span><span id='topic+summarise.disk.frame'></span>

<h3>Description</h3>

<p>The disk.frame group by operation perform group WITHIN each chunk. This is
often used for performance reasons. If the user wishes to perform group-by,
they may choose to use the 'hard_group_by' function which is expensive as it
reorganizes the chunks by the shard key.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grouped_disk.frame'
summarise(.data, ...)

## S3 method for class 'grouped_disk.frame'
summarize(.data, ...)

## S3 method for class 'disk.frame'
group_by(
  .data,
  ...,
  .add = FALSE,
  .drop = stop("disk.frame does not support `.drop` in `group_by` at this stage")
)

## S3 method for class 'disk.frame'
summarize(.data, ...)

## S3 method for class 'disk.frame'
summarise(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise.grouped_disk.frame_+3A_.data">.data</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="summarise.grouped_disk.frame_+3A_...">...</code></td>
<td>
<p>same as the dplyr::group_by</p>
</td></tr>
<tr><td><code id="summarise.grouped_disk.frame_+3A_.add">.add</code></td>
<td>
<p>from dplyr</p>
</td></tr>
<tr><td><code id="summarise.grouped_disk.frame_+3A_.drop">.drop</code></td>
<td>
<p>from dplyr</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>hard_group_by
</p>

<hr>
<h2 id='tbl_vars.disk.frame'>Column names for RStudio auto-complete</h2><span id='topic+tbl_vars.disk.frame'></span><span id='topic+group_vars.disk.frame'></span>

<h3>Description</h3>

<p>Returns the names of the columns. Needed for RStudio to complete variable
names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'disk.frame'
tbl_vars(x)

## S3 method for class 'disk.frame'
group_vars(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_vars.disk.frame_+3A_x">x</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
</table>

<hr>
<h2 id='var_df.chunk_agg.disk.frame'>One Stage function</h2><span id='topic+var_df.chunk_agg.disk.frame'></span><span id='topic+var_df.collected_agg.disk.frame'></span><span id='topic+sd_df.chunk_agg.disk.frame'></span><span id='topic+sd_df.collected_agg.disk.frame'></span><span id='topic+mean_df.chunk_agg.disk.frame'></span><span id='topic+mean_df.collected_agg.disk.frame'></span><span id='topic+sum_df.chunk_agg.disk.frame'></span><span id='topic+sum_df.collected_agg.disk.frame'></span><span id='topic+min_df.chunk_agg.disk.frame'></span><span id='topic+min_df.collected_agg.disk.frame'></span><span id='topic+max_df.chunk_agg.disk.frame'></span><span id='topic+max_df.collected_agg.disk.frame'></span><span id='topic+median_df.chunk_agg.disk.frame'></span><span id='topic+median_df.collected_agg.disk.frame'></span><span id='topic+n_df.chunk_agg.disk.frame'></span><span id='topic+n_df.collected_agg.disk.frame'></span><span id='topic+length_df.chunk_agg.disk.frame'></span><span id='topic+length_df.collected_agg.disk.frame'></span><span id='topic+any_df.chunk_agg.disk.frame'></span><span id='topic+any_df.collected_agg.disk.frame'></span><span id='topic+all_df.chunk_agg.disk.frame'></span><span id='topic+all_df.collected_agg.disk.frame'></span><span id='topic+n_distinct_df.chunk_agg.disk.frame'></span><span id='topic+n_distinct_df.collected_agg.disk.frame'></span><span id='topic+quantile_df.chunk_agg.disk.frame'></span><span id='topic+quantile_df.collected_agg.disk.frame'></span><span id='topic+IQR_df.chunk_agg.disk.frame'></span><span id='topic+IQR_df.collected_agg.disk.frame'></span>

<h3>Description</h3>

<p>One Stage function
</p>
<p>mean chunk_agg
</p>
<p>mean collected_agg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_df.chunk_agg.disk.frame(x, na.rm = FALSE)

var_df.collected_agg.disk.frame(listx)

sd_df.chunk_agg.disk.frame(x, na.rm = FALSE)

sd_df.collected_agg.disk.frame(listx)

mean_df.chunk_agg.disk.frame(x, na.rm = FALSE, ...)

mean_df.collected_agg.disk.frame(listx)

sum_df.chunk_agg.disk.frame(x, ...)

sum_df.collected_agg.disk.frame(listx, ...)

min_df.chunk_agg.disk.frame(x, ...)

min_df.collected_agg.disk.frame(listx, ...)

max_df.chunk_agg.disk.frame(x, ...)

max_df.collected_agg.disk.frame(listx, ...)

median_df.chunk_agg.disk.frame(x, ...)

median_df.collected_agg.disk.frame(listx, ...)

n_df.chunk_agg.disk.frame(...)

n_df.collected_agg.disk.frame(listx, ...)

length_df.chunk_agg.disk.frame(x, ...)

length_df.collected_agg.disk.frame(listx, ...)

any_df.chunk_agg.disk.frame(x, ...)

any_df.collected_agg.disk.frame(listx, ...)

all_df.chunk_agg.disk.frame(x, ...)

all_df.collected_agg.disk.frame(listx, ...)

n_distinct_df.chunk_agg.disk.frame(x, na.rm = FALSE, ...)

n_distinct_df.collected_agg.disk.frame(listx, ...)

quantile_df.chunk_agg.disk.frame(x, ...)

quantile_df.collected_agg.disk.frame(listx, ...)

IQR_df.chunk_agg.disk.frame(x, na.rm = FALSE, ...)

IQR_df.collected_agg.disk.frame(listx, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_df.chunk_agg.disk.frame_+3A_x">x</code></td>
<td>
<p>the input</p>
</td></tr>
<tr><td><code id="var_df.chunk_agg.disk.frame_+3A_na.rm">na.rm</code></td>
<td>
<p>Remove NAs. TRUE of FALSE</p>
</td></tr>
<tr><td><code id="var_df.chunk_agg.disk.frame_+3A_listx">listx</code></td>
<td>
<p>a list</p>
</td></tr>
<tr><td><code id="var_df.chunk_agg.disk.frame_+3A_...">...</code></td>
<td>
<p>additional options</p>
</td></tr>
</table>

<hr>
<h2 id='write_disk.frame'>Write disk.frame to disk</h2><span id='topic+write_disk.frame'></span><span id='topic+output_disk.frame'></span>

<h3>Description</h3>

<p>Write a data.frame/disk.frame to a disk.frame location. If df is a data.frame
then using the as.disk.frame function is recommended for most cases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_disk.frame(
  diskf,
  outdir = tempfile(fileext = ".df"),
  nchunks = ifelse("disk.frame" %in% class(diskf), nchunks.disk.frame(diskf),
    recommend_nchunks(diskf)),
  overwrite = FALSE,
  shardby = NULL,
  partitionby = NULL,
  compress = 50,
  ...
)

output_disk.frame(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_disk.frame_+3A_diskf">diskf</code></td>
<td>
<p>a disk.frame</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>output directory for the disk.frame</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_nchunks">nchunks</code></td>
<td>
<p>number of chunks</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite output directory</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_shardby">shardby</code></td>
<td>
<p>the columns to shard by</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_partitionby">partitionby</code></td>
<td>
<p>the columns to (folder) partition by</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_compress">compress</code></td>
<td>
<p>compression ratio for fst files</p>
</td></tr>
<tr><td><code id="write_disk.frame_+3A_...">...</code></td>
<td>
<p>passed to cmap.disk.frame</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cars.df = as.disk.frame(cars)

# write out a lazy disk.frame to disk
cars2.df = write_disk.frame(cmap(cars.df, ~.x[1,]), overwrite = TRUE)
collect(cars2.df)

# clean up cars.df
delete(cars.df)
delete(cars2.df)
</code></pre>

<hr>
<h2 id='zip_to_disk.frame'>'zip_to_disk.frame' is used to read and convert every CSV file within the zip
file to disk.frame format</h2><span id='topic+zip_to_disk.frame'></span>

<h3>Description</h3>

<p>'zip_to_disk.frame' is used to read and convert every CSV file within the zip
file to disk.frame format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zip_to_disk.frame(
  zipfile,
  outdir,
  ...,
  validation.check = FALSE,
  overwrite = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zip_to_disk.frame_+3A_zipfile">zipfile</code></td>
<td>
<p>The zipfile</p>
</td></tr>
<tr><td><code id="zip_to_disk.frame_+3A_outdir">outdir</code></td>
<td>
<p>The output directory for disk.frame</p>
</td></tr>
<tr><td><code id="zip_to_disk.frame_+3A_...">...</code></td>
<td>
<p>passed to fread</p>
</td></tr>
<tr><td><code id="zip_to_disk.frame_+3A_validation.check">validation.check</code></td>
<td>
<p>should the function perform a check at the end to check for validity of output. It can detect issues with conversion</p>
</td></tr>
<tr><td><code id="zip_to_disk.frame_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite output directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of disk.frame
</p>


<h3>See Also</h3>

<p>Other ingesting data: 
<code><a href="#topic+csv_to_disk.frame">csv_to_disk.frame</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create a zip file containing a csv
csvfile = tempfile(fileext = ".csv")
write.csv(cars, csvfile)
zipfile = tempfile(fileext = ".zip")
zip(zipfile, csvfile)

# read every file and convert it to a disk.frame
zip.df = zip_to_disk.frame(zipfile, tempfile(fileext = ".df"))

# there is only one csv file so it return a list of one disk.frame
zip.df[[1]]

# clean up
unlink(csvfile)
unlink(zipfile)
delete(zip.df[[1]])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
