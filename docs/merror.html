<!DOCTYPE html><html lang="en"><head><title>Help for package merror</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {merror}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha.beta.sigma'><p>Build an alpha-beta-sigma Matrix for Use with the cplot Function</p></a></li>
<li><a href='#beta.bar'><p> Compute the estimates of betas.</p></a></li>
<li><a href='#cb.pd'><p> Compute accuracy estimates and maximum likelihood estimates of precision for the</p>
constant bias measurement error model using paired data.</a></li>
<li><a href='#cplot'><p> Scatter plot of observations for a pair of devices with calibration curve.</p></a></li>
<li><a href='#errors.cb'><p> Extracts the estimated measurement errors assuming there is a constant bias and using the original data.</p></a></li>
<li><a href='#errors.nb'><p> Extracts the estimated measurement errors assuming there is no bias and using the original data.</p></a></li>
<li><a href='#errors.ncb'><p> Extracts the estimated measurement errors assuming there is a</p>
nonconstant bias and using the original data values.</a></li>
<li><a href='#lrt'><p> Likelihood ratio test for all betas equalling one.</p></a></li>
<li><a href='#merror.pairs'><p> A modified <code>"pairs"</code> plot with all axes haveing the same range.</p></a></li>
<li><a href='#mle'><p> Compute maximum likelihood estimates of precision.</p></a></li>
<li><a href='#mle.se2'><p> Compute squared standard errors for imprecision estimates for the</p>
constant bias model using paired data.</a></li>
<li><a href='#ncb.od'><p> Compute accuracy estimates and maximum likelihood estimates of precision for the</p>
nonconstant bias measurement error model using original data.</a></li>
<li><a href='#omx'><p>Compute full information maximum likelihood estimates of accuracy and precision for the</p>
nonconstant bias measurement error model using 'OpenMx'.</a></li>
<li><a href='#panel.merror'><p>Draw diagonal line (line of equality) on merror.pairs plots</p></a></li>
<li><a href='#pm2.5'><p> PM 2.5 Concentrations from SCAMP Collocated Samplers</p></a></li>
<li><a href='#precision.grubbs.cb.pd'><p> Computes Grubbs' method of moments estimators of precision for the</p>
constant bias model using paired differences.</a></li>
<li><a href='#precision.grubbs.ncb.od'><p>  Computes Grubbs' method of moments estimators of precision for the</p>
nonconstant bias model using original data values.</a></li>
<li><a href='#precision.mle.ncb.od'><p> Computes iterative approximation to mle precision estimates for nonconstant bias model using original data.</p></a></li>
<li><a href='#process.sd'><p>Compute process standard deviation</p></a></li>
<li><a href='#process.var.mle'><p> Compute process variance.</p></a></li>
<li><a href='#process.var.mle.jaech.err'><p> Compute process variance but with minor error in Jaech Fortran code.</p></a></li>
<li><a href='#redshift'><p> Spectroscopic and Photometric Galaxy Redshift Measurements</p></a></li>
<li><a href='#sigma_mle'><p> Computes the ith iteration for computing the</p>
squared imprecision estimates.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>3.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-01</td>
</tr>
<tr>
<td>Author:</td>
<td>Richard A. Bilonick &lt;rabilonick@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Richard A. Bilonick &lt;rabilonick@gmail.com&gt;</td>
</tr>
<tr>
<td>Title:</td>
<td>Accuracy and Precision of Measurements</td>
</tr>
<tr>
<td>Description:</td>
<td>N&gt;=3 methods are used to measure each of n items. 
 The data are used to estimate simultaneously systematic error (bias)
 and random error (imprecision). Observed measurements for each method
 or device are assumed to be linear functions of the unknown true values
 and the errors are assumed normally distributed. Pairwise calibration
 curves and plots can be easily generated. Unlike the 'ncb.od' function,
 the 'omx' function builds a one-factor measurement error model using 'OpenMx'
 and allows missing values, uses full information maximum likelihood to 
 estimate parameters, and provides both likelihood-based and bootstrapped 
 confidence intervals for all parameters, in addition to Wald-type intervals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, stats, utils, OpenMx</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-29 12:38:49 UTC; user</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-29 13:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha.beta.sigma'>Build an alpha-beta-sigma Matrix for Use with the cplot Function</h2><span id='topic+alpha.beta.sigma'></span>

<h3>Description</h3>

<p>Creates a <code class="reqn">3 \times N</code> (no. of methods) <code>matrix</code> consisting of the estimated alphas, betas, and imprecision sigmas for use with the <code>cplot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha.beta.sigma(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha.beta.sigma_+3A_x">x</code></td>
<td>
<p>A <code class="reqn">k \times 3</code> <code>data.frame</code> with parameter estimates in the second column where <code class="reqn">k</code> is the number of methods <code class="reqn">m \times 3</code>.  The estimates should be arranged with the estimated <code class="reqn">m-1</code> betas first, followed by the m residual variances, the variance of the true values, the <code class="reqn">m-1</code> alphas, the mean of the true values. The <code>omx</code> function returns the fitted model in <code>fit</code> from which parameter estimates can be retrieved.  See the examples below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is primarily a helper function used by the <code>omx</code> function.
</p>


<h3>Value</h3>

<p>A <code class="reqn">3 \times N</code> <code>matrix</code> consisting of alphas on the first row, betas on the second row, followed by raw imprecision sigmas.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cplot">cplot</a></code>, <code><a href="#topic+omx">omx</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(OpenMx)
library(merror)
data(pm2.5)
pm &lt;- pm2.5

# OpenMx does not like periods in data column names
names(pm) &lt;- c('ms_conc_1','ws_conc_1','ms_conc_2','ws_conc_2','frm')

# Fit model with FRM sampler as reference
omxfit &lt;- omx(data=pm[,c(5,1:4)],bs.q=c(0.025,0.5,0.975),reps=100)

# Extract the estimates
alpha.beta.sigma(summary(omxfit$fit)$parameters[,c(1,5,6)])

# Make a calibration plot
cplot(pm[,c(5,1:4)],1,2,alpha.beta.sigma=
  alpha.beta.sigma(summary(omxfit$fit)$parameters[,c(1,5,6)]))

# The easier way
cplot(pm[,c(5,1:4)],1,2,alpha.beta.sigma=omxfit$abs)

## End(Not run)
</code></pre>

<hr>
<h2 id='beta.bar'> Compute the estimates of betas. </h2><span id='topic+beta.bar'></span>

<h3>Description</h3>

<p>This function is used internally to compute the estimates of betas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.bar(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta.bar_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech, p. 184.
</p>


<h3>Value</h3>

<p>A vector of length N (no. of methods) containing the estimates of beta.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cb.pd">cb.pd</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
beta.bar(pm2.5) # estimate betas (accuracy parameter)

</code></pre>

<hr>
<h2 id='cb.pd'> Compute accuracy estimates and maximum likelihood estimates of precision for the
constant bias measurement error model using paired data. </h2><span id='topic+cb.pd'></span>

<h3>Description</h3>

<p>Compute accuracy estimates and maximum likelihood estimates of precision for the
constant bias measurement error model using paired data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cb.pd(x, conf.level = 0.95, M = 40)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cb.pd_+3A_x">x</code></td>
<td>
<p> n (no. of items) x N (no. of methods) matrix or data.frame containing the measurements. N must be &gt;= 3 and n &gt; N.</p>
</td></tr>
<tr><td><code id="cb.pd_+3A_conf.level">conf.level</code></td>
<td>
<p> Chosen onfidence level. </p>
</td></tr>
<tr><td><code id="cb.pd_+3A_m">M</code></td>
<td>
<p> Maximum no.of iterations to reach convergence. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measurement Error Model:
</p>
<p>x[i,k] = alpha[i] + beta[i]*mu[k] + epsilon[i,k]
</p>
<p>where x[i,k] is the measurement by the ith method for the kth item, i = 1 to N,
k = 1 to n, mu[k] is the true value for the kth item, epsilon[i,k] is the
Normally distributed random error with variance sigma[i] squared for the ith method and the kth item, and
alpha[i] and beta[i] are the accuracy parameters for the ith method.
</p>
<p>The imprecision for the ith method is sigma[i]. If all alphas are zeroes and all betas are ones, there is
no bias. If all betas equal 1, then there is a constant bias. Otherwise there is a nonconstant bias.
</p>
<p>ME (method of moments estimator) and MLE are the same for N=3 instruments
except for a factor of (n-1)/n: MLE = (n-1)/n * ME
</p>
<p>Using paired differences forces Constant Bias model (beta[1] = beta[2] = ... = beta[N]). Also,
the process variance CANNOT be estimated.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level used.</p>
</td></tr>
<tr><td><code>sigma.table</code></td>
<td>
<p>Table of accuracy and precision estimates and confidence
intervals.</p>
</td></tr>
<tr><td><code>n.items</code></td>
<td>
<p>No. of items.</p>
</td></tr>
<tr><td><code>N.methods</code></td>
<td>
<p>No. of methods</p>
</td></tr>
<tr><td><code>Grubbs.initial.sigma2</code></td>
<td>
<p>N vector of initial imprecision estimates using Grubbs' method</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>N vector of variances that measure the method imprecision.</p>
</td></tr>
<tr><td><code>sigma2.se2</code></td>
<td>
<p>N vector of squared standard errors of the estimated imprecisions (variances).</p>
</td></tr>
<tr><td><code>alpha.cb</code></td>
<td>
<p>N vector of estimated alphas for constant bias model.</p>
</td></tr>
<tr><td><code>alpha.ncb</code></td>
<td>
<p>N vector of estimated alphas for nonconstant bias model</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N vector of hypothesized betas for the constant bias model - all ones.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>N vector of estimated degrees of freedom.</p>
</td></tr>
<tr><td><code>chisq.low</code></td>
<td>
<p>N vector of chi-square values for the lower tail (used to compute the ci upper bound).</p>
</td></tr>
<tr><td><code>chisq.low</code></td>
<td>
<p>N vector of chi-square values for the upper tail (used to compute the ci lower bound).</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>N vector of lower bounds for confidence intervals</p>
</td></tr>
<tr><td><code>ub</code></td>
<td>
<p>N vector of upper bounds for confidence intervals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ncb.od">ncb.od</a></code>,
<code><a href="#topic+lrt">lrt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
cb.pd(pm2.5)

</code></pre>

<hr>
<h2 id='cplot'> Scatter plot of observations for a pair of devices with calibration curve. </h2><span id='topic+cplot'></span>

<h3>Description</h3>

<p>Creates a scatter plot for any pair of observations in the data.frame and 
superimposes the calibration curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cplot(df, i, j, leg.loc="topleft", regress=FALSE, lw=1, t.size=1, alpha.beta.sigma=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cplot_+3A_df">df</code></td>
<td>
<p> n (no. of items) x N (no. of methods) matrix or data.frame containing the measurements. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
<tr><td><code id="cplot_+3A_i">i</code></td>
<td>
<p> Select column i for device i. </p>
</td></tr>
<tr><td><code id="cplot_+3A_j">j</code></td>
<td>
<p> Select column j for device j not equal to i.</p>
</td></tr>
<tr><td><code id="cplot_+3A_leg.loc">leg.loc</code></td>
<td>
<p> Location of the legend. </p>
</td></tr>
<tr><td><code id="cplot_+3A_regress">regress</code></td>
<td>
<p> If TRUE, add both naive regression lines (for comparison only). </p>
</td></tr>
<tr><td><code id="cplot_+3A_lw">lw</code></td>
<td>
<p> Line widths.</p>
</td></tr>
<tr><td><code id="cplot_+3A_t.size">t.size</code></td>
<td>
<p> Text size.</p>
</td></tr>
<tr><td><code id="cplot_+3A_alpha.beta.sigma">alpha.beta.sigma</code></td>
<td>
<p> By default, <code>cplot</code> computes the bias (alpha, beta) and
imprecision (sigma) estimates using ncb.od. You can override this by specifying a
3 x N matrix of values with alpha on the first row, beta on the second row, and
sigma on the third row, in the same order as the methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, <code>cplot</code> displays the corresponding calibration curve for
devices i and j based on the parameter estimates for alpha, beta, and sigma computed
using <code>ncb.od</code>. You can overide this calibration curve by providing argument
alpha.beta.sigma with different estimates. Both naive regression lines (device i 
regressed on device j, and device j regressed on device i) by setting &quot;regress=TRUE&quot;. 
Note, however, that the calibration curve will fall somewhere between these two
regression lines, depending on the the ratio of the imprecision standard deviations
(sigmas). (This may not hold if there are missing measurement data values given that ordinary regression requires deleting any item with one or more missing values.)
</p>


<h3>Value</h3>

<p>Produces a scatter plot with the calibration curve and titles that includes the
calibration equation and the scale-bias adjusted imprecision standard deviations.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+merror.pairs">merror.pairs</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(merror)
data(pm2.5)

# Make various calibration plots for pm2.5 measurements
par(mfrow=c(2,2))
cplot(pm2.5,2,1)
cplot(pm2.5,3,1)
cplot(pm2.5,4,1)
# Add the naive regression lines JUST for comparison
cplot(pm2.5,5,1,regress=TRUE,t.size=0.9)

# This is redundant but illustrates using the
# argument alpha.beta.sigma
a &lt;- ncb.od(pm2.5)$sigma.table$alpha.ncb[1:5]
b &lt;- ncb.od(pm2.5)$sigma.table$beta[1:5]
s &lt;- ncb.od(pm2.5)$sigma.table$sigma[1:5]

alpha.beta.sigma &lt;- t(data.frame(a,b,s))

cplot(pm2.5,2,1,alpha.beta.sigma=alpha.beta.sigma)
cplot(pm2.5,2,1,alpha.beta.sigma=alpha.beta.sigma,regress=TRUE)
data(pm2.5)

## Not run: 
# Use omx function to specify the data for alpha.beta.sigma
pm &lt;- pm2.5

# omx uses OpenMx which does not like periods in data column names
names(pm) &lt;- c('ms_conc_1','ws_conc_1','ms_conc_2','ws_conc_2','frm')

# Fit one-factor measurement error model with FRM sampler as reference
omxfit &lt;- omx(data=pm[,c(5,1:4)],bs.q=c(0.025,0.5,0.975),reps=100)

# Make a calibration plot using the results from omx instead of the default ncb.od
cplot(pm[,c(5,1:4)],1,2,alpha.beta.sigma=omxfit$abs)

## End(Not run)


</code></pre>

<hr>
<h2 id='errors.cb'> Extracts the estimated measurement errors assuming there is a constant bias and using the original data. </h2><span id='topic+errors.cb'></span>

<h3>Description</h3>

<p>Extracts the estimated measurement errors assuming there is a constant bias and using the original data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errors.cb(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errors.cb_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Errors should have a zero mean and should be Normally distributed with constant variance for a given method.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>errors.cb</code></td>
<td>
<p> n x N matrix of estimated measurement errors. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley
</p>
<p>. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cb.pd">cb.pd</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
errors.cb(pm2.5)

</code></pre>

<hr>
<h2 id='errors.nb'> Extracts the estimated measurement errors assuming there is no bias and using the original data. </h2><span id='topic+errors.nb'></span>

<h3>Description</h3>

<p>Extracts the estimated measurement errors assuming there is no bias and using the original data
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errors.nb(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errors.nb_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Errors should have a zero mean and should be Normally distributed with constant variance for a given method.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>errors.nb</code></td>
<td>
<p>n x N matrix of estimated errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cb.pd">cb.pd</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
errors.nb(pm2.5)

</code></pre>

<hr>
<h2 id='errors.ncb'> Extracts the estimated measurement errors assuming there is a
nonconstant bias and using the original data values. </h2><span id='topic+errors.ncb'></span>

<h3>Description</h3>

<p>Extracts the estimated measurement errors assuming there is a
nonconstant bias and using the original data values.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>errors.ncb(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="errors.ncb_+3A_x">x</code></td>
<td>
<p>  A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Errors should have a zero mean and should be Normally distributed with constant variance for a given method.
</p>


<h3>Value</h3>

  
<table role = "presentation">
<tr><td><code>errors.ncb</code></td>
<td>
<p>n x N matrix of estimated errors.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cb.pd">cb.pd</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
errors.ncb(pm2.5)

</code></pre>

<hr>
<h2 id='lrt'> Likelihood ratio test for all betas equalling one. </h2><span id='topic+lrt'></span>

<h3>Description</h3>

<p>Likelihood ratio test statistic - H0: all betas = one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lrt(x, M = 40)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lrt_+3A_x">x</code></td>
<td>
<p> n (no. of items) x N (no. of methods) matrix or data.frame containing the measurements. N must be greater than 3 and n &gt; N.</p>
</td></tr>
<tr><td><code id="lrt_+3A_m">M</code></td>
<td>
<p> Maximum no. of iterations for convergence. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech, pp. 204-205.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>n.items</code></td>
<td>
<p>No.of items.</p>
</td></tr>
<tr><td><code>N.methods</code></td>
<td>
<p>No. of methods.'</p>
</td></tr>
<tr><td><code>beta.bars</code></td>
<td>
<p>N vector of estimated betas.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Chi-square test statistic.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>Degrees of freedom for the test (N-1).'</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>Empirical significance level for the observed test statistic.'</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ncb.od">ncb.od</a></code>,<code><a href="#topic+cb.pd">cb.pd</a></code>,<code><a href="#topic+pm2.5">pm2.5</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)

lrt(pm2.5) # compare all 5 samplers (4 personal and 1 frm)

lrt(pm2.5[,1:4]) # compare only the personal samplers

stem(lrt(pm2.5)$beta.bars) # examine the estimated betas

</code></pre>

<hr>
<h2 id='merror.pairs'> A modified <code>"pairs"</code> plot with all axes haveing the same range. </h2><span id='topic+merror.pairs'></span>

<h3>Description</h3>

<p>Creates all pairwise scatter plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merror.pairs(df,labels=names(df))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merror.pairs_+3A_df">df</code></td>
<td>
<p> n (no. of items) x N (no. of methods) matrix or data.frame containing the measurements. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
<tr><td><code id="merror.pairs_+3A_labels">labels</code></td>
<td>
<p>Provide labels for each device down the diagnoal of the pairs plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates all pairwise scatter plots with the same range for all axes and adds
the diagonal line denote the &quot;line of equality&quot; or &quot;no bias&quot;.).
</p>


<h3>Value</h3>

<p>Produces a scatter plot with the calibration curve and titles that include the
calibration equation and the scale-bias adjusted imprecision standard deviations.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>See Also</h3>

 <p><code><a href="#topic+panel.merror">panel.merror</a> </code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)

# All pairwise plots after square root transformation to Normality
merror.pairs(sqrt(pm2.5))

</code></pre>

<hr>
<h2 id='mle'> Compute maximum likelihood estimates of precision. </h2><span id='topic+mle'></span>

<h3>Description</h3>

<p>This is an internal function that computes the maximum likelihood estimates of precision for the constant
bias model using paired data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle(v, r, ni)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_+3A_v">v</code></td>
<td>
<p> Variance-Covariance matrix for the n x N items by methods measurement data. </p>
</td></tr>
<tr><td><code id="mle_+3A_r">r</code></td>
<td>
<p> Initial estimates of imprecision, usually Grubbs. </p>
</td></tr>
<tr><td><code id="mle_+3A_ni">ni</code></td>
<td>
<p> No. of items measured. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>An N vector containing the maximum likelihood estimates of precision.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>

<hr>
<h2 id='mle.se2'> Compute squared standard errors for imprecision estimates for the
constant bias model using paired data. </h2><span id='topic+mle.se2'></span>

<h3>Description</h3>

<p>This is an internal function that computes squared standard errors for imprecision estimates of the
constant bias model using paired data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle.se2(v, r, ni)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle.se2_+3A_v">v</code></td>
<td>
<p> Variance-Covariance matrix for the n x N items by methods measurement data. </p>
</td></tr>
<tr><td><code id="mle.se2_+3A_r">r</code></td>
<td>
<p> Initial estimates of imprecision, usually Grubbs </p>
</td></tr>
<tr><td><code id="mle.se2_+3A_ni">ni</code></td>
<td>
<p> No. of items measured </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the squared standard errors for the squared precisions. Before calling this function, compute the MLE's
</p>


<h3>Value</h3>

<p>An N+1 symmetric H matrix. See p. 201 of Jaech, 1985, eq. 6.4.2.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> J. L. Jaech, Statistical Analysis of Measurement Errors, Wiley, New
York: 1985. </p>

<hr>
<h2 id='ncb.od'> Compute accuracy estimates and maximum likelihood estimates of precision for the
nonconstant bias measurement error model using original data. </h2><span id='topic+ncb.od'></span>

<h3>Description</h3>

<p>Compute accuracy estimates and maximum likelihood estimates of precision for the
nonconstant bias measurement error model using original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ncb.od(x, beta = beta.bar(x), M = 40, conf.level = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ncb.od_+3A_x">x</code></td>
<td>
<p> n (no. of items) x N (no. of methods) <code>matrix</code> or <code>data.frame</code> containing the measurements. N must be &gt;= 3. Missing values are not allowed. </p>
</td></tr>
<tr><td><code id="ncb.od_+3A_beta">beta</code></td>
<td>
<p> N vector of betas, either estimated by <code>beta.bar</code> function or hypothesized. </p>
</td></tr>
<tr><td><code id="ncb.od_+3A_m">M</code></td>
<td>
<p> Maximum number of iterations for convergence. </p>
</td></tr>
<tr><td><code id="ncb.od_+3A_conf.level">conf.level</code></td>
<td>
<p> Chosen confidence level which must be greater than zero and less than one. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measurement Error Model:
</p>
<p>x[i,k] = alpha[i] + beta[i]*mu[k] + epsilon[i,k]
</p>
<p>where x[i,k] is the measurement by the ith method for the kth item, i = 1 to N,
k = 1 to n, mu[k] is the true value for the kth item, epsilon[i,k] is the
normally distributed random error with variance sigma[i] squared for the ith method and the kth item, and
alpha[i] and beta[i] are the accuracy parameters for the ith method.  The product of the betas is constrained to equal one (equivalently, the geometric average of the beta's is constrained to one).  When the betas are all equal to one, the average of the alphas equals zero (equivalently, the sum of the alphas is constrained to zero).
</p>
<p>The imprecision for the ith method is sigma[i]. If all alphas are zeroes and all betas are ones, there is
no bias.  If all betas equal 1, then there is a constant bias. If some of the betas differ from one there is a nonconstant bias.  Note that the individual betas are not unique - only ratios of the betas are unique.  If you divide all the betas by beta_i, then the betas represent the scale bias of the other devices/methods relative to device/method i.  Also, when the betas differ from one, the sigmas are not directly comparable because the measurement scales (size of the units) differ.  To make the sigmas comparable, divide them by their corresponding beta.  This result is shown as bias.adj.sigma.
</p>
<p>By using the original data values, the betas can be estimated and also the process variance, that is, the variance of the true values.
</p>
<p>Technically, the alphas and betas describe the measurements in terms of the unknown true values (i.e., the unknown true values can be thought of as a latent variable).  The &quot;true values&quot; are ALWAYS unknown (unless you have a real, highly accurate reference method/device).  The real goal is to calibrate one device/method in terms of another.  This is easily accomplished because each measurement is a function of the same unknow true values.  By solving the measurement error model (in expectation) for mu and substituting, any two devices/methods i=1 and i=2 can be be related as:
</p>
<p>E[x[1,k]] = alpha[1] - alpha[2]*beta[1]/beta[2] + beta[1]/beta[2]*E[x[2,k]]
</p>
<p>or equivalently
</p>
<p>E[x[2,k]] = alpha[2] - alpha[1]*beta[2]/beta[1] + beta[2]/beta[1]*E[x[1,k]].
</p>
<p>Use <code><a href="#topic+cplot">cplot</a></code> to display this calibration curve and the corresponding scale-bias adjusted imprecision standard deviations.
</p>
<p>The <code>omx</code> function is to be preferred to <code>ncb.od</code>. <code>omx</code> can accomodate missing measurement data values and can provide both likelihood-based confidence intervals and bootstrapped intervals for all parameters and relevant functions of parameters.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>conf.level</code></td>
<td>
<p>Confidence level used.</p>
</td></tr>
<tr><td><code>sigma.table</code></td>
<td>
<p>Table of accuracy and precision estimates and confidence
intervals.</p>
</td></tr>
<tr><td><code>n.items</code></td>
<td>
<p>No. of items.</p>
</td></tr>
<tr><td><code>N.methods</code></td>
<td>
<p>No. of methods</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>N vector of variances that measure the method imprecision.</p>
</td></tr>
<tr><td><code>alpha.cb</code></td>
<td>
<p>N vector of estimated alphas for constant bias model.</p>
</td></tr>
<tr><td><code>alpha.ncb</code></td>
<td>
<p>N vector of estimated alphas for nonconstant bias model.</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p>N vector of estimated or hypothesized betas.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>N vector of estimated degrees of freedom.</p>
</td></tr>
<tr><td><code>lb</code></td>
<td>
<p>N vector of lower bounds for confidence intervals.</p>
</td></tr>
<tr><td><code>ub</code></td>
<td>
<p>N vector of upper bounds for confidence intervals.</p>
</td></tr>
<tr><td><code>bias.adj.sigma</code></td>
<td>
<p>sigma adjusted for scale bias: sigma/beta.</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>N+1 symmetric H matrix (see p. 201, Jaech).</p>
</td></tr>
<tr><td><code>errors.nb</code></td>
<td>
<p>n x N matrix of estimated measurement errors for no bias model.</p>
</td></tr>
<tr><td><code>errors.cb</code></td>
<td>
<p>n x N matrix of estimated measurement errors for constant bias model.</p>
</td></tr>
<tr><td><code>errors.ncb</code></td>
<td>
<p>n x N matrix of estimated measurement errors for nonconstant bias model</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+cb.pd">cb.pd</a></code>, <code><a href="#topic+lrt">lrt</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(merror)
data(pm2.5)
ncb.od(pm2.5)               # nonconstant bias model using original data values
ncb.od(pm2.5,beta=rep(1,5)) # constant bias model using original data values

</code></pre>

<hr>
<h2 id='omx'>Compute full information maximum likelihood estimates of accuracy and precision for the
nonconstant bias measurement error model using 'OpenMx'. </h2><span id='topic+omx'></span>

<h3>Description</h3>

<p>Compute full information maximum likelihood (FIML) estimates of accuracy (bias) and precision (imprecision) for the
nonconstant bias measurement error model.  'OpenMx' functions are used to construct and fit a one latent factor model. Likelihood-based confidence intervals and bootstrapped confidence interval are can be determined for all model parameters and relevant functions of the model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>omx(data, rvEst=rep(1,ncol(data)), mubarEst=mean(data[,1]), interval=0.95, 
  reps=500,bs.q=c(0.025,0.975), bs=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="omx_+3A_data">data</code></td>
<td>
<p><code class="reqn">n</code> (no. of items) <code class="reqn">\times N</code> (no. of methods) <code>matrix</code> or <code>data.frame</code> containing the measurements. <code class="reqn">N</code> must be <code class="reqn">\ge 3</code>. Missing values are allowed.</p>
</td></tr>
<tr><td><code id="omx_+3A_rvest">rvEst</code></td>
<td>
<p>A <code>vector</code> of <code class="reqn">N</code> residual variance starting values, one for each corresponding method.</p>
</td></tr>
<tr><td><code id="omx_+3A_mubarest">mubarEst</code></td>
<td>
<p>A scalar starting value for estimating the the true mean value. </p>
</td></tr>
<tr><td><code id="omx_+3A_interval">interval</code></td>
<td>
<p>Confidence level for likelihood-based confidence intervals. Should be a scalar value greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="omx_+3A_reps">reps</code></td>
<td>
<p>Number of bootstrap samples. Ignored if <code>bs=FALSE</code>.</p>
</td></tr>
<tr><td><code id="omx_+3A_bs.q">bs.q</code></td>
<td>
<p>A <code>vector</code> of desired quantiles for bootstrapped samples. Default is <code>ci.q=c(0.025,0.975)</code>.</p>
</td></tr>
<tr><td><code id="omx_+3A_bs">bs</code></td>
<td>
<p>A boolean indicating whether bootstapped samples are to be generated. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Measurement Error Model:
</p>
<p style="text-align: center;"><code class="reqn">x_{ik}=\alpha_i+\beta_i\mu_k+\epsilon_{ik}</code>
</p>

<p>where <code class="reqn">x_{ik}</code> is the measurement by the ith of <code class="reqn">N</code> methods for the kth of <code class="reqn">n</code> items, <code class="reqn">i = 1</code> to <code class="reqn">N\ge 3</code>, <code class="reqn">k = 1</code> to <code class="reqn">n</code>, <code class="reqn">\mu_k</code> is the true value for the kth item, <code class="reqn">\epsilon_{ik}</code> is the
normally distributed random error with variance <code class="reqn">\sigma_i^2</code> for the ith method and the kth item, and
<code class="reqn">\alpha_i</code> and <code class="reqn">\beta_i</code> are the accuracy parameters for the ith method.  The beta for the first column of <code>data</code>) is set to one.  The corresponding alpha is set to 0.  These constraints or similar are required for model identification.
</p>
<p>The imprecision for the ith method is <code class="reqn">\sigma_i</code>. If all alphas are zeroes and all betas are ones, there is
no bias.  If all betas equal 1, then there is a constant bias.  If some of the betas differ from one there is a nonconstant bias.  Note that the individual betas are not unique - only ratios of the betas are unique. If you divide all the betas by <code class="reqn">\beta_i</code>, then the betas represent the scale bias of the other devices/methods relative to device/method <code class="reqn">i</code>.  Also, when the betas differ from one, the sigmas are not directly comparable because the measurement scales (size of the units) differ.  To make the sigmas comparable, divide them by their corresponding beta.
</p>
<p>Technically, the alphas and betas describe the measurements in terms of the unknown true values (i.e., the unknown true values can be thought of as a latent variable).  The &quot;true values&quot; are ALWAYS unknown (unless you have a real, highly accurate reference method/device). The real goal is to calibrate one device/method in terms of another.  This is easily accomplished because each measurement is a linear function of the same unknown true values.  For methods 1 and 2, the calibration curve is given by:
</p>
<p style="text-align: center;"><code class="reqn">E[x_{1k}]=\left(\alpha_1-\alpha_2\beta_1/\beta_2\right)+\left(\beta_1/\beta_2\right)E[x_{2k}]</code>
</p>

<p>or equivalently
</p>
<p style="text-align: center;"><code class="reqn">E[x_{2k}]=\left(\alpha_2-\alpha_1\beta_2/\beta_1\right)+\left(\beta_2/\beta_1\right)E[x_{1k}]</code>
</p>
<p>.
</p>
<p>Use <code><a href="#topic+cplot">cplot</a></code>, with the alpha.beta.sigma argument specified, to display this calibration curve, calibration equation, and the corresponding scale-bias adjusted imprecision standard deviations.
</p>
<p>Note that likelihood confidence intervals and bootstrapped confidence intervals can be returned.  Wald-type intervals based on the standard errors are alos available by using the <code>confint</code> function on the returned <code>fit</code> object. See examples.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>fit</code></td>
<td>
<p>'OpenMx' fit object containing the results (FIML parameter estimates, etc) </p>
</td></tr>
<tr><td><code>ci</code></td>
<td>
<p>Likelihood-based confidence intervals for all parameters and certain useful functions of parameters.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>Object created by 'mxBootstrap' 'OpenMx' function. Not returned if <code>bs=FALSE</code>.</p>
</td></tr>
<tr><td><code>q.boot</code></td>
<td>
<p><code>data.frame</code> containing the standard error and quantile estimates based on bootstrapped samples. Not returned if <code>bs=FALSE</code>.</p>
</td></tr>
<tr><td><code>abs</code></td>
<td>
<p>A <code class="reqn">3 \times N</code> <code>matrix</code> of the estimated alphas, betas, and the raw imprecision standard deviations for each of the <code class="reqn">N</code> methods. The results can be passed to the <code>merror</code> <code>cplot</code> to produce a calibration plot.</p>
</td></tr>
<tr><td><code>bsReps</code></td>
<td>
<p>Number of bootstrapped samples. Default is 500. Not returned if <code>bs=FALSE</code>.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The 'OpenMx' one-factor model. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The following names are used to describe the estimates:
</p>
<p>1) a1, a2, a3 and so forth denote the alphas (intercept).
</p>
<p>2) b1, b2, b3 and so forth denote the betas (scale or slope).
</p>
<p>3) ve1, ve2, ve3 and so forth denote the raw (uncorrected for scale) residual random error variances (imprecision variances).
</p>
<p>4) se1 denotes the imprecison standard deviation for the reference method.
</p>
<p>5) base2, base3 and so forth denote the scale bias-adjusted imprecision standard deviations on the scale of the reference method.
</p>
<p>6) mubar is the estimated mean of the true values on the scale of the reference method.
</p>
<p>7) sigma2 is the estimated variance of the true values on the scale of the reference method.
</p>
<p>8) sigma is the estimated standard deviation of the true values on the scale of the reference method.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ncb.od">ncb.od</a></code>, <code><a href="#topic+alpha.beta.sigma">alpha.beta.sigma</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(OpenMx)
library(merror)

data(pm2.5)

pm &lt;- pm2.5

# OpenMx does not like periods in data column names
names(pm) &lt;- c('ms_conc_1','ws_conc_1','ms_conc_2','ws_conc_2','frm')

# Fit model with FRM sampler as reference
omxfit &lt;- omx(data=pm[,c(5,1:4)],bs.q=c(0.025,0.5,0.975),reps=100)

# Look at results
summary(omxfit$fit)$parameters[,c(1,5,6)] # Parameter estimates and standard errors
round(omxfit$ci[,1:3],3) # Likelihood-based intervals

# Estimated standard errors and quantiles based on bootstrapped samples
round(omxfit$q.boot,3)

# Wald-type intervals
#   - note variances not standard deviations and different ordering
confint(omxfit$fit) 

omxfit$abs # Use with cplot

# Make a calibration plot using the results from omx instead of the default ncb.od
cplot(pm[,c(5,1:4)],1,2,alpha.beta.sigma=omxfit$abs)

## End(Not run)
</code></pre>

<hr>
<h2 id='panel.merror'>Draw diagonal line (line of equality) on merror.pairs plots</h2><span id='topic+panel.merror'></span>

<h3>Description</h3>

<p>This functionis used internally by the function
merror.pairs.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.merror(x,y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="panel.merror_+3A_x">x</code></td>
<td>
<p> A vector of measurements for one device, of length n. </p>
</td></tr>
<tr><td><code id="panel.merror_+3A_y">y</code></td>
<td>
<p> A vector of measurements for another device, of length n. </p>
</td></tr>
<tr><td><code id="panel.merror_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Draws the diagonal line that represents the &quot;line of equality&quot;, i.e., the &quot;no bias model&quot;.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>See Also</h3>

 <p><code><a href="#topic+merror.pairs">merror.pairs</a></code> </p>

<hr>
<h2 id='pm2.5'> PM 2.5 Concentrations from SCAMP Collocated Samplers</h2><span id='topic+pm2.5'></span>

<h3>Description</h3>

<p>Five filter-based samplers for measuring PM 2.5 concentrations were collocated and
provided 77 complete sets of concentrations. This data was collected by the
Stuebenville Comprehensive Air Monitoring Program (SCAMP) to check the accuracy and
precision of the instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pm2.5)</code></pre>


<h3>Format</h3>

<p>A data frame with 77 sets of PM 2.5 concentrations (micrograms per cubic meter) from the following 5 samplers:
</p>

<dl>
<dt>ms.conc.1</dt><dd><p>- personal sampler 1 - filter MS</p>
</dd>
<dt>ws.conc.1</dt><dd><p>- personal sampler 1 - filter WS</p>
</dd>
<dt>ms.conc.2</dt><dd><p>- personal sampler 2 - filter MS</p>
</dd>
<dt>ws.conc.2</dt><dd><p>- personal sampler 2 - filter WS</p>
</dd>
<dt>frm</dt><dd><p>- Federal Reference Method sampler</p>
</dd>
</dl>



<h3>Source</h3>

<p>Stuebenville Comprehensive Air Monitoring Program (SCAMP) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pm2.5)
boxplot(pm2.5)
merror.pairs(pm2.5)

# estimates of accuracy and precision
#   for nonconstant bias model using 
#   original data values
ncb.od(pm2.5)
</code></pre>

<hr>
<h2 id='precision.grubbs.cb.pd'> Computes Grubbs' method of moments estimators of precision for the
constant bias model using paired differences. </h2><span id='topic+precision.grubbs.cb.pd'></span>

<h3>Description</h3>

<p>This is an internal function that computes Grubbs' method of moments estimators of precision for the
constant bias model using paired differences 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision.grubbs.cb.pd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.grubbs.cb.pd_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech 1985, Chapters 3 &amp; 4, p. 144 in particular.
</p>


<h3>Value</h3>

<p>Estimated squared imprecision estimates (variances).
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley.</p>


<h3>See Also</h3>

 <p><code><a href="#topic+precision.grubbs.ncb.od">precision.grubbs.ncb.od</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>, <code><a href="#topic+cb.pd">cb.pd</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>

<hr>
<h2 id='precision.grubbs.ncb.od'>  Computes Grubbs' method of moments estimators of precision for the
nonconstant bias model using original data values. </h2><span id='topic+precision.grubbs.ncb.od'></span>

<h3>Description</h3>

<p>This is an internal function that computes Grubbs' method of moments estimators of precision for the
nonconstant bias model using original data values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision.grubbs.ncb.od(x, beta.bar.x = beta.bar(x))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.grubbs.ncb.od_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
<tr><td><code id="precision.grubbs.ncb.od_+3A_beta.bar.x">beta.bar.x</code></td>
<td>
<p> Either estimates of beta or hypothesized values (one for
each method in an N vector). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech, p. 184.
</p>


<h3>Value</h3>

<p>Grubbs' method of moments estimates of the squared imprecision (variances).
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

<p><code><a href="#topic+precision.grubbs.cb.pd">precision.grubbs.cb.pd</a></code>, <code><a href="#topic+ncb.od">ncb.od</a></code>, <code><a href="#topic+cb.pd">cb.pd</a></code>,<code><a href="#topic+lrt">lrt</a></code> </p>

<hr>
<h2 id='precision.mle.ncb.od'> Computes iterative approximation to mle precision estimates for nonconstant bias model using original data. </h2><span id='topic+precision.mle.ncb.od'></span>

<h3>Description</h3>

<p>This is an internal function that computes iterative approximation to mle precision estimates for nonconstant bias model using original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precision.mle.ncb.od(x, M = 20, beta.bars = beta.bar(x), jaech.errors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="precision.mle.ncb.od_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N (no. of methods) matrix of measuremnts. N must be &gt;= 3 and n &gt; N. </p>
</td></tr>
<tr><td><code id="precision.mle.ncb.od_+3A_m">M</code></td>
<td>
<p> Maximum no. of iterations for convergence. </p>
</td></tr>
<tr><td><code id="precision.mle.ncb.od_+3A_beta.bars">beta.bars</code></td>
<td>
<p> Estimates or hypothesized values for the betas. </p>
</td></tr>
<tr><td><code id="precision.mle.ncb.od_+3A_jaech.errors">jaech.errors</code></td>
<td>
<p> TRUE replicates the minor error in Jaech's Fortran code to allow comparison with his
examples. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Provides iterative approximation to MLE precision estimates for NonConstant Bias model using Original Data. See Jaech, p. 185-186.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>sigma2</code></td>
<td>
<p>Estimated squared imprecisions (variances) for methods.</p>
</td></tr>
<tr><td><code>sigma.mu2</code></td>
<td>
<p>Estimated process variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+precision.grubbs.ncb.od">precision.grubbs.ncb.od</a></code>,<code><a href="#topic+precision.grubbs.cb.pd">precision.grubbs.cb.pd</a></code> </p>

<hr>
<h2 id='process.sd'>Compute process standard deviation</h2><span id='topic+process.sd'></span>

<h3>Description</h3>

<p>This function computes the process standard
deviation and is used internally by the function
precision.grubbs.ncb.od.</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.sd(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.sd_+3A_x">x</code></td>
<td>
<p> A matrix or numeric data.frame consisting of an n (no. of items) by N
(no. of methods) matrix of measuremnts. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The process standard deviation is the standard deviation of the
true values uncontaminated by measurement error. See Jaech, p. 185.
</p>


<h3>Value</h3>

<p>A scalar containing the method of moments estimate of the process standard deviation.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+precision.grubbs.ncb.od">precision.grubbs.ncb.od</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pm2.5)
process.sd(pm2.5) # estimate of the sd of the "true values using the method of moments")

</code></pre>

<hr>
<h2 id='process.var.mle'> Compute process variance. </h2><span id='topic+process.var.mle'></span>

<h3>Description</h3>

<p>This is an internal function to compute the process variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.var.mle(sigma2, s, beta.bars, N, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.var.mle_+3A_sigma2">sigma2</code></td>
<td>
<p> Estimated imprecisions for each method in an N vector. </p>
</td></tr>
<tr><td><code id="process.var.mle_+3A_s">s</code></td>
<td>
<p> Variance-covariance N x N matrix. </p>
</td></tr>
<tr><td><code id="process.var.mle_+3A_beta.bars">beta.bars</code></td>
<td>
<p> Estimates or hypothesized values for the N betas. </p>
</td></tr>
<tr><td><code id="process.var.mle_+3A_n">N</code></td>
<td>
<p> No. of methods. </p>
</td></tr>
<tr><td><code id="process.var.mle_+3A_n">n</code></td>
<td>
<p> No. of items. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech p. 186  equations 6.37 - 6.3.10.
</p>


<h3>Value</h3>

<p>Estimated process variance.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>

<hr>
<h2 id='process.var.mle.jaech.err'> Compute process variance but with minor error in Jaech Fortran code. </h2><span id='topic+process.var.mle.jaech.err'></span>

<h3>Description</h3>

<p>This is an internal function to compute the process variance that replicates the minor
error in Jaech's Fortran code. This allows comparing merror estimates to those
shown in Jaech 1985.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process.var.mle.jaech.err(sigma2, s, beta.bars, N, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process.var.mle.jaech.err_+3A_sigma2">sigma2</code></td>
<td>
<p> Estimated imprecisions for each method in an N vector. </p>
</td></tr>
<tr><td><code id="process.var.mle.jaech.err_+3A_s">s</code></td>
<td>
<p> Variance-covariance N x N matrix. </p>
</td></tr>
<tr><td><code id="process.var.mle.jaech.err_+3A_beta.bars">beta.bars</code></td>
<td>
<p> Estimates or hypothesized values for the N betas </p>
</td></tr>
<tr><td><code id="process.var.mle.jaech.err_+3A_n">N</code></td>
<td>
<p> No. of methods. </p>
</td></tr>
<tr><td><code id="process.var.mle.jaech.err_+3A_n">n</code></td>
<td>
<p> No. of items. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech p. 186  equations 6.37 - 6.3.10.
Jaech p. 288 line 2330 has s[i,j] instead of s[j,j].
Jaech p. 288 line 2410 omits &quot;- 1/d2&quot;.  
</p>


<h3>Value</h3>

<p>Estimated process variance but replicating minor error in Jaech's Fortran code.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>

<hr>
<h2 id='redshift'> Spectroscopic and Photometric Galaxy Redshift Measurements </h2><span id='topic+redshift'></span>

<h3>Description</h3>

<p>The redshift observations were taken from DEEP 2 Galaxy Redshift Survey.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redshift)</code></pre>


<h3>Format</h3>

<p>Redshift measurements are usually denoted by <code class="reqn">z</code>. 
</p>
<p>A data frame with one spectroscopic redshift measurement and six different photometric measurements (by researcher) for 1432 galaxies:
</p>

<dl>
<dt>z_spec</dt><dd><p>Spectroscopic redshift</p>
</dd>
<dt>z_fink</dt><dd><p>Photometric redshift - S. Finklestein</p>
</dd>
<dt>z_font</dt><dd><p>Photometric redshift - A. Fontana</p>
</dd>
<dt>z_pfor</dt><dd><p>Photometric redshift - J. Pforr</p>
</dd>
<dt>z_salv</dt><dd><p>Photometric redshift - M. Salvator</p>
</dd>
<dt>z_wikl</dt><dd><p>Photometric redshift - T. Wiklind</p>
</dd>
<dt>z_wuyt</dt><dd><p>Photometric redshift - S. Wuyts</p>
</dd>
</dl>



<h3>Details</h3>

<p>Because the photometric methods depend on the same color information, a one-factor measurement error model incuding both the spectroscopic and photomentric measurements would not be a viable model because the photometric measurements would tend to be correlated. A two-factor model would be needed but would require at minimum replicated spectroscopic measurments.
</p>


<h3>Source</h3>

<p>&lt;https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20140013340.pdf&gt;
</p>


<h3>References</h3>

<p>Newman, Jeffrey A., Michael C. Cooper, Marc Davis, S. M. Faber, Alison L. Coil, Puragra Guhathakurta, David C. Koo et al. &quot;The DEEP2 Galaxy Redshift Survey: Design, observations, data reduction, and redshifts.&quot; The Astrophysical Journal Supplement Series 208, no. 1 (2013): 5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(OpenMx)
library(merror)

data(redshift)
merror.pairs(redshift)

# estimates of accuracy and precision
#   parameters for a one-factor
#   measurement error model
head(redshift)
merror.pairs(redshift)

## Not run: 
red &lt;- omx(redshift[,-1],reps=200) # Drop the spectroscopic measurements

summary(red$fit)
red$ci
red$q.boot

cplot(redshift[,-1],1,2,alpha.beta.sigma=red$abs)

## End(Not run)</code></pre>

<hr>
<h2 id='sigma_mle'> Computes the ith iteration for computing the
squared imprecision estimates. </h2><span id='topic+sigma_mle'></span>

<h3>Description</h3>

<p>This is an internal function that computes the ith iteration for computing the
squared imprecision estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sigma_mle(i, s, sigma2, sigma.mu2, beta.bars, N, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sigma_mle_+3A_i">i</code></td>
<td>
<p> Iteration i. </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_s">s</code></td>
<td>
<p> Variance-covariance N x N matrix. </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_sigma2">sigma2</code></td>
<td>
<p> Estimated imprecisions for each method in an N vector </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_sigma.mu2">sigma.mu2</code></td>
<td>
<p> Estimated process varinace. </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_beta.bars">beta.bars</code></td>
<td>
<p> Estimates or hypothesized values for the N betas. </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_n">N</code></td>
<td>
<p> No. of methods. </p>
</td></tr>
<tr><td><code id="sigma_mle_+3A_n">n</code></td>
<td>
<p> No. of items. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Jaech p. 185-186 equations 6.3.1 - 6.3.6.
</p>


<h3>Value</h3>

<p>Estimated squared imprecisions (variances) for the ith iteration.
</p>


<h3>Author(s)</h3>

<p> Richard A. Bilonick </p>


<h3>References</h3>

<p> Jaech, J. L. (1985) <em>Statistical Analysis of Measurement Errors</em>. New York: Wiley. </p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
