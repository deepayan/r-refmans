<!DOCTYPE html><html><head><title>Help for package rstan</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rstan}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rstan-package'><p>RStan &mdash; the <span class="rlang"><b>R</b></span> interface to Stan</p></a></li>
<li><a href='#as.array'><p>Create array, matrix, or data.frame objects from samples in a <code>stanfit</code> object</p></a></li>
<li><a href='#As.mcmc.list'><p>Create an mcmc.list from a stanfit object</p></a></li>
<li><a href='#check_hmc_diagnostics'><p>Check HMC diagnostics after sampling</p></a></li>
<li><a href='#Diagnostic plots'><p>RStan Diagnostic plots</p></a></li>
<li><a href='#expose_stan_functions'>
<p>Expose user-defined Stan functions to <span class="rlang"><b>R</b></span> for testing and simulation</p></a></li>
<li><a href='#extract'><p>Extract samples from a fitted Stan model</p></a></li>
<li><a href='#extract_sparse_parts'><p>Extract the compressed representation of a sparse matrix</p></a></li>
<li><a href='#gqs'><p>Draw samples of generated quantities from a Stan model</p></a></li>
<li><a href='#log_prob-methods'><p><code>log_prob</code> and <code>grad_log_prob</code> functions</p></a></li>
<li><a href='#loo_moment_match.stanfit'><p>Moment matching for efficient approximate leave-one-out cross-validation (LOO)</p></a></li>
<li><a href='#loo.stanfit'><p>Approximate leave-one-out cross-validation</p></a></li>
<li><a href='#lookup'>
<p>Look up the Stan function that corresponds to a <span class="rlang"><b>R</b></span> function or name.</p></a></li>
<li><a href='#makeconf_path'>
<p>Obtain the full path of file <code>Makeconf</code></p></a></li>
<li><a href='#monitor'><p>Compute summaries of MCMC draws and monitor convergence</p></a></li>
<li><a href='#nlist'><p>Created named lists</p></a></li>
<li><a href='#optimizing'><p>Obtain a point estimate by maximizing the joint posterior</p></a></li>
<li><a href='#pairs.stanfit'><p>Create a matrix of output plots from a <code>stanfit</code> object</p></a></li>
<li><a href='#plot-methods'><p>Plots for stanfit objects</p></a></li>
<li><a href='#Plots'><p>ggplot2 for RStan</p></a></li>
<li><a href='#print'><p>Print a summary for a fitted model represented by a <code>stanfit</code> object</p></a></li>
<li><a href='#read_rdump'><p>Read data in an <span class="rlang"><b>R</b></span> dump file to a list</p></a></li>
<li><a href='#read_stan_csv'><p>Read CSV files of samples generated by (R)Stan into a <code>stanfit</code> object</p></a></li>
<li><a href='#Rhat'>
<p>Convergence and efficiency diagnostics for Markov Chains</p></a></li>
<li><a href='#rstan_gg_options'><p>Set default appearance options</p></a></li>
<li><a href='#rstan_options'><p>Set and read options used in RStan</p></a></li>
<li><a href='#rstan-internal'><p>Internal Functions and Methods</p></a></li>
<li><a href='#rstan-plotting-functions'><p>RStan Plotting Functions</p></a></li>
<li><a href='#rstan.package.skeleton'><p>Create a Skeleton for a New Source Package with Stan Programs</p></a></li>
<li><a href='#sampling'><p>Draw samples from a Stan model</p></a></li>
<li><a href='#sbc'><p>Simulation Based Calibration (sbc)</p></a></li>
<li><a href='#set_cppo'><p>Defunct function to set the compiler optimization level</p></a></li>
<li><a href='#sflist2stanfit'><p>Merge a list of stanfit objects into one</p></a></li>
<li><a href='#stan'><p>Fit a model with Stan</p></a></li>
<li><a href='#stan_demo'><p>Demonstrate examples included in Stan</p></a></li>
<li><a href='#stan_model'><p>Construct a Stan model</p></a></li>
<li><a href='#stan_rdump'>
<p>Dump the data for a Stan model to <span class="rlang"><b>R</b></span> dump file</p>
in the limited format that Stan can read.</a></li>
<li><a href='#stan_version'><p>Obtain the version of Stan</p></a></li>
<li><a href='#stanc'>
<p>Translate Stan model specification to C++ code</p></a></li>
<li><a href='#stanfit-class'><p>Class <code>stanfit</code>: fitted Stan model</p></a></li>
<li><a href='#stanmodel-class'><p>Class representing model compiled from C++</p></a></li>
<li><a href='#summary-methods'><p>Summary method for stanfit objects</p></a></li>
<li><a href='#traceplot'><p>Markov chain traceplots</p></a></li>
<li><a href='#vb'><p>Run Stan's variational algorithm for approximate posterior sampling</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Interface to Stan</td>
</tr>
<tr>
<td>Version:</td>
<td>2.32.6</td>
</tr>
<tr>
<td>Description:</td>
<td>User-facing R functions are provided to parse, compile, test,
    estimate, and analyze Stan models by accessing the header-only Stan library
    provided by the 'StanHeaders' package. The Stan project develops a probabilistic
    programming language that implements full Bayesian statistical inference
    via Markov Chain Monte Carlo, rough Bayesian inference via 'variational'
    approximation, and (optionally penalized) maximum likelihood estimation via
    optimization. In all three cases, automatic differentiation is used to quickly
    and accurately evaluate gradients without burdening the user with the need to
    derive the partial derivatives.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats4, inline (&ge; 0.3.19), gridExtra (&ge; 2.3), Rcpp
(&ge; 1.0.7), RcppParallel (&ge; 5.1.4), loo (&ge; 2.4.1), pkgbuild
(&ge; 1.2.0), QuickJSR, ggplot2 (&ge; 3.3.5)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), StanHeaders (&ge; 2.32.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.7), RcppEigen (&ge; 0.3.4.0.0), BH (&ge; 1.75.0-0),
StanHeaders (&ge; 2.32.0), RcppParallel (&ge; 5.1.4)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.4), parallel, KernSmooth, shinystan,
bayesplot, rmarkdown, rstantools, rstudioapi, Matrix, knitr,
coda, V8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mc-stan.org/rstan/">https://mc-stan.org/rstan/</a>, <a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/stan-dev/rstan/issues/">https://github.com/stan-dev/rstan/issues/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make, pandoc</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 23:38:11 UTC; ben</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiqiang Guo [aut],
  Jonah Gabry [aut],
  Ben Goodrich [cre, aut],
  Andrew Johnson [aut],
  Sebastian Weber [aut],
  Hamada S. Badr <a href="https://orcid.org/0000-0002-9808-2344"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Daniel Lee [ctb],
  Krzysztof Sakrejda [ctb],
  Modrak Martin [ctb],
  Trustees of Columbia University [cph],
  Oleg Sklyar [cph] (R/cxxfunplus.R),
  The R Core Team [cph] (R/pairs.R, R/dynGet.R),
  Jens Oehlschlaegel-Akiyoshi [cph] (R/pairs.R),
  John Maddock [cph] (gamma.hpp),
  Paul Bristow [cph] (gamma.hpp),
  Nikhar Agrawal [cph] (gamma.hpp),
  Christopher Kormanyos [cph] (gamma.hpp),
  Bronder Steve [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Goodrich &lt;benjamin.goodrich@columbia.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rstan-package'>RStan &mdash; the <span class="rlang"><b>R</b></span> interface to Stan</h2><span id='topic+rstan-package'></span><span id='topic+rstan'></span>

<h3>Description</h3>


<p><img src="../help/figures/stanlogo.png" width="50" alt="mc-stan.org" />
<em>Stan Development Team</em>

</p>
<p>RStan is the <span class="rlang"><b>R</b></span> interface to the <a href="https://mc-stan.org/">Stan</a> C++ package.
The RStan interface (<span class="pkg">rstan</span> <span class="rlang"><b>R</b></span> package) provides:
</p>

<ul>
<li><p> Full Bayesian inference using the No-U-Turn sampler (NUTS),
a variant of Hamiltonian Monte Carlo (HMC)
</p>
</li>
<li><p> Approximate Bayesian inference using automatic differentiation
variational inference (ADVI)
</p>
</li>
<li><p> Penalized maximum likelihood estimation using L-BFGS optimization
</p>
</li></ul>

<p>For documentation on Stan itself, including the manual and user guide
for the modeling language, case studies and worked examples, and other
tutorial information visit the Users section of the Stan website:
</p>

<ul>
<li> <p><a href="https://mc-stan.org/users/documentation/">mc-stan.org/users/documentation</a>
</p>
</li></ul>



<h3>Other <span class="rlang"><b>R</b></span> packages from the Stan Development Team</h3>

<p>Various related <span class="rlang"><b>R</b></span> packages are also available from the Stan Development Team including these and more:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <strong>Package</strong> </td><td style="text-align: left;"> <strong>Description</strong> </td><td style="text-align: left;"> <strong>Doc</strong> </td><td style="text-align: left;"> <strong>Website</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <span class="pkg">bayesplot</span>
    </td><td style="text-align: left;"> ggplot-based plotting of parameter estimates, diagnostics, and posterior predictive checks.
    </td><td style="text-align: left;"> <a href="bayesplot.html#topic+bayesplot-package">bayesplot-package</a>
    </td><td style="text-align: left;"> <a href="https://mc-stan.org/bayesplot/">mc-stan.org/bayesplot</a>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  <span class="pkg">shinystan</span>
    </td><td style="text-align: left;"> Interactive GUI for exploring MCMC output.
    </td><td style="text-align: left;"> <a href="shinystan.html#topic+shinystan-package">shinystan-package</a>
    </td><td style="text-align: left;"> <a href="https://mc-stan.org/shinystan/">mc-stan.org/shinystan</a>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  <span class="pkg">loo</span>
    </td><td style="text-align: left;"> Out-of-sample predictive performance estimates and model comparison.
    </td><td style="text-align: left;"> <a href="loo.html#topic+loo-package">loo-package</a>
    </td><td style="text-align: left;"> <a href="https://mc-stan.org/loo/">mc-stan.org/loo</a>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  <span class="pkg">rstanarm</span>
    </td><td style="text-align: left;"> <span class="rlang"><b>R</b></span> formula interface for applied regression modeling.
    </td><td style="text-align: left;"> <a href="rstanarm.html#topic+rstanarm-package">rstanarm-package</a>
    </td><td style="text-align: left;"> <a href="https://mc-stan.org/rstanarm/">mc-stan.org/rstanarm</a>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  <span class="pkg">rstantools</span>
    </td><td style="text-align: left;"> Tools for developers of <span class="rlang"><b>R</b></span> packages interfacing with Stan.
    </td><td style="text-align: left;"> <a href="rstantools.html#topic+rstantools-package">rstantools-package</a>
    </td><td style="text-align: left;"> <a href="https://mc-stan.org/rstantools/">mc-stan.org/rstantools</a>
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Author(s)</h3>


<table>
<tr>
 <td style="text-align: left;">
    Jonah Gabry (author)</td><td style="text-align: left;"> &lt;jonah.sol.gabry@columbia.edu&gt; </td>
</tr>
<tr>
 <td style="text-align: left;">
    Ben Goodrich (maintainer, author)</td><td style="text-align: left;"> &lt;benjamin.goodrich@columbia.edu&gt; </td>
</tr>
<tr>
 <td style="text-align: left;">
    Jiqiang Guo (author)</td><td style="text-align: left;"> &lt;guojq28@gmail.com&gt; </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>There are also many other important contributors to RStan
(<a href="https://github.com/stan-dev/rstan">github.com/rstan</a>).
Please use 'Stan Development Team' whenever citing the R interface to Stan.
A BibTex entry is available from <a href="https://mc-stan.org/rstan/authors">https://mc-stan.org/rstan/authors</a>
or <code>citation("rstan")</code>.
</p>


<h3>See Also</h3>


<ul>
<li><p> The RStan vignettes: <a href="https://mc-stan.org/rstan/articles/">https://mc-stan.org/rstan/articles/</a>.
</p>
</li>
<li> <p><code><a href="#topic+stan">stan</a></code> for details on fitting models and
<code><a href="#topic+stanfit-class">stanfit</a></code> for information on the fitted model objects.
</p>
</li>
<li><p> The <code><a href="#topic+lookup">lookup</a></code> for finding a function in the Stan language
that corresponds to a <span class="rlang"><b>R</b></span> function or name.
</p>
</li>
<li> <p><a href="https://github.com/stan-dev/rstan/issues/">https://github.com/stan-dev/rstan/issues/</a> to submit a bug
report or feature request.
</p>
</li>
<li> <p><a href="https://discourse.mc-stan.org">https://discourse.mc-stan.org</a> to ask a
question on the Stan Forums.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

stanmodelcode &lt;- "
data {
  int&lt;lower=0&gt; N;
  array[N] real y;
}

parameters {
  real mu;
}

model {
  target += normal_lpdf(mu | 0, 10);
  target += normal_lpdf(y  | mu, 1);
}
"

y &lt;- rnorm(20)
dat &lt;- list(N = 20, y = y);
fit &lt;- stan(model_code = stanmodelcode, model_name = "example",
            data = dat, iter = 2012, chains = 3, verbose = TRUE,
            sample_file = file.path(tempdir(), 'norm.csv'))
print(fit)

# extract samples
e &lt;- extract(fit, permuted = FALSE) # return a list of arrays
str(e)

arr &lt;- as.array(fit) # return an array
str(arr)

mat &lt;- as.matrix(fit) # return a matrix
str(mat)

## End(Not run)</code></pre>

<hr>
<h2 id='as.array'>Create array, matrix, or data.frame objects from samples in a <code>stanfit</code> object</h2><span id='topic+is.array.stanfit'></span><span id='topic+as.array.stanfit'></span><span id='topic+as.matrix.stanfit'></span><span id='topic+as.data.frame.stanfit'></span><span id='topic+dim.stanfit'></span><span id='topic+dimnames.stanfit'></span><span id='topic+names.stanfit'></span><span id='topic+names+3C-.stanfit'></span>

<h3>Description</h3>

<p>The samples (without warmup) included in a <code><a href="#topic+stanfit-class">stanfit</a></code> 
object can be coerced to an <code>array</code>, <code>matrix</code>, or <code>data.frame</code>.
Methods are also provided for checking and setting names and dimnames.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'stanfit'
as.array(x, ...) 
  ## S3 method for class 'stanfit'
as.matrix(x, ...)
  ## S3 method for class 'stanfit'
as.data.frame(x, ...)
  ## S3 method for class 'stanfit'
is.array(x) 
  ## S3 method for class 'stanfit'
dim(x)
  ## S3 method for class 'stanfit'
dimnames(x)
  ## S3 method for class 'stanfit'
names(x)
  ## S3 replacement method for class 'stanfit'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.array_+3A_x">x</code></td>
<td>
<p>An object of S4 class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="as.array_+3A_...">...</code></td>
<td>
<p>Additional parameters that can be passed to <code><a href="#topic+extract">extract</a></code> 
for extracting samples from <code>x</code>. For now, <code>pars</code>
is the only additional parameter supported.
</p>
</td></tr>
<tr><td><code id="as.array_+3A_value">value</code></td>
<td>
<p>For the <code>names</code> replacement method, a character vector to 
set/replace the parameter names in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>as.array</code> and <code>as.matrix</code> can be applied to a <code>stanfit</code>
object to coerce the samples without warmup to <code>array</code> or <code>matrix</code>.
The <code>as.data.frame</code> method first calls <code>as.matrix</code> and then coerces
this matrix to a <code>data.frame</code>.
</p>
<p>The array has three named dimensions: iterations, chains, parameters. 
For <code>as.matrix</code>, all chains are combined, leaving a matrix of iterations
by parameters.
</p>


<h3>Value</h3>

<p><code>as.array</code>, <code>as.matrix</code>, and <code>as.data.frame</code> return an array,
matrix, and data.frame, respectively.
</p>
<p><code>dim</code> and <code>dimnames</code> return the dim and dimnames of the 
array object that could be created, while <code>names</code> returns the third
element of the <code>dimnames</code>, which are the names of the margins of the
posterior distribution. The <code>names</code> assignment method allows for 
assigning more interpretable names to them.
</p>
<p><code>is.array</code> returns <code>TRUE</code> for <code>stanfit</code> objects that include
samples; otherwise <code>FALSE</code>. 
</p>
<p>When the <code>stanfit</code> object does not contain samples, empty objects
are returned from <code>as.array</code>, <code>as.matrix</code>, <code>as.data.frame</code>,
<code>dim</code>, <code>dimnames</code>, and <code>names</code>. 
</p>


<h3>See Also</h3>

<p>S4 class <code><a href="#topic+stanfit-class">stanfit</a></code> and its method <code><a href="#topic+extract">extract</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ex_model_code &lt;- '
  parameters {
    array[2, 3] real alpha;
    array[2] real beta; 
  } 
  model {
    for (i in 1:2) for (j in 1:3) 
      alpha[i, j] ~ normal(0, 1); 
    for (i in 1:2) 
      beta[i] ~ normal(0, 2); 
    # beta ~ normal(0, 2) // vectorized version
  } 
'

## fit the model 
fit &lt;- stan(model_code = ex_model_code, chains = 4) 

dim(fit)
dimnames(fit)
is.array(fit) 
a &lt;- as.array(fit)
m &lt;- as.matrix(fit)
d &lt;- as.data.frame(fit)

## End(Not run)</code></pre>

<hr>
<h2 id='As.mcmc.list'>Create an mcmc.list from a stanfit object</h2><span id='topic+As.mcmc.list'></span>

<h3>Description</h3>

<p>Create an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> (<span class="pkg">coda</span>) 
from a <code>stanfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  As.mcmc.list(object, pars, include = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="As.mcmc.list_+3A_object">object</code></td>
<td>
<p>object of class <code>"stanfit"</code></p>
</td></tr>
<tr><td><code id="As.mcmc.list_+3A_pars">pars</code></td>
<td>
<p>optional character vector of parameters to include</p>
</td></tr>
<tr><td><code id="As.mcmc.list_+3A_include">include</code></td>
<td>
<p>logical scalar indicating whether to include (the default) or 
exclude the parameters named in <code>pars</code></p>
</td></tr>
<tr><td><code id="As.mcmc.list_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.
</p>

<hr>
<h2 id='check_hmc_diagnostics'>Check HMC diagnostics after sampling</h2><span id='topic+check_hmc_diagnostics'></span><span id='topic+check_divergences'></span><span id='topic+check_treedepth'></span><span id='topic+check_energy'></span><span id='topic+get_divergent_iterations'></span><span id='topic+get_max_treedepth_iterations'></span><span id='topic+get_num_leapfrog_per_iteration'></span><span id='topic+get_num_divergent'></span><span id='topic+get_num_max_treedepth'></span><span id='topic+get_bfmi'></span><span id='topic+get_low_bfmi_chains'></span>

<h3>Description</h3>

<p>These functions print summaries of important HMC diagnostics or extract
those diagnostics from a <code>stanfit</code> object. See the <strong>Details</strong>
section, below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_hmc_diagnostics(object)
check_divergences(object)
check_treedepth(object)
check_energy(object)

get_divergent_iterations(object)
get_max_treedepth_iterations(object)
get_num_leapfrog_per_iteration(object)

get_num_divergent(object)
get_num_max_treedepth(object)

get_bfmi(object)
get_low_bfmi_chains(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_hmc_diagnostics_+3A_object">object</code></td>
<td>
<p>A stanfit object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>check_hmc_diagnostics</code> function calls the other <code>check_*</code> 
functions internally and prints an overall summary, but the other 
functions can also be called directly: 
</p>

<ul>
<li> <p><code>check_divergences</code> prints the number (and percentage) of 
iterations that ended with a divergence,
</p>
</li>
<li> <p><code>check_treedepth</code> prints the number (and percentage) of iterations 
that saturated the max treedepth, 
</p>
</li>
<li> <p><code>check_energy</code> prints E-BFMI values for each chain for which E-BFMI 
is less than 0.2. 
</p>
</li></ul>

<p>The <code>get_*</code> functions are for programmatic access to the diagnostics. 
</p>

<ul>
<li> <p><code>get_divergent_iterations</code> and <code>get_max_treedepth_iterations</code> 
return a logical vector indicating problems for individual iterations,
</p>
</li>
<li> <p><code>get_num_divergent</code> and <code>get_num_max_treedepth</code> return the 
number of offending interations, 
</p>
</li>
<li> <p><code>get_num_leapfrog_per_iteration</code> returns an integer vector with the 
number of leapfrog evalutions for each iteration,
</p>
</li>
<li> <p><code>get_bfmi</code> returns per-chain E-BFMI values and <code>get_low_bfmi_chains</code>
returns the indices of chains with low E-BFMI.
</p>
</li></ul>

<p>The following are several of many resources that provide more information on 
these diagnostics:
</p>

<ul>
<li><p> Brief explanations of some of the problems detected by these diagnostics 
can be found in the <a href="https://mc-stan.org/misc/warnings.html"><em>Brief Guide to Stan's Warnings</em></a>.
</p>
</li>
<li><p> Betancourt (2017) provides much more depth on these diagnostics
as well as a conceptual introduction to Hamiltonian Monte Carlo in general.
</p>
</li>
<li><p> Gabry et al. (2018) and the <span class="pkg">bayesplot</span>
package <a href="https://mc-stan.org/bayesplot/articles/">vignettes</a> demonstrate
various visualizations of these diagnostics that can be made in <span class="rlang"><b>R</b></span>.
</p>
</li></ul>



<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>
<p>Betancourt, M. (2017). A conceptual introduction to Hamiltonian Monte Carlo.
<a href="https://arxiv.org/abs/1701.02434">https://arxiv.org/abs/1701.02434</a>.
</p>
<p>Gabry, J., Simpson, D., Vehtari, A., Betancourt, M., and Gelman, A. (2018). 
Visualization in Bayesian workflow. 
<em>Journal of the Royal Statistical Society Series A</em>, accepted for publication.
arXiv preprint: https://arxiv.org/abs/1709.01449.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
schools &lt;- stan_demo("eight_schools")
check_hmc_diagnostics(schools)
check_divergences(schools)
check_treedepth(schools)
check_energy(schools)

## End(Not run)
</code></pre>

<hr>
<h2 id='Diagnostic+20plots'>RStan Diagnostic plots</h2><span id='topic+stan_diag'></span><span id='topic+stan_par'></span><span id='topic+stan_rhat'></span><span id='topic+stan_ess'></span><span id='topic+stan_mcse'></span>

<h3>Description</h3>

<p>Diagnostic plots for HMC and NUTS using ggplot2. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stan_diag(object, 
            information = c("sample","stepsize", "treedepth","divergence"), 
            chain = 0, ...)
  stan_par(object, par, chain = 0, ...)
  
  stan_rhat(object, pars, ...)
  stan_ess(object, pars, ...)
  stan_mcse(object, pars, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Diagnostic+2B20plots_+3A_object">object</code></td>
<td>
<p>A stanfit or stanreg object.</p>
</td></tr>
<tr><td><code id="Diagnostic+2B20plots_+3A_information">information</code></td>
<td>
<p>The information to be contained in the diagnostic plot.</p>
</td></tr>
<tr><td><code id="Diagnostic+2B20plots_+3A_par">par</code>, <code id="Diagnostic+2B20plots_+3A_pars">pars</code></td>
<td>
<p>The name of a single scalar parameter (<code>par</code>) or 
one or more parameter names (<code>pars</code>).</p>
</td></tr>
<tr><td><code id="Diagnostic+2B20plots_+3A_chain">chain</code></td>
<td>
<p>If <code>chain=0</code> (the default) all chains are combined.
Otherwise the plot for <code>chain</code> is overlaid on the plot for all chains
combined.</p>
</td></tr>
<tr><td><code id="Diagnostic+2B20plots_+3A_...">...</code></td>
<td>
<p>For <code>stan_diag</code> and <code>stan_par</code>, optional arguments to 
<code><a href="gridExtra.html#topic+arrangeGrob">arrangeGrob</a></code>. For <code>stan_rhat</code>, <code>stan_ess</code>, 
and <code>stan_mcse</code>, optional arguments to <code>stat_bin</code> in the 
<span class="pkg">ggplot2</span> package.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>stan_rhat</code>,<code>stan_ess</code>,<code>stan_mcse</code></dt><dd><p>Respectively, 
these plots show the 
distribution of the Rhat statistic, the ratio of effective sample size to 
total sample size, and the ratio of Monte Carlo standard error
to posterior standard deviation for the estimated parameters. These 
plots are not intended to identify individual parameters, but rather to allow
for quickly identifying if the estimated values of these quantities are
desireable for all parameters.</p>
</dd>
<dt><code>stan_par</code></dt><dd><p>Calling <code>stan_par</code> generates three plots: 
(i) a scatterplot of <code>par</code> vs. the accumulated log-posterior (<code>lp__</code>), 
(ii) a scatterplot of <code>par</code> vs. the average Metropolis acceptance rate 
(<code>accept_stat</code>), and 
(iii) a violin plot showing the distribution of <code>par</code> at each of the 
sampled step sizes (one per chain).
For the scatterplots, red points are superimposed to indicate which 
(if any) iterations encountered a divergent transition. Yellow points indicate 
a transition that hit the maximum treedepth rather than terminated its 
evolution normally.</p>
</dd>
<dt><code>stan_diag</code></dt><dd><p>The <code>information</code> argument is used to specify which 
plots <code>stan_diag</code> should generate:
</p>

<ul>
<li> <p><code>information='sample'</code> Histograms of <code>lp__</code> 
and <code>accept_stat</code>, as well as a scatterplot showing their 
joint distribution.
</p>
</li>
<li> <p><code>information='stepsize'</code> Violin plots showing the 
distributions of <code>lp__</code> and <code>accept_stat</code> at each of the sampled
step sizes (one per chain).
</p>
</li>
<li> <p><code>information='treedepth'</code> Histogram of <code>treedepth</code> and 
violin plots showing the distributions of <code>lp__</code> and 
<code>accept_stat</code> for each value of <code>treedepth</code>.
</p>
</li>
<li> <p><code>information='divergence'</code> Violin plots showing the 
distributions of <code>lp__</code> and <code>accept_stat</code> for iterations that
encountered divergent transitions (<code>divergent=1</code>) and those that
did not (<code>divergent=0</code>).
</p>
</li></ul>

</dd>
</dl>



<h3>Value</h3>

<p>For <code>stan_diag</code> and <code>stan_par</code>, a list containing the ggplot objects for 
each of the displayed plots. For <code>stan_rhat</code>, <code>stan_ess</code>, 
and <code>stan_mcse</code>, a single ggplot object.
</p>


<h3>Note</h3>

<p>For details about the individual diagnostics and sampler parameters and their
interpretations see the Stan Modeling Language User's Guide and Reference 
Manual at <a href="https://mc-stan.org/documentation/">https://mc-stan.org/documentation/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstan-plotting-functions">List of RStan plotting functions</a></code>,
<code><a href="#topic+rstan_gg_options">Plot options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- stan_demo("eight_schools")

stan_diag(fit, info = 'sample') # shows three plots together
samp_info &lt;- stan_diag(fit, info = 'sample') # saves the three plots in a list
samp_info[[3]] # access just the third plot

stan_diag(fit, info = 'sample', chain = 1) # overlay chain 1

stan_par(fit, par = "mu")

## End(Not run)
</code></pre>

<hr>
<h2 id='expose_stan_functions'>
Expose user-defined Stan functions to <span class="rlang"><b>R</b></span> for testing and simulation
</h2><span id='topic+expose_stan_functions'></span><span id='topic+get_stream'></span><span id='topic+get_rng'></span>

<h3>Description</h3>

<p>The Stan modeling language allows users to define their own functions in a 
<code>functions</code> block at the top of a Stan program. The 
<code>expose_stan_functions</code> utility function uses
<code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code> to export those user-defined functions
to the specified environment for testing inside <span class="rlang"><b>R</b></span> or for doing posterior
predictive simulations in <span class="rlang"><b>R</b></span> rather than in the <code>generated 
  quantities</code> block of a Stan program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  expose_stan_functions(stanmodel, includes = NULL, 
                        show_compiler_warnings = FALSE, ...)
  get_rng(seed = 0L)
  get_stream()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expose_stan_functions_+3A_stanmodel">stanmodel</code></td>
<td>

<p>A <code><a href="#topic+stanmodel-class">stanmodel</a></code> object, a <code><a href="#topic+stanfit-class">stanfit</a></code> 
object, a list produced by <code><a href="#topic+stanc">stanc</a></code> or the path to a Stan 
program (<code>.stan</code> file). In any of these cases, the underlying Stan 
program should contain a non-empty <code>functions</code> block.
</p>
</td></tr>
<tr><td><code id="expose_stan_functions_+3A_includes">includes</code></td>
<td>
<p>If not <code>NULL</code> (the default), then a character vector of
length one (possibly containing one or more <code>"\n"</code>) of the form 
<code>'#include "/full/path/to/my_header.hpp"'</code>, which will be inserted
into the C++ code in the model's namespace and can be used to provide definitions 
of functions that are declared but not defined in <code>stanmodel</code>
</p>
</td></tr>
<tr><td><code id="expose_stan_functions_+3A_show_compiler_warnings">show_compiler_warnings</code></td>
<td>
<p>Logical scalar defaulting to <code>FALSE</code> that
controls whether compiler warnings, which can be numerous and have never
been relevant, are shown</p>
</td></tr>
<tr><td><code id="expose_stan_functions_+3A_seed">seed</code></td>
<td>
<p>An integer vector of length one indicating the state of Stan's
pseudo-random number generator</p>
</td></tr>
<tr><td><code id="expose_stan_functions_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>expose_stan_functions</code> function requires as much compliance with
the C++14 standard as is implemented in the RTools toolchain for Windows.
On Windows, you will likely need to specify <code>CXX14 = g++ -std=c++1y</code>
in the file whose path is <code><a href="base.html#topic+normalizePath">normalizePath</a>("~/.R/Makevars")</code> in
order for <code>expose_stan_functions</code> to work. Outside of Windows, the
necessary compiler flags are set programatically, which is likely to suffice.
</p>
<p>There are a few special types of user-defined Stan functions for which some 
additional details are relevant:
</p>


<h4>(P)RNG functions</h4>

<p>If a user-defined Stan function ends in <code>_rng</code>, then it can
use the Boost pseudo-random number generator used by Stan. When exposing
such functions to <span class="rlang"><b>R</b></span>, <code>base_rng__</code> and <code>pstream__</code> arguments will 
be added to the <code><a href="base.html#topic+formals">formals</a></code>. The <code>base_rng__</code> argument should
be passed the result of a call to <code>get_rng</code> (perhaps specifying its
<code>seed</code> argument for reproducibility) and the <code>pstream__</code> should
be passed the result of a call to <code>get_stream</code>, which can be used to
see the result of <code>print</code> and <code>reject</code> calls in the user-defined
Stan functions. These arguments default to <code>get_stream()</code> and
<code>get_rng()</code> respectively.
</p>



<h4>LP functions</h4>

<p>If a user-defined Stan function ends in <code>_lp</code>, then it can
modify the log-probability used by Stan to evaluate Metropolis
proposals or as an objective function for optimization. When exposing
such functions to <span class="rlang"><b>R</b></span>, a <code>lp__</code> argument will be added to the 
<code><a href="base.html#topic+formals">formals</a></code>. This <code>lp__</code> argument defaults to zero, but a 
<code><a href="base.html#topic+double">double</a></code> precision scalar may be  passed to this argument when the 
function is called from <span class="rlang"><b>R</b></span>. Such a user-defined Stan function can terminate 
with <code>return target();</code> or can execute <code>print(target());</code> to verify that 
the calculation is correct.
</p>



<h3>Value</h3>

<p>The names of the new functions in <code>env</code> are returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="Rcpp.html#topic+sourceCpp">sourceCpp</a></code> and the section in the Stan User Manual on
user-defined functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
model_code &lt;-
  '
  functions {
    real standard_normal_rng() {
      return normal_rng(0,1);
   }
  }
'
expose_stan_functions(stanc(model_code = model_code))
standard_normal_rng()
PRNG &lt;- get_rng(seed = 3)
o &lt;- get_stream()
standard_normal_rng(PRNG, o)

## End(Not run)
</code></pre>

<hr>
<h2 id='extract'>Extract samples from a fitted Stan model</h2><span id='topic+extract'></span><span id='topic+extract+2Cstanfit-method'></span>

<h3>Description</h3>

<p>Extract samples from a fitted model represented by an 
instance of class <code><a href="#topic+stanfit-class">stanfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'stanfit'
extract(object, pars, permuted = TRUE, inc_warmup = FALSE, 
  include = TRUE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_pars">pars</code></td>
<td>
<p>An optional character vector providing the parameter
names (or other quantity names) of interest. If not specified,
all parameters and other quantities are used. The log-posterior with
name <code>lp__</code> is also included by default.</p>
</td></tr> 
<tr><td><code id="extract_+3A_permuted">permuted</code></td>
<td>
<p>A logical scalar indicating whether the draws
after the <em>warmup</em> period in each chain should be <em>permuted</em> and 
<em>merged</em>. If <code>FALSE</code>, the original order is kept. For each 
<code>stanfit</code> object, the permutation is fixed (i.e., extracting samples 
a second time will give the same sequence of iterations).</p>
</td></tr>
<tr><td><code id="extract_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>A logical scalar indicating whether to include
the warmup draws. This argument is only relevant if <code>permuted</code> is 
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="extract_+3A_include">include</code></td>
<td>
<p>A logical scalar indicating whether the parameters
named in <code>pars</code> should be included (<code>TRUE</code>) or excluded 
(<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>permuted = TRUE</code>, this function returns a named list,  
every element of which is an array representing samples for a parameter
with all chains merged together.
</p>
<p>When <code>permuted = FALSE</code>, an array is returned; the first
dimension is for the iterations, the second for the number of chains, the 
third for the parameters. Vectors and arrays are expanded to one 
parameter (a scalar) per cell, with names indicating the third dimension.
See the examples (with comments) below. The <code><a href="#topic+monitor">monitor</a></code> function
can be applied to the returned array to obtain a summary 
(similar to the <code>print</code> method for <code><a href="#topic+stanfit-class">stanfit</a></code> objects).
</p>


<h3>Methods</h3>


<dl>
<dt>extract</dt><dd><p><code>signature(object = "stanfit")</code>
Extract samples from a fitted model represented by an instance of class 
<code><a href="#topic+stanfit-class">stanfit</a></code>.  
</p>
</dd>
</dl>



<h3>See Also</h3>

<p>S4 class <code><a href="#topic+stanfit-class">stanfit</a></code>, <code><a href="#topic+as.array.stanfit">as.array.stanfit</a></code>, and
<code><a href="#topic+monitor">monitor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ex_model_code &lt;- '
  parameters {
    array[2, 3] real alpha;
    array[2] real beta; 
  } 
  model {
    for (i in 1:2) for (j in 1:3) 
      alpha[i, j] ~ normal(0, 1); 
    for (i in 1:2) 
      beta ~ normal(0, 2); 
  } 
'

## fit the model 
fit &lt;- stan(model_code = ex_model_code, chains = 4) 

## extract alpha and beta with 'permuted = TRUE' 
fit_ss &lt;- extract(fit, permuted = TRUE) # fit_ss is a list 
## list fit_ss should have elements with name 'alpha', 'beta', 'lp__'
alpha &lt;- fit_ss$alpha  
beta &lt;- fit_ss$beta 
## or extract alpha by just specifying pars = 'alpha' 
alpha2 &lt;- extract(fit, pars = 'alpha', permuted = TRUE)$alpha 
print(identical(alpha, alpha2)) 

## or extract alpha by excluding beta and lp__
alpha3 &lt;- extract(fit, pars = c('beta', 'lp__'), 
                  permuted = TRUE, include = FALSE)$alpha
print(identical(alpha, alpha3))

## get the samples for alpha[1,1] and beta[2] 
alpha_11 &lt;- alpha[, 1, 1] 
beta_2 &lt;- beta[, 2] 

## extract samples with 'permuted = FALSE' 
fit_ss2 &lt;- extract(fit, permuted = FALSE) # fit_ss2 is an array  

## the dimensions of fit_ss2 should be  
## "# of iterations * # of chains * # of parameters"
dim(fit_ss2) 

## since the third dimension of `fit_ss2` indicates 
## parameters, the names should be 
##  alpha[1,1], alpha[2,1], alpha[1,2], alpha[2,2], 
##  alpha[1,3], alpha[2,3], beta[1], beta[2], and lp__ 
## `lp__` (the log-posterior) is always included 
## in the samples.  
dimnames(fit_ss2) 

## End(Not run)

# Create a stanfit object from reading CSV files of samples (saved in rstan
# package) generated by funtion stan for demonstration purpose from model as follows. 
# 
excode &lt;- '
  transformed data {
    array[20] real y;
    y[1] &lt;- 0.5796;  y[2]  &lt;- 0.2276;   y[3] &lt;- -0.2959; 
    y[4] &lt;- -0.3742; y[5]  &lt;- 0.3885;   y[6] &lt;- -2.1585;
    y[7] &lt;- 0.7111;  y[8]  &lt;- 1.4424;   y[9] &lt;- 2.5430; 
    y[10] &lt;- 0.3746; y[11] &lt;- 0.4773;   y[12] &lt;- 0.1803; 
    y[13] &lt;- 0.5215; y[14] &lt;- -1.6044;  y[15] &lt;- -0.6703; 
    y[16] &lt;- 0.9459; y[17] &lt;- -0.382;   y[18] &lt;- 0.7619;
    y[19] &lt;- 0.1006; y[20] &lt;- -1.7461;
  }
  parameters {
    real mu;
    real&lt;lower=0, upper=10&gt; sigma;
    vector[2] z[3];
    real&lt;lower=0&gt; alpha;
  } 
  model {
    y ~ normal(mu, sigma);
    for (i in 1:3) 
      z[i] ~ normal(0, 1);
    alpha ~ exponential(2);
  } 
'
# exfit &lt;- stan(model_code = excode, save_dso = FALSE, iter = 200, 
#               sample_file = "rstan_doc_ex.csv")
# 
exfit &lt;- read_stan_csv(dir(system.file('misc', package = 'rstan'),
                       pattern='rstan_doc_ex_[[:digit:]].csv',
                       full.names = TRUE))

ee1 &lt;- extract(exfit, permuted = TRUE)
print(names(ee1))

for (name in names(ee1)) {
  cat(name, "\n")
  print(dim(ee1[[name]]))
}

ee2 &lt;- extract(exfit, permuted = FALSE)
print(dim(ee2))
print(dimnames(ee2))
</code></pre>

<hr>
<h2 id='extract_sparse_parts'>Extract the compressed representation of a sparse matrix</h2><span id='topic+extract_sparse_parts'></span>

<h3>Description</h3>

<p>Create a list of vectors that represents a sparse matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sparse_parts(A)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_sparse_parts_+3A_a">A</code></td>
<td>
<p>A <code><a href="base.html#topic+matrix">matrix</a></code> or <code><a href="Matrix.html#topic+Matrix">Matrix</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stan Math Library has a function called <code>csr_matrix_times_vector</code>,
which inputs a matrix in compressed row storage form and a dense vector and
returns their product without fillin. To use the 
<code>csr_matrix_times_vector</code> function with a large
sparse matrix, it is optimal in terms of memory to simply pass the three vectors
that characterize the compressed row storage form of the matrix to the 
<code>data</code> block of the Stan program. 
The <code>extract_sparse_parts</code> function provides a convenient means of 
obtaining these vectors.
</p>


<h3>Value</h3>

<p>A named list with components 
</p>
 
<ol>
<li> <p><code>w</code> A numeric vector containing the non-zero elements of <code>A</code>.
</p>
</li>
<li> <p><code>v</code> An integer vector containing the column indices of the non-zero
elements of <code>A</code>.
</p>
</li>
<li> <p><code>u</code> An integer vector indicating where in <code>w</code> a given row's
non-zero values start.
</p>
</li></ol>
 


<h3>Examples</h3>

<pre><code class='language-R'>  A &lt;- rbind(
    c(19L, 27L,  0L,  0L),
    c( 0L,  0L,  0L,  0L),
    c( 0L,  0L,  0L, 52L),
    c(81L,  0L, 95L, 33L)
  )
  str(extract_sparse_parts(A))
</code></pre>

<hr>
<h2 id='gqs'>Draw samples of generated quantities from a Stan model</h2><span id='topic+gqs'></span><span id='topic+gqs+2Cstanmodel-method'></span>

<h3>Description</h3>

<p>Draw samples from the generated quantities block of a 
<code><a href="#topic+stanmodel-class">stanmodel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'stanmodel'
gqs(object, data = list(), draws, 
    seed = sample.int(.Machine$integer.max, size = 1L))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gqs_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanmodel-class">stanmodel</a></code>.</p>
</td></tr>
<tr><td><code id="gqs_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code>
providing the data for the model or a character vector 
for all the names of objects used as data. 
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr> 
<tr><td><code id="gqs_+3A_draws">draws</code></td>
<td>
<p>A matrix of posterior draws, typically created by
calling <code>as.matrix</code> on a <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="gqs_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated 
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine.
When a seed is specified by a number, <code>as.integer</code> will be applied to it. 
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly. 
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S4 class <code><a href="#topic+stanmodel-class">stanmodel</a></code> representing
the fitted results. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>object</code></dt><dd><p><code>signature(object = "stanmodel")</code> 
Evaluate the generated quantities block of a Stan program
by supplying <code>data</code> and the <code>draws</code> output from a
previous Stan program.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stanmodel-class">stanmodel</a></code>, <code><a href="#topic+stanfit-class">stanfit</a></code>, <code><a href="#topic+stan">stan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
f &lt;- sampling(m, iter = 300)
mc &lt;-
'
parameters {real y;}
generated quantities {real y_rep = normal_rng(y, 1);}
'
m2 &lt;- stan_model(model_code = mc)
f2 &lt;- gqs(m2, draws = as.matrix(f))
f2

## End(Not run)</code></pre>

<hr>
<h2 id='log_prob-methods'><code>log_prob</code> and <code>grad_log_prob</code> functions</h2><span id='topic+log_prob'></span><span id='topic+log_prob+2Cstanfit-method'></span><span id='topic+grad_log_prob'></span><span id='topic+grad_log_prob+2Cstanfit-method'></span><span id='topic+constrain_pars'></span><span id='topic+constrain_pars+2Cstanfit-method'></span><span id='topic+unconstrain_pars'></span><span id='topic+unconstrain_pars+2Cstanfit-method'></span><span id='topic+get_num_upars'></span><span id='topic+get_num_upars+2Cstanfit-method'></span>

<h3>Description</h3>

<p>Using model's <code>log_prob</code> and <code>grad_log_prob</code> take values from the
unconstrained space of model parameters and (by default) return values in 
the same space. Sometimes we need to convert the values of parameters from 
their support defined in the parameters block (which might be constrained, 
and for simplicity, we call it the constrained space) to the unconstrained 
space and vice versa. The <code>constrain_pars</code> and <code>unconstrain_pars</code> 
functions are used for this purpose.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S4 method for signature 'stanfit'
log_prob(object, upars, adjust_transform = TRUE, gradient = FALSE)
  
  ## S4 method for signature 'stanfit'
grad_log_prob(object, upars, adjust_transform = TRUE)
  
  ## S4 method for signature 'stanfit'
get_num_upars(object)
  
  ## S4 method for signature 'stanfit'
constrain_pars(object, upars)
  
  ## S4 method for signature 'stanfit'
unconstrain_pars(object, pars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_prob-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="log_prob-methods_+3A_pars">pars</code></td>
<td>
<p>An list specifying the values for all parameters on the
constrained space.</p>
</td></tr> 
<tr><td><code id="log_prob-methods_+3A_upars">upars</code></td>
<td>
<p>A numeric vector for specifying the values for all parameters 
on the unconstrained space.</p>
</td></tr>  
<tr><td><code id="log_prob-methods_+3A_adjust_transform">adjust_transform</code></td>
<td>
<p>Logical to indicate whether to adjust
the log density since Stan transforms parameters to unconstrained
space if it is in constrained space. Set to <code>FALSE</code> to make the
function return the same values as Stan's <code>lp__</code> output.
</p>
</td></tr> 
<tr><td><code id="log_prob-methods_+3A_gradient">gradient</code></td>
<td>
<p>Logical to indicate whether gradients are also 
computed as well as the log density. 
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Stan requires that parameters be defined along with their support.
For example, for a variance parameter, we must define it 
on the positive real line. But inside Stan's samplers all parameters
defined on the constrained space are transformed to an unconstrained
space amenable to Hamiltonian Monte Carlo. Because of this, Stan adjusts 
the log density function by adding the log absolute value of the 
Jacobian determinant. Once a new iteration is drawn, Stan transforms 
the parameters back to the original constrained space without
requiring interference from the user. However, when using the log 
density function for a model exposed to R, we need to be careful.
For example, if we are interested in finding the mode of parameters 
on the constrained space, we then do not need the adjustment. 
For this reason, the <code>log_prob</code> and <code>grad_log_prob</code> functions 
accept an <code>adjust_transform</code> argument. 
</p>


<h3>Value</h3>

<p><code>log_prob</code> returns a value (up to an additive constant) the log posterior. 
If <code>gradient</code> is <code>TRUE</code>,  the gradients are also returned as an
attribute with name <code>gradient</code>.
</p>
<p><code>grad_log_prob</code> returns a vector of the gradients.  Additionally, the vector
has an attribute named <code>log_prob</code> being the value the same as <code>log_prob</code>
is called for the input parameters. 
</p>
<p><code>get_num_upars</code> returns the number of parameters on the unconstrained space. 
</p>
<p><code>constrain_pars</code> returns a list and <code>unconstrain_pars</code> returns a vector. 
</p>


<h3>Methods</h3>


<dl>
<dt>log_prob</dt><dd><p><code>signature(object = "stanfit")</code>
Compute <code>lp__</code>, the log posterior (up to an additive constant)
for the model represented by a <code>stanfit</code> object. Note that,
by default, <code>log_prob</code> returns the log posterior in the 
<em>unconstrained</em> space Stan works in internally.
set <code>adjust_transform = FALSE</code> to make the values match Stan's output.
</p>
</dd>
<dt>grad_log_prob</dt><dd><p><code>signature(object = "stanfit")</code> Compute the gradients
for <code>log_prob</code> as well as the log posterior. The latter is returned as 
an attribute. 
</p>
</dd>
<dt>get_num_upars</dt><dd><p><code>signature(object = "stanfit")</code> Get the number
of unconstrained parameters.
</p>
</dd> 
<dt>constrain_pars</dt><dd><p><code>signature(object = "stanfit")</code> Convert values
of the parameter from unconstrained space (given as a vector) to their
constrained space (returned as a named list).</p>
</dd>
<dt>unconstrain_pars</dt><dd><p><code>signature(object = "stanfit")</code> Contrary to
<code>constrained</code>, conert values of the parameters from constrained
to unconstrained space.
</p>
</dd>
</dl>



<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanfit-class">stanfit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# see the examples in the help for stanfit as well
# do a simple optimization problem 
opcode &lt;- "
parameters {
  real y;
}
model {
  target += log(square(y - 5) + 1);
}
"
opfit &lt;- stan(model_code = opcode, chains = 0)
tfun &lt;- function(y) log_prob(opfit, y)
tgrfun &lt;- function(y) grad_log_prob(opfit, y)
or &lt;- optim(1, tfun, tgrfun, method = 'BFGS')
print(or)

# return the gradient as an attribute
tfun2 &lt;- function(y) { 
  g &lt;- grad_log_prob(opfit, y) 
  lp &lt;- attr(g, "log_prob")
  attr(lp, "gradient") &lt;- g
  lp
} 

or2 &lt;- nlm(tfun2, 10)
or2 

## End(Not run)</code></pre>

<hr>
<h2 id='loo_moment_match.stanfit'>Moment matching for efficient approximate leave-one-out cross-validation (LOO)</h2><span id='topic+loo_moment_match.stanfit'></span><span id='topic+loo_moment_match+2Cstanfit-method'></span><span id='topic+loo_moment_match'></span>

<h3>Description</h3>

<p>A <code><a href="loo.html#topic+loo_moment_match">loo_moment_match</a></code> method that
is customized for stanfit objects.
The <code>loo_moment_match</code> method for stanfit objects &mdash;a wrapper around the
<code><a href="loo.html#topic+loo_moment_match">loo_moment_match</a></code> (<span class="pkg">loo</span> package)&mdash; updates
a loo object using moment matching (Paananen et al., 2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanfit'
loo_moment_match(x,
    loo = loo,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo_moment_match.stanfit_+3A_x">x</code></td>
<td>
<p>An object of S4 class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="loo_moment_match.stanfit_+3A_loo">loo</code></td>
<td>
<p>A loo object that is modified.</p>
</td></tr>
<tr><td><code id="loo_moment_match.stanfit_+3A_...">...</code></td>
<td>
<p>Further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>loo_moment_match()</code> methods return an updated <code>loo</code> object.
</p>


<h3>References</h3>

<p>Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A. (2020).
Implicitly Adaptive Importance Sampling.
<a href="https://arxiv.org/abs/1906.08850">preprint arXiv:1906.08850</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loo">loo()</a></code>, <code><a href="#topic+loo">loo_moment_match()</a></code>
</p>

<hr>
<h2 id='loo.stanfit'>Approximate leave-one-out cross-validation</h2><span id='topic+loo.stanfit'></span><span id='topic+loo+2Cstanfit-method'></span><span id='topic+loo'></span>

<h3>Description</h3>

<p>A <code><a href="loo.html#topic+loo">loo</a></code> method that is customized for stanfit objects.
The <code>loo</code> method for stanfit objects &mdash;a wrapper around the <code>array</code>
method for <code><a href="loo.html#topic+loo">loo</a></code> in the  <span class="pkg">loo</span> package &mdash; computes PSIS-LOO CV,
approximate leave-one-out cross-validation using Pareto smoothed importance
sampling (Vehtari, Gelman, and Gabry, 2017a,2017b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'stanfit'
loo(x,
    pars = "log_lik",
    save_psis = FALSE,
    cores = getOption("mc.cores", 1),
    moment_match = FALSE,
    k_threshold = 0.7,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loo.stanfit_+3A_x">x</code></td>
<td>
<p>An object of S4 class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_pars">pars</code></td>
<td>
<p>Name of transformed parameter or generated quantity in
the Stan program corresponding to the pointwise log-likelihood. If not
specified the default behavior is to look for <code>"log_lik"</code>.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_save_psis">save_psis</code></td>
<td>
<p>Should the intermediate results from <code><a href="loo.html#topic+psis">psis</a></code>
be saved in the returned object? The default is <code>FALSE</code>. This can be
useful to avoid repeated computation when using other functions in the
<span class="pkg">loo</span> and <span class="pkg">bayesplot</span> packages.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use for parallelization. The default is 1 unless
<code>cores</code> is specified or the <code>mc.cores</code> <a href="base.html#topic+options">option</a>
has been set.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_moment_match">moment_match</code></td>
<td>
<p>Logical; Whether to use the moment matching algorithm for
observations with high Pareto k values to improve accuracy. Note:
because the moment matching algorithm relies on the <code>unconstrain_pars</code>
method in RStan it is only available if run in the same R session as fitting the
model.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_k_threshold">k_threshold</code></td>
<td>
<p>Threshold value for Pareto k values above which
the moment matching algorithm is used. If <code>moment_match</code> is <code>FALSE</code>,
this is ignored.</p>
</td></tr>
<tr><td><code id="loo.stanfit_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stan does not automatically compute and store the log-likelihood. It
is up to the user to incorporate it into the Stan program if it is to be
extracted after fitting the model. In a Stan program, the pointwise log
likelihood can be coded as a vector in the transformed parameters block
(and then summed up in the model block) or it can be coded entirely in the
generated quantities block. We recommend using the generated quantities
block so that the computations are carried out only once per iteration
rather than once per HMC leapfrog step.
</p>
<p>For example, the following is the <code>generated quantities</code> block for
computing and saving the log-likelihood for a linear regression model with
<code>N</code> data points, outcome <code>y</code>, predictor matrix <code>X</code> (including
column of 1s for intercept), coefficients <code>beta</code>,
and standard deviation <code>sigma</code>:
</p>
<p><code>vector[N] log_lik;</code>
</p>
<p><code>for (n in 1:N) log_lik[n] = normal_lpdf(y[n] | X[n, ] * beta, sigma);</code>
</p>
<p>This function automatically uses Pareto k diagnostics for assessing
the accuracy of importance sampling for each observation. When the
diagnostics indicate that importance sampling for certain observations
is inaccurate, a moment matching algorithm can be used, which can
improve the accuracy (Paananen et al., 2020).
</p>


<h3>Value</h3>

<p>A list with class <code>c("psis_loo", "loo")</code>, as detailed in the
<code><a href="loo.html#topic+loo">loo</a></code> documentation.
</p>


<h3>References</h3>

<p>Vehtari, A., Gelman, A., and Gabry, J. (2017a).
Practical Bayesian model evaluation using leave-one-out cross-validation and WAIC.
<em>Statistics and Computing</em>. 27(5), 1413-1432.
<code>doi:10.1007/s11222-016-9696-4</code>.
<a href="https://arxiv.org/abs/1507.04544">https://arxiv.org/abs/1507.04544</a>,
<a href="https://link.springer.com/article/10.1007/s11222-016-9696-4">https://link.springer.com/article/10.1007/s11222-016-9696-4</a>
</p>
<p>Vehtari, A., Gelman, A., and Gabry, J. (2017b).
Pareto smoothed importance sampling. arXiv preprint:
<a href="https://arxiv.org/abs/1507.02646">https://arxiv.org/abs/1507.02646</a>
</p>
<p>Yao, Y., Vehtari, A., Simpson, D., and Gelman, A. (2018).
Using stacking to average Bayesian predictive distributions.
Bayesian Analysis, advance publication, <code>doi:10.1214/17-BA1091</code>.
</p>
<p>Paananen, T., Piironen, J., Buerkner, P.-C., Vehtari, A. (2020).
Implicitly Adaptive Importance Sampling.
arXiv preprint:
<a href="https://arxiv.org/abs/1906.08850">https://arxiv.org/abs/1906.08850</a>.
</p>


<h3>See Also</h3>


<ul>
<li><p> The <span class="pkg"><a href="loo.html#topic+loo">loo</a></span> package documentation, including the vignettes for
many examples (<a href="https://mc-stan.org/loo/">https://mc-stan.org/loo/</a>).
</p>
</li>
<li> <p><code><a href="loo.html#topic+loo_moment_match">loo_moment_match</a></code> for the moment matching algorithm.
</p>
</li>
<li> <p><code><a href="loo.html#topic+loo_model_weights">loo_model_weights</a></code> for model averaging/weighting via
stacking or pseudo-BMA weighting.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a dataset from N(0,1)
N &lt;- 100
y &lt;- rnorm(N, 0, 1)

# Suppose we have three models for y:
#  1) y ~ N(-1, sigma)
#  2) y ~ N(0.5, sigma)
#  3) y ~ N(0.6,sigma)
#
stan_code &lt;- "
data {
  int N;
  vector[N] y;
  real mu_fixed;
}
  parameters {
  real&lt;lower=0&gt; sigma;
}
model {
  sigma ~ exponential(1);
  y ~ normal(mu_fixed, sigma);
}
generated quantities {
  vector[N] log_lik;
  for (n in 1:N) log_lik[n] = normal_lpdf(y[n]| mu_fixed, sigma);
}"

mod &lt;- stan_model(model_code = stan_code)
fit1 &lt;- sampling(mod, data=list(N=N, y=y, mu_fixed=-1))
fit2 &lt;- sampling(mod, data=list(N=N, y=y, mu_fixed=0.5))
fit3 &lt;- sampling(mod, data=list(N=N, y=y, mu_fixed=0.6))

# use the loo method for stanfit objects
loo1 &lt;- loo(fit1, pars = "log_lik")
print(loo1)

# which is equivalent to
LL &lt;- as.array(fit1, pars = "log_lik")
r_eff &lt;- loo::relative_eff(exp(LL))
loo1b &lt;- loo::loo.array(LL, r_eff = r_eff)
print(loo1b)

# compute loo for the other models
loo2 &lt;- loo(fit2)
loo3 &lt;- loo(fit3)

# stacking weights
wts &lt;- loo::loo_model_weights(list(loo1, loo2, loo3), method = "stacking")
print(wts)

# use the moment matching for loo with a stanfit object
loo_mm &lt;- loo(fit1, pars = "log_lik", moment_match = TRUE)
print(loo_mm)

## End(Not run)
</code></pre>

<hr>
<h2 id='lookup'>
Look up the Stan function that corresponds to a <span class="rlang"><b>R</b></span> function or name.
</h2><span id='topic+lookup'></span>

<h3>Description</h3>

<p>This function helps to map between R functions and Stan functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  lookup(FUN, ReturnType = character()) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lookup_+3A_fun">FUN</code></td>
<td>
<p>A character string naming a <span class="rlang"><b>R</b></span> function or a <span class="rlang"><b>R</b></span> function for
which the (near) equivalent Stan function is sought. If no matching
<span class="rlang"><b>R</b></span> function is found, <code>FUN</code> is reinterpreted as a <code><a href="base.html#topic+regexp">regexp</a></code> 
and matches are sought.</p>
</td></tr>
<tr><td><code id="lookup_+3A_returntype">ReturnType</code></td>
<td>
<p>A character string of positive length naming a valid
return type for a Stan function: <code>int</code>, <code>int[]</code>, <code>matrix</code>,
<code>real</code>, <code>real[,]</code>, <code>real[]</code>, <code>row_vector</code>, 
<code>T[]</code>, <code>vector</code>, or <code>void</code>. If <code>"ANY"</code> is passed,
then the entire <code><a href="base.html#topic+data.frame">data.frame</a></code> is returned and can be 
inspected with the <code><a href="utils.html#topic+View">View</a></code> function, for example.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ordinarily, a data.frame with rows equal to the number of partial matches and four columns:
</p>

<ol>
<li> <p><code>StanFunction</code> Character string for the Stan function's name.
</p>
</li>
<li> <p><code>Arguments</code> Character string indicating the arguments to that Stan function. 
</p>
</li>
<li> <p><code>ReturnType</code> Character string indicating the return type of that Stan function.
</p>
</li>
<li> <p><code>Page</code> Integer indicating the page of the Stan reference manual where  
that Stan function is defined. 
</p>
</li></ol>

<p>If there are no matching Stan functions, a character string indicating so is returned.
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>
<p>The Stan Development Team
<em>CmdStan Interface User's Guide</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lookup(dnorm)      # Stan equivalents for the normal PDF (in log form)
lookup("foo")      # fails
lookup("Student")  # succeeds even though there is no such R function
lookup("^poisson") # every Stan function that starts with poisson
</code></pre>

<hr>
<h2 id='makeconf_path'>
Obtain the full path of file <code>Makeconf</code> 
</h2><span id='topic+makeconf_path'></span>

<h3>Description</h3>

<p>Obtain the full path of file <code>Makeconf</code>, in which, for example
the flags for compiling C/C++ code are configured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeconf_path() 
</code></pre>


<h3>Details</h3>

<p>The configuration for compiling shared objects using <code>R CMD SHLIB</code> 
are set in file <code>Makeconf</code>. To change how the C++ code is
compiled, modify this file. For RStan, package <span class="pkg">inline</span> 
compiles the C++ code using <code>R CMD SHLIB</code>. To speed up compiled
Stan models, increase the optimization level to <code>-O3</code> defined
in property <code>CXXFLAGS</code> in the file <code>Makeconf</code>.
This file may also be modified to specify alternative C++ compilers,
such as clang++ or later versions of g++.
</p>


<h3>Value</h3>

<p>An character string for the full path of file <code>Makeconf</code>. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan">stan</a></code>  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeconf_path() 
</code></pre>

<hr>
<h2 id='monitor'>Compute summaries of MCMC draws and monitor convergence</h2><span id='topic+monitor'></span><span id='topic+print.simsummary'></span><span id='topic++5B.simsummary'></span>

<h3>Description</h3>

<p>Similar to the <code>print</code> method for <code>stanfit</code> objects, but <code>monitor</code>
takes an array of simulations as its argument rather than a <code>stanfit</code>
object. For a 3-D array (iterations * chains * parameters) of MCMC draws, 
<code>monitor</code> computes means, standard deviations, quantiles, Monte Carlo 
standard errors, split Rhats, and effective sample sizes. By default, half of 
the iterations are considered warmup and are excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monitor(sims, warmup = floor(dim(sims)[1]/2), 
        probs = c(0.025, 0.25, 0.5, 0.75, 0.975), 
        digits_summary = 1, print = TRUE, ...)
## S3 method for class 'simsummary'
print(x, digits = 3, se = FALSE, ...)
## S3 method for class 'simsummary'
x[i, j, drop = if (missing(i)) TRUE else length(j) == 1]
        
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="monitor_+3A_sims">sims</code></td>
<td>
<p>A 3-D array (iterations * chains * parameters) of MCMC 
simulations from any MCMC algorithm.</p>
</td></tr>
<tr><td><code id="monitor_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations to be excluded 
when computing the summaries. The default is half of the total number 
of iterations. If <code>sims</code> doesn't include the warmup iterations then 
<code>warmup</code> should be set to zero.</p>
</td></tr>
<tr><td><code id="monitor_+3A_probs">probs</code></td>
<td>
<p>A numeric vector specifying quantiles of interest. The 
defaults is <code>c(0.025,0.25,0.5,0.75,0.975)</code>.</p>
</td></tr>
<tr><td><code id="monitor_+3A_digits_summary">digits_summary</code></td>
<td>
<p>The number of significant digits to use when printing
the summary, defaulting to 1. Applies to the quantities other than 
the effective sample size, which is always rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="monitor_+3A_print">print</code></td>
<td>
<p>Logical, indicating whether to print the summary after the 
computations are performed.</p>
</td></tr> 
<tr><td><code id="monitor_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying <code>print</code> method.</p>
</td></tr>
<tr><td><code id="monitor_+3A_x">x</code></td>
<td>
<p>An object of class <code>simsummary</code> created by <code>monitor</code></p>
</td></tr>
<tr><td><code id="monitor_+3A_digits">digits</code></td>
<td>
<p>An integer scalar defaulting to 3 for the number of decimal
places to print</p>
</td></tr>
<tr><td><code id="monitor_+3A_se">se</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating whether
to print the estimated standard errors of the estimates</p>
</td></tr>
<tr><td><code id="monitor_+3A_i">i</code></td>
<td>
<p>A vector indicating which rows of the object created by <code>monitor</code>
to select</p>
</td></tr>
<tr><td><code id="monitor_+3A_j">j</code></td>
<td>
<p>A vector indicating which columns of the object crated by <code>monitor</code>
to select</p>
</td></tr>
<tr><td><code id="monitor_+3A_drop">drop</code></td>
<td>
<p>A logical scalar indicating whether the resulting object 
should return a vector where possible</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-D array with rows corresponding to parameters and columns to the 
summary statistics that can be printed and subset.
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p>S4 class <code><a href="#topic+stanfit-class">stanfit</a></code> and particularly its
<code><a href="#topic+print.stanfit">print</a></code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csvfiles &lt;- dir(system.file('misc', package = 'rstan'),
                pattern = 'rstan_doc_ex_[0-9].csv', full.names = TRUE)
fit &lt;- read_stan_csv(csvfiles)
# The following is just for the purpose of giving an example
# since print can be used for a stanfit object.
monitor(extract(fit, permuted = FALSE, inc_warmup = TRUE))
</code></pre>

<hr>
<h2 id='nlist'>Created named lists</h2><span id='topic+nlist'></span>

<h3>Description</h3>

<p>Create a named list using specified names or, if names are omitted, using the 
names of the objects in the list. The code ]<code>list(a = a, b = b)</code> becomes 
<code>nlist(a,b)</code> and <code>list(a = a, b = 2)</code> becomes <code>nlist(a, b = 2)</code>, 
etc. This is convenient when creating the list of data to pass to Stan. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  nlist(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlist_+3A_...">...</code></td>
<td>
<p>The objects to include in the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># All variables already defined
x &lt;- 1
y &lt;- 2
nlist(x, y)

# Define some variables in the call and take the rest from the environment
nlist(x, y, z = 3)
</code></pre>

<hr>
<h2 id='optimizing'>Obtain a point estimate by maximizing the joint posterior</h2><span id='topic+optimizing'></span><span id='topic+optimizing+2Cstanmodel-method'></span>

<h3>Description</h3>

<p>Obtain a point estimate by maximizing the joint posterior 
from the model defined by class <code>stanmodel</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S4 method for signature 'stanmodel'
optimizing(object, data = list(), 
    seed = sample.int(.Machine$integer.max, 1), init = 'random', 
    check_data = TRUE, sample_file = NULL, 
    algorithm = c("LBFGS", "BFGS", "Newton"),
    verbose = FALSE, hessian = FALSE, as_vector = TRUE, 
    draws = 0, constrained = TRUE, importance_resampling = FALSE, ...)   
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimizing_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanmodel-class">stanmodel</a></code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code>
providing the data for the model or a character vector 
for all the names of objects used as data. 
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated 
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine. Even if 
multiple chains are used, only one seed is needed, with other chains having 
seeds derived from that of the first chain to avoid dependent samples.
When a seed is specified by a number, <code>as.integer</code> will be applied to it. 
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly. 
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_init">init</code></td>
<td>
<p>Initial values specification. See the detailed documentation for 
the <code>init</code> argument in <code><a href="#topic+stan">stan</a></code> with one exception. If specifying inits  
using a list then only a single named list of values should be provided.
For example, to initialize a parameter <code>alpha</code> to <code>value1</code> and 
<code>beta</code> to <code>value2</code> you can specify <code>list(alpha = value1, beta = value2)</code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_check_data">check_data</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>. If <code>TRUE</code> 
the data will be preprocessed; otherwise not.
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_sample_file">sample_file</code></td>
<td>
<p>A character string of file name for specifying where to 
write samples for <em>all</em> parameters and other saved quantities. 
If not provided, files are not created. When the folder specified 
is not writable, <code>tempdir()</code> is used.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_algorithm">algorithm</code></td>
<td>
<p>One of <code>"Newton"</code>, <code>"BFGS"</code>, 
and <code>"LBFGS"</code> (the default) indicating which optimization algorithm 
to use.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (the default): flag indicating 
whether to print intermediate output from Stan on the console, which might
be helpful for model debugging.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_hessian">hessian</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (the default): flag indicating
whether to calculate the Hessian (via numeric differentiation of the
gradient function in the unconstrained parameter space).</p>
</td></tr>
<tr><td><code id="optimizing_+3A_as_vector">as_vector</code></td>
<td>
<p><code>TRUE</code> (the default) or <code>FALSE</code>: flag indicating
whether a vector is used to store the point estimate found. A list can be 
used instead by specifying it to be <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_draws">draws</code></td>
<td>
<p>A non-negative integer (that defaults to zero) indicating how
many times to draw from a multivariate normal distribution whose parameters
are the mean vector and the inverse negative Hessian in the unconstrained
space. If <code>draws &gt; 0</code> and <code>importance_resampling=TRUE</code> 
then <code>log_p</code> and <code>log_g</code> will be computed and returned 
(see description in the <strong>Value</strong> section).</p>
</td></tr>
<tr><td><code id="optimizing_+3A_constrained">constrained</code></td>
<td>
<p>A logical scalar indicating, if <code>draws &gt; 0</code>, whether
the draws should be transformed to the constrained space defined in the
parameters block of the Stan program. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="optimizing_+3A_importance_resampling">importance_resampling</code></td>
<td>
<p>A logical scalar (defaulting to <code>FALSE</code>) 
indicating whether to do importance resampling to compute diagnostics on the 
draws from the normal approximation to the posterior distribution.
If <code>TRUE</code> and <code>draws &gt; 0</code> then <code>log_p</code> 
and <code>log_g</code> will be computed and returned (see description in the 
<strong>Value</strong> section).</p>
</td></tr>
<tr><td><code id="optimizing_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>iter</code> (<code>integer</code>), the maximum number of iterations, 
defaulting to 2000.
</p>
</li>
<li> <p><code>save_iterations</code> (logical), a flag indicating whether to save 
the iterations, defaulting to <code>FALSE</code>.
</p>
</li>
<li> <p><code>refresh</code> (<code>integer</code>), the number of interations between 
screen updates, defaulting to 100.
</p>
</li>
<li> <p><code>init_alpha</code> (<code>double</code>), for BFGS and LBFGS, 
the line search step size for first iteration, defaulting to 0.001.
</p>
</li>
<li> <p><code>tol_obj</code> (<code>double</code>), for BFGS and LBFGS, 
the convergence tolerance on changes in objective function value, 
defaulting to 1e-12.
</p>
</li>
<li> <p><code>tol_rel_obj</code> (<code>double</code>), for BFGS and LBFGS, 
the convergence tolerance on relative changes in objective function value,
defaulting to 1e4.
</p>
</li>
<li> <p><code>tol_grad</code> (<code>double</code>), for BFGS and LBFGS, 
the convergence tolerance on the norm of the gradient, defaulting to 1e-8.
</p>
</li>
<li> <p><code>tol_rel_grad</code> (<code>double</code>), for BFGS and LBFGS, 
the convergence tolerance on the relative norm of the gradient, defaulting
to 1e7.
</p>
</li>
<li> <p><code>tol_param</code> (<code>double</code>), for BFGS and LBFGS, 
the convergence tolerance on changes in parameter value, defaulting to 1e-8.
</p>
</li>
<li> <p><code>history_size</code> (<code>integer</code>), for LBFGS, 
the number of update vectors to use in Hessian approximations, 
defaulting to 5.
</p>
</li></ul>

<p>Refer to the manuals for both CmdStan and Stan for more details.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components: 
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The point estimate found. Its form (vector or list) 
is determined by the <code>as_vector</code> argument.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the log-posterior (up to an additive constant, 
the <code>"lp__"</code> in Stan) corresponding to <code>par</code>.</p>
</td></tr>
<tr><td><code>return_code</code></td>
<td>
<p>The value of the return code from the optimizer;
anything that is not zero is problematic.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian matrix if <code>hessian</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code>theta_tilde</code></td>
<td>
<p>If <code>draws &gt; 0</code>, the matrix of parameter draws
in the constrained or unconstrained space, depending on the value of 
the <code>constrained</code> argument.</p>
</td></tr>
<tr><td><code>log_p</code></td>
<td>
<p>If <code>draws &gt; 0</code> and <code>importance_resampling=TRUE</code>, 
a vector of length <code>draws</code> that contains the value of the 
log-posterior evaluated at each row of <code>theta_tilde</code>.</p>
</td></tr>
<tr><td><code>log_g</code></td>
<td>
<p>If <code>draws &gt; 0</code>, a vector of length <code>draws</code> that 
contains the value of the logarithm of the multivariate normal density 
evaluated at each row of <code>theta_tilde</code>.</p>
</td></tr>
</table>
<p>If the optimization is not completed for reasons such as feeding wrong data,
it returns <code>NULL</code>. 
</p>


<h3>Methods</h3>


<dl>
<dt>optimizing</dt><dd><p><code>signature(object = "stanmodel")</code>
Call Stan's optimization methods to obtain a point estimate 
for the model defined by S4 class <code>stanmodel</code> 
given the data, initial values, etc. 
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stanmodel-class">stanmodel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
f &lt;- optimizing(m, hessian = TRUE)

## End(Not run)</code></pre>

<hr>
<h2 id='pairs.stanfit'>Create a matrix of output plots from a <code>stanfit</code> object</h2><span id='topic+pairs.stanfit'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs</a></code> method that is customized for MCMC output</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'stanfit'
pairs(x, labels = NULL, panel = NULL, ..., 
    lower.panel = NULL, 
    upper.panel = NULL, diag.panel = NULL, text.panel = NULL, 
    label.pos = 0.5 + 1/3, cex.labels = NULL, font.labels = 1, 
    row1attop = TRUE, gap = 1, log = "", pars = NULL, include = TRUE,
    condition = "accept_stat__") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs.stanfit_+3A_x">x</code></td>
<td>
<p>An object of S4 class <code>stanfit</code></p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_labels">labels</code>, <code id="pairs.stanfit_+3A_panel">panel</code>, <code id="pairs.stanfit_+3A_...">...</code>, <code id="pairs.stanfit_+3A_lower.panel">lower.panel</code>, <code id="pairs.stanfit_+3A_upper.panel">upper.panel</code>, <code id="pairs.stanfit_+3A_diag.panel">diag.panel</code></td>
<td>
<p>Same as in 
<code><a href="graphics.html#topic+pairs">pairs</a></code> syntactically but see the Details section for different
default arguments</p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_text.panel">text.panel</code>, <code id="pairs.stanfit_+3A_label.pos">label.pos</code>, <code id="pairs.stanfit_+3A_cex.labels">cex.labels</code>, <code id="pairs.stanfit_+3A_font.labels">font.labels</code>, <code id="pairs.stanfit_+3A_row1attop">row1attop</code>, <code id="pairs.stanfit_+3A_gap">gap</code></td>
<td>
<p>Same as in <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code></p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_log">log</code></td>
<td>
<p>Same as in <code><a href="graphics.html#topic+pairs.default">pairs.default</a></code>, which makes it possible to
utilize logarithmic axes and additionally accepts <code>log = TRUE</code>. See the
Details section.</p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_pars">pars</code></td>
<td>
<p>If not <code>NULL</code>, a character vector indicating which quantities
to include in the plots, which is passed to <code><a href="#topic+extract">extract</a></code>. Thus,
by default, all unknown quantities are included, which may be far too many
to visualize on a small computer screen. If <code>include = FALSE</code>, then
the named parameters are excluded from the plot.</p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_condition">condition</code></td>
<td>
<p>If <code>NULL</code>, it will plot roughly half of the
chains in the lower panel and the rest in the upper panel. An
integer vector can be passed to select some subset of the chains, of which
roughly half will be plotted in the lower panel and the rest in the upper
panel. A list of two integer vectors can be passed, each specifying a subset
of the chains to be plotted in the lower and upper panels respectively.
</p>
<p>A single number between zero and one exclusive can be passed, which is 
interpreted as the proportion of realizations (among all chains) to plot
in the lower panel starting with the first realization in each chain, 
with the complement (from the end of each chain) plotted in the upper panel.
</p>
<p>A (possibly abbreviated) character vector of length one can be passed among 
<code>"accept_stat__", "stepsize__"</code>, <code>"treedepth__", "n_leapfrog__"</code>,
<code>"divergent__"</code>,, <code>"energy__"</code>, or <code>"lp__"</code>, which are the 
variables produced by <code><a href="#topic+get_sampler_params">get_sampler_params</a></code> and 
<code><a href="#topic+get_logposterior">get_logposterior</a></code>. In that case the lower panel will plot 
realizations that are below the median of the indicated variable (or are zero 
in the case of <code>"divergent__"</code>) and the upper panel will plot realizations 
that are greater than or equal to the median of the indicated variable (or are 
one in the case of <code>"divergent__"</code>). 
Finally, any logical vector whose length is equal to the product of the number 
of iterations and the number of chains can be passed, in which case realizations
corresponding to <code>FALSE</code> and <code>TRUE</code> will be plotted in the lower 
and upper panel respectively. The default is <code>"accept_stat__"</code>.</p>
</td></tr>
<tr><td><code id="pairs.stanfit_+3A_include">include</code></td>
<td>
<p>Logical scalar indicating whether to include (the default) or
exclude the parameters named in the <code>pars</code> argument from the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method differs from the default <code><a href="graphics.html#topic+pairs">pairs</a></code> method in the following
ways. If unspecified, the <code><a href="graphics.html#topic+smoothScatter">smoothScatter</a></code> function is used for the
off-diagonal plots, rather than <code><a href="graphics.html#topic+points">points</a></code>, since the former is more
appropriate for visualizing thousands of draws from a posterior distribution.
Also, if unspecified, histograms of the marginal distribution of each quantity
are placed on the diagonal of the plot, after pooling all of the chains specified
by the <code>chain\_id</code> argument.
</p>
<p>The draws from the warmup phase are always discarded before plotting.
</p>
<p>By default, the lower (upper) triangle of the plot contains draws with below
(above) median acceptance probability. Also, if <code>condition</code> is not
<code>"divergent__"</code>, red points will be superimposed onto the smoothed
density plots indicating which (if any) iterations encountered a divergent 
transition. Otherwise, yellow points indicate a transition that hit the
maximum treedepth rather than terminated its evolution normally.
</p>
<p>You may very well want to specify the <code>log</code> argument for non-negative
parameters. However, the <code>pairs</code> function will drop (with a message)
parameters that are either constant or duplicative with previous parameters.
For example, if a correlation matrix is included among <code>pars</code>, then 
neither its diagonal elements (which are always 1) nor its upper triangular
elements (which are the same as the corresponding lower triangular elements)
will be included. Thus, if <code>log</code> is an integer vector, it needs to
pertain to the parameters after constant and duplicative ones are dropped.
It is perhaps easiest to specify <code>log = TRUE</code>, which will utilize
logarithmic axes for all non-negative parameters, except <code>lp__</code> and
any integer valued quantities.
</p>


<h3>See Also</h3>

<p>S4 class <code><a href="#topic+stanfit-class">stanfit</a></code> and its method <code><a href="#topic+extract">extract</a></code> as
well as the <code><a href="graphics.html#topic+pairs">pairs</a></code> generic function. Also, see
<code><a href="#topic+get_sampler_params">get_sampler_params</a></code> and <code><a href="#topic+get_logposterior">get_logposterior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(read_stan_csv)
pairs(fit, pars = c("mu", "sigma", "alpha", "lp__"), log = TRUE, las = 1)
# sigma and alpha will have logarithmic axes
</code></pre>

<hr>
<h2 id='plot-methods'>Plots for stanfit objects</h2><span id='topic+plot+2Cstanfit-method'></span><span id='topic+plot+2Cstanfit+2Cmissing-method'></span>

<h3>Description</h3>

<p>The default plot shows posterior uncertainty intervals and point 
estimates for parameters and generated quantities. The <code>plot</code> method can 
also be used to call the other <strong>rstan</strong> plotting functions via the 
<code>plotfun</code> argument (see Examples).</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'stanfit,missing'
plot(x, ..., plotfun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-methods_+3A_x">x</code></td>
<td>
<p>An instance of class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_plotfun">plotfun</code></td>
<td>
<p>A character string naming the plotting function to apply to the
stanfit object. If <code>plotfun</code> is missing, the default is to call
<code><a href="#topic+stan_plot">stan_plot</a></code>, which generates a plot of credible intervals and
point estimates. See <code><a href="#topic+rstan-plotting-functions">rstan-plotting-functions</a></code> for the names and
descriptions of the other plotting functions. <code>plotfun</code> can be either the
full name of the plotting function (e.g. <code>"stan_hist"</code>) or can be 
abbreviated to the part of the name following the underscore 
(e.g. <code>"hist"</code>).</p>
</td></tr>
<tr><td><code id="plot-methods_+3A_...">...</code></td>
<td>
<p>Optional arguments to <code>plotfun</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further customized
using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Note</h3>

<p>Because the <span class="pkg">rstan</span> plotting functions use <span class="pkg">ggplot2</span> (and thus the 
resulting plots behave like <code>ggplot</code> objects), when calling a plotting 
function within a loop or when assigning a plot to a name 
(e.g., <code>graph &lt;- plot(fit, plotfun = "rhat")</code>),
if you also want the side effect of the plot being displayed you 
must explicity print it (e.g., <code>(graph &lt;- plot(fit, plotfun = "rhat"))</code>, 
<code>print(graph &lt;- plot(fit, plotfun = "rhat"))</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstan-plotting-functions">List of RStan plotting functions</a></code>,
<code><a href="#topic+rstan_gg_options">Plot options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rstan)
fit &lt;- stan_demo("eight_schools")
plot(fit)
plot(fit, show_density = TRUE, ci_level = 0.5, fill_color = "purple")
plot(fit, plotfun = "hist", pars = "theta", include = FALSE)
plot(fit, plotfun = "trace", pars = c("mu", "tau"), inc_warmup = TRUE)
plot(fit, plotfun = "rhat") + ggtitle("Example of adding title to plot")

## End(Not run)
</code></pre>

<hr>
<h2 id='Plots'>ggplot2 for RStan</h2><span id='topic+stan_plot'></span><span id='topic+stan_trace'></span><span id='topic+stan_dens'></span><span id='topic+stan_hist'></span><span id='topic+stan_scat'></span><span id='topic+stan_ac'></span><span id='topic+quietgg'></span>

<h3>Description</h3>

<p>Visual posterior analysis using ggplot2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stan_plot(object, pars, include = TRUE, unconstrain = FALSE, ...)
  stan_trace(object, pars, include = TRUE, unconstrain = FALSE,
            inc_warmup = FALSE, nrow = NULL, ncol = NULL, ..., 
            window = NULL)
  stan_scat(object, pars, unconstrain = FALSE,
            inc_warmup = FALSE, nrow = NULL, ncol = NULL, ...)
  stan_hist(object, pars, include = TRUE, unconstrain = FALSE,
            inc_warmup = FALSE, nrow = NULL, ncol = NULL, ...)
  stan_dens(object, pars, include = TRUE, unconstrain = FALSE,
            inc_warmup = FALSE, nrow = NULL, ncol = NULL, ..., 
            separate_chains = FALSE)
  stan_ac(object, pars, include = TRUE, unconstrain = FALSE,
            inc_warmup = FALSE, nrow = NULL, ncol = NULL, ..., 
            separate_chains = FALSE, lags = 25, partial = FALSE)
  quietgg(gg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Plots_+3A_object">object</code></td>
<td>
<p>A stanfit or stanreg object.</p>
</td></tr>
<tr><td><code id="Plots_+3A_pars">pars</code></td>
<td>
<p>Optional character vector of parameter names. 
If <code>object</code> is a stanfit object, the default is to show
all user-defined parameters or the first 10 (if there are more 
than 10). If <code>object</code> is a stanreg object, the default is 
to show all (or the first 10) regression coefficients 
(including the intercept). For <code>stan_scat</code> only, 
<code>pars</code> should not be missing and should contain exactly 
two parameter names.</p>
</td></tr>
<tr><td><code id="Plots_+3A_include">include</code></td>
<td>
<p>Should the parameters given by the <code>pars</code> argument be
included (the default) or excluded from the plot?</p>
</td></tr>
<tr><td><code id="Plots_+3A_unconstrain">unconstrain</code></td>
<td>
<p>Should parameters be plotted on the unconstrained space?
Defaults to <code>FALSE</code>. Only available if <code>object</code> is a 
stanfit object.</p>
</td></tr>
<tr><td><code id="Plots_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Should warmup iterations be included? Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Plots_+3A_nrow">nrow</code>, <code id="Plots_+3A_ncol">ncol</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.</p>
</td></tr>
<tr><td><code id="Plots_+3A_...">...</code></td>
<td>
<p>Optional additional named arguments passed to geoms 
(e.g. for <code>stan_trace</code> the geom is <code><a href="ggplot2.html#topic+geom_path">geom_path</a></code> 
and we could specify <code>linetype</code>, <code>size</code>, <code>alpha</code>, etc.). 
For <code>stan_plot</code> there are also additional arguments that can be specified 
in <code>...</code> (see Details).</p>
</td></tr>
<tr><td><code id="Plots_+3A_window">window</code></td>
<td>
<p>For <code>stan_trace</code> <code>window</code> is used to control
which iterations are shown in the plot. See <code><a href="#topic+traceplot">traceplot</a></code>.</p>
</td></tr>
<tr><td><code id="Plots_+3A_separate_chains">separate_chains</code></td>
<td>
<p>For <code>stan_dens</code>, should the density for each 
chain be plotted? The default is <code>FALSE</code>, which means that for each 
parameter the draws from all chains are combined. For <code>stan_ac</code>, 
if <code>separate_chains=FALSE</code> (the default), the autocorrelation is
averaged over the chains. If <code>TRUE</code> each chain is plotted separately.</p>
</td></tr>
<tr><td><code id="Plots_+3A_lags">lags</code></td>
<td>
<p>For <code>stan_ac</code>, the maximum number of lags to show.</p>
</td></tr>
<tr><td><code id="Plots_+3A_partial">partial</code></td>
<td>
<p>For <code>stan_ac</code>, should partial autocorrelations be 
plotted instead? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Plots_+3A_gg">gg</code></td>
<td>
<p>A ggplot object or an expression that creates one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>stan_plot</code>, there are additional arguments that can be specified in 
<code>...</code>. The optional arguments and their default values are:
</p>

<dl>
<dt><code>point_est = "median"</code></dt><dd><p>The point estimate to show. 
Either &quot;median&quot; or &quot;mean&quot;.
</p>
</dd>
<dt><code>show_density = FALSE</code></dt><dd><p>Should kernel density estimates be plotted 
above the intervals?
</p>
</dd>
<dt><code>ci_level = 0.8</code></dt><dd><p>The posterior uncertainty interval to highlight.
Central <code>100*ci_level</code>% intervals are computed from the quantiles of 
the posterior draws.</p>
</dd>
<dt><code>outer_level = 0.95</code></dt><dd><p>An outer interval to also draw as a line 
(if <code>show_outer_line</code> is <code>TRUE</code>) but not highlight.
</p>
</dd>
<dt><code>show_outer_line = TRUE</code></dt><dd><p>Should the <code>outer_level</code> interval 
be shown or hidden? Defaults to = <code>TRUE</code> (to plot it).
</p>
</dd>
<dt><code>fill_color</code>, <code>outline_color</code>, <code>est_color</code></dt><dd><p>Colors to 
override the defaults for the highlighted interval, the outer interval 
(and density outline), and the point estimate.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further customized
using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Note</h3>

<p>Because the <span class="pkg">rstan</span> plotting functions use <span class="pkg">ggplot2</span> (and thus the 
resulting plots behave like <code>ggplot</code> objects), when calling a plotting 
function within a loop or when assigning a plot to a name 
(e.g., <code>graph &lt;- plot(fit, plotfun = "rhat")</code>),
if you also want the side effect of the plot being displayed you 
must explicity print it (e.g., <code>(graph &lt;- plot(fit, plotfun = "rhat"))</code>, 
<code>print(graph &lt;- plot(fit, plotfun = "rhat"))</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rstan-plotting-functions">List of RStan plotting functions</a></code>,
<code><a href="#topic+rstan_gg_options">Plot options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
example("read_stan_csv")
stan_plot(fit)
stan_trace(fit)

library(gridExtra)
fit &lt;- stan_demo("eight_schools")

stan_plot(fit)
stan_plot(fit, point_est = "mean", show_density = TRUE, fill_color = "maroon")


# histograms
stan_hist(fit)
# suppress ggplot2 messages about default bindwidth
quietgg(stan_hist(fit))
quietgg(h &lt;- stan_hist(fit, pars = "theta", binwidth = 5)) 

# juxtapose histograms of tau and unconstrained tau 
tau &lt;- stan_hist(fit, pars = "tau")
tau_unc &lt;- stan_hist(fit, pars = "tau", unconstrain = TRUE) + 
            xlab("tau unconstrained")
grid.arrange(tau, tau_unc)

# kernel density estimates
stan_dens(fit)
(dens &lt;- stan_dens(fit, fill = "skyblue", ))
dens &lt;- dens + ggtitle("Kernel Density Estimates\n") + xlab("")
dens

(dens_sep &lt;- stan_dens(fit, separate_chains = TRUE, alpha = 0.3))
dens_sep + scale_fill_manual(values = c("red", "blue", "green", "black"))
(dens_sep_stack &lt;- stan_dens(fit, pars = "theta", alpha = 0.5,
                             separate_chains = TRUE, position = "stack"))

# traceplot
trace &lt;- stan_trace(fit)
trace +
  scale_color_manual(values = c("red", "blue", "green", "black"))
trace +
  scale_color_brewer(type = "div") +
  theme(legend.position = "none")

facet_style &lt;- theme(strip.background = ggplot2::element_rect(fill = "white"),
                     strip.text = ggplot2::element_text(size = 13, color = "black"))
(trace &lt;- trace + facet_style)

# scatterplot
(mu_vs_tau &lt;- stan_scat(fit, pars = c("mu", "tau"), color = "blue", size = 4))
mu_vs_tau + 
  ggplot2::coord_flip() + 
  theme(panel.background = ggplot2::element_rect(fill = "black"))
  

## End(Not run)
</code></pre>

<hr>
<h2 id='print'>Print a summary for a fitted model represented by a <code>stanfit</code> object</h2><span id='topic+print.stanfit'></span>

<h3>Description</h3>

<p>Print basic information regarding the fitted model and 
a summary for the parameters of interest estimated by the samples included
in a <code>stanfit</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'stanfit'
print(x, pars = x@sim$pars_oi, 
      probs = c(0.025, 0.25, 0.5, 0.75, 0.975),
      digits_summary = 2, include = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>An object of S4 class <code>stanfit</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names. The default is all parameters
for which samples are saved. If <code>include = FALSE</code>, then the specified parameters
are excluded from the printed summary.</p>
</td></tr>
<tr><td><code id="print_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of quantiles of interest. The default is
<code>c(0.025,0.25,0.5,0.75,0.975)</code>.</p>
</td></tr>
<tr><td><code id="print_+3A_digits_summary">digits_summary</code></td>
<td>
<p>The number of significant digits to use when printing
the summary, defaulting to 2. Applies to the quantities other than 
the effective sample size, which is always rounded to the nearest integer.</p>
</td></tr>
<tr><td><code id="print_+3A_include">include</code></td>
<td>
<p>Logical scalar (defaulting to <code>TRUE</code>) indicating whether to
include or exclude the parameters named by the <code>pars</code> argument.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>summary</code> method 
for <code>stanfit</code> objects.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information regarding the fitted model includes the number of iterations,
the number of chains, the total number of saved iterations, 
the estimation algorithm used, and the timestamp indicating when 
sampling finished.
</p>
<p>The parameter summaries computed include means, standard deviations (sd), 
quantiles, Monte Carlo standard errors (se_mean), split Rhats, and 
effective sample sizes (n_eff). The summaries are computed after dropping 
the warmup iterations and merging together the draws from all chains.
</p>
<p>In addition to the model parameters, summaries for the 
log-posterior (<code>lp__</code>) are also reported. 
</p>


<h3>See Also</h3>

<p>S4 class <code><a href="#topic+stanfit-class">stanfit</a></code> and particularly its method
<code><a href="#topic+summary+2Cstanfit-method">summary</a></code>, which is used to obtain the 
values that are printed.
</p>

<hr>
<h2 id='read_rdump'>Read data in an <span class="rlang"><b>R</b></span> dump file to a list</h2><span id='topic+read_rdump'></span>

<h3>Description</h3>

<p>Create an <span class="rlang"><b>R</b></span> list from an <span class="rlang"><b>R</b></span> dump file</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rdump(f, keep.source = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_rdump_+3A_f">f</code></td>
<td>
<p>A character string providing the dump file name.</p>
</td></tr>
<tr><td><code id="read_rdump_+3A_keep.source">keep.source</code></td>
<td>
<p>logical: should the source formatting be retained when
echoing expressions, if possible?</p>
</td></tr>
<tr><td><code id="read_rdump_+3A_...">...</code></td>
<td>
<p>passed to <code>source</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <span class="rlang"><b>R</b></span> dump file can be read directly by <span class="rlang"><b>R</b></span> function <code>source</code>, which
by default would read the data into the user's workspace (the global environment). 
This function instead read the data to a list, making it convenient to 
prepare data for the <code>stan</code> model-fitting function.
</p>


<h3>Value</h3>

<p>A list containing all the data defined in the dump file with
keys corresponding to variable names.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_rdump">stan_rdump</a></code>; <code><a href="base.html#topic+dump">dump</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1; y &lt;- 1:10; z &lt;- array(1:10, dim = c(2,5)) 
stan_rdump(ls(pattern = '^[xyz]'), file.path(tempdir(), "xyz.Rdump"))
l &lt;- read_rdump(file.path(tempdir(), 'xyz.Rdump'))
print(l)
unlink(file.path(tempdir(), "xyz.Rdump"))
</code></pre>

<hr>
<h2 id='read_stan_csv'>Read CSV files of samples generated by (R)Stan into a <code>stanfit</code> object</h2><span id='topic+read_stan_csv'></span>

<h3>Description</h3>

<p>Create a <code>stanfit</code> object from the saved CSV files that are
created by Stan or RStan and that include the samples drawn from the
distribution of interest to facilitate analysis of samples using RStan.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_stan_csv(csvfiles, col_major = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_stan_csv_+3A_csvfiles">csvfiles</code></td>
<td>
<p>A character vector providing CSV file names</p>
</td></tr>
<tr><td><code id="read_stan_csv_+3A_col_major">col_major</code></td>
<td>
<p>The order for array parameters; default to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stan and RStan could save the samples to CSV files.  This function
reads the samples and using the comments (beginning with <code>"#"</code>)
to create a <code>stanfit</code> object. The model name is derived from 
the first CSV file. 
</p>
<p><code>col_major</code> specifies how array parameters are ordered in each row of
the CSV files.  For example, parameter <code>"a[2,2]"</code> would be ordered as
<code>"a[1,1], a[2,1], a[1,2], a[2,2]"</code> if col_major is <code>TRUE</code>. 
</p>


<h3>Value</h3>

<p>A <code>stanfit</code> object (with invalid <code>stanmodel</code> slot). This <code>stanfit</code>
object cannot be used to re-run the sampler. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanfit-class">stanfit</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>csvfiles &lt;- dir(system.file('misc', package = 'rstan'),
                pattern = 'rstan_doc_ex_[0-9].csv', full.names = TRUE)
fit &lt;- read_stan_csv(csvfiles)
</code></pre>

<hr>
<h2 id='Rhat'>
Convergence and efficiency diagnostics for Markov Chains
</h2><span id='topic+Rhat'></span><span id='topic+ess_bulk'></span><span id='topic+ess_tail'></span>

<h3>Description</h3>

<p>These functions are improved versions of the traditional
Rhat (for convergence) and Effective Sample Size (for
efficiency).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rhat(sims)
ess_bulk(sims)
ess_tail(sims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rhat_+3A_sims">sims</code></td>
<td>

<p>A two-dimensional array whose rows are equal to the
number of iterations of the Markov Chain(s) and whose
columns are equal to the number of Markov Chains
(preferably more than one). The cells are the realized
draws for a particular parameter or function of parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>Rhat</code> function produces R-hat convergence diagnostic, which
compares the between- and within-chain estimates for model parameters
and other univariate quantities of interest. If chains have not mixed
well (ie, the between- and within-chain estimates don't agree), R-hat is
larger than 1. We recommend running at least four chains by default and
only using the sample if R-hat is less than 1.05. Stan reports R-hat
which is the maximum of rank normalized split-R-hat and rank normalized
folded-split-R-hat, which works for thick tailed distributions and is
sensitive also to differences in scale.
</p>
<p>The <code>ess_bulk</code> function produces an estimated Bulk Effective Sample
Size (bulk-ESS) using rank normalized draws. Bulk-ESS is useful measure
for sampling efficiency in the bulk of the distribution (related e.g. to
efficiency of mean and median estimates), and is well defined even if
the chains do not have finite mean or variance.
</p>
<p>The <code>ess_tail</code> function produces an estimated Tail Effective Sample
Size (tail-ESS) by computing the minimum of effective sample sizes for
5% and 95% quantiles. Tail-ESS is useful measure for sampling
efficiency in the tails of the distribution (related e.g. to efficiency
of variance and tail quantile estimates).
</p>
<p>Both bulk-ESS and tail-ESS should be at least <code class="reqn">100</code> (approximately)
per Markov Chain in order to be reliable and indicate that estimates of
respective posterior quantiles are reliable.
</p>


<h3>Author(s)</h3>

<p>Paul-Christian Burkner and Aki Vehtari
</p>


<h3>References</h3>

<p>Aki Vehtari, Andrew Gelman, Daniel Simpson, Bob Carpenter, and
Paul-Christian Burkner (2019). Rank-normalization, folding, and
localization: An improved R-hat for assessing convergence of MCMC.
<em>arXiv preprint</em> <code>arXiv:1903.08008</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+monitor">monitor</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># pretend these draws came from five actual Markov Chins
sims &lt;- matrix(rnorm(500), nrow = 100, ncol = 5)
Rhat(sims)
ess_bulk(sims)
ess_tail(sims)
</code></pre>

<hr>
<h2 id='rstan_gg_options'>Set default appearance options</h2><span id='topic+rstan_gg_options'></span><span id='topic+rstan_ggtheme_options'></span>

<h3>Description</h3>

<p>Set default appearance options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  rstan_gg_options(...)
  
  rstan_ggtheme_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstan_gg_options_+3A_...">...</code></td>
<td>
<p>For <code>rstan_ggtheme_options</code>, see
<code><a href="ggplot2.html#topic+theme">theme</a></code> for the theme elements that can be specified
in <code>...</code>. For <code>rstan_gg_options</code>, <code>...</code> can be <code>fill</code>,
<code>color</code>, <code>chain_colors</code>, <code>size</code>, <code>pt_color</code>, or
<code>pt_size</code>. See Examples.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rstan-plotting-functions">List of RStan plotting functions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rstan_ggtheme_options(panel.background = ggplot2::element_rect(fill = "gray"),
                      legend.position = "top")
rstan_gg_options(fill = "skyblue", color = "skyblue4", pt_color = "red")
</code></pre>

<hr>
<h2 id='rstan_options'>Set and read options used in RStan</h2><span id='topic+rstan_options'></span>

<h3>Description</h3>

<p>Set and read options used in RStan. Some settings as options can be 
controlled by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstan_options(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstan_options_+3A_...">...</code></td>
<td>
<p>Arguments of the form <code>opt = val</code> set
option <code>opt</code> to value <code>val</code>.  Arguments of the
form <code>opt</code> set the function to return option <code>opt</code>'s value.  
Each argument must be a character string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available options are:
</p>

<ol>
<li> <p><code>plot_rhat_breaks</code>: The cut off points for Rhat for which we
would indicate using a different color. This is a numeric vector,
defaulting to <code>c(1.1, 1.2, 1.5, 2)</code>.
The value for this option will be sorted in ascending order,
so for example <code>plot_rhat_breaks = c(1.2, 1.5)</code> is equivalent to
<code>plot_rhat_breaks = c(1.5, 1.2)</code>. 
</p>
</li>
<li> <p><code>plot_rhat_cols</code>: A vector of the same length as   
<code>plot_rhat_breaks</code> that indicates the colors for the
breaks.
</p>
</li>
<li> <p><code>plot_rhat_nan_col</code>: The color for Rhat when it is <code>Inf</code> or <code>NaN</code>. 
</p>
</li>
<li> <p><code>plot_rhat_large_col</code>: The color for Rhat when it is larger than 
the largest value of <code>plot_rhat_breaks</code>. 
</p>
</li>
<li> <p><code>rstan_alert_col</code>: The color used in method <code>plot</code>
of S4 class <code><a href="#topic+stanfit-class">stanfit</a></code>  to show that the vector/array
parameters are truncated. 
</p>
</li>
<li> <p><code>rstan_chain_cols</code>: The colors used in methods <code>plot</code>
and <code>traceplot</code> of S4 class <code><a href="#topic+stanfit-class">stanfit</a></code>  
for coloring different chains. 
</p>
</li>
<li> <p><code>rstan_warmup_bg_col</code>: The background color for  
the warmup area in the traceplots. 
</p>
</li>
<li> <p><code>boost_lib</code>: The path for the Boost C++ library used
to compile Stan models.  This option is valid 
for the whole <span class="rlang"><b>R</b></span> session if not changed again. 
</p>
</li>
<li> <p><code>eigen_lib</code>: The path for the Eigen C++ library used
to compile Stan models.  This option is valid 
for the whole <span class="rlang"><b>R</b></span> session if not changed again. 
</p>
</li>
<li> <p><code>auto_write</code>: A logical scalar (defaulting to <code>FALSE</code>) that
controls whether a compiled instance of a <code><a href="#topic+stanmodel-class">stanmodel-class</a></code>
is written to the hard disk in the same directory as the <code>.stan</code>
program.
</p>
</li>
<li> <p><code>threads_per_chain</code>: A positive integer (defaulting to <code>1</code>).
If the model was compiled with threading support, the number of
threads to use in parallelized sections _within_ an MCMC chain (e.g., when
using the Stan functions 'reduce_sum()' or 'map_rect()'). The actual number of CPU cores
used is 'chains * threads_per_chain' where 'chains' is the number of parallel chains.
For an example of using threading, see the Stan case study [Reduce Sum: A Minimal
Example](https://mc-stan.org/users/documentation/case-studies/reduce_sum_tutorial.html).
</p>
</li></ol>
 


<h3>Value</h3>

<p>The values as a <code>list</code> for existing options and <code>NA</code> for non-existent options.
When only one option is specified, its old value is returned. 
</p>

<hr>
<h2 id='rstan-internal'>Internal Functions and Methods</h2><span id='topic+rstan-internal'></span><span id='topic+get_cppcode+2CANY-method'></span><span id='topic+get_logposterior+2CANY-method'></span><span id='topic+get_adaptation_info+2CANY-method'></span><span id='topic+get_sampler_params+2CANY-method'></span><span id='topic+get_posterior_mean+2CANY-method'></span><span id='topic+get_elapsed_time+2CANY-method'></span><span id='topic+get_num_upars+2CANY-method'></span><span id='topic+log_prob+2CANY-method'></span><span id='topic+grad_log_prob+2CANY-method'></span><span id='topic+unconstrain_pars+2CANY-method'></span><span id='topic+constrain_pars+2CANY-method'></span><span id='topic+cpp_object_initializer'></span><span id='topic+cxxdso-class'></span><span id='topic+show+2Ccxxdso-method'></span><span id='topic+grab_cxxfun+2Ccxxdso-method'></span><span id='topic+is_dso_loaded+2Ccxxdso-method'></span><span id='topic+RNG'></span><span id='topic+OUT'></span>

<h3>Description</h3>

<p>These functions are not intended to be called directly. In the case of
methods, they are documented elsewhere, either with the associated generic
function or with the class of the object for which the method is defined.
</p>

<hr>
<h2 id='rstan-plotting-functions'>RStan Plotting Functions</h2><span id='topic+rstan-plotting-functions'></span>

<h3>Description</h3>

<p>List of RStan plotting functions that return ggplot objects
</p>


<h3>RStan plotting functions</h3>


<dl>
<dt>Posterior intervals and point estimates</dt><dd><p><code><a href="#topic+stan_plot">stan_plot</a></code></p>
</dd>
<dt>Traceplots</dt><dd><p><code><a href="#topic+stan_trace">stan_trace</a></code></p>
</dd>
<dt>Histograms</dt><dd><p><code><a href="#topic+stan_hist">stan_hist</a></code></p>
</dd>
<dt>Kernel density estimates</dt><dd><p><code><a href="#topic+stan_dens">stan_dens</a></code></p>
</dd>
<dt>Scatterplots</dt><dd><p><code><a href="#topic+stan_scat">stan_scat</a></code></p>
</dd>
<dt>Diagnostics for Hamiltonian Monte Carlo and the No-U-Turn Sampler</dt><dd><p><code><a href="#topic+stan_diag">stan_diag</a></code></p>
</dd>
<dt>Rhat</dt><dd><p><code><a href="#topic+stan_rhat">stan_rhat</a></code></p>
</dd>
<dt>Ratio of effective sample size to total posterior sample size</dt><dd><p><code><a href="#topic+stan_ess">stan_ess</a></code></p>
</dd>
<dt>Ratio of Monte Carlo standard error to posterior standard deviation</dt><dd><p><code><a href="#topic+stan_mcse">stan_mcse</a></code></p>
</dd>
<dt>Autocorrelation</dt><dd><p><code><a href="#topic+stan_plot">stan_plot</a></code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rstan_gg_options">Plot options</a></code>
</p>

<hr>
<h2 id='rstan.package.skeleton'>Create a Skeleton for a New Source Package with Stan Programs</h2><span id='topic+rstan.package.skeleton'></span>

<h3>Description</h3>

<p>This function has been removed from <span class="pkg">rstan</span>. Please use the new 
<code>rstan_package_skeleton</code> function in the <span class="pkg">rstantools</span> package.
</p>

<hr>
<h2 id='sampling'>Draw samples from a Stan model</h2><span id='topic+sampling'></span><span id='topic+sampling+2Cstanmodel-method'></span>

<h3>Description</h3>

<p>Draw samples from the model defined by class <code>stanmodel</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S4 method for signature 'stanmodel'
sampling(object, data = list(), pars = NA, 
    chains = 4, iter = 2000, warmup = floor(iter/2), thin = 1,
    seed = sample.int(.Machine$integer.max, 1), 
    init = 'random', check_data = TRUE, 
    sample_file = NULL, diagnostic_file = NULL, verbose = FALSE, 
    algorithm = c("NUTS", "HMC", "Fixed_param"),
    control = NULL, include = TRUE, 
    cores = getOption("mc.cores", 1L),
    open_progress = interactive() &amp;&amp; !isatty(stdout()) &amp;&amp;
                    !identical(Sys.getenv("RSTUDIO"), "1"),
    show_messages = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampling_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanmodel-class">stanmodel</a></code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code>
providing the data for the model or a character vector 
for all the names of objects used as data. 
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr> 
<tr><td><code id="sampling_+3A_pars">pars</code></td>
<td>
<p>A vector of character strings specifying parameters of interest. 
The default is <code>NA</code> indicating all parameters in the model. 
If <code>include = TRUE</code>, only samples for parameters named in <code>pars</code> 
are stored in the fitted results. Conversely, if <code>include = FALSE</code>, 
samples for all parameters <em>except</em> those named in <code>pars</code> are 
stored in the fitted results.</p>
</td></tr>
<tr><td><code id="sampling_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains. 
The default is 4.</p>
</td></tr> 
<tr><td><code id="sampling_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each 
chain (including warmup). The default is 2000.</p>
</td></tr>
<tr><td><code id="sampling_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka burnin)
iterations per chain. If step-size adaptation is on (which it is by default), 
this also controls the number of iterations for which adaptation is run (and
hence these warmup samples should not be used for inference). The number of 
warmup iterations should be smaller than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples. 
The default is 1, which is usually the recommended value.</p>
</td></tr>
<tr><td><code id="sampling_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated 
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine. Even if 
multiple chains are used, only one seed is needed, with other chains having 
seeds derived from that of the first chain to avoid dependent samples.
When a seed is specified by a number, <code>as.integer</code> will be applied to it. 
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly. 
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.</p>
</td></tr>
<tr><td><code id="sampling_+3A_init">init</code></td>
<td>
<p>Initial values specification. See the detailed documentation for 
the init argument in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_check_data">check_data</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>. If <code>TRUE</code> 
the data will be preprocessed; otherwise not.
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_sample_file">sample_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the draws for <em>all</em> parameters and other saved quantities
will be written to the file. If not provided, files are not created. 
When the folder specified is not writable, <code>tempdir()</code> is used. 
When there are multiple chains, an underscore and chain number are appended
to the file name prior to the <code>.csv</code> extension.</p>
</td></tr>
<tr><td><code id="sampling_+3A_diagnostic_file">diagnostic_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the diagnostics data for <em>all</em> parameters will be written
to the file. If not provided, files are not created. When the folder specified 
is not writable, <code>tempdir()</code> is used. When there are multiple chains, 
an underscore and chain number are appended to the file name prior to the
<code>.csv</code> extension.</p>
</td></tr>
<tr><td><code id="sampling_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>: flag indicating whether 
to print intermediate output from Stan on the console, which might
be helpful for model debugging.</p>
</td></tr>
<tr><td><code id="sampling_+3A_algorithm">algorithm</code></td>
<td>
<p>One of sampling algorithms that are implemented in Stan. 
Current options are <code>"NUTS"</code> (No-U-Turn sampler, Hoffman and Gelman 2011, Betancourt 2017), 
<code>"HMC"</code> (static HMC), or <code>"Fixed_param"</code>. The default and 
preferred algorithm is <code>"NUTS"</code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. See the details in the documentation for the <code>control</code> argument
in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_include">include</code></td>
<td>
<p>Logical scalar defaulting to <code>TRUE</code> indicating
whether to include or exclude the parameters given by the 
<code>pars</code> argument. If <code>FALSE</code>, only entire multidimensional
parameters can be excluded, rather than particular elements of them.</p>
</td></tr>
<tr><td><code id="sampling_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use when executing the chains in parallel,
which defaults to 1 but we recommend setting the <code>mc.cores</code> option 
to be as many processors as the hardware and RAM allow (up to the 
number of chains).</p>
</td></tr>
<tr><td><code id="sampling_+3A_open_progress">open_progress</code></td>
<td>
<p>Logical scalar that only takes effect if 
<code>cores &gt; 1</code> but is recommended to be <code>TRUE</code> in interactive
use so that the progress of the chains will be redirected to a file
that is automatically opened for inspection. For very short runs, the
user might prefer <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="sampling_+3A_show_messages">show_messages</code></td>
<td>
<p>Either a logical scalar (defaulting to <code>TRUE</code>)
indicating whether to print the summary of Informational Messages to
the screen after a chain is finished or a character string naming a path
where the summary is stored. Setting to <code>FALSE</code> is not recommended
unless you are very sure that the model is correct up to numerical 
error.</p>
</td></tr>
<tr><td><code id="sampling_+3A_...">...</code></td>
<td>
<p>Additional arguments can be <code>chain_id</code>, <code>init_r</code>, 
<code>test_grad</code>, <code>append_samples</code>, <code>refresh</code>,
<code>enable_random_init</code>. See the documentation in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>An object of S4 class <code>stanfit</code> representing
the fitted results. Slot <code>mode</code> for this object
indicates if the sampling is done or not. 
</p>


<h3>Methods</h3>


<dl>
<dt><code>sampling</code></dt><dd><p><code>signature(object = "stanmodel")</code>
Call a sampler (NUTS, HMC, or Fixed_param depending on parameters) 
to draw samples from the model defined by S4 class <code>stanmodel</code> 
given the data, initial values, etc. 
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+stanmodel-class">stanmodel</a></code>, <code><a href="#topic+stanfit-class">stanfit</a></code>, <code><a href="#topic+stan">stan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
f &lt;- sampling(m, iter = 100)

## End(Not run)</code></pre>

<hr>
<h2 id='sbc'>Simulation Based Calibration (sbc)</h2><span id='topic+sbc'></span><span id='topic+print.sbc'></span><span id='topic+plot.sbc'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Check whether a model is well-calibrated with respect to the
prior distribution and hence possibly amenable to obtaining
a posterior distribution conditional on observed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sbc(stanmodel, data, M, ..., save_progress, load_incomplete=FALSE)
  ## S3 method for class 'sbc'
plot(x, thin = 3, ...)
  ## S3 method for class 'sbc'
print(x, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sbc_+3A_stanmodel">stanmodel</code></td>
<td>

<p>An object of <code><a href="#topic+stanmodel-class">stanmodel-class</a></code> that is first created by
calling the <code><a href="#topic+stan_model">stan_model</a></code> function</p>
</td></tr>
<tr><td><code id="sbc_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code> providing the data for
the model, or a character vector for all the names of objects to use as data.
This is the same format as in <code><a href="#topic+stan">stan</a></code> or <code><a href="#topic+sampling">sampling</a></code>.</p>
</td></tr>
<tr><td><code id="sbc_+3A_m">M</code></td>
<td>

<p>The number of times to condition on draws from the prior predictive
distribution</p>
</td></tr>
<tr><td><code id="sbc_+3A_...">...</code></td>
<td>
<p>Additional arguments that are passed to <code><a href="#topic+sampling">sampling</a></code>,
such as <code>refresh = 0</code> when calling <code>sbc</code>. For the <code>plot</code>
and <code>print</code> methods, the additional arguments are not used.</p>
</td></tr>
<tr><td><code id="sbc_+3A_x">x</code></td>
<td>
<p>An object produced by <code>sbc</code></p>
</td></tr>
<tr><td><code id="sbc_+3A_thin">thin</code></td>
<td>
<p>An integer vector of length one indicating the thinning interval
when plotting, which defaults to 3</p>
</td></tr>
<tr><td><code id="sbc_+3A_save_progress">save_progress</code></td>
<td>
<p>If a directory is provided, stanfit objects
are saved to disk making it easy to resume a partial <code>sbc</code>
run after interruption.</p>
</td></tr>
<tr><td><code id="sbc_+3A_load_incomplete">load_incomplete</code></td>
<td>
<p>When <code>save_progress</code> is used, load
whatever runs have been saved to disk and ignore argument <code>M</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes adherence to the following conventions in the
underlying Stan program:
</p>

<ol>
<li><p> Realizations of the unknown parameters are drawn in the <code>transformed data</code>
block of the Stan program and are postfixed with an underscore, such as
<code>theta_</code>. These are considered the &ldquo;true&rdquo; parameters being estimated by
the corresponding symbol declared in the <code>parameters</code> block, which
should have the same name except for the trailing underscore, such as <code>theta</code>.
</p>
</li>
<li><p> The realizations of the unknown parameters are then conditioned on when drawing from
the prior predictive distribution, also in the <code>transformed data</code> block.
There is no restriction on the symbol name that holds the realizations from
the prior predictive distribution but for clarity, it should not end with
a trailing underscore.
</p>
</li>
<li><p> The realizations of the unknown parameters should be copied into a <code>vector</code>
in the <code>generated quantities</code> block named <code>pars_</code>.
</p>
</li>
<li><p> The realizations from the prior predictive distribution should be copied
into an object (of the same type) in the <code>generated quantities</code> block
named <code>y_</code>. Technically, this step is optional and could be omitted
to conserve RAM, but inspecting the realizations from the prior predictive distribution
is a good way to judge whether the priors are reasonable.
</p>
</li>
<li><p> The <code>generated quantities</code> block must contain an integer array named
<code>ranks_</code> whose only values are zero or one, depending on whether the realization of a
parameter from the posterior distribution exceeds the corresponding &ldquo;true&rdquo;
realization, such as <code>theta &gt; theta_;</code>. These are not actually &quot;ranks&quot;
but can be used afterwards to reconstruct (thinned) ranks.
</p>
</li>
<li><p> The <code>generated quantities</code> block may contain a vector named <code>log_lik</code>
whose values are the contribution to the log-likelihood by each observation. This
is optional but facilitates calculating Pareto k shape parameters to judge whether
the posterior distribution is sensitive to particular observations.
</p>
</li></ol>

<p>Although the user can pass additional arguments to <code><a href="#topic+sampling">sampling</a></code> through the ...,
the following arguments are hard-coded and should not be passed through the ...:
</p>

<ol>
<li> <p><code>pars = "ranks_"</code> because nothing else needs to be stored for each posterior draw
</p>
</li>
<li> <p><code>include = TRUE</code> to ensure that <code>"ranks_"</code> is included rather than excluded
</p>
</li>
<li> <p><code>chains = 1</code> because only one chain is run for each integer less than <code>M</code>
</p>
</li>
<li> <p><code>seed</code> because a sequence of seeds is used across the <code>M</code> runs to preserve
independence across runs
</p>
</li>
<li> <p><code>save_warmup = FALSE</code> because the warmup realizations are not relevant
</p>
</li>
<li> <p><code>thin = 1</code> because thinning can and should be done after the Markov Chain is
finished, as is done by the <code>thin</code> argument to the <code>plot</code> method in order to
make the histograms consist of approximately independent realizations
</p>
</li></ol>

<p>Other arguments will take the default values used by <code><a href="#topic+sampling">sampling</a></code> unless
passed through the .... Specifying <code>refresh = 0</code> is recommended to avoid printing
a lot of intermediate progress reports to the screen. It may be necessary to pass a
list to the <code>control</code> argument of <code><a href="#topic+sampling">sampling</a></code> with elements <code>adapt_delta</code>
and / or <code>max_treedepth</code> in order to obtain adequate results.
</p>
<p>Ideally, users would want to see the absence of divergent transitions (which is shown
by the <code>print</code> method) and other warnings, plus an approximately uniform histogram
of the ranks for each parameter (which are shown by the <code>plot</code> method). See the
vignette for more details.
</p>


<h3>Value</h3>

<p>The <code>sbc</code> function outputs a list of S3 class <code>"sbc"</code>, which contains the
following elements:
</p>

<ol>
<li> <p><code>ranks</code> A list of <code>M</code> matrices, each with number of
rows equal to the number of saved iterations and number of columns equal to
the number of unknown parameters. These matrices contain the realizations
of the <code>ranks_</code> object from the <code>generated quantities</code> block of the
Stan program.
</p>
</li>
<li> <p><code>Y</code> If present, a matrix of realizations from the prior predictive
distribution whose rows are equal to the number of observations and whose columns
are equal to <code>M</code>, which are taken from the <code>y_</code> object in the
<code>generated quantities</code> block of the Stan program.
</p>
</li>
<li> <p><code>pars</code> A matrix of realizations from the prior distribution whose rows
are equal to the number of parameters and whose columns are equal to <code>M</code>,
which are taken from the <code>pars_</code> object in the <code>generated quantities</code>
block of the Stan program.
</p>
</li>
<li> <p><code>pareto_k</code> A matrix of Pareto k shape parameter estimates or <code>NULL</code>
if there is no <code>log_lik</code> symbol in the <code>generated quantities</code> block
of the Stan program
</p>
</li>
<li> <p><code>sampler_params</code> A three-dimensional array that results from combining
calls to <code><a href="#topic+get_sampler_params">get_sampler_params</a></code> for each of
the <code>M</code> runs. The resulting matrix has rows equal to the number of
post-warmup iterations, columns equal to six, and <code>M</code> floors. The columns
are named <code>"accept_stat__"</code>, <code>"stepsize__"</code>, <code>"treedepth__"</code>,
<code>"n_leapfrog__"</code>, <code>"divergent__"</code>, and <code>"energy__"</code>. The most
important of which is <code>"divergent__"</code>, which should be all zeros and
perhaps <code>"treedepth__"</code>, which should only rarely get up to the value
of <code>max_treedepth</code> passed as an element of the <code>control</code> list
to <code><a href="#topic+sampling">sampling</a></code> or otherwise defaults to <code class="reqn">10</code>.
</p>
</li></ol>

<p>The <code>print</code> method outputs the number of divergent transitions and
returns <code>NULL</code> invisibly.
The <code>plot</code> method returns a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
with histograms whose appearance can be further customized.
</p>


<h3>References</h3>

<p>The Stan Development Team
<em>Stan Modeling Language User's Guide and Reference Manual</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>
<p>Talts, S., Betancourt, M., Simpson, D., Vehtari, A., and Gelman, A. (2018).
Validating Bayesian Inference Algorithms with Simulation-Based Calibration.
arXiv preprint arXiv:1804.06788. <a href="https://arxiv.org/abs/1804.06788">https://arxiv.org/abs/1804.06788</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_model">stan_model</a></code> and <code><a href="#topic+sampling">sampling</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scode &lt;- "
data {
  int&lt;lower = 1&gt; N;
  real&lt;lower = 0&gt; a;
  real&lt;lower = 0&gt; b;
}
transformed data { // these adhere to the conventions above
  real pi_ = beta_rng(a, b);
  int y = binomial_rng(N, pi_);
}
parameters {
  real&lt;lower = 0, upper = 1&gt; pi;
}
model {
  target += beta_lpdf(pi | a, b);
  target += binomial_lpmf(y | N, pi);
}
generated quantities { // these adhere to the conventions above
  int y_ = y;
  vector[1] pars_;
  int ranks_[1] = {pi &gt; pi_};
  vector[N] log_lik;
  pars_[1] = pi_;
  for (n in 1:y) log_lik[n] = bernoulli_lpmf(1 | pi);
  for (n in (y + 1):N) log_lik[n] = bernoulli_lpmf(0 | pi);
}
"
</code></pre>

<hr>
<h2 id='set_cppo'>Defunct function to set the compiler optimization level</h2><span id='topic+set_cppo'></span>

<h3>Description</h3>

<p>This function returns nothing and does nothing except throw a warning. See <a href="https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Customizing-package-compilation">https://cran.r-project.org/doc/manuals/r-release/R-admin.html#Customizing-package-compilation</a> for information on customizing the compiler options, but doing so should be unnecessary for normal useage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  set_cppo(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_cppo_+3A_...">...</code></td>
<td>
<p>Any input is ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An invisible <code>NULL</code>
</p>

<hr>
<h2 id='sflist2stanfit'>Merge a list of stanfit objects into one</h2><span id='topic+sflist2stanfit'></span>

<h3>Description</h3>

<p>This function takes a list of <code>stanfit</code> objects and returns a
consolidated <code>stanfit</code> object. The <code>stanfit</code> objects to be merged
need to have the same configuration of iteration, warmup, and thin, besides
being from the same model.  This could facilitate some parallel usage of RStan.
For example, if we call <code><a href="#topic+stan">stan</a></code> by parallel and it returns a list of
<code>stanfit</code> objects, this function can be used to create one <code>stanfit</code>
object from the list. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  sflist2stanfit(sflist) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sflist2stanfit_+3A_sflist">sflist</code></td>
<td>
<p>A list of <code>stanfit</code> objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of <code>stanfit</code> consolidated from all the input <code>stanfit</code>
objects. 
</p>


<h3>Note</h3>

<p>This function should be called in rare circumstances because 
<code><a href="#topic+sampling">sampling</a></code> has a <code>cores</code> argument that allows multiple
chains to be executed in parallel. However, if you need to depart from that,
the best practice is to use <code>sflist2stanfit</code> on a list of <code>stanfit</code>
objects created with the same <code>seed</code> but different <code>chain_id</code> (see
example below). Using the same seed but different chain_id can make sure 
the random number generations for all chains are not correlated. 
</p>
<p>This function would do some check to see if the <code>stanfit</code> objects in the input list 
can be merged. But the check is not sufficient. So generally, it is the
user's responsibility to make sure the input is correct so that the merging
makes sense. 
</p>
<p>The date in the new <code>stanfit</code> object is when it is merged. 
</p>
<p><code>get_seed</code> function for the new consolidated <code>stanfit</code> object only returns
the seed used in the first chain of the new object. 
</p>
<p>The sampler such as NUTS2 that is displayed in the printout by <code>print</code> 
is the sampler used for the first chain. The <code>print</code> method assumes the samplers
are the same for all chains. 
</p>
<p>The included <code>stanmodel</code> object, which includes the compiled model, 
in the new <code>stanfit</code> object is from the first element of the input list. 
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan">stan</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(rstan)
scode &lt;- "
data {
  int&lt;lower=1&gt; N;
} 
parameters {
  array[N] real y1;
  array[N] real y2; 
} 
model {
  y1 ~ normal(0, 1);
  y2 ~ double_exponential(0, 2);
} 
"
seed &lt;- 123 # or any other integer 
foo_data &lt;- list(N = 2)
foo &lt;- stan(model_code = scode, data = foo_data, chains = 1, iter = 1)
f1 &lt;- stan(fit = foo, data = foo_data, chains = 1, seed = seed, chain_id = 1) 
f2 &lt;- stan(fit = foo, data = foo_data, chains = 2, seed = seed, chain_id = 2:3) 
f12 &lt;- sflist2stanfit(list(f1, f2)) 

## parallel stan call for unix-like OS
library(parallel)

if (.Platform$OS.type == "unix") {
sflist1 &lt;- 
  mclapply(1:4, mc.cores = 2, 
           function(i) stan(fit = foo, data = foo_data, seed = seed, 
	                    chains = 1, chain_id = i, refresh = -1))
f3 &lt;- sflist2stanfit(sflist1)
}
if (.Platform$OS.type == "windows") { # also works on non-Windows
CL &lt;- makeCluster(2)
clusterExport(cl = CL, c("foo_data", "foo", "seed")) 
sflist1 &lt;- parLapply(CL, 1:4, fun = function(cid) {  
  require(rstan)
  stan(fit = foo, data = foo_data, chains = 1, 
       iter = 2000, seed = seed, chain_id = cid)
})

fit &lt;- sflist2stanfit(sflist1)
print(fit)
stopCluster(CL)
} # end example for Windows 

## End(Not run)</code></pre>

<hr>
<h2 id='stan'>Fit a model with Stan</h2><span id='topic+stan'></span>

<h3>Description</h3>

<p><img src="../help/figures/stanlogo.png" width="25" alt="https://mc-stan.org/about/logo/" />
Fit a model defined in the Stan modeling language and
return the fitted result as an instance of <code>stanfit</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan(file, model_name = "anon_model", model_code = "", fit = NA,
  data = list(), pars = NA,
  chains = 4, iter = 2000, warmup = floor(iter/2), thin = 1,
  init = "random", seed = sample.int(.Machine$integer.max, 1),
  algorithm = c("NUTS", "HMC", "Fixed_param"), 
  control = NULL, sample_file = NULL, diagnostic_file = NULL,
  save_dso = TRUE, verbose = FALSE, include = TRUE,
  cores = getOption("mc.cores", 1L),
  open_progress = interactive() &amp;&amp; !isatty(stdout()) &amp;&amp;
                  !identical(Sys.getenv("RSTUDIO"), "1"),
  ...,
  boost_lib = NULL, eigen_lib = NULL
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_+3A_file">file</code></td>
<td>

<p>The path to the Stan program to use.
<code>file</code> should be a character string file name or a connection that
<span class="rlang"><b>R</b></span> supports containing the text of a model specification in the Stan
modeling language.
</p>
<p>A model may also be specified directly as a character string using the
<code>model_code</code> argument, but we recommend always putting Stan programs
in separate files with a <code>.stan</code> extension.
</p>
<p>The <code>stan</code> function can also use the Stan program from an existing
<code>stanfit</code> object via the <code>fit</code> argument. When <code>fit</code> is
specified, the <code>file</code> argument is ignored.
</p>
</td></tr>
<tr><td><code id="stan_+3A_model_code">model_code</code></td>
<td>

<p>A character string either containing the model definition or the name of
a character string object in the workspace. This argument is used only
if arguments <code>file</code> and <code>fit</code> are not specified.
</p>
</td></tr>
<tr><td><code id="stan_+3A_fit">fit</code></td>
<td>

<p>An instance of S4 class <code>stanfit</code> derived from a previous fit;
defaults to <code>NA</code>. If <code>fit</code> is not <code>NA</code>, the compiled model
associated with the fitted result is re-used; thus the time that would
otherwise be spent recompiling the C++ code for the model can be saved.
</p>
</td></tr>
<tr><td><code id="stan_+3A_model_name">model_name</code></td>
<td>

<p>A string to use as the name of the model; defaults
to <code>"anon_model"</code>. However, the model name will be derived from
<code>file</code> or <code>model_code</code> (if <code>model_code</code> is the name
of a character string object) if <code>model_name</code> is not specified.
This is not a particularly important argument, although since it
affects the name used in printed messages, developers of other packages
that use <span class="pkg">rstan</span> to fit models may want to use informative names.
</p>
</td></tr>
<tr><td><code id="stan_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code> providing the data for
the model, or a character vector for all the names of objects to use as data.
See the <strong>Passing data to Stan</strong> section below.</p>
</td></tr>
<tr><td><code id="stan_+3A_pars">pars</code></td>
<td>
<p>A character vector specifying parameters of interest to be saved.
The default is to save all parameters from the model.
If <code>include = TRUE</code>, only samples for parameters named in <code>pars</code>
are stored in the fitted results. Conversely, if <code>include = FALSE</code>,
samples for all parameters <em>except</em> those named in <code>pars</code> are
stored in the fitted results.</p>
</td></tr>
<tr><td><code id="stan_+3A_include">include</code></td>
<td>
<p>Logical scalar defaulting to <code>TRUE</code> indicating
whether to include or exclude the parameters given by the
<code>pars</code> argument. If <code>FALSE</code>, only entire multidimensional
parameters can be excluded, rather than particular elements of them.</p>
</td></tr>
<tr><td><code id="stan_+3A_iter">iter</code></td>
<td>
<p>A positive integer specifying the number of iterations for each
chain (including warmup). The default is 2000.</p>
</td></tr>
<tr><td><code id="stan_+3A_warmup">warmup</code></td>
<td>
<p>A positive integer specifying the number of warmup (aka burnin)
iterations per chain. If step-size adaptation is on (which it is by default),
this also controls the number of iterations for which adaptation is run (and
hence these warmup samples should not be used for inference). The number of
warmup iterations should be smaller than <code>iter</code> and the default is
<code>iter/2</code>.</p>
</td></tr>
<tr><td><code id="stan_+3A_chains">chains</code></td>
<td>
<p>A positive integer specifying the number of Markov chains.
The default is 4.</p>
</td></tr>
<tr><td><code id="stan_+3A_cores">cores</code></td>
<td>

<p>The number of cores to use when executing the Markov chains in parallel.
The default is to use the value of the <code>"mc.cores"</code> option if it
has been set and otherwise to default to 1 core. However, we recommend
setting it to be as many processors as the hardware and RAM allow
(up to the number of chains). See <code><a href="parallel.html#topic+detectCores">detectCores</a></code>
if you don't know this number for your system.
</p>
</td></tr>
<tr><td><code id="stan_+3A_thin">thin</code></td>
<td>
<p>A positive integer specifying the period for saving samples.
The default is 1, which is usually the recommended value. Unless your
posterior distribution takes up too much memory we do <em>not</em> recommend
thinning as it throws away information. The tradition of thinning when
running MCMC stems primarily from the use of samplers that require
a large number of iterations to achieve the desired effective sample size.
Because of the efficiency (effective samples per second) of
Hamiltonian Monte Carlo, rarely should this be necessary when using Stan.</p>
</td></tr>
<tr><td><code id="stan_+3A_init">init</code></td>
<td>

<p>Specification of initial values for all or some parameters.
Can be the digit <code>0</code>, the strings <code>"0"</code> or <code>"random"</code>,
a function that returns a named list, or a list of named lists:
</p>

<dl>
<dt><code>init="random"</code> (default):</dt><dd><p>Let Stan generate random initial values
for all parameters. The seed of the random number generator used by Stan
can be specified via the <code>seed</code> argument. If the seed for Stan is
fixed, the same initial values are used. The default is to randomly
generate initial values between <code>-2</code> and <code>2</code> <em>on the
unconstrained support</em>. The optional additional parameter <code>init_r</code> can
be set to some value other than <code>2</code> to change the range of the randomly
generated inits.</p>
</dd>
<dt><code>init="0", init=0</code>:</dt><dd><p>Initialize all parameters to zero on
the unconstrained support.</p>
</dd>
<dt>inits via list:</dt><dd><p>Set inital values by providing a list
equal in length to the number of chains. The elements of this list should
themselves be named lists, where each of these named lists has the name
of a parameter and is used to specify the initial values for that parameter
for the corresponding chain.</p>
</dd>
<dt>inits via function:</dt><dd><p>Set initial values by providing a function that
returns a list for specifying the initial values of parameters for a chain.
The function can take an optional parameter <code>chain_id</code> through which the
<code>chain_id</code> (if specified) or the integers from 1 to <code>chains</code> will be
supplied to the function for generating initial values.
See the <strong>Examples</strong> section below for examples of defining
such functions and using a list of lists for specifying initial values.</p>
</dd>
</dl>

<p>When specifying initial values via a <code>list</code> or <code>function</code>, any
parameters for which values are not specified will receive initial values
generated as described in the <code>init="random"</code> description above.
</p>
</td></tr>
<tr><td><code id="stan_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine. Even if
multiple chains are used, only one seed is needed, with other chains having
seeds derived from that of the first chain to avoid dependent samples.
When a seed is specified by a number, <code>as.integer</code> will be applied to it.
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly.
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.
</p>
<p>Using <span class="rlang"><b>R</b></span>'s <code>set.seed</code> function to set the seed for Stan will not work.
</p>
</td></tr>
<tr><td><code id="stan_+3A_algorithm">algorithm</code></td>
<td>

<p>One of the sampling algorithms that are implemented in Stan.
The default and preferred algorithm is <code>"NUTS"</code>, which is
the No-U-Turn sampler variant of Hamiltonian Monte Carlo
(Hoffman and Gelman 2011, Betancourt 2017). Currently the other options
are <code>"HMC"</code> (Hamiltonian Monte Carlo), and <code>"Fixed_param"</code>.
When <code>"Fixed_param"</code> is used no MCMC sampling is performed
(e.g., for simulating with in the generated quantities block).
</p>
</td></tr>
<tr><td><code id="stan_+3A_sample_file">sample_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the draws for <em>all</em> parameters and other saved quantities
will be written to the file. If not provided, files are not created.
When the folder specified is not writable, <code>tempdir()</code> is used.
When there are multiple chains, an underscore and chain number are appended
to the file name.</p>
</td></tr>
<tr><td><code id="stan_+3A_diagnostic_file">diagnostic_file</code></td>
<td>
<p>An optional character string providing the name of a file.
If specified the diagnostics data for <em>all</em> parameters will be written
to the file. If not provided, files are not created. When the folder specified
is not writable, <code>tempdir()</code> is used. When there are multiple chains,
an underscore and chain number are appended to the file name.</p>
</td></tr>
<tr><td><code id="stan_+3A_save_dso">save_dso</code></td>
<td>
<p>Logical, with default <code>TRUE</code>, indicating whether the
dynamic shared object (DSO) compiled from the C++ code for the model
will be saved or not. If <code>TRUE</code>, we can draw samples from
the same model in another <span class="rlang"><b>R</b></span> session using the saved DSO (i.e.,
without compiling the C++ code again).
This parameter only takes effect if <code>fit</code> is not used; with
<code>fit</code> defined, the DSO from the previous run is used.
When <code>save_dso=TRUE</code>, the fitted object can be loaded from
what is saved previously and used for sampling, if the compiling is
done on the same platform, that is, same operating system and same
architecture (32bits or 64bits).</p>
</td></tr>
<tr><td><code id="stan_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>: flag indicating whether
to print intermediate output from Stan on the console, which might
be helpful for model debugging.</p>
</td></tr>
<tr><td><code id="stan_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> of parameters to control the sampler's
behavior. It defaults to <code>NULL</code> so all the default values are used.
First, the following are adaptation parameters for sampling algorithms.
These are parameters used in Stan with similar names here.
</p>

<ul>
<li> <p><code>adapt_engaged</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>adapt_gamma</code> (<code>double</code>, positive, defaults to 0.05)
</p>
</li>
<li> <p><code>adapt_delta</code> (<code>double</code>, between 0 and 1, defaults to 0.8)
</p>
</li>
<li> <p><code>adapt_kappa</code> (<code>double</code>, positive, defaults to 0.75)
</p>
</li>
<li> <p><code>adapt_t0</code> (<code>double</code>, positive, defaults to 10)
</p>
</li>
<li> <p><code>adapt_init_buffer</code> (<code>integer</code>, positive, defaults to 75)
</p>
</li>
<li> <p><code>adapt_term_buffer</code> (<code>integer</code>, positive, defaults to 50)
</p>
</li>
<li> <p><code>adapt_window</code> (<code>integer</code>, positive, defaults to 25)
</p>
</li></ul>

<p>In addition, algorithm HMC (called 'static HMC' in Stan) and NUTS share the
following parameters:
</p>

<ul>
<li> <p><code>stepsize</code> (<code>double</code>, positive, defaults to 1)
Note: this controls the <em>initial</em> stepsize only, unless <code>adapt_engaged=FALSE</code>.
</p>
</li>
<li> <p><code>stepsize_jitter</code> (<code>double</code>, [0,1], defaults to 0)
</p>
</li>
<li> <p><code>metric</code> (<code>string</code>, one of &quot;unit_e&quot;, &quot;diag_e&quot;, &quot;dense_e&quot;,
defaults to &quot;diag_e&quot;)
</p>
</li></ul>

<p>For algorithm NUTS, we can also set:
</p>

<ul>
<li> <p><code>max_treedepth</code> (<code>integer</code>, positive, defaults to 10)
</p>
</li></ul>

<p>For algorithm HMC, we can also set:
</p>

<ul>
<li> <p><code>int_time</code> (<code>double</code>, positive)
</p>
</li></ul>

<p>For <code>test_grad</code> mode, the following parameters can be set:
</p>

<ul>
<li> <p><code>epsilon</code> (<code>double</code>, defaults to 1e-6)
</p>
</li>
<li> <p><code>error</code> (<code>double</code>, defaults to 1e-6)
</p>
</li></ul>

</td></tr>
<tr><td><code id="stan_+3A_open_progress">open_progress</code></td>
<td>
<p>Logical scalar that only takes effect if
<code>cores &gt; 1</code> but is recommended to be <code>TRUE</code> in interactive
use so that the progress of the chains will be redirected to a file
that is automatically opened for inspection. For very short runs, the
user might prefer <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="stan_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>chain_id</code> (<code>integer</code>)
</p>
</li>
<li> <p><code>init_r</code> (<code>double</code>, positive)
</p>
</li>
<li> <p><code>test_grad</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>append_samples</code> (<code>logical</code>)
</p>
</li>
<li> <p><code>refresh</code>(<code>integer</code>)
</p>
</li>
<li> <p><code>save_warmup</code>(<code>logical</code>)
</p>
</li>
<li><p> deprecated: <code>enable_random_init</code>(<code>logical</code>)
</p>
</li></ul>

<p><code>chain_id</code> can be a vector to specify the chain_id for all
chains or an integer. For the former case, they should be unique.
For the latter, the sequence of integers starting from the given
<code>chain_id</code> are used for all chains.
</p>
<p><code>init_r</code> is used only for generating random initial values,
specifically when <code>init="random"</code> or not all parameters
are initialized in the user-supplied list or function. If specified,
the initial values are simulated uniformly from interval
[-<code>init_r</code>, <code>init_r</code>] rather than using the default interval
(see the manual of (cmd)Stan).
</p>
<p><code>test_grad</code> (<code>logical</code>).
If <code>test_grad=TRUE</code>, Stan will not do any sampling. Instead,
the gradient calculation is tested and printed out and the fitted
<code>stanfit</code> object is in test gradient mode.  By default, it is
<code>FALSE</code>.
</p>
<p><code>append_samples</code> (<code>logical</code>).
Only relevant if <code>sample_file</code> is specified <em>and</em> is an
existing file. In that case, setting <code>append_samples=TRUE</code> will append
the samples to the existing file rather than overwriting the contents of
the file.
</p>
<p><code>refresh</code> (<code>integer</code>) can be used to
control how often the progress of the sampling is reported (i.e.
show the progress every <code>refresh</code> iterations).
By default, <code>refresh = max(iter/10, 1)</code>.
The progress indicator is turned off if <code>refresh &lt;= 0</code>.
</p>
<p>Deprecated: <code>enable_random_init</code> (<code>logical</code>) being <code>TRUE</code>
enables specifying initial values randomly when the initial
values are not fully specified from the user.
</p>
<p><code>save_warmup</code> (<code>logical</code>) indicates whether to
save draws during the warmup phase and defaults to <code>TRUE</code>. Some
memory related problems can be avoided by setting it to <code>FALSE</code>,
but some diagnostics are more limited if the warmup draws are not
stored.
</p>
</td></tr>
<tr><td><code id="stan_+3A_boost_lib">boost_lib</code></td>
<td>
<p>The path for an alternative version of the Boost C++
to use instead of the one in the <span class="pkg">BH</span> package.</p>
</td></tr>
<tr><td><code id="stan_+3A_eigen_lib">eigen_lib</code></td>
<td>
<p>The path for an alternative version of the Eigen C++
library to the one in <span class="pkg">RcppEigen</span>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stan</code> function does all of the work of fitting a Stan model and
returning the results as an instance of <code>stanfit</code>. The steps are
roughly as follows:
</p>

<ol>
<li><p> Translate the Stan model to C++ code.  (<code><a href="#topic+stanc">stanc</a></code>)
</p>
</li>
<li><p> Compile the C++ code into a binary shared object, which
is loaded into the current <span class="rlang"><b>R</b></span> session (an object
of S4 class <code>stanmodel</code> is created).   (<code><a href="#topic+stan_model">stan_model</a></code>)
</p>
</li>
<li><p> Draw samples and wrap them in an object of S4 class <code>stanfit</code>. (<code><a href="#topic+sampling">sampling</a></code>)
</p>
</li></ol>

<p>The returned object can be used with methods such as <code>print</code>,
<code>summary</code>, and <code>plot</code> to inspect and retrieve the results of
the fitted model.
</p>
<p><code>stan</code> can also be used to sample again from a fitted model under
different settings (e.g., different <code>iter</code>, <code>data</code>, etc.) by
using the <code>fit</code> argument to specify an existing <code>stanfit</code> object.
In this case, the compiled C++ code for the model is reused.
</p>


<h3>Value</h3>

<p>An object of S4 class <code><a href="#topic+stanfit">stanfit</a></code>. However, if <code>cores &gt; 1</code>
and there is an error for any of the chains, then the error(s) are printed. If
all chains have errors and an error occurs before or during sampling, the returned
object does not contain samples. But the compiled binary object for the
model is still included, so we can reuse the returned object for another
sampling.
</p>


<h3>Passing data to Stan</h3>

<p>The data passed to <code>stan</code> are preprocessed before being passed to Stan.
If <code>data</code> is not a character vector, the data block of the Stan program
is parsed and <span class="rlang"><b>R</b></span> objects of the same name are searched starting from the
calling environment. Then, if <code>data</code> is list-like but not a <code>data.frame</code>
the elements of <code>data</code> take precedence. This behavior is similar to how
a <code>formula</code> is evaluated by the <code><a href="stats.html#topic+lm">lm</a></code> function when <code>data</code> is
supplied. In general, each <span class="rlang"><b>R</b></span> object being passed to Stan should be either a numeric
vector (including the special case of a 'scalar') or a numeric array (matrix).
The first exception is that an element can be a logical vector: <code>TRUE</code>'s
are converted to 1 and <code>FALSE</code>'s to 0.
An element can also be a data frame or a specially structured list (see
details below), both of which will be converted into arrays in the
preprocessing.  Using a specially structured list is not
encouraged though it might be convenient sometimes; and when in doubt, just
use arrays.
</p>
<p>This preprocessing for each element mainly includes the following:
</p>

<ol>
<li><p> Change the data of type from <code>double</code>
to <code>integer</code> if no accuracy is lost. The main
reason is that by default, <span class="rlang"><b>R</b></span> uses <code>double</code>
as data type such as in <code>a &lt;- 3</code>. But Stan
will not read data of type <code>int</code> from <code>real</code>
and it reads data from <code>int</code> if the data
type is declared as <code>real</code>.
</p>
</li>
<li><p> Check if there is <code>NA</code> in the data.
Unlike BUGS, Stan does not allow missing data. Any <code>NA</code> values
in supplied data will cause the function to stop and report an error.
</p>
</li>
<li><p> Check data types.  Stan allows only numeric data, that is,
doubles, integers, and arrays of these.  Data of other types (for
example, characters and factors) are not passed to Stan.
</p>
</li>
<li><p> Check whether there are objects in the data list with duplicated names.
Duplicated names, if found, will cause the function to stop and
report an error.
</p>
</li>
<li><p> Check whether the names of objects in the data list are legal
Stan names. If illegal names are found, it will stop and
report an error. See (Cmd)Stan's manual for the rules of variable names.
</p>
</li>
<li><p> When an element is of type <code>data.frame</code>, it will be converted to
<code>matrix</code> by function <code>data.matrix</code>.
</p>
</li>
<li><p> When an element is of type <code>list</code>, it is supposed to make it
easier to pass data for those declared in Stan code such as
<code>"vector[J] y1[I]"</code> and <code>"matrix[J,K] y2[I]"</code>. Using the latter
as an example, we can use a list for <code>y2</code> if the list has &quot;I&quot; elements,
each of which is an array (matrix) of dimension &quot;J*K&quot;. However, it is
not possible to pass a list for data declared such as
<code>"vector[K] y3[I,J]"</code>; the only way for it is to use an array with
dimension &quot;I*J*K&quot;. In addition, technically a <code>data.frame</code> in R is
also a list, but it should not be used for the purpose here since a
<code>data.frame</code> will be converted to a matrix as described above.
</p>
</li></ol>

<p>Stan treats a vector of length 1 in R as a scalar.  So technically
if, for example, <code>"array[1] real y;"</code> is defined in the data block, an array
such as <code>"y = array(1.0, dim = 1)"</code> in R should be used. This
is also the case for specifying initial values since the same
underlying approach for reading data from R in Stan is used, in which
vector of length 1 is treated as a scalar.
</p>
<p>In general, the higher the optimization level is set, the faster the
generated binary code for the model runs, which can be set in a Makevars file.
However, the binary code generated for the model runs fast by using a higher
optimization level at the cost of longer times to compile the C++ code.
</p>


<h3>References</h3>

<p>The Stan Development Team
<em>Stan Modeling Language User's Guide and Reference Manual</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>
<p>The Stan Development Team
<em>CmdStan Interface User's Guide</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>


<ul>
<li><p> The package vignettes for an example of fitting a model and accessing
the contents of <code>stanfit</code> objects (<a href="https://mc-stan.org/rstan/articles/">https://mc-stan.org/rstan/articles/</a>).
</p>
</li>
<li> <p><code><a href="#topic+stanc">stanc</a></code> for translating model code in Stan modeling language to C++,
<code><a href="#topic+sampling">sampling</a></code> for sampling, and <code><a href="#topic+stanfit-class">stanfit</a></code> for the
fitted results.
</p>
</li>
<li> <p><code><a href="#topic+as.array.stanfit">as.array.stanfit</a></code> and <code><a href="#topic+extract">extract</a></code> for extracting
samples from <code>stanfit</code> objects.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### example 1
library(rstan)
scode &lt;- "
parameters {
  array[2] real y;
}
model {
  y[1] ~ normal(0, 1);
  y[2] ~ double_exponential(0, 2);
}
"
fit1 &lt;- stan(model_code = scode, iter = 10, verbose = FALSE)
print(fit1)
fit2 &lt;- stan(fit = fit1, iter = 10000, verbose = FALSE)

## using as.array on the stanfit object to get samples
a2 &lt;- as.array(fit2)

## extract samples as a list of arrays
e2 &lt;- extract(fit2, permuted = FALSE)

#### example 2
#### the result of this package is included in the package

excode &lt;- '
  transformed data {
    array[20] real y;
    y[1] = 0.5796;  y[2] = 0.2276;   y[3]  = -0.2959;
    y[4] = -0.3742; y[5] = 0.3885;   y[6]  = -2.1585;
    y[7] = 0.7111;  y[8] = 1.4424;   y[9]  = 2.5430;
    y[10] = 0.3746; y[11] = 0.4773;  y[12] = 0.1803;
    y[13] = 0.5215; y[14] = -1.6044; y[15] = -0.6703;
    y[16] = 0.9459; y[17] = -0.382;  y[18] = 0.7619;
    y[19] = 0.1006; y[20] = -1.7461;
  }
  parameters {
    real mu;
    real&lt;lower=0, upper=10&gt; sigma;
    vector[2] z[3];
    real&lt;lower=0&gt; alpha;
  }
  model {
    y ~ normal(mu, sigma);
    for (i in 1:3)
      z[i] ~ normal(0, 1);
    alpha ~ exponential(2);
  }
'

exfit &lt;- stan(model_code = excode, save_dso = FALSE, iter = 500)
print(exfit)
plot(exfit)

## End(Not run)
## Not run: 
## examples of specify argument `init` for function stan

## define a function to generate initial values that can
## be fed to function stan's argument `init`
# function form 1 without arguments
initf1 &lt;- function() {
  list(mu = 1, sigma = 4, z = array(rnorm(6), dim = c(3,2)), alpha = 1)
}
# function form 2 with an argument named `chain_id`
initf2 &lt;- function(chain_id = 1) {
  # cat("chain_id =", chain_id, "\n")
  list(mu = 1, sigma = 4, z = array(rnorm(6), dim = c(3,2)), alpha = chain_id)
}

# generate a list of lists to specify initial values
n_chains &lt;- 4
init_ll &lt;- lapply(1:n_chains, function(id) initf2(chain_id = id))

exfit0 &lt;- stan(model_code = excode, init = initf1)
stan(fit = exfit0, init = initf2)
stan(fit = exfit0, init = init_ll, chains = n_chains)

## End(Not run)</code></pre>

<hr>
<h2 id='stan_demo'>Demonstrate examples included in Stan</h2><span id='topic+stan_demo'></span>

<h3>Description</h3>

<p>Stan includes a variety of examples and most of the BUGS example models 
that are translated into Stan modeling language. One example is chosen from a list
created from matching user input and gets fitted in the demonstration.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stan_demo(model = character(0), 
            method = c("sampling", "optimizing", "meanfield", "fullrank"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_demo_+3A_model">model</code></td>
<td>
<p>A character string for model name to specify which model
will be used for demonstration.  The default is an empty string, which
prompts the user to select one the available models. If <code>model = 0</code>,
a character vector of all models is returned without any user intervention.
If <code>model = i</code> where <code>i &gt; 0</code>, then the ith available model is
chosen without user intervention, which is useful for testing.</p>
</td></tr>
<tr><td><code id="stan_demo_+3A_method">method</code></td>
<td>
<p>Whether to call <code><a href="#topic+sampling">sampling</a></code> (the default),
<code><a href="#topic+optimizing">optimizing</a></code>, or one of the variants of <code><a href="#topic+vb">vb</a></code>
for the demonstration</p>
</td></tr>
<tr><td><code id="stan_demo_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>method</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S4 object of <code>stanfit</code>, unless <code>model = 0</code>, in which case a 
character vector of paths to available models is returned.
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sampling">sampling</a></code>, <code><a href="#topic+optimizing">optimizing</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: 
     dogsfit &lt;- stan_demo("dogs") # run the dogs model
     fit1 &lt;- stan_demo(1) # run model_names[1]
  
## End(Not run)
</code></pre>

<hr>
<h2 id='stan_model'>Construct a Stan model</h2><span id='topic+stan_model'></span>

<h3>Description</h3>

<p>Construct an instance of S4 class <code>stanmodel</code> from a model
specified in Stan's modeling language. A <code>stanmodel</code> object
can then be used to draw samples from the model. The Stan program
(the model expressed in the Stan modeling language) is first translated to
C++ code and then the C++ code for the model plus other auxiliary
code is compiled into a dynamic shared object (DSO) and then loaded.
The loaded DSO for the model can be executed to draw samples, allowing
inference to be performed for the model and data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stan_model(
    file, model_name = "anon_model",
    model_code = "", stanc_ret = NULL,
    boost_lib = NULL, eigen_lib = NULL,
    save_dso = TRUE, verbose = FALSE,
    auto_write = rstan_options("auto_write"),
    obfuscate_model_name = TRUE,
    allow_undefined = isTRUE(getOption("stanc.allow_undefined", FALSE)),
    allow_optimizations = isTRUE(getOption("stanc.allow_optimizations", FALSE)),
    standalone_functions = isTRUE(getOption("stanc.standalone_functions", FALSE)),
    use_opencl = isTRUE(getOption("stanc.use_opencl", FALSE)),
    warn_pedantic = isTRUE(getOption("stanc.warn_pedantic", FALSE)),
    warn_uninitialized = isTRUE(getOption("stanc.warn_uninitialized", FALSE)),
    includes = NULL,
    isystem = c(if (!missing(file)) dirname(file), getwd()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_model_+3A_file">file</code></td>
<td>
<p>A character string or a connection that <span class="rlang"><b>R</b></span> supports
specifying the Stan model specification in Stan's modeling language.
</p>
</td></tr>
<tr><td><code id="stan_model_+3A_model_name">model_name</code></td>
<td>
<p>A character string naming the model; defaults
to <code>"anon_model"</code>. However, the model name will be derived from
<code>file</code> or <code>model_code</code> (if <code>model_code</code> is the name of a
character string object) if <code>model_name</code> is not specified.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_model_code">model_code</code></td>
<td>
<p>Either a character string containing the model
specification or the name of a character string object in the workspace.
This is an alternative to specifying the model via the <code>file</code>
or <code>stanc_ret</code> arguments.
</p>
</td></tr>
<tr><td><code id="stan_model_+3A_stanc_ret">stanc_ret</code></td>
<td>
<p>A named list returned from a previous call to
the <code><a href="#topic+stanc">stanc</a></code> function. The list can be used to specify the model
instead of using the <code>file</code> or <code>model_code</code> arguments.
</p>
</td></tr>
<tr><td><code id="stan_model_+3A_boost_lib">boost_lib</code></td>
<td>
<p>The path to a version of the Boost C++ library to
use instead of the one in the <span class="pkg">BH</span> package.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_eigen_lib">eigen_lib</code></td>
<td>
<p>The path to a version of the Eigen C++ library to
use instead of the one in the <span class="pkg">RcppEigen</span> package.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_save_dso">save_dso</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>, indicating
whether the  dynamic shared object (DSO) compiled from the C++ code for the
model will be saved or not. If <code>TRUE</code>, we can draw samples from
the same model in another <span class="rlang"><b>R</b></span> session using the saved DSO (i.e.,
without compiling the C++ code again).</p>
</td></tr>
<tr><td><code id="stan_model_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaulting to <code>FALSE</code>, indicating whether
to report additional intermediate output to the console,
which might be helpful for debugging.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_auto_write">auto_write</code></td>
<td>
<p>Logical, defaulting to the value of
<code>rstan_options("auto_write")</code>, indicating whether to write the
object to the hard disk using <code><a href="base.html#topic+saveRDS">saveRDS</a></code>. Although this argument
is <code>FALSE</code> by default, we recommend calling
<code>rstan_options("auto_write" = TRUE)</code> in order to avoid unnecessary
recompilations. If <code>file</code> is supplied and its <code><a href="base.html#topic+dirname">dirname</a></code>
is writable, then the object will be written to that same directory,
substituting a <code>.rds</code> extension for the <code>.stan</code> extension.
Otherwise, the object will be written to the <code><a href="base.html#topic+tempdir">tempdir</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_obfuscate_model_name">obfuscate_model_name</code></td>
<td>
<p>A logical scalar that is <code>TRUE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_allow_undefined">allow_undefined</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_allow_optimizations">allow_optimizations</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_standalone_functions">standalone_functions</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_use_opencl">use_opencl</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_warn_pedantic">warn_pedantic</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_warn_uninitialized">warn_uninitialized</code></td>
<td>
<p>A logical scalar that is <code>FALSE</code> by default and
passed to <code><a href="#topic+stanc">stanc</a></code>.</p>
</td></tr>
<tr><td><code id="stan_model_+3A_includes">includes</code></td>
<td>
<p>If not <code>NULL</code> (the default), then a character vector of
length one (possibly containing one or more <code>"\n"</code>) of the form
<code>'#include "/full/path/to/my_header.hpp"'</code>, which will be inserted
into the C++ code in the model's namespace and can be used to provide definitions
of functions that are declared but not defined in <code>file</code> or
<code>model_code</code> when <code>allow_undefined = TRUE</code></p>
</td></tr>
<tr><td><code id="stan_model_+3A_isystem">isystem</code></td>
<td>
<p>A character vector naming a path to look for
file paths in <code>file</code> that are to be included within the Stan program
named by <code>file</code>. See the Details section below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a previously compiled <code>stanmodel</code> exists on the hard drive, its validity
is checked and then returned without recompiling. The most common form of
invalidity seems to be Stan code that ends with a <code>}</code> rather than a blank
line, which causes the hash checker to think that the current model is different
than the one saved on the hard drive. To avoid reading previously
compiled <code>stanmodel</code>s from the hard drive, supply the <code>stanc_ret</code>
argument rather than the <code>file</code> or <code>model_code</code> arguments.
</p>
<p>There are three ways to specify the model's code for <code>stan_model</code>:
</p>

<ol>
<li><p> parameter <code>model_code</code>: a character string containing the
Stan model specification,
</p>
</li>
<li><p> parameter <code>file</code>: a file name (or a connection) from
which to read the Stan model specification, or
</p>
</li>
<li><p> parameter <code>stanc_ret</code>: a list returned by <code>stanc</code>
to be reused.
</p>
</li></ol>



<h3>Value</h3>

<p>An instance of S4 class <code><a href="#topic+stanmodel-class">stanmodel</a></code> that can be
passed to the <code><a href="#topic+sampling">sampling</a></code>, <code><a href="#topic+optimizing">optimizing</a></code>, and
<code><a href="#topic+vb">vb</a></code> functions.
</p>


<h3>References</h3>

<p>The Stan Development Team
<em>Stan Modeling Language User's Guide and Reference Manual</em>.
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanmodel-class">stanmodel</a></code> for details on the class.
</p>
<p><code><a href="#topic+sampling">sampling</a></code>, <code><a href="#topic+optimizing">optimizing</a></code>, and <code><a href="#topic+vb">vb</a></code>,
which take a <code>stanmodel</code> object as input, for estimating the model
parameters.
</p>
<p>More details on Stan, including the full user's guide and reference
manual, can be found at <a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
stancode &lt;- 'data {real y_mean;} parameters {real y;} model {y ~ normal(y_mean,1);}'
mod &lt;- stan_model(model_code = stancode, verbose = TRUE)
fit &lt;- sampling(mod, data = list(y_mean = 0))
fit2 &lt;- sampling(mod, data = list(y_mean = 5))

## End(Not run)</code></pre>

<hr>
<h2 id='stan_rdump'>
Dump the data for a Stan model to <span class="rlang"><b>R</b></span> dump file
in the limited format that Stan can read.
</h2><span id='topic+stan_rdump'></span>

<h3>Description</h3>

<p>This function takes a vector of names of <span class="rlang"><b>R</b></span> objects and outputs
text representations of the objects to a file or connection.
The file created by <code>stan_rdump</code> is typically used as data 
input of the Stan package (<a href="https://mc-stan.org/">https://mc-stan.org/</a>) or
<code><a href="base.html#topic+source">source</a></code>d into another <span class="rlang"><b>R</b></span> session. The usage of 
this function is very similar to <code>dump</code> in <span class="rlang"><b>R</b></span>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_rdump(list, file = "", append = FALSE, 
          envir = parent.frame(),
          width = options("width")$width, 
          quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stan_rdump_+3A_list">list</code></td>
<td>
<p>A vector of character string: the names of one or more <span class="rlang"><b>R</b></span> objects
to be dumped. See the note below.</p>
</td></tr>
<tr><td><code id="stan_rdump_+3A_file">file</code></td>
<td>
<p>Either a character string naming a file or a
<a href="base.html#topic+connection">connection</a>.  <code>""</code> indicates output to the console.</p>
</td></tr>
<tr><td><code id="stan_rdump_+3A_append">append</code></td>
<td>
<p>Logical: if <code>TRUE</code> and <code>file</code> is a character string,
output will be appended to <code>file</code>; otherwise, it will overwrite
the contents of <code>file</code>.</p>
</td></tr>
<tr><td><code id="stan_rdump_+3A_envir">envir</code></td>
<td>
<p>The environment to search for objects.</p>
</td></tr>
<tr><td><code id="stan_rdump_+3A_width">width</code></td>
<td>
<p>The width for maximum characters on a line.  
The output is broken into lines with <code>width.</code></p>
</td></tr>
<tr><td><code id="stan_rdump_+3A_quiet">quiet</code></td>
<td>
<p>Whether to suppress warning messages that would appear when 
a variable is not found or not supported for dumping (not being numeric
or it would not be converted to numeric) or a variable name is not allowed
in Stan.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>An invisible character vector containing the names of the objects
that were dumped.
</p>


<h3>Note</h3>

<p><code>stan_rdump</code> only dumps numeric data, which first can be 
a scalar, vector, matrix, or (multidimensional) array.  Additional types
supported are <code>logical</code> (<code>TRUE</code> and <code>FALSE</code>), <code>factor</code>,
<code>data.frame</code> and a specially structured <code>list</code>.  
</p>
<p>The conversion for logical variables is to map <code>TRUE</code> to 1
and <code>FALSE</code> to 0.  For <code>factor</code> variable, function 
<code>as.integer</code> is used to do the conversion (If we want to transform a
factor <code>f</code> to approximately its original numeric values, see the help of
function <code>factor</code> and do the transformation before calling
<code>stan_rdump</code>). 
In the case of <code>data.frame</code>, function 
<code>data.matrix</code> is applied to the data frame before
dumping. See the notes in <a href="#topic+stan">stan</a> for the specially
structured <code>list</code>, which will be converted to 
<code>array</code> before dumping. 
</p>
<p><code>stan_rdump</code> will check whether the names of objects
are legal variable names in Stan. If an illegal name is 
found, data will be dumped with a warning. However, passing the 
name checking does not necessarily mean that the name is 
legal. More details regarding rules of variable names in Stan can
be found in Stan's manual. 
</p>
<p>If objects with specified names are not found, a warning will
be issued. 
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+dump">dump</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set variables in global environment
a &lt;- 17.5
b &lt;- c(1,2,3)
# write variables a and b to file ab.data.R in temporary directory
stan_rdump(c('a','b'), file.path(tempdir(), "ab.data.R"))
unlink(file.path(tempdir(), "ab.data.R"))

x &lt;- 1; y &lt;- 1:10; z &lt;- array(1:10, dim = c(2,5)) 
stan_rdump(ls(pattern = '^[xyz]'), file.path(tempdir(), "xyz.Rdump"))
cat(paste(readLines(file.path(tempdir(), "xyz.Rdump")), collapse = '\n'), '\n')
unlink(file.path(tempdir(), "xyz.Rdump"))
</code></pre>

<hr>
<h2 id='stan_version'>Obtain the version of Stan</h2><span id='topic+stan_version'></span>

<h3>Description</h3>

<p>The stan version is in form of <code>major.minor.patch</code>;  the
first version is 1.0.0, indicating major version 1, minor version
0 and patch level 0.  Functionality only changes with minor versions
and backward compatibility will only be affected by major versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stan_version()
</code></pre>


<h3>Value</h3>

<p>A character string giving the version of Stan used in this version of RStan. 
</p>


<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan">stan</a></code> and <code><a href="#topic+stan_model">stan_model</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  stan_version() 
</code></pre>

<hr>
<h2 id='stanc'>
Translate Stan model specification to C++ code
</h2><span id='topic+stanc'></span><span id='topic+stanc_builder'></span>

<h3>Description</h3>

<p>Translate a model specification in Stan code to C++ code, which can
then be compiled and loaded for sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  stanc(
    file, model_code = '', model_name = "anon_model", verbose = FALSE,
    obfuscate_model_name = TRUE,
    allow_undefined = isTRUE(getOption("stanc.allow_undefined", FALSE)),
    allow_optimizations = isTRUE(getOption("stanc.allow_optimizations", FALSE)),
    standalone_functions = isTRUE(getOption("stanc.standalone_functions", FALSE)),
    use_opencl = isTRUE(getOption("stanc.use_opencl", FALSE)),
    warn_pedantic = isTRUE(getOption("stanc.warn_pedantic", FALSE)),
    warn_uninitialized = isTRUE(getOption("stanc.warn_uninitialized", FALSE)),
    isystem = c(if (!missing(file)) dirname(file), getwd()))
  stanc_builder(
    file, isystem = c(dirname(file), getwd()),
    verbose = FALSE, obfuscate_model_name = FALSE,
    allow_undefined = isTRUE(getOption("stanc.allow_undefined", FALSE)),
    allow_optimizations = isTRUE(getOption("stanc.allow_optimizations", FALSE)),
    standalone_functions = isTRUE(getOption("stanc.standalone_functions", FALSE)),
    use_opencl = isTRUE(getOption("stanc.use_opencl", FALSE)),
    warn_pedantic = isTRUE(getOption("stanc.warn_pedantic", FALSE)),
    warn_uninitialized = isTRUE(getOption("stanc.warn_uninitialized", FALSE)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stanc_+3A_file">file</code></td>
<td>
<p>A character string or a connection that <span class="rlang"><b>R</b></span> supports
specifying the Stan model specification in Stan's modeling language.</p>
</td></tr>
<tr><td><code id="stanc_+3A_model_code">model_code</code></td>
<td>
<p>Either a character string containing a Stan model
specification or the name of a character string object in the workspace.
This parameter is used only if parameter <code>file</code> is not specified,
so it defaults to the empty string.</p>
</td></tr>
<tr><td><code id="stanc_+3A_model_name">model_name</code></td>
<td>
<p>A character string naming the model. The
default is <code>"anon_model"</code>. However, the model name will be derived
from <code>file</code> or <code>model_code</code> (if <code>model_code</code> is the name of a
character string object) if <code>model_name</code> is not specified.</p>
</td></tr>
<tr><td><code id="stanc_+3A_verbose">verbose</code></td>
<td>
<p>Logical, defaulting to <code>FALSE</code>. If <code>TRUE</code>
more intermediate information is printed during the translation procedure.</p>
</td></tr>
<tr><td><code id="stanc_+3A_obfuscate_model_name">obfuscate_model_name</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>,
indicating whether to use a randomly-generated character string for the
name of the C++ class. This prevents name clashes when compiling multiple
models in the same R session.</p>
</td></tr>
<tr><td><code id="stanc_+3A_isystem">isystem</code></td>
<td>
<p>A character vector naming a path to look for
file paths in <code>file</code> that are to be included within the Stan program
named by <code>file</code>. See the Details section below.</p>
</td></tr>
<tr><td><code id="stanc_+3A_allow_undefined">allow_undefined</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether to allow Stan functions to be declared but not defined in <code>file</code>
or <code>model_code</code>. If <code>TRUE</code>, then it is the caller's responsibility
to provide a function definition in another header file or linked shared object.</p>
</td></tr>
<tr><td><code id="stanc_+3A_allow_optimizations">allow_optimizations</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether to allow level-1 compiler optimization to the <span class="pkg">Stan</span> code.</p>
</td></tr>
<tr><td><code id="stanc_+3A_standalone_functions">standalone_functions</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether to generate the standalone functions <span class="pkg">C++</span> code.</p>
</td></tr>
<tr><td><code id="stanc_+3A_use_opencl">use_opencl</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether to try to use <code>matrix_cl</code> signatures.</p>
</td></tr>
<tr><td><code id="stanc_+3A_warn_pedantic">warn_pedantic</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether to emit warnings about common mistakes in <span class="pkg">Stan</span> programs.</p>
</td></tr>
<tr><td><code id="stanc_+3A_warn_uninitialized">warn_uninitialized</code></td>
<td>
<p>A logical scalar defaulting to <code>FALSE</code> indicating
whether emit warnings about uninitialized variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>stanc_builder</code> function supports the standard C++ convention of
specifying something like <code>#include "my_includes.txt"</code> on an entire line
within the file named by the <code>file</code> argument. In other words,
<code>stanc_builder</code> would look for <code>"my_includes.txt"</code> in (or under) the
directories named by the <code>isystem</code> argument and &mdash; if found &mdash; insert its
contents verbatim at that position before calling <code>stanc</code> on the resulting
<code>model_code</code>. This mechanism reduces the need to copy common chunks of code
across Stan programs. It is possible to include such files recursively.
</p>
<p>Note that line numbers referred to in parser warnings or errors refer to the
postprocessed Stan program rather than <code>file</code>. In the case of a parser
error, the postprocessed Stan program will be printed after the error message.
Line numbers referred to in messages while Stan is executing also refer to
the postprocessed Stan program which can be obtained by calling
<code><a href="#topic+get_stancode">get_stancode</a></code>.
</p>


<h3>Value</h3>

<p>A list with named entries:
</p>

<ol>
<li> <p><code>model_name</code> Character string for the model name.
</p>
</li>
<li> <p><code>model_code</code> Character string for the model's Stan specification.
</p>
</li>
<li> <p><code>cppcode</code>    Character string for the model's C++ code.
</p>
</li>
<li> <p><code>status</code>     Logical indicating success/failure (always <code>TRUE</code>)
of translating the Stan code.
</p>
</li></ol>



<h3>Note</h3>

<p>Unlike <span class="rlang"><b>R</b></span>, in which variable identifiers may contain dots (e.g. <code>a.1</code>),
Stan prohibits dots from occurring in variable identifiers. Furthermore,
C++ reserved words and Stan reserved words may not be used for variable names;
see the Stan User's Guide for a complete list.
</p>


<h3>References</h3>

<p>The Stan Development Team
<em>Stan Modeling Language User's Guide and Reference Manual</em>.
<a href="https://mc-stan.org/">https://mc-stan.org/</a>.
</p>
<p>The Stan Development Team
<em>CmdStan Interface User's Guide</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_model">stan_model</a></code> and <code><a href="#topic+stan">stan</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stanmodelcode &lt;- "
data {
  int&lt;lower=0&gt; N;
  array[N] real y;
}

parameters {
  real mu;
}

model {
  mu ~ normal(0, 10);
  y ~ normal(mu, 1);
}
"

r &lt;- stanc(model_code = stanmodelcode, model_name = "normal1")
str(r)
</code></pre>

<hr>
<h2 id='stanfit-class'>Class <code>stanfit</code>: fitted Stan model</h2><span id='topic+stanfit-class'></span><span id='topic+stanfit'></span><span id='topic+show+2Cstanfit-method'></span><span id='topic+get_cppo_mode'></span><span id='topic+get_cppo_mode+2Cstanfit-method'></span><span id='topic+get_stancode'></span><span id='topic+get_stancode+2Cstanfit-method'></span><span id='topic+get_stanmodel'></span><span id='topic+get_stanmodel+2Cstanfit-method'></span><span id='topic+get_seed'></span><span id='topic+get_seed+2Cstanfit-method'></span><span id='topic+get_seeds'></span><span id='topic+get_seeds+2Cstanfit-method'></span><span id='topic+get_inits'></span><span id='topic+get_inits+2Cstanfit-method'></span><span id='topic+get_posterior_mean'></span><span id='topic+get_posterior_mean+2Cstanfit-method'></span><span id='topic+get_elapsed_time'></span><span id='topic+get_elapsed_time+2Cstanfit-method'></span><span id='topic+get_logposterior'></span><span id='topic+get_logposterior+2Cstanfit-method'></span><span id='topic+get_adaptation_info'></span><span id='topic+get_adaptation_info+2Cstanfit-method'></span><span id='topic+get_sampler_params'></span><span id='topic+get_sampler_params+2Cstanfit+2Clogical-method'></span>

<h3>Description</h3>

<p>The components (slots) of a <code>stanfit</code> object and the various available
methods are described below. When methods have their own more detailed 
documentation pages links are provided. 
</p>


<h3>Objects from the Class</h3>

<p>An object of class <code>stanfit</code> contains the
output derived from fitting a Stan model as returned by the top-level function
<code><a href="#topic+stan">stan</a></code> or the lower-level methods <code><a href="#topic+sampling">sampling</a></code> and
<code><a href="#topic+vb">vb</a></code> (which are defined on class <code><a href="#topic+stanmodel-class">stanmodel</a></code>).
Many methods (e.g., <code>print</code>, <code>plot</code>, <code>summary</code>) are provided for 
summarizing results and various access methods also allow the underlying data 
(e.g., simulations, diagnostics) contained in the object to be retrieved.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model_name</code>:</dt><dd><p>The model name as a string.</p>
</dd> 
<dt><code>model_pars</code>:</dt><dd><p>A character vector of names of parameters
(including transformed parameters and derived quantities).</p>
</dd>
<dt><code>par_dims</code>:</dt><dd><p>A named list giving the dimensions for all 
parameters. The dimension for a scalar parameter is given as 
<code>numeric(0)</code>.</p>
</dd>
<dt><code>mode</code>:</dt><dd><p>An integer indicating the mode of the fitted model.
<code>0</code> indicates sampling mode, <code>1</code> indicates test gradient mode 
(no sampling is done), and <code>2</code> indicates error mode (an error occurred
before sampling). Most methods for <code>stanfit</code> objects are useful only 
if <code>mode=0</code>.</p>
</dd>
<dt><code>sim</code>:</dt><dd><p>A list containing simulation results including the 
posterior draws as well as various pieces of metadata used by many of the 
methods for <code>stanfit</code> objects.</p>
</dd> 
<dt><code>inits</code>:</dt><dd><p>The initial values (either user-specified or generated
randomly) for all chains. This is a list with one component per chain. Each
component is a named list containing the initial values for each parameter
for the corresponding chain.</p>
</dd>
<dt><code>stan_args</code>:</dt><dd><p>A list with one component per chain containing the 
arguments used for sampling (e.g. <code>iter</code>, <code>seed</code>, etc.).</p>
</dd>
<dt><code>stanmodel</code>:</dt><dd><p>The instance of S4 class <code><a href="#topic+stanmodel-class">stanmodel</a></code>.</p>
</dd> 
<dt><code>date</code>:</dt><dd><p>A string containing the date and time the object was created.</p>
</dd>
<dt><code>.MISC</code>:</dt><dd><p>Miscellaneous helper information used for the fitted model. 
This is an object of type <code>environment</code>. Users rarely (if ever)
need to access the contents of <code>.MISC</code>.</p>
</dd>
</dl>



<h3>Methods</h3>

<p><strong>Printing, plotting, and summarizing:</strong>
</p>

<dl>
<dt><code>show</code></dt><dd><p>Print the default summary for the model.</p>
</dd>
<dt><code>print</code></dt><dd><p>Print a customizable summary for the model. 
See <code><a href="#topic+print.stanfit">print.stanfit</a></code>.</p>
</dd>
<dt><code>plot</code></dt><dd><p>Create various plots summarizing the fitted model. 
See <code><a href="#topic+plot+2Cstanfit-method">plot,stanfit-method</a></code>.</p>
</dd>
<dt><code>summary</code></dt><dd><p>Summarize the distributions of estimated 
parameters and derived quantities using the posterior draws. 
See <code><a href="#topic+summary+2Cstanfit-method">summary,stanfit-method</a></code>.</p>
</dd>
<dt><code>get_posterior_mean</code></dt><dd>
<p>Get the posterior mean for parameters of interest (using <code>pars</code>
to specify a subset of parameters). Returned is a matrix with 
one column per chain and an additional column for all chains combined.</p>
</dd>
</dl>

<p><strong>Extracting posterior draws:</strong>
</p>

<dl>
<dt><code>extract</code></dt><dd><p>Extract the draws for all chains for all 
(or specified) parameters. See <code><a href="#topic+extract">extract</a></code>.</p>
</dd>
<dt><code>as.array</code>, <code>as.matrix</code>, <code>as.data.frame</code></dt><dd>
<p>Coerce the draws (without warmup) to an array, 
matrix or data frame. See <code><a href="#topic+as.array.stanfit">as.array.stanfit</a></code>.</p>
</dd>
<dt><code>As.mcmc.list</code></dt><dd><p>Convert a <code>stanfit</code> object to an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> as in package <span class="pkg">coda</span>. 
See <code><a href="#topic+As.mcmc.list">As.mcmc.list</a></code>.</p>
</dd>
<dt><code>get_logposterior</code></dt><dd>
<p>Get the log-posterior at each iteration.
Each element of the returned <code>list</code> is the vector of log-posterior
values (up to an additive constant, i.e. up to a multiplicative constant 
on the linear scale) for a single chain.
The optional argument <code>inc_warmup</code> (defaulting to <code>TRUE</code>) 
indicates whether to include the warmup period.</p>
</dd>
</dl>

<p><strong>Diagnostics, log probability, and gradients:</strong>
</p>

<dl>
<dt><code>get_sampler_params</code></dt><dd>
<p>Obtain the parameters used for the sampler such as 
<code>stepsize</code> and <code>treedepth</code>. The results are returned
as a list with one component (an array) per chain.
The array has number of columns corresponding to the number
of parameters used in the sampler and its column names 
provide the parameter names. Optional argument <code>inc_warmup</code> 
(defaulting to <code>TRUE</code>) indicates whether to include the warmup period.</p>
</dd>
<dt><code>get_adaptation_info</code></dt><dd>
<p>Obtain the adaptation information for the sampler if NUTS was used. 
The results are returned as a list, each element of which is a character 
string with the info for a single chain.</p>
</dd> 
<dt><code>log_prob</code></dt><dd>
<p>Compute the log probability density (<code>lp__</code>) for a set of parameter 
values (on the <em>unconstrained</em> space) up to an additive constant. 
The unconstrained parameters are specified using a numeric vector.
The number of parameters on the unconstrained space can be obtained 
using method <code>get_num_upars</code>. A numeric value is returned. See also
the documentation in <code><a href="#topic+log_prob">log_prob</a></code>.</p>
</dd> 
<dt><code>grad_log_prob</code></dt><dd>
<p>Compute the gradient of log probability density function for a set of parameter 
values (on the <em>unconstrained</em> space) up to an additive constant.
The unconstrained parameters are specified using a numeric vector
with the length being the number of unconstrained parameters.
A numeric vector is returned with the length of the number of 
unconstrained parameters and an attribute named <code>log_prob</code> being
the <code>lp__</code>. See also the documentation in <code><a href="#topic+grad_log_prob">grad_log_prob</a></code>.</p>
</dd>
<dt><code>get_num_upars</code></dt><dd>
<p>Get the number of unconstrained parameters of the model. The number of parameters 
for a model is not necessarily equal to this number of unconstrained 
parameters. For example, when a parameter is specified as a simplex of 
length K, the number of unconstrained parameters is K-1.</p>
</dd> 
<dt><code>unconstrain_pars</code></dt><dd>
<p>Transform the parameters to unconstrained space. The input is a named list 
as for specifying initial values for each parameter. A numeric vector is
returned. See also the documentation in <code><a href="#topic+unconstrain_pars">unconstrain_pars</a></code>.</p>
</dd>
<dt><code>constrain_pars</code></dt><dd>
<p>Get the parameter values from their unconstrained space. The input is a 
numeric vector. A list is returned.  This function is contrary to
<code>unconstrain_pars</code>. See also the documentation in 
<code><a href="#topic+constrain_pars">constrain_pars</a></code>.</p>
</dd>
</dl>

<p><strong>Metadata and miscellaneous:</strong>
</p>

<dl>
<dt><code>get_stancode</code></dt><dd>
<p>Get the Stan code for the fitted model as a string. The result can 
be printed in a readable format using <code><a href="base.html#topic+cat">cat</a></code>.</p>
</dd>
<dt><code>get_stanmodel</code></dt><dd>
<p>Get the object of S4 class <code><a href="#topic+stanmodel-class">stanmodel</a></code> of the fitted 
model.</p>
</dd>
<dt><code>get_elapsed_time</code></dt><dd>
<p>Get the warmup time and sample time in seconds.
A matrix of two columns is returned with each row containing the warmup
and sample times for one chain.</p>
</dd>
<dt><code>get_inits, iter = NULL</code></dt><dd>
<p>Get the initial values for parameters used in sampling all chains. The 
returned object is a list with the same structure as the <code>inits</code> 
slot described above. If <code>object@mode=2</code> (error mode) an empty list 
is returned. If <code>iter</code> is not <code>NULL</code>, then the draw from that
iteration is returned for each chain rather than the initial state.</p>
</dd>
<dt><code>get_cppo_mode</code></dt><dd>
<p>Get the optimization mode used for compilation. The returned string is 
one of <code>"fast"</code>, <code>"presentation2"</code>, <code>"presentation1"</code>,
and <code>"debug"</code>.</p>
</dd>
<dt><code>get_seed</code></dt><dd>
<p>Get the (P)RNG seed used. When the fitted object 
is empty (<code>mode=2</code>), <code>NULL</code> might be returned.
In the case that the seeds for all chains are different, use 
<code>get_seeds</code>.</p>
</dd> 
<dt><code>get_seeds</code></dt><dd>
<p>Get the seeds used for all chains. When the fitted object 
is empty (<code>mode=2</code>), <code>NULL</code> might be returned.</p>
</dd> 
</dl>



<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan">stan</a></code> and <code><a href="#topic+stanmodel-class">stanmodel</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
showClass("stanfit")
ecode &lt;- '
  parameters {
    array[2] real&lt;lower=0&gt; y;
  } 
  model {
    y ~ exponential(1);
  }
'
fit &lt;- stan(model_code = ecode, iter = 10, chains = 1)
fit2 &lt;- stan(fit = fit)
print(fit2)
plot(fit2)
traceplot(fit2)
ainfo &lt;- get_adaptation_info(fit2)
cat(ainfo[[1]])
seed &lt;- get_seed(fit2)
sp &lt;- get_sampler_params(fit2)
sp2 &lt;- get_sampler_params(fit2, inc_warmup = FALSE)
head(sp[[1]])

lp &lt;- log_prob(fit, c(1, 2))
grad &lt;- grad_log_prob(fit, c(1, 2))
lp2 &lt;- attr(grad, "log_prob") # should be the same as "lp"

# get the number of parameters on the unconstrained space
n &lt;- get_num_upars(fit)

# parameters on the positive real line (constrained space) 
y1 &lt;- list(y = rep(1, 2)) 

uy &lt;- unconstrain_pars(fit, y1) 
## uy should be c(0, 0) since here the log transformation is used
y1star &lt;- constrain_pars(fit, uy)

print(y1)
print(y1star) # y1start should equal to y1 

## End(Not run)

# Create a stanfit object from reading CSV files of samples (saved in rstan
# package) generated by funtion stan for demonstration purpose from model as follows. 
# 
excode &lt;- '
  transformed data {
    array[20] real y;
    y[1] &lt;- 0.5796;  y[2]  &lt;- 0.2276;   y[3] &lt;- -0.2959; 
    y[4] &lt;- -0.3742; y[5]  &lt;- 0.3885;   y[6] &lt;- -2.1585;
    y[7] &lt;- 0.7111;  y[8]  &lt;- 1.4424;   y[9] &lt;- 2.5430; 
    y[10] &lt;- 0.3746; y[11] &lt;- 0.4773;   y[12] &lt;- 0.1803; 
    y[13] &lt;- 0.5215; y[14] &lt;- -1.6044;  y[15] &lt;- -0.6703; 
    y[16] &lt;- 0.9459; y[17] &lt;- -0.382;   y[18] &lt;- 0.7619;
    y[19] &lt;- 0.1006; y[20] &lt;- -1.7461;
  }
  parameters {
    real mu;
    real&lt;lower=0, upper=10&gt; sigma;
    vector[2] z[3];
    real&lt;lower=0&gt; alpha;
  } 
  model {
    y ~ normal(mu, sigma);
    for (i in 1:3) 
      z[i] ~ normal(0, 1);
    alpha ~ exponential(2);
  } 
'

# exfit &lt;- stan(model_code = excode, save_dso = FALSE, iter = 200, 
#               sample_file = "rstan_doc_ex.csv")
# 

exfit &lt;- read_stan_csv(dir(system.file('misc', package = 'rstan'),
                       pattern='rstan_doc_ex_[[:digit:]].csv',
                       full.names = TRUE))

print(exfit)
## Not run: 
plot(exfit)

## End(Not run)

adaptinfo &lt;- get_adaptation_info(exfit)
inits &lt;- get_inits(exfit) # empty
inits &lt;- get_inits(exfit, iter = 101)
seed &lt;- get_seed(exfit)
sp &lt;- get_sampler_params(exfit)
ml &lt;- As.mcmc.list(exfit)
cat(get_stancode(exfit))
</code></pre>

<hr>
<h2 id='stanmodel-class'>Class representing model compiled from C++</h2><span id='topic+stanmodel-class'></span><span id='topic+get_cppcode'></span><span id='topic+get_cxxflags'></span><span id='topic+get_cppcode+2Cstanmodel-method'></span><span id='topic+get_cxxflags+2Cstanmodel-method'></span><span id='topic+get_stancode+2Cstanmodel-method'></span><span id='topic+show+2Cstanmodel-method'></span>

<h3>Description</h3>

<p>A <code>stanmodel</code> object represents the model compiled from C++ code. 
The <code>sampling</code> method defined in this class may be used to 
draw samples from the model and <code>optimizing</code> method is for
obtaining a point estimate by maximizing the log-posterior.
</p>


<h3>Objects from the Class</h3>

<p>Instances of <code>stanmodel</code> are usually created by calling 
function <code>stan_model</code> or function <code>stan</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>model_name</code>:</dt><dd><p>The model name, an object of type <code>character</code>.</p>
</dd> 
<dt><code>model_code</code>:</dt><dd><p>The Stan model specification, an object of type <code>character</code>.</p>
</dd> 
<dt><code>model_cpp</code>:</dt><dd><p>Object of type <code>list</code>
that includes the C++ code for the model.</p>
</dd> 
<dt><code>mk_cppmodule</code>:</dt><dd><p>A function to return a RCpp module. This function will be
called in function <code>sampling</code> and <code>optimzing</code> with one
argument (the instance of <code>stanmodel</code> itself).</p>
</dd> 
<dt><code>dso</code>:</dt><dd><p>Object of S4 class <code>cxxdso</code>. The container for the dynamic 
shared objects compiled from the C++ code of the model, returned from function
<code>cxxfunction</code> in package <span class="pkg">inline</span>.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt><code>show</code></dt><dd><p><code>signature(object = "stanmodel")</code>: print the Stan model specification.</p>
</dd>
<dt><code>vb</code></dt><dd><p><code>signature(object = "stanmodel")</code>: use the variational Bayes algorithms.</p>
</dd>
<dt><code>sampling</code></dt><dd><p><code>signature(object = "stanmodel")</code>: draw samples for
the model (see <code><a href="#topic+sampling">sampling</a></code>).</p>
</dd>
<dt><code>optimizing</code></dt><dd><p><code>signature(object = "stanmodel")</code>: obtain a point 
estimate by maximizing the posterior (see <code><a href="#topic+optimizing">optimizing</a></code>).</p>
</dd>
<dt><code>get_cppcode</code></dt><dd><p><code>signature(object = "stanmodel")</code>: returns the C++ code for the model
as a character string. This is part of the C++ code that is compiled to the dynamic 
shared object for the model.</p>
</dd>
<dt><code>get_stancode</code></dt><dd><p><code>signature(object = "stanmodel")</code>: returns the Stan code for
the model as a character string</p>
</dd>  
<dt><code>get_cxxflags</code></dt><dd><p><code>signature(object = "stanmodel")</code>: return the <code>CXXFLAGS</code> 
used for compiling the model. The returned string is like <code>CXXFLAGS = -O3</code>.</p>
</dd>
</dl>



<h3>Note</h3>

<p>Objects of class <code>stanmodel</code> can be saved for use across 
<span class="rlang"><b>R</b></span> sessions only if <code>save_dso = TRUE</code> is set during calling
functions that create <code>stanmodel</code> objects (e.g., <code>stan</code> 
and <code>stan_model</code>). 
</p>
<p>Even if <code>save_dso = TRUE</code>, the model cannot be loaded on
a platform (operating system, 32 bits or 64 bits, etc.) that differs from
the one on which it was compiled.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stan_model">stan_model</a></code>, <code><a href="#topic+stanc">stanc</a></code>
<code><a href="#topic+sampling">sampling</a></code>, <code><a href="#topic+optimizing">optimizing</a></code>, <code><a href="#topic+vb">vb</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("stanmodel")
</code></pre>

<hr>
<h2 id='summary-methods'>Summary method for stanfit objects</h2><span id='topic+summary+2Cstanfit-method'></span>

<h3>Description</h3>

<p>Summarize the distributions of estimated parameters and derived quantities 
using the posterior draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S4 method for signature 'stanfit'
summary(object, pars, probs = c(0.025, 0.25, 0.50, 0.75, 0.975),
  use_cache = TRUE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary-methods_+3A_object">object</code></td>
<td>
<p>An instance of class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names. Defaults to all parameters
as well as the log-posterior (<code>lp__</code>).</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_probs">probs</code></td>
<td>
<p>A numeric vector of <code><a href="stats.html#topic+quantile">quantile</a></code>s of interest. 
The default is <code>c(0.025,0.25,0.5,0.75,0.975)</code>.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_use_cache">use_cache</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>. When <code>use_cache=TRUE</code>
the summary quantities for all parameters are computed and cached for future
use. Setting <code>use_cache=FALSE</code> can be used to avoid performing the 
summary computations for all parameters if <code>pars</code> is given as some 
specific parameters.</p>
</td></tr>
<tr><td><code id="summary-methods_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>summary</code> method returns a named list with elements <code>summary</code> 
and <code>c_summary</code>, which contain summaries for for all chains merged and 
individual chains, respectively.
Included in the summaries are quantiles, means, standard deviations (sd),
effective sample sizes (n_eff), and split Rhats (the potential scale
reduction derived from all chains after splitting each chain in half and
treating the halves as chains). For the summary of all chains merged, 
Monte Carlo standard errors (se_mean) are also reported.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+monitor">monitor</a></code>, which computes similar summaries but accepts an 
array of MCMC draws as its input rather than a <code>stanfit</code> object.
</p>
</li>
<li><p> The RStan vignettes for more example usage.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
ecode &lt;- '
  parameters {
    array[2] real&lt;lower=0&gt; y;
  } 
  model {
    y ~ exponential(1);
  }
'
fit &lt;- stan(model_code = ecode)
s &lt;- summary(fit, probs = c(0.1, 0.9))
s$summary  # all chaines merged
s$c_summary  # individual chains

## End(Not run)
</code></pre>

<hr>
<h2 id='traceplot'>Markov chain traceplots</h2><span id='topic+traceplot'></span><span id='topic+traceplot+2Cstanfit-method'></span>

<h3>Description</h3>

<p>Draw the traceplot corresponding to one or more
Markov chains, providing a visual way to inspect sampling behavior
and assess mixing across chains and convergence.</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S4 method for signature 'stanfit'
traceplot(object, pars, include = TRUE, unconstrain = FALSE, 
          inc_warmup = FALSE, window = NULL, nrow = NULL, ncol = NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_object">object</code></td>
<td>
<p>An instance of class <code><a href="#topic+stanfit-class">stanfit</a></code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_pars">pars</code></td>
<td>
<p>A character vector of parameter names. Defaults to all parameters 
or the first 10 parameters (if there are more than 10).</p>
</td></tr>
<tr><td><code id="traceplot_+3A_include">include</code></td>
<td>
<p>Should the parameters given by the <code>pars</code> argument be
included (the default) or excluded from the plot? Only relevant if 
<code>pars</code> is not missing.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether 
the warmup sample are included in the trace plot; defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_window">window</code></td>
<td>
<p>A vector of length 2. Iterations between <code>window[1]</code>
and <code>window[2]</code> will be shown in the plot. The default is to 
show all iterations if <code>inc_warmup</code> is <code>TRUE</code> and all iterations
from the sampling period only if <code>inc_warmup</code> is <code>FALSE</code>. If 
<code>inc_warmup</code> is <code>FALSE</code> the iterations specified in <code>window</code>
should not include iterations from the warmup period.</p>
</td></tr>
<tr><td><code id="traceplot_+3A_unconstrain">unconstrain</code></td>
<td>
<p>Should parameters be plotted on the unconstrained space?
Defaults to <code>FALSE</code>.</p>
</td></tr>  
<tr><td><code id="traceplot_+3A_nrow">nrow</code>, <code id="traceplot_+3A_ncol">ncol</code></td>
<td>
<p>Passed to <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>.</p>
</td></tr> 
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>
<p>Optional arguments to pass to <code><a href="ggplot2.html#topic+geom_path">geom_path</a></code> 
(e.g. <code>size</code>, <code>linetype</code>, <code>alpha</code>, etc.).</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object that can be further customized
using the <span class="pkg">ggplot2</span> package.</p>


<h3>Methods</h3>


<dl>
<dt>traceplot</dt><dd><p><code>signature(object = "stanfit")</code> Plot the sampling paths for all chains.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+rstan-plotting-functions">List of RStan plotting functions</a></code>,
<code><a href="#topic+rstan_gg_options">Plot options</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create a stanfit object from reading CSV files of samples (saved in rstan
# package) generated by funtion stan for demonstration purpose from model as follows. 
# 
excode &lt;- '
  transformed data {
    array[20] real y;
    y[1] &lt;- 0.5796;  y[2]  &lt;- 0.2276;   y[3] &lt;- -0.2959; 
    y[4] &lt;- -0.3742; y[5]  &lt;- 0.3885;   y[6] &lt;- -2.1585;
    y[7] &lt;- 0.7111;  y[8]  &lt;- 1.4424;   y[9] &lt;- 2.5430; 
    y[10] &lt;- 0.3746; y[11] &lt;- 0.4773;   y[12] &lt;- 0.1803; 
    y[13] &lt;- 0.5215; y[14] &lt;- -1.6044;  y[15] &lt;- -0.6703; 
    y[16] &lt;- 0.9459; y[17] &lt;- -0.382;   y[18] &lt;- 0.7619;
    y[19] &lt;- 0.1006; y[20] &lt;- -1.7461;
  }
  parameters {
    real mu;
    real&lt;lower=0, upper=10&gt; sigma;
    vector[2] z[3];
    real&lt;lower=0&gt; alpha;
  } 
  model {
    y ~ normal(mu, sigma);
    for (i in 1:3) 
      z[i] ~ normal(0, 1);
    alpha ~ exponential(2);
  } 
'
# exfit &lt;- stan(model_code = excode, save_dso = FALSE, iter = 200, 
#               sample_file = "rstan_doc_ex.csv")
# 
exfit &lt;- read_stan_csv(dir(system.file('misc', package = 'rstan'),
                       pattern='rstan_doc_ex_[[:digit:]].csv',
                       full.names = TRUE))

print(exfit)
traceplot(exfit)
traceplot(exfit, size = 0.25)
traceplot(exfit, pars = "sigma", inc_warmup = TRUE)

trace &lt;- traceplot(exfit, pars = c("z[1,1]", "z[3,1]"))
trace + scale_color_discrete() + theme(legend.position = "top")

## End(Not run)
</code></pre>

<hr>
<h2 id='vb'>Run Stan's variational algorithm for approximate posterior sampling</h2><span id='topic+vb'></span><span id='topic+vb+2Cstanmodel-method'></span>

<h3>Description</h3>

<p>Approximately draw from a posterior distribution using variational inference.
</p>
<p>This is still considered an experimental feature.
We recommend calling <code><a href="#topic+stan">stan</a></code> or <code><a href="#topic+sampling">sampling</a></code> for 
final inferences and only using <code>vb</code> to get a rough idea of the parameter
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  
  ## S4 method for signature 'stanmodel'
vb(object, data = list(), pars = NA, include = TRUE,
    seed = sample.int(.Machine$integer.max, 1), 
    init = 'random', check_data = TRUE, 
    sample_file = tempfile(fileext = '.csv'),
    algorithm = c("meanfield", "fullrank"), 
    importance_resampling = FALSE, keep_every = 1,
    ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vb_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+stanmodel-class">stanmodel</a></code>.</p>
</td></tr>
<tr><td><code id="vb_+3A_data">data</code></td>
<td>
<p>A named <code>list</code> or <code>environment</code>
providing the data for the model or a character vector 
for all the names of objects used as data. 
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="vb_+3A_pars">pars</code></td>
<td>
<p>If not <code>NA</code>, then a character vector naming parameters,
which are included in the output if <code>include = TRUE</code> and excluded
if <code>include = FALSE</code>. By default, all parameters are included.</p>
</td></tr>
<tr><td><code id="vb_+3A_include">include</code></td>
<td>
<p>Logical scalar defaulting to <code>TRUE</code> indicating
whether to include or exclude the parameters given by the 
<code>pars</code> argument. If <code>FALSE</code>, only entire multidimensional
parameters can be excluded, rather than particular elements of them.</p>
</td></tr>
<tr><td><code id="vb_+3A_seed">seed</code></td>
<td>
<p>The seed for random number generation. The default is generated 
from 1 to the maximum integer supported by <span class="rlang"><b>R</b></span> on the machine. Even if 
multiple chains are used, only one seed is needed, with other chains having 
seeds derived from that of the first chain to avoid dependent samples.
When a seed is specified by a number, <code>as.integer</code> will be applied to it. 
If <code>as.integer</code> produces <code>NA</code>, the seed is generated randomly. 
The seed can also be specified as a character string of digits, such as
<code>"12345"</code>, which is converted to integer.</p>
</td></tr>
<tr><td><code id="vb_+3A_init">init</code></td>
<td>
<p>Initial values specification. See the detailed documentation for 
the init argument in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="vb_+3A_check_data">check_data</code></td>
<td>
<p>Logical, defaulting to <code>TRUE</code>. If <code>TRUE</code> 
the data will be preprocessed; otherwise not.
See the <strong>Passing data to Stan</strong> section in <code><a href="#topic+stan">stan</a></code>.</p>
</td></tr>
<tr><td><code id="vb_+3A_sample_file">sample_file</code></td>
<td>
<p>A character string of file name for specifying where to 
write samples for <em>all</em> parameters and other saved quantities. 
This defaults to a temporary file.</p>
</td></tr>
<tr><td><code id="vb_+3A_algorithm">algorithm</code></td>
<td>
<p>Either <code>"meanfield"</code> (the default) or <code>"fullrank"</code>, 
indicating which variational inference algorithm is used. The <code>"meanfield"</code> 
option uses a fully factorized Gaussian for the approximation whereas the 
<code>fullrank</code> option uses a Gaussian with a full-rank covariance matrix 
for the approximation. Details and additional references are available in 
the Stan manual.</p>
</td></tr>
<tr><td><code id="vb_+3A_importance_resampling">importance_resampling</code></td>
<td>
<p>Logical scalar (defaulting to <code>FALSE</code>) indicating
whether to do importance resampling to adjust the draws at the optimum
to be more like draws from the posterior distribution</p>
</td></tr>
<tr><td><code id="vb_+3A_keep_every">keep_every</code></td>
<td>
<p>Integer scalar (defaulting to 1) indicating the interval
by which to thin the draws when <code>imporance_resampling = TRUE</code></p>
</td></tr>
<tr><td><code id="vb_+3A_...">...</code></td>
<td>
<p>Other optional parameters:
</p>

<ul>
<li> <p><code>iter</code> (positive <code>integer</code>), the maximum number 
of iterations, defaulting to 10000.
</p>
</li>
<li> <p><code>grad_samples</code> (positive <code>integer</code>), the number of samples
for Monte Carlo estimate of gradients, defaulting to 1.
</p>
</li>
<li> <p><code>elbo_samples</code> (positive <code>integer</code>), the number of samples
for Monte Carlo estimate of ELBO (objective function), defaulting to 100.
(ELBO stands for &quot;the evidence lower bound&quot;.)
</p>
</li>
<li> <p><code>eta</code> (<code>double</code>), positive stepsize weighting parameter
for variational inference but is ignored if adaptation is engaged, which
is the case by default.
</p>
</li>
<li> <p><code>adapt_engaged</code> (<code>logical</code>), a flag indicating whether to
automatically adapt the stepsize, defaulting to <code>TRUE</code>.
</p>
</li>
<li> <p><code>tol_rel_obj</code> (positive <code>double</code>), the convergence tolerance 
on the relative norm of the objective, defaulting to 0.01. 
</p>
</li>
<li> <p><code>eval_elbo</code> (positive <code>integer</code>), evaluate ELBO every Nth 
iteration, defaulting to 100.
</p>
</li>
<li> <p><code>output_samples</code> (positive <code>integer</code>), number of posterior
samples to draw and save, defaults to 1000.
</p>
</li>
<li> <p><code>adapt_iter</code> (positive <code>integer</code>), the maximum number of 
iterations to adapt the stepsize, defaulting to 50. Ignored if 
<code>adapt_engaged = FALSE</code>.
</p>
</li></ul>

<p>Refer to the manuals for both CmdStan and Stan for more details. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <code><a href="#topic+stanfit-class">stanfit-class</a></code>.
</p>


<h3>Methods</h3>


<dl>
<dt>vb</dt><dd><p><code>signature(object = "stanmodel")</code>
Call Stan's variational Bayes methods
for the model defined by S4 class <code>stanmodel</code> 
given the data, initial values, etc. 
</p>
</dd>
</dl>



<h3>References</h3>

<p>The Stan Development Team 
<em>Stan Modeling Language User's Guide and Reference Manual</em>. 
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>
<p>The Stan Development Team
<em>CmdStan Interface User's Guide</em>.
<a href="https://mc-stan.org">https://mc-stan.org</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stanmodel-class">stanmodel</a></code>
</p>
<p>The manuals of CmdStan and Stan. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
m &lt;- stan_model(model_code = 'parameters {real y;} model {y ~ normal(0,1);}')
f &lt;- vb(m)

## End(Not run)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
