<!DOCTYPE html><html><head><title>Help for package TIGERr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TIGERr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compute_RSD'><p>Compute RSD (relative standard deviation)</p></a></li>
<li><a href='#compute_targetVal'><p>Compute target values for ensemble learning architecture</p></a></li>
<li><a href='#FF4_qc'><p>Accompanying QC samples of KORA FF4 (demo data)</p></a></li>
<li><a href='#run_TIGER'><p>Run TIGER to eliminate technical variation</p></a></li>
<li><a href='#select_variable'><p>Select variables for ensemble learning architecture</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Technical Variation Elimination with Ensemble Learning
Architecture</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Siyu Han [aut, cre], Jialing Huang [aut], Francesco Foppiano [aut], Cornelia Prehn [aut], Jerzy Adamski [aut], Karsten Suhre [aut], Ying Li [aut], Giuseppe Matullo [aut], Freimut Schliess [aut], Christian Gieger [aut], Annette Peters [aut], Rui Wang-Sattler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Siyu Han &lt;siyu.han@helmholtz-muenchen.de&gt;</td>
</tr>
<tr>
<td>Acknowledgments:</td>
<td>TAI Yun-hsiu, WANG Ruoyu, CHENG Ming, GUO Yuan, LI
Han, FAN Linrui</td>
</tr>
<tr>
<td>Description:</td>
<td>
    The R implementation of TIGER. 
    TIGER integrates random forest algorithm into an innovative ensemble learning architecture. Benefiting from this advanced architecture, TIGER is resilient to outliers, free from model tuning and less likely to be affected by specific hyperparameters.
    TIGER supports targeted and untargeted metabolomics data and is competent to perform both intra- and inter-batch technical variation removal. TIGER can also be used for cross-kit adjustment to ensure data obtained from different analytical assays can be effectively combined and compared.
    Reference: Han S. et al. (2022) &lt;<a href="https://doi.org/10.1093%2Fbib%2Fbbab535">doi:10.1093/bib/bbab535</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel (&ge; 2.1.0), pbapply (&ge; 1.4-3), ppcor (&ge; 1.1),
randomForest (&ge; 4.6-14), stats (&ge; 3.0.0)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/HAN-Siyu/TIGER/issues">https://github.com/HAN-Siyu/TIGER/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-06 13:37:53 UTC; siyu.han</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-06 14:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compute_RSD'>Compute RSD (relative standard deviation)</h2><span id='topic+compute_RSD'></span>

<h3>Description</h3>

<p>This function computes the RSD (relative standard deviation) of the values in <code>input_data</code>. Missing values are removed before the computation automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_RSD(input_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_RSD_+3A_input_data">input_data</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The RSD in this function is computed by:
</p>
<p><code>sd(input_data, na.rm = TRUE) / mean(input_data, na.rm = TRUE)</code>.
</p>


<h3>Value</h3>

<p>The RSD of the values in <code>input_data</code> is computed, as a numeric of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>RSD_1 &lt;- compute_RSD(c(1:10))

data(FF4_qc) # load demo dataset

# RSD of QC:
RSD_2 &lt;- sapply(FF4_qc[FF4_qc$sampleType == "QC", -c(1:5)], compute_RSD)
quantile(RSD_2)

# RSD of different types of QC samples:
# (each metabolote has its own RSD)
RSD_3 &lt;- aggregate(FF4_qc[-c(1:5)], by = list(Type = FF4_qc$sampleType),
                   FUN = compute_RSD)
</code></pre>

<hr>
<h2 id='compute_targetVal'>Compute target values for ensemble learning architecture</h2><span id='topic+compute_targetVal'></span>

<h3>Description</h3>

<p>This function provides an advanced option to calculate the target values of one reference dataset (i.e. <code>QC_num</code>, numeric values of quality control samples). The generated target values (a list) can be further passed to argument <code>targetVal_external</code> in function <code><a href="#topic+run_TIGER">run_TIGER</a></code> such that TIGER can align the <code>test_samples</code> with the reference dataset. This is useful for longitudinal datasets correction and cross-kit adjustment. See case study section of our original paper for detailed explanation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_targetVal(
  QC_num,
  sampleType,
  batchID = NULL,
  targetVal_method = c("mean", "median"),
  targetVal_batchWise = FALSE,
  targetVal_removeOutlier = !targetVal_batchWise,
  coerce_numeric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_targetVal_+3A_qc_num">QC_num</code></td>
<td>
<p>a numeric data.frame including the metabolite values of quality control (QC) samples. Missing values and infinite values will not be taken into account. Row: sample. Column: metabolite variable. See Examples.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_sampletype">sampleType</code></td>
<td>
<p>a vector corresponding to <code>QC_num</code> to specify the type of each QC sample. QC samples of the <strong>same type</strong> should have the <strong>same type name</strong>. See Examples.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_batchid">batchID</code></td>
<td>
<p>a vector corresponding to <code>QC_num</code> to specify the batch of each sample. Ignored if <code>targetVal_batchWise = FALSE</code>. See Examples.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_targetval_method">targetVal_method</code></td>
<td>
<p>a character string specifying how the target values are computed. Can be <code>"mean"</code> (default) or <code>"median"</code>. See Details.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_targetval_batchwise">targetVal_batchWise</code></td>
<td>
<p>logical. If <code>TRUE</code>, the target values will be computed based on each batch, otherwise, based on the whole dataset. Setting <code>TRUE</code> might be useful if your dataset has very obvious batch effects, but this may also make the algorithm less robust. See Details. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_targetval_removeoutlier">targetVal_removeOutlier</code></td>
<td>
<p>logical. If <code>TRUE</code>, outliers will be removed before the computation. Outliers are determined with 1.5 * IQR (interquartile range) rule. We recommend turning this off when the target values are computed based on batches. See Details. Default: <code>!targetVal_batchWise</code>.</p>
</td></tr>
<tr><td><code id="compute_targetVal_+3A_coerce_numeric">coerce_numeric</code></td>
<td>
<p>logical. If <code>TRUE</code>, values in <code>QC_num</code> will be coerced to numeric before the computation. The columns cannot be coerced will be removed (with warnings). See Examples. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+run_TIGER">run_TIGER</a></code>.
</p>


<h3>Value</h3>

<p>If <code>targetVal_batchWise = FALSE</code>, the function returns a list of length one containing the target values computed on the whole dataset.
</p>
<p>If <code>targetVal_batchWise = TRUE</code>, a list containing the target values computed on different batches is returned. The length of the returned list equals the number of batch specified by <code>batchID</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(FF4_qc) # load demo dataset
QC_num &lt;- FF4_qc[-c(1:5)] # only contain numeric metabolite values.

# target values computed on the whole dataset:
tarVal_1 &lt;- compute_targetVal(QC_num = QC_num,
                              sampleType = FF4_qc$sampleType,
                              batchID = FF4_qc$plateID,
                              targetVal_method = "mean",
                              targetVal_batchWise = FALSE,
                              targetVal_removeOutlier = TRUE)

# target values computed on batches:
tarVal_2 &lt;- compute_targetVal(QC_num = QC_num,
                              sampleType = FF4_qc$sampleType,
                              batchID = FF4_qc$plateID,
                              targetVal_method = "mean",
                              targetVal_batchWise = TRUE,
                              targetVal_removeOutlier = FALSE)

# If coerce_numeric = TRUE,
# columns cannot be coerced to numeric will be removed (with warnings):
tarVal_3 &lt;- compute_targetVal(QC_num = FF4_qc[-c(4:5)],
                              sampleType = FF4_qc$sampleType,
                              batchID = FF4_qc$plateID,
                              targetVal_method = "mean",
                              targetVal_batchWise = TRUE,
                              targetVal_removeOutlier = FALSE,
                              coerce_numeric = TRUE)
identical(tarVal_2, tarVal_3)  # identical to tarVal_2

## Not run: 

# will throw errors if input data have non-numeric columns
# and coerce_numeric = FALSE:

tarVal_4 &lt;- compute_targetVal(QC_num = FF4_qc,
                              sampleType = FF4_qc$sampleType,
                              batchID = FF4_qc$plateID,
                              targetVal_method = "mean",
                              targetVal_batchWise = TRUE,
                              targetVal_removeOutlier = FALSE,
                              coerce_numeric = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='FF4_qc'>Accompanying QC samples of KORA FF4 (demo data)</h2><span id='topic+FF4_qc'></span>

<h3>Description</h3>

<p>This demo dataset, a data.frame with 232 samples (rows) and 108 variables (columns). The dataset includes four types of quality control (QC) samples from 29 kit plates:
</p>

<ul>
<li><p> QC1 (<em>N</em> = 29, one per plate),
</p>
</li>
<li><p> QC2 (<em>N</em> = 29, one per plate),
</p>
</li>
<li><p> QC3 (<em>N</em> = 29, one per plate),
</p>
</li>
<li><p> QC  (<em>N</em> = 145, five per plate).
</p>
</li></ul>

<p>The columns include sample ID, sample type, plate ID, well position, injection order and the concentrations of 103 selected targeted metabolites. These QC samples are measured with the cohort samples of KORA FF4 (Cooperative Health Research in the Augsburg Region, the second follow-up study, 2013–2014) using the analytical assay Biocrates Absolute<em>IDQ</em><sup>®</sup> p180 (BIOCRATES Life Sciences AG, Innsbruck, Austria).
</p>
<p>In our paper, we used QC as training samples, while QC1, QC2, QC3 and cohort samples were used as test samples. The cohort data are operated by Helmholtz Zentrum München and available via KORA platform <a href="https://www.helmholtz-munich.de/en/kora/">https://www.helmholtz-munich.de/en/kora/</a> upon reasonable request. See Reference for detailed information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FF4_qc)
</code></pre>


<h3>Reference</h3>

<p>Han S. <em>et al</em>. TIGER: technical variation elimination for metabolomics data using ensemble learning architecture. <em>Briefings in Bioinformatics</em> (2022) bbab535. doi: <a href="https://doi.org/10.1093/bib/bbab535">10.1093/bib/bbab535</a>.
</p>

<hr>
<h2 id='run_TIGER'>Run TIGER to eliminate technical variation</h2><span id='topic+run_TIGER'></span>

<h3>Description</h3>

<p>Use TIGER algorithm to eliminate the technical variation in metabolomics data. TIGER supports targeted and untargeted metabolomics data and is competent to perform both intra- and inter-batch technical variation removal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_TIGER(
  test_samples,
  train_samples,
  col_sampleID,
  col_sampleType,
  col_batchID,
  col_order = NULL,
  col_position = NULL,
  targetVal_external = NULL,
  targetVal_method = c("mean", "median"),
  targetVal_batchWise = FALSE,
  targetVal_removeOutlier = !targetVal_batchWise,
  selectVar_external = NULL,
  selectVar_corType = c("cor", "pcor"),
  selectVar_corMethod = c("pearson", "spearman"),
  selectVar_minNum = 5,
  selectVar_maxNum = 10,
  selectVar_batchWise = FALSE,
  mtry_percent = seq(0.2, 0.8, 0.2),
  nodesize_percent = seq(0.2, 0.8, 0.2),
  ...,
  parallel.cores = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_TIGER_+3A_test_samples">test_samples</code></td>
<td>
<p>(required) a data.frame containing the samples to be corrected (for example, subject samples). This data.frame should contain columns of
</p>

<ul>
<li><p> sample ID (required): name or label for each sample,
</p>
</li>
<li><p> sample type (required): indicating the type of each sample,
</p>
</li>
<li><p> batch ID (required): the batch of each sample,
</p>
</li>
<li><p> order information (optional): injection order or temporal information of each sample,
</p>
</li>
<li><p> position information (optional): well position of each sample,
</p>
</li>
<li><p> metabolite values (required): values to be normalised. Infinite values are not allowed.
</p>
</li></ul>

<p>Row: sample. Column: variable. See Examples.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_train_samples">train_samples</code></td>
<td>
<p>(required) a data.frame containing the quality control (QC) samples used for model training. The columns in this data.frame should correspond to the columns in <code>test_samples</code>. And <code>test_samples</code> and <code>train_samples</code> should have the identical column names.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_col_sampleid">col_sampleID</code></td>
<td>
<p>(required) a character string indicating the name of the column that specifies the sample ID of each sample. The values in this column will not affect the data correction process but can act as labels for different samples. See Examples.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_col_sampletype">col_sampleType</code></td>
<td>
<p>(required) a character string indicating the name of the column that specifies the type (such as QC1, QC2, subject) of each sample. This column can be used to indicate different kinds of QC samples in <code>train_samples</code>. QC samples of the <strong>same type</strong> should have the <strong>same type name</strong>. See Examples.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_col_batchid">col_batchID</code></td>
<td>
<p>(required) a character string indicating the name of the column that specifies the batch ID of each sample. See Examples.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_col_order">col_order</code></td>
<td>
<p>(optional) <code>NULL</code> or a character string indicating the name of the column that contains the injection order or temporal information (numeric values). This can explicitly ask the algorithm capture the technical variation introduced by injection order, which might be useful when your data have very obvious temporal drifts. If <code>NULL</code> (default), <code>train_samples</code> and <code>test_samples</code> should have <strong>No</strong> column contains injection order information.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_col_position">col_position</code></td>
<td>
<p>(optional) <code>NULL</code> or a character string indicating the name of the column that contains the well position information (numeric values). This can explicitly ask the algorithm capture the technical variation introduced by well position, which might be useful when the well position has a great impact during data acquisition. If <code>NULL</code> (default), <code>train_samples</code> and <code>test_samples</code> should have <strong>No</strong> column contains well position information.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_targetval_external">targetVal_external</code></td>
<td>
<p>(optional) a list generated by function <code><a href="#topic+compute_targetVal">compute_targetVal</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_targetval_method">targetVal_method</code></td>
<td>
<p>a character string specifying how target values are to be computed. Can be <code>"mean"</code> (default) or <code>"median"</code>. Ignored if a list of external target values has been assigned to  <code>targetVal_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_targetval_batchwise">targetVal_batchWise</code></td>
<td>
<p>logical. If <code>TRUE</code>, the target values will be computed based on each batch, otherwise, based on the whole dataset. Setting <code>TRUE</code> might be useful if your dataset has very obvious batch effects, but this may also make the algorithm less robust. Default: <code>FALSE</code>. Ignored if a list of external target values has been assigned to  <code>targetVal_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_targetval_removeoutlier">targetVal_removeOutlier</code></td>
<td>
<p>logical. If <code>TRUE</code>, outliers will be removed before the computation. Outliers are determined with 1.5 * IQR (interquartile range) rule. We recommend turning this off when the target values are computed based on batches. Default: <code>!targetVal_batchWise</code>. Ignored if a list of external target values has been assigned to  <code>targetVal_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_external">selectVar_external</code></td>
<td>
<p>(optional) a list generated by function <code><a href="#topic+select_variable">select_variable</a></code>. See Details.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_cortype">selectVar_corType</code></td>
<td>
<p>a character string indicating correlation (<code>"cor"</code>, default) or partial correlation (<code>"pcor"</code>) is to be used. Can be abbreviated. Ignored if a list of selected variables has been assigned to <code>selectVar_external</code>. <strong>Note</strong>: computing partial correlations of a large dataset can be very time-consuming.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_cormethod">selectVar_corMethod</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed. One of <code>"spearman"</code> (default) or <code>"pearson"</code>. Can be abbreviated. Ignored if a list of selected variables has been assigned to <code>selectVar_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_minnum">selectVar_minNum</code></td>
<td>
<p>an integer specifying the minimum number of the selected metabolite variables (injection order and well position are not regarded as metabolite variables). If <code>NULL</code>, no limited, but 1 at least. Default: <code>5</code>. Ignored if a list of selected variables has been assigned to <code>selectVar_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_maxnum">selectVar_maxNum</code></td>
<td>
<p>an integer specifying the maximum number of the selected metabolite variables (injection order and well position are not regarded as metabolite variables). If <code>NULL</code>, no limited, but no more than the number of all available metabolite variables. Default: <code>10</code>. Ignored if a list of selected variables has been assigned to <code>selectVar_external</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_selectvar_batchwise">selectVar_batchWise</code></td>
<td>
<p>(advanced) logical. Specify whether the variable selection should be performed based on each batch. Default: <code>FALSE</code>. Ignored if a list of selected variables has been assigned to <code>selectVar_external</code>. <strong>Note</strong>: the support of batch-wise variable selection is provided for data requiring special processing (for example, data with strong batch effects). But in most case, batch-wise variable selection is not necessary. Setting <code>TRUE</code> can make the algorithm less robust.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_mtry_percent">mtry_percent</code></td>
<td>
<p>(advanced) a numeric vector indicating the percentages of selected variables randomly sampled as candidates at each split when training random forest models (base learners). <strong>Note</strong>: providing more arguments will include more base learners into the ensemble model, which will increase the processing time. Default: <code>seq(0.2, 0.8, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_nodesize_percent">nodesize_percent</code></td>
<td>
<p>(advanced) a numeric vector indicating the percentages of sample size used as the minimum sizes of the terminal nodes in random forest models (base learners). <strong>Note</strong>: providing more arguments will include more base learners into the ensemble model, which will increase the processing time. Default: <code>seq(0.2, 0.8, 0.2)</code>.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_...">...</code></td>
<td>
<p>(advanced) optional arguments (except <code>mtry</code> and <code>nodesize</code>) to be passed to <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> for model training. Arguments <code>mtry</code> and <code>nodesize</code> are determined by <code>mtry_percent</code> and <code>nodesize_percent</code>. See <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> and Examples. <strong>Note</strong>: providing more arguments will include more base learners into the ensemble model, which will increase the processing time.</p>
</td></tr>
<tr><td><code id="run_TIGER_+3A_parallel.cores">parallel.cores</code></td>
<td>
<p>an integer (== -1 or &gt;= 1) specifying the number of cores for parallel computation. Setting <code>-1</code> to run with all cores. Default: <code>2</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TIGER can effectively process the datasets with its default setup. The following hyperparameters are provided to customise the algorithm and achieve the best possible performance. These hyperparameters are also practical for some special purposes (such as cross-kit adjustment, longitudinal dataset correction) or datasets requiring special processing (for example, data with very strong temporal drifts or batch effects). We recommend users to examine the normalised result with different metrics, such as RSD (relative standard deviation), MAPE (mean absolute percentage error) and PCA (principal component analysis), especially when using advanced options of TIGER.
</p>
<p><strong>Hyperparameters for target value computation</strong>
</p>

<ul>
<li> <p><code>targetVal_external</code>
</p>
<p>TIGER by default captures and eliminate the technical variation within the input dataset, and the target values are automatically computed from <code>train_samples</code>. The target values can also be calculated from a reference dataset using function <code><a href="#topic+compute_targetVal">compute_targetVal</a></code> and then passed to this function as an argument. This will enable TIGER to align <code>test_samples</code> with the reference dataset. In this case, <code>train_samples</code> is still the accompanying QC samples of <code>test_samples</code>. And argument <code>targetVal_external</code> accepts external target values (a list). If the list of external target values is provided, values in <code>targetVal_method</code>, <code>targetVal_batchWise</code> and <code>targetVal_removeOutlier</code> will be ignored.
</p>
</li>
<li> <p><code>targetVal_method</code>
</p>
<p>The target values can be the mean or median values of metabolite values. The target values of different kinds of QC samples are computed separately. <code>"mean"</code> is recommended here, but the optimal selection can differ for different datasets.
</p>
</li>
<li> <p><code>targetVal_batchWise</code>
</p>
<p>The target values can be computed from the whole dataset or from different batches. By default, the target values are computed based on the whole dataset. Computing based on batches (<code>targetVal_batchWise = TRUE</code>) is only recommended when the samples has very strong batch effects. For example, we set this as <code>TRUE</code> when normalising WaveICA's Amide dataset in our original paper.
</p>
</li>
<li>  <p><code>targetVal_removeOutlier</code>
</p>
<p>If computing is based on the whole dataset (<code>targetVal_batchWise = TRUE</code>), users can remove the outliers in each metabolite by setting <code>targetVal_removeOutlier</code> as <code>TRUE</code>. This can weaken the impact of extreme values. If <code>targetVal_batchWise = FALSE</code>, it is generally not recommended to remove outliers, as we assume the input data have strong batch effects and contain extreme values—we hope TIGER can take these into account. Code for checking outliers is adapted from <code><a href="grDevices.html#topic+boxplot.stats">boxplot.stats</a></code>.
</p>
</li></ul>

<p><strong>Hyperparameters for variable selection</strong>
</p>

<ul>
<li> <p><code>selectVar_external</code>:
</p>
<p>This argument accepts a list of selected variables generated by <code><a href="#topic+select_variable">select_variable</a></code>. This is helpful when you want to use the same selected variables to correct several datasets. You can also pass a self-defined list to this argument, as long as the self-defined list has similar data structure as the one generated by <code><a href="#topic+select_variable">select_variable</a></code>.
</p>
</li>
<li> <p><code>selectVar_corType</code> and <code>selectVar_corMethod</code>:
</p>
<p>TIGER supports Pearson product-moment correlation (<code>"pearson"</code>) and Spearman's rank correlation (<code>"spearman"</code>) to compute correlation coefficients (<code>"cor"</code>) or partial correlation coefficients (<code>"por"</code>) for variable selection. See <code><a href="stats.html#topic+cor">cor</a></code> and <code><a href="ppcor.html#topic+pcor">pcor</a></code> for further details.
</p>
</li>
<li> <p><code>selectVar_minNum</code> and <code>selectVar_maxNum</code>:
</p>
<p>For an objective metabolite to be corrected, the intersection of its top <em>t</em> highly-correlated metabolites calculated from training and test samples are selected to train the ensemble model. The highly-correlated metabolites are the ones with correlation coefficients greater than 0.5 (the objective metabolite itself will not be regarded as its highly-correlated metabolite). Arguments <code>selectVar_minNum</code> and <code>selectVar_maxNum</code> are used to avoid selecting too many or too few metabolites. Selecting too many metabolites can lower the process, sometimes even lower the accuracy.
</p>
</li>
<li> <p><code>selectVar_batchWise</code>:
</p>
<p>Advanced option designed for special cases. Setting it <code>TRUE</code> might be useful when your data have very obvious batch effects.
</p>
</li></ul>

<p><strong>Hyperparameters for model construction</strong>
</p>

<ul>
<li> <p><code>mtry_percent</code>, <code>nodesize_percent</code> and <code>...</code>:
</p>
<p>Advanced options to specify <code>mtry</code>, <code>nodesize</code> and other related arguments in <code><a href="randomForest.html#topic+randomForest">randomForest</a></code> for a customised ensemble learning architecture. See Examples.
</p>
</li></ul>



<h3>Value</h3>

<p>This function returns a data.frame with the same data structure as the input <code>test_samples</code>, but the metabolite values are the normalised/corrected ones. <code>NA</code> and zeros in the original <code>test_samples</code> will not be changed or normalised.
</p>


<h3>Reference</h3>

<p>Han S. <em>et al</em>. TIGER: technical variation elimination for metabolomics data using ensemble learning architecture. <em>Briefings in Bioinformatics</em> (2022) bbab535. doi: <a href="https://doi.org/10.1093/bib/bbab535">10.1093/bib/bbab535</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FF4_qc) # load demo dataset

# QC as training samples; QC1, QC2 and QC3 as test samples:
train_samples &lt;- FF4_qc[FF4_qc$sampleType == "QC",]
test_samples  &lt;- FF4_qc[FF4_qc$sampleType != "QC",]

# col_sampleID includes labels. You can assign names for different samples:
train_samples$sampleID &lt;- "train"
test_samples$sampleID  &lt;- "test"

# Use default setting and
# include injection order and well position into feature set:
test_norm_1 &lt;- run_TIGER(test_samples = test_samples,
                         train_samples = train_samples,
                         col_sampleID  = "sampleID",     # input column name
                         col_sampleType = "sampleType",  # input column name
                         col_batchID = "plateID",        # input column name
                         col_order = "injectionOrder",   # input column name
                         col_position = "wellPosition",  # input column name
                         parallel.cores = 2)

# If the information of injection order and well position is not available,
# or you don't want to use them:
train_data &lt;- train_samples[-c(4:5)]  # remove the two columns
test_data  &lt;- test_samples[-c(4:5)]   # remove the two columns

test_norm_2 &lt;- run_TIGER(test_samples = test_data,
                         train_samples = train_data,
                         col_sampleID  = "sampleID",
                         col_sampleType = "sampleType",
                         col_batchID = "plateID",
                         col_order = NULL,                # set NULL
                         col_position = NULL,             # set NULL
                         parallel.cores = 2)

# If use external target values and selected variables with
# customised settings:
target_val &lt;- compute_targetVal(QC_num = train_samples[-c(1:5)],
                                sampleType = train_samples$sampleType,
                                batchID = train_samples$plateID,
                                targetVal_method = "median",
                                targetVal_batchWise = TRUE)

select_var &lt;- select_variable(train_num = train_samples[-c(1:5)],
                              test_num = test_samples[-c(1:5)],
                              train_batchID = train_samples$plateID,
                              test_batchID = test_samples$plateID,
                              selectVar_corType = "pcor",
                              selectVar_corMethod = "spearman",
                              selectVar_minNum = 10,
                              selectVar_maxNum = 30,
                              selectVar_batchWise = TRUE)

test_norm_3 &lt;- run_TIGER(test_samples = test_samples,
                         train_samples = train_samples,
                         col_sampleID  = "sampleID",
                         col_sampleType = "sampleType",
                         col_batchID = "plateID",
                         col_order = "injectionOrder",
                         col_position = "wellPosition",
                         targetVal_external = target_val,
                         selectVar_external = select_var,
                         parallel.cores = 2)

# The definitions of other hyperparameters correspond to
# randomForest::randomForest().
# If want to include more hyperparameters into model training,
# put hyperparameter values like this:
mtry_percent &lt;- c(0.4, 0.8)
nodesize_percent &lt;- c(0.4, 0.8)
replace &lt;- c(TRUE, FALSE)
ntree &lt;- c(100, 200, 300)

test_norm_4 &lt;- run_TIGER(test_samples = test_data,
                         train_samples = train_data,
                         col_sampleID  = "sampleID",
                         col_sampleType = "sampleType",
                         col_batchID = "plateID",
                         mtry_percent = mtry_percent,
                         nodesize_percent = nodesize_percent,
                         replace = replace,
                         ntree = ntree,
                         parallel.cores = 2)

# test_norm_4 is corrected by the ensemble model consisted of base learners
# trained with (around) 24 different hyperparameter combinations:
expand.grid(mtry_percent, nodesize_percent, replace, ntree)

# Note: mtry and nodesize are calculated by mtry_percent and nodesize_percent,
#       duplicated hyperparameter combinations, if any, will be removed.
#       Thus, the total number of hyperparameter combinations can be less than 24.
#       This is determined by the shape of your input datasets.

</code></pre>

<hr>
<h2 id='select_variable'>Select variables for ensemble learning architecture</h2><span id='topic+select_variable'></span>

<h3>Description</h3>

<p>This function provides an advanced option to select metabolite variables from external dataset(s). The selected variables (as a list) can be further passed to argument <code>selectVar_external</code> in function <code><a href="#topic+run_TIGER">run_TIGER</a></code> for a customised data correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_variable(
  train_num,
  test_num = NULL,
  train_batchID = NULL,
  test_batchID = NULL,
  selectVar_corType = c("cor", "pcor"),
  selectVar_corMethod = c("spearman", "pearson"),
  selectVar_minNum = 5,
  selectVar_maxNum = 10,
  selectVar_batchWise = FALSE,
  coerce_numeric = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_variable_+3A_train_num">train_num</code></td>
<td>
<p>a numeric data.frame <strong>only</strong> including the metabolite values of training samples (can be quality control samples). Information such as injection order or well position need to be excluded. Row: sample. Column: metabolite variable. See Examples.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_test_num">test_num</code></td>
<td>
<p>an optional numeric data.frame including the metabolite values of test samples (can be subject samples). If provided, the column names of <code>test_num</code> should correspond to the column names of <code>train_num</code>. Row: sample. Column: metabolite variable. If <code>NULL</code>, the variables will be selected based on <code>train_num</code> only. See Examples.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_train_batchid">train_batchID</code></td>
<td>
<p><code>NULL</code> or a vector corresponding to <code>train_num</code> to specify the batch of each sample. Ignored if <code>selectVar_batchWise = FALSE</code>. See Examples.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_test_batchid">test_batchID</code></td>
<td>
<p><code>NULL</code> or a vector corresponding to <code>test_num</code> to specify the batch of each sample. Ignored if <code>selectVar_batchWise = FALSE</code>. See Examples.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_selectvar_cortype">selectVar_corType</code></td>
<td>
<p>a character string indicating correlation (<code>"cor"</code>, default) or partial correlation (<code>"pcor"</code>) is to be used. Can be abbreviated. See Details. <strong>Note</strong>: computing partial correlations of a large dataset can be very time-consuming.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_selectvar_cormethod">selectVar_corMethod</code></td>
<td>
<p>a character string indicating which correlation coefficient is to be computed. One of <code>"spearman"</code> (default) or <code>"pearson"</code>. Can be abbreviated. See Details.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_selectvar_minnum">selectVar_minNum</code></td>
<td>
<p>an integer specifying the minimum number of the selected variables. If <code>NULL</code>, no limited, but 1 at least. See Details. Default: 5.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_selectvar_maxnum">selectVar_maxNum</code></td>
<td>
<p>an integer specifying the maximum number of the selected variables. If <code>NULL</code>, no limited, but <code>ncol(train_num) - 1</code> at most. See Details. Default: 10.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_selectvar_batchwise">selectVar_batchWise</code></td>
<td>
<p>(advanced) logical. Specify whether the variable selection should be performed based on each batch. Default: <code>FALSE</code>. <strong>Note</strong>: if <code>TRUE</code>, batch ID of each sample are required. The support of batch-wise variable selection is provided for data requiring special processing (for example, data with strong batch effects). But in most case, batch-wise variable selection is not necessary. Setting <code>TRUE</code> might make the algorithm less robust. See Details.</p>
</td></tr>
<tr><td><code id="select_variable_+3A_coerce_numeric">coerce_numeric</code></td>
<td>
<p>logical. If <code>TRUE</code>, values in <code>train_num</code> and  <code>test_num</code> will be coerced to numeric before the computation. The columns cannot be coerced will be removed (with warnings). See Examples. Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+run_TIGER">run_TIGER</a></code>.
</p>


<h3>Value</h3>

<p>If <code>selectVar_batchWise = FALSE</code>, the function returns a list of length one containing the selected variables computed on the whole dataset.
</p>
<p>If <code>selectVar_batchWise = TRUE</code>, a list containing the selected variables computed on different batches is returned. The length of the returned list equals the number of batch specified by <code>test_batchID</code> and/or <code>train_batchID</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(FF4_qc) # load demo dataset

# QC as training samples; QC1, QC2 and QC3 as test samples:
train_samples &lt;- FF4_qc[FF4_qc$sampleType == "QC",]
test_samples  &lt;- FF4_qc[FF4_qc$sampleType != "QC",]

# Only numeric data of metabolite variables are allowed:
train_num = train_samples[-c(1:5)]
test_num  = test_samples[-c(1:5)]

# If the selection is performed on the whole dataset:
# based on training samples only:
selected_var_1 &lt;- select_variable(train_num = train_num,
                                  test_num  = NULL,
                                  selectVar_batchWise = FALSE)

# also consider test samples:
selected_var_2 &lt;- select_variable(train_num = train_num,
                                  test_num  = test_num,
                                  selectVar_batchWise = FALSE)

# If the selection is based on different batches:
# (In selectVar_batchWise, batch ID is required.)
selected_var_3 &lt;- select_variable(train_num = train_num,
                                  test_num  = NULL,
                                  train_batchID = train_samples$plateID,
                                  test_batchID  = NULL,
                                  selectVar_batchWise = TRUE)

# If coerce_numeric = TRUE,
# columns cannot be coerced to numeric will be removed (with warnings):
# (In this example, columns of injection order and well position are excluded.
# Because we don't want to calculate the correlations between metabolites and
# injection order/well position.)
selected_var_4 &lt;- select_variable(train_num = train_samples[-c(4,5)],
                                  train_batchID = train_samples$plateID,
                                  selectVar_batchWise = TRUE,
                                  coerce_numeric = TRUE)
identical(selected_var_3, selected_var_4)  # identical to selected_var_3

## Not run: 

# will throw errors if input data have non-numeric columns
# and coerce_numeric = FALSE:

selected_var_5 &lt;- select_variable(train_num = train_samples[-c(4,5)],
                                  coerce_numeric = FALSE)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
