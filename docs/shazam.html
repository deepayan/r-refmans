<!DOCTYPE html><html lang="en"><head><title>Help for package shazam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shazam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#shazam-package'><p>shazam: Immunoglobulin Somatic Hypermutation Analysis</p></a></li>
<li><a href='#Baseline-class'><p>S4 class defining a BASELINe (selection) object</p></a></li>
<li><a href='#calcBaseline'><p>Calculate the BASELINe PDFs (including for regions that include CDR3 and FWR4)</p></a></li>
<li><a href='#calcExpectedMutations'><p>Calculate expected mutation frequencies of a sequence</p></a></li>
<li><a href='#calcObservedMutations'><p>Count the number of observed mutations in a sequence.</p></a></li>
<li><a href='#calcTargetingDistance'><p>Calculates a 5-mer distance matrix from a TargetingModel object</p></a></li>
<li><a href='#calculateMutability'><p>Calculate total mutability</p></a></li>
<li><a href='#collapseClones'><p>Constructs effective clonal sequences for all clones</p></a></li>
<li><a href='#consensusSequence'><p>Construct a consensus sequence</p></a></li>
<li><a href='#convertNumbering'><p>convertNumbering: IMGT-Kabat number conversion</p></a></li>
<li><a href='#createBaseline'><p>Creates a Baseline object</p></a></li>
<li><a href='#createMutabilityMatrix'><p>Builds a mutability model</p></a></li>
<li><a href='#createMutationDefinition'><p>Creates a MutationDefinition</p></a></li>
<li><a href='#createRegionDefinition'><p>Creates a RegionDefinition</p></a></li>
<li><a href='#createSubstitutionMatrix'><p>Builds a substitution model</p></a></li>
<li><a href='#createTargetingMatrix'><p>Calculates a targeting rate matrix</p></a></li>
<li><a href='#createTargetingModel'><p>Creates a TargetingModel</p></a></li>
<li><a href='#DensityThreshold-class'><p>Output of the <code>dens</code> method of findThreshold</p></a></li>
<li><a href='#distToNearest'><p>Distance to nearest neighbor</p></a></li>
<li><a href='#editBaseline'><p>Edit the Baseline object</p></a></li>
<li><a href='#expectedMutations'><p>Calculate expected mutation frequencies</p></a></li>
<li><a href='#extendMutabilityMatrix'><p>Extends a mutability model to include Ns.</p></a></li>
<li><a href='#extendSubstitutionMatrix'><p>Extends a substitution model to include Ns.</p></a></li>
<li><a href='#findThreshold'><p>Find distance threshold</p></a></li>
<li><a href='#GmmThreshold-class'><p>Output of the <code>gmm</code> method of findThreshold</p></a></li>
<li><a href='#groupBaseline'><p>Group BASELINe PDFs</p></a></li>
<li><a href='#HH_S1F'><p>Human heavy chain, silent, 1-mer, functional substitution model.</p></a></li>
<li><a href='#HH_S5F'><p>Human heavy chain, silent, 5-mer, functional targeting model.</p></a></li>
<li><a href='#HKL_S1F'><p>Human kappa and lambda chain, silent, 1-mer, functional substitution model.</p></a></li>
<li><a href='#HKL_S5F'><p>Human kappa and lambda light chain, silent, 5-mer, functional targeting model.</p></a></li>
<li><a href='#IMGT_SCHEMES'><p>IMGT unique numbering schemes</p></a></li>
<li><a href='#makeAverage1merMut'><p>Make a 1-mer mutability model by averaging over a 5-mer mutability model</p></a></li>
<li><a href='#makeAverage1merSub'><p>Make a 1-mer substitution model by averaging over a 5-mer substitution model</p></a></li>
<li><a href='#makeDegenerate5merMut'><p>Make a degenerate 5-mer mutability model based on a 1-mer mutability model</p></a></li>
<li><a href='#makeDegenerate5merSub'><p>Make a degenerate 5-mer substitution model based on a 1-mer substitution model</p></a></li>
<li><a href='#makeGraphDf'><p>Build a data.frame from a ChangeoClone and an igraph object containing a clonal lineage</p></a></li>
<li><a href='#minNumMutationsTune'><p>Parameter tuning for minNumMutations</p></a></li>
<li><a href='#minNumSeqMutationsTune'><p>Parameter tuning for minNumSeqMutations</p></a></li>
<li><a href='#MK_RS1NF'><p>Mouse kappa chain, replacement and silent, 1-mer, non-functional substitution model.</p></a></li>
<li><a href='#MK_RS5NF'><p>Mouse kappa light chain, replacement and silent, 5-mer, non-functional targeting model.</p></a></li>
<li><a href='#MutabilityModel-class'><p>S4 class defining a mutability model</p></a></li>
<li><a href='#MUTATION_SCHEMES'><p>Amino acid mutation definitions</p></a></li>
<li><a href='#MutationDefinition-class'><p>S4 class defining replacement and silent mutation definitions</p></a></li>
<li><a href='#observedMutations'><p>Calculate observed numbers of mutations</p></a></li>
<li><a href='#plotBaselineDensity'><p>Plots BASELINe probability density functions</p></a></li>
<li><a href='#plotBaselineSummary'><p>Plots BASELINe summary statistics</p></a></li>
<li><a href='#plotDensityThreshold'><p>Plot findThreshold results for the density method</p></a></li>
<li><a href='#plotGmmThreshold'><p>Plot findThreshold results for the gmm method</p></a></li>
<li><a href='#plotMutability'><p>Plot mutability probabilities</p></a></li>
<li><a href='#plotSlideWindowTune'><p>Visualize parameter tuning for sliding window approach</p></a></li>
<li><a href='#plotTune'><p>Visualize parameter tuning for minNumMutations and minNumSeqMutations</p></a></li>
<li><a href='#RegionDefinition-class'><p>S4 class defining a region definition</p></a></li>
<li><a href='#setRegionBoundaries'><p>Build a RegionDefinition object that includes CDR3 and FWR4.</p></a></li>
<li><a href='#shazam'><p>The shazam package</p></a></li>
<li><a href='#shmulateSeq'><p>Simulate mutations in a single sequence</p></a></li>
<li><a href='#shmulateTree'><p>Simulate mutations in a lineage tree</p></a></li>
<li><a href='#slideWindowDb'><p>Sliding window approach towards filtering sequences in a <code>data.frame</code></p></a></li>
<li><a href='#slideWindowSeq'><p>Sliding window approach towards filtering a single sequence</p></a></li>
<li><a href='#slideWindowTune'><p>Parameter tuning for sliding window approach</p></a></li>
<li><a href='#slideWindowTunePlot'><p>slideWindowTunePlot - plotSlideWindowTune backward compatability</p></a></li>
<li><a href='#summarizeBaseline'><p>Calculate BASELINe summary statistics</p></a></li>
<li><a href='#TargetingMatrix-class'><p>S4 class defining a targeting matrix</p></a></li>
<li><a href='#TargetingModel-class'><p>S4 class defining a targeting model</p></a></li>
<li><a href='#testBaseline'><p>Two-sided test of BASELINe PDFs</p></a></li>
<li><a href='#U5N'><p>Uniform 5-mer null targeting model.</p></a></li>
<li><a href='#writeTargetingDistance'><p>Write targeting model distances to a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-02</td>
</tr>
<tr>
<td>Title:</td>
<td>Immunoglobulin Somatic Hypermutation Analysis</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a computational framework for analyzing mutations in
    immunoglobulin (Ig) sequences. Includes methods for Bayesian estimation of
    antigen-driven selection pressure, mutational load quantification, building of
    somatic hypermutation (SHM) models, and model-dependent distance calculations.
    Also includes empirically derived models of SHM for both mice and humans.
    Citations: 
    Gupta and Vander Heiden, et al (2015) &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtv359">doi:10.1093/bioinformatics/btv359</a>&gt;, 
    Yaari, et al (2012) &lt;<a href="https://doi.org/10.1093%2Fnar%2Fgks457">doi:10.1093/nar/gks457</a>&gt;, 
    Yaari, et al (2013) &lt;<a href="https://doi.org/10.3389%2Ffimmu.2013.00358">doi:10.3389/fimmu.2013.00358</a>&gt;, 
    Cui, et al (2016) &lt;<a href="https://doi.org/10.4049%2Fjimmunol.1502263">doi:10.4049/jimmunol.1502263</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://shazam.readthedocs.io">http://shazam.readthedocs.io</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://bitbucket.org/kleinstein/shazam/issues">https://bitbucket.org/kleinstein/shazam/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildVignettes:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), ggplot2 (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>alakazam (&ge; 1.3.0), ape, diptest, doParallel, dplyr (&ge; 1.0),
foreach, graphics, grid, igraph (&ge; 1.5.0), iterators,
KernSmooth, lazyeval, MASS, methods, parallel, progress, rlang,
scales, seqinr, stats, stringi (&ge; 1.1.3), tidyr, tidyselect,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>Collate:</td>
<td>'Shazam.R' 'Core.R' 'RegionDefinitions.R' 'Baseline.R'
'ConvertNumbering.R' 'MutationProfiling.R' 'Deprecated.R'
'DistToNearest.R' 'MutationDefinitions.R' 'RegionsExtend.R'
'Shmulate.R' 'TargetingModels.R' 'kedd.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-02 16:57:50 UTC; susanna</td>
</tr>
<tr>
<td>Author:</td>
<td>Mohamed Uduman [aut],
  Namita Gupta [aut],
  Susanna Marquez [aut, cre],
  Julian Zhou [aut],
  Nima Nouri [aut],
  Noah Yann Lee [aut],
  Ang Cui [ctb],
  Jason Vander Heiden [aut],
  Gur Yaari [aut],
  Steven Kleinstein [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Susanna Marquez &lt;susanna.marquez@yale.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-02 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='shazam-package'>shazam: Immunoglobulin Somatic Hypermutation Analysis</h2><span id='topic+shazam-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Provides a computational framework for analyzing mutations in immunoglobulin (Ig) sequences. Includes methods for Bayesian estimation of antigen-driven selection pressure, mutational load quantification, building of somatic hypermutation (SHM) models, and model-dependent distance calculations. Also includes empirically derived models of SHM for both mice and humans. Citations: Gupta and Vander Heiden, et al (2015) <a href="https://doi.org/10.1093/bioinformatics/btv359">doi:10.1093/bioinformatics/btv359</a>, Yaari, et al (2012) <a href="https://doi.org/10.1093/nar/gks457">doi:10.1093/nar/gks457</a>, Yaari, et al (2013) <a href="https://doi.org/10.3389/fimmu.2013.00358">doi:10.3389/fimmu.2013.00358</a>, Cui, et al (2016) <a href="https://doi.org/10.4049/jimmunol.1502263">doi:10.4049/jimmunol.1502263</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Susanna Marquez <a href="mailto:susanna.marquez@yale.edu">susanna.marquez@yale.edu</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Mohamed Uduman <a href="mailto:mohamed.uduman@yale.edu">mohamed.uduman@yale.edu</a>
</p>
</li>
<li><p> Namita Gupta <a href="mailto:namita.gupta@yale.edu">namita.gupta@yale.edu</a>
</p>
</li>
<li><p> Julian Zhou <a href="mailto:julian.zhou@yale.edu">julian.zhou@yale.edu</a>
</p>
</li>
<li><p> Nima Nouri <a href="mailto:nima.nouri@yale.edu">nima.nouri@yale.edu</a>
</p>
</li>
<li><p> Noah Yann Lee <a href="mailto:noah.yann.lee@yale.edu">noah.yann.lee@yale.edu</a>
</p>
</li>
<li><p> Jason Vander Heiden <a href="mailto:jason.vanderheiden@gmail.com">jason.vanderheiden@gmail.com</a>
</p>
</li>
<li><p> Gur Yaari <a href="mailto:gur.yaari@biu.ac.il">gur.yaari@biu.ac.il</a>
</p>
</li>
<li><p> Steven Kleinstein <a href="mailto:steven.kleinstein@yale.edu">steven.kleinstein@yale.edu</a> [copyright holder]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Ang Cui <a href="mailto:angcui@mit.edu">angcui@mit.edu</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="http://shazam.readthedocs.io">http://shazam.readthedocs.io</a>
</p>
</li>
<li><p> Report bugs at <a href="https://bitbucket.org/kleinstein/shazam/issues">https://bitbucket.org/kleinstein/shazam/issues</a>
</p>
</li></ul>


<hr>
<h2 id='Baseline-class'>S4 class defining a BASELINe (selection) object</h2><span id='topic+Baseline-class'></span><span id='topic+Baseline'></span><span id='topic+plot+2CBaseline+2Ccharacter-method'></span><span id='topic+Baseline-method'></span><span id='topic+summary+2CBaseline-method'></span>

<h3>Description</h3>

<p><code>Baseline</code> defines a common data structure the results of selection
analysis using the BASELINe method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Baseline,character'
plot(x, y, ...)

## S4 method for signature 'Baseline'
summary(object, nproc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Baseline-class_+3A_x">x</code></td>
<td>
<p><code>Baseline</code> object.</p>
</td></tr>
<tr><td><code id="Baseline-class_+3A_y">y</code></td>
<td>
<p>name of the column in the <code>db</code> slot of <code>baseline</code> 
containing primary identifiers.</p>
</td></tr>
<tr><td><code id="Baseline-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotBaselineDensity">plotBaselineDensity</a>.</p>
</td></tr>
<tr><td><code id="Baseline-class_+3A_object">object</code></td>
<td>
<p><code>Baseline</code> object.</p>
</td></tr>
<tr><td><code id="Baseline-class_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the operation over.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>description</code></dt><dd><p><code>character</code> providing general information regarding the 
sequences, selection analysis and/or object.</p>
</dd>
<dt><code>db</code></dt><dd><p><code>data.frame</code> containing annotation information about 
the sequences and selection results.</p>
</dd>
<dt><code>regionDefinition</code></dt><dd><p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences.</p>
</dd>
<dt><code>testStatistic</code></dt><dd><p><code>character</code> indicating the statistical framework 
used to test for selection. For example, <code>"local"</code> or 
<code>"focused"</code>.</p>
</dd>
<dt><code>regions</code></dt><dd><p><code>character</code> vector defining the regions the BASELINe 
analysis was carried out on. For <code>"cdr"</code> and <code>"fwr"</code> 
or <code>"cdr1"</code>, <code>"cdr2"</code>, <code>"cdr3"</code>, etc.</p>
</dd>
<dt><code>numbOfSeqs</code></dt><dd><p><code>matrix</code> of dimensions <code>r x c</code> containing the number of 
sequences or PDFs in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</dd>
<dt><code>binomK</code></dt><dd><p><code>matrix</code> of dimensions <code>r x c</code> containing the number of 
successes in the binomial trials in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</dd>
<dt><code>binomN</code></dt><dd><p><code>matrix</code> of dimensions <code>r x c</code> containing the total 
number of trials in the binomial in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</dd>
<dt><code>binomP</code></dt><dd><p><code>matrix</code> of dimensions <code>r x c</code> containing the probability 
of success in one binomial trial in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</dd>
<dt><code>pdfs</code></dt><dd><p><code>list</code> of matrices containing PDFs with one item for each 
defined region (e.g. <code>cdr</code> and <code>fwr</code>). Matrices have dimensions
<code>r x c</code> dementions, where:<br />
<code>r</code> = number of rows = number of sequences or groups. <br />
<code>c</code> = number of columns = length of the PDF (default 4001).</p>
</dd>
<dt><code>stats</code></dt><dd><p><code>data.frame</code> of BASELINe statistics, 
including: mean selection strength (mean Sigma), 95% confidence 
intervals, and p-values with positive signs for the presence of 
positive selection and/or p-values with negative signs for the
presence of negative selection.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+summarizeBaseline">summarizeBaseline</a> for more information on <code>@stats</code>.
</p>

<hr>
<h2 id='calcBaseline'>Calculate the BASELINe PDFs (including for regions that include CDR3 and FWR4)</h2><span id='topic+calcBaseline'></span>

<h3>Description</h3>

<p><code>calcBaseline</code> calculates the BASELINe posterior probability density 
functions (PDFs) for sequences in the given Change-O <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcBaseline(
  db,
  sequenceColumn = "clonal_sequence",
  germlineColumn = "clonal_germline",
  testStatistic = c("local", "focused", "imbalanced"),
  regionDefinition = NULL,
  targetingModel = HH_S5F,
  mutationDefinition = NULL,
  calcStats = FALSE,
  nproc = 1,
  cloneColumn = NULL,
  juncLengthColumn = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcBaseline_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data and annotations.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p><code>character</code> name of the column in <code>db</code> 
containing input sequences.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p><code>character</code> name of the column in <code>db</code> 
containing germline sequences.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_teststatistic">testStatistic</code></td>
<td>
<p><code>character</code> indicating the statistical framework 
used to test for selection. One of 
<code>c("local", "focused", "imbalanced")</code>.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_targetingmodel">targetingModel</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object. Default is  <a href="#topic+HH_S5F">HH_S5F</a>.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_mutationdefinition">mutationDefinition</code></td>
<td>
<p><a href="#topic+MutationDefinition">MutationDefinition</a> object defining replacement
and silent mutation criteria. If <code>NULL</code> then 
replacement and silent are determined by exact 
amino acid identity. Note, if the input data.frame 
already contains observed and expected mutation frequency 
columns then mutations will not be recalculated and this
argument will be ignored.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_calcstats">calcStats</code></td>
<td>
<p><code>logical</code> indicating whether or not to calculate the 
summary statistics <code>data.frame</code> stored in the 
<code>stats</code> slot of a <a href="#topic+Baseline">Baseline</a> object.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the operation over. If 
<code>nproc=0</code> then the <code>cluster</code> has already been
set and will not be reset.</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_clonecolumn">cloneColumn</code></td>
<td>
<p><code>character</code> name of the column in <code>db</code> 
containing clonal identifiers. Relevant only for 
when regionDefinition includes CDR and FWR4 (else
this value can be <code>NULL</code>)</p>
</td></tr>
<tr><td><code id="calcBaseline_+3A_junclengthcolumn">juncLengthColumn</code></td>
<td>
<p><code>character</code> name of the column in <code>db</code> 
containing the junction length. Relevant only for 
when regionDefinition includes CDR and FWR4 (else
this value can be <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the BASELINe posterior probability density function (PDF) for 
sequences in the provided <code>db</code>. 
</p>
<p><strong>Note</strong>: Individual sequences within clonal groups are not, strictly speaking, 
independent events and it is generally appropriate to only analyze selection 
pressures on an effective sequence for each clonal group. For this reason,
it is strongly recommended that the input <code>db</code> contains one effective 
sequence per clone. Effective clonal sequences can be obtained by calling 
the <a href="#topic+collapseClones">collapseClones</a> function.
</p>
<p>If the <code>db</code> does not contain the 
required columns to calculate the PDFs (namely mu_count &amp; mu_expected)
then the function will:
</p>

<ol>
<li><p>  Calculate the numbers of observed mutations.
</p>
</li>
<li><p>  Calculate the expected frequencies of mutations and modify the provided 
<code>db</code>. The modified <code>db</code> will be included as part of the 
returned <code>Baseline</code> object.
</p>
</li></ol>

<p>The <code>testStatistic</code> indicates the statistical framework used to test for selection. 
E.g.
</p>

<ul>
<li>   <p><code>local</code> = CDR_R / (CDR_R + CDR_S).
</p>
</li>
<li>   <p><code>focused</code> = CDR_R / (CDR_R + CDR_S + FWR_S).
</p>
</li>
<li>   <p><code>imbalanced</code> = CDR_R + CDR_S / (CDR_R + CDR_S + FWR_S + FRW_R).
</p>
</li></ul>

<p>For <code>focused</code> the <code>regionDefinition</code> must only contain two regions. If more 
than two regions are defined the <code>local</code> test statistic will be used.
For further information on the frame of these tests see Uduman et al. (2011).
</p>


<h3>Value</h3>

<p>A <a href="#topic+Baseline">Baseline</a> object containing the modified <code>db</code> and BASELINe 
posterior probability density functions (PDF) for each of the sequences.
</p>


<h3>References</h3>


<ol>
<li><p>  Hershberg U, et al. Improved methods for detecting selection by mutation 
analysis of Ig V region sequences. 
Int Immunol. 2008 20(5):683-94.
</p>
</li>
<li><p>  Uduman M, et al. Detecting selection in immunoglobulin sequences. 
Nucleic Acids Res. 2011 39(Web Server issue):W499-504.
</p>
</li>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based
on synonymous mutations from high-throughput immunoglobulin sequencing data.
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+Baseline">Baseline</a> for the return object.
See <a href="#topic+groupBaseline">groupBaseline</a> and <a href="#topic+summarizeBaseline">summarizeBaseline</a> for further processing.
See <a href="#topic+plotBaselineSummary">plotBaselineSummary</a> and <a href="#topic+plotBaselineDensity">plotBaselineDensity</a> for plotting results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and subset example data
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHG" &amp; sample_id == "+7d")

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id", 
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)
 
# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)
                         
</code></pre>

<hr>
<h2 id='calcExpectedMutations'>Calculate expected mutation frequencies of a sequence</h2><span id='topic+calcExpectedMutations'></span>

<h3>Description</h3>

<p><code>calcExpectedMutations</code> calculates the expected mutation
frequencies of a given sequence. This is primarily a helper function for
<a href="#topic+expectedMutations">expectedMutations</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcExpectedMutations(
  germlineSeq,
  inputSeq = NULL,
  targetingModel = HH_S5F,
  regionDefinition = NULL,
  mutationDefinition = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcExpectedMutations_+3A_germlineseq">germlineSeq</code></td>
<td>
<p>germline (reference) sequence.</p>
</td></tr>
<tr><td><code id="calcExpectedMutations_+3A_inputseq">inputSeq</code></td>
<td>
<p>input (observed) sequence. If this is not <code>NULL</code>, 
then <code>germlineSeq</code> will be processed to be the same
same length as <code>inputSeq</code> and positions in 
<code>germlineSeq</code> corresponding to positions with Ns in 
<code>inputSeq</code> will also be assigned an N.</p>
</td></tr>
<tr><td><code id="calcExpectedMutations_+3A_targetingmodel">targetingModel</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object. Default is <a href="#topic+HH_S5F">HH_S5F</a>.</p>
</td></tr>
<tr><td><code id="calcExpectedMutations_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences.</p>
</td></tr>
<tr><td><code id="calcExpectedMutations_+3A_mutationdefinition">mutationDefinition</code></td>
<td>
<p><a href="#topic+MutationDefinition">MutationDefinition</a> object defining replacement
and silent mutation criteria. If <code>NULL</code> then 
replacement and silent are determined by exact 
amino acid identity.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>calcExpectedMutations</code> calculates the expected mutation frequencies of a 
given sequence and its germline. 
</p>
<p>Note, only the part of the sequences defined in <code>regionDefinition</code> are analyzed. 
For example, when using the default <a href="#topic+IMGT_V">IMGT_V</a> definition, mutations in
positions beyond 312 will be ignored.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector of the expected frequencies of mutations in the 
regions in the <code>regionDefinition</code>. For example, when using the default 
<a href="#topic+IMGT_V">IMGT_V</a> definition, which defines positions for CDR and 
FWR, the following columns are calculated:
</p>

<ul>
<li>  <p><code>mu_expected_cdr_r</code>:  number of replacement mutations in CDR1 and 
CDR2 of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_cdr_s</code>:  number of silent mutations in CDR1 and CDR2 
of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_fwr_r</code>:  number of replacement mutations in FWR1, 
FWR2 and FWR3 of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_fwr_s</code>:  number of silent mutations in FWR1, FWR2 and
FWR3 of the V-segment.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+expectedMutations">expectedMutations</a> calls this function.
To create a custom <code>targetingModel</code> see <a href="#topic+createTargetingModel">createTargetingModel</a>.
See <a href="#topic+calcObservedMutations">calcObservedMutations</a> for getting observed mutation counts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example data
data(ExampleDb, package="alakazam")

# Use first entry in the exampled data for input and germline sequence
in_seq &lt;- ExampleDb[["sequence_alignment"]][1]
germ_seq &lt;-  ExampleDb[["germline_alignment_d_mask"]][1]

# Identify all mutations in the sequence
calcExpectedMutations(germ_seq,in_seq)

# Identify only mutations the V segment minus CDR3
calcExpectedMutations(germ_seq, in_seq, regionDefinition=IMGT_V)

# Define mutations based on hydropathy
calcExpectedMutations(germ_seq, in_seq, regionDefinition=IMGT_V,
                      mutationDefinition=HYDROPATHY_MUTATIONS)

</code></pre>

<hr>
<h2 id='calcObservedMutations'>Count the number of observed mutations in a sequence.</h2><span id='topic+calcObservedMutations'></span>

<h3>Description</h3>

<p><code>calcObservedMutations</code> determines all the mutations in a given input sequence 
compared to its germline sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcObservedMutations(
  inputSeq,
  germlineSeq,
  regionDefinition = NULL,
  mutationDefinition = NULL,
  ambiguousMode = c("eitherOr", "and"),
  returnRaw = FALSE,
  frequency = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcObservedMutations_+3A_inputseq">inputSeq</code></td>
<td>
<p>input sequence. IUPAC ambiguous characters for DNA are 
supported.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_germlineseq">germlineSeq</code></td>
<td>
<p>germline sequence. IUPAC ambiguous characters for DNA 
are supported.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences. Note, only the part of
sequences defined in <code>regionDefinition</code> are analyzed.
If NULL, mutations are counted for entire sequence.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_mutationdefinition">mutationDefinition</code></td>
<td>
<p><a href="#topic+MutationDefinition">MutationDefinition</a> object defining replacement
and silent mutation criteria. If <code>NULL</code> then 
replacement and silent are determined by exact 
amino acid identity.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_ambiguousmode">ambiguousMode</code></td>
<td>
<p>whether to consider ambiguous characters as 
<code>"either or"</code> or <code>"and"</code> when determining and 
counting the type(s) of mutations. Applicable only if
<code>inputSeq</code> and/or <code>germlineSeq</code> 
contain(s) ambiguous characters. One of 
<code>c("eitherOr", "and")</code>. Default is <code>"eitherOr"</code>.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_returnraw">returnRaw</code></td>
<td>
<p>return the positions of point mutations and their 
corresponding mutation types, as opposed to counts of 
mutations across positions. Also returns the number of 
bases used as the denominator when calculating frequency. 
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="calcObservedMutations_+3A_frequency">frequency</code></td>
<td>
<p><code>logical</code> indicating whether or not to calculate
mutation frequencies. The denominator used is the number 
of bases that are not one of &quot;N&quot;, &quot;-&quot;, or &quot;.&quot; in either 
the input or the germline sequences. If set, this 
overwrites <code>returnRaw</code>. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Each mutation is considered independently in the germline context</strong>. For illustration,
consider the case where the germline is <code>TGG</code> and the observed is <code>TAC</code>.
When determining the mutation type at position 2, which sees a change from <code>G</code> to 
<code>A</code>, we compare the codon <code>TGG</code> (germline) to <code>TAG</code> (mutation at position
2 independent of other mutations in the germline context). Similarly, when determining 
the mutation type at position 3, which sees a change from <code>G</code> to <code>C</code>, we 
compare the codon <code>TGG</code> (germline) to <code>TGC</code> (mutation at position 3 independent 
of other mutations in the germline context).
</p>
<p>If specified, only the part of <code>inputSeq</code> defined in <code>regionDefinition</code> is 
analyzed. For example, when using the default <a href="#topic+IMGT_V">IMGT_V</a> definition, then mutations 
in positions beyond 312 will be ignored. Additionally, non-triplet overhang at the 
sequence end is ignored.
</p>
<p>Only replacement (R) and silent (S) mutations are included in the results. <strong>Excluded</strong>
are: 
</p>

<ul>
<li><p> Stop mutations
</p>
<p>E.g.: the case where <code>TAGTGG</code> is observed for the germline <code>TGGTGG</code>.
</p>
</li>
<li><p> Mutations occurring in codons where one or both of the observed and the 
germline involve(s) one or more of &quot;N&quot;, &quot;-&quot;, or &quot;.&quot;.
</p>
<p>E.g.: the case where <code>TTG</code> is observed for the germline being any one of 
<code>TNG</code>, <code>.TG</code>, or <code>-TG</code>. Similarly, the case where any one of 
<code>TTN</code>, <code>TT.</code>, or <code>TT-</code> is observed for the germline <code>TTG</code>.
</p>
</li></ul>

<p>In other words, a result that is <code>NA</code> or zero indicates absence of R and S mutations, 
not necessarily all types of mutations, such as the excluded ones mentioned above.
</p>
<p><code>NA</code> is also returned if <code>inputSeq</code> or <code>germlineSeq</code> is shorter than 3
nucleotides.
</p>


<h3>Value</h3>

<p>For <code>returnRaw=FALSE</code>, an <code>array</code> with the numbers of replacement (R) 
and silent (S) mutations. 
</p>
<p>For <code>returnRaw=TRUE</code>, a list containing 
</p>

<ul>
<li> <p><code>$pos</code>: A data frame whose columns (<code>position</code>, <code>r</code>, 
<code>s</code>, and <code>region</code>) indicate, respecitively, the nucleotide 
position, the number of R mutations at that position, the number of S 
mutations at that position, and the region in which that nucleotide
is in.
</p>
</li>
<li> <p><code>$nonN</code>: A vector indicating the number of bases in regions 
defined by <code>regionDefinition</code> (excluding non-triplet overhang, 
if any) that are not one of &quot;N&quot;, &quot;-&quot;, or &quot;.&quot; in either the 
<code>inputSeq</code> or <code>germlineSeq</code>.
</p>
</li></ul>

<p>For <code>frequency=TRUE</code>, regardless of <code>returnRaw</code>, an <code>array</code> 
with the frequencies of replacement (R) and silent (S) mutations.
</p>


<h3>Ambiguous characters</h3>

<p>When there are ambiguous characters present, the user could choose how mutations involving
ambiguous characters are counted through <code>ambiguousMode</code>. The two available modes 
are <code>"eitherOr"</code> and <code>"and"</code>. 
</p>

<ul>
<li><p> With <code>"eitherOr"</code>, ambiguous characters are each expanded but only 
1 mutation is recorded. When determining the type of mutation, the 
priority for different types of mutations, in decreasing order, is as follows:
no mutation, replacement mutation, silent mutation, and stop mutation. 
</p>
<p>When counting the number of non-N, non-dash, and non-dot positions, each
position is counted only once, regardless of the presence of ambiguous
characters.
</p>
<p>As an example, consider the case where <code>germlineSeq</code> is <code>"TST"</code> and
<code>inputSeq</code> is <code>"THT"</code>. Expanding <code>"H"</code> at position 2 in 
<code>inputSeq</code> into <code>"A"</code>, <code>"C"</code>, and <code>"T"</code>, as well as 
expanding <code>"S"</code> at position 2 in <code>germlineSeq</code> into <code>"C"</code> and 
<code>"G"</code>, one gets:
</p>

<ul>
<li> <p><code>"TCT"</code> (germline) to <code>"TAT"</code> (observed): replacement
</p>
</li>
<li> <p><code>"TCT"</code> (germline) to <code>"TCT"</code> (observed): no mutation
</p>
</li>
<li> <p><code>"TCT"</code> (germline) to <code>"TTT"</code> (observed): replacement 
</p>
</li>
<li> <p><code>"TGT"</code> (germline) to <code>"TAT"</code> (observed): replacement 
</p>
</li>
<li> <p><code>"TGT"</code> (germline) to <code>"TCT"</code> (observed): replacement
</p>
</li>
<li> <p><code>"TGT"</code> (germline) to <code>"TTT"</code> (observed): replacement
</p>
</li></ul>

<p>Because &quot;no mutation&quot; takes priority over replacement mutation, the final 
mutation count returned for this example is <code>NA</code> (recall that only R and 
S mutations are returned). The number of non-N, non-dash, and non-dot 
positions is 3.
</p>
</li>
<li><p> With <code>"and"</code>, ambiguous characters are each expanded and mutation(s)
from all expansions are recorded.
</p>
<p>When counting the number of non-N, non-dash, and non-dot positions, if a 
position contains ambiguous character(s) in <code>inputSeq</code> and/or 
<code>germlineSeq</code>, the count at that position is taken to be the total 
number of combinations of germline and observed codons after expansion.
</p>
<p>Using the same example from above, the final result returned for this example
is that there are 5 R mutations at position 2. The number of non-N, non-dash,
and non-dot positions is 8, since there are 6 combinations stemming from 
position 2 after expanding the germline codon (<code>"TST"</code>) and the observed 
codon (<code>"THT"</code>).
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+observedMutations">observedMutations</a> for counting the number of observed mutations 
in a <code>data.frame</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use an entry in the example data for input and germline sequence
data(ExampleDb, package="alakazam")
in_seq &lt;- ExampleDb[["sequence_alignment"]][100]
germ_seq &lt;-  ExampleDb[["germline_alignment_d_mask"]][100]

# Identify all mutations in the sequence
ex1_raw &lt;- calcObservedMutations(in_seq, germ_seq, returnRaw=TRUE)
# Count all mutations in the sequence
ex1_count &lt;- calcObservedMutations(in_seq, germ_seq, returnRaw=FALSE)
ex1_freq &lt;- calcObservedMutations(in_seq, germ_seq, returnRaw=FALSE, frequency=TRUE)
# Compare this with ex1_count
table(ex1_raw$pos$region, ex1_raw$pos$r)[, "1"]
table(ex1_raw$pos$region, ex1_raw$pos$s)[, "1"]
# Compare this with ex1_freq
table(ex1_raw$pos$region, ex1_raw$pos$r)[, "1"]/ex1_raw$nonN
table(ex1_raw$pos$region, ex1_raw$pos$s)[, "1"]/ex1_raw$nonN

# Identify only mutations the V segment minus CDR3
ex2_raw &lt;- calcObservedMutations(in_seq, germ_seq, 
                                regionDefinition=IMGT_V, returnRaw=TRUE)
# Count only mutations the V segment minus CDR3
ex2_count &lt;- calcObservedMutations(in_seq, germ_seq, 
                                  regionDefinition=IMGT_V, returnRaw=FALSE)
ex2_freq &lt;- calcObservedMutations(in_seq, germ_seq, 
                                 regionDefinition=IMGT_V, returnRaw=FALSE,
                                 frequency=TRUE)
# Compare this with ex2_count
table(ex2_raw$pos$region, ex2_raw$pos$r)[, "1"]
table(ex2_raw$pos$region, ex2_raw$pos$s)[, "1"]                              
# Compare this with ex2_freq
table(ex2_raw$pos$region, ex2_raw$pos$r)[, "1"]/ex2_raw$nonN     
table(ex2_raw$pos$region, ex2_raw$pos$s)[, "1"]/ex2_raw$nonN                                       

# Identify mutations by change in hydropathy class
ex3_raw &lt;- calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,
                                mutationDefinition=HYDROPATHY_MUTATIONS, 
                                returnRaw=TRUE)
# Count mutations by change in hydropathy class
ex3_count &lt;- calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,
                                  mutationDefinition=HYDROPATHY_MUTATIONS, 
                                  returnRaw=FALSE)
ex3_freq &lt;- calcObservedMutations(in_seq, germ_seq, regionDefinition=IMGT_V,
                                 mutationDefinition=HYDROPATHY_MUTATIONS, 
                                 returnRaw=FALSE, frequency=TRUE)
# Compre this with ex3_count
table(ex3_raw$pos$region, ex3_raw$pos$r)[, "1"]
table(ex3_raw$pos$region, ex3_raw$pos$s)[, "1"]
# Compare this with ex3_freq
table(ex3_raw$pos$region, ex3_raw$pos$r)[, "1"]/ex3_raw$nonN                                        
table(ex3_raw$pos$region, ex3_raw$pos$s)[, "1"]/ex3_raw$nonN                                        
                                
</code></pre>

<hr>
<h2 id='calcTargetingDistance'>Calculates a 5-mer distance matrix from a TargetingModel object</h2><span id='topic+calcTargetingDistance'></span>

<h3>Description</h3>

<p><code>calcTargetingDistance</code> converts either the targeting rates in a <code>TargetingModel</code>
model to a matrix of 5-mer to single-nucleotide mutation distances, or the substitution 
rates in a 1-mer substitution model to a symmetric distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcTargetingDistance(model, places = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcTargetingDistance_+3A_model">model</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object with mutation likelihood information, or
a 4x4 1-mer substitution matrix normalized by row with rownames and 
colnames consisting of &quot;A&quot;, &quot;T&quot;, &quot;G&quot;, and &quot;C&quot;.</p>
</td></tr>
<tr><td><code id="calcTargetingDistance_+3A_places">places</code></td>
<td>
<p>decimal places to round distances to.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The targeting model is transformed into a distance matrix by:
</p>

<ol>
<li><p>  Converting the likelihood of being mutated <code class="reqn">p=mutability*substitution</code> to 
distance <code class="reqn">d=-log10(p)</code>.
</p>
</li>
<li><p>  Dividing this distance by the mean of the distances.
</p>
</li>
<li><p>  Converting all infinite, no change (e.g., A-&gt;A), and NA distances to 
zero.
</p>
</li></ol>

<p>The 1-mer substitution matrix is transformed into a distance matrix by:
</p>

<ol>
<li><p>  Symmetrize the 1-mer substitution matrix.
</p>
</li>
<li><p>  Converting the rates to distance <code class="reqn">d=-log10(p)</code>.
</p>
</li>
<li><p>  Dividing this distance by the mean of the distances.
</p>
</li>
<li><p>  Converting all infinite, no change (e.g., A -&gt; A), and NA distances to 
zero.
</p>
</li></ol>



<h3>Value</h3>

<p>For input of <a href="#topic+TargetingModel">TargetingModel</a>, a matrix of distances for each 5-mer motif with 
rows names defining the center nucleotide and column names defining the 5-mer 
nucleotide sequence. For input of 1-mer substitution matrix, a 4x4 symmetric distance
matrix.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+TargetingModel">TargetingModel</a> for this class of objects and
<a href="#topic+createTargetingModel">createTargetingModel</a> for building one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Calculate targeting distance of HH_S5F
dist &lt;- calcTargetingDistance(HH_S5F)

# Calculate targeting distance of HH_S1F
dist &lt;- calcTargetingDistance(HH_S1F)

</code></pre>

<hr>
<h2 id='calculateMutability'>Calculate total mutability</h2><span id='topic+calculateMutability'></span>

<h3>Description</h3>

<p><code>calculateMutability</code> calculates the total (summed) mutability for a set of sequences 
based on a 5-mer nucleotide mutability model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateMutability(sequences, model = HH_S5F, progress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculateMutability_+3A_sequences">sequences</code></td>
<td>
<p>character vector of sequences.</p>
</td></tr>
<tr><td><code id="calculateMutability_+3A_model">model</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object with mutation likelihood information.</p>
</td></tr>
<tr><td><code id="calculateMutability_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> print a progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with a total mutability score for each sequence.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")

# Calculate mutability of germline sequences using \link{HH_S5F} model
mutability &lt;- calculateMutability(sequences=db[["germline_alignment_d_mask"]], model=HH_S5F)


</code></pre>

<hr>
<h2 id='collapseClones'>Constructs effective clonal sequences for all clones</h2><span id='topic+collapseClones'></span>

<h3>Description</h3>

<p><code>collapseClones</code> creates effective input and germline sequences for each clonal 
group and appends columns containing the consensus sequences to the input 
<code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseClones(
  db,
  cloneColumn = "clone_id",
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  muFreqColumn = NULL,
  regionDefinition = NULL,
  method = c("mostCommon", "thresholdedFreq", "catchAll", "mostMutated", "leastMutated"),
  minimumFrequency = NULL,
  includeAmbiguous = FALSE,
  breakTiesStochastic = FALSE,
  breakTiesByColumns = NULL,
  expandedDb = FALSE,
  nproc = 1,
  juncLengthColumn = "junction_length",
  fields = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collapseClones_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data. Required.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_clonecolumn">cloneColumn</code></td>
<td>
<p><code>character</code> name of the column containing clonal 
identifiers. Required.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p><code>character</code> name of the column containing input 
sequences. Required. The length of each input sequence should 
match that of its corresponding germline sequence.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p><code>character</code> name of the column containing germline 
sequences. Required. The length of each germline sequence 
should match that of its corresponding input sequence.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_mufreqcolumn">muFreqColumn</code></td>
<td>
<p><code>character</code> name of the column containing mutation
frequency. Optional. Applicable to the <code>"mostMutated"</code>
and <code>"leastMutated"</code> methods. If not supplied, mutation
frequency is computed by calling <code>observedMutations</code>.
Default is <code>NULL</code>. See Cautions for note on usage.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences. Optional. Default is 
<code>NULL</code>.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_method">method</code></td>
<td>
<p>method for calculating input consensus sequence. Required. 
One of <code>"thresholdedFreq"</code>, <code>"mostCommon"</code>, 
<code>"catchAll"</code>, <code>"mostMutated"</code>, or 
<code>"leastMutated"</code>. See &quot;Methods&quot; for details.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_minimumfrequency">minimumFrequency</code></td>
<td>
<p>frequency threshold for calculating input consensus sequence.
Applicable to and required for the <code>"thresholdedFreq"</code> 
method. A canonical choice is 0.6. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_includeambiguous">includeAmbiguous</code></td>
<td>
<p>whether to use ambiguous characters to represent positions 
at which there are multiple characters with frequencies that 
are at least <code>minimumFrequency</code> or that are maximal 
(i.e. ties). Applicable to and required for the 
<code>"thresholdedFreq"</code> and <code>"mostCommon"</code> methods. 
Default is <code>FALSE</code>. See &quot;Choosing ambiguous characters&quot; 
for rules on choosing ambiguous characters.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_breaktiesstochastic">breakTiesStochastic</code></td>
<td>
<p>In case of ties, whether to randomly pick a sequence from 
sequences that fulfill the criteria as consensus. Applicable 
to and required for all methods except for <code>"catchAll"</code>. 
Default is <code>FALSE</code>. See &quot;Methods&quot; for details.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_breaktiesbycolumns">breakTiesByColumns</code></td>
<td>
<p>A list of the form 
<code>list(c(col_1, col_2, ...), c(fun_1, fun_2, ...))</code>, 
where <code>col_i</code> is a <code>character</code> name of a column 
in <code>db</code>, and <code>fun_i</code> is a function to be applied 
on that column. Currently, only <code>max</code> and <code>min</code> 
are supported. Note that the two <code>c()</code>'s in <code>list()</code> 
are essential (i.e. if there is only 1 column, the list should 
be of the form <code>list(c(col_1), c(func_1))</code>. Applicable 
to and optional for the <code>"mostMutated"</code> and 
<code>"leastMutated"</code> methods. If supplied, <code>fun_i</code>'s 
are applied on <code>col_i</code>'s to help break ties. Default 
is <code>NULL</code>. See &quot;Methods&quot; for details.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_expandeddb">expandedDb</code></td>
<td>
<p><code>logical</code> indicating whether or not to return the 
expanded <code>db</code>, containing all the sequences (as opposed
to returning just one sequence per clone).</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to distribute the operation over. If the 
<code>cluster</code> has already been set earlier, then pass the 
<code>cluster</code>. This will ensure that it is not reset.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_junclengthcolumn">juncLengthColumn</code></td>
<td>
<p><code>character</code> name of the column containing the junction length.
Needed when <code>regionDefinition</code> includes CDR3 and FWR4.</p>
</td></tr>
<tr><td><code id="collapseClones_+3A_fields">fields</code></td>
<td>
<p>additional fields used for grouping. Use sample_id, to
avoid combining sequences with the same clone_id 
that belong to different sample_id.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified <code>db</code> with the following additional columns: 
</p>

<ul>
<li> <p><code>clonal_sequence</code>:  effective sequence for the clone.
</p>
</li>
<li> <p><code>clonal_germline</code>:  germline sequence for the clone.
</p>
</li>
<li> <p><code>clonal_sequence_mufreq</code>:  mutation frequency of 
<code>clonal_sequence</code>; only added for the <code>"mostMutated"</code>
and <code>"leastMutated"</code> methods.
</p>
</li></ul>

<p><code>clonal_sequence</code> is generated with the method of choice indicated 
by <code>method</code>, and <code>clonal_germline</code> is generated with the 
<code>"mostCommon"</code> method, along with, where applicable, user-defined 
parameters such as <code>minimumFrequency</code>, <code>includeAmbiguous</code>, 
<code>breakTiesStochastic</code>, and <code>breakTiesByColumns</code>.
</p>


<h3>Consensus lengths</h3>

<p>For each clone, <code>clonal_sequence</code> and 
<code>clonal_germline</code> have the same length. 
</p>

<ul>
<li><p> For the <code>"thresholdedFreq"</code>, <code>"mostCommon"</code>, and 
<code>"catchAll"</code> methods:
</p>
<p>The length of the consensus sequences is determined by the longest possible
consensus sequence (baesd on <code>inputSeq</code> and <code>germlineSeq</code>) and 
<code>regionDefinition@seqLength</code> (if supplied), whichever is shorter.
</p>
<p>Given a set of sequences of potentially varying lengths, the longest possible 
length of their consensus sequence is taken to be the longest length along 
which there is information contained at every nucleotide position across 
majority of the sequences. Majority is defined to be greater than 
<code>floor(n/2)</code>, where <code>n</code> is the number of sequences. If the longest 
possible consensus length is 0, there will be a warning and an empty string 
(<code>""</code>) will be returned. 
</p>
<p>If a length limit is defined by supplying a <code>regionDefinition</code> via 
<code>regionDefinition@seqLength</code>, the consensus length will be further 
restricted to the shorter of the longest possible length and 
<code>regionDefinition@seqLength</code>.
</p>
</li>
<li><p> For the <code>"mostMutated"</code> and <code>"leastMutated"</code> methods:
</p>
<p>The length of the consensus sequences depends on that of the most/least 
mutated input sequence, and, if supplied, the length limit defined by 
<code>regionDefinition@seqLength</code>, whichever is shorter. If the germline 
consensus computed using the <code>"mostCommon"</code> method is longer than 
the most/least mutated input sequence, the germline consensus is trimmed 
to be of the same length as the input consensus.
</p>
</li></ul>



<h3>Methods</h3>

<p>The descriptions below use &quot;sequences&quot; as a generalization of input 
sequences and germline sequences. 
</p>

<ul>
<li> <p><code>method="thresholdedFreq"</code>
</p>
<p>A threshold must be supplied to the argument <code>minimumFrequency</code>. At 
each position along the length of the consensus sequence, the frequency 
of each nucleotide/character across sequences is tabulated. The 
nucleotide/character whose frequency is at least (i.e. <code>&gt;=</code>) 
<code>minimumFrequency</code> becomes the consensus; if there is none, the
consensus nucleotide will be <code>"N"</code>.
</p>
<p>When there are ties (frequencies of multiple nucleotides/characters 
are at least <code>minimumFrequency</code>), this method can be deterministic 
or stochastic, depending on additional parameters.
</p>

<ul>
<li><p> With <code>includeAmbiguous=TRUE</code>, ties are resolved 
deterministically by representing ties using ambiguous 
characters. See &quot;Choosing ambiguous characters&quot; for how 
ambiguous characters are chosen.
</p>
</li>
<li><p> With <code>breakTiesStochastic=TRUE</code>, ties are resolved 
stochastically by randomly picking a character amongst the 
ties.
</p>
</li>
<li><p> When both <code>TRUE</code>, <code>includeAmbiguous</code> takes 
precedence over <code>breakTiesStochastic</code>.
</p>
</li>
<li><p> When both <code>FALSE</code>, the first character from the ties is 
taken to be the consensus following the order of <code>"A"</code>, 
<code>"T"</code>, <code>"G"</code>, <code>"C"</code>, <code>"N"</code>, <code>"."</code>, 
and <code>"-"</code>.
</p>
</li></ul>

<p>Below are some examples looking at a single position based on 5 
sequences with <code>minimumFrequency=0.6</code>, 
<code>includeAmbiguous=FALSE</code>, and <code>breakTiesStochastic=FALSE</code>:
</p>

<ul>
<li><p> If the sequences have <code>"A"</code>, <code>"A"</code>, <code>"A"</code>, 
<code>"T"</code>, <code>"C"</code>, the consensus will be <code>"A"</code>, 
because <code>"A"</code> has frequency 0.6, which is at least 
<code>minimumFrequency</code>.
</p>
</li>
<li><p> If the sequences have <code>"A"</code>, <code>"A"</code>, <code>"T"</code>, 
<code>"T"</code>, <code>"C"</code>, the consensus will be <code>"N"</code>, 
because none of <code>"A"</code>, <code>"T"</code>, or <code>"C"</code> has 
frequency that is at least <code>minimumFrequency</code>.
</p>
</li></ul>

</li>
<li> <p><code>method="mostCommon"</code>
</p>
<p>The most frequent nucleotide/character across sequences at each 
position along the length of the consensus sequence makes up the consensus.
</p>
<p>When there are ties (multiple nucleotides/characters with equally 
maximal frequencies), this method can be deterministic or stochastic, 
depending on additional parameters. The same rules for breaking ties 
for <code>method="thresholdedFreq"</code> apply.
</p>
<p>Below are some examples looking at a single position based on 5 
sequences with <code>includeAmbiguous=FALSE</code>, and 
<code>breakTiesStochastic=FALSE</code>:
</p>

<ul>
<li><p> If the sequences have <code>"A"</code>, <code>"A"</code>, <code>"T"</code>, 
<code>"A"</code>, <code>"C"</code>, the consensus will be <code>"A"</code>.
</p>
</li>
<li><p> If the sequences have <code>"T"</code>, <code>"T"</code>, <code>"C"</code>, 
<code>"C"</code>, <code>"G"</code>, the consensus will be <code>"T"</code>, 
because <code>"T"</code> is before <code>"C"</code> in the order of 
<code>"A"</code>, <code>"T"</code>, <code>"G"</code>, <code>"C"</code>, <code>"N"</code>, 
<code>"."</code>, and <code>"-"</code>. 
</p>
</li></ul>
       
</li>
<li> <p><code>method="catchAll"</code>
</p>
<p>This method returns a consensus sequence capturing most of the 
information contained in the sequences. Ambiguous characters are 
used where applicable. See &quot;Choosing ambiguous characters&quot; for how 
ambiguous characters are chosen. This method is deterministic and 
does not involve breaking ties.
</p>
<p>Below are some examples for <code>method="catchAll"</code> looking at a 
single position based on 5 sequences:
</p>

<ul>
<li><p> If the sequences have <code>"N"</code>, <code>"N"</code>, <code>"N"</code>, 
<code>"N"</code>, <code>"N"</code>, the consensus will be <code>"N"</code>.
</p>
</li>
<li><p> If the sequences have <code>"N"</code>, <code>"A"</code>, <code>"A"</code>, 
<code>"A"</code>, <code>"A"</code>, the consensus will be <code>"A"</code>.
</p>
</li>
<li><p> If the sequences have <code>"N"</code>, <code>"A"</code>, <code>"G"</code>, 
<code>"A"</code>, <code>"A"</code>, the consensus will be <code>"R"</code>.
</p>
</li>
<li><p> If the sequences have <code>"-"</code>, <code>"-"</code>, <code>"."</code>, 
<code>"."</code>, <code>"."</code>, the consensus will be <code>"-"</code>.
</p>
</li>
<li><p> If the sequences have <code>"-"</code>, <code>"-"</code>, <code>"-"</code>, 
<code>"-"</code>, <code>"-"</code>, the consensus will be <code>"-"</code>.
</p>
</li>
<li><p> If the sequences have <code>"."</code>, <code>"."</code>, <code>"."</code>, 
<code>"."</code>, <code>"."</code>, the consensus will be <code>"."</code>.
</p>
</li></ul>

</li>
<li> <p><code>method="mostMutated"</code> and <code>method="leastMutated"</code>
</p>
<p>These methods return the most/least mutated sequence as the consensus 
sequence. 
</p>
<p>When there are ties (multple sequences have the maximal/minimal mutation
frequency), this method can be deterministic or stochastic, depending on 
additional parameters.
</p>

<ul>
<li><p> With <code>breakTiesStochastic=TRUE</code>, ties are resolved 
stochastically by randomly picking a sequence out of 
sequences with the maximal/minimal mutation frequency.
</p>
</li>
<li><p> When <code>breakTiesByColumns</code> is supplied, ties are resolved
deterministically. Column by column, a function is applied on 
the column and sequences with column value matching the 
functional value are retained, until ties are resolved or 
columns run out. In the latter case, the first remaining 
sequence is taken as the consensus.
</p>
</li>
<li><p> When <code>breakTiesStochastic=TRUE</code> and 
<code>breakTiesByColumns</code> is also supplied, 
<code>breakTiesStochastic</code> takes precedence over 
<code>breakTiesByColumns</code>.
</p>
</li>
<li><p> When <code>breakTiesStochastic=FALSE</code> and 
<code>breakTiesByColumns</code> is not supplied (i.e. <code>NULL</code>), 
the sequence that appears first amongst the ties is taken 
as the consensus.
</p>
</li></ul>

</li></ul>



<h3>Choosing ambiguous characters</h3>

<p>Ambiguous characters may be present in the returned consensuses when using the
<code>"catchAll"</code> method and when using the <code>"thresholdedFreq"</code> or 
<code>"mostCommon"</code> methods with <code>includeAmbiguous=TRUE</code>. 
</p>
<p>The rules on choosing ambiguous characters are as follows:
</p>

<ul>
<li><p> If a position contains only <code>"N"</code> across sequences, the consensus 
at that position is <code>"N"</code>.
</p>
</li>
<li><p> If a position contains one or more of <code>"A"</code>, <code>"T"</code>, 
<code>"G"</code>, or <code>"C"</code>, the consensus will be an IUPAC character 
representing all of the characters present, regardless of whether 
<code>"N"</code>, <code>"-"</code>, or <code>"."</code> is present.
</p>
</li>
<li><p> If a position contains only <code>"-"</code> and <code>"."</code> across sequences, 
the consensus at that position is taken to be <code>"-"</code>. 
</p>
</li>
<li><p> If a position contains only one of <code>"-"</code> or <code>"."</code> across 
sequences, the consensus at that position is taken to be the character 
present. 
</p>
</li></ul>



<h3>Cautions</h3>


<ul>
<li><p>   Note that this function does not perform multiple sequence alignment. 
As a prerequisite, it is assumed that the sequences in 
<code>sequenceColumn</code> and <code>germlineColumn</code> have been aligned 
somehow. In the case of immunoglobulin repertoire analysis, this 
usually means that the sequences are IMGT-gapped.
</p>
</li>
<li><p>   When using the <code>"mostMutated"</code> and <code>"leastMutated"</code> methods, 
if you supply both <code>muFreqColumn</code> and <code>regionDefinition</code>,
it is your responsibility to ensure that the mutation frequency in
<code>muFreqColumn</code> was calculated with sequence lengths restricted 
to the <strong>same</strong> <code>regionDefinition</code> you are supplying. 
Otherwise, the &quot;most/least mutated&quot; sequence you obtain might not 
be the most/least mutated given the <code>regionDefinition</code> supplied, 
because your mutation frequency was based on a 
<code>regionDefinition</code> different from the one supplied.
</p>
</li>
<li><p>   If you intend to run <code>collapseClones</code> before 
building a 5-mer targeting model, you <strong>must</strong> choose 
parameters such that your collapsed clonal consensuses do 
<strong>not</strong> include ambiguous characters. This is because the 
targeting model functions do NOT support ambiguous characters 
in their inputs.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+IMGT_SCHEMES">IMGT_SCHEMES</a> for a set of predefined <a href="#topic+RegionDefinition">RegionDefinition</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHA", "IGHG") &amp; sample_id == "+7d" &amp;
                        clone_id %in% c("3100", "3141", "3184"))

# thresholdedFreq method, resolving ties deterministically without using ambiguous characters
clones &lt;- collapseClones(db, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="thresholdedFreq", minimumFrequency=0.6,
                         includeAmbiguous=FALSE, breakTiesStochastic=FALSE)

# mostCommon method, resolving ties deterministically using ambiguous characters
clones &lt;- collapseClones(db, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="mostCommon", 
                         includeAmbiguous=TRUE, breakTiesStochastic=FALSE)

# Make a copy of db that has a mutation frequency column
db2 &lt;- observedMutations(db, frequency=TRUE, combine=TRUE)

# mostMutated method, resolving ties stochastically
clones &lt;- collapseClones(db2, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="mostMutated", muFreqColumn="mu_freq", 
                         breakTiesStochastic=TRUE, breakTiesByColumns=NULL)
                         
# mostMutated method, resolving ties deterministically using additional columns
clones &lt;- collapseClones(db2, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="mostMutated", muFreqColumn="mu_freq", 
                         breakTiesStochastic=FALSE, 
                         breakTiesByColumns=list(c("duplicate_count"), c(max)))

# Build consensus for V segment only
# Capture all nucleotide variations using ambiguous characters 
clones &lt;- collapseClones(db, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="catchAll", regionDefinition=IMGT_V)

# Return the same number of rows as the input
clones &lt;- collapseClones(db, cloneColumn="clone_id", sequenceColumn="sequence_alignment", 
                         germlineColumn="germline_alignment_d_mask",
                         method="mostCommon", expandedDb=TRUE)

</code></pre>

<hr>
<h2 id='consensusSequence'>Construct a consensus sequence</h2><span id='topic+consensusSequence'></span>

<h3>Description</h3>

<p>Construct a consensus sequence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>consensusSequence(
  sequences,
  db = NULL,
  method = c("mostCommon", "thresholdedFreq", "catchAll", "mostMutated", "leastMutated"),
  minFreq = NULL,
  muFreqColumn = NULL,
  lenLimit = NULL,
  includeAmbiguous = FALSE,
  breakTiesStochastic = FALSE,
  breakTiesByColumns = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensusSequence_+3A_sequences">sequences</code></td>
<td>
<p>character vector of sequences.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data for a single clone.
Applicable to and required for the <code>"mostMutated"</code> and
<code>"leastMutated"</code> methods. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_method">method</code></td>
<td>
<p>method to calculate consensus sequence. One of
<code>"thresholdedFreq"</code>, <code>"mostCommon"</code>, <code>"catchAll"</code>,
<code>"mostMutated"</code>, or <code>"leastMutated"</code>. See &quot;Methods&quot; under
<a href="#topic+collapseClones">collapseClones</a> for details.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_minfreq">minFreq</code></td>
<td>
<p>frequency threshold for calculating input consensus sequence.
Applicable to and required for the <code>"thresholdedFreq"</code> method.
A canonical choice is 0.6. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_mufreqcolumn">muFreqColumn</code></td>
<td>
<p><code>character</code> name of the column in db containing mutation
frequency. Applicable to and required for the <code>"mostMutated"</code>
and <code>"leastMutated"</code> methods. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_lenlimit">lenLimit</code></td>
<td>
<p>limit on consensus length. if <code>NULL</code> then no length limit is set.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_includeambiguous">includeAmbiguous</code></td>
<td>
<p>whether to use ambiguous characters to represent positions at
which there are multiple characters with frequencies that are at least
<code>minimumFrequency</code> or that are maximal (i.e. ties). Applicable to
and required for the <code>"thresholdedFreq"</code> and <code>"mostCommon"</code>
methods. Default is <code>FALSE</code>. See &quot;Choosing ambiguous characters&quot;
under <a href="#topic+collapseClones">collapseClones</a> for rules on choosing ambiguous characters.
Note: this argument refers to the use of ambiguous nucleotides in the 
output consensus sequence. Ambiguous nucleotides in the input sequences
are allowed for methods catchAll, mostMutated and leastMutated.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_breaktiesstochastic">breakTiesStochastic</code></td>
<td>
<p>In case of ties, whether to randomly pick a sequence from sequences that
fulfill the criteria as consensus. Applicable to and required for all methods
except for <code>"catchAll"</code>. Default is <code>FALSE</code>. See &quot;Methods&quot;
under <a href="#topic+collapseClones">collapseClones</a> for details.</p>
</td></tr>
<tr><td><code id="consensusSequence_+3A_breaktiesbycolumns">breakTiesByColumns</code></td>
<td>
<p>A list of the form <code>list(c(col_1, col_2, ...), c(fun_1, fun_2, ...))</code>,
where <code>col_i</code> is a <code>character</code> name of a column in <code>db</code>,
and <code>fun_i</code> is a function to be applied on that column. Currently,
only <code>max</code> and <code>min</code> are supported. Note that the two <code>c()</code>'s
in <code>list()</code> are essential (i.e. if there is only 1 column, the list
should be of the form <code>list(c(col_1), c(func_1))</code>. Applicable to and
optional for the <code>"mostMutated"</code> and <code>"leastMutated"</code> methods.
If supplied, <code>fun_i</code>'s are applied on <code>col_i</code>'s to help break
ties. Default is <code>NULL</code>. See &quot;Methods&quot; under <a href="#topic+collapseClones">collapseClones</a>
for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="#topic+collapseClones">collapseClones</a> for detailed documentation on methods and additional parameters.
</p>


<h3>Value</h3>

<p>A list containing <code>cons</code>, which is a character string that is the consensus sequence
for <code>sequences</code>; and <code>muFreq</code>, which is the maximal/minimal mutation frequency of
the consensus sequence for the <code>"mostMutated"</code> and <code>"leastMutated"</code> methods, or
<code>NULL</code> for all other methods.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHA", "IGHG") &amp; sample_id == "+7d")
clone &lt;- subset(db, clone_id == "3192")

# First compute mutation frequency for most/leastMutated methods
clone &lt;- observedMutations(clone, frequency=TRUE, combine=TRUE)

# Manually create a tie
clone &lt;- rbind(clone, clone[which.max(clone$mu_freq), ])

# ThresholdedFreq method. 
# Resolve ties deterministically without using ambiguous characters
cons1 &lt;- consensusSequence(clone$sequence_alignment,
                           method="thresholdedFreq", minFreq=0.3,
                           includeAmbiguous=FALSE, 
                           breakTiesStochastic=FALSE)
cons1$cons
                                        
</code></pre>

<hr>
<h2 id='convertNumbering'>convertNumbering: IMGT-Kabat number conversion</h2><span id='topic+convertNumbering'></span>

<h3>Description</h3>

<p>Converts numbering systems like Kabat or IMGT using these conventions:
http://www.imgt.org/IMGTScientificChart/Numbering/IMGT-Kabat_part1.html
with Gaps (unoccupied positions) shown by &quot;G&quot; and Asterisks (*) shown by &quot;S&quot;: 
arbitrary mappings (multiple possible &quot;to&quot; values) represented with &quot;NA&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertNumbering(locus, from, to, calls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convertNumbering_+3A_locus">locus</code></td>
<td>
<p>string indicating heavy (&quot;IGH&quot;) or light chains (&quot;IGK&quot; or &quot;IGL)</p>
</td></tr>
<tr><td><code id="convertNumbering_+3A_from">from</code></td>
<td>
<p>string indicating numbering system to convert to (&quot;IMGT&quot; or &quot;KABAT&quot;)</p>
</td></tr>
<tr><td><code id="convertNumbering_+3A_to">to</code></td>
<td>
<p>string indicating original numbering system (&quot;IMGT&quot; or &quot;KABAT&quot;)</p>
</td></tr>
<tr><td><code id="convertNumbering_+3A_calls">calls</code></td>
<td>
<p>vector of strings representing original numbering</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of string indicating the corresponding numbering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>convertNumbering("IGH", "IMGT", "KABAT", c("51", "23", "110"))
convertNumbering("IGH", "KABAT", "IMGT", c("51", "23", "G"))
</code></pre>

<hr>
<h2 id='createBaseline'>Creates a Baseline object</h2><span id='topic+createBaseline'></span>

<h3>Description</h3>

<p><code>createBaseline</code> creates and initialize a <code>Baseline</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createBaseline(
  description = "",
  db = data.frame(),
  regionDefinition = createRegionDefinition(),
  testStatistic = "",
  regions = NULL,
  numbOfSeqs = matrix(),
  binomK = matrix(),
  binomN = matrix(),
  binomP = matrix(),
  pdfs = list(),
  stats = data.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createBaseline_+3A_description">description</code></td>
<td>
<p><code>character</code> providing general information regarding the 
sequences, selection analysis and/or object.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing annotation information about 
the sequences and selection results.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_teststatistic">testStatistic</code></td>
<td>
<p><code>character</code> indicating the statistical framework 
used to test for selection. For example, <code>"local"</code> or 
<code>"focused"</code> or <code>"imbalanced"</code>.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_regions">regions</code></td>
<td>
<p><code>character</code> vector defining the regions the BASELINe 
analysis was carried out on. For <code>"cdr"</code> and <code>"fwr"</code> 
or <code>"cdr1"</code>, <code>"cdr2"</code>, <code>"cdr3"</code>, etc. If <code>NULL</code>
then regions will be determined automatically from <code>regionDefinition</code>.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_numbofseqs">numbOfSeqs</code></td>
<td>
<p><code>matrix</code> of dimensions <code>r x c</code> containing the number of 
sequences or PDFs in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_binomk">binomK</code></td>
<td>
<p><code>matrix</code> of dimensions <code>r x c</code> containing the number of 
successes in the binomial trials in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_binomn">binomN</code></td>
<td>
<p><code>matrix</code> of dimensions <code>r x c</code> containing the total 
number of trials in the binomial in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_binomp">binomP</code></td>
<td>
<p><code>matrix</code> of dimensions <code>r x c</code> containing the probability 
of success in one binomial trial in each region, where:<br />
<code>r</code> = number of rows = number of groups or sequences.<br />
<code>c</code> = number of columns = number of regions.</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_pdfs">pdfs</code></td>
<td>
<p><code>list</code> of matrices containing PDFs with one item for each 
defined region (e.g. <code>cdr</code> and <code>fwr</code>). Matrices have dimensions
<code>r x c</code> dementions, where:<br />
<code>r</code> = number of rows = number of sequences or groups. <br />
<code>c</code> = number of columns = length of the PDF (default 4001).</p>
</td></tr>
<tr><td><code id="createBaseline_+3A_stats">stats</code></td>
<td>
<p><code>data.frame</code> of BASELINe statistics, 
including: mean selection strength (mean Sigma), 95% confidence 
intervals, and p-values with positive signs for the presence of 
positive selection and/or p-values with negative signs for the
presence of negative selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create and initialize a <code>Baseline</code> object. 
</p>
<p>The <code>testStatistic</code> indicates the statistical framework used to test for selection. 
For example,
</p>

<ul>
<li>   <p><code>local</code> = CDR_R / (CDR_R + CDR_S).
</p>
</li>
<li>   <p><code>focused</code> = CDR_R / (CDR_R + CDR_S + FWR_S).
</p>
</li>
<li>   <p><code>immbalance</code> = CDR_R + CDR_s / (CDR_R + CDR_S + FWR_S + FWR_R)
</p>
</li></ul>

<p>For <code>focused</code> the <code>regionDefinition</code> must only contain two regions. If more 
than two regions are defined, then the <code>local</code> test statistic will be used.
For further information on the frame of these tests see Uduman et al. (2011).
</p>


<h3>Value</h3>

<p>A <code>Baseline</code> object.
</p>


<h3>References</h3>


<ol>
<li><p>  Hershberg U, et al. Improved methods for detecting selection by mutation 
analysis of Ig V region sequences. 
Int Immunol. 2008 20(5):683-94.
</p>
</li>
<li><p>  Uduman M, et al. Detecting selection in immunoglobulin sequences. 
Nucleic Acids Res. 2011 39(Web Server issue):W499-504.
</p>
</li>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based
on synonymous mutations from high-throughput immunoglobulin sequencing data.
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+Baseline">Baseline</a> for the return object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates an empty Baseline object
createBaseline()

</code></pre>

<hr>
<h2 id='createMutabilityMatrix'>Builds a mutability model</h2><span id='topic+createMutabilityMatrix'></span>

<h3>Description</h3>

<p><code>createMutabilityMatrix</code> builds a 5-mer nucleotide mutability model by counting 
the number of mutations occuring in the center position for all 5-mer motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMutabilityMatrix(
  db,
  substitutionModel,
  model = c("s", "rs"),
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  vCallColumn = "v_call",
  multipleMutation = c("independent", "ignore"),
  minNumSeqMutations = 500,
  numSeqMutationsOnly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createMutabilityMatrix_+3A_db">db</code></td>
<td>
<p>data.frame containing sequence data.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_substitutionmodel">substitutionModel</code></td>
<td>
<p>matrix of 5-mer substitution rates built by 
<a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>. Note, this model will
only impact mutability scores when <code>model="s"</code>
(using only silent mutations).</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_model">model</code></td>
<td>
<p>type of model to create. The default model, &quot;s&quot;, 
builds a model by counting only silent mutations. <code>model="s"</code>
should be used for data that includes functional sequences.
Setting <code>model="rs"</code> creates a model by counting both 
replacement and silent mutations and may be used on fully 
non-functional sequence data sets.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped sample sequences.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_vcallcolumn">vCallColumn</code></td>
<td>
<p>name of the column containing the V-segment allele call.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_multiplemutation">multipleMutation</code></td>
<td>
<p>string specifying how to handle multiple mutations occuring 
within the same 5-mer. If <code>"independent"</code> then multiple 
mutations within the same 5-mer are counted indepedently. 
If <code>"ignore"</code> then 5-mers with multiple mutations are 
excluded from the total mutation tally.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_minnumseqmutations">minNumSeqMutations</code></td>
<td>
<p>minimum number of mutations in sequences containing each 5-mer
to compute the mutability rates. If the number is smaller 
than this threshold, the mutability for the 5-mer will be 
inferred. Default is 500. Not required if 
<code>numSeqMutationsOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code id="createMutabilityMatrix_+3A_numseqmutationsonly">numSeqMutationsOnly</code></td>
<td>
<p>when <code>TRUE</code>, return only a vector counting the number of 
observed mutations in sequences containing each 5-mer. This 
option can be used for parameter tuning for <code>minNumSeqMutations</code> 
during preliminary analysis using <a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>. 
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Caution: The targeting model functions do NOT support ambiguous 
characters in their inputs. You MUST make sure that your input and germline
sequences do NOT contain ambiguous characters (especially if they are 
clonal consensuses returned from <code>collapseClones</code>).</strong>
</p>


<h3>Value</h3>

<p>When <code>numSeqMutationsOnly</code> is <code>FALSE</code>, a <code>MutabilityModel</code> containing a
named numeric vector of 1024 normalized mutability rates for each 5-mer motif with names 
defining the 5-mer nucleotide sequence.
</p>
<p>When <code>numSeqMutationsOnly</code> is <code>TRUE</code>, a named numeric
vector of length 1024 counting the number of observed mutations in sequences containing 
each 5-mer.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+MutabilityModel">MutabilityModel</a>, <a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a>, <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>, 
<a href="#topic+createTargetingMatrix">createTargetingMatrix</a>, <a href="#topic+createTargetingModel">createTargetingModel</a>,
<a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to 50 sequences of one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")[1:50,]

# Create model using only silent mutations
sub_model &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                      germlineColumn="germline_alignment_d_mask",
                                      vCallColumn="v_call",model="s")
mut_model &lt;- createMutabilityMatrix(db, sub_model, model="s", 
                                    sequenceColumn="sequence_alignment",
                                    germlineColumn="germline_alignment_d_mask",
                                    vCallColumn="v_call",
                                    minNumSeqMutations=200,
                                    numSeqMutationsOnly=FALSE)
                                    
# View top 5 mutability estimates
head(sort(mut_model, decreasing=TRUE), 5)

# View the number of S mutations used for estimating mutabilities
mut_model@numMutS

# Count the number of mutations in sequences containing each 5-mer
mut_count &lt;- createMutabilityMatrix(db, sub_model, model="s", 
                                    sequenceColumn="sequence_alignment",
                                    germlineColumn="germline_alignment_d_mask",
                                    vCallColumn="v_call",
                                    numSeqMutationsOnly=TRUE)


</code></pre>

<hr>
<h2 id='createMutationDefinition'>Creates a MutationDefinition</h2><span id='topic+createMutationDefinition'></span>

<h3>Description</h3>

<p><code>createMutationDefinition</code> creates a <code>MutationDefinition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createMutationDefinition(name, classes, description = "", citation = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createMutationDefinition_+3A_name">name</code></td>
<td>
<p>name of the mutation definition.</p>
</td></tr>
<tr><td><code id="createMutationDefinition_+3A_classes">classes</code></td>
<td>
<p>named character vectors with single-letter amino acid codes as names
and amino acid classes as values, with <code>NA</code> assigned to set of 
characters <code>c("X", "*", "-", ".")</code>. Replacement (R) is be 
defined as a change in amino acid class and silent (S) as no 
change in class.</p>
</td></tr>
<tr><td><code id="createMutationDefinition_+3A_description">description</code></td>
<td>
<p>description of the mutation definition and its source data.</p>
</td></tr>
<tr><td><code id="createMutationDefinition_+3A_citation">citation</code></td>
<td>
<p>publication source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MutationDefinition</code> object.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+MutationDefinition">MutationDefinition</a> for the return object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define hydropathy classes
suppressPackageStartupMessages(library(alakazam))
hydropathy &lt;- list(hydrophobic=c("A", "I", "L", "M", "F", "W", "V"),
                   hydrophilic=c("R", "N", "D", "C", "Q", "E", "K"),
                   neutral=c("G", "H", "P", "S", "T", "Y"))
chars &lt;- unlist(hydropathy, use.names=FALSE)
classes &lt;- setNames(translateStrings(chars, hydropathy), chars)

# Create hydropathy mutation definition
md &lt;- createMutationDefinition("Hydropathy", classes)

</code></pre>

<hr>
<h2 id='createRegionDefinition'>Creates a RegionDefinition</h2><span id='topic+createRegionDefinition'></span>

<h3>Description</h3>

<p><code>createRegionDefinition</code> creates a <code>RegionDefinition</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createRegionDefinition(
  name = "",
  boundaries = factor(),
  description = "",
  citation = ""
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createRegionDefinition_+3A_name">name</code></td>
<td>
<p>name of the region definition.</p>
</td></tr>
<tr><td><code id="createRegionDefinition_+3A_boundaries">boundaries</code></td>
<td>
<p><code>factor</code> defining the region boundaries of the sequence.
The levels and values of <code>boundaries</code> determine the 
number of regions (e.g. CDR and FWR).</p>
</td></tr>
<tr><td><code id="createRegionDefinition_+3A_description">description</code></td>
<td>
<p>description of the region definition and its source data.</p>
</td></tr>
<tr><td><code id="createRegionDefinition_+3A_citation">citation</code></td>
<td>
<p>publication source.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RegionDefinition</code> object.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+RegionDefinition">RegionDefinition</a> for the return object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Creates an empty RegionDefinition object
createRegionDefinition()

</code></pre>

<hr>
<h2 id='createSubstitutionMatrix'>Builds a substitution model</h2><span id='topic+createSubstitutionMatrix'></span>

<h3>Description</h3>

<p><code>createSubstitutionMatrix</code> builds a 5-mer nucleotide substitution model by counting 
the number of substitution mutations occuring in the center position for all 5-mer 
motifs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSubstitutionMatrix(
  db,
  model = c("s", "rs"),
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  vCallColumn = "v_call",
  multipleMutation = c("independent", "ignore"),
  returnModel = c("5mer", "1mer", "1mer_raw"),
  minNumMutations = 50,
  numMutationsOnly = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSubstitutionMatrix_+3A_db">db</code></td>
<td>
<p>data.frame containing sequence data.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_model">model</code></td>
<td>
<p>type of model to create. The default model, &quot;s&quot;, 
builds a model by counting only silent mutations. <code>model="s"</code>
should be used for data that includes functional sequences.
Setting <code>model="rs"</code> creates a model by counting both 
replacement and silent mutations and may be used on fully 
non-functional sequence data sets.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped sample sequences.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_vcallcolumn">vCallColumn</code></td>
<td>
<p>name of the column containing the V-segment allele call.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_multiplemutation">multipleMutation</code></td>
<td>
<p>string specifying how to handle multiple mutations occuring 
within the same 5-mer. If <code>"independent"</code> then multiple 
mutations within the same 5-mer are counted indepedently. 
If <code>"ignore"</code> then 5-mers with multiple mutations are 
excluded from the total mutation tally.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_returnmodel">returnModel</code></td>
<td>
<p>string specifying what type of model to return; one of
<code>c("5mer", "1mer", "1mer_raw")</code>. If <code>"5mer"</code> 
(the default) then a 5-mer nucleotide context model is 
returned. If <code>"1mer"</code> or <code>"1mer_raw"</code> then a single 
nucleotide substitution matrix (no context) is returned;
where <code>"1mer_raw"</code> is the unnormalized version of the 
<code>"1mer"</code> model. Note, neither 1-mer model may be used
as input to <a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_minnummutations">minNumMutations</code></td>
<td>
<p>minimum number of mutations required to compute the 5-mer 
substitution rates. If the number of mutations for a 5-mer
is below this threshold, its substitution rates will be 
estimated from neighboring 5-mers. Default is 50. 
Not required if <code>numMutationsOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code id="createSubstitutionMatrix_+3A_nummutationsonly">numMutationsOnly</code></td>
<td>
<p>when <code>TRUE</code>, return counting information on the number
of mutations for each 5-mer, instead of building a substitution
matrix. This option can be used for parameter tuning for 
<code>minNumMutations</code> during preliminary analysis. 
Default is <code>FALSE</code>. Only applies when <code>returnModel</code> 
is set to <code>"5mer"</code>. The <code>data.frame</code> returned when
this argument is <code>TRUE</code> can serve as the input for
<a href="#topic+minNumMutationsTune">minNumMutationsTune</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Caution: The targeting model functions do NOT support ambiguous 
characters in their inputs. You MUST make sure that your input and germline
sequences do NOT contain ambiguous characters (especially if they are
clonal consensuses returned from <code>collapseClones</code>).</strong>
</p>


<h3>Value</h3>

<p>For <code>returnModel = "5mer"</code>: 
</p>
<p>When <code>numMutationsOnly</code> is <code>FALSE</code>, a 4x1024 matrix of column 
normalized substitution rates for each 5-mer motif with row names defining 
the center nucleotide, one of <code>c("A", "C", "G", "T")</code>, and column names 
defining the 5-mer nucleotide sequence. 
</p>
<p>When <code>numMutationsOnly</code> is 
<code>TRUE</code>, a 1024x4 data frame with each row providing information on 
counting the number of mutations for a 5-mer. Columns are named 
<code>fivemer.total</code>, <code>fivemer.every</code>, <code>inner3.total</code>, and
<code>inner3.every</code>, corresponding to, respectively,
the total number of mutations when counted as a 5-mer, 
whether there is mutation to every other base when counted as a 5-mer,
the total number of mutations when counted as an inner 3-mer, and
whether there is mutation to every other base when counted as an inner 3-mer.
</p>
<p>For <code>returnModel = "1mer"</code> or <code>"1mer_raw"</code>:
a 4x4 normalized or un-normalized 1-mer substitution matrix respectively.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>, <a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>, 
<a href="#topic+createTargetingMatrix">createTargetingMatrix</a>, <a href="#topic+createTargetingModel">createTargetingModel</a>,
<a href="#topic+minNumMutationsTune">minNumMutationsTune</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")[1:25,]

# Count the number of mutations per 5-mer
subCount &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                     germlineColumn="germline_alignment_d_mask",
                                     vCallColumn="v_call",
                                     model="s", multipleMutation="independent",
                                     returnModel="5mer", numMutationsOnly=TRUE)

# Create model using only silent mutations
sub &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                germlineColumn="germline_alignment_d_mask",
                                vCallColumn="v_call",
                                model="s", multipleMutation="independent",
                                returnModel="5mer", numMutationsOnly=FALSE,
                                minNumMutations=20)


</code></pre>

<hr>
<h2 id='createTargetingMatrix'>Calculates a targeting rate matrix</h2><span id='topic+createTargetingMatrix'></span>

<h3>Description</h3>

<p><code>createTargetingMatrix</code> calculates the targeting model matrix as the
combined probability of mutability and substitution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTargetingMatrix(substitutionModel, mutabilityModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTargetingMatrix_+3A_substitutionmodel">substitutionModel</code></td>
<td>
<p>matrix of 5-mers substitution rates built by 
<a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a> or 
<a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>.</p>
</td></tr>
<tr><td><code id="createTargetingMatrix_+3A_mutabilitymodel">mutabilityModel</code></td>
<td>
<p>vector of 5-mers mutability rates built by 
<a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a> or 
<a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targeting rates are calculated by multiplying the normalized mutability rate by the 
normalized substitution rates for each individual 5-mer.
</p>


<h3>Value</h3>

<p>A <code>TargetingMatrix</code> with the same dimensions as the input <code>substitutionModel</code> 
containing normalized targeting probabilities for each 5-mer motif with 
row names defining the center nucleotide and column names defining the 
5-mer nucleotide sequence. 
</p>
<p>If the input <code>mutabilityModel</code> is of class <code>MutabilityModel</code>, then the output 
<code>TargetingMatrix</code> will carry over the input <code>numMutS</code> and <code>numMutR</code> slots.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based
on synonymous mutations from high-throughput immunoglobulin sequencing data.
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>, <a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>, 
<a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>, <a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a>, 
<a href="#topic+TargetingMatrix">TargetingMatrix</a>, <a href="#topic+createTargetingModel">createTargetingModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to 50 sequences, of one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")[1:50,]

# Create 4x1024 models using only silent mutations
sub_model &lt;- createSubstitutionMatrix(db, model="s", sequenceColumn="sequence_alignment",
                                      germlineColumn="germline_alignment_d_mask",
                                      vCallColumn="v_call")
mut_model &lt;- createMutabilityMatrix(db, sub_model, model="s",
                                    sequenceColumn="sequence_alignment",
                                    germlineColumn="germline_alignment_d_mask",
                                    vCallColumn="v_call")

# Extend substitution and mutability to including Ns (5x3125 model)
sub_model &lt;- extendSubstitutionMatrix(sub_model)
mut_model &lt;- extendMutabilityMatrix(mut_model)

# Create targeting model from substitution and mutability
tar_model &lt;- createTargetingMatrix(sub_model, mut_model)


</code></pre>

<hr>
<h2 id='createTargetingModel'>Creates a TargetingModel</h2><span id='topic+createTargetingModel'></span>

<h3>Description</h3>

<p><code>createTargetingModel</code> creates a 5-mer <code>TargetingModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTargetingModel(
  db,
  model = c("s", "rs"),
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  vCallColumn = "v_call",
  multipleMutation = c("independent", "ignore"),
  minNumMutations = 50,
  minNumSeqMutations = 500,
  modelName = "",
  modelDescription = "",
  modelSpecies = "",
  modelCitation = "",
  modelDate = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createTargetingModel_+3A_db">db</code></td>
<td>
<p>data.frame containing sequence data.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_model">model</code></td>
<td>
<p>type of model to create. The default model, &quot;s&quot;, 
builds a model by counting only silent mutations. <code>model="s"</code>
should be used for data that includes functional sequences.
Setting <code>model="rs"</code> creates a model by counting both 
replacement and silent mutations and may be used on fully 
non-functional sequence data sets.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped sample sequences.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_vcallcolumn">vCallColumn</code></td>
<td>
<p>name of the column containing the V-segment allele calls.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_multiplemutation">multipleMutation</code></td>
<td>
<p>string specifying how to handle multiple mutations occuring 
within the same 5-mer. If <code>"independent"</code> then multiple 
mutations within the same 5-mer are counted indepedently. 
If <code>"ignore"</code> then 5-mers with multiple mutations are 
excluded from the otal mutation tally.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_minnummutations">minNumMutations</code></td>
<td>
<p>minimum number of mutations required to compute the 5-mer 
substitution rates. If the number of mutations for a 5-mer
is below this threshold, its substitution rates will be 
estimated from neighboring 5-mers. Default is 50.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_minnumseqmutations">minNumSeqMutations</code></td>
<td>
<p>minimum number of mutations in sequences containing each 5-mer
to compute the mutability rates. If the number is smaller 
than this threshold, the mutability for the 5-mer will be 
inferred. Default is 500.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_modelname">modelName</code></td>
<td>
<p>name of the model.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_modeldescription">modelDescription</code></td>
<td>
<p>description of the model and its source data.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_modelspecies">modelSpecies</code></td>
<td>
<p>genus and species of the source sequencing data.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_modelcitation">modelCitation</code></td>
<td>
<p>publication source.</p>
</td></tr>
<tr><td><code id="createTargetingModel_+3A_modeldate">modelDate</code></td>
<td>
<p>date the model was built. If <code>NULL</code> the current date
will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Caution: The targeting model functions do NOT support ambiguous 
characters in their inputs. You MUST make sure that your input and germline
sequences do NOT contain ambiguous characters (especially if they are
clonal consensuses returned from <code>collapseClones</code>).</strong>
</p>


<h3>Value</h3>

<p>A <a href="#topic+TargetingModel">TargetingModel</a> object.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based
on synonymous mutations from high-throughput immunoglobulin sequencing data.
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+TargetingModel">TargetingModel</a> for the return object. 
See <a href="#topic+plotMutability">plotMutability</a> plotting a mutability model.
See <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>, <a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>, 
<a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>, <a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a> and 
<a href="#topic+createTargetingMatrix">createTargetingMatrix</a> for component steps in building a model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")[1:80,]

# Create model using only silent mutations and ignore multiple mutations
model &lt;- createTargetingModel(db, model="s", sequenceColumn="sequence_alignment",
                              germlineColumn="germline_alignment_d_mask",
                              vCallColumn="v_call", multipleMutation="ignore")

# View top 5 mutability estimates
head(sort(model@mutability, decreasing=TRUE), 5)

# View number of silent mutations used for estimating mutability
model@numMutS


</code></pre>

<hr>
<h2 id='DensityThreshold-class'>Output of the <code>dens</code> method of findThreshold</h2><span id='topic+DensityThreshold-class'></span><span id='topic+DensityThreshold'></span><span id='topic+print+2CDensityThreshold-method'></span><span id='topic+DensityThreshold-method'></span><span id='topic+plot+2CDensityThreshold+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>DensityThreshold</code> contains output from the <code>dens</code> method <a href="#topic+findThreshold">findThreshold</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'DensityThreshold'
print(x)

## S4 method for signature 'DensityThreshold,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DensityThreshold-class_+3A_x">x</code></td>
<td>
<p>DensityThreshold object</p>
</td></tr>
<tr><td><code id="DensityThreshold-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="DensityThreshold-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotDensityThreshold">plotDensityThreshold</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>input distance vector with NA or infinite values removed.</p>
</dd>
<dt><code>bandwidth</code></dt><dd><p>bandwidth value fit during density estimation.</p>
</dd>
<dt><code>xdens</code></dt><dd><p>x-axis (distance value) vector for smoothed density estimate.</p>
</dd>
<dt><code>ydens</code></dt><dd><p>y-axis (density) vector for smoothed density estimate.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>distance threshold that separates two modes of the input distribution.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+findThreshold">findThreshold</a>
</p>

<hr>
<h2 id='distToNearest'>Distance to nearest neighbor</h2><span id='topic+distToNearest'></span>

<h3>Description</h3>

<p>Get non-zero distance of every heavy chain (<code>IGH</code>) sequence (as defined by 
<code>sequenceColumn</code>) to its nearest sequence in a partition of heavy chains sharing the same 
V gene, J gene, and junction length (V-J-length), or in a partition of single cells with heavy/long chains
sharing the same heavy/long chain V-J-length combination, or of single cells with heavy/long and light/short chains 
sharing the same heavy/long chain V-J-length and light/short chain V-J-length combinations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distToNearest(
  db,
  sequenceColumn = "junction",
  vCallColumn = "v_call",
  jCallColumn = "j_call",
  model = c("ham", "aa", "hh_s1f", "hh_s5f", "mk_rs1nf", "mk_rs5nf", "m1n_compat",
    "hs1f_compat"),
  normalize = c("len", "none"),
  symmetry = c("avg", "min"),
  first = TRUE,
  VJthenLen = TRUE,
  nproc = 1,
  fields = NULL,
  cross = NULL,
  mst = FALSE,
  subsample = NULL,
  progress = FALSE,
  cellIdColumn = NULL,
  locusColumn = "locus",
  locusValues = c("IGH"),
  onlyHeavy = TRUE,
  keepVJLgroup = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distToNearest_+3A_db">db</code></td>
<td>
<p>data.frame containing sequence data.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing the junction for grouping and for calculating
nearest neighbor distances. Note that while both heavy/long and light/short chain junctions
may be used for V-J-length grouping, only the heavy/long chain (IGH, TRB, TRD) junction is 
used to calculate distances.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_vcallcolumn">vCallColumn</code></td>
<td>
<p>name of the column containing the V-segment allele calls.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_jcallcolumn">jCallColumn</code></td>
<td>
<p>name of the column containing the J-segment allele calls.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_model">model</code></td>
<td>
<p>underlying SHM model, which must be one of 
<code>c("ham", "aa", "hh_s1f", "hh_s5f", "mk_rs1nf", "hs1f_compat", "m1n_compat")</code>.
See Details for further information.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_normalize">normalize</code></td>
<td>
<p>method of normalization. The default is <code>"len"</code>, which 
divides the distance by the length of the sequence group. If 
<code>"none"</code> then no normalization if performed.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_symmetry">symmetry</code></td>
<td>
<p>if model is hs5f, distance between seq1 and seq2 is either the
average (avg) of seq1-&gt;seq2 and seq2-&gt;seq1 or the minimum (min).</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_first">first</code></td>
<td>
<p>if <code>TRUE</code> only the first call of the gene assignments 
is used. if <code>FALSE</code> the union of ambiguous gene 
assignments is used to group all sequences with any 
overlapping gene calls.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_vjthenlen">VJthenLen</code></td>
<td>
<p>logical value specifying whether to perform partitioning as a 2-stage
process. If <code>TRUE</code>, partitions are made first based on V and J
gene, and then further split based on junction lengths corresponding 
to <code>sequenceColumn</code>. If <code>FALSE</code>, perform partition as a 1-stage 
process during which V gene, J gene, and junction length are used 
to create partitions simultaneously. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the function over.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_fields">fields</code></td>
<td>
<p>additional fields to use for grouping.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_cross">cross</code></td>
<td>
<p>character vector of column names to use for grouping to calculate 
distances across groups. Meaning the columns that define self versus others.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_mst">mst</code></td>
<td>
<p>if <code>TRUE</code>, return comma-separated branch lengths from minimum 
spanning tree.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_subsample">subsample</code></td>
<td>
<p>number of sequences to subsample for speeding up pairwise-distance-matrix calculation. 
Subsampling is performed without replacement in each V-J-length group of heavy chain sequences. 
If <code>subsample</code> is larger than the unique number of heavy chain sequences in each 
VJL group, then the subsampling process is ignored for that group. For each heavy chain
sequence in <code>db</code>, the reported <code>dist_nearest</code> is the distance to the closest
heavy chain sequence in the subsampled set for the V-J-length group. If <code>NULL</code> no 
subsampling is performed.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> print a progress bar.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_cellidcolumn">cellIdColumn</code></td>
<td>
<p>name of the character column containing cell identifiers or barcodes. 
If specified, grouping will be performed in single-cell mode
with the behavior governed by the <code>locusColumn</code> and 
<code>onlyHeavy</code> arguments. If set to <code>NULL</code> then the 
bulk sequencing data is assumed.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_locuscolumn">locusColumn</code></td>
<td>
<p>name of the column containing locus information. 
Valid loci values
are &quot;IGH&quot;, &quot;IGI&quot;, &quot;IGK&quot;, &quot;IGL&quot;, &quot;TRA&quot;, &quot;TRB&quot;, 
&quot;TRD&quot;, and &quot;TRG&quot;.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_locusvalues">locusValues</code></td>
<td>
<p>Loci values to focus the analysis on.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_onlyheavy">onlyHeavy</code></td>
<td>
<p>use only the IGH (BCR) or TRB/TRD (TCR) sequences 
for grouping. Only applicable to single-cell data.
Ignored if <code>cellIdColumn=NULL</code>. 
See <a href="alakazam.html#topic+groupGenes">groupGenes</a> for further details.</p>
</td></tr>
<tr><td><code id="distToNearest_+3A_keepvjlgroup">keepVJLgroup</code></td>
<td>
<p>logical value specifying whether to keep in the output the the column 
column indicating grouping based on V-J-length combinations. Only applicable for
1-stage partitioning (i.e. <code>VJthenLen=FALSE</code>). Also see 
<a href="alakazam.html#topic+groupGenes">groupGenes</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To invoke single-cell mode the <code>cellIdColumn</code> argument must be specified and <code>locusColumn</code> 
must be correct. Otherwise, <code>distToNearest</code> will be run with bulk sequencing assumptions, 
using all input sequences regardless of the values in the <code>locusColumn</code> column.
</p>
<p>Under single-cell mode, only heavy/long chain (IGH, TRB, TRD) sequences will be used for calculating 
nearest neighbor distances. Under non-single-cell mode, all input sequences will be used for 
calculating nearest neighbor distances, regardless of the values in the <code>locusColumn</code> field (if present).
</p>
<p>Values in the <code>locusColumn</code> must be one of <code>c("IGH", "IGI", "IGK", "IGL")</code> for BCR 
or <code>c("TRA", "TRB", "TRD", "TRG")</code> for TCR sequences. Otherwise, the function returns an 
error message and stops.
</p>
<p>For single-cell mode, the input format is the same as that for <a href="alakazam.html#topic+groupGenes">groupGenes</a>. 
Namely, each row represents a sequence/chain. Sequences/chains from the same cell are linked
by a cell ID in the <code>cellIdColumn</code> field. In this mode, there is a choice of whether 
grouping should be done by (a) using IGH (BCR) or TRB/TRD (TCR) sequences only or
(b) using IGH plus IGK/IGL (BCR) or TRB/TRD plus TRA/TRG (TCR). 
This is governed by the <code>onlyHeavy</code> argument.
</p>
<p>Note, <code>distToNearest</code> required that each cell (each unique value in <code>cellIdColumn</code>)
correspond to only a single <code>IGH</code> (BCR) or <code>TRB/TRD</code> (TCR) sequence.
</p>
<p>The distance to nearest neighbor can be used to estimate a threshold for assigning 
Ig sequences to clonal groups. A histogram of the resulting vector is often bimodal, with the 
ideal threshold being a value that separates the two modes.
</p>
<p>The following distance measures are accepted by the <code>model</code> parameter.
</p>

<ul>
<li> <p><code>"ham"</code>:          Single nucleotide Hamming distance matrix from <a href="alakazam.html#topic+getDNAMatrix">getDNAMatrix</a> 
with gaps assigned zero distance.
</p>
</li>
<li> <p><code>"aa"</code>:           Single amino acid Hamming distance matrix from <a href="alakazam.html#topic+getAAMatrix">getAAMatrix</a>.
</p>
</li>
<li> <p><code>"hh_s1f"</code>:       Human single nucleotide distance matrix derived from <a href="#topic+HH_S1F">HH_S1F</a> with 
<a href="#topic+calcTargetingDistance">calcTargetingDistance</a>.
</p>
</li>
<li> <p><code>"hh_s5f"</code>:       Human 5-mer nucleotide context distance matix derived from <a href="#topic+HH_S5F">HH_S5F</a> with 
<a href="#topic+calcTargetingDistance">calcTargetingDistance</a>.
</p>
</li>
<li> <p><code>"mk_rs1nf"</code>:     Mouse single nucleotide distance matrix derived from <a href="#topic+MK_RS1NF">MK_RS1NF</a> with 
<a href="#topic+calcTargetingDistance">calcTargetingDistance</a>.
</p>
</li>
<li> <p><code>"mk_rs5nf"</code>:     Mouse 5-mer nucleotide context distance matrix derived from <a href="#topic+MK_RS1NF">MK_RS1NF</a> with 
<a href="#topic+calcTargetingDistance">calcTargetingDistance</a>.
</p>
</li>
<li> <p><code>"hs1f_compat"</code>:  Backwards compatible human single nucleotide distance matrix used in 
SHazaM v0.1.4 and Change-O v0.3.3.
</p>
</li>
<li> <p><code>"m1n_compat"</code>:   Backwards compatibley mouse single nucleotide distance matrix used in 
SHazaM v0.1.4 and Change-O v0.3.3.
</p>
</li></ul>

<p>Note on <code>NA</code>s: if, for a given combination of V gene, J gene, and junction length,
there is only 1  heavy chain sequence (as defined by <code>sequenceColumn</code>), <code>NA</code> is 
returned instead of a distance (since it has no heavy/long chain neighbor). If for a given combination 
there are multiple heavy/long chain sequences but only 1 unique one, (in which case every heavy/long cahin 
sequence in this group is the de facto nearest neighbor to each other, thus giving rise to distances 
of 0), <code>NA</code>s are returned instead of zero-distances.
</p>
<p>Note on <code>subsample</code>: Subsampling is performed independently in each V-J-length group for 
heavy/long chain sequences. If <code>subsample</code> is larger than number of heavy/long chain sequences 
in the group, it is ignored. In other words, subsampling is performed only on groups in which the 
number of heavy/long chain sequences is equal to or greater than <code>subsample</code>. <code>dist_nearest</code> 
has values calculated using all heavy chain sequences in the group for groups with fewer than 
<code>subsample</code> heavy/long chain sequences, and values calculated using a subset of heavy/long chain 
sequences for the larger groups. To select a value of <code>subsample</code>, it can be useful to explore 
the group sizes in <code>db</code> (and the number of heavy/long chain sequences in those groups).
</p>


<h3>Value</h3>

<p>Returns a modified <code>db</code> data.frame with nearest neighbor distances between heavy chain
sequences in the <code>dist_nearest</code> column if <code>cross=NULL</code>. If <code>cross</code> was 
specified, distances will be added as the <code>cross_dist_nearest</code> column. 
</p>
<p>Note that distances between light/short (IGK, IGL, TRA, TRG) chain sequences are not calculated, 
even if light/short chains were used for V-J-length grouping via <code>onlyHeavy=FALSE</code>. 
Light/short chain sequences, if any, will have <code>NA</code> in the <code>dist_nearest</code> output column.
</p>
<p>Note that the output <code>vCallColumn</code> and <code>jCallColumn</code> columns will be converted to 
type <code>character</code> if they were type <code>factor</code> in the input <code>db</code>.
</p>


<h3>References</h3>


<ol>
<li><p>  Smith DS, et al. Di- and trinucleotide target preferences of somatic 
mutagenesis in normal and autoreactive B cells. 
J Immunol. 1996 156:2642-52. 
</p>
</li>
<li><p>  Glanville J, Kuo TC, von Budingen H-C, et al. 
Naive antibody gene-segment frequencies are heritable and unaltered by 
chronic lymphocyte ablation. 
Proc Natl Acad Sci USA. 2011 108(50):20066-71.
</p>
</li>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4:358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+calcTargetingDistance">calcTargetingDistance</a> for generating nucleotide distance matrices 
from a <a href="#topic+TargetingModel">TargetingModel</a> object. See <a href="#topic+HH_S5F">HH_S5F</a>, <a href="#topic+HH_S1F">HH_S1F</a>, 
<a href="#topic+MK_RS1NF">MK_RS1NF</a>, <a href="alakazam.html#topic+getDNAMatrix">getDNAMatrix</a>, and <a href="alakazam.html#topic+getAAMatrix">getAAMatrix</a>
for individual model details. <a href="alakazam.html#topic+getLocus">getLocus</a> to get locus
values based on allele calls.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data to one sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, sample_id == "-1h")

# Use genotyped V assignments, Hamming distance, and normalize by junction length
# First partition based on V and J assignments, then by junction length
# Take into consideration ambiguous V and J annotations
dist &lt;- distToNearest(db, sequenceColumn="junction", 
                      vCallColumn="v_call_genotyped", jCallColumn="j_call",
                      model="ham", first=FALSE, VJthenLen=TRUE, normalize="len")
                           
# Plot histogram of non-NA distances
p1 &lt;- ggplot(data=subset(dist, !is.na(dist_nearest))) + 
      theme_bw() + 
      ggtitle("Distance to nearest: Hamming") + 
      xlab("distance") +
      geom_histogram(aes(x=dist_nearest), binwidth=0.025, 
                     fill="steelblue", color="white")
plot(p1)

</code></pre>

<hr>
<h2 id='editBaseline'>Edit the Baseline object</h2><span id='topic+editBaseline'></span>

<h3>Description</h3>

<p><code>editBaseline</code> edits a field in a <code>Baseline</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editBaseline(baseline, field, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editBaseline_+3A_baseline">baseline</code></td>
<td>
<p><code>Baseline</code> object to be edited.</p>
</td></tr>
<tr><td><code id="editBaseline_+3A_field">field</code></td>
<td>
<p>name of the field in the <code>Baseline</code> object to be edited.</p>
</td></tr>
<tr><td><code id="editBaseline_+3A_value">value</code></td>
<td>
<p>value to set the <code>field</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>Baseline</code> object with the field of choice updated.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+Baseline">Baseline</a> for the input and return object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHG" &amp; sample_id == "+7d")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=100)

# Make Baseline object
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="sequence_alignment",
                         germlineColumn="germline_alignment_d_mask", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)
                         
# Edit the field "description"
baseline &lt;- editBaseline(baseline, field="description", 
                         value="+7d IGHG")


</code></pre>

<hr>
<h2 id='expectedMutations'>Calculate expected mutation frequencies</h2><span id='topic+expectedMutations'></span>

<h3>Description</h3>

<p><code>expectedMutations</code> calculates the expected mutation frequencies for each 
sequence in the input <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expectedMutations(
  db,
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment",
  targetingModel = HH_S5F,
  regionDefinition = NULL,
  mutationDefinition = NULL,
  nproc = 1,
  cloneColumn = "clone_id",
  juncLengthColumn = "junction_length"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectedMutations_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p><code>character</code> name of the column containing input 
sequences.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p><code>character</code> name of the column containing 
the germline or reference sequence.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_targetingmodel">targetingModel</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object. Default is <a href="#topic+HH_S5F">HH_S5F</a>.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences. To use regions definitions,
sequences in <code>sequenceColum</code> and <code>germlineColumn</code>
must be aligned, following the IMGT schema.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_mutationdefinition">mutationDefinition</code></td>
<td>
<p><a href="#topic+MutationDefinition">MutationDefinition</a> object defining replacement
and silent mutation criteria. If <code>NULL</code> then 
replacement and silent are determined by exact 
amino acid identity.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_nproc">nproc</code></td>
<td>
<p><code>numeric</code> number of cores to distribute the operation
over. If the cluster has already been set the call function with 
<code>nproc</code> = 0 to not reset or reinitialize. Default is 
<code>nproc</code> = 1.</p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_clonecolumn">cloneColumn</code></td>
<td>
<p>clone id column name in <code>db</code></p>
</td></tr>
<tr><td><code id="expectedMutations_+3A_junclengthcolumn">juncLengthColumn</code></td>
<td>
<p>junction length column name in <code>db</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only the part of the sequences defined in <code>regionDefinition</code> are analyzed. 
For example, when using the <a href="#topic+IMGT_V">IMGT_V</a> definition, mutations in
positions beyond 312 will be ignored.
</p>


<h3>Value</h3>

<p>A modified <code>db</code> <code>data.frame</code> with expected mutation frequencies 
for each region defined in <code>regionDefinition</code>.
</p>
<p>The columns names are dynamically created based on the regions in  
<code>regionDefinition</code>. For example, when using the <a href="#topic+IMGT_V">IMGT_V</a>
definition, which defines positions for CDR and FWR, the following columns are
added:  
</p>

<ul>
<li>  <p><code>mu_expected_cdr_r</code>:  number of replacement mutations in CDR1 and 
CDR2 of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_cdr_s</code>:  number of silent mutations in CDR1 and CDR2 
of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_fwr_r</code>:  number of replacement mutations in FWR1, 
FWR2 and FWR3 of the V-segment.
</p>
</li>
<li>  <p><code>mu_expected_fwr_s</code>:  number of silent mutations in FWR1, FWR2 and
FWR3 of the V-segment.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+calcExpectedMutations">calcExpectedMutations</a> is called by this function to calculate the expected 
mutation frequencies. See <a href="#topic+observedMutations">observedMutations</a> for getting observed 
mutation counts. See <a href="#topic+IMGT_SCHEMES">IMGT_SCHEMES</a> for a set of predefined 
<a href="#topic+RegionDefinition">RegionDefinition</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHA", "IGHG") &amp; sample_id == "+7d")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=100)
# Calculate expected mutations over V region
db_exp &lt;- expectedMutations(db,
                            sequenceColumn="sequence_alignment",
                            germlineColumn="germline_alignment_d_mask",
                            regionDefinition=IMGT_V,
                            nproc=1)

# Calculate hydropathy expected mutations over V region
db_exp &lt;- expectedMutations(db,
                           sequenceColumn="sequence_alignment",
                           germlineColumn="germline_alignment_d_mask",
                           regionDefinition=IMGT_V,
                           mutationDefinition=HYDROPATHY_MUTATIONS,
                           nproc=1)

</code></pre>

<hr>
<h2 id='extendMutabilityMatrix'>Extends a mutability model to include Ns.</h2><span id='topic+extendMutabilityMatrix'></span>

<h3>Description</h3>

<p><code>extendMutabilityMatrix</code> extends a 5-mer nucleotide mutability model 
with 5-mers that include Ns by averaging over all corresponding 5-mers without Ns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendMutabilityMatrix(mutabilityModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extendMutabilityMatrix_+3A_mutabilitymodel">mutabilityModel</code></td>
<td>
<p>vector of 5-mer mutability rates built by 
<a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>MutabilityModel</code> containing a 3125 vector of normalized 
mutability rates for each 5-mer motif with names defining the 5-mer 
nucleotide sequence. Note that &quot;normalized&quot; means that the mutability 
rates for the 1024 5-mers that contain no &quot;N&quot; at any position sums up 
to 1 (as opposed to the entire vector summing up to 1). 
</p>
<p>If the input <code>mutabilityModel</code> is of class <code>MutabilityModel</code>, 
then the output <code>MutabilityModel</code> will carry over the input 
<code>numMutS</code> and <code>numMutR</code> slots.
</p>


<h3>See Also</h3>

<p><a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>, <a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>, 
<a href="#topic+MutabilityModel">MutabilityModel</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=75)

# Create model using only silent mutations and ignore multiple mutations
sub_model &lt;- createSubstitutionMatrix(db, model="s", sequenceColumn="sequence_alignment",
                                      germlineColumn="germline_alignment_d_mask",
                                      vCallColumn="v_call")
mut_model &lt;- createMutabilityMatrix(db, sub_model, model="s", 
                                    sequenceColumn="sequence_alignment",
                                    germlineColumn="germline_alignment_d_mask",
                                    vCallColumn="v_call")
ext_model &lt;- extendMutabilityMatrix(mut_model)


</code></pre>

<hr>
<h2 id='extendSubstitutionMatrix'>Extends a substitution model to include Ns.</h2><span id='topic+extendSubstitutionMatrix'></span>

<h3>Description</h3>

<p><code>extendSubstitutionMatrix</code> extends a 5-mer nucleotide substitution model 
with 5-mers that include Ns by averaging over all corresponding 5-mers without Ns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extendSubstitutionMatrix(substitutionModel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extendSubstitutionMatrix_+3A_substitutionmodel">substitutionModel</code></td>
<td>
<p>matrix of 5-mers substitution counts built by 
<a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 5x3125 matrix of normalized substitution rate for each 5-mer motif with 
rows names defining the center nucleotide, one of <code>c("A", "C", "G", "T", "N")</code>, 
and column names defining the 5-mer nucleotide sequence.
</p>


<h3>See Also</h3>

<p><a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>, <a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")

# Create model using only silent mutations
sub_model &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                      germlineColumn="germline_alignment_d_mask",
                                      vCallColumn="v_call",model="s")
ext_model &lt;- extendSubstitutionMatrix(sub_model)

</code></pre>

<hr>
<h2 id='findThreshold'>Find distance threshold</h2><span id='topic+findThreshold'></span>

<h3>Description</h3>

<p><code>findThreshold</code> automatically determines an optimal threshold for clonal assignment of
Ig sequences using a vector of nearest neighbor distances. It provides two alternative methods 
using either a Gamma/Gaussian Mixture Model fit (<code>method="gmm"</code>) or kernel density 
fit (<code>method="density"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findThreshold(
  distances,
  method = c("density", "gmm"),
  edge = 0.9,
  cross = NULL,
  subsample = NULL,
  model = c("gamma-gamma", "gamma-norm", "norm-gamma", "norm-norm"),
  cutoff = c("optimal", "intersect", "user"),
  sen = NULL,
  spc = NULL,
  progress = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findThreshold_+3A_distances">distances</code></td>
<td>
<p>numeric vector containing nearest neighbor distances.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_method">method</code></td>
<td>
<p>string defining the method to use for determining the optimal threshold.
One of <code>"gmm"</code> or <code>"density"</code>. See Details for methodological
descriptions.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_edge">edge</code></td>
<td>
<p>upper range as a fraction of the data density to rule initialization of 
Gaussian fit parameters. Default value is 90
Applies only when <code>method="density"</code>. .</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_cross">cross</code></td>
<td>
<p>supplementary nearest neighbor distance vector output from <a href="#topic+distToNearest">distToNearest</a> 
for initialization of the Gaussian fit parameters. 
Applies only when <code>method="gmm"</code>.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_subsample">subsample</code></td>
<td>
<p>maximum number of distances to subsample to before threshold detection.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_model">model</code></td>
<td>
<p>allows the user to choose among four possible combinations of fitting curves: 
<code>"norm-norm"</code>, <code>"norm-gamma"</code>, <code>"gamma-norm"</code>, 
and <code>"gamma-gamma"</code>. Applies only when <code>method="gmm"</code>.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_cutoff">cutoff</code></td>
<td>
<p>method to use for threshold selection: the optimal threshold <code>"opt"</code>, 
the intersection point of the two fitted curves <code>"intersect"</code>, or 
a value defined by user for one of the sensitivity or specificity <code>"user"</code>.
Applies only when <code>method="gmm"</code>.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_sen">sen</code></td>
<td>
<p>sensitivity required. Applies only when <code>method="gmm"</code> and <code>cutoff="user"</code>.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_spc">spc</code></td>
<td>
<p>specificity required. Applies only when <code>method="gmm"</code> and <code>cutoff="user"</code>.</p>
</td></tr>
<tr><td><code id="findThreshold_+3A_progress">progress</code></td>
<td>
<p>if <code>TRUE</code> print a progress bar.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<ul>
<li> <p><code>"gmm"</code>:     Performs a maximum-likelihood fitting procedure, for learning 
the parameters of two mixture univariate, either Gamma or Gaussian, distributions 
which fit the bimodal distribution entries. Retrieving the fit parameters, 
it then calculates the optimum threshold <code>method="optimal"</code>, where the 
average of the sensitivity plus specificity reaches its maximum. In addition, 
the <code>findThreshold</code> function is also able 
to calculate the intersection point (<code>method="intersect"</code>) of the two fitted curves 
and allows the user to invoke its value as the cut-off point, instead of optimal point.
</p>
</li>
<li> <p><code>"density"</code>: Fits a binned approximation to the ordinary kernel density estimate
to the nearest neighbor distances after determining the optimal
bandwidth for the density estimate via least-squares cross-validation of 
the 4th derivative of the kernel density estimator. The optimal threshold
is set as the minimum value in the valley in the density estimate
between the two modes of the distribution.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>"gmm"</code> method:      Returns a <a href="#topic+GmmThreshold">GmmThreshold</a> object including the  
<code>threshold</code> and the function fit parameters, i.e.
mixing weight, mean, and standard deviation of a Normal distribution, or 
mixing weight, shape and scale of a Gamma distribution.
</p>
</li>
<li> <p><code>"density"</code> method:  Returns a <a href="#topic+DensityThreshold">DensityThreshold</a> object including the optimum 
<code>threshold</code> and the density fit parameters.
</p>
</li></ul>



<h3>Note</h3>

<p>Visually inspecting the resulting distribution fits is strongly recommended when using 
either fitting method. Empirical observations imply that the bimodality 
of the distance-to-nearest distribution is detectable for a minimum of 1,000 distances.
Larger numbers of distances will improve the fitting procedure, although this can come 
at the expense of higher computational demands.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+distToNearest">distToNearest</a> for generating the nearest neighbor distance vectors.
See <a href="#topic+plotGmmThreshold">plotGmmThreshold</a> and <a href="#topic+plotDensityThreshold">plotDensityThreshold</a> for plotting output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to 50 sequences, one sample and isotype as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, sample_id == "-1h" &amp; c_call=="IGHG")[1:50,]

# Use nucleotide Hamming distance and normalize by junction length
db &lt;- distToNearest(db, sequenceColumn="junction", vCallColumn="v_call",
                    jCallColumn="j_call", model="ham", normalize="len", nproc=1)
                            
# Find threshold using the "gmm" method with user defined specificity
output &lt;- findThreshold(db$dist_nearest, method="gmm", model="gamma-gamma", 
                        cutoff="user", spc=0.99)
plot(output, binwidth=0.02, title=paste0(output@model, "   loglk=", output@loglk))
print(output)

</code></pre>

<hr>
<h2 id='GmmThreshold-class'>Output of the <code>gmm</code> method of findThreshold</h2><span id='topic+GmmThreshold-class'></span><span id='topic+GmmThreshold'></span><span id='topic+print+2CGmmThreshold-method'></span><span id='topic+GmmThreshold-method'></span><span id='topic+plot+2CGmmThreshold+2Cmissing-method'></span>

<h3>Description</h3>

<p><code>GmmThreshold</code> contains output from the <code>gmm</code> method <a href="#topic+findThreshold">findThreshold</a>. 
It includes parameters of two Gaussian fits and threshold cut.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GmmThreshold'
print(x)

## S4 method for signature 'GmmThreshold,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GmmThreshold-class_+3A_x">x</code></td>
<td>
<p>GmmThreshold object</p>
</td></tr>
<tr><td><code id="GmmThreshold-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="GmmThreshold-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotGmmThreshold">plotGmmThreshold</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>x</code></dt><dd><p>input distance vector with NA or infinite values removed.</p>
</dd>
<dt><code>model</code></dt><dd><p>first-second fit functions.</p>
</dd>
<dt><code>cutoff</code></dt><dd><p>type of threshold cut.</p>
</dd>
<dt><code>a1</code></dt><dd><p>mixing weight of the first curve.</p>
</dd>
<dt><code>b1</code></dt><dd><p>second parameter of the first curve. Either the mean of a Normal 
distribution or shape of a Gamma distribution.</p>
</dd>
<dt><code>c1</code></dt><dd><p>third parameter of the first curve. Either the standard deviation of a 
Normal distribution or scale of a Gamma distribution.</p>
</dd>
<dt><code>a2</code></dt><dd><p>mixing weight of the second curve.</p>
</dd>
<dt><code>b2</code></dt><dd><p>second parameter of the second curve. Either the mean of a Normal 
distribution or shape of a Gamma distribution.</p>
</dd>
<dt><code>c2</code></dt><dd><p>third parameter of the second curve. Either the standard deviation 
of a Normal distribution or scale of a Gamma distribution.</p>
</dd>
<dt><code>loglk</code></dt><dd><p>log-likelihood of the fit.</p>
</dd>
<dt><code>threshold</code></dt><dd><p>threshold.</p>
</dd>
<dt><code>sensitivity</code></dt><dd><p>sensitivity.</p>
</dd>
<dt><code>specificity</code></dt><dd><p>specificity.</p>
</dd>
<dt><code>pvalue</code></dt><dd><p>p-value from Hartigans' dip statistic (HDS) test. 
Values less than 0.05 indicate significant bimodality.</p>
</dd>
</dl>


<h3>See Also</h3>

<p><a href="#topic+findThreshold">findThreshold</a>
</p>

<hr>
<h2 id='groupBaseline'>Group BASELINe PDFs</h2><span id='topic+groupBaseline'></span>

<h3>Description</h3>

<p><code>groupBaseline</code> convolves groups of BASELINe posterior probability density 
functions (PDFs) to get combined PDFs for each group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>groupBaseline(baseline, groupBy, nproc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="groupBaseline_+3A_baseline">baseline</code></td>
<td>
<p><code>Baseline</code> object containing the <code>db</code> and the 
BASELINe posterior probability density functions 
(PDF) for each of the sequences, as returned by
<a href="#topic+calcBaseline">calcBaseline</a>.</p>
</td></tr>
<tr><td><code id="groupBaseline_+3A_groupby">groupBy</code></td>
<td>
<p>The columns in the <code>db</code> slot of the <code>Baseline</code>
object by which to group the sequence PDFs.</p>
</td></tr>
<tr><td><code id="groupBaseline_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the operation over. If 
<code>nproc</code> = 0 then the <code>cluster</code> has already been
set and will not be reset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While the selection strengths predicted by BASELINe perform well on average, 
the estimates for individual sequences can be highly variable, especially when the 
number of mutations is small. 
</p>
<p>To overcome this, PDFs from sequences grouped by biological or experimental relevance,
are convolved to from a single PDF for the selection strength. For example, sequences
from each sample may be combined together, allowing you to compare selection  across 
samples. This is accomplished through a fast numerical convolution technique.
</p>


<h3>Value</h3>

<p>A <a href="#topic+Baseline">Baseline</a> object, containing the modified <code>db</code> and the BASELINe 
posterior probability density functions (PDF) for each of the groups.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Quantifying selection in high-throughput immunoglobulin 
sequencing data sets. 
Nucleic Acids Res. 2012 40(17):e134. 
(Corrections at http://selection.med.yale.edu/baseline/correction/)
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate the <a href="#topic+Baseline">Baseline</a> object see <a href="#topic+calcBaseline">calcBaseline</a>.
To calculate BASELINe statistics, such as the mean selection strength
and the 95% confidence interval, see <a href="#topic+summarizeBaseline">summarizeBaseline</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
## Not run: 
# Subset example data from alakazam as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHM", "IGHG"))
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=200)

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id",
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)

# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)
                         
# Group PDFs by sample
grouped1 &lt;- groupBaseline(baseline, groupBy="sample_id")
sample_colors &lt;- c("-1h"="steelblue", "+7d"="firebrick")
plotBaselineDensity(grouped1, idColumn="sample_id", colorValues=sample_colors, 
                    sigmaLimits=c(-1, 1))
 
# Group PDFs by both sample (between variable) and isotype (within variable)
grouped2 &lt;- groupBaseline(baseline, groupBy=c("sample_id", "c_call"))
isotype_colors &lt;- c("IGHM"="darkorchid", "IGHD"="firebrick", 
                    "IGHG"="seagreen", "IGHA"="steelblue")
plotBaselineDensity(grouped2, idColumn="sample_id", groupColumn="c_call",
                    colorElement="group", colorValues=isotype_colors,
                    sigmaLimits=c(-1, 1))
# Collapse previous isotype (within variable) grouped PDFs into sample PDFs
grouped3 &lt;- groupBaseline(grouped2, groupBy="sample_id")
sample_colors &lt;- c("-1h"="steelblue", "+7d"="firebrick")
plotBaselineDensity(grouped3, idColumn="sample_id", colorValues=sample_colors,
                    sigmaLimits=c(-1, 1))

## End(Not run)
</code></pre>

<hr>
<h2 id='HH_S1F'>Human heavy chain, silent, 1-mer, functional substitution model.</h2><span id='topic+HH_S1F'></span>

<h3>Description</h3>

<p>1-mer substitution model of somatic hypermutation based on analysis of silent mutations
in functional heavy chain Ig sequences from Homo sapiens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HH_S1F
</code></pre>


<h3>Format</h3>

<p>A 4x4 matrix of nucleotide substitution rates. The rates are normalized,
therefore each row sums up to 1.
</p>


<h3>Note</h3>

<p><code>HH_S1F</code> replaces <code>HS1FDistance</code> in versions of SHazaM prior to 0.1.5.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+HKL_S1F">HKL_S1F</a> for the human light chain 1-mer substitution model and 
<a href="#topic+MK_RS1NF">MK_RS1NF</a> for the mouse light chain 1-mer substitution model.
</p>

<hr>
<h2 id='HH_S5F'>Human heavy chain, silent, 5-mer, functional targeting model.</h2><span id='topic+HH_S5F'></span>

<h3>Description</h3>

<p>5-mer model of somatic hypermutation targeting based on analysis of silent mutations
in functional heavy chain Ig sequences from Homo sapiens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HH_S5F
</code></pre>


<h3>Format</h3>

<p>A <a href="#topic+TargetingModel">TargetingModel</a> object.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+HH_S1F">HH_S1F</a> for the 1-mer substitution matrix from the same 
publication; <a href="#topic+HKL_S5F">HKL_S5F</a> for the human light chain 5-mer targeting model; 
<a href="#topic+MK_RS5NF">MK_RS5NF</a> for the mouse 5-mer targeting model; and <a href="#topic+U5N">U5N</a> for the 
uniform 5-mer null targeting model.
</p>

<hr>
<h2 id='HKL_S1F'>Human kappa and lambda chain, silent, 1-mer, functional substitution model.</h2><span id='topic+HKL_S1F'></span>

<h3>Description</h3>

<p>1-mer substitution model of somatic hypermutation based on analysis of silent mutations
in functional kappa and lambda light chain Ig sequences from Homo sapiens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HKL_S1F
</code></pre>


<h3>Format</h3>

<p>A 4x4 matrix of nucleotide substitution rates. The rates are normalized,
therefore each row sums up to 1.
</p>


<h3>Note</h3>

<p>Reported in Table III in Cui et al, 2016.
</p>


<h3>References</h3>


<ol>
<li><p>  Cui A, Di Niro R, Vander Heiden J, Briggs A, Adams K, Gilbert T, O'Connor K,
Vigneault F, Shlomchik M and Kleinstein S (2016). A Model of Somatic Hypermutation 
Targeting in Mice Based on High-Throughput Ig Sequencing Data. The Journal of 
Immunology, 197(9), 3566-3574.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+HH_S1F">HH_S1F</a> for the human heavy chain 1-mer substitution model and 
<a href="#topic+MK_RS1NF">MK_RS1NF</a> for the mouse light chain 1-mer substitution model.
</p>

<hr>
<h2 id='HKL_S5F'>Human kappa and lambda light chain, silent, 5-mer, functional targeting model.</h2><span id='topic+HKL_S5F'></span>

<h3>Description</h3>

<p>5-mer model of somatic hypermutation targeting based on analysis of silent mutations
in functional kappa and lambda light chain Ig sequences from Homo sapiens.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HKL_S5F
</code></pre>


<h3>Format</h3>

<p>A <a href="#topic+TargetingModel">TargetingModel</a> object.
</p>


<h3>References</h3>


<ol>
<li><p>  Cui A, Di Niro R, Vander Heiden J, Briggs A, Adams K, Gilbert T, O'Connor K,
Vigneault F, Shlomchik M and Kleinstein S (2016). A Model of Somatic Hypermutation 
Targeting in Mice Based on High-Throughput Ig Sequencing Data. The Journal of 
Immunology, 197(9), 3566-3574.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+HH_S5F">HH_S5F</a> for the human heavy chain 5-mer targeting model; 
<a href="#topic+MK_RS5NF">MK_RS5NF</a> for the mouse kappa light chain 5-mer targeting model; 
and <a href="#topic+U5N">U5N</a> for the uniform 5-mer null targeting model.
</p>

<hr>
<h2 id='IMGT_SCHEMES'>IMGT unique numbering schemes</h2><span id='topic+IMGT_SCHEMES'></span><span id='topic+IMGT_V'></span><span id='topic+IMGT_V_BY_CODONS'></span><span id='topic+IMGT_V_BY_REGIONS'></span><span id='topic+IMGT_V_BY_SEGMENTS'></span><span id='topic+IMGT_VDJ_BY_REGIONS'></span><span id='topic+IMGT_VDJ'></span>

<h3>Description</h3>

<p>Sequence region definitions according to the IMGT unique numbering scheme.
</p>


<h3>Format</h3>

<p>A <a href="#topic+RegionDefinition">RegionDefinition</a> object defining:
</p>

<ul>
<li>  <p><code>IMGT_V</code>:               The IMGT numbered V segment up to position nucleotide 312.
This definition combines the CDR1 and CDR2 into a single CDR region,
and FWR1, FWR2 and FWR3 into a single FWR region. CDR3 and FWR4 are
excluded as they are downstream of nucleotide 312.
</p>
</li>
<li>  <p><code>IMGT_V_BY_CODONS</code>:     The IMGT numbered V segment up to position nucleotide 312.
This definition treats each codon, from codon 1 to codon 104, as a 
distinct region.
</p>
</li>
<li>  <p><code>IMGT_V_BY_REGIONS</code>:    The IMGT numbered V segment up to position nucleotide 312.
This defines separate regions for each of CDR1, CDR2,
FWR1, FWR2 and FWR3. CDR3 and FWR4 are
excluded as they are downstream of nucleotide 312.
</p>
</li>
<li>  <p><code>IMGT_V_BY_SEGMENTS</code>:   The IMGT numbered V segment up to position nucleotide 312.
This definition has no subdivisons and treats the entire V segment
as a single region.
</p>
</li>
<li>  <p><code>IMGT_VDJ</code>:             IMGT numbered regions for CDR1-3 and FWR1-4 with combined CDR and FWR 
definitions spanning CDR1-3 and FWR1-4, respectively.
Note, unless the definition object has been updated using <a href="#topic+setRegionBoundaries">setRegionBoundaries</a> 
this schema will have a value of <code>0</code> for the <code>seqLength</code> slot and
the <code>boundaries</code> slot will be empty. This is because
these slots depend on the junction length which is unknown in the template 
scheme. After <a href="#topic+setRegionBoundaries">setRegionBoundaries</a> has been run, these slots will be populated
with the appropriate values for the specied sequence and junction length.
</p>
</li>
<li>  <p><code>IMGT_VDJ_BY_REGIONS</code>:  The IMGT numbered regions for FWR1-4 and CDR1-3 with separate region boundaries
for each of CDR1, CDR2, CDR3, FWR1, FWR2, FWR3 and FWR4. 
Note, unless the definition object has been updated using <a href="#topic+setRegionBoundaries">setRegionBoundaries</a> 
this schema will have a value of <code>0</code> for the <code>seqLength</code> slot and
the <code>boundaries</code> slot will be empty. This is because
these slots depend on the junction length which is unknown in the template 
scheme. After <a href="#topic+setRegionBoundaries">setRegionBoundaries</a> has been run, these slots will be populated
with the appropriate values for the specied sequence and junction length.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Lefranc MP, et al. IMGT unique numbering for immunoglobulin and T cell 
receptor variable domains and Ig superfamily V-like domains. 
Developmental and comparative immunology. 2003 27:55-77.
</p>
</li></ol>


<hr>
<h2 id='makeAverage1merMut'>Make a 1-mer mutability model by averaging over a 5-mer mutability model</h2><span id='topic+makeAverage1merMut'></span>

<h3>Description</h3>

<p><code>makeAverage1merMut</code> averages mutability rates in a 5-mer mutability model
to derive a 1-mer mutability model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAverage1merMut(mut5mer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeAverage1merMut_+3A_mut5mer">mut5mer</code></td>
<td>
<p>a named vector of length 1024 such as that returned by 
<code>createMutabilityMatrix</code> and that returned by
<code>makeDegenerate5merMut</code> with <code>extended=FALSE</code>.
Names should correspond to 5-mers made up of &quot;A&quot;, &quot;T&quot;, 
&quot;G&quot;, and &quot;C&quot; (case-insensitive). <code>NA</code> values are 
allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, the mutability rate of &quot;A&quot; in the resultant 1-mer model
is derived by averaging the mutability rates of all the 5-mers that 
have an &quot;A&quot; as their central 1-mer, followed by normalization.
</p>


<h3>Value</h3>

<p>A named vector of length 4 containing normalized mutability rates.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+makeDegenerate5merMut">makeDegenerate5merMut</a> for making a degenerate 5-mer mutability
model based on a 1-mer mutability model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a degenerate 5-mer model (length of 1024) based on a 1-mer model
example1merMut &lt;- c(A=0.2, T=0.1, C=0.4, G=0.3)
degenerate5merMut &lt;- makeDegenerate5merMut(mut1mer = example1merMut)
 
# Now make a 1-mer model by averaging over the degenerate 5-mer model
# Expected to get back example1merMut
makeAverage1merMut(mut5mer = degenerate5merMut)

</code></pre>

<hr>
<h2 id='makeAverage1merSub'>Make a 1-mer substitution model by averaging over a 5-mer substitution model</h2><span id='topic+makeAverage1merSub'></span>

<h3>Description</h3>

<p><code>makeAverage1merSub</code> averages substitution rates in a 5-mer substitution model
to derive a 1-mer substitution model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeAverage1merSub(sub5mer)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeAverage1merSub_+3A_sub5mer">sub5mer</code></td>
<td>
<p>a 4x1024 matrix such as that returned by 
<code>createSubstitutionMatrix</code> and that returned by
<code>makeDegenerate5merSub</code> with <code>extended=FALSE</code>.
Column names should correspond to 5-mers containing the 
central 1-mer to mutate from. Row names should correspond to 
nucleotides to mutate into. Nucleotides should include 
&quot;A&quot;, &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; (case-insensitive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example, the substitution rate from &quot;A&quot; to &quot;T&quot; in the resultant 1-mer model
is derived by averaging the substitution rates into a &quot;T&quot; of all the 5-mers that 
have an &quot;A&quot; as their central 1-mer.
</p>


<h3>Value</h3>

<p>A 4x4 matrix with row names representing nucleotides to mutate from and column
names representing nucleotides to mutate into. Rates are normalized by row.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+makeDegenerate5merSub">makeDegenerate5merSub</a> for making a degenerate 5-mer substitution 
model based on a 1-mer substitution model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a degenerate 5-mer model (4x1024) based on HKL_S1F (4x4)
degenerate5merSub &lt;- makeDegenerate5merSub(sub1mer = HKL_S1F)

# Now make a 1-mer model by averaging over the degenerate 5-mer model
# Expected to get back HKL_S1F
makeAverage1merSub(sub5mer = degenerate5merSub)

</code></pre>

<hr>
<h2 id='makeDegenerate5merMut'>Make a degenerate 5-mer mutability model based on a 1-mer mutability model</h2><span id='topic+makeDegenerate5merMut'></span>

<h3>Description</h3>

<p><code>makeDegenerate5merMut</code> populates mutability rates from a 1-mer mutability model
into 5-mers with corresponding central 1-mers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDegenerate5merMut(mut1mer, extended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeDegenerate5merMut_+3A_mut1mer">mut1mer</code></td>
<td>
<p>a named vector of length 4 containing (normalized) 
mutability rates. Names should correspond to nucleotides, 
which should include &quot;A&quot;, &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; 
(case-insensitive).</p>
</td></tr>
<tr><td><code id="makeDegenerate5merMut_+3A_extended">extended</code></td>
<td>
<p>whether to return the unextended (<code>extended=FALSE</code>) or 
extended (<code>extended=TRUE</code>) 5-mer mutability model. 
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a concrete example, consider a 1-mer mutability model in which mutability
rates of &quot;A&quot;, &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; are, respectively, 0.14, 0.23, 0.31, and 0.32. 
In the resultant degenerate 5-mer mutability model, all the 5-mers that have 
an &quot;A&quot; as their central 1-mer would have mutability rate of 0.14/256, where 256 is
the number of such 5-mers. 
</p>
<p>When <code>extended=TRUE</code>, <code>extendMutabilityMatrix</code> is called to extend the
mutability vector of length 1024 into a vector of length 3125.
</p>


<h3>Value</h3>

<p>For <code>extended=FALSE</code>, a vector of length 1024. The vector returned is 
normalized. For <code>extended=TRUE</code>, a vector of length 3125.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+makeAverage1merMut">makeAverage1merMut</a> for making a 1-mer mutability model by 
taking the average of a 5-mer mutability model. See 
<a href="#topic+extendMutabilityMatrix">extendMutabilityMatrix</a> for extending the mutability vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a degenerate 5-mer model (length of 1024) based on a 1-mer model
example1merMut &lt;- c(A=0.2, T=0.1, C=0.4, G=0.3)
degenerate5merMut &lt;- makeDegenerate5merMut(mut1mer = example1merMut)

# Look at a few 5-mers
degenerate5merMut[c("AAAAT", "AACAT", "AAGAT", "AATAT")]

# Normalized
sum(degenerate5merMut)

</code></pre>

<hr>
<h2 id='makeDegenerate5merSub'>Make a degenerate 5-mer substitution model based on a 1-mer substitution model</h2><span id='topic+makeDegenerate5merSub'></span>

<h3>Description</h3>

<p><code>makeDegenerate5merSub</code> populates substitution rates from a 1-mer substitution model
into 5-mers with corresponding central 1-mers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDegenerate5merSub(sub1mer, extended = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeDegenerate5merSub_+3A_sub1mer">sub1mer</code></td>
<td>
<p>a 4x4 matrix containing (normalized) substitution rates.
Row names should correspond to nucleotides to mutate from.
Column names should correspond to nucleotides to mutate into.
Nucleotides should include &quot;A&quot;, &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; 
(case-insensitive).</p>
</td></tr>
<tr><td><code id="makeDegenerate5merSub_+3A_extended">extended</code></td>
<td>
<p>whether to return the unextended (<code>extended=FALSE</code>) or 
extended (<code>extended=TRUE</code>) 5-mer substitution model. 
Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As a concrete example, consider a 1-mer substitution model in which substitution
rates from &quot;A&quot; to &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; are, respectively, 0.1, 0.6, and 0.3. In the 
resultant degenerate 5-mer substitution model, all the 5-mers (columns) that have 
an &quot;A&quot; as their central 1-mer would have substitution rates (rows) of 0.1, 0.6, and 
0.3 to &quot;T&quot;, &quot;G&quot;, and &quot;C&quot; respectively. 
</p>
<p>When <code>extended=TRUE</code>, <code>extendSubstitutionMatrix</code> is called to extend
the 4x1024 substitution matrix.
</p>


<h3>Value</h3>

<p>For <code>extended=FALSE</code>, a 4x1024 matrix. For <code>extended=TRUE</code>, a 5x3125 
matrix.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+makeAverage1merSub">makeAverage1merSub</a> for making a 1-mer substitution model by taking
the average of a 5-mer substitution model. See <a href="#topic+extendSubstitutionMatrix">extendSubstitutionMatrix</a>
for extending the substitution matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Make a degenerate 5-mer model (4x1024) based on HKL_S1F (4x4)
# Note: not to be confused with HKL_S5F@substitution, which is non-degenerate
degenerate5merSub &lt;- makeDegenerate5merSub(sub1mer = HKL_S1F)

# Look at a few 5-mers
degenerate5merSub[, c("AAAAT", "AACAT", "AAGAT", "AATAT")]

</code></pre>

<hr>
<h2 id='makeGraphDf'>Build a data.frame from a ChangeoClone and an igraph object containing a clonal lineage</h2><span id='topic+makeGraphDf'></span>

<h3>Description</h3>

<p><code>makeGraphDf</code> creates a data.frame from a <a href="alakazam.html#topic+ChangeoClone">ChangeoClone</a> and an 
igraph <code>graph</code> object containing a B cell lineage tree and associated sequence data. 
The data.frame contains the original fields and additions such as each sequence's parent in the 
lineage tree, the lineage germline, and additional rows for inferred sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeGraphDf(
  curCloneGraph,
  curCloneObj,
  objSeqId = "sequence_id",
  objSeq = "sequence"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeGraphDf_+3A_curclonegraph">curCloneGraph</code></td>
<td>
<p>an igraph <code>graph</code> object for the lineage tree generated by 
<a href="alakazam.html#topic+buildPhylipLineage">buildPhylipLineage</a>. Note that the field containing the 
nucleotide sequence in the object must be named <code>sequence</code>.</p>
</td></tr>
<tr><td><code id="makeGraphDf_+3A_curcloneobj">curCloneObj</code></td>
<td>
<p><a href="alakazam.html#topic+ChangeoClone">ChangeoClone</a> object used to generate the lineage.</p>
</td></tr>
<tr><td><code id="makeGraphDf_+3A_objseqid">objSeqId</code></td>
<td>
<p>name of the sequence identifier field in <code>curCloneObj</code>.</p>
</td></tr>
<tr><td><code id="makeGraphDf_+3A_objseq">objSeq</code></td>
<td>
<p>name of the nucleotide sequence field in <code>curCloneObj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with sequence and lineage information, including the
the parent nucleotide sequence in the lineage tree(<code>parent_sequence</code>), 
an internal parent identifier (<code>parent</code>), and additional rows for germline 
sequence and inferred intermediate sequences.
</p>
<p>Values in the <code>sequence_id</code> field are renamed to numeric values,
prefixed with the clonal grouping identifier and labeled as either <code>"Inferred"</code> 
or <code>"Germline"</code> if they are not an observed sequence. For example, for a lineage 
with <code>clone_id = 34</code> the new identifiers would be of the form: 
<code>"34_Germline"</code>, <code>"34_Inferred1"</code>, <code>"34_1"</code>, <code>"34_2"</code>, etc.
</p>
<p>Note that the original sequence identifier is preserved in the <code>orig_sequence_id</code> field 
and the original parent sequence identifier is retained in <code>orig_parent</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+observedMutations">observedMutations</a> to calculate mutation frequencies using
<code>parent_sequence</code> as the reference germline. See <a href="alakazam.html#topic+ChangeoClone">ChangeoClone</a>,
<a href="alakazam.html#topic+buildPhylipLineage">buildPhylipLineage</a>, and <a href="igraph.html#topic+graph">graph</a> for details on the 
input objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and subset example data
data(ExampleDb, package = "alakazam")
data(ExampleTrees, package = "alakazam")
graph &lt;- ExampleTrees[[17]]
db &lt;- subset(ExampleDb, clone_id == graph$clone)
clone &lt;- alakazam::makeChangeoClone(db)

# Extend data with lineage information
df &lt;- makeGraphDf(graph, clone)

</code></pre>

<hr>
<h2 id='minNumMutationsTune'>Parameter tuning for minNumMutations</h2><span id='topic+minNumMutationsTune'></span>

<h3>Description</h3>

<p><code>minNumMutationsTune</code> helps with picking a threshold value for <code>minNumMutations</code>
in <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a> by tabulating the number of 5-mers for which 
substitution rates would be computed directly or inferred at various threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minNumMutationsTune(subCount, minNumMutationsRange)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minNumMutationsTune_+3A_subcount">subCount</code></td>
<td>
<p><code>data.frame</code> returned by <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>
with <code>numMutationsOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code id="minNumMutationsTune_+3A_minnummutationsrange">minNumMutationsRange</code></td>
<td>
<p>a number or a vector indicating the value or range of values
of <code>minNumMutations</code> to try.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a given threshold value of <code>minNumMutations</code>, for a given 5-mer,
if the total number of mutations is greater than the threshold and there
are mutations to every other base, substitution rates are computed directly
for the 5-mer using its mutations. Otherwise, mutations from 5-mers with 
the same inner 3-mer as the 5-mer of interest are aggregated. If the number 
of such mutations is greater than the threshold and there are mutations to 
every other base, these mutations are used for inferring the substitution 
rates for the 5-mer of interest; if not, mutations from all 5-mers with the 
same center nucleotide are aggregated and used for inferring the substitution
rates for the 5-mer of interest (i.e. the 1-mer model).
</p>


<h3>Value</h3>

<p>A 3xn <code>matrix</code>, where n is the number of trial values of <code>minNumMutations</code>
supplied in <code>minNumMutationsRange</code>. Each column corresponds to a value
in <code>minNumMutationsRange</code>. The rows correspond to the number of 5-mers
for which substitution rates would be computed directly using the 5-mer itself 
(<code>"5mer"</code>), using its inner 3-mer (<code>"3mer"</code>), and using the central 
1-mer (<code>"1mer"</code>), respectively.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See argument <code>numMutationsOnly</code> in <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a> 
for generating the required input <code>data.frame</code> <code>subCount</code>. 
See argument <code>minNumMutations</code> in <a href="#topic+createSubstitutionMatrix">createSubstitutionMatrix</a>
for what it does.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")

# Count the number of mutations per 5-mer
subCount &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                     germlineColumn="germline_alignment_d_mask",
                                     vCallColumn="v_call",
                                     model="s", multipleMutation="independent",
                                     returnModel="5mer", numMutationsOnly=TRUE)

# Tune minNumMutations
minNumMutationsTune(subCount, seq(from=10, to=80, by=10))
                                      
</code></pre>

<hr>
<h2 id='minNumSeqMutationsTune'>Parameter tuning for minNumSeqMutations</h2><span id='topic+minNumSeqMutationsTune'></span>

<h3>Description</h3>

<p><code>minNumSeqMutationsTune</code> helps with picking a threshold value for <code>minNumSeqMutations</code>
in <a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a> by tabulating the number of 5-mers for which 
mutability would be computed directly or inferred at various threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minNumSeqMutationsTune(mutCount, minNumSeqMutationsRange)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="minNumSeqMutationsTune_+3A_mutcount">mutCount</code></td>
<td>
<p>a <code>vector</code> of length 1024 returned by 
<a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a> with <code>numSeqMutationsOnly=TRUE</code>.</p>
</td></tr>
<tr><td><code id="minNumSeqMutationsTune_+3A_minnumseqmutationsrange">minNumSeqMutationsRange</code></td>
<td>
<p>a number or a vector indicating the value or the range of values 
of <code>minNumSeqMutations</code> to try.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At a given threshold value of <code>minNumSeqMutations</code>, for a given 5-mer,
if the total number of mutations is greater than the threshold, mutability 
is computed directly. Otherwise, mutability is inferred.
</p>


<h3>Value</h3>

<p>A 2xn <code>matrix</code>, where n is the number of trial values of <code>minNumSeqMutations</code>
supplied in <code>minNumSeqMutationsRange</code>. Each column corresponds to a value
in <code>minNumSeqMutationsRange</code>. The rows correspond to the number of 5-mers
for which mutability would be computed directly (<code>"measured"</code>) and inferred
(<code>"inferred"</code>), respectively.
</p>


<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4(November):358.
</p>
</li></ol>



<h3>See Also</h3>

<p>See argument <code>numSeqMutationsOnly</code> in <a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a> 
for generating the required input <code>vector</code> <code>mutCount</code>. 
See argument <code>minNumSeqMutations</code> in <a href="#topic+createMutabilityMatrix">createMutabilityMatrix</a>
for what it does.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA" &amp; sample_id == "-1h")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=75)
# Create model using only silent mutations
sub &lt;- createSubstitutionMatrix(db, sequenceColumn="sequence_alignment",
                                germlineColumn="germline_alignment_d_mask",
                                vCallColumn="v_call", 
                                model="s", multipleMutation="independent",
                                returnModel="5mer", numMutationsOnly=FALSE,
                                minNumMutations=20)

# Count the number of mutations in sequences containing each 5-mer
mutCount &lt;- createMutabilityMatrix(db, substitutionModel = sub,
                                   sequenceColumn="sequence_alignment",
                                   germlineColumn="germline_alignment_d_mask",
                                   vCallColumn="v_call",
                                   model="s", multipleMutation="independent",
                                   numSeqMutationsOnly=TRUE)

# Tune minNumSeqMutations
minNumSeqMutationsTune(mutCount, seq(from=100, to=300, by=50))
                                      
</code></pre>

<hr>
<h2 id='MK_RS1NF'>Mouse kappa chain, replacement and silent, 1-mer, non-functional substitution model.</h2><span id='topic+MK_RS1NF'></span>

<h3>Description</h3>

<p>1-mer substitution model of somatic hypermutation based on analysis of replacement and
silent mutations in non-functional kappa light chain Ig sequences from NP-immunized Mus
musculus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MK_RS1NF
</code></pre>


<h3>Format</h3>

<p>A 4x4 matrix of nucleotide substitution rates. The rates are normalized,
therefore each row sums up to 1.
</p>


<h3>Note</h3>

<p><code>MK_RS1NF</code> replaces <code>M1NDistance</code> from versions of SHazaM prior to 0.1.5.
</p>


<h3>References</h3>


<ol>
<li><p>  Cui A, Di Niro R, Vander Heiden J, Briggs A, Adams K, Gilbert T, O'Connor K,
Vigneault F, Shlomchik M and Kleinstein S (2016). A Model of Somatic Hypermutation 
Targeting in Mice Based on High-Throughput Ig Sequencing Data. The Journal of 
Immunology, 197(9), 3566-3574.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+HH_S1F">HH_S1F</a> for the human heavy chain 1-mer substitution model and 
<a href="#topic+HKL_S1F">HKL_S1F</a> for the human light chain 1-mer substitution model.
</p>

<hr>
<h2 id='MK_RS5NF'>Mouse kappa light chain, replacement and silent, 5-mer, non-functional targeting model.</h2><span id='topic+MK_RS5NF'></span>

<h3>Description</h3>

<p>5-mer model of somatic hypermutation targeting based on analysis of replacement and
silent mutations in non-functional kappa light chain Ig sequences from NP-immunized 
Mus musculus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MK_RS5NF
</code></pre>


<h3>Format</h3>

<p><a href="#topic+TargetingModel">TargetingModel</a> object.
</p>


<h3>References</h3>


<ol>
<li><p>  Cui A, Di Niro R, Vander Heiden J, Briggs A, Adams K, Gilbert T, O'Connor K,
Vigneault F, Shlomchik M and Kleinstein S (2016). A Model of Somatic Hypermutation 
Targeting in Mice Based on High-Throughput Ig Sequencing Data. The Journal of 
Immunology, 197(9), 3566-3574.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+MK_RS1NF">MK_RS1NF</a> for the 1-mer substitution matrix from the same
publication; <a href="#topic+HH_S5F">HH_S5F</a> for the human heavy chain silent 5-mer 
functional targeting model; <a href="#topic+HKL_S5F">HKL_S5F</a> for the human light chain 
silent 5-mer functional targeting model; and <a href="#topic+U5N">U5N</a> for the 
uniform 5-mer null targeting model.
</p>

<hr>
<h2 id='MutabilityModel-class'>S4 class defining a mutability model</h2><span id='topic+MutabilityModel-class'></span><span id='topic+MutabilityModel'></span><span id='topic+print+2CMutabilityModel-method'></span><span id='topic+MutabilityModel-method'></span><span id='topic+as.data.frame+2CMutabilityModel-method'></span>

<h3>Description</h3>

<p><code>MutabilityModel</code> defines a data structure for the 5-mer motif-based SHM targeting
mutability model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MutabilityModel'
print(x)

## S4 method for signature 'MutabilityModel'
as.data.frame(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MutabilityModel-class_+3A_x">x</code></td>
<td>
<p><code>MutabilityModel</code> object.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>numeric vector containing 5-mer mutability estimates</p>
</dd>
<dt><code>source</code></dt><dd><p>character vector annotating whether the mutability was
inferred or directly measured.</p>
</dd>
<dt><code>numMutS</code></dt><dd><p>a number indicating the number of silent mutations used for 
estimating mutability</p>
</dd>
<dt><code>numMutR</code></dt><dd><p>a number indicating the number of replacement mutations used 
for estimating mutability</p>
</dd>
</dl>

<hr>
<h2 id='MUTATION_SCHEMES'>Amino acid mutation definitions</h2><span id='topic+MUTATION_SCHEMES'></span><span id='topic+CHARGE_MUTATIONS'></span><span id='topic+HYDROPATHY_MUTATIONS'></span><span id='topic+POLARITY_MUTATIONS'></span><span id='topic+VOLUME_MUTATIONS'></span>

<h3>Description</h3>

<p>Definitions of replacement (R) and silent (S) mutations for different amino acid
physicochemical classes.
</p>


<h3>Format</h3>

<p>A <a href="#topic+MutationDefinition">MutationDefinition</a> object defining:
</p>

<ul>
<li>  <p><code>CHARGE_MUTATIONS</code>:      Amino acid mutations are defined by changes
in side chain charge class.
</p>
</li>
<li>  <p><code>HYDROPATHY_MUTATIONS</code>:  Amino acid mutations are defined by changes
in side chain hydrophobicity class.
</p>
</li>
<li>  <p><code>POLARITY_MUTATIONS</code>:    Amino acid mutations are defined by changes
in side chain polarity class.
</p>
</li>
<li>  <p><code>VOLUME_MUTATIONS</code>:      Amino acid mutations are defined by changes
in side chain volume class.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li>  <p><a href="https://www.imgt.org/IMGTeducation/Aide-memoire/_UK/aminoacids/IMGTclasses.html">https://www.imgt.org/IMGTeducation/Aide-memoire/_UK/aminoacids/IMGTclasses.html</a> 
</p>
</li></ol>


<hr>
<h2 id='MutationDefinition-class'>S4 class defining replacement and silent mutation definitions</h2><span id='topic+MutationDefinition-class'></span><span id='topic+MutationDefinition'></span>

<h3>Description</h3>

<p><code>MutationDefinition</code> defines a common data structure for defining the whether
a mutation is annotated as a replacement or silent mutation.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>name of the MutationDefinition.</p>
</dd>
<dt><code>description</code></dt><dd><p>description of the model and its source.</p>
</dd>
<dt><code>classes</code></dt><dd><p>named character vectors with single-letter amino acid codes as names
and amino acid classes as values, with <code>NA</code> assigned to set of 
characters <code>c("X", "*", "-", ".")</code>. Replacement (R) is be 
defined as a change in amino acid class and silent (S) as no 
change in class.</p>
</dd>
<dt><code>codonTable</code></dt><dd><p>matrix of codons (columns) and substitutions (rows).</p>
</dd>
<dt><code>citation</code></dt><dd><p>publication source.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+MUTATION_SCHEMES">MUTATION_SCHEMES</a> for a set of predefined <code>MutationDefinition</code> objects.
</p>

<hr>
<h2 id='observedMutations'>Calculate observed numbers of mutations</h2><span id='topic+observedMutations'></span>

<h3>Description</h3>

<p><code>observedMutations</code> calculates the observed number of mutations for each 
sequence in the input <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>observedMutations(
  db,
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  regionDefinition = NULL,
  mutationDefinition = NULL,
  ambiguousMode = c("eitherOr", "and"),
  frequency = FALSE,
  combine = FALSE,
  nproc = 1,
  cloneColumn = "clone_id",
  juncLengthColumn = "junction_length"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="observedMutations_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p><code>character</code> name of the column containing input 
sequences. IUPAC ambiguous characters for DNA are 
supported.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p><code>character</code> name of the column containing 
the germline or reference sequence. IUPAC ambiguous 
characters for DNA are supported.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><a href="#topic+RegionDefinition">RegionDefinition</a> object defining the regions
and boundaries of the Ig sequences. If NULL, mutations 
are counted for entire sequence. To use regions definitions,
sequences in <code>sequenceColum</code> and <code>germlineColumn</code>
must be aligned, following the IMGT schema.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_mutationdefinition">mutationDefinition</code></td>
<td>
<p><a href="#topic+MutationDefinition">MutationDefinition</a> object defining replacement
and silent mutation criteria. If <code>NULL</code> then 
replacement and silent are determined by exact 
amino acid identity.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_ambiguousmode">ambiguousMode</code></td>
<td>
<p>whether to consider ambiguous characters as 
<code>"either or"</code> or <code>"and"</code> when determining and 
counting the type(s) of mutations. Applicable only if
<code>sequenceColumn</code> and/or <code>germlineColumn</code> 
contain(s) ambiguous characters. One of 
<code>c("eitherOr", "and")</code>. Default is <code>"eitherOr"</code>.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_frequency">frequency</code></td>
<td>
<p><code>logical</code> indicating whether or not to calculate
mutation frequencies. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_combine">combine</code></td>
<td>
<p><code>logical</code> indicating whether for each sequence should
the mutation counts for the different regions (CDR, FWR) and 
mutation types be combined and return one value of 
count/frequency per sequence instead of 
multiple values. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the operation over. If the 
cluster has already been set the call function with 
<code>nproc</code> = 0 to not reset or reinitialize. Default is 
<code>nproc</code> = 1.</p>
</td></tr>
<tr><td><code id="observedMutations_+3A_clonecolumn">cloneColumn</code></td>
<td>
<p>clone id column name in <code>db</code></p>
</td></tr>
<tr><td><code id="observedMutations_+3A_junclengthcolumn">juncLengthColumn</code></td>
<td>
<p>junction length column name in <code>db</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mutation counts are determined by comparing a reference sequence to the input sequences in the 
column specified by <code>sequenceColumn</code>. See <a href="#topic+calcObservedMutations">calcObservedMutations</a> for more technical details, 
<strong>including criteria for which sequence differences are included in the mutation 
counts and which are not</strong>.
</p>
<p>The mutations are binned as either replacement (R) or silent (S) across the different 
regions of the sequences as defined by <code>regionDefinition</code>. Typically, this would 
be the framework (FWR) and complementarity determining (CDR) regions of IMGT-gapped 
nucleotide sequences. Mutation counts are appended to the input <code>db</code> as 
additional columns.
</p>
<p>If <code>db</code> includes lineage information, such as the <code>parent_sequence</code> column created by 
<a href="#topic+makeGraphDf">makeGraphDf</a>, the reference sequence can be set to use that field as reference sequence 
using the <code>germlineColumn</code> argument.
</p>


<h3>Value</h3>

<p>A modified <code>db</code> <code>data.frame</code> with observed mutation counts for each 
sequence listed. The columns names are dynamically created based on the
regions in the <code>regionDefinition</code>. For example, when using the
<a href="#topic+IMGT_V">IMGT_V</a> definition, which defines positions for CDR and
FWR, the following columns are added:
</p>

<ul>
<li>  <p><code>mu_count_cdr_r</code>:  number of replacement mutations in CDR1 and 
CDR2 of the V-segment.
</p>
</li>
<li>  <p><code>mu_count_cdr_s</code>:  number of silent mutations in CDR1 and CDR2 
of the V-segment.
</p>
</li>
<li>  <p><code>mu_count_fwr_r</code>:  number of replacement mutations in FWR1, 
FWR2 and FWR3 of the V-segment.
</p>
</li>
<li>  <p><code>mu_count_fwr_s</code>:  number of silent mutations in FWR1, FWR2 and
FWR3 of the V-segment.
</p>
</li></ul>

<p>If <code>frequency=TRUE</code>, R and S mutation frequencies are
calculated over the number of non-N positions in the specified regions.
</p>

<ul>
<li>  <p><code>mu_freq_cdr_r</code>:  frequency of replacement mutations in CDR1 and 
CDR2 of the V-segment.
</p>
</li>
<li>  <p><code>mu_freq_cdr_s</code>:  frequency of silent mutations in CDR1 and CDR2 
of the V-segment.
</p>
</li>
<li>  <p><code>mu_freq_fwr_r</code>:  frequency of replacement mutations in FWR1, 
FWR2 and FWR3 of the V-segment.
</p>
</li>
<li>  <p><code>mu_freq_fwr_s</code>:  frequency of silent mutations in FWR1, FWR2 and
FWR3 of the V-segment.
</p>
</li></ul>
 
<p>If <code>frequency=TRUE</code> and <code>combine=TRUE</code>, the mutations and non-N positions
are aggregated and a single <code>mu_freq</code> value is returned
</p>

<ul>
<li>  <p><code>mu_freq</code>:  frequency of replacement and silent mutations in the 
specified region
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+calcObservedMutations">calcObservedMutations</a> is called by this function to get the number of mutations 
in each sequence grouped by the <a href="#topic+RegionDefinition">RegionDefinition</a>. 
See <a href="#topic+IMGT_SCHEMES">IMGT_SCHEMES</a> for a set of predefined <a href="#topic+RegionDefinition">RegionDefinition</a> objects.
See <a href="#topic+expectedMutations">expectedMutations</a> for calculating expected mutation frequencies.
See <a href="#topic+makeGraphDf">makeGraphDf</a> for creating the field <code>parent_sequence</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Subset example data
data(ExampleDb, package="alakazam")
db &lt;- ExampleDb[1:10, ]

# Calculate mutation frequency over the entire sequence
db_obs &lt;- observedMutations(db, sequenceColumn="sequence_alignment",
                            germlineColumn="germline_alignment_d_mask",
                            frequency=TRUE,
                            nproc=1)

# Count of V-region mutations split by FWR and CDR
# With mutations only considered replacement if charge changes
db_obs &lt;- observedMutations(db, sequenceColumn="sequence_alignment",
                            germlineColumn="germline_alignment_d_mask",
                            regionDefinition=IMGT_V,
                            mutationDefinition=CHARGE_MUTATIONS,
                            nproc=1)
                            
# Count of VDJ-region mutations, split by FWR and CDR
db_obs &lt;- observedMutations(db, sequenceColumn="sequence_alignment",
                            germlineColumn="germline_alignment_d_mask",
                            regionDefinition=IMGT_VDJ,
                            nproc=1)
                            
# Extend data with lineage information
data(ExampleTrees, package="alakazam")
graph &lt;- ExampleTrees[[17]]
clone &lt;- alakazam::makeChangeoClone(subset(ExampleDb, clone_id == graph$clone))
gdf &lt;- makeGraphDf(graph, clone)

# Count of mutations between observed sequence and immediate ancenstor
db_obs &lt;- observedMutations(gdf, sequenceColumn="sequence",
                            germlineColumn="parent_sequence",
                            regionDefinition=IMGT_VDJ,
                            nproc=1)    
    
</code></pre>

<hr>
<h2 id='plotBaselineDensity'>Plots BASELINe probability density functions</h2><span id='topic+plotBaselineDensity'></span>

<h3>Description</h3>

<p><code>plotBaselineDensity</code> plots the probability density functions resulting from selection 
analysis using the BASELINe method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBaselineDensity(
  baseline,
  idColumn,
  groupColumn = NULL,
  colorElement = c("id", "group"),
  colorValues = NULL,
  title = NULL,
  subsetRegions = NULL,
  sigmaLimits = c(-5, 5),
  facetBy = c("region", "group"),
  style = c("density"),
  sizeElement = c("none", "id", "group"),
  size = 1,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBaselineDensity_+3A_baseline">baseline</code></td>
<td>
<p><code>Baseline</code> object containing selection probability 
density functions.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_idcolumn">idColumn</code></td>
<td>
<p>name of the column in the <code>db</code> slot of <code>baseline</code> 
containing primary identifiers.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>name of the column in the <code>db</code> slot of <code>baseline</code> 
containing secondary grouping identifiers. If <code>NULL</code>, 
organize the plot only on values in <code>idColumn</code>.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_colorelement">colorElement</code></td>
<td>
<p>one of <code>c("id", "group")</code> specifying whether the 
<code>idColumn</code> or <code>groupColumn</code> will be used for color coding. 
The other entry, if present, will be coded by line style.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_colorvalues">colorValues</code></td>
<td>
<p>named vector of colors for entries in <code>colorElement</code>, with 
names defining unique values in the <code>colorElement</code> column and values
being colors. Also controls the order in which values appear on the
plot. If <code>NULL</code> alphabetical ordering and a default color palette 
will be used.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_title">title</code></td>
<td>
<p>string defining the plot title.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_subsetregions">subsetRegions</code></td>
<td>
<p>character vector defining a subset of regions to plot, correspoding 
to the regions for which the <code>baseline</code> data was calculated. If
<code>NULL</code> all regions in <code>baseline</code> are plotted.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_sigmalimits">sigmaLimits</code></td>
<td>
<p>numeric vector containing two values defining the <code>c(lower, upper)</code>
bounds of the selection scores to plot.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_facetby">facetBy</code></td>
<td>
<p>one of <code>c("region", "group")</code> specifying which category to facet the
plot by, either values in <code>groupColumn</code> (&quot;group&quot;) or regions
defined in the <code>regions</code> slot of the <code>baseline</code> object (&quot;region&quot;).
If this is set to &quot;group&quot;, then the region will behave as the <code>groupColumn</code>
for purposes of the <code>colorElement</code> argument.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_style">style</code></td>
<td>
<p>type of plot to draw. One of:
</p>

<ul>
<li> <p><code>"density"</code>:  plots a set of curves for each probability 
density function in <code>baseline</code>, 
with colors determined by values in the
<code>colorElement</code> column.
Faceting is determined by the 
<code>facetBy</code> argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_sizeelement">sizeElement</code></td>
<td>
<p>one of <code>c("none", "id", "group")</code> specifying whether the lines in the
plot should be all of the same size (<code>none</code>) or have their sizes depend on 
the values in <code>id</code> or <code>code</code>.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_size">size</code></td>
<td>
<p>numeric scaling factor for lines, points and text in the plot.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotBaselineDensity_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object defining the plot.
</p>


<h3>See Also</h3>

<p>Takes as input a <a href="#topic+Baseline">Baseline</a> object returned from <a href="#topic+groupBaseline">groupBaseline</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Subset example data as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHM", "IGHG"))
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=100)

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id",
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)
                     
# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)
 
# Grouping the PDFs by the sample and isotype annotations
grouped &lt;- groupBaseline(baseline, groupBy=c("sample_id", "c_call"))

# Plot density faceted by region with custom isotype colors
isotype_colors &lt;- c("IGHM"="darkorchid", "IGHD"="firebrick", 
                    "IGHG"="seagreen", "IGHA"="steelblue")
plotBaselineDensity(grouped, "sample_id", "c_call", colorValues=isotype_colors, 
                    colorElement="group", sigmaLimits=c(-1, 1))

# Facet by isotype instead of region
sample_colors &lt;- c("-1h"="steelblue", "+7d"="firebrick")
plotBaselineDensity(grouped, "sample_id", "c_call", facetBy="group",
                    colorValues=sample_colors, sigmaLimits=c(-1, 1))

## End(Not run)

</code></pre>

<hr>
<h2 id='plotBaselineSummary'>Plots BASELINe summary statistics</h2><span id='topic+plotBaselineSummary'></span>

<h3>Description</h3>

<p><code>plotBaselineSummary</code> plots a summary of the results of selection analysis 
using the BASELINe method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBaselineSummary(
  baseline,
  idColumn,
  groupColumn = NULL,
  groupColors = NULL,
  subsetRegions = NULL,
  facetBy = c("region", "group"),
  title = NULL,
  style = c("summary"),
  size = 1,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBaselineSummary_+3A_baseline">baseline</code></td>
<td>
<p>either a data.frame returned from <a href="#topic+summarizeBaseline">summarizeBaseline</a>
or a <code>Baseline</code> object returned from <a href="#topic+groupBaseline">groupBaseline</a>
containing selection probability density functions and summary 
statistics.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_idcolumn">idColumn</code></td>
<td>
<p>name of the column in <code>baseline</code> containing primary identifiers. 
If the input is a <code>Baseline</code> object, then this will be a column
in the <code>stats</code> slot of <code>baseline</code>.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_groupcolumn">groupColumn</code></td>
<td>
<p>name of the column in <code>baseline</code> containing secondary grouping 
identifiers. If the input is a <code>Baseline</code> object, then this will 
be a column in the <code>stats</code> slot of <code>baseline</code>.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_groupcolors">groupColors</code></td>
<td>
<p>named vector of colors for entries in <code>groupColumn</code>, with 
names defining unique values in the <code>groupColumn</code> and values
being colors. Also controls the order in which groups appear on the
plot. If <code>NULL</code> alphabetical ordering and a default color palette 
will be used. Has no effect if <code>facetBy="group"</code>.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_subsetregions">subsetRegions</code></td>
<td>
<p>character vector defining a subset of regions to plot, correspoding 
to the regions for which the <code>baseline</code> data was calculated. If
<code>NULL</code> all regions in <code>baseline</code> are plotted.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_facetby">facetBy</code></td>
<td>
<p>one of c(&quot;group&quot;, &quot;region&quot;) specifying which category to facet the
plot by, either values in <code>groupColumn</code> (&quot;group&quot;) or regions
defined in <code>baseline</code> (&quot;region&quot;). The data that is not used
for faceting will be color coded.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_title">title</code></td>
<td>
<p>string defining the plot title.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_style">style</code></td>
<td>
<p>type of plot to draw. One of:
</p>

<ul>
<li> <p><code>"summary"</code>:  plots the mean and confidence interval for
the selection scores of each value in 
<code>idColumn</code>. Faceting and coloring
are determine by values in <code>groupColumn</code>
and regions defined in <code>baseline</code>, 
depending upon the <code>facetBy</code> argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_size">size</code></td>
<td>
<p>numeric scaling factor for lines, points and text in the plot.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotBaselineSummary_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object defining the plot.
</p>


<h3>See Also</h3>

<p>Takes as input either a <a href="#topic+Baseline">Baseline</a> object returned by <a href="#topic+groupBaseline">groupBaseline</a> 
or a data.frame returned from <a href="#topic+summarizeBaseline">summarizeBaseline</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHM", "IGHG"))
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=25)

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id",
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)
                     
# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)
 
# Grouping the PDFs by sample and isotype annotations
grouped &lt;- groupBaseline(baseline, groupBy=c("sample_id", "c_call"))

# Plot mean and confidence interval by region with custom group colors
isotype_colors &lt;- c("IGHM"="darkorchid", "IGHD"="firebrick", 
                    "IGHG"="seagreen", "IGHA"="steelblue")
plotBaselineSummary(grouped, "sample_id", "c_call", 
                    groupColors=isotype_colors, facetBy="region")


</code></pre>

<hr>
<h2 id='plotDensityThreshold'>Plot findThreshold results for the density method</h2><span id='topic+plotDensityThreshold'></span>

<h3>Description</h3>

<p><code>plotDensityThreshold</code> plots the results from <code>"density"</code> method of 
<a href="#topic+findThreshold">findThreshold</a>, including the smoothed density estimate, input nearest neighbor 
distance histogram, and threshold selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDensityThreshold(
  data,
  cross = NULL,
  xmin = NULL,
  xmax = NULL,
  breaks = NULL,
  binwidth = NULL,
  title = NULL,
  size = 1,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotDensityThreshold_+3A_data">data</code></td>
<td>
<p><a href="#topic+DensityThreshold">DensityThreshold</a> object output by the <code>"density"</code> method 
of <a href="#topic+findThreshold">findThreshold</a>.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_cross">cross</code></td>
<td>
<p>numeric vector of distances from <a href="#topic+distToNearest">distToNearest</a> to draw as a
histogram below the <code>data</code> histogram for comparison purposes.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_xmin">xmin</code></td>
<td>
<p>minimum limit for plotting the x-axis. If <code>NULL</code> the limit will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_xmax">xmax</code></td>
<td>
<p>maximum limit for plotting the x-axis. If <code>NULL</code> the limit will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks to show on the x-axis. If <code>NULL</code> the breaks will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_binwidth">binwidth</code></td>
<td>
<p>binwidth for the histogram. If <code>NULL</code> the binwidth 
will be set automatically to the bandwidth parameter determined by
<a href="#topic+findThreshold">findThreshold</a>.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_title">title</code></td>
<td>
<p>string defining the plot title.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_size">size</code></td>
<td>
<p>numeric value for the plot line sizes.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotDensityThreshold_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+DensityThreshold">DensityThreshold</a> for the the input object definition and 
<a href="#topic+findThreshold">findThreshold</a> for generating the input object. See 
<a href="#topic+distToNearest">distToNearest</a> calculating nearest neighbor distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, sample_id == "-1h")

# Use nucleotide Hamming distance and normalize by junction length
db &lt;- distToNearest(db, sequenceColumn="junction", vCallColumn="v_call_genotyped",
                    jCallColumn="j_call", model="ham", normalize="len", nproc=1)

# To find the threshold cut, call findThreshold function for "gmm" method.
output &lt;- findThreshold(db$dist_nearest, method="density")
print(output)

# Plot
plotDensityThreshold(output)

</code></pre>

<hr>
<h2 id='plotGmmThreshold'>Plot findThreshold results for the gmm method</h2><span id='topic+plotGmmThreshold'></span>

<h3>Description</h3>

<p><code>plotGmmThreshold</code> plots the results from <code>"gmm"</code> method of 
<a href="#topic+findThreshold">findThreshold</a>, including the Gaussian distributions, input nearest neighbor 
distance histogram, and threshold selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGmmThreshold(
  data,
  cross = NULL,
  xmin = NULL,
  xmax = NULL,
  breaks = NULL,
  binwidth = NULL,
  title = NULL,
  size = 1,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotGmmThreshold_+3A_data">data</code></td>
<td>
<p><a href="#topic+GmmThreshold">GmmThreshold</a> object output by the <code>"gmm"</code> method 
of <a href="#topic+findThreshold">findThreshold</a>.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_cross">cross</code></td>
<td>
<p>numeric vector of distances from <a href="#topic+distToNearest">distToNearest</a> to draw as a
histogram below the <code>data</code> histogram for comparison purposes.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_xmin">xmin</code></td>
<td>
<p>minimum limit for plotting the x-axis. If <code>NULL</code> the limit will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_xmax">xmax</code></td>
<td>
<p>maximum limit for plotting the x-axis. If <code>NULL</code> the limit will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks to show on the x-axis. If <code>NULL</code> the breaks will 
be set automatically.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_binwidth">binwidth</code></td>
<td>
<p>binwidth for the histogram. If <code>NULL</code> the binwidth 
will be set automatically.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_title">title</code></td>
<td>
<p>string defining the plot title.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_size">size</code></td>
<td>
<p>numeric value for lines in the plot.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
object; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotGmmThreshold_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object defining the plot.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+GmmThreshold">GmmThreshold</a> for the the input object definition and 
<a href="#topic+findThreshold">findThreshold</a> for generating the input object. See 
<a href="#topic+distToNearest">distToNearest</a> calculating nearest neighbor distances.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one sample as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, sample_id == "-1h")

# Use nucleotide Hamming distance and normalize by junction length
db &lt;- distToNearest(db, sequenceColumn="junction", vCallColumn="v_call_genotyped",
                    jCallColumn="j_call", model="ham", normalize="len", nproc=1)

# To find the threshold cut, call findThreshold function for "gmm" method.
output &lt;- findThreshold(db$dist_nearest, method="gmm", model="norm-norm", cutoff="opt")
print(output)

# Plot results
plotGmmThreshold(output, binwidth=0.02)

</code></pre>

<hr>
<h2 id='plotMutability'>Plot mutability probabilities</h2><span id='topic+plotMutability'></span>

<h3>Description</h3>

<p><code>plotMutability</code> plots the mutability rates of a <code>TargetingModel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMutability(
  model,
  nucleotides = c("A", "C", "G", "T"),
  mark = NULL,
  style = c("hedgehog", "bar"),
  size = 1,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotMutability_+3A_model">model</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object or vector containing normalized 
mutability rates.</p>
</td></tr>
<tr><td><code id="plotMutability_+3A_nucleotides">nucleotides</code></td>
<td>
<p>vector of center nucleotide characters to plot.</p>
</td></tr>
<tr><td><code id="plotMutability_+3A_mark">mark</code></td>
<td>
<p>vector of 5-mer motifs to highlight in the plot. If <code>NULL</code>
only highlight classical hot and cold spot motifs.</p>
</td></tr>
<tr><td><code id="plotMutability_+3A_style">style</code></td>
<td>
<p>type of plot to draw. One of:
</p>

<ul>
<li> <p><code>"hedgehog"</code>:  circular plot showing higher mutability
scores further from the circle. The 5-mer
is denoted by the values of the inner 
circle. The 5-mer is read from the most interior 
position of the 5-mer (5') to most exterior position 
(3'), with the center nucleotide in the center ring.
Note, the order in which the 5-mers are plotted is
different for nucleotides <code>c("A", "C")</code> and 
<code>c("G", "T")</code>.
</p>
</li>
<li> <p><code>"bar"</code>:       bar plot of mutability similar to the 
<code>hedgehog</code> style with the most 5' positions
of each 5-mer at the base of the plot.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plotMutability_+3A_size">size</code></td>
<td>
<p>numeric scaling factor for lines and text in the plot.</p>
</td></tr>
<tr><td><code id="plotMutability_+3A_silent">silent</code></td>
<td>
<p>if <code>TRUE</code> do not draw the plot and just return the ggplot2 
objects; if <code>FALSE</code> draw the plot.</p>
</td></tr>
<tr><td><code id="plotMutability_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to ggplot2::theme.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of ggplot objects defining the plots, with names defined by the 
center nucleotide for the plot object.
</p>


<h3>See Also</h3>

<p>Takes as input a <a href="#topic+TargetingModel">TargetingModel</a> object. 
See <a href="#topic+createTargetingModel">createTargetingModel</a> for model building.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot one nucleotide in circular style
plotMutability(HH_S5F, "C")

# Plot two nucleotides in barchart style
plotMutability(HH_S5F, c("G", "T"), style="bar")

</code></pre>

<hr>
<h2 id='plotSlideWindowTune'>Visualize parameter tuning for sliding window approach</h2><span id='topic+plotSlideWindowTune'></span>

<h3>Description</h3>

<p>Visualize results from <a href="#topic+slideWindowTune">slideWindowTune</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSlideWindowTune(
  tuneList,
  plotFiltered = c("filtered", "remaining", "per_mutation"),
  percentage = FALSE,
  jitter.x = FALSE,
  jitter.x.amt = 0.1,
  jitter.y = FALSE,
  jitter.y.amt = 0.1,
  pchs = 1:length(tuneList),
  ltys = 1:length(tuneList),
  cols = 1,
  plotLegend = TRUE,
  legendPos = "topright",
  legendHoriz = FALSE,
  legendCex = 1,
  title = NULL,
  returnRaw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSlideWindowTune_+3A_tunelist">tuneList</code></td>
<td>
<p>a list of logical matrices returned by <a href="#topic+slideWindowTune">slideWindowTune</a>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_plotfiltered">plotFiltered</code></td>
<td>
<p>whether to plot the number of filtered ('filtered'), 
or remaining ('remaining') sequences for each mutation threshold. 
Use 'per_mutation' to plot the number of sequences at each mutation
value. Default is <code>'filtered'</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_percentage">percentage</code></td>
<td>
<p>whether to plot on the y-axis the percentage of filtered sequences
(as opposed to the absolute number). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_jitter.x">jitter.x</code></td>
<td>
<p>whether to jitter x-axis values. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_jitter.x.amt">jitter.x.amt</code></td>
<td>
<p>amount of jittering to be applied on x-axis values if 
<code>jitter.x=TRUE</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_jitter.y">jitter.y</code></td>
<td>
<p>whether to jitter y-axis values. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_jitter.y.amt">jitter.y.amt</code></td>
<td>
<p>amount of jittering to be applied on y-axis values if 
<code>jitter.y=TRUE</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_pchs">pchs</code></td>
<td>
<p>point types to pass on to <a href="base.html#topic+plot">plot</a>. Default is
<code>1:length(tuneList)</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_ltys">ltys</code></td>
<td>
<p>line types to pass on to <a href="base.html#topic+plot">plot</a>. Default is
<code>1:length(tuneList)</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_cols">cols</code></td>
<td>
<p>colors to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_plotlegend">plotLegend</code></td>
<td>
<p>whether to plot legend. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_legendpos">legendPos</code></td>
<td>
<p>position of legend to pass on to <a href="graphics.html#topic+legend">legend</a>. Can be either a
numeric vector specifying x-y coordinates, or one of 
<code>"topright"</code>, <code>"center"</code>, etc. Default is <code>"topright"</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_legendhoriz">legendHoriz</code></td>
<td>
<p>whether to make legend horizontal. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_legendcex">legendCex</code></td>
<td>
<p>numeric values by which legend should be magnified relative to 1.</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_title">title</code></td>
<td>
<p>plot main title. Default is NULL (no title)</p>
</td></tr>
<tr><td><code id="plotSlideWindowTune_+3A_returnraw">returnRaw</code></td>
<td>
<p>Return a data.frame with sequence counts (TRUE) or a
plot. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>windowSize</code>, if <code>plotFiltered='filtered'</code>, the x-axis 
represents a mutation threshold range, and the y-axis the number of
sequences that have at least that number of mutations. If 
<code>plotFiltered='remaining'</code>, the y-axis represents the number of sequences
that have less mutations than the mutation threshold range. For the same
window size, a sequence can be included in the counts for different
mutation thresholds. For example, sequence &quot;CCACCAAAA&quot; with germline
&quot;AAAAAAAAA&quot; has 4 mutations. This sequence has at least 2 mutations 
and at least 3 mutations, in a window of size 4. the sequence will
be included in the sequence count for mutation thresholds 2 and 3.
If <code>plotFiltered='per_mutation'</code>, the sequences are counted only once 
for each window size, at their largest mutation threshold. The above 
example sequence would be included in the sequence count for 
mutation threshold 3. 
</p>
<p>When plotting, a user-defined <code>amount</code> of jittering can be applied on values plotted
on either axis or both axes via adjusting <code>jitter.x</code>, <code>jitter.y</code>, 
<code>jitter.x.amt</code> and <code>jitter.y.amt</code>. This may be help with visually distinguishing
lines for different window sizes in case they are very close or identical to each other. 
If plotting percentages (<code>percentage=TRUE</code>) and using jittering on the y-axis values 
(<code>jitter.y=TRUE</code>), it is strongly recommended that <code>jitter.y.amt</code> be set very
small (e.g. 0.01). 
</p>
<p><code>NA</code> for a combination of <code>mutThresh</code> and <code>windowSize</code> where 
<code>mutThresh</code> is greater than <code>windowSize</code> will not be plotted.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+slideWindowTune">slideWindowTune</a> for how to get <code>tuneList</code>. See <a href="base.html#topic+jitter">jitter</a> for 
use of <code>amount</code> of jittering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use an entry in the example data for input and germline sequence
data(ExampleDb, package="alakazam")

# Try out thresholds of 2-4 mutations in window sizes of 3-5 nucleotides 
# on a subset of ExampleDb
tuneList &lt;- slideWindowTune(db = ExampleDb[1:10, ], 
                           mutThreshRange = 2:4, windowSizeRange = 3:5,
                           verbose = FALSE)

# Visualize
# Plot numbers of sequences filtered without jittering y-axis values
plotSlideWindowTune(tuneList, pchs=1:3, ltys=1:3, cols=1:3, 
                    plotFiltered='filtered', jitter.y=FALSE)
                    
# Notice that some of the lines overlap
# Jittering could help
plotSlideWindowTune(tuneList, pchs=1:3, ltys=1:3, cols=1:3,
                    plotFiltered='filtered', jitter.y=TRUE)
                    
# Plot numbers of sequences remaining instead of filtered
plotSlideWindowTune(tuneList, pchs=1:3, ltys=1:3, cols=1:3, 
                    plotFiltered='remaining', jitter.y=TRUE, 
                    legendPos="bottomright")
                    
# Plot percentages of sequences filtered with a tiny amount of jittering
plotSlideWindowTune(tuneList, pchs=1:3, ltys=1:3, cols=1:3,
                    plotFiltered='filtered', percentage=TRUE, 
                    jitter.y=TRUE, jitter.y.amt=0.01)
</code></pre>

<hr>
<h2 id='plotTune'>Visualize parameter tuning for minNumMutations and minNumSeqMutations</h2><span id='topic+plotTune'></span>

<h3>Description</h3>

<p>Visualize results from <a href="#topic+minNumMutationsTune">minNumMutationsTune</a> and <a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTune(
  tuneMtx,
  thresh,
  criterion = c("5mer", "3mer", "1mer", "3mer+1mer", "measured", "inferred"),
  pchs = 1,
  ltys = 2,
  cols = 1,
  plotLegend = TRUE,
  legendPos = "topright",
  legendHoriz = FALSE,
  legendCex = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotTune_+3A_tunemtx">tuneMtx</code></td>
<td>
<p>a <code>matrix</code> or a <code>list</code> of matrices produced by either 
<a href="#topic+minNumMutationsTune">minNumMutationsTune</a> or <a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>.
In the case of a list, it is assumed that each matrix corresponds
to a sample and that all matrices in the list were produced using
the same set of trial values of <code>minNumMutations</code> or 
<code>minNumSeqMutations</code>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_thresh">thresh</code></td>
<td>
<p>a number or a vector of indicating the value or the range of values
of <code>minNumMutations</code> or <code>minNumSeqMutations</code> to plot. 
Should correspond to the columns of <code>tuneMtx</code>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_criterion">criterion</code></td>
<td>
<p>one of <code>"5mer"</code>, <code>"3mer"</code>, <code>"1mer"</code>, or <code>"3mer+1mer"</code> 
(for <code>tuneMtx</code> produced by <a href="#topic+minNumMutationsTune">minNumMutationsTune</a>), or either 
<code>"measured"</code> or <code>"inferred"</code> (for <code>tuneMtx</code> produced by 
<a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>).</p>
</td></tr>
<tr><td><code id="plotTune_+3A_pchs">pchs</code></td>
<td>
<p>point types to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_ltys">ltys</code></td>
<td>
<p>line types to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_cols">cols</code></td>
<td>
<p>colors to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_plotlegend">plotLegend</code></td>
<td>
<p>whether to plot legend. Default is <code>TRUE</code>. Only applicable 
if <code>tuneMtx</code> is a named list with names of the matrices 
corresponding to the names of the samples.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_legendpos">legendPos</code></td>
<td>
<p>position of legend to pass on to <a href="graphics.html#topic+legend">legend</a>. Can be either a
numeric vector specifying x-y coordinates, or one of 
<code>"topright"</code>, <code>"center"</code>, etc. Default is <code>"topright"</code>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_legendhoriz">legendHoriz</code></td>
<td>
<p>whether to make legend horizontal. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotTune_+3A_legendcex">legendCex</code></td>
<td>
<p>numeric values by which legend should be magnified relative to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>tuneMtx</code> produced by <a href="#topic+minNumMutationsTune">minNumMutationsTune</a>, for each sample, depending on
<code>criterion</code>, the numbers of 5-mers for which substitution rates are directly computed
(<code>"5mer"</code>), inferred based on inner 3-mers (<code>"3mer"</code>), inferred based on 
central 1-mers (<code>"1mer"</code>), or inferred based on inner 3-mers and central 1-mers
(<code>"3mer+1mer"</code>) are plotted on the y-axis against values of <code>minNumMutations</code> 
on the x-axis.
</p>
<p>For <code>tuneMtx</code> produced by <a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a>, for each sample, depending on
<code>criterion</code>, the numbers of 5-mers for which mutability rates are directly measured
(<code>"measured"</code>) or inferred (<code>"inferred"</code>) are plotted on the y-axis against values
of <code>minNumSeqMutations</code> on the x-axis.
</p>
<p>Note that legends will be plotted only if <code>tuneMtx</code> is a supplied as a named <code>list</code>
of matrices, ideally with names of each <code>matrix</code> corresponding to those of the samples 
based on which the matrices were produced, even if <code>plotLegend=TRUE</code>.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+minNumMutationsTune">minNumMutationsTune</a> and <a href="#topic+minNumSeqMutationsTune">minNumSeqMutationsTune</a> for generating 
<code>tuneMtx</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data to one isotype and 200 sequences
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHA")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=50)

tuneMtx = list()
for (i in 1:length(unique(db$sample_id))) {
    # Get data corresponding to current sample
    curDb = db[db[["sample_id"]] == unique(db[["sample_id"]])[i], ]
    
    # Count the number of mutations per 5-mer
    subCount = createSubstitutionMatrix(db=curDb, model="s", 
                                        sequenceColumn="sequence_alignment",
                                        germlineColumn="germline_alignment_d_mask",
                                        vCallColumn="v_call",
                                        multipleMutation="independent",
                                        returnModel="5mer", numMutationsOnly=TRUE)
    
    # Tune over minNumMutations = 5..50
    subTune = minNumMutationsTune(subCount, seq(from=5, to=50, by=5))
    
    tuneMtx = c(tuneMtx, list(subTune))
}

# Name tuneMtx after sample names 
names(tuneMtx) = unique(db[["sample_id"]])

# plot with legend for both samples for a subset of minNumMutations values
plotTune(tuneMtx, thresh=c(5, 15, 25, 40), criterion="3mer",
         pchs=16:17, ltys=1:2, cols=2:3, 
         plotLegend=TRUE, legendPos=c(25, 30))

# plot for only 1 sample for all the minNumMutations values (no legend)
plotTune(tuneMtx[[1]], thresh=seq(from=5, to=50, by=5), criterion="3mer")


</code></pre>

<hr>
<h2 id='RegionDefinition-class'>S4 class defining a region definition</h2><span id='topic+RegionDefinition-class'></span><span id='topic+RegionDefinition'></span>

<h3>Description</h3>

<p><code>RegionDefinition</code> defines a common data structure for defining the region
boundaries of an Ig sequence.
</p>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>name of the RegionDefinition.</p>
</dd>
<dt><code>description</code></dt><dd><p>description of the model and its source.</p>
</dd>
<dt><code>boundaries</code></dt><dd><p><code>factor</code> defining the region boundaries of the 
sequence. The levels and values of <code>boundaries</code> 
determine the number of regions.</p>
</dd>
<dt><code>seqLength</code></dt><dd><p>length of the sequence.</p>
</dd>
<dt><code>regions</code></dt><dd><p>levels of the boundaries; e.g, <code>c("cdr", "fwr")</code>.</p>
</dd>
<dt><code>labels</code></dt><dd><p>labels for the boundary and mutations combinations;
e.g., <code>c("cdr_r", "cdr_s", "fwr_r", "fwr_s")</code>.</p>
</dd>
<dt><code>citation</code></dt><dd><p>publication source.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+IMGT_SCHEMES">IMGT_SCHEMES</a> for a set of predefined <code>RegionDefinition</code> objects.
</p>

<hr>
<h2 id='setRegionBoundaries'>Build a RegionDefinition object that includes CDR3 and FWR4.</h2><span id='topic+setRegionBoundaries'></span>

<h3>Description</h3>

<p><code>setRegionBoundaries</code> takes as input a junction length and an IMGT-numbered sequence
and outputs a custom <code>RegionDefinition</code> object that includes the boundary definitions of 
CDR1-3 and FWR1-4 for that sequence. In contrast to the universal <code>RegionDefinition</code> object 
that end with FWR3, the returned definition is per-sequence due to variable junction lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setRegionBoundaries(juncLength, sequenceImgt, regionDefinition = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setRegionBoundaries_+3A_junclength">juncLength</code></td>
<td>
<p>junction length of the sequence.</p>
</td></tr>
<tr><td><code id="setRegionBoundaries_+3A_sequenceimgt">sequenceImgt</code></td>
<td>
<p>IMGT-numbered sequence.</p>
</td></tr>
<tr><td><code id="setRegionBoundaries_+3A_regiondefinition">regionDefinition</code></td>
<td>
<p><code>RegionDefinition</code> type to calculate the region definition for. 
Can be one of <code>IMGT_VDJ_BY_REGIONS</code> or <code>IMGT_VDJ</code>,
which are template definitions that include CDR1-3 and FWR1-4. 
Only these two regions include all CDR1-3 and FWR1-4 regions.
If this argument is set to <code>NULL</code>, then an empty 
<code>RegionDefinition</code> will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>RegionDefinition</code> object that includes CDR1-3 and FWR1-4 for the  
<code>sequenceImgt</code>, <code>juncLength</code>, and <code>regionDefinition</code> specified.
</p>
<p>For <code>regionDefinition=IMGT_VDJ_BY_REGIONS</code>, the returned <code>RegionDefinition</code> 
includes:
</p>

<ul>
<li>  <p><code>fwr1</code>:   Positions 1 to 78.
</p>
</li>
<li>  <p><code>cdr1</code>:   Positions 79 to 114.
</p>
</li>
<li>  <p><code>fwr2</code>:   Positions 115 to 165.
</p>
</li>
<li>  <p><code>cdr2</code>:   Positions 166 to 195.
</p>
</li>
<li>  <p><code>fwr3</code>:   Positions 196 to 312.
</p>
</li>
<li>  <p><code>cdr3</code>:   Positions 313 to (313 + juncLength - 6) since the junction 
sequence includes (on the left) the last codon from FWR3 and 
(on the right) the first codon from FWR4.  
</p>
</li>
<li>  <p><code>fwr4</code>:   Positions (313 + juncLength - 6 + 1) to the end of the sequence.
</p>
</li></ul>

<p>For <code>regionDefinition=IMGT_VDJ</code>, the returned <code>RegionDefinition</code> includes:
</p>

<ul>
<li>  <p><code>fwr</code>:   Positions belonging to a FWR.
</p>
</li>
<li>  <p><code>cdr</code>:   Positions belonging to a CDR.
</p>
</li></ul>

<p>In the case that the <code>regionDefinition</code> argument is not one of the extended
regions (<code>IMGT_VDJ_BY_REGIONS</code> or <code>IMGT_VDJ</code>), the input 
<code>regionDefinition</code> is returned as is.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+RegionDefinition">RegionDefinition</a> for the return object. 
See <a href="#topic+IMGT_SCHEMES">IMGT_SCHEMES</a> for a set of predefined <code>RegionDefinition</code> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and subset example data
data(ExampleDb, package = "alakazam")  
len &lt;- ExampleDb$junction_length[1]
sequence &lt;- ExampleDb$sequence_alignment[1]
region &lt;- setRegionBoundaries(len, sequence, regionDefinition = IMGT_VDJ)

</code></pre>

<hr>
<h2 id='shazam'>The shazam package</h2><span id='topic+shazam'></span>

<h3>Description</h3>

<p>Dramatic improvements in high-throughput sequencing technologies now enable 
large-scale characterization of Ig repertoires, defined as the collection of transmembrane 
antigen-receptor proteins located on the surface of T and B lymphocytes. The <code>shazam</code>
package provides tools for advanced analysis of somatic hypermutation (SHM) in
immunoglobulin (Ig) sequences. The key functions in <code>shazam</code>, broken down topic, are 
described below.
</p>


<h3>Mutational profiling</h3>

<p><code>shazam</code> provides tools to quantify the extent and nature of SHM within
full length V(D)J sequences as well as sub-regions (eg, FWR and CDR).
Quantification of expected mutational loaded, under specific SHM targeting 
models, can also be performed along with model driven simulations of SHM.
</p>

<ul>
<li>  <p><a href="#topic+collapseClones">collapseClones</a>:           Build clonal consensus sequences.
</p>
</li>
<li>  <p><a href="#topic+consensusSequence">consensusSequence</a>:        Build a single consensus sequence.
</p>
</li>
<li>  <p><a href="#topic+observedMutations">observedMutations</a>:        Compute observed mutation counts and frequencies.
</p>
</li>
<li>  <p><a href="#topic+expectedMutations">expectedMutations</a>:        Compute expected mutation frequencies.
</p>
</li>
<li>  <p><a href="#topic+shmulateSeq">shmulateSeq</a>:              Simulate mutations in a single sequence.
</p>
</li>
<li>  <p><a href="#topic+shmulateTree">shmulateTree</a>:             Simulate mutations over a lineage tree.
</p>
</li>
<li>  <p><a href="#topic+setRegionBoundaries">setRegionBoundaries</a>:      Extends a region definition to include CDR3 and FWR4.
</p>
</li></ul>



<h3>SHM targeting models</h3>

<p>Computational models and analyses of SHM have separated the process 
into two independent components: 
</p>

<ol>
<li><p>  A mutability model that defines where mutations occur.
</p>
</li>
<li><p>  A nucleotide substitution model that defines the resulting mutation.
</p>
</li></ol>

<p>Collectively these are what form the targeting model of SHM. <code>shazam</code> 
provides empirically derived targeting models for both humans and mice,
along with tools to build these mutability and substitution models from data.
</p>

<ul>
<li>  <p><a href="#topic+createTargetingModel">createTargetingModel</a>:     Build a 5-mer targeting model.
</p>
</li>
<li>  <p><a href="#topic+plotMutability">plotMutability</a>:           Plot 5-mer mutability rates.
</p>
</li>
<li>  <p><a href="#topic+HH_S5F">HH_S5F</a>:                   Human 5-mer SHM targeting model.
</p>
</li>
<li>  <p><a href="#topic+MK_RS5NF">MK_RS5NF</a>:                 Mouse 5-mer SHM targeting model.
</p>
</li></ul>



<h3>Quantification of selection pressure</h3>

<p>Bayesian Estimation of Antigen-driven Selection in Ig Sequences is a 
novel method for quantifying antigen-driven selection in high-throughput
Ig sequence data. Targeting models created using <code>shazam</code> can be used 
to estimate the null distribution of expected mutation frequencies used
by BASELINe, providing measures of selection pressure informed by known 
AID targeting biases.
</p>

<ul>
<li>  <p><a href="#topic+calcBaseline">calcBaseline</a>:             Calculate the BASELINe probability
density functions (PDFs).
</p>
</li>
<li>  <p><a href="#topic+groupBaseline">groupBaseline</a>:            Combine PDFs from sequences grouped
by biological or experimental relevance.
</p>
</li>
<li>  <p><a href="#topic+summarizeBaseline">summarizeBaseline</a>:        Compute summary statistics from BASELINe PDFs.
</p>
</li>
<li>  <p><a href="#topic+testBaseline">testBaseline</a>:             Perform significance testing for the difference
between BASELINe PDFs.
</p>
</li>
<li>  <p><a href="#topic+plotBaselineDensity">plotBaselineDensity</a>:      Plot the probability density functions
resulting from selection analysis.
</p>
</li>
<li>  <p><a href="#topic+plotBaselineSummary">plotBaselineSummary</a>:      Plot summary stastistics resulting from 
selection analysis.
</p>
</li></ul>



<h3>Mutational distance calculation</h3>

<p><code>shazam</code> provides tools to compute evolutionary distances between 
sequences or groups of sequences, which can leverage SHM targeting 
models. This information is particularly useful in understanding and 
defining clonal relationships.
</p>

<ul>
<li>  <p><a href="#topic+findThreshold">findThreshold</a>:            Identify clonal assignment threshold based on 
distances to nearest neighbors.
</p>
</li>
<li>  <p><a href="#topic+distToNearest">distToNearest</a>:            Tune clonal assignment thresholds by calculating 
distances to nearest neighbors.
</p>
</li>
<li>  <p><a href="#topic+calcTargetingDistance">calcTargetingDistance</a>:    Construct a nucleotide distance matrix from a 
5-mer targeting model.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Hershberg U, et al. Improved methods for detecting selection by mutation 
analysis of Ig V region sequences. 
Int Immunol. 2008 20(5):683-94.
</p>
</li>
<li><p>  Uduman M, et al. Detecting selection in immunoglobulin sequences. 
Nucleic Acids Res. 2011 39(Web Server issue):W499-504. (Corrections at 
http://selection.med.yale.edu/baseline/correction/) 
</p>
</li>
<li><p>  Yaari G, et al. Quantifying selection in high-throughput immunoglobulin 
sequencing data sets. 
Nucleic Acids Res. 2012 40(17):e134.
</p>
</li>
<li><p>  Yaari G, et al. Models of somatic hypermutation targeting and substitution based 
on synonymous mutations from high-throughput immunoglobulin sequencing data. 
Front Immunol. 2013 4:358.
</p>
</li>
<li><p>  Cui A, Di Niro R, Vander Heiden J, Briggs A, Adams K, Gilbert T, O'Connor K,
Vigneault F, Shlomchik M and Kleinstein S (2016). A Model of Somatic Hypermutation 
Targeting in Mice Based on High-Throughput Ig Sequencing Data. The Journal of 
Immunology, 197(9), 3566-3574.
</p>
</li></ol>


<hr>
<h2 id='shmulateSeq'>Simulate mutations in a single sequence</h2><span id='topic+shmulateSeq'></span>

<h3>Description</h3>

<p>Generates random mutations in a sequence iteratively using a targeting model.
Targeting probabilities at each position are updated after each iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shmulateSeq(
  sequence,
  numMutations,
  targetingModel = HH_S5F,
  start = 1,
  end = nchar(sequence),
  frequency = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shmulateSeq_+3A_sequence">sequence</code></td>
<td>
<p>sequence string in which mutations are to be introduced.
Accepted alphabet: <code>{A, T, G, C, N, .}</code>. Note
that <code>-</code> is not accepted.</p>
</td></tr>
<tr><td><code id="shmulateSeq_+3A_nummutations">numMutations</code></td>
<td>
<p>a whole number indicating the number of mutations to be 
introduced into <code>sequence</code>, if <code>frequency=FALSE</code>.
A fraction bewteen 0 and 1 indicating the mutation frequency
if <code>frequency=TRUE</code>.</p>
</td></tr>
<tr><td><code id="shmulateSeq_+3A_targetingmodel">targetingModel</code></td>
<td>
<p>5-mer <a href="#topic+TargetingModel">TargetingModel</a> object to be used for computing 
probabilities of mutations at each position. Defaults to
<a href="#topic+HH_S5F">HH_S5F</a>.</p>
</td></tr>
<tr><td><code id="shmulateSeq_+3A_start">start</code></td>
<td>
<p>Initial position in <code>sequence</code> where mutations can 
be introduced. Default: 1</p>
</td></tr>
<tr><td><code id="shmulateSeq_+3A_end">end</code></td>
<td>
<p>Last position in <code>sequence</code> where mutations can 
be introduced. Default: last position (sequence length).</p>
</td></tr>
<tr><td><code id="shmulateSeq_+3A_frequency">frequency</code></td>
<td>
<p>If <code>TRUE</code>, treat <code>numMutations</code> as a frequency.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the input <code>sequence</code> has a non-triplet overhang at the end, it will be trimmed
to the last codon. For example, <code>ATGCATGC</code> will be trimmed to <code>ATGCAT</code>.
</p>
<p>Mutations are not introduced to positions in the input <code>sequence</code> that contain 
<code>.</code> or <code>N</code>.
</p>
<p>With <code>frequency=TRUE</code>, the number of mutations introduced is the <code>floor</code> of 
the length of the sequence multiplied by the mutation frequency specified via
<code>numMutations</code>.
</p>


<h3>Value</h3>

<p>A string defining the mutated sequence.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+shmulateTree">shmulateTree</a> for imposing mutations on a lineage tree. 
See <a href="#topic+HH_S5F">HH_S5F</a> and <a href="#topic+MK_RS5NF">MK_RS5NF</a> for predefined 
<a href="#topic+TargetingModel">TargetingModel</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define example input sequence
sequence &lt;- "NGATCTGACGACACGGCCGTGTATTACTGTGCGAGAGATA.TTTA"

# Simulate using the default human 5-mer targeting model
# Introduce 6 mutations
shmulateSeq(sequence, numMutations=6, frequency=FALSE)

# Introduction 5% mutations
shmulateSeq(sequence, numMutations=0.05, frequency=TRUE)

</code></pre>

<hr>
<h2 id='shmulateTree'>Simulate mutations in a lineage tree</h2><span id='topic+shmulateTree'></span>

<h3>Description</h3>

<p><code>shmulateTree</code> returns a set of simulated sequences generated from an input 
sequence and a lineage tree. The input sequence is used to replace the most recent 
common ancestor (MRCA) node of the <code>igraph</code> object defining the lineage tree. 
Sequences are then simulated with mutations corresponding to edge weights in the tree. 
Sequences will not be generated for groups of nodes that are specified to be excluded.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shmulateTree(
  sequence,
  graph,
  targetingModel = HH_S5F,
  field = NULL,
  exclude = NULL,
  junctionWeight = NULL,
  start = 1,
  end = nchar(sequence)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shmulateTree_+3A_sequence">sequence</code></td>
<td>
<p>string defining the MRCA sequence to seed mutations from.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_graph">graph</code></td>
<td>
<p><code>igraph</code> object defining the seed lineage tree, with 
vertex annotations, whose edges are to be recreated.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_targetingmodel">targetingModel</code></td>
<td>
<p>5-mer <a href="#topic+TargetingModel">TargetingModel</a> object to be used for computing 
probabilities of mutations at each position. Defaults to
<a href="#topic+HH_S5F">HH_S5F</a>.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_field">field</code></td>
<td>
<p>annotation to use for both unweighted path length exclusion 
and consideration as the MRCA node. If <code>NULL</code> do not 
exclude any nodes.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_exclude">exclude</code></td>
<td>
<p>vector of annotation values in <code>field</code> to exclude from 
potential MRCA set. If <code>NULL</code> do not exclude any nodes.
Has no effect if <code>field=NULL</code>.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_junctionweight">junctionWeight</code></td>
<td>
<p>fraction of the nucleotide sequence that is within the 
junction region. When specified this adds a proportional 
number of mutations to the immediate offspring nodes of the 
MRCA. Requires a value between 0 and 1. If <code>NULL</code> then 
edge weights are unmodified from the input <code>graph</code>.</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_start">start</code></td>
<td>
<p>Initial position in <code>sequence</code> where mutations can 
be introduced. Default: 1</p>
</td></tr>
<tr><td><code id="shmulateTree_+3A_end">end</code></td>
<td>
<p>Last position in <code>sequence</code> where mutations can 
be introduced. Default: last position (sequence length).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> of simulated sequences with columns:
</p>

<ul>
<li> <p><code>name</code>:      name of the corresponding node in the input 
<code>graph</code>.  
</p>
</li>
<li> <p><code>sequence</code>:  mutated sequence.
</p>
</li>
<li> <p><code>distance</code>:  Hamming distance of the mutated sequence from 
the seed <code>sequence</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>See <a href="#topic+shmulateSeq">shmulateSeq</a> for imposing mutations on a single sequence. 
See <a href="#topic+HH_S5F">HH_S5F</a> and <a href="#topic+MK_RS5NF">MK_RS5NF</a> for predefined 
<a href="#topic+TargetingModel">TargetingModel</a> objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load example lineage and define example MRCA
data(ExampleTrees, package="alakazam")
graph &lt;- ExampleTrees[[17]]
sequence &lt;- "NGATCTGACGACACGGCCGTGTATTACTGTGCGAGAGATAGTTTA"

# Simulate using the default human 5-mer targeting model
shmulateTree(sequence, graph)

# Simulate using the mouse 5-mer targeting model
# Exclude nodes without a sample identifier
# Add 20% mutation rate to the immediate offsprings of the MRCA
shmulateTree(sequence, graph, targetingModel=MK_RS5NF,
             field="sample_id", exclude=NA, junctionWeight=0.2)
 
</code></pre>

<hr>
<h2 id='slideWindowDb'>Sliding window approach towards filtering sequences in a <code>data.frame</code></h2><span id='topic+slideWindowDb'></span>

<h3>Description</h3>

<p><code>slideWindowDb</code> determines whether each input sequence in a <code>data.frame</code> 
contains equal to or more than a given number of mutations in a given length of 
consecutive nucleotides (a &quot;window&quot;) when compared to their respective germline 
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideWindowDb(
  db,
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  mutThresh = 6,
  windowSize = 10,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideWindowDb_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="slideWindowDb_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped sample sequences.</p>
</td></tr>
<tr><td><code id="slideWindowDb_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="slideWindowDb_+3A_mutthresh">mutThresh</code></td>
<td>
<p>threshold on the number of mutations in <code>windowSize</code> 
consecutive nucleotides. Must be between 1 and <code>windowSize</code> 
inclusive.</p>
</td></tr>
<tr><td><code id="slideWindowDb_+3A_windowsize">windowSize</code></td>
<td>
<p>length of consecutive nucleotides. Must be at least 2.</p>
</td></tr>
<tr><td><code id="slideWindowDb_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to distribute the operation over. If the 
<code>cluster</code> has already been set earlier, then pass the 
<code>cluster</code>. This will ensure that it is not reset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector. The length of the vector matches the number of input sequences in 
<code>db</code>. Each entry in the vector indicates whether the corresponding input sequence
should be filtered based on the given parameters.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+slideWindowSeq">slideWindowSeq</a> for applying the sliding window approach on a single sequence. 
See <a href="#topic+slideWindowTune">slideWindowTune</a> for parameter tuning for <code>mutThresh</code> and <code>windowSize</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use an entry in the example data for input and germline sequence
data(ExampleDb, package="alakazam")

# Apply the sliding window approach on a subset of ExampleDb
slideWindowDb(db=ExampleDb[1:10, ], sequenceColumn="sequence_alignment", 
              germlineColumn="germline_alignment_d_mask", 
              mutThresh=6, windowSize=10, nproc=1)

</code></pre>

<hr>
<h2 id='slideWindowSeq'>Sliding window approach towards filtering a single sequence</h2><span id='topic+slideWindowSeq'></span>

<h3>Description</h3>

<p><code>slideWindowSeq</code> determines whether an input sequence contains equal to or more than 
a given number of mutations in a given length of consecutive nucleotides (a &quot;window&quot;) 
when compared to a germline sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideWindowSeq(inputSeq, germlineSeq, mutThresh, windowSize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideWindowSeq_+3A_inputseq">inputSeq</code></td>
<td>
<p>input sequence.</p>
</td></tr>
<tr><td><code id="slideWindowSeq_+3A_germlineseq">germlineSeq</code></td>
<td>
<p>germline sequence.</p>
</td></tr>
<tr><td><code id="slideWindowSeq_+3A_mutthresh">mutThresh</code></td>
<td>
<p>threshold on the number of mutations in <code>windowSize</code> 
consecutive nucleotides. Must be between 1 and <code>windowSize</code> 
inclusive.</p>
</td></tr>
<tr><td><code id="slideWindowSeq_+3A_windowsize">windowSize</code></td>
<td>
<p>length of consecutive nucleotides. Must be at least 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if there are equal to or more than <code>mutThresh</code> number of mutations
in any window of <code>windowSize</code> consecutive nucleotides (i.e. the sequence should
be filtered); <code>FALSE</code> if otherwise.
</p>


<h3>See Also</h3>

<p><a href="#topic+calcObservedMutations">calcObservedMutations</a> is called by <code>slideWindowSeq</code> to identify observed 
mutations. See <a href="#topic+slideWindowDb">slideWindowDb</a> for applying the sliding window approach on a 
<code>data.frame</code>. See <a href="#topic+slideWindowTune">slideWindowTune</a> for parameter tuning for <code>mutThresh</code>
and <code>windowSize</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use an entry in the example data for input and germline sequence
data(ExampleDb, package="alakazam")
in_seq &lt;- ExampleDb[["sequence_alignment"]][100]
germ_seq &lt;-  ExampleDb[["germline_alignment_d_mask"]][100]

# Determine if in_seq has 6 or more mutations in 10 consecutive nucleotides
slideWindowSeq(inputSeq=in_seq, germlineSeq=germ_seq, mutThresh=6, windowSize=10)
slideWindowSeq(inputSeq="TCGTCGAAAA", germlineSeq="AAAAAAAAAA", mutThresh=6, windowSize=10)
</code></pre>

<hr>
<h2 id='slideWindowTune'>Parameter tuning for sliding window approach</h2><span id='topic+slideWindowTune'></span>

<h3>Description</h3>

<p>Apply <a href="#topic+slideWindowDb">slideWindowDb</a> over a search grid made of combinations of <code>mutThresh</code> and 
<code>windowSize</code> to help with picking a pair of values for these parameters. Parameter 
tuning can be performed by choosing a combination that gives a reasonable number of 
filtered/remaining sequences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideWindowTune(
  db,
  sequenceColumn = "sequence_alignment",
  germlineColumn = "germline_alignment_d_mask",
  dbMutList = NULL,
  mutThreshRange,
  windowSizeRange,
  verbose = TRUE,
  nproc = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideWindowTune_+3A_db">db</code></td>
<td>
<p><code>data.frame</code> containing sequence data.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_sequencecolumn">sequenceColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped sample sequences.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_germlinecolumn">germlineColumn</code></td>
<td>
<p>name of the column containing IMGT-gapped germline sequences.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_dbmutlist">dbMutList</code></td>
<td>
<p>if supplied, this should be a list consisting of <code>data.frame</code>s 
returned as <code>$pos</code> in the nested list produced by 
<a href="#topic+calcObservedMutations">calcObservedMutations</a> with <code>returnRaw=TRUE</code>; otherwise, 
<a href="#topic+calcObservedMutations">calcObservedMutations</a> is called on columns <code>sequenceColumn</code>
and <code>germlineColumn</code> of <code>db</code>. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_mutthreshrange">mutThreshRange</code></td>
<td>
<p>range of threshold on the number of mutations in <code>windowSize</code> 
consecutive nucleotides to try. Must be between 1 and 
maximum <code>windowSizeRange</code> inclusive.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_windowsizerange">windowSizeRange</code></td>
<td>
<p>range of length of consecutive nucleotides to try. The lower end
must be at least 2.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_verbose">verbose</code></td>
<td>
<p>whether to print out messages indicating current progress. Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTune_+3A_nproc">nproc</code></td>
<td>
<p>Number of cores to distribute the operation over. If the 
<code>cluster</code> has already been set earlier, then pass the 
<code>cluster</code>. This will ensure that it is not reset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If, in a given combination of <code>mutThresh</code> and <code>windowSize</code>, <code>mutThresh</code> 
is greater than <code>windowSize</code>, <code>NA</code>s will be returned for that particular
combination. A message indicating that the combination has been &quot;skipped&quot; will be 
printed if <code>verbose=TRUE</code>.
</p>
<p>If <a href="#topic+calcObservedMutations">calcObservedMutations</a> was previously run on <code>db</code> and saved, supplying
<code>$pos</code> from the saved result as <code>dbMutList</code> could save time by skipping a
second call of <a href="#topic+calcObservedMutations">calcObservedMutations</a>. This could be helpful especially when 
<code>db</code> is large.
</p>


<h3>Value</h3>

<p>a list of logical matrices. Each matrix corresponds to a <code>windowSize</code> in 
<code>windowSizeRange</code>. Each column in a matrix corresponds to a <code>mutThresh</code> in
<code>mutThreshRange</code>. Each row corresponds to a sequence. <code>TRUE</code> values
mean the sequences has at least the number of mutations specified in the column name,
for that <code>windowSize</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+slideWindowDb">slideWindowDb</a> is called on <code>db</code> for tuning. See <a href="#topic+slideWindowTunePlot">slideWindowTunePlot</a> 
for visualization. See <a href="#topic+calcObservedMutations">calcObservedMutations</a> for generating <code>dbMutList</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load and subset example data
data(ExampleDb, package="alakazam")
db &lt;- ExampleDb[1:5, ]

# Try out thresholds of 2-4 mutations in window sizes of 7-9 nucleotides. 
# In this case, all combinations are legal.
slideWindowTune(db, mutThreshRange=2:4, windowSizeRange=7:9)

# Illegal combinations are skipped, returning NAs.
slideWindowTune(db, mutThreshRange=2:4, windowSizeRange=2:4, 
                verbose=FALSE)
                                                            
# Run calcObservedMutations separately
exDbMutList &lt;- sapply(1:5, function(i) {
    calcObservedMutations(inputSeq=db[["sequence_alignment"]][i],
                          germlineSeq=db[["germline_alignment_d_mask"]][i],
                          returnRaw=TRUE)$pos })
slideWindowTune(db, dbMutList=exDbMutList, 
                mutThreshRange=2:4, windowSizeRange=2:4)
</code></pre>

<hr>
<h2 id='slideWindowTunePlot'>slideWindowTunePlot - plotSlideWindowTune backward compatability</h2><span id='topic+slideWindowTunePlot'></span>

<h3>Description</h3>

<p>Wrapper function for <a href="#topic+plotSlideWindowTune">plotSlideWindowTune</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slideWindowTunePlot(
  tuneList,
  plotFiltered = c(TRUE, FALSE, NULL, "filtered", "remaining", "per_mutation"),
  percentage = FALSE,
  jitter.x = FALSE,
  jitter.x.amt = 0.1,
  jitter.y = FALSE,
  jitter.y.amt = 0.1,
  pchs = 1,
  ltys = 2,
  cols = 1,
  plotLegend = TRUE,
  legendPos = "topright",
  legendHoriz = FALSE,
  legendCex = 1,
  title = NULL,
  returnRaw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="slideWindowTunePlot_+3A_tunelist">tuneList</code></td>
<td>
<p>a list of logical matrices returned by <a href="#topic+slideWindowTune">slideWindowTune</a>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_plotfiltered">plotFiltered</code></td>
<td>
<p>whether to plot the number of filtered (<code>TRUE</code> or <code>filtered</code>), 
or remaining (FALSE or remaining) sequences for each mutation threshold. 
Use <code>NULL</code> or <code>per_mutation</code> to plot the number of sequences 
at each mutation value. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_percentage">percentage</code></td>
<td>
<p>whether to plot on the y-axis the percentage of filtered sequences
(as opposed to the absolute number). Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_jitter.x">jitter.x</code></td>
<td>
<p>whether to jitter x-axis values. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_jitter.x.amt">jitter.x.amt</code></td>
<td>
<p>amount of jittering to be applied on x-axis values if 
<code>jitter.x=TRUE</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_jitter.y">jitter.y</code></td>
<td>
<p>whether to jitter y-axis values. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_jitter.y.amt">jitter.y.amt</code></td>
<td>
<p>amount of jittering to be applied on y-axis values if 
<code>jitter.y=TRUE</code>. Default is 0.1.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_pchs">pchs</code></td>
<td>
<p>point types to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_ltys">ltys</code></td>
<td>
<p>line types to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_cols">cols</code></td>
<td>
<p>colors to pass on to <a href="base.html#topic+plot">plot</a>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_plotlegend">plotLegend</code></td>
<td>
<p>whether to plot legend. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_legendpos">legendPos</code></td>
<td>
<p>position of legend to pass on to <a href="graphics.html#topic+legend">legend</a>. Can be either a
numeric vector specifying x-y coordinates, or one of 
<code>"topright"</code>, <code>"center"</code>, etc. Default is <code>"topright"</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_legendhoriz">legendHoriz</code></td>
<td>
<p>whether to make legend horizontal. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_legendcex">legendCex</code></td>
<td>
<p>numeric values by which legend should be magnified relative to 1.</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_title">title</code></td>
<td>
<p>plot main title. Default is NULL (no title)</p>
</td></tr>
<tr><td><code id="slideWindowTunePlot_+3A_returnraw">returnRaw</code></td>
<td>
<p>Return a data.frame with sequence counts (TRUE) or a
plot. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>windowSize</code>, if <code>plotFiltered=TRUE</code>, the x-axis 
represents a mutation threshold range, and the y-axis the number of
sequences that have at least that number of mutations. If 
<code>plotFiltered=TRUE</code>, the y-axis represents the number of sequences
that have less mutations than the mutation threshold range. For the same
window size, a sequence can be included in the counts for different
mutation thresholds. For example, sequence &quot;CCACCAAAA&quot; with germline
&quot;AAAAAAAAA&quot; has 4 mutations. This sequence has at least 2 mutations 
and at least 3 mutations, in a window of size 4. the sequence will
be included in the sequence count for mutation thresholds 2 and 3.
If <code>plotFiltered=TRUE</code>, the sequences are counted only once for
each window size, at their largest mutation threshold. The above 
example sequence would be included in the sequence count for 
mutation threshold 3. 
</p>
<p>When plotting, a user-defined <code>amount</code> of jittering can be applied on values plotted
on either axis or both axes via adjusting <code>jitter.x</code>, <code>jitter.y</code>, 
<code>jitter.x.amt</code> and <code>jitter.y.amt</code>. This may be help with visually distinguishing
lines for different window sizes in case they are very close or identical to each other. 
If plotting percentages (<code>percentage=TRUE</code>) and using jittering on the y-axis values 
(<code>jitter.y=TRUE</code>), it is strongly recommended that <code>jitter.y.amt</code> be set very
small (e.g. 0.01). 
</p>
<p><code>NA</code> for a combination of <code>mutThresh</code> and <code>windowSize</code> where 
<code>mutThresh</code> is greater than <code>windowSize</code> will not be plotted.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+slideWindowTune">slideWindowTune</a> for how to get <code>tuneList</code>. See <a href="base.html#topic+jitter">jitter</a> for 
use of <code>amount</code> of jittering.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Use an entry in the example data for input and germline sequence
data(ExampleDb, package="alakazam")

# Try out thresholds of 2-4 mutations in window sizes of 3-5 nucleotides 
# on a subset of ExampleDb
tuneList &lt;- slideWindowTune(db = ExampleDb[1:10, ], 
                           mutThreshRange = 2:4, windowSizeRange = 3:5,
                           verbose = FALSE)

# Visualize
# Plot numbers of sequences filtered without jittering y-axis values
slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3, 
                    plotFiltered=TRUE, jitter.y=FALSE)
                    
# Notice that some of the lines overlap
# Jittering could help
slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3,
                    plotFiltered=TRUE, jitter.y=TRUE)
                    
# Plot numbers of sequences remaining instead of filtered
slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3, 
                    plotFiltered=FALSE, jitter.y=TRUE, 
                    legendPos="bottomright")
                    
# Plot percentages of sequences filtered with a tiny amount of jittering
slideWindowTunePlot(tuneList, pchs=1:3, ltys=1:3, cols=1:3,
                    plotFiltered=TRUE, percentage=TRUE, 
                    jitter.y=TRUE, jitter.y.amt=0.01)
</code></pre>

<hr>
<h2 id='summarizeBaseline'>Calculate BASELINe summary statistics</h2><span id='topic+summarizeBaseline'></span>

<h3>Description</h3>

<p><code>summarizeBaseline</code> calculates BASELINe statistics such as the mean selection 
strength (mean Sigma), the 95% confidence intervals and p-values for the presence of
selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeBaseline(baseline, returnType = c("baseline", "df"), nproc = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summarizeBaseline_+3A_baseline">baseline</code></td>
<td>
<p><code>Baseline</code> object returned by <a href="#topic+calcBaseline">calcBaseline</a> containing 
annotations and BASELINe posterior probability density functions 
(PDFs) for each sequence.</p>
</td></tr>
<tr><td><code id="summarizeBaseline_+3A_returntype">returnType</code></td>
<td>
<p>One of <code>c("baseline", "df")</code> defining whether
to return a <code>Baseline</code> object (&quot;baseline&quot;) with an updated
<code>stats</code> slot or a data.frame (&quot;df&quot;) of summary statistics.</p>
</td></tr>
<tr><td><code id="summarizeBaseline_+3A_nproc">nproc</code></td>
<td>
<p>number of cores to distribute the operation over. If 
<code>nproc</code> = 0 then the <code>cluster</code> has already been
set and will not be reset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned p-value can be either positive or negative. Its magnitude 
(without the sign) should be interpreted as per normal. Its sign indicates 
the direction of the selection detected. A positive p-value indicates positive
selection, whereas a negative p-value indicates negative selection.
</p>


<h3>Value</h3>

<p>Either a modified <code>Baseline</code> object or data.frame containing the 
mean BASELINe selection strength, its 95% confidence intervals, and 
a p-value for the presence of selection.
</p>


<h3>References</h3>


<ol>
<li><p>  Uduman M, et al. Detecting selection in immunoglobulin sequences. 
Nucleic Acids Res. 2011 39(Web Server issue):W499-504.
</p>
</li></ol>



<h3>See Also</h3>

<p>See <a href="#topic+calcBaseline">calcBaseline</a> for generating <code>Baseline</code> objects and
<a href="#topic+groupBaseline">groupBaseline</a> for convolving groups of BASELINe PDFs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call == "IGHG")
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=100)

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id",
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)
                     
# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc = 1)

# Grouping the PDFs by the sample annotation
grouped &lt;- groupBaseline(baseline, groupBy="sample_id")

# Get a data.frame of the summary statistics
stats &lt;- summarizeBaseline(grouped, returnType="df")
                     
</code></pre>

<hr>
<h2 id='TargetingMatrix-class'>S4 class defining a targeting matrix</h2><span id='topic+TargetingMatrix-class'></span><span id='topic+TargetingMatrix'></span>

<h3>Description</h3>

<p><code>TargetingMatrix</code> defines a data structure for just the targeting matrix 
(as opposed to the entire <code>TargetingModel</code>)
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code></dt><dd><p>matrix.</p>
</dd>
<dt><code>numMutS</code></dt><dd><p>number indicating the number of silent mutations used for 
estimating mutability.</p>
</dd>
<dt><code>numMutR</code></dt><dd><p>number indicating the number of replacement mutations used 
for estimating mutability.</p>
</dd>
</dl>

<hr>
<h2 id='TargetingModel-class'>S4 class defining a targeting model</h2><span id='topic+TargetingModel-class'></span><span id='topic+TargetingModel'></span><span id='topic+plot+2CTargetingModel+2Cmissing-method'></span><span id='topic+TargetingModel-method'></span>

<h3>Description</h3>

<p><code>TargetingModel</code> defines a common data structure for mutability, substitution and
targeting of immunoglobulin (Ig) sequencing data in a 5-mer microsequence context.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TargetingModel,missing'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TargetingModel-class_+3A_x">x</code></td>
<td>
<p><code>TargetingModel</code> object.</p>
</td></tr>
<tr><td><code id="TargetingModel-class_+3A_y">y</code></td>
<td>
<p>ignored.</p>
</td></tr>
<tr><td><code id="TargetingModel-class_+3A_...">...</code></td>
<td>
<p>arguments to pass to <a href="#topic+plotMutability">plotMutability</a>.</p>
</td></tr>
</table>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Name of the model.</p>
</dd>
<dt><code>description</code></dt><dd><p>Description of the model and its source data.</p>
</dd>
<dt><code>species</code></dt><dd><p>Genus and species of the source sequencing data.</p>
</dd>
<dt><code>date</code></dt><dd><p>Date the model was built.</p>
</dd>
<dt><code>citation</code></dt><dd><p>Publication source.</p>
</dd>
<dt><code>substitution</code></dt><dd><p>Normalized rates of the center nucleotide of a given 5-mer 
mutating to a different nucleotide. The substitution model 
is stored as a 5x3125 matrix of rates. Rows define
the mutated nucleotide at the center of each 5-mer, one of 
<code>c("A", "C", "G", "T", "N")</code>, and columns define the 
complete 5-mer of the unmutated nucleotide sequence.</p>
</dd>
<dt><code>mutability</code></dt><dd><p>Normalized rates of a given 5-mer being mutated. The 
mutability model is stored as a numeric vector of length 3125 
with mutability rates for each 5-mer. Note that &quot;normalized&quot; 
means that the mutability rates for the 1024 5-mers that 
contain no &quot;N&quot; at any position sums up to 1 (as opposed to 
the entire vector summing up to 1).</p>
</dd>
<dt><code>targeting</code></dt><dd><p>Rate matrix of a given mutation ocurring, defined as 
<code class="reqn">mutability * substitution</code>. The targeting model 
is stored as a 5x3125 matrix. Rows define
the mutated nucleotide at the center of each 5-mer, one of 
<code>c("A", "C", "G", "T", "N")</code>, and columns define the complete 5-mer 
of the unmutated nucleotide sequence.</p>
</dd>
<dt><code>numMutS</code></dt><dd><p>number indicating the number of silent mutations used for 
estimating mutability.</p>
</dd>
<dt><code>numMutR</code></dt><dd><p>number indicating the number of replacement mutations used 
for estimating mutability.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>See <a href="#topic+createTargetingModel">createTargetingModel</a> building models from sequencing data.
</p>

<hr>
<h2 id='testBaseline'>Two-sided test of BASELINe PDFs</h2><span id='topic+testBaseline'></span>

<h3>Description</h3>

<p><code>testBaseline</code> performs a two-sample signifance test of BASELINe 
posterior probability density functions (PDFs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testBaseline(baseline, groupBy)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testBaseline_+3A_baseline">baseline</code></td>
<td>
<p><code>Baseline</code> object containing the <code>db</code> and grouped 
BASELINe PDFs returned by <a href="#topic+groupBaseline">groupBaseline</a>.</p>
</td></tr>
<tr><td><code id="testBaseline_+3A_groupby">groupBy</code></td>
<td>
<p>string defining the column in the <code>db</code> slot of the 
<code>Baseline</code> containing sequence or group identifiers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with test results containing the following columns:
</p>

<ul>
<li>  <p><code>region</code>:  sequence region, such as <code>cdr</code> and <code>fwr</code>.
</p>
</li>
<li>  <p><code>test</code>:    string defining the groups be compared. The
string is formated as the conclusion associated with the
p-value in the form <code>GROUP1 != GROUP2</code>. Meaning,
the p-value for rejection of the null hypothesis that 
GROUP1 and GROUP2 have equivalent distributions.
</p>
</li>
<li>  <p><code>pvalue</code>:  two-sided p-value for the comparison.
</p>
</li>
<li>  <p><code>fdr</code>:     FDR corrected <code>pvalue</code>.
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p>  Yaari G, et al. Quantifying selection in high-throughput immunoglobulin 
sequencing data sets. 
Nucleic Acids Res. 2012 40(17):e134. 
(Corretions at http://selection.med.yale.edu/baseline/correction/)
</p>
</li></ol>



<h3>See Also</h3>

<p>To generate the <a href="#topic+Baseline">Baseline</a> input object see <a href="#topic+groupBaseline">groupBaseline</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Subset example data as a demo
data(ExampleDb, package="alakazam")
db &lt;- subset(ExampleDb, c_call %in% c("IGHM", "IGHG"))
set.seed(112)
db &lt;- dplyr::slice_sample(db, n=200)

# Collapse clones
db &lt;- collapseClones(db, cloneColumn="clone_id",
                     sequenceColumn="sequence_alignment",
                     germlineColumn="germline_alignment_d_mask",
                     method="thresholdedFreq", minimumFrequency=0.6,
                     includeAmbiguous=FALSE, breakTiesStochastic=FALSE)
                     
# Calculate BASELINe
baseline &lt;- calcBaseline(db, 
                         sequenceColumn="clonal_sequence",
                         germlineColumn="clonal_germline", 
                         testStatistic="focused",
                         regionDefinition=IMGT_V,
                         targetingModel=HH_S5F,
                         nproc=1)

# Group PDFs by the isotype
grouped &lt;- groupBaseline(baseline, groupBy="c_call")

# Visualize isotype PDFs
plot(grouped, "c_call")

# Perform test on isotype PDFs
testBaseline(grouped, groupBy="c_call")

</code></pre>

<hr>
<h2 id='U5N'>Uniform 5-mer null targeting model.</h2><span id='topic+U5N'></span>

<h3>Description</h3>

<p>A null 5-mer model of somatic hypermutation targeting where all substitution, mutability
and targeting rates are uniformly distributed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>U5N
</code></pre>


<h3>Format</h3>

<p>A <a href="#topic+TargetingModel">TargetingModel</a> object.
</p>


<h3>See Also</h3>

<p>See <a href="#topic+HH_S5F">HH_S5F</a> and <a href="#topic+HKL_S5F">HKL_S5F</a> for the human 5-mer targeting models; and 
<a href="#topic+MK_RS5NF">MK_RS5NF</a> for the mouse 5-mer targeting model.
</p>

<hr>
<h2 id='writeTargetingDistance'>Write targeting model distances to a file</h2><span id='topic+writeTargetingDistance'></span>

<h3>Description</h3>

<p><code>writeTargetingDistance</code> writes a 5-mer targeting distance matrix 
to a tab-delimited file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeTargetingDistance(model, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeTargetingDistance_+3A_model">model</code></td>
<td>
<p><a href="#topic+TargetingModel">TargetingModel</a> object with 
mutation likelihood information.</p>
</td></tr>
<tr><td><code id="writeTargetingDistance_+3A_file">file</code></td>
<td>
<p>name of file to write.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The targeting distance write as a tab-delimited 5x3125 matrix. Rows define the mutated 
nucleotide at the center of each 5-mer, one of <code>c("A", "C", "G", "T", "N")</code>, 
and columns define the complete 5-mer of the unmutated nucleotide sequence. 
<code>NA</code> values in the distance matrix are replaced with distance 0.
</p>


<h3>See Also</h3>

<p>Takes as input a <a href="#topic+TargetingModel">TargetingModel</a> object and calculates  
distances using <a href="#topic+calcTargetingDistance">calcTargetingDistance</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Write HS5F targeting model to working directory as hs5f.tab
writeTargetingDistance(HH_S5F, "hh_s5f.tsv") 

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
