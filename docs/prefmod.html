<!DOCTYPE html><html><head><title>Help for package prefmod</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prefmod}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baseball'><p>Data (paired comparisons): Baseball Games</p></a></li>
<li><a href='#carconf'><p>Data (partial rankings): Car Configurator</p></a></li>
<li><a href='#cemspc'><p>Data (paired comparisons with undecided): CEMS (Community of European management schools)</p></a></li>
<li><a href='#checkMIS'><p>Function to check/report missing values in paired comparison studies</p></a></li>
<li><a href='#dat4'><p>Data (paired comparisons): dat4</p></a></li>
<li><a href='#euro55.2.des'><p>Design data frame for a paired comparison pattern model for rankings (Eurobarometer 55.2)</p></a></li>
<li><a href='#expand.mat'><p>Utility function to expand aggregated data</p></a></li>
<li><a href='#immig'><p>Data (paired comparisons with undecided and forced <code>NA</code>s): Negative Attitudes towards Immigrants</p></a></li>
<li><a href='#issp2000'><p>Data (Likert items): ISSP 2000 Survey on Environmental Issues</p></a></li>
<li><a href='#llbt.design'><p>Loglinear Bradley-Terry Model (LLBT) &ndash; Design Matrix Generation</p></a></li>
<li><a href='#llbt.fit'><p>Function to fit an LLBT</p></a></li>
<li><a href='#llbt.worth'><p>Function to calculate and print worth parameters from LLBT model results</p></a></li>
<li><a href='#llbtPC.fit'><p>Function to fit a loglinear Bradley-Terry model for paired comparisons</p></a></li>
<li><a href='#music'><p>Data (ratings): Music (US General social survey 1993)</p></a></li>
<li><a href='#patt.design'><p>Paired Comparison Patterns &ndash; Design Matrix Generation</p></a></li>
<li><a href='#patt.worth'><p>Function to calculate and print worth parameters from pattern model results</p></a></li>
<li><a href='#pattL.fit'><p>Function to fit a pattern model for ratings (Likert items)</p></a></li>
<li><a href='#pattLrep.fit'><p>Function to fit a pattern model for repeated ratings (Likert items)</p></a></li>
<li><a href='#pattnpml.fit'><p>NPML estimation for paired comparison models</p></a></li>
<li><a href='#pattPC.fit'><p>Function to fit a pattern model for paired comparisons</p></a></li>
<li><a href='#pattR.fit'><p>Function to fit a pattern model for (partial) rankings</p></a></li>
<li><a href='#pattRrep.fit'><p>Function to fit a pattern model for repeated rankings)</p></a></li>
<li><a href='#plot.wmat'><p>Method to plot worth or model parameters from LLBT or pattern models</p></a></li>
<li><a href='#prefmod-defunct'><p>Defunct Functions in Package <span class="pkg">prefmod</span></p></a></li>
<li><a href='#prefmod-package'><p><span class="pkg">prefmod</span>: Utilities to Fit Paired Comparison Models for Preferences</p></a></li>
<li><a href='#print.pattMod'><p>Print methods for pattern models</p></a></li>
<li><a href='#salad'><p>Data (ranks): Salad Dressings (Critchlow and Fligner)</p></a></li>
<li><a href='#simPC'><p>Utility function to simulate paired comparison or rankings data</p></a></li>
<li><a href='#summary.pattNPML'><p>Summarizing finite mixture regression fits</p></a></li>
<li><a href='#tennis'><p>Data (paired comparisons): Preferred Interview Partner</p></a></li>
<li><a href='#trdel'><p>Data (paired comparisons): Training delivery modes</p></a></li>
<li><a href='#xmpl'><p>Data (Likert items): Example Data Set</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Utilities to Fit Paired Comparison Models for Preferences</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8-36</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-28</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), stats, graphics, gnm (&ge; 1.0-0), colorspace</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, utils, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Generates design matrix for analysing real paired comparisons and derived paired comparison data (Likert type items/ratings or rankings) using a loglinear approach. Fits loglinear Bradley-Terry model (LLBT) exploiting an eliminate feature. Computes pattern models for paired comparisons, rankings, and ratings. Some treatment of missing values (MCAR and MNAR). Fits latent class (mixture) models for paired comparison, rating and ranking patterns using a non-parametric ML approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-28 15:00:53 UTC; mm</td>
</tr>
<tr>
<td>Author:</td>
<td>Reinhold Hatzinger [aut],
  Marco Johannes Maier [cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Johannes Maier &lt;marco_maier@posteo.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-30 16:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baseball'>Data (paired comparisons): Baseball Games</h2><span id='topic+baseball'></span>

<h3>Description</h3>


<p>The result of the 1987 season for seven baseball teams in the Eastern Division of the American League according to the (home team, away team) classification are shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>baseball</code></pre>


<h3>Format</h3>


<p>Baseball is a numeric vector with the results for the season according to the (home team, away team) classification.
</p>


<h3>Details</h3>


<p>The results of the seven teams Milwaukee, Detroit, Toronto, New York, Boston, Cleveland and Baltimore, that play 13 games each.
There is no possibility of ending in a draw.
</p>


<h3>References</h3>


<p>Alan Agresti, <em>Categorical Data Analysis (Second Edition)</em>, 2002 pages 437 and 438
</p>
<p>R. Dittrich, R. Hatzinger, and W. Katzenbeisser, Fitting paired comparison models in GLIM. <em>GLIM newsletter</em> 1997
</p>


<h3>Examples</h3>

<pre><code class='language-R'># baseball example (Agresti, 2002, p. 437)

# pseudodata for generating a design matrix
d1 &lt;- c(rep(0, 21), 1)
d2 &lt;- c(1, rep(0, 20), 2)
d  &lt;- data.frame(rbind(d1, d2))
names(d) &lt;- c(paste0("v", 1:21), "cov")

# design matrix
des5 &lt;- llbt.design(d, nitems = 7,
    objnames = c("MIL", "DET", "TOR", "NY", "BOS", "CLE", "BAL"),
    cat.scov = "cov")
des5$y  &lt;- baseball
des5$mu &lt;- gl(42, 2)
pos     &lt;- c(rep(1:0, 21), rep(0:1, 21))

# fit model and display results
res5 &lt;- gnm(y ~ MIL+DET+TOR+NY+BOS+CLE+BAL + pos,
    eliminate = mu, data = des5, family = poisson)
w5   &lt;- llbt.worth(res5)
plot(w5)
</code></pre>

<hr>
<h2 id='carconf'>Data (partial rankings): Car Configurator</h2><span id='topic+carconf'></span>

<h3>Description</h3>


<p>Online configuration systems allow customers to actively participate in the creation of products and become increasingly important in various market sectors.
Dabic and Hatzinger report a study on car configurators that aimed at investigating the effects of certain person characteristics (such as gender) on the configuration process.
Subjects were asked to configure a car according to their preferences.
They could choose freely from several modules: such as exterior and interior design, technical equipment, brand, price, and producing country.
The order of module choice was recorded as ranks.
Since not all modules had to be chosen the response format was partial rankings.</p>


<h3>Usage</h3>

<pre><code class='language-R'>carconf</code></pre>


<h3>Format</h3>


<p>A data frame with 435 observations on the following 9 variables.
</p>

<dl>
<dt><code>price</code></dt><dd><p>rank (1 highest preference)</p>
</dd>
<dt><code>exterior</code></dt><dd><p>rank</p>
</dd>
<dt><code>brand</code></dt><dd><p>rank</p>
</dd>
<dt><code>tech.equip</code></dt><dd><p>rank</p>
</dd>
<dt><code>country</code></dt><dd><p>rank</p>
</dd>
<dt><code>interior</code></dt><dd><p>rank</p>
</dd>
<dt><code>sex</code></dt><dd><p>1 female 2 male</p>
</dd>
<dt><code>age</code></dt><dd><p>1 17&ndash;29 years, 2 30&ndash;49 years, 3 50+ years</p>
</dd>
<dt><code>segment</code></dt><dd><p>preferred car type: 1 premium-class, 2 medium-class, 3 low-budget</p>
</dd>
</dl>



<h3>Source</h3>


<p>Dabic, M., &amp; Hatzinger, R. (2009). Zielgruppenad채quate Abl채ufe in Konfigurationssystemen &ndash; eine empirische Studie im Automobilmarkt: Das Paarvergleichs-Pattern-Modell f체r Partial Rankings. In R. Hatzinger, R. Dittrich, &amp; T. Salzberger (Eds.), <em>Pr채ferenzanalyse mit R: Anwendungen aus Marketing, Behavioural Finance und Human Resource Management</em> (pp. 119&ndash;150). Wien: Facultas.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(carconf)</code></pre>

<hr>
<h2 id='cemspc'>Data (paired comparisons with undecided): CEMS (Community of European management schools)</h2><span id='topic+cemspc'></span>

<h3>Description</h3>


<p>A survey of 303 students was carried out to examine the students' preferences of 6 universities (London, Paris, Milano, St. Gallen, Barcelona and Stockholm) with a 17 items questionnaire.
The first 15 variables indicate the subjects' preferences.
For a given comparison the responses are coded as 0 if the first university was preferred, 2 if the second university was preferred and 1 if no decision was made.
The variable <code>ENG</code> contains the knowledge of English and the variable <code>SEX</code> contains the gender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cemspc</code></pre>


<h3>Format</h3>


<p>A data frame with 303 rows for the subjects containing the outcome of the 15 comparisons and the two covariates
</p>

<dl>
<dt><code>V1</code></dt><dd><p>London vs. Paris</p>
</dd>
<dt><code>V2</code></dt><dd><p>London vs. Milano</p>
</dd>
<dt><code>V3</code></dt><dd><p>Paris vs. Milano</p>
</dd>
<dt><code>V4</code></dt><dd><p>London vs. St. Gallen</p>
</dd>
<dt><code>V5</code></dt><dd><p>Paris vs. St. Gallen</p>
</dd>
<dt><code>V6</code></dt><dd><p>Milano vs. St. Gallen</p>
</dd>
<dt><code>V7</code></dt><dd><p>London vs. Barcelona</p>
</dd>
<dt><code>V8</code></dt><dd><p>Paris vs. Barcelona</p>
</dd>
<dt><code>V9</code></dt><dd><p>Milano vs. Barcelona</p>
</dd>
<dt><code>V10</code></dt><dd><p>St. Gallen vs. Barcelona</p>
</dd>
<dt><code>V11</code></dt><dd><p>London vs. Stockholm</p>
</dd>
<dt><code>V12</code></dt><dd><p>Paris vs. Stockholm</p>
</dd>
<dt><code>V13</code></dt><dd><p>Milano vs. Stockholm</p>
</dd>
<dt><code>V14</code></dt><dd><p>St. Gallen vs. Stockholm</p>
</dd>
<dt><code>V15</code></dt><dd><p>Barcelona vs. Stockholm</p>
</dd>
<dt><code>ENG</code></dt><dd><p>Knowledge of English: (1) good, (2) poor</p>
</dd>
<dt><code>SEX</code></dt><dd><p>Gender: (1) female, (2) male</p>
</dd>
</dl>



<h3>References</h3>


<p>Dittrich, R., Hatzinger, R., &amp; Katzenbeisser, W. (1998).
Modelling the effect of subject-specific covariates in paired comparison studies with an application to university rankings.
<em>Applied Statistics, 47</em>(4), 511&ndash;525.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>old_par &lt;- par(mfrow = c(4, 4))
for(i in 1:15){ barplot(table(cemspc[, i])) }
par(old_par)
</code></pre>

<hr>
<h2 id='checkMIS'>Function to check/report missing values in paired comparison studies</h2><span id='topic+checkMIS'></span>

<h3>Description</h3>


<p>For a given paired comparisons data set the function calculates and prints the number of missing comparisons and the number of times objects are missing.
It can also be used to avoid failure of nonresponse-parameter for nonresponse models in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
checkMIS(obj, nitems, MISmodel = "obj", obj.names = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="checkMIS_+3A_obj">obj</code></td>
<td>
<p>dataframe or datafile path/name (like <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>).</p>
</td></tr>
<tr><td><code id="checkMIS_+3A_nitems">nitems</code></td>
<td>
<p>the number of compared objects, not the number of comparisons (like <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>).</p>
</td></tr>
<tr><td><code id="checkMIS_+3A_mismodel">MISmodel</code></td>
<td>

<p>specifies the nonresponse model, either <code>obj</code> (default) for missing mechanisms based on objects, or <code>comp</code> based on comparisons.
This argument is only relevant for the (invisible) output of <code>checkMIS</code>.
</p>
</td></tr>
<tr><td><code id="checkMIS_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="checkMIS_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> printed output, otherwise only invisible output to be used, e.g., in the specification of <code>MISalpha</code> and <code>MISbeta</code> in <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>


<p>a logical vector (returned invisibly) specifying for which object/comparison there are <code>NA</code> responses in the data (<code>obj)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pattPC.fit">pattPC.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># no missing NAs in dataset dat4
checkMIS(dat4, nitems = 4, verbose = TRUE)

# generates data set with three items and some missing values in
# comparison (23), column 3, then there are no NAs for object 1
data3 &lt;- dat4[, 1:3]
idx3  &lt;- sample(1:100, 10)
data3[idx3, 3] &lt;- NA
checkMIS(data3, nitems = 3, verbose = TRUE)

# estimate MCAR PC pattern model for data3 with NA indicators alpha1
# cannot be estimated being accommodated by using checkMIS
pattPC.fit(data3, nitems = 3, MISalpha = checkMIS(data3, nitems = 3))
</code></pre>

<hr>
<h2 id='dat4'>Data (paired comparisons): dat4</h2><span id='topic+dat4'></span>

<h3>Description</h3>


<p>A fictitious dataset with 100 observations on 6 paired comparisons.
The responses get the value <code class="reqn">1</code> if the first object in a comparison is preferred and <code class="reqn">-1</code> otherwise.
</p>
<p>For the arrangement of objects and comparisons see <code><a href="#topic+llbt.design">llbt.design</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dat4</code></pre>


<h3>Format</h3>


<p>A data frame with 100 observations on 6 comparisons (<code>comp1</code> to <code>comp6</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(dat4)

# to get a general idea we use the histogram plot
old_par &lt;- par(mfrow = c(2, 3))
for(i in 1:6){ barplot(table(dat4[, i])) }
par(old_par)
</code></pre>

<hr>
<h2 id='euro55.2.des'>Design data frame for a paired comparison pattern model for rankings (Eurobarometer 55.2)</h2><span id='topic+euro55.2.des'></span>

<h3>Description</h3>


<p>Eurobarometer public opinion surveys have been carried out in all member states of the European Union since 1973.
Eurobarometer 55.2 was a special survey collected in 2001 and designed to elicit information on European experience and perception of science and technology.
One question, of identical form in all states, asked respondents about their sources of information about science, and requested them to rank them in order of importance.
The items were: Television, Radio, Press, Scientific Magazines, Internet, School and University.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euro55.2.des</code></pre>


<h3>Format</h3>


<p>The data is a design data frame generated from the original data using <code><a href="#topic+patt.design">patt.design</a></code>.
Each row represents a (derived) paired comparison response pattern crossclassified by the categorical subject covariates <code>SEX</code> and <code>AGE4</code>.
The columns are:
</p>

<dl>
<dt><code>y</code></dt><dd><p>counts</p>
</dd>
<dt><code>TV</code></dt><dd><p>design vector for Television</p>
</dd>
<dt><code>RAD</code></dt><dd><p>design vector for Radio</p>
</dd>
<dt><code>NEWSP</code></dt><dd><p>design vector for Newspapers and magazine</p>
</dd>
<dt><code>SCIMAG</code></dt><dd><p>design vector for Scientific magazines</p>
</dd>
<dt><code>WWW</code></dt><dd><p>design vector for The internet</p>
</dd>
<dt><code>EDINST</code></dt><dd><p>design vector for School/University</p>
</dd>
<dt><code>SEX</code></dt><dd><p>Gender: Factor with 2 levels: (1) male, (2) female</p>
</dd>
<dt><code>AGE4</code></dt><dd><p>Age: Factor with 4 levels: (1) 15&ndash;24, (2) 25&ndash;39, (3) 40&ndash;54, (4) 55+</p>
</dd>
</dl>



<h3>Details</h3>

<p>The original data contained  16 029 cases, after removal of cases with missing values and improper rankings this design data frame is based on 12216 observations.
</p>


<h3>Source</h3>


<p><a href="https://data.europa.eu/data/datasets/s209_55_2_ebs154">https://data.europa.eu/data/datasets/s209_55_2_ebs154</a>
</p>


<h3>References</h3>

<p>Christensen, T. (2001). Eurobarometer 55.2: Europeans, science and technology. Technical
report, European Opinion Research Group, Commission of the European Communities,
Brussels.





</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(euro55.2.des)</code></pre>

<hr>
<h2 id='expand.mat'>Utility function to expand aggregated data</h2><span id='topic+expand.mat'></span>

<h3>Description</h3>

<p>The function expands aggregated data into casewise data.
For instance, for a contingency table given in the form of a design matrix and corresponding counts the function sets up a matrix where each design row is repeated according to the frequencies for that row.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand.mat(mat, freq)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand.mat_+3A_mat">mat</code></td>
<td>
<p>a matrix (or column vector) or data frame to be expanded</p>
</td></tr>
<tr><td><code id="expand.mat_+3A_freq">freq</code></td>
<td>
<p>a vector of counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the expanded matrix.
</p>


<h3>Note</h3>


<p>This utility allows to generate input data for the design generating and model fitting functions of the <span class="pkg">prefmod</span> package from aggregated data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tdat &lt;- expand.mat(tennis[, -1], tennis[, 1])
head(tdat)
</code></pre>

<hr>
<h2 id='immig'>Data (paired comparisons with undecided and forced <code>NA</code>s): Negative Attitudes towards Immigrants</h2><span id='topic+immig'></span>

<h3>Description</h3>


<p>A survey of 98 students was carried out to examine student's (negative) attitudes towards immigrants.
Four statements had to be compared with regard to higher acceptance.
The four statements were
</p>

<ul>
<li><p> Foreigners increase crime rates (<code>crimRate</code>)
</p>
</li>
<li><p> Foreigners take apprenticeship training position away (<code>position</code>)
</p>
</li>
<li><p> Foreigners are a strain for the social welfare system (<code>socBurd</code>)
</p>
</li>
<li><p> Foreigners threaten our culture (<code>culture</code>)
</p>
</li></ul>

<p>The first 6 variables in the dataset indicate the preferences of the students.
For a given comparison the responses are coded by <code class="reqn">1</code> if the first item was preferred, <code class="reqn">-1</code> if the second university was preferred and <code class="reqn">0</code> if no decision was made.
The variable <code>ENG</code> characterises the knowledge of English and the variable <code>SEX</code> characterises the gender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immig</code></pre>


<h3>Format</h3>


<p>A data frame with 98 observations on the following 9 variables.
</p>

<dl>
<dt><code>V12</code></dt><dd><p><code>crimRate</code> vs. <code>position</code></p>
</dd>
<dt><code>V13</code></dt><dd><p><code>crimRate</code> vs. <code>socBurd</code></p>
</dd>
<dt><code>V23</code></dt><dd><p><code>position</code> vs. <code>socBurd</code></p>
</dd>
<dt><code>V14</code></dt><dd><p><code>crimRate</code> vs. <code>culture</code></p>
</dd>
<dt><code>V24</code></dt><dd><p><code>position</code> vs. <code>culture</code></p>
</dd>
<dt><code>V34</code></dt><dd><p><code>socBurd</code> vs. <code>culture</code></p>
</dd>
<dt><code>SEX</code></dt><dd><p>Gender: (1) male, (2) female</p>
</dd>
<dt><code>AGE</code></dt><dd><p>Age (continuous)</p>
</dd>
<dt><code>NAT</code></dt><dd><p>Nationality (Factor). Cannot directly be used in <span class="pkg">prefmod</span></p>
</dd>
</dl>



<h3>References</h3>


<p>Weber, D., &amp; Hatzinger, R. (2011).
A novel approach for modelling paired comparisons data with non-ignorable missing values on students' attitudes towards foreigners.
<em>Data Analysis Bulletin, 12</em>, 11&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(immig)</code></pre>

<hr>
<h2 id='issp2000'>Data (Likert items): ISSP 2000 Survey on Environmental Issues</h2><span id='topic+issp2000'></span>

<h3>Description</h3>


<p>In 2000 the International Social Survey Programme (ISSP) has addressed the topic of attitudes to environmental protection and preferred government measures for environmental protection.
This dataset focusses on six items (with a 5-point rating scale (Likert type)) where respondents from Austria and Great Britain were asked about their perception of environmental dangers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issp2000</code></pre>


<h3>Format</h3>


<p>A data frame with 1595 observations on the following 11 variables.
The first six variables are items to be answered on a 5-point rating scale (Likert type) with response categories: (1) <em>extremely dangerous for the environment</em> to (5) <em>not dangerous at all for the environment</em>.
</p>

<dl>
<dt><code>CAR</code></dt><dd><p>air pollution caused by cars</p>
</dd>
<dt><code>IND</code></dt><dd><p>air pollution caused by industry</p>
</dd>
<dt><code>FARM</code></dt><dd><p>pesticides and chemicals used in farming</p>
</dd>
<dt><code>WATER</code></dt><dd><p>pollution of country's rivers, lakes and streams</p>
</dd>
<dt><code>TEMP</code></dt><dd><p>a rise in the world's temperature</p>
</dd>
<dt><code>GENE</code></dt><dd><p>modifying the genes of certain crops</p>
</dd>
<dt><code>SEX</code></dt><dd><p>gender: (1) <em>male</em>, (2) <em>female</em></p>
</dd>
<dt><code>URB</code></dt><dd><p>location of residence: (1) <em>urban area</em>, (2) <em>suburbs of large cities, small town, county seat</em> (3) <em>rural area</em></p>
</dd>
<dt><code>AGE</code></dt><dd><p>age: (1) <em>&lt; 40 years</em>, (2) <em>41&ndash;59 years</em>, (3) <em>60+ years</em></p>
</dd>
<dt><code>CNTRY</code></dt><dd><p>country: (1) <em>Great Britain</em>, (2) <em>Austria</em></p>
</dd>
<dt><code>EDU</code></dt><dd><p>education: (1) <em>below A-level/matrice</em>, (2) <em>A-level/matrice or higher</em></p>
</dd>
</dl>



<h3>Source</h3>


<p>ISSP Research Group (2003). <em>International Social Survey Programme: Environment II &ndash; ISSP 2000.</em> GESIS Data Archive, Cologne. ZA3440 Data file Version 1.0.0, <a href="https://doi.org/10.4232/1.3440">doi:10.4232/1.3440</a><br />
<a href="https://www.gesis.org/issp/modules/issp-modules-by-topic/environment/2000">https://www.gesis.org/issp/modules/issp-modules-by-topic/environment/2000</a>
(<a href="https://www.gesis.org/fileadmin/upload/dienstleistung/daten/umfragedaten/_bgordnung_bestellen/Usage_regulations.pdf">Usage regulations</a>)
</p>


<h3>References</h3>


<p>Dittrich, R., Francis, B.J., Hatzinger R., Katzenbeisser, W. (2007). A Paired Comparison Approach for the Analysis of Sets of Likert Scale Responses. <em>Statistical Modelling</em>, Vol. 7, No. 1, 3&ndash;28.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(issp2000)</code></pre>

<hr>
<h2 id='llbt.design'>Loglinear Bradley-Terry Model (LLBT) &ndash; Design Matrix Generation</h2><span id='topic+llbt.design'></span>

<h3>Description</h3>


<p>The function <code>llbt.design</code> returns a data frame containing the design matrix for a loglinear paired comparison model.
Additionally, the frequencies of the pairwise comparisons are computed and are stored in the first column of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
llbt.design(data, nitems = NULL, objnames = "", objcovs = NULL,
        cat.scovs = NULL, num.scovs = NULL, casewise = FALSE, ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="llbt.design_+3A_data">data</code></td>
<td>

<p>either a data frame or a data file name.
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_nitems">nitems</code></td>
<td>

<p>number of items (objects).
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_objnames">objnames</code></td>
<td>

<p>an optional character vector with names for the objects.
These names are the columns names in the output data frame.
If <code>objnames</code> is not specified <code>o1</code>, <code>o2</code>, etc. will be used.
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_objcovs">objcovs</code></td>
<td>

<p>an optional data frame with object specific covariates.
The rows correspond to the objects, the columns define the covariates.
The column names of this data frame are later used to fit the covariates.
Factors are not allowed.
In that case dummy variables have to be set up manually (favourably using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>).
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_cat.scovs">cat.scovs</code></td>
<td>

<p>a character vector with the names of the categorical subject covariates in the data file to be included into the design matrix.
(Example: <code>cat.scovs = c("SEX", "WORK")</code>.)
If all covariates in the data are categorical and should be included,  the specification can be abbreviated to <code>cat.scovs = "ALL"</code>.
In that case, <code>num.scovs</code> must not be specified.
For no categorical covariates: <code>cat.scovs = ""</code>, the default.
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_num.scovs">num.scovs</code></td>
<td>

<p>analogous to  <code>cat.scovs</code> for numerical (continuous) subject covariates.
If any numerical covariates are specified, <code>casewise</code> is set to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_casewise">casewise</code></td>
<td>

<p>If <code>casewise = TRUE</code> a separate design structure is set up for each subject in the data.
This is required when fitting continuous subject covariates.
However, the design can become very large in the case of many subjects and/or comparisons.
See Details below.
</p>
</td></tr>
<tr><td><code id="llbt.design_+3A_...">...</code></td>
<td>

<p>deprecated options to allow for backwards compatibility (see Deprecated below)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>llbt.design</code> allows for different scenarios mainly concerning
</p>

<ul>
<li><p><strong>Paired comparison data.</strong>
Responses can be either simply <em>preferred</em> &ndash; <em>not preferred</em> or ordinal (<em>strongly preferred</em> &ndash; ... &ndash; <em>not at all preferred</em>).
In both cases an undecided category may or may not occur.
If there are more than three categories a they are reduced to two or three response categories.
</p>
</li>
<li><p><strong>Item covariates.</strong>
The design matrix for the basic model has columns for the items (objects) and for each response category.
</p>
</li>
<li><p><strong>Object specific covariates.</strong>
For modelling certain characteristics of objects a reparameterisation can be included in the design.
This is sometimes called conjoint analysis.
The object specific covariates can be continuous or dummy variables.
For the specification see Argument <code>objcovs</code> above.
</p>
</li>
<li><p><strong>Subject covariates.</strong>
For modelling different preference scales for the items according to characteristics of the respondents categorical and/or continuous subject covariates can be included in the design.<br />
<em>Categorical subject covariates</em>: The corresponding variables are defined as numerical vectors where the levels are specified with consecutive integers starting with 1.
This format must be used in the input data file.
These variables are <code><a href="base.html#topic+factor">factor</a>(s)</code> in the output data frame.<br />
<em>Continuous subject covariates</em>: also defined as numerical vectors in the input data frame.
If present, the resulting design structure is automatically expanded, i.e., there are as many design blocks as there are subjects.
</p>
</li>
<li><p><strong>Object specific covariates.</strong>
The objects (items) can be reparameterised using an object specific design matrix.
This allows for scenarios such as conjoint analysis or for modelling some characteristics shared by the objects.
The number of such characteristics must not exceed the number of objects minus one.
</p>
</li></ul>



<h3>Value</h3>

<p>The output is a dataframe of class <code>llbtdes</code>.
Each row represents a decision in a certain comparison.
Dependent on the number of response categories, comparisons are made up of two or three rows in the design matrix.
If subject covariates are specified, the design matrix is duplicated as many times as there are combinations of the levels of each categorical covariate or, if <code>casewise = TRUE</code>, as there are subjects in the data.
Each individual design matrix consists of rows for all comparisons.
</p>
<p>The first column contains the counts for the paired comparison response patterns and is labelled with <code>y</code>.
The next columns are the covariates for the categories (labelled as <code>g0</code>, <code>g1</code>, etc.).
In case of an odd number of categories, <code>g1</code> can be used to model an undecided effect.
The subsequent columns are covariates for the items.
If specified, subject covariates and then object specific covariates follow.
</p>


<h3>Input Data</h3>

<p>Responses have to be coded as consecutive integers (e.g., (0, 1), or (1, 2, 3, ...), where the smallest value corresponds to (highest) preference for the first object in a comparison.
For (ordinal) paired comparison data (<code>resptype = "paircomp"</code>) the codings <code class="reqn">(1, -1)</code>, <code class="reqn">(2, 1, -1, -2)</code>, <code class="reqn">(1, 0, -1)</code>, <code class="reqn">(2, 1, 0, -1, -2)</code>, etc. can also be used.
Then negative numbers correspond to not preferred, 0 to undecided.
Missing responses (for paired comparisons but not for subject covariates) are allowed under a missing at random assumption and specified via <code>NA</code>.
</p>
<p>Input data (via the first argument <code>obj</code> in the function call) is specified either through a dataframe or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>The leftmost columns must be the responses to the paired comparisons (where the mandatory order of comparisons is (12) (13) (23) (14) (24) (34) (15) (25) etc.), optionally followed by columns for subject covariates.
If categorical, these have to be specified such that the categories are represented by consecutive integers starting with 1.
Missing values for subject covariates are not allowed and treated such that rows with NAs are removed from the resulting design structure and a message is printed.
</p>
<p>For an example see <code><a href="#topic+xmpl">xmpl</a></code>.
</p>


<h3>Deprecated</h3>

<p>The following options are for backwards compatibility and should no longer be used.
</p>

<dl>
<dt>blnCasewise</dt><dd><p>same as <code>casewise</code>.</p>
</dd>
<dt>cov.sel</dt><dd><p>same as <code>cat.scovs</code>.</p>
</dd>
</dl>

<p>Options for requesting GLIM commands and data structures are no longer supported.
Specifying the input to <code>llbt.design</code> via a control list is also deprecated.
If you want to use these features you have to install <span class="pkg">prefmod</span> &lt;= 0.8-22.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>References</h3>


<p>Dittrich, R., Hatzinger, R., &amp; Katzenbeisser, W. (1998). Modelling the effect of subject-specific covariates in paired comparison studies with an application to university rankings.
<em>Journal of the Royal Statistical Society: Series C (Applied Statistics), 47</em>(4), 511&ndash;252.
<a href="https://doi.org/10.1111/1467-9876.00125">doi:10.1111/1467-9876.00125</a>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+llbt.worth">llbt.worth</a></code>,
<code><a href="#topic+llbtPC.fit">llbtPC.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># cems universities example
des &lt;- llbt.design(cemspc, nitems = 6, cat.scovs = "ENG")

res0 &lt;- gnm(y ~ o1+o2+o3+o4+o5+o6 + ENG:(o1+o2+o3+o4+o5+o6),
    eliminate = mu:ENG, data = des, family = poisson)
summary(res0)

# inclusion of g1 allows for an undecided effect
res &lt;- gnm(y ~ o1+o2+o3+o4+o5+o6 + ENG:(o1+o2+o3+o4+o5+o6) + g1,
    eliminate = mu:ENG, data = des, family = poisson)
summary(res)

# calculating and plotting worth parameters
wmat &lt;- llbt.worth(res)
plot(wmat)

# object specific covariates
LAT  &lt;- c(0, 1, 1, 0, 1, 0)        # latin cities
EC   &lt;- c(1, 0, 1, 0, 0, 1)
OBJ  &lt;- data.frame(LAT, EC)
des2 &lt;- llbt.design(cemspc, nitems = 6, objcovs = OBJ, cat.scovs = "ENG")
res2 &lt;- gnm(y ~ LAT + EC + LAT:ENG + g1,
    eliminate = mu:ENG, data = des2, family = poisson)

# calculating and plotting worth parameters
wmat2 &lt;- llbt.worth(res2)
wmat2
plot(wmat2)
</code></pre>

<hr>
<h2 id='llbt.fit'>Function to fit an LLBT</h2><span id='topic+llbt.fit'></span>

<h3>Description</h3>


<p>Function to fit an LLBT using an ELIMINATE feature
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llbt.fit(y, Xmodel, q, ncat, maxiter = 100)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="llbt.fit_+3A_y">y</code></td>
<td>
<p>response, usually counts</p>
</td></tr>
<tr><td><code id="llbt.fit_+3A_xmodel">Xmodel</code></td>
<td>
<p>design matrix</p>
</td></tr>
<tr><td><code id="llbt.fit_+3A_q">q</code></td>
<td>
<p>number of parameters to eliminate (usually number of comparisons times number of subject covariate levels</p>
</td></tr>
<tr><td><code id="llbt.fit_+3A_ncat">ncat</code></td>
<td>
<p>number of response categories</p>
</td></tr>
<tr><td><code id="llbt.fit_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations (default 100)</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Be careful when specifying the design matrix.
Since there is no extrinsic aliasing the matrix must have full rank.
Usually, one of the design columns for object must be left out.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>References</h3>


<p>Hatzinger, R., &amp; Francis, B. (2004). <em>Fitting paired comparison models in R.</em> <a href="https://epub.wu.ac.at/id/eprint/740">https://epub.wu.ac.at/id/eprint/740</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit basic model casewise
mfr &lt;- llbt.design(cemspc, nitems = 6,
    objnames = c("lo", "pa", "mi", "sg", "ba", "st"),
    casewise = TRUE)
mm   &lt;- model.matrix(~ lo+pa+mi+sg+ba + g1, data = mfr)
X    &lt;- mm[, -1]
p    &lt;- ncol(X)
ncat &lt;- 3
q    &lt;- length(levels(mfr$mu)) * length(levels(mfr$CASE))
llbt.fit(mfr$y, X, q, ncat)


# fit the (aggregated) model with one subject covariate
mfr &lt;- llbt.design(cemspc, nitems = 6,
    objnames = c("lo", "pa", "mi", "sg", "ba", "st"),
    cov.sel = "ENG")
eng  &lt;- mfr$ENG
eng  &lt;- factor(eng)
mm   &lt;- model.matrix(~ lo+pa+mi+sg+ba + g1 + (lo+pa+mi+sg+ba):eng, data = mfr)
X    &lt;- mm[, -1]
q    &lt;- length(levels(mfr$mu)) * length(levels(eng))
ncat &lt;- 3
llbt.fit(mfr$y, X, q, ncat)
</code></pre>

<hr>
<h2 id='llbt.worth'>Function to calculate and print worth parameters from LLBT model results</h2><span id='topic+llbt.worth'></span>

<h3>Description</h3>


<p>Worth parameters are calculated from the results of an LLBT model fit, i.e., from <code><a href="#topic+llbtPC.fit">llbtPC.fit</a></code> or from a <code>gnm</code>-fit, respectively.
For the latter, the function only works if the design matrix had been generated using <code>llbt.design</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
llbt.worth(fitobj, outmat = "worth")
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="llbt.worth_+3A_fitobj">fitobj</code></td>
<td>
<p>result of an LLBT model fit using either <code><a href="#topic+llbtPC.fit">llbtPC.fit</a></code> or <code><a href="igraph.html#topic+gnm">gnm</a></code> (having used a design matrix generated by <code><a href="#topic+llbt.design">llbt.design</a></code>).</p>
</td></tr>
<tr><td><code id="llbt.worth_+3A_outmat">outmat</code></td>
<td>
<p>a matrix of estimated worth parameters (<code>outmat = "worth"</code>, the default) or LLBT model parameters (<code>outmat = "lambda"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<p>If the LLBT model includes categorical subject covariates, the function provides estimates for all groups formed by the full crossclassification.
Numerical subject covariates are not implemented (yet)(see Warning below).
</p>


<h3>Value</h3>

<p><code>llbt.worth</code> returns a matrix of worth or model parameters.
If subject covariates have been specified, each column represents a group defined by the crossclassification of the subject covariates.
</p>
<p>In case of object-specific covariates (<code>gnm</code>-fit only) the rows are collapsed to the number of different combinations of object-specific covariate values and labelled accordingly.
Additionally, there is an attribute <code>objtable</code> containing a summary of original objects (items) and their reparameterisation with object-specific covariates.
This is a list or a matrix.
</p>
<p>The function <code><a href="#topic+plot.wmat">plot</a></code> gives a plot of the estimates.
</p>


<h3>Warning</h3>


<p>If the LLBT model has been fitted including numerical subject covariates, they are ignored.
However, estimates for the remaining predictors are calculated for convenience.
Please note, that these cannot be interpreted as standard estimates but are intercepts of the regression model where the objects (or reparameterised objects) are explained by one or more numerical subject covariates.
</p>


<h3>Note</h3>

<p>If a position effect has been fitted (for details see Dittrich, et. al., 1998), the corresponding variable must have been named <code>pos</code>.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>See Also</h3>

<p><code><a href="#topic+llbtPC.fit">llbtPC.fit</a></code>, <code><a href="#topic+llbt.design">llbt.design</a></code>, <code><a href="#topic+plot.wmat">plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># fit only first three objects with SEX effect
mod &lt;- llbtPC.fit(cemspc, nitems = 3, formel = ~SEX, elim = ~SEX, undec = TRUE)

# calculate and print worth parameters
mw &lt;- llbt.worth(mod)
mw

# the same using llbt.design and gnm
des &lt;- llbt.design(cemspc, nitems = 3, cat.scovs = "SEX")
m2  &lt;- gnm(y ~ o1+o2+o3 + SEX:(o1+o2+o3) + g1, elim = SEX:mu,
  data = des, family = poisson)

# calculate and plot worth parameters
w2 &lt;- llbt.worth(m2)
plot(w2)


# model with object specific covariates
latin &lt;- c(0, 1, 1, 0, 1, 0)     # object-specific covariate
LAT   &lt;- data.frame(LAT = latin) # objcovs must be data frame with named columns

onames &lt;- c("LO", "PA", "MI", "SG", "BA", "ST")

des &lt;- llbt.design(cemspc, nitems = 6, objnames = onames, objcovs = LAT)
m3  &lt;- gnm(y ~ LAT + g1, eliminate = mu, data = des, family = poisson)
w3  &lt;- llbt.worth(m3)
w3
attr(w3, "objtable")
</code></pre>

<hr>
<h2 id='llbtPC.fit'>Function to fit a loglinear Bradley-Terry model for paired comparisons</h2><span id='topic+llbtPC.fit'></span>

<h3>Description</h3>


<p>Function to fit a loglinear Bradley-Terry for paired comparisons allowing subject covariates and undecided response categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llbtPC.fit(obj, nitems, formel = ~1, elim = ~1, resptype = "paircomp",
        obj.names = NULL, undec = TRUE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="llbtPC.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of compared objects, not the number of comparisons</p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_elim">elim</code></td>
<td>
<p>the formula for the subject covariates that specify the table to be analysed. If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>. If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.</p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_resptype">resptype</code></td>
<td>
<p>is <code>"paircomp"</code> by default and is reserved for future usage. Any other specification will not change the behaviour of <code>llbtPC.fit</code> </p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="llbtPC.fit_+3A_undec">undec</code></td>
<td>
<p>for paired comparisons with a undecided/neutral category, a common parameter will be estimated if <code>undec = TRUE</code>.</p>
</td></tr></table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed.
See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the successive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>llbtPC.fit</code> returns an object of class <code>llbtMod</code>.
This object is basically a <code>gnm</code> object with an additional element <code>envList</code>.
This is a list with further details like the subject covariates design structure <code>covdesmat</code>, the model specification (<code>formel</code> and <code>elim</code>), the object names (<code>obj.names</code>), the number of items (<code>nobj</code>) and comparisons (<code>ncomp</code>), etc.
</p>
<p>The function <code><a href="#topic+llbt.worth">llbt.worth</a></code> can be used to produce a matrix of estimated worth parameters.
</p>


<h3>Input Data</h3>


<p>The responses have to be coded as 0/1 for paired comparisons without undecided category (0 means first object in a comparison preferred) or 0/1/2 for paired comparisons with an undecided category (where 1 is the undecided category).
Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
The leftmost columns in the data must be the responses to the paired comparisons (where the mandatory order of comparisons is (12) (13) (23) (14) (24) (34) (15) (25) etc.), optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>For an example see <code><a href="#topic+cemspc">cemspc</a></code>.
</p>


<h3>Note</h3>


<p>The function <code>llbtPC.fit</code> is a wrapper function for <code>gnm</code> and was designed to facilitate fitting of LLBTs with subject covariates and undecided categories.
More specialised setups (e.g., object-specific covariates) can be obtained using <code><a href="#topic+llbt.design">llbt.design</a></code> and then calling <code>gnm</code> (or <code><a href="stats.html#topic+glm">glm</a></code>) directly (see Examples for <code><a href="#topic+llbt.design">llbt.design</a></code>).
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>See Also</h3>

<p><code><a href="#topic+llbt.design">llbt.design</a></code>, <code><a href="#topic+pattL.fit">pattL.fit</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># cems universities example
res0 &lt;- llbtPC.fit(cemspc, nitems = 6, formel = ~1,   elim = ~ENG, undec = TRUE)
res1 &lt;- llbtPC.fit(cemspc, nitems = 6, formel = ~ENG, elim = ~ENG, undec = TRUE)

anova(res1, res0)
llbt.worth(res1)
</code></pre>

<hr>
<h2 id='music'>Data (ratings): Music (US General social survey 1993)</h2><span id='topic+music'></span>

<h3>Description</h3>


<p>The dataset contains data on 18 items referring to the liking of musical styles (ratings on a 5-point Likert type response scale) and three subject covariates.
The data is an excerpt from the US General Social Survey 1993.
Missing values have been removed from the subject variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>music</code></pre>


<h3>Format</h3>


<p>A data frame with 1597 observations.
The variables <code>bigb</code> through <code>hvym</code> are responses to items asking for liking/disliking of type of music:
Do you like it very much (1), like it (2), have mixed feelings (3), dislike it (4), dislike it very much (5).
</p>

<dl>
<dt><code>bigb</code></dt><dd><p>like or dislike bigband music</p>
</dd>
<dt><code>blug</code></dt><dd><p>like or dislike bluegrass music</p>
</dd>
<dt><code>coun</code></dt><dd><p>like or dislike country western music</p>
</dd>
<dt><code>blue</code></dt><dd><p>like or dislike blues or r and b music</p>
</dd>
<dt><code>musi</code></dt><dd><p>like or dislike broadway musicals</p>
</dd>
<dt><code>clas</code></dt><dd><p>like or dislike classical music</p>
</dd>
<dt><code>folk</code></dt><dd><p>like or dislike folk music</p>
</dd>
<dt><code>gosp</code></dt><dd><p>like or dislike gospel music</p>
</dd>
<dt><code>jazz</code></dt><dd><p>like or dislike jazz</p>
</dd>
<dt><code>lati</code></dt><dd><p>like or dislike latin music</p>
</dd>
<dt><code>mood</code></dt><dd><p>like or dislike easy listening music</p>
</dd>
<dt><code>newa</code></dt><dd><p>like or dislike new age music</p>
</dd>
<dt><code>oper</code></dt><dd><p>like or dislike opera</p>
</dd>
<dt><code>rap</code></dt><dd><p>like or dislike rap music</p>
</dd>
<dt><code>regg</code></dt><dd><p>like or dislike reggae music</p>
</dd>
<dt><code>conr</code></dt><dd><p>like or dislike contemporary rock music</p>
</dd>
<dt><code>oldi</code></dt><dd><p>like or dislike oldies rock music</p>
</dd>
<dt><code>hvym</code></dt><dd><p>like or dislike heavy metal music</p>
</dd>
<dt><code>age</code></dt><dd><p>age in years</p>
</dd>
<dt><code>educ</code></dt><dd><p>highest year of school completed</p>
</dd>
<dt><code>sex</code></dt><dd><p>1 male, 2 female</p>
</dd>
</dl>



<h3>Source</h3>








<p>Davis, J. A., Smith, T. W., &amp; Marsden, P. V. (2016)
<em>General Social Survey, 1993, 1998, 2000, 2002 with Cultural, Information Security, and Freedom Modules [United States]. Inter-university Consortium for Political and Social Research [distributor].</em> <a href="https://doi.org/10.3886/ICPSR35536.v2">doi:10.3886/ICPSR35536.v2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(music)
</code></pre>

<hr>
<h2 id='patt.design'>Paired Comparison Patterns &ndash; Design Matrix Generation</h2><span id='topic+patt.design'></span>

<h3>Description</h3>


<p>The function <code>patt.design</code> converts (i) real paired comparison responses, or (ii) a set of ratings (or Likert-type responses measured on a common scale), or (iii) full rankings into paired comparison patterns, returning a new data frame containing the design matrix for a loglinear paired comparison model.
Additionally, the frequencies of these patterns are computed and are stored in the first column of the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patt.design(obj, nitems = NULL, objnames = "", objcovs = NULL,
            cat.scovs = NULL, num.scovs = NULL, resptype = "paircomp",
            reverse = FALSE, ia = FALSE, casewise = FALSE, ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="patt.design_+3A_obj">obj</code></td>
<td>
<p>either a data frame or a data file name.</p>
</td></tr>
<tr><td><code id="patt.design_+3A_nitems">nitems</code></td>
<td>
<p>number of items (objects). <code>nitems</code> is not the number of comparisons!</p>
</td></tr>
<tr><td><code id="patt.design_+3A_objnames">objnames</code></td>
<td>

<p>an optional character vector with names for the objects.
These names are the columns names in the output data frame.
If <code>objnames</code> is not specified <code>o1</code>, <code>o2</code>, etc. will be used.
</p>
</td></tr>
<tr><td><code id="patt.design_+3A_objcovs">objcovs</code></td>
<td>

<p>an optional data frame with object specific covariates.
The rows correspond to the objects, the columns define the covariates.
The column names of this data frame are later used to fit the covariates.
Factors are not allowed.
In that case dummy variables have to be set up manually (favourably using <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>).
</p>
</td></tr>
<tr><td><code id="patt.design_+3A_cat.scovs">cat.scovs</code></td>
<td>

<p>a character vector with the names of the categorical subject covariates in the data file to be included into the design matrix.
(example: <code>cat.scovs = c("SEX", "WORK")</code>).
If all covariates in the data are categorical and should be included, the specification can be abbreviated to <code>cat.scovs = "ALL"</code>.
In that case, <code>num.scovs</code> must not be specified.
For no categorical covariates: <code>cat.scovs = ""</code>, the default.
</p>
</td></tr>
<tr><td><code id="patt.design_+3A_num.scovs">num.scovs</code></td>
<td>
<p>analogous to  <code>cat.scovs</code> for numerical (continuous) subject covariates. If any numerical covariates are specified, <code>casewise</code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="patt.design_+3A_resptype">resptype</code></td>
<td>
<p>one of <code>"paircomp"</code>, <code>"rating"</code>, or <code>"ranking"</code>.</p>
</td></tr>
<tr><td><code id="patt.design_+3A_reverse">reverse</code></td>
<td>

<p>If the responses are such that low values correspond to high preference (or agreement or rank) and high values to low preference (or agreement or ranks) (e.g., (1) <em>I strongly agree</em> ... (5) <em>I strongly disagree</em>) then <code>reverse</code> should be specified to be <code>FALSE</code>, the default.
Otherwise set <code>reverse = TRUE</code>.
The only exception is paired comparison responses that are coded <code class="reqn">-1</code>/<code class="reqn">1</code>, <code class="reqn">-1</code>/<code class="reqn">0</code>/<code class="reqn">1</code>, <code class="reqn">-2</code>/<code class="reqn">-1</code>/<code class="reqn">0</code>/<code class="reqn">1</code>/<code class="reqn">2</code>, etc.
Then negative numbers are treated as not preferred.
(See Input Data below)
</p>
</td></tr>
<tr><td><code id="patt.design_+3A_ia">ia</code></td>
<td>
<p>generates covariates for interactions between comparisons if <code>ia = TRUE</code>.</p>
</td></tr>
<tr><td><code id="patt.design_+3A_casewise">casewise</code></td>
<td>

<p>If <code>casewise = TRUE</code> a separate design structure is set up for each subject in the data.
This is required when fitting continuous subject covariates.
However, the design can become very large in the case of many subjects and/or comparisons.
See Details below.
</p>
</td></tr>
<tr><td><code id="patt.design_+3A_...">...</code></td>
<td>
<p>deprecated options to allow for backwards compatibility (see Deprecated below).</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function <code>patt.design</code> allows for different scenarios mainly concerning
</p>

<ul>
<li><p><strong>responses.</strong>
Currently, three types of responses can be specified.
</p>

<ul>
<li><p><strong><em>paired comparison data.</em></strong>
Responses can be either simply <em>preferred</em> &ndash; <em>not preferred</em> or ordinal (<em>strongly preferred</em> &ndash; ... &ndash; <em>not at all preferred</em>).
In both cases an undecided category may or may not occur.
If there are more than three categories a they are reduced to two or three response categories.
The set of paired comparison responses represents a response pattern.
</p>
</li>
<li><p><strong><em>ratings/Likert type responses.</em></strong>
The responses to Likert type items are transformed to paired comparison responses by calculating the difference between each pair of the Likert items.
This leads to an ordinal (adjacent categories) paired comparison model with 2<code class="reqn">k</code>-1 response categories where <code class="reqn">k</code> is the number of the (original) Likert categories.
Again, the transformed ratings are reduced to three response categories (<em>preferred</em> &ndash; <em>undecided</em> &ndash; <em>not preferred</em>).
</p>
</li>
<li><p><strong><em>rankings.</em></strong>
Currently only full rankings are allowed, i.e., a (consecutive) integer must uniquely be assigned to each object in a list according to the (subjective) ordering.
Ties are not allowed.
As for ratings, the rankings are transformed to paired comparison responses by calculating the difference between each pair of the ranks.
Again a category reduction (as described above) is automatically performed.
</p>
</li></ul>

</li>
<li><p><strong>comparison covariates.</strong>
The design matrix for the basic model has columns for the items (objects) and (depending on the type of responses) for undecided comparisons.
For ratings (Likert type) undecided comparisons occur if any subject has responded to two items in the same category.
For paired comparisons it depends on the design.
For rankings there are no undecided categories.
If undecided categories occur there is one dummy variable for each comparison.
Additionally, covariates for two way interaction between comparisons (i.e., for effects resulting from the dependence between two comparisons that have one item in common) can be obtained by setting <code>ia = TRUE</code>.
</p>
</li>
<li><p><strong>object specific covariates.</strong>
For modelling certain characteristics of objects a reparameterisation can be included in the design.
This is sometimes called conjoint analysis.
The object specific covariates can be continuous or dummy variables.
For the specification see Argument <code>objcovs</code> above.
</p>
</li>
<li><p><strong>subject covariates.</strong>
For modelling different preference scales for the items according to characteristics of the respondents categorical subject covariates can be included in the design.
The corresponding variables are defined as numerical vectors where the levels are specified with consecutive integers starting with 1.
This format must be used in the input data file and is also used in all outputs.
</p>
</li></ul>



<h3>Value</h3>


<p>The output is a dataframe.
Each row represents a unique response pattern.
If subject covariates are specified, each row instead represents a particular combination of a unique covariate combination with a response pattern.
All possible combinations are generated.
</p>
<p>The first column contains the counts for the paired comparison response patterns and is labelled with <code>Y</code>.
The next columns are the covariates for the items and the undecided category effects (one for each comparison).
These are labelled as <code>u12</code>, <code>u13</code>, etc., where <code>12</code> denotes the comparison between items <code>1</code> and <code>2</code>.
Optionally, covariates for dependencies between comparisons follow.
The columns are labelled <code>Ia.bc</code> denoting the interaction of the comparisons between items <code>(a, b)</code> and <code>(a, c)</code> where the common item is <code>a</code>.
If subject covariates are present they are in the rightmost columns and defined to be factors.



</p>


<h3>Input Data</h3>


<p>Responses have to be coded as consecutive integers (e.g., (0, 1), or (1, 2, 3, ...), where the smallest value corresponds to (highest) preference for the first object in a comparison.
</p>
<p>For (ordinal) paired comparison data (<code>resptype = "paircomp"</code>) the codings <code class="reqn">(1, -1)</code>, <code class="reqn">(2, 1, -1, -2)</code>, <code class="reqn">(1, 0, -1)</code>, <code class="reqn">(2, 1, 0, -1, -2)</code> etc. can also be used.
Then negative numbers correspond to not preferred, 0 to undecided.
Missing responses are not allowed (use functions <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>, <code><a href="#topic+pattL.fit">pattL.fit</a></code>, or <code><a href="#topic+pattR.fit">pattR.fit</a></code> instead).
</p>
<p>Input data (via the first argument <code>obj</code> in the function call) is specified either through a dataframe or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>The leftmost columns must be the responses to the paired comparisons, ratings (Likert items), or rankings.
For paired comparisons the mandatory order is of comparisons is (12) (13) (23) (14) (24) (34) (15) (25) etc. For rankings, the lowest value means highest rank according to the underlying scale.
Each column in the data file corresponds to one of the ranked objects.
For example, if we have 3 objects denoted by <code>A</code>, <code>B</code>, and <code>C</code>, with corresponding columns in the data matrix, the response pattern <code>(3, 1, 2)</code> represents: object <code>B</code> ranked highest, <code>C</code> ranked second, and <code>A</code> ranked lowest.
For ratings.
again the lowest value means highest &lsquo;endorsement&rsquo; (agreement) according to the underlying scale.
All items are assumed to have the same number of response category.
</p>
<p>The columns for responses are optionally followed  by columns for subject covariates.
If categorical, they have to be specified such that the categories are represented by consecutive integers starting with 1.
Missing values are not allowed and treated such that rows with <code>NA</code>s are removed from the resulting design structure and a message is printed.
For an example see <code><a href="#topic+xmpl">xmpl</a></code>.
</p>
<p>(Besides supplying data via a dataframe or a datafile name, <code>obj</code> can also be specified as a control list with the same elements as the arguments in the function call.
The data must then be specified as a path/filename using the element <code>datafile = "filename"</code>.
The control list feature is deprecated.
An example is given below.)
</p>


<h3>Deprecated</h3>


<p>The following options are for backwards compatibility and should no longer be used.
</p>

<dl>
<dt>blnCasewise</dt><dd><p>same as <code>casewise</code>.</p>
</dd>
<dt>blnIntcovs</dt><dd><p>same as <code>ia</code>.</p>
</dd>
<dt>blnRevert</dt><dd><p>same as <code>reverse</code>.</p>
</dd>
<dt>cov.sel</dt><dd><p>same as <code>cat.scovs</code>.</p>
</dd>
</dl>

<p>Options for requesting GLIM commands and data structures are no longer supported.
Specifying the input to <code>llbt.design</code> via a control list is also deprecated.
If you want to use these features you have to install <span class="pkg">prefmod</span> &lt;= 0.8-22.
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>References</h3>


<p>Dittrich, R., Francis, B.J., Hatzinger R., Katzenbeisser, W. (2007),
A Paired Comparison Approach for the Analysis of Sets of Likert Scale Responses.
<em>Statistical Modelling</em>, Vol. 7, No. 1, 3&ndash;28.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+llbt.design">llbt.design</a></code>,
<code><a href="#topic+pattPC.fit">pattPC.fit</a></code>, <code><a href="#topic+pattL.fit">pattL.fit</a></code>, <code><a href="#topic+pattR.fit">pattR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mini example with three Likert items and two subject covariates
dsgnmat &lt;- patt.design(xmpl, nitems = 3, resptype = "rating",
      ia = TRUE, cov.sel = "ALL")
head(dsgnmat)


# ILLUSTRATING THE ISSP2000 EXAMPLE
# simplified version of the analysis as given in Dittrich et. al (2007).
design &lt;- patt.design(issp2000, nitems = 6, resptype = "rating",
      cov.sel = c("SEX", "EDU"))


# - fit null multinomial model (basic model for items without subject
#     covariates) through Poisson distribution.
# - SEX:EDU parameters are nuisance parameters
# - the last item (GENE) becomes a reference item in the model and is aliased;
#     all other items are compared to this last item

# item parameters with undecided effects and no covariate effects.
summary(glm(y ~ SEX*EDU
  + CAR+IND+FARM+WATER+TEMP+GENE
  + u12+u13+u23+u14+u24+u34+u15+u25+u35+u45+u16+u26+u36+u46+u56,
  data = design, family = poisson))

# now add main effect of SEX on items
summary(glm(y ~ SEX:EDU
  + CAR+IND+FARM+WATER+TEMP+GENE
  + (CAR+IND+FARM+WATER+TEMP+GENE):SEX
  + u12+u13+u23+u14+u24+u34+u15+u25+u35+u45+u16+u26+u36+u46+u56,
  data = design, family = poisson))
</code></pre>

<hr>
<h2 id='patt.worth'>Function to calculate and print worth parameters from pattern model results</h2><span id='topic+patt.worth'></span>

<h3>Description</h3>


<p>Worth parameter are calculated from the results of a pattern model fit, i.e., from <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>, <code><a href="#topic+pattR.fit">pattR.fit</a></code>, <code><a href="#topic+pattL.fit">pattL.fit</a></code>, and <code><a href="#topic+pattLrep.fit">pattLrep.fit</a></code> or from a <code>gnm</code>-fit, respectively.
For the latter, the function only works if the design matrix had been generated using <code>patt.design</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patt.worth(fitobj, obj.names = NULL, outmat = "worth")
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="patt.worth_+3A_fitobj">fitobj</code></td>
<td>
<p>Object of class <code>pattMod</code> obtained from pattern model fit.</p>
</td></tr>
<tr><td><code id="patt.worth_+3A_obj.names">obj.names</code></td>
<td>
<p>names for the objects, for repeated measurement models just the names of objects for the first time point</p>
</td></tr>
<tr><td><code id="patt.worth_+3A_outmat">outmat</code></td>
<td>
<p>a matrix of estimated worth parameters (<code>outmat = "worth"</code>, the default) or pattern model parameters (<code>outmat = "lambda"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<p>If the pattern model includes categorical subject covariates, the function provides estimates for all groups formed by the full crossclassification.
Numerical subject covariates are not implemented (yet)(see Warning below).
</p>


<h3>Value</h3>


<p><code>patt.worth</code> returns a matrix of worth or model parameters.
If subject covariates have been specified, each column represents a groups defined by the crossclassification of the subject covariates.
</p>
<p>The function <code><a href="#topic+plot.wmat">plot</a></code> gives a plot of the estimates.
</p>


<h3>Warning</h3>


<p>If the pattern model has been fitted including numerical subject covariates, they are ignored.
However, estimates for the remaining predictors are calculated for convenience.
Please note, that these cannot be interpreted as standard estimates but are intercepts of the regression model where the objects (or reparameterised objects) are explained by one or more numerical subject covariates.
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>See Also</h3>


<p><code><a href="#topic+pattPC.fit">pattPC.fit</a></code>,
<code><a href="#topic+pattR.fit">pattR.fit</a></code>,
<code><a href="#topic+pattL.fit">pattL.fit</a></code>,
<code><a href="#topic+pattLrep.fit">pattLrep.fit</a></code>,
<code><a href="#topic+plot.wmat">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit only first three objects with SEX effect
m2 &lt;- pattPC.fit(cemspc, nitems = 3, formel = ~SEX, elim = ~SEX, undec = TRUE)

# calculate and print worth parameters
m2worth &lt;- patt.worth(m2)
m2worth
</code></pre>

<hr>
<h2 id='pattL.fit'>Function to fit a pattern model for ratings (Likert items)</h2><span id='topic+pattL.fit'></span>

<h3>Description</h3>


<p>Function to fit a pattern model for ratings/Likert items (transformed to paired comparisons) allowing for missing values using a CL approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattL.fit(obj, nitems, formel = ~1, elim = ~1, resptype = "rating",
        obj.names = NULL, undec = TRUE, ia = FALSE, NItest = FALSE,
        pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattL.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of items</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_elim">elim</code></td>
<td>

<p>the formula for the subject covariates that specify the table to be analysed.
If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>.
If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.
</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_resptype">resptype</code></td>
<td>
<p>is <code>"rating"</code> by default and is reserved for future usage. Any other specification will not change the behaviour of <code>pattL.fit</code></p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_undec">undec</code></td>
<td>
<p>for paired comparisons with a undecided/neutral category, a common parameter will be estimated if <code>undec = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_ia">ia</code></td>
<td>
<p>interaction parameters between comparisons that have one object in common if <code>ia = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_nitest">NItest</code></td>
<td>

<p>separate estimation of object parameters for complete and incomplete patterns if <code>NItest = TRUE</code>.
Currently, <code>NItest</code> is set to <code>FALSE</code> if subject covariates are specified.
</p>
</td></tr>
<tr><td><code id="pattL.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>a dot is printed at each iteration cycle if set to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed.
See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the succesive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>pattL.fit</code> returns an object of class <code>pattMod</code>.
The function <code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.pattMod">print.pattMod</a></code>) can be used to print the results and the function <code><a href="#topic+patt.worth">patt.worth</a></code> to produce a matrix of worth parameters.
</p>
<p>An object of class <code>pattMod</code> is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>log-likelihood of the saturated model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a list of results from the fitting routine (see Value of <code><a href="stats.html#topic+nlm">nlm</a></code>).</p>
</td></tr>
<tr><td><code>envList</code></td>
<td>
<p>a list with further fit details like subject covariates design structure <code>covdesmat</code>, paired comparison response pattern matrix <code>Y</code>, etc.</p>
</td></tr>
<tr><td><code>partsList</code></td>
<td>

<p>a list of the basic data structures for each subgroup defined by crossing all covariate levels and different missing value patterns.
Each element of <code>partsList</code> is again a list containing counts, missing value pattern, the CL matrix represented as a vector, and the specification of the covariates.
Use <code><a href="utils.html#topic+str">str</a></code> to inspect the elements and see example below.
</p>
</td></tr>
</table>


<h3>Input Data</h3>


<p>The responses have to be coded as consecutive integers starting with 1 (or 0).
The value of 1 (0) means highest &lsquo;endorsement&rsquo; (agreement) according to the underlying scale.
Missing values are coded as <code>NA</code>, rows with less than 2 valid responses are removed from the fit and a message is printed.
</p>
<p>Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
The leftmost columns in the data must be the rankings, optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>For an example see <code><a href="#topic+issp2000">issp2000</a></code>.
</p>


<h3>Warning</h3>


<p>The size of the table to be analysed increases dramatically with the number of items.
For ratings (Likert items) the number of paired comparison response categories is always three.
The number of rows of the table to set up the design matrix is initially <code class="reqn">(2 * number of categories - 1) ^ (number of items)</code>, e.g., for six items with 5 response categories each this is 531441.
A reasonable maximum number of items with five response categories to be analysed with pattern models is 7.
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>See Also</h3>


<p><code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+pattPC.fit">pattPC.fit</a></code>,
<code><a href="#topic+pattR.fit">pattR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit only four items
music4 &lt;- music[, c("jazz", "blue", "folk", "rap")]
pattL.fit(music4, nitems = 4)

# fit additional undecided effect
pattL.fit(music4, nitems = 4, undec = TRUE)

# fit dependence parameters
## Not run: pattL.fit(music4, nitems = 4, undec = TRUE, ia = TRUE)

# check for ignorable missing
pattL.fit(music4, nitems = 4, undec = TRUE, NItest = TRUE)
</code></pre>

<hr>
<h2 id='pattLrep.fit'>Function to fit a pattern model for repeated ratings (Likert items)</h2><span id='topic+pattLrep.fit'></span>

<h3>Description</h3>


<p>Function to fit a pattern model for repeated ratings/Likert items (transformed to paired comparisons) allowing for missing values using a CL approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
pattLrep.fit(obj, nitems, tpoints = 1, formel = ~1, elim = ~1,
        resptype = "ratingT",  obj.names = NULL, undec = TRUE, ia = FALSE,
        iaT = FALSE, NItest = FALSE, pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattLrep.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of items at one time point.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_tpoints">tpoints</code></td>
<td>
<p>the number of time points.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_elim">elim</code></td>
<td>

<p>the formula for the subject covariates that specify the table to be analysed.
If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>.
If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.
</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_resptype">resptype</code></td>
<td>
<p>is <code>"ratingT"</code> by default and is reserved for future usage. Any other specification will not change the behaviour of <code>pattLrep.fit</code></p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_undec">undec</code></td>
<td>
<p>for paired comparisons with a undecided/neutral category, a common parameter will be estimated if <code>undec = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_ia">ia</code></td>
<td>
<p>for each time point interaction parameters between comparisons that have one object in common if <code>ia = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_iat">iaT</code></td>
<td>
<p>if <code>iaT = TRUE</code>, dependence parameters for each item between two successive time points.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_nitest">NItest</code></td>
<td>
<p>separate estimation of object parameters for complete and incomplete patterns if <code>NItest = TRUE</code>. Currently, <code>NItest</code> is set to <code>FALSE</code> if subject covariates are specified.</p>
</td></tr>
<tr><td><code id="pattLrep.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>a dot is printed at each iteration cycle if set to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed (redundant terms are removed automatically).
See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the successive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>pattLrep.fit</code> returns an object of class <code>pattMod</code>.
The function <code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.pattMod">print.pattMod</a></code>) can be used to print the results and the function <code><a href="#topic+patt.worth">patt.worth</a></code> to produce a matrix of worth parameters.
</p>
<p>An object of class <code>pattMod</code> is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>log-likelihood of the saturated model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a list of results from the fitting routine (see Value of <code><a href="stats.html#topic+nlm">nlm</a></code>).</p>
</td></tr>
<tr><td><code>envList</code></td>
<td>
<p>a list with further fit details like subject covariates design structure <code>covdesmat</code>, paired comparison response pattern matrix <code>Y</code>, etc.</p>
</td></tr>
<tr><td><code>partsList</code></td>
<td>

<p>a list of the basic data structures for each subgroup defined by crossing all covariate levels and different missing value patterns.
Each element of <code>partsList</code> is again a list containing counts, missing value pattern, the CL matrix represented as the vector <code>s</code>, and the specification of the covariates.
Use <code><a href="utils.html#topic+str">str</a></code> to inspect the elements and see example below.
</p>
</td></tr>
</table>


<h3>Input Data</h3>

<p>The input data must have the following order (from left to right): all items at first time point, all items at second time point (with the same order as before), etc. for the other time points, optional subject covariates.
The responses have to be coded as consecutive integers starting with 1 (or 0).
The value of 1 (0) means highest &lsquo;endorsement&rsquo; (agreement) according to the underlying scale.
Missing values are coded as <code>NA</code>, rows with less than 2 valid responses are removed from the fit and a message is printed.
</p>
<p>Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
Again, the leftmost columns in the data must be the ratings, optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>


<h3>Warning</h3>


<p>The size of the table to be analysed increases dramatically with the number of items and time points.
For ratings (Likert items) the number of paired comparison response categories is always three.
For each time point the number of rows of the table to set up the design matrix is initially <code class="reqn">(2 * number of categories - 1) ^ (number of items)</code>.
After reducing to three categories the number of patterns are 13, 75, 541 for 3 to 5 items, respectively.
Generally, the number of rows in the design matrix is <code class="reqn">(number of patterns) ^ (number of timepoints)</code>.
The number of covariate levels and the number of missing value patterns have effects only on the run time.
A (reasonable) maximum number of items for two time points is 5, for three timepoints 4, and for four to five timepoints 3.
</p>


<h3>Note</h3>


<p>The number of timepoints can also be regarded as different response dimensions.
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>See Also</h3>


<p><code><a href="#topic+pattL.fit">pattL.fit</a></code>,
<code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+pattPC.fit">pattPC.fit</a></code>,
<code><a href="#topic+pattR.fit">pattR.fit</a></code>,
<code><a href="#topic+pattRrep.fit">pattRrep.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulated data: 3 items, 2 timepoints
dat &lt;- as.data.frame(matrix(sample(1:5, 300, replace = TRUE), ncol = 6))
res &lt;- pattLrep.fit(dat, nitems = 3, tpoints = 2, iaT = TRUE)
res
patt.worth(res, obj.names = LETTERS[1:3])
</code></pre>

<hr>
<h2 id='pattnpml.fit'>NPML estimation for paired comparison models</h2><span id='topic+pattnpml.fit'></span>

<h3>Description</h3>


<p>Fits a mixture model to overdispersed paired comparison data using non-parametric maximum likelihood (Aitkin, 1996a).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattnpml.fit(formula, random = ~1, k = 1, design,
        tol = 0.5, startp = NULL, EMmaxit = 500, EMdev.change = 0.001,
        seed = NULL, pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="pattnpml.fit_+3A_formula">formula</code></td>
<td>
<p>A formula defining the response (the count of the number of cases of each pattern) and the fixed effects (e.g. <code>y ~ x</code>).</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_random">random</code></td>
<td>
<p>A formula defining the random model.  If there are three objects labelled o1, o2, o3, set <code>random = ~o1+o2+o3</code> to model overdispersion. For more details, see below.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_k">k</code></td>
<td>
<p>The number of mass points (latent classes). Up to 21 mass points are supported.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_design">design</code></td>
<td>
<p>The design data frame for paired comparison data as generated using  <code><a href="#topic+patt.design">patt.design</a></code> (mandatory, even if it is attached to the workspace!).</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_tol">tol</code></td>
<td>
<p>The <code>tol</code> scalar (usually, <code class="reqn">0 &lt; </code><code>tol</code> <code class="reqn">\le 1</code>). This scalar sets the scaling factor for the locations of the initial mass points. A larger value means that the starting point locations are more widely spread.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_startp">startp</code></td>
<td>
<p>Optional numerical vector of length <code>k</code> specifying the starting probabilities for the mass points to initialise the EM algorithm. The default is to take Gaussian quadrature probabilities.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_emmaxit">EMmaxit</code></td>
<td>
<p>The maximum number of EM iterations.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_emdev.change">EMdev.change</code></td>
<td>
<p>Stops EM algorithm when deviance change falls below this value.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_seed">seed</code></td>
<td>
<p>Seed for random weights. If <code>NULL</code>, the seed is set using the system time.</p>
</td></tr>
<tr><td><code id="pattnpml.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>A dot is printed at each iteration cycle of the EM algorithm if set to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function <code>pattnpml.fit</code> is a wrapper function for <code>alldistPC</code> which in turn is a modified version of the function <code>alldist</code> from the <span class="pkg">npmlreg</span> package.
</p>
<p>The non-parametric maximum likelihood (NPML) approach was introduced in Aitkin (1996) as a tool to fit overdispersed generalised linear models.
The idea is to approximate the unknown and unspecified distribution of the random effect by a discrete mixture of exponential family densities, leading to a simple expression of the marginal likelihood which can then be maximised using a standard EM algorithm.
</p>
<p>This function extends the NPML approach to allow fitting of overdispersed paired comparison models.
It assumes that overdispersion arises because of dependence in the patterns.
Fitting a non-parametric random effects term is equivalent to specifying distinct latent classes of response patterns.
</p>
<p>The number of components <code>k</code> of the finite mixture has to be specified beforehand.
</p>
<p>The EM algorithm used by the function takes the Gauss-Hermite masses and mass points as starting points.
The position of the starting points can be concentrated or extended by setting <code>tol</code> smaller or larger, respectively; the initial mass point probabilities of the starting points can also be specified through <code>startp</code>.
</p>
<p>Fitting models for overdispersion can be achieved by specifying the paired comparison items as additive terms in the random part of the model formula.
A separate estimate for each item and for each mass point is produced.
</p>
<p>Fitting subject covariate models with the same effect for each mass point component is achieved by specifying as part of the <code>formula</code> a) a subject factor giving a different estimate for each covariate combination b) an interaction of the chosen subject covariates with the objects.
For models with subject factor covariates only, the first term is simply the interaction of all of the factor covariates.
</p>
<p>Fitting subject covariate models with a different effect for each mass point component (sometimes called random coefficient models, see Aitkin, Francis, Hinde and Darnell, 2009, pp. 497) is possible by specifying an interaction of the subject covariates with the items in the <code>random</code> term, and also in the <code>formula</code> part.
Thus the setting <code>random = ~x:(o1+o2+o3</code> gives a model with a set of random slopes (one set for each mass point) and a set of random intercepts, one set for each mass point.
</p>
<p>The <code>AIC</code> and <code>BIC</code> functions from the <span class="pkg">stats</span>-package can be used.
</p>


<h3>Value</h3>


<p>The function produces an object of class <code>pattNPML</code>.
The object contains the following 29 components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients (including the mass points). In case of Gaussian quadrature, the coefficient given at <code>z</code> corresponds to the standard deviation of the mixing distribution.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the difference between the true response and the empirical Bayes predictions.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the empirical Bayes predictions (Aitkin, 1996b) on the scale of the responses.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the &lsquo;family&rsquo; object used.</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the extended linear predictors <code class="reqn">\hat{\eta}_{ik}</code>.</p>
</td></tr>
<tr><td><code>disparity</code></td>
<td>
<p>the disparity (<code>-2logL</code>) of the fitted mixture regression model.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the deviance of the fitted mixture regression model.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model (just containing an intercept), comparable with &lsquo;deviance.&rsquo;</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom of the fitted model (including the random part).</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the (extended) response vector.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>the formula supplied.</p>
</td></tr>
<tr><td><code>random</code></td>
<td>
<p>the random term of the model formula.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>the data argument.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the (extended) design matrix.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the case weights initially supplied.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset initially supplied.</p>
</td></tr>
<tr><td><code>mass.points</code></td>
<td>
<p>the fitted mass points.</p>
</td></tr>
<tr><td><code>masses</code></td>
<td>
<p>the mass point probabilities corresponding to the patterns.</p>
</td></tr>
<tr><td><code>sdev</code></td>
<td>

<p>a list of the two elements <code>sdev$sdev</code> and <code>sdev$sdevk</code>.
The former is the estimated standard deviation of the Gaussian mixture components (estimated over all mixture components), and the latter gives the unequal or smooth component-specific standard deviations.
All values are equal if <code>lambda = 0</code>.
</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>a list of the two elements <code>shape$shape</code> and <code>shape$shapek</code>, to be interpreted in analogy to sdev.</p>
</td></tr>
<tr><td><code>rsdev</code></td>
<td>
<p>estimated random effect standard deviation.</p>
</td></tr>
<tr><td><code>post.prob</code></td>
<td>
<p>a matrix of posteriori probabilities.</p>
</td></tr>
<tr><td><code>post.int</code></td>
<td>
<p>a vector of &lsquo;posteriori intercepts&rsquo; (as in Sofroniou et al. (2006)).</p>
</td></tr>
<tr><td><code>ebp</code></td>
<td>
<p>the empirical Bayes Predictions on the scale of the linear predictor. For compatibility with older versions.</p>
</td></tr>
<tr><td><code>EMiter</code></td>
<td>
<p>gives the number of iterations of the EM algorithm.</p>
</td></tr>
<tr><td><code>EMconverged</code></td>
<td>
<p>logical value indicating if the EM algorithm converged.</p>
</td></tr>
<tr><td><code>lastglm</code></td>
<td>
<p>the fitted <code>glm</code> object from the last EM iteration.</p>
</td></tr>
<tr><td><code>Misc</code></td>
<td>
<p>contains additional information relevant for the summary and plot functions, in particular the disparity trend and the EM trajectories.</p>
</td></tr>
</table>
<p>For further details see the help file for function <code>alldist</code> in package <span class="pkg">npmlreg</span>.
</p>


<h3>Note</h3>


<p>The mass point probabilities given in the output are the proportion of patterns estimated to contribute to each mass point.
To estimate the  proportion  of cases contributing to each mass point the posterior probabilities need to be averaged over patterns with observed counts as weights (see example below).
</p>


<h3>Author(s)</h3>


<p>Originally translated from the GLIM 4 functions <code>alldist</code> and <code>allvc</code> (Aitkin &amp; Francis, 1995) to <span class="rlang"><b>R</b></span> by Ross Darnell (2002).
Modified, extended, and prepared for publication by Jochen Einbeck and John Hinde (2006).
Adapted for paired comparison modelling by Reinhold Hatzinger and Brian Francis (2009).
</p>


<h3>References</h3>


<p>Aitkin, M. (1996). A general maximum likelihood analysis of overdispersion in generalized linear models. <em>Statistics and Computing, 6</em>(3), 251&ndash;262. <a href="https://doi.org/10.1007/BF00140869">doi:10.1007/BF00140869</a>
</p>
<p>Aitkin, M., Francis, B., Hinde, J., &amp; Darnell, R. (2009). <em>Statistical Modelling in R.</em> Oxford: Oxford University Press.
</p>
<p>Einbeck, J., &amp; Hinde, J. (2006). A Note on NPML Estimation for Exponential Family Regression Models with Unspecified Dispersion Parameter. <em>Austrian Journal of Statistics, 35</em>(2&amp;3), 233&ndash;243.
</p>
<p>Sofroniou, N., Einbeck, J., &amp; Hinde, J. (2006). Analyzing Irish suicide rates with mixture models. Proceedings of the 21st International Workshop on Statistical Modelling in Galway, Ireland, 2006.
</p>


<h3>See Also</h3>


<p><code><a href="stats.html#topic+glm">glm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two latent classes for paired comparison data
dfr   &lt;- patt.design(dat4, 4)
modPC &lt;- pattnpml.fit(y ~ 1, random = ~o1 + o2 + o3, k = 2, design = dfr)
modPC

# estimated proportion of cases in each mixture component
apply(modPC$post.prob, 2, function(x){ sum(x * dfr$y / sum(dfr$y)) })

## Not run: 
# fitting a model for two latent classes and fixed categorical subject
# covariates to the Eurobarometer 55.2 data (see help("euro55.2.des"))
# on rankings of sources of information on scientific developments

model2cl &lt;- pattnpml.fit(
  y ~ SEX:AGE4 + (SEX + AGE4):(TV + RAD + NEWSP + SCIMAG + WWW + EDINST) - 1,
  random = ~ TV + RAD + NEWSP + SCIMAG + WWW + EDINST,
  k = 2, design = euro55.2.des, pr.it = TRUE)
summary(model2cl)
BIC(model2cl)
## End(Not run)
</code></pre>

<hr>
<h2 id='pattPC.fit'>Function to fit a pattern model for paired comparisons</h2><span id='topic+pattPC.fit'></span>

<h3>Description</h3>


<p>Function to fit a pattern model for paired comparisons allowing for missing values using a CL approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattPC.fit(obj, nitems, formel = ~1, elim = ~1, resptype = "paircomp",
    obj.names = NULL, undec = TRUE, ia = FALSE, NItest = FALSE,
    NI = FALSE, MIScommon = FALSE, MISmodel = "obj", MISalpha = NULL,
    MISbeta = NULL, pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="pattPC.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of compared objects, not the number of comparisons</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_elim">elim</code></td>
<td>

<p>the formula for the subject covariates that specify the table to be analysed.
If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>.
If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.
</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_resptype">resptype</code></td>
<td>
<p>is <code>"paircomp"</code> by default and is reserved for future usage. Any other specification will not change the behaviour of <code>pattPC.fit</code></p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_undec">undec</code></td>
<td>
<p>for paired comparisons with a undecided/neutral category, a common parameter will be estimated if <code>undec = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_ia">ia</code></td>
<td>
<p>interaction parameters between comparisons that have one object in common if <code>ia = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_nitest">NItest</code></td>
<td>

<p>separate estimation of object parameters for complete and incomplete patterns if <code>NItest = TRUE</code>.
Currently, <code>NItest</code> is set to <code>FALSE</code> if subject covariates are specified.
</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_ni">NI</code></td>
<td>
<p>if <code>TRUE</code>, fits large table (crossclassification with <code>NA</code> patterns), for comparison with models including <code>MISalpha</code> (and <code>MISbeta</code>).</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_miscommon">MIScommon</code></td>
<td>
<p>if <code>TRUE</code>, fits a common parameter for <code>NA</code> indicators, i.e., <code class="reqn">\alpha = \alpha_i = \alpha_j = \dots</code>.</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_mismodel">MISmodel</code></td>
<td>

<p>either <code>obj</code> (default) or <code>comp</code>.
Specifies the model for missing values.
If <code>obj</code>, parameters for missing objects or if <code>comp</code>, parameters for missing comparisons are estimated.
In both cases <code>MISalpha</code> (and optionally <code>MISbeta</code>) specify which parameters are involved.
</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_misalpha">MISalpha</code></td>
<td>

<p>if not <code>NULL</code>, specification to fit parameters for <code>NA</code> indicators using a logical vector, where <code>TRUE</code> means that the <code>NA</code> indicator parameter for the corresponding object (or comparison, dependent on <code>MISmodel</code>) should be estimated (see example below).
For <code>MISmodel = "obj"</code> each comparison is reparameterised with <code class="reqn">\alpha_i+\alpha_j</code>, for <code>MISmodel = "comp"</code> each comparison is reparameterised with <code class="reqn">\alpha_{ij}</code>.
</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_misbeta">MISbeta</code></td>
<td>

<p>if not <code>NULL</code>, fits parameters for MNAR model, i.e., interactions between outcome model parameters and <code>NA</code> indicator parameters.
The reparameterisation is analogous to <code>MISalpha</code>.
Usually, the specification for <code>MISbeta</code> is the same as for <code>MISalpha</code>, but any subset is reasonable.
If <code>MISalpha = NULL</code> but <code>MISbeta</code> is not, then <code>MISalpha</code> is set to  <code>MISbeta</code>.
</p>
</td></tr>
<tr><td><code id="pattPC.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>a dot is printed at each iteration cycle if set to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed. See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the successive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>pattPC.fit</code> returns an object of class <code>pattMod</code>.
The function <code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.pattMod">print.pattMod</a></code>) can be used to print the results and the function <code><a href="#topic+patt.worth">patt.worth</a></code> to produce a matrix of the estimated worth parameters.
</p>
<p>An object of class <code>pattMod</code> is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>log-likelihood of the saturated model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a list of results from the fitting routine (see Value of <code><a href="stats.html#topic+nlm">nlm</a></code>).</p>
</td></tr>
<tr><td><code>envList</code></td>
<td>
<p>a list with further fit details like subject covariates design structure <code>covdesmat</code>, paired comparison response pattern matrix <code>Y</code>, etc.</p>
</td></tr>
<tr><td><code>partsList</code></td>
<td>

<p>a list of the basic data structures for each subgroup defined by crossing all covariate levels and different missing value patterns.
Each element of <code>partsList</code> is again a list containing counts, missing value pattern, the CL matrix represented as a vector, and the specification of the covariates.
Use <code><a href="utils.html#topic+str">str</a></code> to inspect the elements and see example below.
</p>
</td></tr>
</table>


<h3>Input Data</h3>


<p>The responses have to be coded as 0/1 for paired comparisons without undecided category (0 means first object in a comparison preferred) or 0/1/2 for paired comparisons with an undecided category (where 1 is the undecided category).
Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
The leftmost columns in the data must be the responses to the paired comparisons (where the mandatory order of comparisons is (12) (13) (23) (14) (24) (34) (15) (25) etc.), optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>For an example see <code><a href="#topic+cemspc">cemspc</a></code>.
</p>


<h3>Warning</h3>


<p>The size of the table to be analysed increases dramatically with the number of objects.
For paired comparisons with two response categories the number of rows of the table is <code class="reqn">2^\mathrm{\mbox{(number of comparisons)}}</code>, e.g., with six objects this is 32768, for three response categories this is 14348907.
A reasonable maximum number of objects to be analysed with pattern models is 6 in the case of two response categories and 5 when an additional undecided/neutral category has been observed).
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>See Also</h3>


<p><code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+checkMIS">checkMIS</a></code>,
<code><a href="#topic+pattL.fit">pattL.fit</a></code>,
<code><a href="#topic+pattR.fit">pattR.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit only first three objects with undecided parameter
pattPC.fit(cemspc, nitems = 3, undec = TRUE)

# check for ignorable missing
pattPC.fit(cemspc, nitems = 3, undec = TRUE, NItest = TRUE)

# check if SEX has an effect
m1 &lt;- pattPC.fit(cemspc, nitems = 3, formel = ~1,   elim = ~SEX, undec = TRUE)
m2 &lt;- pattPC.fit(cemspc, nitems = 3, formel = ~SEX, elim = ~SEX, undec = TRUE)

# calculate LR test for SEX
ll1 &lt;- m1$result$minimum
ll2 &lt;- m2$result$minimum
df1 &lt;- length(m1$result$estimate)
df2 &lt;- length(m2$result$estimate)
lr  &lt;- 2*(ll1 - ll2)
df  &lt;- df2 - df1
cat("LR test = ", lr, " on df = ", df, " (p = ",
    round(pchisq(lr, df, lower.tail = FALSE), digits = 5), ")\n", sep = "")


# generates data set with three items and some missing values in
# comparison (23), column 3, then there are no NAs for object 1
data3 &lt;- dat4[, 1:3]
idx3  &lt;- sample(1:100, 10)
data3[idx3, 3] &lt;- NA
checkMIS(data3, nitems = 3, verbose = TRUE)

# estimate MNAR PC pattern model for data3 without alpha1 and beta1
pattPC.fit(data3, nitems = 3,
  MISalpha = c(FALSE, TRUE, TRUE),
  MISbeta  = c(FALSE, TRUE, TRUE))
</code></pre>

<hr>
<h2 id='pattR.fit'>Function to fit a pattern model for (partial) rankings</h2><span id='topic+pattR.fit'></span>

<h3>Description</h3>


<p>Function to fit a pattern model for (partial) rankings (transformed to paired comparisons) allowing for missing values using a CL approach.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattR.fit(obj, nitems, formel = ~1, elim = ~1, resptype = "ranking",
        obj.names = NULL, ia = FALSE, NItest = FALSE, pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="pattR.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of items</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_elim">elim</code></td>
<td>

<p>the formula for the subject covariates that specify the table to be analysed.
If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>.
If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.
</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_resptype">resptype</code></td>
<td>
<p>is <code>"ranking"</code> by default and is reserved for future usage. Any other specification will not change the behaviour of <code>pattR.fit</code></p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_ia">ia</code></td>
<td>
<p>interaction parameters between comparisons that have one object in common if <code>ia = TRUE</code>.</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_nitest">NItest</code></td>
<td>
<p>separate estimation of object parameters for complete and incomplete patterns if <code>NItest = TRUE</code>. Currently, <code>NItest</code> is set to <code>FALSE</code> if subject covariates are specified.</p>
</td></tr>
<tr><td><code id="pattR.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>a dot is printed at each iteration cycle if set to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed.
See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the successive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>pattR.fit</code> returns an object of class <code>pattMod</code>.
The function <code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.pattMod">print.pattMod</a></code>) can be used to print the results and the function <code><a href="#topic+patt.worth">patt.worth</a></code> to produce a matrix of worth parameters.
</p>
<p>An object of class <code>pattMod</code> is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>log-likelihood of the saturated model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a list of results from the fitting routine (see Value of <code><a href="stats.html#topic+nlm">nlm</a></code>).</p>
</td></tr>
<tr><td><code>envList</code></td>
<td>
<p>a list with further fit details like subject covariates design structure <code>covdesmat</code>, paired comparison response pattern matrix <code>Y</code>, etc.</p>
</td></tr>
<tr><td><code>partsList</code></td>
<td>

<p>a list of the basic data structures for each subgroup defined by crossing all covariate levels and different missing value patterns.
Each element of <code>partsList</code> is again a list containing counts, missing value pattern, the CL matrix represented as a vector, and the specification of the covariates.
Use <code><a href="utils.html#topic+str">str</a></code> to inspect the elements and see example below.
</p>
</td></tr>
</table>


<h3>Input Data</h3>


<p>The responses have to be coded as consecutive integers starting with 1.
The value of 1 means highest rank according to the underlying scale.
Each column in the data file corresponds to one of the ranked objects.
For example, if we have 3 objects denoted by <code>A</code>, <code>B</code>, and <code>C</code>, with corresponding columns in the data matrix, the response pattern <code>(3, 1, 2)</code> represents: object <code>B</code> ranked highest, <code>C</code> ranked second, and <code>A</code> ranked lowest.
Missing values are coded as <code>NA</code>, ties are not allowed (in that case use <code><a href="#topic+pattL.fit">pattL.fit</a></code>.
Rows with less than 2 ranked objects are removed from the fit and a message is printed.
</p>
<p>Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
The leftmost columns in the data must be the rankings, optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>
<p>For an example without covariates and no missing values see <code><a href="#topic+salad">salad</a></code>.
</p>


<h3>Warning</h3>


<p>The size of the table to be analysed increases dramatically with the number of items.
For rankings the number of paired comparison response categories is always two.
The number of rows of the table used to set up the design matrix is <code>factorial(number of items)</code>.
For instance, for nine objects this is 362880.
A reasonable maximum number of items is 8.
</p>
<p>The option <code>NItest = TRUE</code> has to be used with care.
The meaning of missing responses is not obvious with partial rankings.
Are the corresponding values really missing or just not chosen.
</p>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger
</p>


<h3>See Also</h3>


<p><code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+pattL.fit">pattL.fit</a></code>,
<code><a href="#topic+pattPC.fit">pattPC.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># fit of Critchlov &amp; Fligner (1991) Salad Dressings Data
pattR.fit(salad, nitems = 4)

# alternatively use glm() with patt.design()
sal &lt;- patt.design(salad, nitems = 4, resptype = "ranking")
glm(y ~ A+B+C+D, data = sal, family = poisson)
</code></pre>

<hr>
<h2 id='pattRrep.fit'>Function to fit a pattern model for repeated rankings)</h2><span id='topic+pattRrep.fit'></span>

<h3>Description</h3>


<p>Function to fit a pattern model for repeated (partial) rankings (transformed to paired comparisons) allowing for missing values using a CL approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattRrep.fit(obj, nitems, tpoints = 1, formel = ~1, elim = ~1,
        resptype = "rankingT", obj.names = NULL, ia = FALSE,
        iaT = FALSE, NItest = FALSE, pr.it = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattRrep.fit_+3A_obj">obj</code></td>
<td>
<p>either a dataframe or the path/name of the datafile to be read.</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_nitems">nitems</code></td>
<td>
<p>the number of items at one time point.</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_tpoints">tpoints</code></td>
<td>
<p>the number of time points (must be &gt; 1).</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_formel">formel</code></td>
<td>
<p>the formula for subject covariates to fit different preference scales for the objects (see below).</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_elim">elim</code></td>
<td>

<p>the formula for the subject covariates that specify the table to be analysed.
If omitted and <code>formel</code> is not <code>~1</code> then <code>elim</code> will be set to the highest interaction between all terms contained in <code>formel</code>.
If <code>elim</code> is specified, the terms must be separated by the <code>*</code> operator.
</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_resptype">resptype</code></td>
<td>

<p>is <code>"rankingT"</code> by default and is reserved for future usage.
Any other specification will not change the behaviour of <code>pattL.fit</code>
</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_obj.names">obj.names</code></td>
<td>
<p>character vector with names for objects.</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_ia">ia</code></td>
<td>
<p><code>FALSE</code> by default, has no meaning for rankings. Reserved for future usage.</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_iat">iaT</code></td>
<td>
<p>if <code>iaT = TRUE</code>, dependence parameters for each item between two successive time points.</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_nitest">NItest</code></td>
<td>

<p>separate estimation of object parameters for complete and incomplete patterns if <code>NItest = TRUE</code>.
Currently, <code>NItest</code> is set to <code>FALSE</code> if subject covariates are specified.
</p>
</td></tr>
<tr><td><code id="pattRrep.fit_+3A_pr.it">pr.it</code></td>
<td>
<p>a dot is printed at each iteration cycle if set to <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<p>Models including categorical subject covariates can be fitted using the <code>formel</code> and <code>elim</code> arguments.
<code>formel</code> specifies the actual model to be fitted.
For instance, if specified as <code>formel = ~SEX</code> different preference scale for the objects will be estimated for males and females.
For two or more covariates, the operators <code>+</code> or <code>*</code> can be used to model main or interaction effects, respectively.
The operator <code>:</code> is not allowed (redundant terms are removed automatically).
See also <code><a href="stats.html#topic+formula">formula</a></code>.
</p>
<p>The specification for <code>elim</code> follows the same rules as for <code>formel</code>.
However, <code>elim</code> specifies the basic contingency table to be set up but does not specify any covariates to be fitted.
This is done using <code>formel</code>.
If, e.g., <code>elim = ~SEX</code> but <code>formel = ~1</code>, then the table is set up as if <code>SEX</code> would be fitted but only one global preference scale is computed.
This feature allows for the successive fitting of nested models to enable the use of deviance differences for model selection (see example below).
</p>


<h3>Value</h3>


<p><code>pattRrep.fit</code> returns an object of class <code>pattMod</code>.
The function <code><a href="base.html#topic+print">print</a></code> (i.e., <code><a href="#topic+print.pattMod">print.pattMod</a></code>) can be used to print the results and the function <code><a href="#topic+patt.worth">patt.worth</a></code> to produce a matrix of worth parameters.
</p>
<p>An object of class <code>pattMod</code> is a list containing the following components:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>estimates</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>log-likelihood of the model</p>
</td></tr>
<tr><td><code>fl</code></td>
<td>
<p>log-likelihood of the saturated model</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>result</code></td>
<td>
<p>a list of results from the fitting routine (see Value of <code><a href="stats.html#topic+nlm">nlm</a></code>).</p>
</td></tr>
<tr><td><code>envList</code></td>
<td>
<p>a list with further fit details like subject covariates design structure <code>covdesmat</code>, paired comparison response pattern matrix <code>Y</code>, etc.</p>
</td></tr>
<tr><td><code>partsList</code></td>
<td>

<p>a list of the basic data structures for each subgroup defined by crossing all covariate levels and different missing value patterns.
Each element of <code>partsList</code> is again a list containing counts, missing value pattern, the CL matrix represented as the vector <code>s</code>, and the specification of the covariates.
Use <code><a href="utils.html#topic+str">str</a></code> to inspect the elements and see example below.
</p>
</td></tr>
</table>


<h3>Input Data</h3>


<p>The input data must have the following order (from left to right): all items at first time point, all items at second time point (with the same order as before), etc. for the other time points, optional subject covariates.
The responses have to be coded as consecutive integers starting with 1 (or 0).
The value of 1 (0) means highest &lsquo;endorsement&rsquo; (agreement) according to the underlying scale.
Missing values are coded as <code>NA</code>, rows with less than 1 valid response are removed from the fit and a message is printed.
</p>
<p>Optional subject covariates have to be specified such that the categories are represented by consecutive integers starting with 1.
Rows with missing values for subject covariates are removed from the data and a message is printed.
Again, the leftmost columns in the data must be the rankings, optionally followed by columns for categorical subject covariates.
</p>
<p>The data specified via <code>obj</code> are supplied using either a data frame or a datafile in which case <code>obj</code> is a path/filename.
The input data file if specified must be a plain text file with variable names in the first row as readable via the command <code>read.table(datafilename, header = TRUE)</code>.
</p>


<h3>Warning</h3>


<p>The size of the table to be analysed increases dramatically with the number of items <code class="reqn">J</code> and time points <code class="reqn">T</code>.
For rankings the number of paired comparison response categories is always two.
For each time point the number of rows of the table to set up the design matrix is initially <code class="reqn">(J!</code>.
Thus, the number of rows in the design matrix is <code class="reqn">(J!) ^ T</code>.
The number of combined covariate levels and the number of missing value patterns have effects only on the run time.
A (reasonable) maximum number of items for two time points is 5 or 6, for three timepoints 4, and for four to seven timepoints 3.
</p>


<h3>Note</h3>


<p>The number of timepoints can also be regarded as different response dimensions.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>See Also</h3>


<p><code><a href="#topic+pattL.fit">pattL.fit</a></code>,
<code><a href="#topic+patt.design">patt.design</a></code>,
<code><a href="#topic+pattPC.fit">pattPC.fit</a></code>,
<code><a href="#topic+pattR.fit">pattR.fit</a></code>,
<code><a href="#topic+pattLrep.fit">pattLrep.fit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulated data: 3 items, 2 timepoints
dat1 &lt;- simR(3, 100, c(.2, .7, .1))
dat2 &lt;- simR(3, 100, c(.5, .4, .1))
dat  &lt;- data.frame(dat1, dat2)
res  &lt;- pattLrep.fit(dat, nitems = 3, tpoints = 2, iaT = TRUE)
res
patt.worth(res, obj.names = LETTERS[1:3])
</code></pre>

<hr>
<h2 id='plot.wmat'>Method to plot worth or model parameters from LLBT or pattern models</h2><span id='topic+plot.wmat'></span>

<h3>Description</h3>


<p>A plot of the worth or model parameter matrix obtained from the fit of an LLBT or pattern model is produced.
This matrix is obtained from <code>llbt.worth</code> or <code>patt.worth</code> and is an object of class <code>wmat</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wmat'
plot(x, main = "Preferences", ylab = "Estimate", psymb = NULL,
        pcol = NULL, ylim = range(worthmat), log = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.wmat_+3A_x">x</code></td>
<td>
<p>worth or parameter matrix as generated from <code><a href="#topic+llbt.worth">llbt.worth</a></code> or <code><a href="#topic+patt.worth">patt.worth</a></code>.</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_psymb">psymb</code></td>
<td>
<p>plotsymbols for objects, see Details below</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_pcol">pcol</code></td>
<td>
<p>colours for objects, see Details below</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_ylim">ylim</code></td>
<td>
<p>limits for y-axis</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_log">log</code></td>
<td>
<p>if specified as  <code>log = "y"</code>, the y-axis is to be logarithmic</p>
</td></tr>
<tr><td><code id="plot.wmat_+3A_...">...</code></td>
<td>
<p>further graphical parameters, use e.g. <code>lty = "dashed"</code> to obtain dashed lines connecting the objects</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Plotsymbols can be defined as an integer vector of length equal to the number of objects, e.g., <code>psymb = c(15, 22, 18)</code>.
They specify the graphical option <code>pch</code> as used in the <code><a href="graphics.html#topic+points">points</a></code> function.
The default (<code>psymb = NULL</code>) uses the symbols 15 through 18 and 21 through 25.
The number of symbols is determined from the number of rows in <code>worthmat</code>.
A display of some plotsymbols may be obtained from the corresponding example below.
</p>
<p>If <code>pcol = NULL</code>, the colours for objects are defined from the <code>rainbow_hcl</code> palette using the <span class="pkg">colorspace</span> package.
Other specifications include <code>"heat"</code>, <code>"terrain"</code> (see <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>), and <code>"gray"</code> (see <code><a href="grDevices.html#topic+grDevices">grDevices</a></code>).
The number of different colours is automatically determined via the number of objects.
Alternatively, <code>pcol</code> can be specified as a character vector containing user defined RGB colour values for all objects (as hexadecimal strings in the form <code>"#rrggbb"</code>), e.g., for blue <code>"#0000FF"</code>).
These are usually set up using standard colour palettes (see <code>rainbow</code> or, e.g., the <span class="pkg">RColorBrewer</span> package (see Examples below).
</p>
<p>The old plot function, <code><a href="#topic+plotworth">plotworth</a>()</code>, is defunct (see <code><a href="#topic+prefmod-defunct">prefmod-defunct</a></code>) and will generate errors.
If you are still using it, please update your code!
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>See Also</h3>

<p><code><a href="#topic+patt.worth">patt.worth</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># fit only first three objects with SEX effect
m2 &lt;- pattPC.fit(cemspc, nitems = 3, formel = ~SEX, elim = ~SEX, undec = TRUE)

# calculate and plot worth parameters
m2worth &lt;- patt.worth(m2)
plot(m2worth)
plot(m2worth, pcol = "terrain")

# display of some plotsymbols (pch)
plot(0:25, rep(1, 26), pch = 0:25, cex = 1.5)
text(0:25, rep(0.95, 26), 0:25)

# usage of the "RColorBrewer" package
## Not run: 
library("RColorBrewer")
mypalette &lt;- brewer.pal(3, "Set1")
plot(m2worth, pcol = mypalette)
## End(Not run)
</code></pre>

<hr>
<h2 id='prefmod-defunct'>Defunct Functions in Package <span class="pkg">prefmod</span></h2><span id='topic+prefmod-defunct'></span><span id='topic+plotworth'></span>

<h3>Description</h3>


<p>A list of functions that are no longer part of <span class="pkg">prefmod</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotworth(worthmat, main = "Preferences", ylab = "Estimate", psymb = NULL,
        pcol = NULL, ylim = range(worthmat), ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="prefmod-defunct_+3A_worthmat">worthmat</code></td>
<td>
<p>parameter matrix as generated from <code><a href="#topic+llbt.worth">llbt.worth</a></code> or <code><a href="#topic+patt.worth">patt.worth</a></code>.</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_main">main</code></td>
<td>
<p>main title of the plot.</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_psymb">psymb</code></td>
<td>
<p>plotsymbols for objects, see Details below</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_pcol">pcol</code></td>
<td>
<p>colours for objects, see Details below</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_ylim">ylim</code></td>
<td>
<p>limits for y-axis</p>
</td></tr>
<tr><td><code id="prefmod-defunct_+3A_...">...</code></td>
<td>
<p>further graphical parameters, use e.g. <code>log = "y"</code> to obtain a logarithmic plot</p>
</td></tr>
</table>


<h3>Details</h3>


<p><code><a href="#topic+plotworth">plotworth</a>()</code> was initially used to plot worth or model parameters from LLBT or pattern models (in a matrix created by <code><a href="#topic+llbt.worth">llbt.worth</a>()</code> or <code><a href="#topic+patt.worth">patt.worth</a>()</code>).
Now, the generic <code><a href="#topic+plot.wmat">plot</a></code> (i.e., <code><a href="#topic+plot.wmat">plot.wmat</a>()</code>) has to be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
###################
### plotworth() ###
###################

# fit only first three objects with SEX effect
m2 &lt;- pattPC.fit(cemspc, nitems = 3, formel = ~SEX, elim = ~SEX, undec = TRUE)

# calculate and plot worth parameters
m2worth &lt;- patt.worth(m2)
plot.wmat(m2worth)
plot.wmat(m2worth, pcol = "terrain")

# display of some plotsymbols (pch)
plot(0:25, rep(1, 26), pch = 0:25, cex = 1.5)
text(0:25, rep(0.95, 26), 0:25)

# usage of the "RColorBrewer" package
library("RColorBrewer")
mypalette &lt;- brewer.pal(3, "Set1")
plot.wmat(m2worth, pcol = mypalette)
## End(Not run)
</code></pre>

<hr>
<h2 id='prefmod-package'><span class="pkg">prefmod</span>: Utilities to Fit Paired Comparison Models for Preferences</h2><span id='topic+prefmod-package'></span><span id='topic+prefmod'></span>

<h3>Description</h3>


<p>Generates design matrix for analysing real paired comparisons and derived paired comparison data (Likert-type items/ratings or rankings) using a loglinear approach.
Fits loglinear Bradley-Terry model (LLBT) exploiting an eliminate feature.
Computes pattern models for paired comparisons, rankings, and ratings.
Some treatment of missing values (MCAR and MNAR).
Fits pattern mixture models using a non-parametric ML approach.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package:</td><td style="text-align: left;">prefmod</td>
</tr>
<tr>
 <td style="text-align: left;">
Type:   </td><td style="text-align: left;">Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version:</td><td style="text-align: left;">0.8-36</td>
</tr>
<tr>
 <td style="text-align: left;">
Date:   </td><td style="text-align: left;">2023-09-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License:</td><td style="text-align: left;">GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<h3>Author(s)</h3>


<p>Reinhold Hatzinger, Marco J. Maier
</p>
<p>Maintainer: Marco J. Maier (<a href="mailto:marco_maier@posteo.de">marco_maier@posteo.de</a>)
</p>


<h3>References</h3>

<p>Hatzinger, R., &amp; Dittrich, R. (2012). <span class="pkg">prefmod</span>: An R Package for Modeling Preferences Based on Paired Comparisons, Rankings, or Ratings.
<em>Journal of Statistical Software, 48</em>(10), 1&ndash;31. <a href="https://www.jstatsoft.org/v48/i10/">https://www.jstatsoft.org/v48/i10/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># mini example with three Likert items and two subject covariates

# using example data "xmpl" in the package
dsgnmat &lt;- patt.design(xmpl, nitems = 3, resptype = "rating",
    ia = TRUE, cov.sel = "ALL")
head(dsgnmat)

# fit of Critchlov &amp; Fligner (1991) Salad Dressings Data
pattR.fit(salad, nitems = 4)

# alternatively use glm() with patt.design()
sal &lt;- patt.design(salad, nitems = 4, resptype = "ranking")
glm(y ~ A+B+C+D, data = sal, family = poisson)
</code></pre>

<hr>
<h2 id='print.pattMod'>Print methods for pattern models</h2><span id='topic+print.pattMod'></span>

<h3>Description</h3>

<p>Print method for objects of class <code>pattMod</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pattMod'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pattMod_+3A_x">x</code></td>
<td>
<p>Object of class <code>pattMod</code>.</p>
</td></tr>
<tr><td><code id="print.pattMod_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to or from other methods. They are ignored in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This print method generates output for fitted pattern models, i.e., for models of class <code>pattMod</code>.
The functions <code><a href="#topic+pattPC.fit">pattPC.fit</a></code>, <code><a href="#topic+pattR.fit">pattR.fit</a></code>, <code><a href="#topic+pattL.fit">pattL.fit</a></code>, and <code><a href="#topic+pattLrep.fit">pattLrep.fit</a></code> produce such objects.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- pattR.fit(salad, nitems = 4)
res
</code></pre>

<hr>
<h2 id='salad'>Data (ranks): Salad Dressings (Critchlow and Fligner)</h2><span id='topic+salad'></span>

<h3>Description</h3>


<p>The dataset contains the rankings of four salad dressings concerning tartness by 32 judges, with values ranging from 1 (most tart) to 4 (least tart).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salad</code></pre>


<h3>Format</h3>

<p>A data frame with 32 observations on 4 variables (<code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>) each representing a different salad dressing.
</p>


<h3>References</h3>


<p>Critchlow, D. E. &amp; Fligner, M. A. (1991).
Paired comparison, triple comparison, and ranking experiments as generalized linear models, and their implementation on GLIM.
<em>Psychometrika 56</em>(3), 517&ndash;533.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example for object covariates
# fit object covariates:
# salads A - D have varying concentrations of acetic and gluconic acid.
# The four pairs of concentrations are
# A = (.5, 0), B = (.5, 10.0), C = (1.0, 0), and D = (0, 10.0),

conc &lt;- matrix(c(.5, 0,  .5, 10,  1, 0,  0, 10), ncol = 2, byrow = TRUE)
sal  &lt;- patt.design(salad, nitems = 4, resptype = "ranking")
X    &lt;- as.matrix(sal[, 2:5]) 

glm(y ~ X, data = sal, family = poisson)
</code></pre>

<hr>
<h2 id='simPC'>Utility function to simulate paired comparison or rankings data</h2><span id='topic+simPC'></span><span id='topic+simR'></span>

<h3>Description</h3>


<p>The function generates a random paired comparison data matrix (two response categories, no undecided) or a rankings data matrix optionally based on user specified worth parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simPC(nobj, nobs, worth = NULL, seed = NULL, pr = FALSE)
simR(nobj, nobs, worth = NULL, seed = NULL, pr = FALSE)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="simPC_+3A_nobj">nobj</code></td>
<td>
<p>Number of objects.</p>
</td></tr>
<tr><td><code id="simPC_+3A_nobs">nobs</code></td>
<td>
<p>Number of cases.</p>
</td></tr>
<tr><td><code id="simPC_+3A_worth">worth</code></td>
<td>

<p>If <code>NULL</code>, values are drawn from uniform distribution (interval from 0 to 1), otherwise the user may specify arbitrary values.
In both cases, the values are transformed into [0, 1] and scaled to sum up to 1.
</p>
</td></tr>
<tr><td><code id="simPC_+3A_seed">seed</code></td>
<td>
<p>Starting value for the random number generator.</p>
</td></tr>
<tr><td><code id="simPC_+3A_pr">pr</code></td>
<td>
<p>If <code>TRUE</code>, the used worth parameters are printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The random data matrix as a data frame.
</p>


<h3>Author(s)</h3>

<p>Reinhold Hatzinger</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- simPC(4, 10, worth = 1:4, seed = 123456)
data
</code></pre>

<hr>
<h2 id='summary.pattNPML'>Summarizing finite mixture regression fits</h2><span id='topic+summary.pattNPML'></span><span id='topic+print.pattNPML'></span><span id='topic+BIC.pattNPML'></span>

<h3>Description</h3>


<p>These functions are the <code>summary</code>, <code>print</code>, and <code>BIC</code> methods for objects of type <code>pattNPML</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pattNPML'
summary(object, digits = max(3, getOption("digits") - 3), ...)
## S3 method for class 'pattNPML'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>


<table>
<tr><td><code id="summary.pattNPML_+3A_object">object</code></td>
<td>
<p>a fitted object of class <code>pattNPML</code>.</p>
</td></tr>
<tr><td><code id="summary.pattNPML_+3A_x">x</code></td>
<td>
<p>a fitted object of class <code>pattNPML</code>.</p>
</td></tr>
<tr><td><code id="summary.pattNPML_+3A_digits">digits</code></td>
<td>
<p>number of digits; applied on various displayed quantities.</p>
</td></tr>
<tr><td><code id="summary.pattNPML_+3A_...">...</code></td>
<td>
<p>further arguments, which will mostly be ignored.</p>
</td></tr>
</table>


<h3>Note</h3>


<p>The <code>summary</code> and <code>print</code> methods are adapted versions from the <span class="pkg">npmlreg</span> package.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+pattnpml.fit">pattnpml.fit</a></code>
</p>

<hr>
<h2 id='tennis'>Data (paired comparisons): Preferred Interview Partner</h2><span id='topic+tennis'></span>

<h3>Description</h3>


<p>The data describes results from a paired comparison study where 68 male and 96 female students were asked whom they would prefer to interview.
The potential interview partners were Bonnie Blair, Jackie Joyner, and Jennifer Capriati.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tennis</code></pre>


<h3>Format</h3>


<p>A data frame with 16 observations on the following 5 variables.
</p>

<dl>
<dt><code>n</code></dt><dd><p>counts of response pattern (<code>C1, C2, C3</code>)</p>
</dd>
<dt><code>C1</code></dt><dd><p>Blair vs. Joyner: (1) Blair preferred, (<code class="reqn">-1</code>) Joyner preferred</p>
</dd>
<dt><code>C2</code></dt><dd><p>Blair vs. Capriati: (1) Blair preferred, (<code class="reqn">-1</code>) Capriati preferred)</p>
</dd>
<dt><code>C3</code></dt><dd><p>Joyner vs. Capriati: (1) Joyner preferred, (<code class="reqn">-1</code>) Capriati preferred)</p>
</dd>
<dt><code>SEX</code></dt><dd><p>a numeric vector: (1) male, (2) female</p>
</dd>
</dl>



<h3>References</h3>


<p>B철ckenholt, U., &amp; Dillon, W. R., (1997). Modeling within-subject dependencies in ordinal paired comparison data. <em>Psychometrika, 62</em>(3), 411&ndash;434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tdat &lt;- expand.mat(tennis[, -1], tennis[, 1])
head(tdat)
</code></pre>

<hr>
<h2 id='trdel'>Data (paired comparisons): Training delivery modes</h2><span id='topic+trdel'></span>

<h3>Description</h3>


<p>The dataset <code>trdel</code> contains data from a paired comparison study to investigate which of five training delivery modes trainees prefer (Schoell and Veith, 2011).
The modes were computer-based (<code>CO</code>), TV-based (<code>TV</code>), paper-based (<code>PA</code>), audio-based (<code>AU</code>) and classroom-based (<code>CL</code>) training.
Study participants were unemployed persons in the labour market training of the Austrian labour market service (AMS).
To account for trainee characteristics that might affect the preference order the variables gender, age, and learning personality type were recorded.
These variables were coded as <code>sex</code> (1 male, 2 female), <code>age</code> (numeric in years), <code>ltype</code> (1 accomodator, 2 diverger, 3 converger, 4 assimilator).
The learning personality types were identified from a questionnaire.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trdel</code></pre>


<h3>Format</h3>


<p>A data frame with 198 observations on the following 14 variables.
</p>

<dl>
<dt><code>V1</code>, <code>V2</code>, <code>V3</code>, <code>V4</code>, <code>V5</code>, <code>V6</code>, <code>V7</code>, <code>V8</code>, <code>V9</code>, <code>V10</code></dt><dd>
<p>paired comparisons in standard order: <code>CO:TV</code>, <code>CO:PA</code>, etc.<br />
<code>1</code> first object preferred, <code>2</code> second object preferred.
</p>
</dd>
<dt><code>ltype</code></dt><dd><p>learning types: (1) accomodator, (2) diverger, (3) converger, (4) assimilator</p>
</dd>
<dt><code>age</code></dt><dd><p>numeric in years</p>
</dd>
<dt><code>sex</code></dt><dd><p>(1) male, (2) female</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sch철ll, B., Veith, S. (2011). Learning style evaluation and preferred training delivery modes in labour market training (in German). Master's thesis, Vienna University of Economics and Business.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>head(trdel)
</code></pre>

<hr>
<h2 id='xmpl'>Data (Likert items): Example Data Set</h2><span id='topic+xmpl'></span>

<h3>Description</h3>

<p>Data to illustrate the usage of <code><a href="#topic+patt.design">patt.design</a> for rating scale (Likert type) items</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xmpl</code></pre>


<h3>Format</h3>


<p>A data frame with 100 observations on 5 numeric variables.
The first three variables (<code>I1</code>, <code>I2</code>, <code>I3</code>) are the rating scale (Likert type) items with 5 response categories, ranging from 1 (strong agreement) to 5 (strong disagreement).
</p>

<dl>
<dt><code>I1</code></dt><dd><p>response to item 1</p>
</dd>
<dt><code>I2</code></dt><dd><p>response to item 2</p>
</dd>
<dt><code>I3</code></dt><dd><p>response to item 3</p>
</dd>
<dt><code>SEX</code></dt><dd><p>(1) <em>male</em>, (2) <em>female</em></p>
</dd>
<dt><code>EDU</code></dt><dd><p>(1) <em>low education</em>, (2) <em>high education</em></p>
</dd>
</dl>



<h3>Details</h3>


<p>Datasets in data files or Data frames used in <code><a href="#topic+patt.design">patt.design</a></code> require the following structure:
</p>

<ul>
<li><p> All values must be numeric.
</p>
</li>
<li><p> The item responses must be in the leftmost columns (such as <code>I1</code> to <code>I3</code> above).
</p>
</li>
<li><p> Categorical subject covariates follow the item responses (rightmost columns) and their levels must be specified as consecutive integers.
If in a used datafile or dataframe these are defined as <span class="pkg">R</span> factors they will be converted to integers.
This is not possible if characters are used as factor levels and, consequently, <code>patt.design</code> will produce an error.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>des &lt;- patt.design(xmpl, nitems = 3, resptype = "rating", cov.sel = "SEX")
head(des)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
