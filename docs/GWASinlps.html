<!DOCTYPE html><html><head><title>Help for package GWASinlps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GWASinlps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GWASinlps'><p>Non-local prior based iterative variable selection for GWAS data, or other high-dimensional data</p></a></li>
<li><a href='#GWASinlps-package'><p>Non-local prior based iterative variable selection tool for genome-wide association study data, or other high-dimensional data</p></a></li>
<li><a href='#nlps'><p>Non-local prior based single-step variable selection for high-dimensional data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Non-Local Prior Based Iterative Variable Selection Tool for
Genome-Wide Association Studies</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-11-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs variable selection with data from Genome-wide association studies (GWAS), or other high-dimensional data with continuous, binary or survival outcomes, combining in an iterative framework the computational efficiency of the structured screen-and-select variable selection strategy based on some association learning and the parsimonious uncertainty quantification provided by the use of non-local priors (see Sanyal et al., 2019 &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbty472">doi:10.1093/bioinformatics/bty472</a>&gt;). </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>mombf</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.9), RcppArmadillo, fastglm, horseshoe, survival</td>
</tr>
<tr>
<td>Suggests:</td>
<td>glmnet</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nilotpalsanyal.github.io/GWASinlps/">https://nilotpalsanyal.github.io/GWASinlps/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nilotpalsanyal/GWASinlps/issues">https://github.com/nilotpalsanyal/GWASinlps/issues</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-11-23 07:50:44 UTC; nsanyal</td>
</tr>
<tr>
<td>Author:</td>
<td>Nilotpal Sanyal <a href="https://orcid.org/0000-0003-4814-7602"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nilotpal Sanyal &lt;nilotpal.sanyal@gmail.com&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-11-23 08:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='GWASinlps'>Non-local prior based iterative variable selection for GWAS data, or other high-dimensional data</h2><span id='topic+GWASinlps'></span>

<h3>Description</h3>

<p><code>GWASinlps</code> performs variable selection with data from Genome-wide association studies (GWAS), or other high-dimensional data with continuous, binary or survival outcomes, combining in an iterative framework, the computational efficiency of the structured screen-and-select variable selection strategy based on some association learning and the parsimonious uncertainty quantification provided by the use of non-local priors (see the References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GWASinlps(
  y, 
  event,
  x, 
  family = c("normal","binomial","survival"),
  method = c("rigorous","quick"),
  cor_xy = NULL,
  mmle_xy = NULL,
  mu_xy = NULL,
  prior = c("mom", "imom", "emom", "zellner", "horseshoe"), 
  tau, 
  priorDelta = modelbbprior(1,1), 
  k0, 
  m, 
  rxx, 
  nskip = 3, 
  niter = 2000, 
  verbose = FALSE, 
  seed = NULL, 
  tau.hs.method = "halfCauchy", 
  sigma.hs.method = "Jeffreys"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GWASinlps_+3A_y">y</code></td>
<td>
<p>The vector of continuous response (phenotype) for linear models (LM), or binary response (phenotype) for generalized linear models (GLM), or survival times for accelerated failure time models (AFTM). Binary response values must be 0 or 1.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_event">event</code></td>
<td>
<p>Only for AFTM. The vector of status indicator for the survival data.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_x">x</code></td>
<td>
<p>The design matrix with subjects in rows and independent variables (e.g., SNPs) in columns. Missing values are not accepted currently.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_family">family</code></td>
<td>
<p><code>"normal"</code> for continuous data, <code>"binomial"</code> for binary data (logit link is used), <code>"survival"</code> for survival data.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_method">method</code></td>
<td>
<p>Applies only when <code>family="binomial"</code>. The <code>rigorous</code> method uses logistic regression based analysis which is theoretically appropriate but can be slow. The <code>quick</code> method uses a curious combination of linear model and logistic regression based analyses and is considerably faster. See Details.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_cor_xy">cor_xy</code></td>
<td>
<p>Used only when <code>family="normal"</code>. Vector of (Pearson) correlation coefficients of <code>y</code> with the individual columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_mmle_xy">mmle_xy</code></td>
<td>
<p>Used only when <code>family="binomial"</code>. Vector of maximum marginal likelihood estimates of the regression parameters corresponding to the <code>x</code> variables (e.g., SNPs). These are obtained from GLM fits of <code>y</code> with the individual columns of <code>x</code> including an intercept.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_mu_xy">mu_xy</code></td>
<td>
<p>Used only when <code>family="survival"</code>. Vector of marginal utility estimates of the variables (SNPs) in <code>x</code>. These may be obtained by fitting AFT model to <code>y</code> with individual columns of <code>x</code> using the <code>survreg</code> function of the package <code>survival</code>.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_prior">prior</code></td>
<td>
<p><code>"mom"</code> for pMOM prior, <code>"imom"</code> for piMOM prior, <code>"emom"</code> for peMOM prior, <code>"zellner"</code> for Zellner's g-prior, <code>"horseshoe"</code> for horseshoe prior. For GLM, <code>"zellner"</code> considers group Zellner prior and <code>"emom"</code> and <code>"horseshoe"</code> are not available. For AFTM, <code>"horseshoe"</code> is not available. </p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_tau">tau</code></td>
<td>
<p>The value of the scale parameter tau of the non-local prior. </p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_priordelta">priorDelta</code></td>
<td>
<p>Prior for model space. Defaults to <code>modelbbprior(1,1)</code>, which is beta-binomial(1,1) prior.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_k0">k0</code></td>
<td>
<p>GWASinlps tuning parameter denoting the number of leading SNPs/variables (see Details).</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_m">m</code></td>
<td>
<p>GWASinlps tuning parameter, denoting the maximum number of SNPs/variables to be selected.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_rxx">rxx</code></td>
<td>
<p>GWASinlps tuning parameter denoting the correlation threshold to determine leading sets (see References).</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_nskip">nskip</code></td>
<td>
<p>GWASinlps tuning parameter denoting the maximum allowed count of skipping an iteration that does not select any variable (SNP) (see References).</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_niter">niter</code></td>
<td>
<p>Number of MCMC iterations for non-local prior based Bayesian variable selection. Defaults to 2000.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, prints result from the iterations progressively. FALSE by default.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_seed">seed</code></td>
<td>
<p>For reproducibility. If provided, the random seed is set to this value at the beginning of the function.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_tau.hs.method">tau.hs.method</code></td>
<td>
<p>Necessary only when <code>prior="horseshoe"</code>. See <code>horseshoe</code> function reference.</p>
</td></tr>
<tr><td><code id="GWASinlps_+3A_sigma.hs.method">sigma.hs.method</code></td>
<td>
<p>Necessary only when <code>prior="horseshoe"</code>. See <code>horseshoe</code> function reference.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The GWASinlps method selects variables (SNPs) iteratively. 
</p>


<h4>For continuous response</h4>

<p>For continuous response (phenotype), the procedure starts with an initial set of independent variables (SNPs), a design matrix (SNP genotype matrix) <code>x</code> and a response (phenotype) vector <code>y</code>. 
</p>
<p>- An iteration proceeds by determining the <code>k0</code> <em>leading SNPs/variables</em> having the highest association with <code>y</code>. The measure of association is the absolute value of the Pearson's correlation coefficient <code>cor_xy</code>. These <code>k0</code> leading SNPs/variables, in turn, determine <code>k0</code> <em>leading sets</em>, where each leading set consists of all SNPs/variables with absolute correlation coefficient more than or equal to <code>rxx</code> with the correspondng leading SNP/variable.
</p>
<p>- Within each leading set, non-local prior based Bayesian variable selection for linear models is performed (using package <span class="pkg">mombf</span>). The variables (SNPs) appearing in the highest posterior probability model (HPPM) are considered selected in the current iteration. Note that a single variable (SNP) can be selected from multiple leading sets. The selected variables (SNPs) are regressed out from <code>y</code> using <code>lm</code> fit. The variables (SNPs) that are included in one or more of the <em>leading sets</em> but do not appear in any HPPM are dropped from further analysis. 
</p>
<p>- With updated <code>y</code> and variable (SNP) set, next iteration proceeds similarly. And so on like this. The procedure continues until the stopping point, which is determined by the GWASinlps tuning parameters <code>m</code>, <code>rxx</code>, and <code>nskip</code>, is reached. For more details, see References.
</p>



<h4>For binary response</h4>

<p>For binary response (phenotype), the procedure starts with an initial set of variables (SNPs), a design matrix (SNP genotype matrix) <code>x</code> and a binary response (phenotype) vector <code>y</code>. If <code>method="rigorous"</code>,
</p>
<p>- The first iteration proceeds by determining the <code>k0</code> <em>leading SNPs/variables</em> having the highest association with <code>y</code>. The measure of association is the absolute value of the maximum marginal likelihood estimate <code>mmle_xy</code>. These <code>k0</code> leading SNPs/variables, in turn, determine <code>k0</code> <em>leading sets</em>, where each leading set consists of all SNPs/variables with absolute correlation coefficient more than or equal to <code>rxx</code> with the correspondng leading SNP. 
</p>
<p>- Within each leading set, non-local prior based Bayesian variable selection for logistic regression model is performed (using package <span class="pkg">mombf</span>). The variables (SNPs) appearing in the HPPM are considered selected in the first iteration. Note that a single variable (SNP) can be selected from multiple leading sets. The variables (SNPs) which are included in one or more <em>leading sets</em> but do not appear in any HPPM are dropped from further analysis. After this, the selected variables (SNPs) are accounted for by including them in <code>glm</code> fits of <code>y</code> with each of the remaining variables (SNPs). The <code>glm</code> coefficients of the remaining variables, thus obtained, reflect their contribution in presence of the selected variables (SNPs) of the first iteration. 
</p>
<p>- Considering the absolute values of these <code>glm</code> coefficients as the measure of association, we proceed with the second iteration with updated variable (SNP) set. And so on in this manner. The procedure continues until the stopping point, which is determined by the GWASinlps tuning parameters <code>m</code>, <code>rxx</code>, and <code>nskip</code>, is reached.
</p>
<p>If <code>method="quick"</code>, the procedure is similar to above except at the following points. In this method, non-local prior based Bayesian variable selection using logistic regression model is performed until one or more variables (SNP) are selected in an iteration. Until a variable is selected, there is no need to account for anything, so the initial maximum marginal likelihood estimates continue to be used. After the first selections (if any) are made, a <code>glm</code> fit of <code>y</code> on the selected variables is performed and the deviance residuals are computed. In the subsequent iterations, considering these (continuous) deviance residuals as response, non-local prior based Bayesian variable selection for linear models is performed till the stopping point is reached.
</p>



<h4>For survival data</h4>

<p>For survival data, the procedure starts with an initial set of variables (SNPs), a design matrix (SNP genotype matrix) <code>x</code> and a binary response (phenotype) vector <code>y</code>. 
</p>
<p>- The first iteration proceeds by determining the <code>k0</code> <em>leading SNPs/variables</em> having the highest association with <code>y</code>. The measure of association is the absolute value of the marginal utility <code>mu_xy</code>. These <code>k0</code> leading SNPs/variables, in turn, determine <code>k0</code> <em>leading sets</em>, where each leading set consists of all SNPs with absolute correlation coefficient more than or equal to <code>rxx</code> with the correspondng leading SNP. 
</p>
<p>- Within each leading set, non-local prior based Bayesian variable selection for accelerated failure time model is performed (using package <span class="pkg">mombf</span>). The variables (SNPs) appearing in the HPPM are considered selected in the first iteration. Note that a single variable (SNP) can be selected from multiple leading sets. The variables (SNPs) which are included in one or more <em>leading sets</em> but do not appear in any HPPM are dropped from further analysis. After this, to account for the selected variables (SNPs), conditional utilities of each of the remaining variables (SNPs) are computed in the presence of the selected variables (SNPs) in the model. These conditional utilities reflect the contribution of the remaining variables (SNPs) in presence of the selected variables (SNPs) of the first iteration. 
</p>
<p>- Considering the absolute values of these conditional utilities as the measure of association, we proceed with the second iteration with updated variable (SNP) set. And so on in this manner. The procedure continues until the stopping point, which is determined by the GWASinlps tuning parameters <code>m</code>, <code>rxx</code>, and <code>nskip</code>, is reached.
</p>



<h4> </h4>

<p>For horseshoe prior, package <span class="pkg">horseshoe</span> is used.
</p>



<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>selected</code></td>
<td>
<p>Vector with names of the GWASinlps selected variables (SNPs) in the order they were selected. </p>
</td></tr>
<tr><td><code>selected_iterwise</code></td>
<td>
<p>List with selected variables (SNPs) from each iteration. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nilotpal Sanyal &lt;nilotpal.sanyal@gmail.com&gt;
</p>


<h3>References</h3>

<p>Sanyal et al. (2019), &quot;GWASinlps: Non-local prior based iterative SNP selection tool for genome-wide association studies&quot;. Bioinformatics, 35(1), 1-11.
</p>
<p>Sanyal, N. (2022). &quot;Iterative variable selection for high-dimensional data with binary outcomes&quot;. arXiv preprint arXiv:2211.03190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nlpsLM">nlpsLM</a></code>, <code><a href="#topic+nlpsGLM">nlpsGLM</a></code>, <code><a href="#topic+nlpsAFTM">nlpsAFTM</a></code>, <code><a href="mombf.html#topic+modelSelection">modelSelection</a></code>, <code><a href="horseshoe.html#topic+horseshoe">horseshoe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 200
p = 1000
m = 10

# Generate design matrix (genotype matrix)
set.seed(1) 
f = runif( p, .1, .2 ) # simulate minor allele frequency
x = matrix( nrow = n, ncol = p )
colnames(x) = 1:p
for(j in 1:p)
  x[,j] = rbinom( n, 2, f[j] )

# Generate true effect sizes
causal_snps = sample( 1:p, m )
beta = rep( 0, p )
set.seed(1)
beta[causal_snps] = rnorm(m, mean = 0, sd = 2 )

# Generate continuous (phenotype) data
y = x %*% beta + rnorm(n, 0, 1) 

# Fix scale parameter tau 
tau = 0.2

# GWASinlps analysis
inlps = GWASinlps(y=y, x=x, family="normal", prior="mom", tau=tau, k0=1,  
        m=50, rxx=0.2)
cat( "GWASinlps selected", length(inlps$selected), "SNPs with", 
    length(intersect(inlps$selected, causal_snps)), "true positive(s) and",
    length(setdiff(causal_snps, inlps$selected)), "false negative(s) out  
    of a pool of", p, "SNPs with data from", n, "persons." )

# Compare with LASSO
library(glmnet)
fit.cvlasso = cv.glmnet( x, y, alpha = 1 )
l.min = fit.cvlasso $lambda.min # lambda that gives minimum cvm
l.1se = fit.cvlasso $lambda.1se  # largest lambda such that error is 
                                 # within 1 se of the minimum

lasso_min = which( as.vector( coef( fit.cvlasso, s = l.min ) )[-1] != 0 )  
cat( "LASSO with lambda.min selected", length(lasso_min), "SNPs with", 
     length(intersect(lasso_min, causal_snps)), "true positives and",
    length(setdiff(causal_snps, inlps$selected)), "false negative(s)." )

lasso_1se = which( as.vector( coef( fit.cvlasso, s = l.1se ) )[-1] != 0 )
cat( "LASSO with lambda.1se selected", length(lasso_1se), "SNPs with", 
     length(intersect(lasso_1se, causal_snps)), "true positives and",
    length(setdiff(causal_snps, inlps$selected)), "false negative(s)." )
</code></pre>

<hr>
<h2 id='GWASinlps-package'>Non-local prior based iterative variable selection tool for genome-wide association study data, or other high-dimensional data</h2><span id='topic+GWASinlps-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">GWASinlps</span> package performs variable selection for data from genome-wide association studies (GWAS), or other high-dimensional data with continuous, binary or survival outcomes, combining in an iterative framework, the computational efficiency of the structured screen-and-select variable selection strategy based on some association learning and the parsimonious uncertainty quantification provided by the use of non-local priors (see the References).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> GWASinlps</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-11-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The main function: <br />
<code><a href="#topic+GWASinlps">GWASinlps</a></code>
</p>
<p>The main function calls the following functions: <br />
<code><a href="#topic+nlpsLM">nlpsLM</a></code> <br />
<code><a href="#topic+nlpsGLM">nlpsGLM</a></code> <br />
<code><a href="#topic+nlpsAFTM">nlpsAFTM</a></code>
</p>


<h3>Author(s)</h3>

<p>Nilotpal Sanyal &lt;nilotpal.sanyal@gmail.com&gt;
</p>
<p>Maintainer: Nilotpal Sanyal &lt;nilotpal.sanyal@gmail.com&gt;
</p>


<h3>References</h3>

<p>Sanyal et al. (2019), &quot;GWASinlps: Non-local prior based iterative SNP selection tool for genome-wide association studies&quot;. Bioinformatics, 35(1), 1-11.
</p>
<p>Sanyal, N. (2022). &quot;Iterative variable selection for high-dimensional data with binary outcomes&quot;. arXiv preprint arXiv:2211.03190.
</p>

<hr>
<h2 id='nlps'>Non-local prior based single-step variable selection for high-dimensional data</h2><span id='topic+nlpsLM'></span><span id='topic+nlpsGLM'></span><span id='topic+nlpsAFTM'></span>

<h3>Description</h3>

<p><code>nlpsLM</code>, <code>nlpsGLM</code>, <code>nlpsAFTM</code> perform variable selection in a single iteration respectively for continuous, binary and survival outcomes, combining the computational efficiency of the 'structured screen-and-select' variable selection strategy based on some association learning and the parsimonious uncertainty quantification provided by the use of non-local priors (see the References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlpsLM(y, x, cor_xy, prior = c("mom", "imom", "emom", "zellner", 
  "horseshoe"), tau, priorDelta = modelbbprior(1,1), 
  k0, rxx, niter = 2000, verbose = F, 
  tau.hs.method = "halfCauchy", sigma.hs.method = "Jeffreys" )

nlpsGLM(y, x, mmle_xy, prior = c("mom", "imom", "zellner"), 
  tau, priorDelta = modelbbprior(1,1), 
  k0, rxx, niter = 2000, verbose = F )

nlpsAFTM(y, event, x, mu_xy, prior = c("mom", "imom", "emom", 
  "zellner"), tau, priorDelta = modelbbprior(1,1), 
  k0, rxx, niter = 2000, verbose = F )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlps_+3A_y">y</code></td>
<td>
<p>The vector of continuous response (phenotype) for linear models (LM), or binary response (phenotype) for generalized linear models (GLM), or survival times for accelerated failure time models (AFTM). Binary response values must be 0 or 1.</p>
</td></tr>
<tr><td><code id="nlps_+3A_event">event</code></td>
<td>
<p>Only for AFTM. The vector of status indicator for the survival data.</p>
</td></tr>
<tr><td><code id="nlps_+3A_x">x</code></td>
<td>
<p>The design matrix with subjects in rows and independent variables (SNPs) in columns. Missing values are not accepted currently.</p>
</td></tr>
<tr><td><code id="nlps_+3A_cor_xy">cor_xy</code></td>
<td>
<p>Only for LM. Vector of (Pearson) correlations of <code>y</code> with the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="nlps_+3A_mmle_xy">mmle_xy</code></td>
<td>
<p>Only for GLM. Vector of maximum marginal likelihood estimates of the regression parameters for the variables (SNPs) in <code>x</code>. These may be obtained from individual GLM fits of <code>y</code> with the columns of <code>x</code>.</p>
</td></tr>
<tr><td><code id="nlps_+3A_mu_xy">mu_xy</code></td>
<td>
<p>Only for AFTM. Vector of marginal utility estimates of the variables (SNPs) in <code>x</code>. These may be obtained by fitting AFT model to <code>y</code> with individual columns of <code>x</code> using the <code>survreg</code> function of the package <code>survival</code>. </p>
</td></tr>
<tr><td><code id="nlps_+3A_prior">prior</code></td>
<td>
<p><code>"mom"</code> for pMOM prior, <code>"imom"</code> for piMOM prior, <code>"emom"</code> for peMOM prior, <code>"zellner"</code> for Zellner's g-prior, <code>"horseshoe"</code> for horseshoe prior. For GLM, <code>"zellner"</code> considers group Zellner prior and <code>"emom"</code> and <code>"horseshoe"</code> are not available. For AFTM, <code>"horseshoe"</code> is not available. </p>
</td></tr>
<tr><td><code id="nlps_+3A_tau">tau</code></td>
<td>
<p>the value of the scale parameter tau of the non-local prior. </p>
</td></tr>
<tr><td><code id="nlps_+3A_priordelta">priorDelta</code></td>
<td>
<p>Prior for model space. Defaults to <code>modelbbprior(1,1)</code>, which is beta-binomial(1,1) prior.</p>
</td></tr>
<tr><td><code id="nlps_+3A_k0">k0</code></td>
<td>
<p>GWASinlps tuning parameter denoting the number of leading SNPs (see Details).</p>
</td></tr>
<tr><td><code id="nlps_+3A_rxx">rxx</code></td>
<td>
<p>GWASinlps tuning parameter denoting the correlation threshold to determine leading sets (see References).</p>
</td></tr>
<tr><td><code id="nlps_+3A_niter">niter</code></td>
<td>
<p>Number of MCMC iterations for non-local prior based Bayesian variable selection. Defaults to 2000.</p>
</td></tr>
<tr><td><code id="nlps_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, prints result from the iterations progressively. FALSE by default.</p>
</td></tr>
<tr><td><code id="nlps_+3A_tau.hs.method">tau.hs.method</code></td>
<td>
<p>Necessary only when <code>prior="horseshoe"</code>. See <code>horseshoe</code> function reference.</p>
</td></tr>
<tr><td><code id="nlps_+3A_sigma.hs.method">sigma.hs.method</code></td>
<td>
<p>Necessary only when <code>prior="horseshoe"</code>. See <code>horseshoe</code> function reference.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The <code>nlpsLM</code>, <code>nlpsGLM</code> and <code>nlpsAFTM</code> functions perform SNP selection in one iteration for continuous data, binary data, and survival data, respectively. The <code>GWASinlps</code> function repeatedly calls these functions. For details of the procedure, see the reference for the <code>GWASinlps</code> function.
</p>


<h3>Value</h3>

<p>A list with elements
</p>
<table>
<tr><td><code>hppm</code></td>
<td>
<p>The names of variables (SNPs) appearing in the highest posterior probability model (HPPM) of at least one leading set. </p>
</td></tr>
<tr><td><code>not.selected</code></td>
<td>
<p>The names of variables (SNPs) appearing in at least one leading set but in none of the HPPMs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nilotpal Sanyal &lt;nilotpal.sanyal@gmail.com&gt;
</p>


<h3>References</h3>

<p>Sanyal et al. (2019), &quot;GWASinlps: Non-local prior based iterative SNP selection tool for genome-wide association studies&quot;. Bioinformatics, 35(1), 1-11.
</p>
<p>Sanyal, N. (2022). &quot;Iterative variable selection for high-dimensional data with binary outcomes&quot;. arXiv preprint arXiv:2211.03190.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GWASinlps">GWASinlps</a></code>, <code><a href="mombf.html#topic+modelSelection">modelSelection</a></code>, <code><a href="horseshoe.html#topic+horseshoe">horseshoe</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n = 100
p = 1000
m = 10

# Generate design matrix (genotype matrix)
set.seed(1) 
f = runif( p, .1, .2 ) # simulate minor allele frequency
x = matrix( nrow = n, ncol = p )
colnames(x) = 1:p
for(j in 1:p)
  x[,j] = rbinom( n, 2, f[j] )

# Generate true effect sizes
causal_snps = sample( 1:p, m )
beta = rep( 0, p )
set.seed(1)
beta[causal_snps] = rnorm(m, mean = 0, sd = 2 )

# Generate continuous (phenotype) data
y.cont = x %*% beta + rnorm(n, 0, 1) 

# Generate binary (phenotype) data
prob = exp(x %*% beta)/(1 + exp(x %*% beta))
y.bin = sapply(1:n, function(i)rbinom(1,1,prob[i]) )

# Fix scale parameter tau 
tau = 0.022

# GWASinlps analysis
cor_xy = c(cor(x,y.cont))
names(cor_xy) = colnames(x)
nlps_cont = nlpsLM(y.cont, x, cor_xy=cor_xy, prior="mom", 
  tau=tau, k0=2, rxx=0.3, niter=10000, verbose=TRUE) 
nlps_cont

library(fastglm)
mode(x) = "double"  #needed for fastglm() function below
mmle_xy = apply( x, 2, function(z) coef( fastglm(y=y.bin, 
x=cbind(1,matrix(z)), family = binomial(link = "logit")) )[2] )
nlps_bin = nlpsGLM(y.bin, x, mmle_xy=mmle_xy, prior="mom", 
  tau=tau, k0=2, rxx=0.3, niter=10000, verbose=TRUE) 
nlps_bin
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
