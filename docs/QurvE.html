<!DOCTYPE html><html><head><title>Help for package QurvE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {QurvE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biosensor.eq'><p>Internal function used to fit a biosensor response model with <code>nlsLM</code></p></a></li>
<li><a href='#buildTooltipOrPopoverOptionsList'><p>Custom tooltip function</p></a></li>
<li><a href='#export_RData'><p>Export an R object as .RData file</p></a></li>
<li><a href='#export_Table'><p>Export a tabular object as tab-separated .txt file</p></a></li>
<li><a href='#fl.control'><p>Create a <code>fl.control</code> object.</p></a></li>
<li><a href='#fl.drFit'><p>Fit a biosensor model (Meyer et al., 2019) to response vs. concentration data</p></a></li>
<li><a href='#fl.drFitModel'><p>Perform a biosensor model fit on response vs. concentration data of a single sample.</p></a></li>
<li><a href='#fl.report'><p>Create a PDF and HTML report with results from a fluorescence analysis workflow</p></a></li>
<li><a href='#fl.workflow'><p>Run a complete fluorescence curve analysis and dose-reponse analysis workflow.</p></a></li>
<li><a href='#flBootSpline'><p>flBootSpline: Function to generate a bootstrap</p></a></li>
<li><a href='#flFit'><p>Perform a fluorescence curve analysis on all samples in the provided dataset.</p></a></li>
<li><a href='#flFitLinear'><p>Data fit via a heuristic linear method</p></a></li>
<li><a href='#flFitSpline'><p>Perform a smooth spline fit on fluorescence data</p></a></li>
<li><a href='#growth.control'><p>Create a <code>grofit.control</code> object.</p></a></li>
<li><a href='#growth.drBootSpline'><p>Perform a smooth spline fit on response vs. concentration data of a single sample</p></a></li>
<li><a href='#growth.drFit'><p>Perform a dose-response analysis on response vs. concentration data</p></a></li>
<li><a href='#growth.drFitModel'><p>Fit various models to response vs. concentration data of a single sample to determine the EC50.</p></a></li>
<li><a href='#growth.drFitSpline'><p>Perform a smooth spline fit on response vs. concentration data of a single sample to determine the EC50.</p></a></li>
<li><a href='#growth.gcBootSpline'><p>Perform a bootstrap on growth vs. time data followed by spline fits for each resample</p></a></li>
<li><a href='#growth.gcFit'><p>Perform a growth curve analysis on all samples in the provided dataset.</p></a></li>
<li><a href='#growth.gcFitLinear'><p>Fit an exponential growth model with a heuristic linear method</p></a></li>
<li><a href='#growth.gcFitModel'><p>Fit nonlinear growth models to growth data</p></a></li>
<li><a href='#growth.gcFitSpline'><p>Perform a smooth spline fit on growth data</p></a></li>
<li><a href='#growth.report'><p>Create a PDF and HTML report with results from a growth curve analysis workflow</p></a></li>
<li><a href='#growth.workflow'><p>Run a complete growth curve analysis and dose-reponse analysis workflow.</p></a></li>
<li><a href='#inflect'><p>Find indices of maxima an minima in a data series</p></a></li>
<li><a href='#lm_parms'><p>Helper functions for handling linear fits.</p></a></li>
<li><a href='#low.integrate'><p>Function to estimate the area under a curve given as x and y(x) values</p></a></li>
<li><a href='#parse_data'><p>Parse raw plate reader data and convert it to a format compatible with QurvE</p></a></li>
<li><a href='#parse_Gen5Gen6'><p>Extract relevant data from a raw data export file generated with the &quot;Gen5&quot; or &quot;Gen6&quot; software.</p></a></li>
<li><a href='#parse_victornivo'><p>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor Nivo&quot; plate readers.</p></a></li>
<li><a href='#parse_victorx3'><p>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor X3&quot; plate readers.</p></a></li>
<li><a href='#plot.dr_parameter'><p>Compare calculated dose-response parameters between conditions.</p></a></li>
<li><a href='#plot.drBootSpline'><p>Generic plot function for <code>gcBootSpline</code> objects.</p></a></li>
<li><a href='#plot.drFit'><p>Generic plot function for <code>drFit</code> objects.</p></a></li>
<li><a href='#plot.drFitfl'><p>Generic plot function for <code>drFitFL</code> objects.</p></a></li>
<li><a href='#plot.drFitFLModel'><p>Generic plot function for <code>drFitFLModel</code> objects.</p></a></li>
<li><a href='#plot.drFitModel'><p>Generic plot function for <code>drFitModel</code> objects.</p></a></li>
<li><a href='#plot.drFitSpline'><p>Generic plot function for <code>drFitSpline</code> objects.</p></a></li>
<li><a href='#plot.dual'><p>Compare fluorescence and growth over time</p></a></li>
<li><a href='#plot.flBootSpline'><p>Generic plot function for <code>flBootSpline</code> objects.</p></a></li>
<li><a href='#plot.flFitLinear'><p>Generic plot function for <code>flcFittedLinear</code> objects. Plot the results of a linear regression on ln-transformed data</p></a></li>
<li><a href='#plot.flFitRes'><p>Combine different groups of samples into a single plot</p></a></li>
<li><a href='#plot.flFitSpline'><p>Generic plot function for <code>flFitSpline</code> objects.</p></a></li>
<li><a href='#plot.gcBootSpline'><p>Generic plot function for <code>gcBootSpline</code> objects.</p></a></li>
<li><a href='#plot.gcFitLinear'><p>Generic plot function for <code>gcFittedLinear</code> objects. Plot the results of a linear regression on ln-transformed data</p></a></li>
<li><a href='#plot.gcFitModel'><p>Generic plot function for <code>gcFitModel</code> objects.</p></a></li>
<li><a href='#plot.gcFitSpline'><p>Generic plot function for <code>gcFitSpline</code> objects.</p></a></li>
<li><a href='#plot.grid'><p>Plot a matrix of growth curve panels</p></a></li>
<li><a href='#plot.grodata'><p>Generic plot function for <code>grodata</code> objects. Plots raw growth, fluorescence, or normalized fluorescence data of multiple samples or conditions.</p></a></li>
<li><a href='#plot.grofit'><p>Generic plot function for <code>grofit</code> objects. Combine different groups of samples into a single plot</p></a></li>
<li><a href='#plot.parameter'><p>Compare growth parameters between samples or conditions</p></a></li>
<li><a href='#QurvE-package'><p>QurvE: Robust and User-Friendly Analysis of Growth and Fluorescence Curves</p></a></li>
<li><a href='#rdm.data'><p>The function calls the <code>baranyi</code> function to generate curves between time zero and <code>t</code> and adds some random noise to the x- and y-axes. The three growth parameters given as input values will be slightly changed to produce different growth curves. The resulting datasets can be used to test the <code>growth.workflow</code> function.</p></a></li>
<li><a href='#read_data'><p>Read growth and fluorescence data in table format</p></a></li>
<li><a href='#read_file'><p>Call the appropriate function required to read a table file and return the table as a dataframe object.</p></a></li>
<li><a href='#run_app'><p>Run Shiny QurvE App</p></a></li>
<li><a href='#summary.drBootSpline'><p>Generic summary function for drBootSpline objects</p></a></li>
<li><a href='#summary.drFit'><p>Generic summary function for drFit objects</p></a></li>
<li><a href='#summary.drFitfl'><p>Generic summary function for drFitfl objects</p></a></li>
<li><a href='#summary.drFitFLModel'><p>Generic summary function for drFitFLModel objects</p></a></li>
<li><a href='#summary.drFitModel'><p>Generic summary function for drFitModel objects</p></a></li>
<li><a href='#summary.drFitSpline'><p>Generic summary function for drFitSpline objects</p></a></li>
<li><a href='#summary.flBootSpline'><p>Generic summary function for flBootSpline objects</p></a></li>
<li><a href='#summary.flFit'><p>Generic summary function for flFit objects</p></a></li>
<li><a href='#summary.flFitLinear'><p>Generic summary function for flFitLinear objects</p></a></li>
<li><a href='#summary.flFitSpline'><p>Generic summary function for flFitSpline objects</p></a></li>
<li><a href='#summary.gcBootSpline'><p>Generic summary function for gcBootSpline objects</p></a></li>
<li><a href='#summary.gcFit'><p>Generic summary function for gcFit objects</p></a></li>
<li><a href='#summary.gcFitLinear'><p>Generic summary function for gcFitLinear objects</p></a></li>
<li><a href='#summary.gcFitModel'><p>Generic summary function for gcFitModel objects</p></a></li>
<li><a href='#summary.gcFitSpline'><p>Generic summary function for gcFitSpline objects</p></a></li>
<li><a href='#table_group_fluorescence_linear'><p>Generate a grouped results table for linear fits with average and standard deviations</p></a></li>
<li><a href='#table_group_fluorescence_spline'><p>Generate a grouped results table for spline fits with average and standard deviations</p></a></li>
<li><a href='#table_group_growth_linear'><p>Generate a grouped results table for linear fits with average and standard deviations</p></a></li>
<li><a href='#table_group_growth_model'><p>Generate a grouped results table for parametric fits with average and standard deviations</p></a></li>
<li><a href='#table_group_growth_spline'><p>Generate a grouped results table for spline fits with average and standard deviations</p></a></li>
<li><a href='#tidy_to_custom'><p>Convert a tidy data frame to a custom QurvE format</p></a></li>
<li><a href='#updateResistantPopover'><p>Create an update-resistant popover for a Shiny element</p></a></li>
<li><a href='#zipFastener'><p>Combine two dataframes like a zip-fastener</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Robust and User-Friendly Analysis of Growth and Fluorescence
Curves</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>High-throughput analysis of growth curves and fluorescence
    data using three methods: linear regression, growth model fitting, and
    smooth spline fit. Analysis of dose-response relationships via
    smoothing splines or dose-response models. Complete data analysis
    workflows can be executed in a single step via user-friendly wrapper
    functions. The results of these workflows are summarized in detailed
    reports as well as intuitively navigable 'R' data containers. A 'shiny'
    application provides access to all features without
    requiring any programming knowledge. The package is described in further
    detail in Wirth et al. (2023) &lt;<a href="https://doi.org/10.1038%2Fs41596-023-00850-7">doi:10.1038/s41596-023-00850-7</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/NicWir/QurvE">https://github.com/NicWir/QurvE</a>, <a href="https://nicwir.github.io/QurvE/">https://nicwir.github.io/QurvE/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/NicWir/QurvE/issues">https://github.com/NicWir/QurvE/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr, methods, R (&ge; 4.0), stringr, tidyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, drc, DT, foreach, ggh4x, ggnewscale, ggplot2,
ggpubr, kableExtra, knitr, labeling, magrittr, minpack.lm,
plyr, purrr, RColorBrewer, readxl, rmarkdown, scales, shiny,
stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bookdown, Cairo, htmltools, plotrix, prettydoc, rlang,
shinyBS, shinycssloaders, shinyFiles, shinyjs, shinysurveys,
shinythemes, testthat (&ge; 3.0.0), tibble, tinytex</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Collate:</td>
<td>'QurvE-package.R' 'control_functions.R' 'data_parsers.R'
'dose-response-analysis.R' 'fluorescence_plots.R'
'fluorescence_summaries.R' 'fluorescence_workflows.R'
'group_tables.R' 'growth_plots.R' 'growth_summaries.R'
'growth_workflows.R' 'linear_fits.R' 'nonparametric_fits.R'
'parametric_fits.R' 'utils.R' 'report_functions.R'
'shiny_app_functions.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-26 12:06:01 UTC; ncw</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas T. Wirth <a href="https://orcid.org/0000-0003-0799-1321"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Jonathan Funk [aut] (Co-developer of shiny app.),
  Matthias Kahm [ctb] (Author of 'grofit' package, whose general data
    structure was adopted for QurvE.),
  Maik Kschischo [ctb] (Author of 'grofit' package, whose general data
    structure was adopted for QurvE.),
  Thomas Petzoldt <a href="https://orcid.org/0000-0002-4951-6468"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (Creator of the package 'growthrates', whose function for
    calculating linear regressions served as a template in QurvE.),
  Andrew Stein [ctb] (Creator of 'xgxr' package from which QurvE adopted
    code to plot axis ticks on log10 scale.),
  Michael W. Kearney [ctb] (Creator of 'tfse' package from which QurvE
    adopted the match_arg function.),
  Santiago I. Hurtado [ctb] (Creator of 'RobustLinearReg' package from
    which QurvE adopted the Theil Sehn Regression method.),
  Mark Heckmann [ctb] (Creator of the 'zipFastener' function; source:
    https://ryouready.wordpress.com/2009/03/27/r-zip-fastener-for-two-data-frames-combining-rows-or-columns-of-two-dataframes-in-an-alternating-manner/),
  Nicholas Hamilton [ctb] (Creator of the 'colFmt' function.),
  Evan Friedland [ctb] (Creator of the 'inflect' function.),
  Heather Turner [ctb] (Creator of the 'base_breaks' function.),
  Georgi N. Boshnakov [ctb] (Creator of 'gbRd' package from which
    functions are used to display function help pages within the shiny
    app.)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas T. Wirth &lt;mail.nicowirth@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-26 12:40:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='biosensor.eq'>Internal function used to fit a biosensor response model with <code><a href="minpack.lm.html#topic+nlsLM">nlsLM</a></code></h2><span id='topic+biosensor.eq'></span>

<h3>Description</h3>

<p>Calculates the values of biosensor response model for given time points and response parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>biosensor.eq(x, y.min, y.max, K, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="biosensor.eq_+3A_x">x</code></td>
<td>
<p>A vector of concentration values</p>
</td></tr>
<tr><td><code id="biosensor.eq_+3A_y.min">y.min</code></td>
<td>
<p>The minimum fluorescence value</p>
</td></tr>
<tr><td><code id="biosensor.eq_+3A_y.max">y.max</code></td>
<td>
<p>The maximum fluorescence value</p>
</td></tr>
<tr><td><code id="biosensor.eq_+3A_k">K</code></td>
<td>
<p>Sensitivity parameter</p>
</td></tr>
<tr><td><code id="biosensor.eq_+3A_n">n</code></td>
<td>
<p>Cooperativity parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of fluorescence values
</p>


<h3>References</h3>

<p>Meyer, A.J., Segall-Shapiro, T.H., Glassey, E. et al. <em>Escherichia coli “Marionette” strains with 12 highly optimized small-molecule sensors.</em> Nat Chem Biol 15, 196–204 (2019). DOI: 10.1038/s41589-018-0168-3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- seq(1:10)
conc &lt;- rev(10*(1/2)^n)
fit &lt;- biosensor.eq(conc, 300, 82000, 0.85, 2)

</code></pre>

<hr>
<h2 id='buildTooltipOrPopoverOptionsList'>Custom tooltip function</h2><span id='topic+buildTooltipOrPopoverOptionsList'></span>

<h3>Description</h3>

<p>This function creates a custom tooltip for a given element in a Shiny application.
The implementation is based on the shinyBS package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildTooltipOrPopoverOptionsList(title, placement, trigger, options, content)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="buildTooltipOrPopoverOptionsList_+3A_title">title</code></td>
<td>
<p>The text for the tooltip's title.</p>
</td></tr>
<tr><td><code id="buildTooltipOrPopoverOptionsList_+3A_placement">placement</code></td>
<td>
<p>Placement of the tooltip. One of 'top', 'bottom', 'left', or 'right'.</p>
</td></tr>
<tr><td><code id="buildTooltipOrPopoverOptionsList_+3A_trigger">trigger</code></td>
<td>
<p>The events that trigger the tooltip. One or more of 'click', 'hover', 'focus', or 'manual'.</p>
</td></tr>
<tr><td><code id="buildTooltipOrPopoverOptionsList_+3A_options">options</code></td>
<td>
<p>A list of additional options for the tooltip.</p>
</td></tr>
<tr><td><code id="buildTooltipOrPopoverOptionsList_+3A_content">content</code></td>
<td>
<p>Optional HTML content for the tooltip.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of tooltip options to be used in the Shiny application.
</p>


<h3>See Also</h3>

<p><a href="https://CRAN.R-project.org/package=shinyBS">https://CRAN.R-project.org/package=shinyBS</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tooltip_options &lt;- custom_tooltip(
  title = "Sample tooltip",
  placement = "top",
  trigger = "hover",
  options = list(delay = 100),
  content = "This is a custom tooltip."
)

# In a Shiny app
# shiny::tags$span("Hover me!", `data-toggle` = "tooltip",
                   `data-placement` = "top", `data-trigger` = "hover",
                   `title` = "Hello, tooltip!")

## End(Not run)
</code></pre>

<hr>
<h2 id='export_RData'>Export an R object as .RData file</h2><span id='topic+export_RData'></span>

<h3>Description</h3>

<p>Export an R object as .RData file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_RData(object, out.dir = tempdir(), out.nm = class(object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_RData_+3A_object">object</code></td>
<td>
<p>An R object.</p>
</td></tr>
<tr><td><code id="export_RData_+3A_out.dir">out.dir</code></td>
<td>
<p>The path to the output directory. Default: the working directory</p>
</td></tr>
<tr><td><code id="export_RData_+3A_out.nm">out.nm</code></td>
<td>
<p>The output filename (with or without '.RData' ending). Default: the class of <code>object</code> followed by '.RData'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
df &lt;- data.frame('A' = seq(1:10), 'B' = rev(seq(1:10)))

export_RData(df)
}
</code></pre>

<hr>
<h2 id='export_Table'>Export a tabular object as tab-separated .txt file</h2><span id='topic+export_Table'></span>

<h3>Description</h3>

<p>Export a tabular object as tab-separated .txt file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_Table(table, out.dir = tempdir(), out.nm = deparse(substitute(table)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export_Table_+3A_table">table</code></td>
<td>
<p>A tabular R object (dataframe, matrix, array)</p>
</td></tr>
<tr><td><code id="export_Table_+3A_out.dir">out.dir</code></td>
<td>
<p>The path to the output directory. Default: the working directory</p>
</td></tr>
<tr><td><code id="export_Table_+3A_out.nm">out.nm</code></td>
<td>
<p>The output filename (with or without '.txt' ending). Default: the name of <code>table</code> followed by '.txt'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
df &lt;- data.frame('A' = seq(1:10), 'B' = rev(seq(1:10)))

export_Table(df)
}
</code></pre>

<hr>
<h2 id='fl.control'>Create a <code>fl.control</code> object.</h2><span id='topic+fl.control'></span>

<h3>Description</h3>

<p>A <code>fl.control</code> object is required to perform various computations on fluorescence data stored within <code>grodata</code> objects (created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>). A <code>fl.control</code> object is created automatically as part of <code><a href="#topic+fl.workflow">fl.workflow</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl.control(
  fit.opt = c("l", "s"),
  x_type = c("growth", "time"),
  norm_fl = TRUE,
  t0 = 0,
  tmax = NA,
  min.growth = NA,
  max.growth = NA,
  log.x.lin = FALSE,
  log.x.spline = FALSE,
  log.y.lin = FALSE,
  log.y.spline = FALSE,
  lin.h = NULL,
  lin.R2 = 0.97,
  lin.RSD = 0.05,
  lin.dY = 0.05,
  dr.parameter = "max_slope.spline",
  dr.method = c("model", "spline"),
  dr.have.atleast = 5,
  smooth.dr = NULL,
  log.x.dr = FALSE,
  log.y.dr = FALSE,
  nboot.dr = 0,
  biphasic = FALSE,
  interactive = FALSE,
  nboot.fl = 0,
  smooth.fl = 0.75,
  growth.thresh = 1.5,
  suppress.messages = FALSE,
  neg.nan.act = FALSE,
  clean.bootstrap = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fl.control_+3A_fit.opt">fit.opt</code></td>
<td>
<p>(Character or vector of strings) Indicates whether the program should perform a linear regression (<code>'l'</code>) and/or spline fit (<code>'s'</code>). Default:  <code>fit.opt = c('l', 's')</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_x_type">x_type</code></td>
<td>
<p>(Character) Which data type shall be used as independent variable? Options are <code>'growth'</code> and <code>'time'</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_norm_fl">norm_fl</code></td>
<td>
<p>(Logical) use normalized (to growth) fluorescence data in fits. Has an effect only when <code>x_type = 'time'</code></p>
</td></tr>
<tr><td><code id="fl.control_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits (if <code>x_type = 'time'</code>).</p>
</td></tr>
<tr><td><code id="fl.control_+3A_tmax">tmax</code></td>
<td>
<p>(Numeric) Maximum time value considered for linear and spline fits (if <code>x_type = 'time'</code>)..</p>
</td></tr>
<tr><td><code id="fl.control_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only values above a certain threshold should be considered for linear regressions or spline fits (if <code>x_type = 'growth'</code>).</p>
</td></tr>
<tr><td><code id="fl.control_+3A_max.growth">max.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values below a certain threshold should be considered for linear regressions or spline fits (if <code>x_type = 'growth'</code>).</p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.x.lin">log.x.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the independent variable for <em>linear</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.x.spline">log.x.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the independent variable for <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.y.lin">log.y.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the fluorescence data for <em>linear</em> fits. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.y.spline">log.y.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the fluorescence data for <em>spline</em> fits. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fl.control_+3A_lin.h">lin.h</code></td>
<td>
<p>(Numeric) Manually define the size of the sliding window used in <code><a href="#topic+flFitLinear">flFitLinear</a></code>. If <code>NULL</code>, h is calculated for each samples based on the number of measurements in the fluorescence increase phase of the plot.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_lin.r2">lin.R2</code></td>
<td>
<p>(Numeric) R<sup>2</sup> threshold for <code><a href="#topic+flFitLinear">flFitLinear</a></code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_lin.rsd">lin.RSD</code></td>
<td>
<p>(Numeric) Relative standard deviation (RSD) threshold for the calculated slope in <code><a href="#topic+flFitLinear">flFitLinear</a></code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_lin.dy">lin.dY</code></td>
<td>
<p>(Numeric) Threshold for the minimum fraction of growth increase a linear regression window should cover. Default: 0.05 (5%).</p>
</td></tr>
<tr><td><code id="fl.control_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+fl.drFit">fl.drFit</a></code> for further details. Default: <code>'max_slope.spline'</code>, which represents the maximum slope of the spline fit Typical options include: <code>'max_slope.linfit'</code>, <code>'dY.linfit'</code>, <code>'max_slope.spline'</code>, and <code>'dY.spline'</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Perform either a smooth spline fit on response parameter vs. concentration data (<code>'spline'</code>) or fit a biosensor response model with <code>'model'</code> (proposed by Meyer et al., 2019).</p>
</td></tr>
<tr><td><code id="fl.control_+3A_dr.have.atleast">dr.have.atleast</code></td>
<td>
<p>(Numeric) Minimum number of different values for the response parameter one should have for estimating a dose response curve. Note: All fit procedures require at least six unique values. Default: <code>6</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_smooth.dr">smooth.dr</code></td>
<td>
<p>(Numeric) Smoothing parameter used in the spline fit by smooth.spline during dose response curve estimation. Usually (not necessesary) in (0; 1]. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.x.dr">log.x.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(x+1)</code> should be applied to the concentration data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_log.y.dr">log.y.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(y+1)</code> should be applied to the response data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_nboot.dr">nboot.dr</code></td>
<td>
<p>(Numeric) Defines the number of bootstrap samples for EC50 estimation. Use <code>nboot.dr = 0</code> to disable bootstrapping. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+flFitLinear">flFitLinear</a></code> and <code><a href="#topic+flFitSpline">flFitSpline</a></code> try to extract fluorescence parameters for two different phases (as observed with, e.g., regulator-promoter systems with varying response in different growth stages) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="fl.control_+3A_interactive">interactive</code></td>
<td>
<p>(Logical) Controls whether the fit for each sample and method is controlled manually by the user. If <code>TRUE</code>, each fit is visualized in the <em>Plots</em> pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_nboot.fl">nboot.fl</code></td>
<td>
<p>(Numeric) Number of bootstrap samples used for nonparametric curve fitting with <code><a href="#topic+flBootSpline">flBootSpline</a></code>. Use <code>nboot.fl = 0</code> to disable the bootstrap. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="fl.control_+3A_smooth.fl">smooth.fl</code></td>
<td>
<p>(Numeric) Parameter describing the smoothness of the spline fit; usually (not necessary) within (0;1]. <code>smooth.gc=NULL</code> causes the program to query an optimal value via cross validation techniques. Especially for datasets with few data points the option <code>NULL</code> might cause a too small smoothing parameter. This can result a too tight fit that is susceptible to measurement errors (thus overestimating slopes) or produce an error in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or lead to overfitting. The usage of a fixed value is recommended for reproducible results across samples. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>0.55</code></p>
</td></tr>
<tr><td><code id="fl.control_+3A_growth.thresh">growth.thresh</code></td>
<td>
<p>(Numeric) Define a threshold for growth. Only if any growth value in a sample is greater than <code>growth.thresh</code> (default: 1.5) times the start growth, further computations are performed. Else, a message is returned.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_suppress.messages">suppress.messages</code></td>
<td>
<p>(Logical) Indicates whether messages (information about current fluorescence curve, EC50 values etc.) should be displayed (<code>FALSE</code>) or not (<code>TRUE</code>). This option is meant to speed up the high-throughput processing data. Note: warnings are still displayed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_neg.nan.act">neg.nan.act</code></td>
<td>
<p>(Logical) Indicates whether the program should stop when negative fluorescence values or NA values appear (<code>TRUE</code>). Otherwise, the program removes these values silently (<code>FALSE</code>). Improper values may be caused by incorrect data or input errors. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.control_+3A_clean.bootstrap">clean.bootstrap</code></td>
<td>
<p>(Logical) Determines if negative values which occur during bootstrap should be removed (<code>TRUE</code>) or kept (<code>FALSE</code>). Note: Infinite values are always removed. Default: <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a list with all arguments described above as entries.
</p>


<h3>References</h3>

<p>Meyer, A.J., Segall-Shapiro, T.H., Glassey, E. et al. <em>Escherichia coli “Marionette” strains with 12 highly optimized small-molecule sensors.</em> Nat Chem Biol 15, 196–204 (2019). DOI: 10.1038/s41589-018-0168-3
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default option
control_default &lt;- fl.control()
# user defined
control_manual &lt;- fl.control(fit.opt = c('s'),
                             smooth.fl = 0.6,
                             x_type = 'time',
                             t0 = 2)
</code></pre>

<hr>
<h2 id='fl.drFit'>Fit a biosensor model (Meyer et al., 2019) to response vs. concentration data</h2><span id='topic+fl.drFit'></span>

<h3>Description</h3>

<p>Fit a biosensor model (Meyer et al., 2019) to response vs. concentration data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl.drFit(
  flTable,
  control = fl.control(dr.method = "model", dr.parameter = "max_slope.spline")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fl.drFit_+3A_fltable">flTable</code></td>
<td>
<p>A dataframe containing the data for the dose-response model estimation. Such table of class <code>flTable</code> can be obtained by running <code><a href="#topic+flFit">flFit</a></code> with <code>dr.method = 'model'</code> as argument in the <code>fl.control</code> object.</p>
</td></tr>
<tr><td><code id="fl.drFit_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="fl.drFit_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Perform either a smooth spline fit on response parameter vs. concentration data (<code>'spline'</code>) or fit a biosensor response model with <code>'model'</code> (proposed by Meyer et al., 2019).</p>
</td></tr>
<tr><td><code id="fl.drFit_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+fl.drFit">fl.drFit</a></code> for further details. Default: <code>'max_slope.spline'</code>, which represents the maximum slope of the spline fit Typical options include: <code>'max_slope.linfit'</code>, <code>'dY.linfit'</code>, <code>'max_slope.spline'</code>, and <code>'dY.spline'</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common response parameters used in dose-response analysis:<br><br><b>Linear fit:</b><br>- max_slope.linfit: Fluorescence increase rate<br>- lambda.linfit: Lag time<br>- dY.linfit: Maximum Fluorescence - Minimum Fluorescence<br>- A.linfit: Maximum fluorescence<br><br><b>Spline fit:</b><br>- max_slope.spline: Fluorescence increase rate<br>- lambda.spline: Lag time<br>- dY.spline: Maximum Fluorescence - Minimum Fluorescence<br>- A.spline: Maximum fluorescence<br>- integral.spline: Integral<br><br><b>Parametric fit:</b><br>- max_slope.model: Fluorescence increase rate<br>- lambda.model: Lag time<br>- dY.model: Maximum Fluorescence - Minimum Fluorescence<br>- A.model: Maximum fluorescence<br>- integral.model: Integral'
</p>


<h3>Value</h3>

<p>An object of class <code>drFit</code>.
</p>
<table>
<tr><td><code>raw.data</code></td>
<td>
<p>Data that passed to the function as <code>flTable</code>.</p>
</td></tr>
<tr><td><code>drTable</code></td>
<td>
<p>Dataframe containing condition identifiers, fit options, and results of the dose-response analysis.</p>
</td></tr>
<tr><td><code>drFittedModels</code></td>
<td>
<p>List of all <code>drFitModel</code> objects generated by the call of <code><a href="#topic+fl.drFitModel">fl.drFitModel</a></code> for each distinct experiment.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> created with the call of <code><a href="#topic+fl.control">fl.control</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Meyer, A.J., Segall-Shapiro, T.H., Glassey, E. et al. <em>Escherichia coli “Marionette” strains with 12 highly optimized small-molecule sensors.</em> Nat Chem Biol 15, 196–204 (2019). DOI: 10.1038/s41589-018-0168-3
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load example dataset
input &lt;- read_data(data.fl = system.file('lac_promoters_fluorescence.txt', package = 'QurvE'),
                   csvsep.fl = "\t")

# Run fluorescence curve analysis workflow
fitres &lt;- flFit(fl_data = input$fluorescence,
                time = input$time,
                parallelize = FALSE,
                control = fl.control(x_type = 'time', norm_fl = FALSE,
                                     suppress.messages = TRUE))

# Perform dose-response analysis
drFit &lt;- fl.drFit(flTable = fitres$flTable,
                  control = fl.control(dr.method = 'model',
                                       dr.parameter = 'max_slope.linfit'))

# Inspect results
summary(drFit)
plot(drFit)

</code></pre>

<hr>
<h2 id='fl.drFitModel'>Perform a biosensor model fit on response vs. concentration data of a single sample.</h2><span id='topic+fl.drFitModel'></span>

<h3>Description</h3>

<p><code>fl.drFitModel</code> fits the biosensor model proposed by Meyer et al. (2019) to the provided response (e.g., <code>max_slope.spline</code> vs. concentration data to determine the leakiness, sensitivity, induction fold-change, and cooperativity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl.drFitModel(conc, test, drID = "undefined", control = fl.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fl.drFitModel_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values.</p>
</td></tr>
<tr><td><code id="fl.drFitModel_+3A_test">test</code></td>
<td>
<p>Vector of response parameter values of the same length as <code>conc</code>.</p>
</td></tr>
<tr><td><code id="fl.drFitModel_+3A_drid">drID</code></td>
<td>
<p>(Character) The name of the analyzed condition</p>
</td></tr>
<tr><td><code id="fl.drFitModel_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>drFitFLModel</code> object.
</p>
<table>
<tr><td><code>raw.conc</code></td>
<td>
<p>Raw data provided to the function as <code>conc</code>.</p>
</td></tr>
<tr><td><code>raw.test</code></td>
<td>
<p>Raw data for the response parameter provided to the function as <code>test</code>.</p>
</td></tr>
<tr><td><code>drID</code></td>
<td>
<p>(Character) Identifies the tested condition</p>
</td></tr>
<tr><td><code>fit.conc</code></td>
<td>
<p>Fitted concentration values.</p>
</td></tr>
<tr><td><code>fit.test</code></td>
<td>
<p>Fitted response values.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p><code>nls</code> object generated by the <code>nlsLM</code> function.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>List of parameters estimated from dose response curve fit.</p>
</td></tr>
</table>

<ul>
<li> <p><code>yEC50</code>: Response value related to EC50.
</p>
</li>
<li> <p><code>y.min</code>: Minimum fluorescence ('leakiness', if lowest concentration is 0).
</p>
</li>
<li> <p><code>y.max</code>: Maximum fluorescence.
</p>
</li>
<li> <p><code>fc</code>: Fold change (<code>y.max</code> divided by <code>y.min</code>).
</p>
</li>
<li> <p><code>K</code>: Concentration at half-maximal response ('sensitivity').
</p>
</li>
<li> <p><code>n</code>: Cooperativity.
</p>
</li>
<li> <p><code>yEC50.orig</code>: Response value for EC50 in original scale, if a transformation was applied.
</p>
</li>
<li> <p><code>K.orig</code>: K in original scale, if a transformation was applied.
</p>
</li>
<li> <p><code>test.nm</code>: Test identifier extracted from <code>test</code>.
</p>
</li></ul>

<table>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether a spline could fitted successfully to data.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> created with the call of <code><a href="#topic+fl.control">fl.control</a></code>.</p>
</td></tr>
</table>
<p>Use <code><a href="#topic+plot.drFitModel">plot.drFitModel</a></code> to visualize the model fit.
</p>


<h3>References</h3>

<p>Meyer, A.J., Segall-Shapiro, T.H., Glassey, E. et al. <em>Escherichia coli “Marionette” strains with 12 highly optimized small-molecule sensors.</em> Nat Chem Biol 15, 196–204 (2019). DOI: 10.1038/s41589-018-0168-3
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create concentration values via a serial dilution
conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)

# Simulate response values via biosensor equation
response &lt;- biosensor.eq(conc, y.min = 110, y.max = 6000, K = 0.5, n = 2) +
            0.01*6000*rnorm(10)

# Perform fit
TestRun &lt;- fl.drFitModel(conc, response, drID = 'test', control = fl.control())

print(summary(TestRun))
plot(TestRun)
</code></pre>

<hr>
<h2 id='fl.report'>Create a PDF and HTML report with results from a fluorescence analysis workflow</h2><span id='topic+fl.report'></span>

<h3>Description</h3>

<p><code>fl.report</code> requires a <code>flFitRes</code> object and creates a report in PDF and HTML format that summarizes all results obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl.report(
  flFitRes,
  out.dir = tempdir(),
  out.nm = NULL,
  ec50 = FALSE,
  format = c("pdf", "html"),
  export = FALSE,
  parallelize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fl.report_+3A_flfitres">flFitRes</code></td>
<td>
<p>A <code>grofit</code> object created with <code><a href="#topic+fl.workflow">fl.workflow</a></code>.</p>
</td></tr>
<tr><td><code id="fl.report_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) The path or name of the folder in which the report files are created.  If <code>NULL</code>, the folder will be named with a combination of 'Report.fluorescence_' and the current date and time.</p>
</td></tr>
<tr><td><code id="fl.report_+3A_out.nm">out.nm</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of the report files. If <code>NULL</code>, the files will be named with a combination of 'FluorescenceReport_' and the current date and time.</p>
</td></tr>
<tr><td><code id="fl.report_+3A_ec50">ec50</code></td>
<td>
<p>(Logical) Display results of dose-response analysis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fl.report_+3A_format">format</code></td>
<td>
<p>(Character) Define the file format for the report, PDF (<code>'pdf'</code>) and/or HTML (<code>'html'</code>). Default: (<code>c('pdf', 'html')</code>)</p>
</td></tr>
<tr><td><code id="fl.report_+3A_export">export</code></td>
<td>
<p>(Logical) Shall all plots generated in the report be exported as individual PDF and PNG files <code>TRUE</code> or not <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="fl.report_+3A_parallelize">parallelize</code></td>
<td>
<p>(Logical) Create plots using all but one available processor cores (<code>TRUE</code>) or only a single core (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fl.report_+3A_...">...</code></td>
<td>
<p>Further arguments passed to create a report. Currently supported:
</p>

<ul>
<li> <p><code>mean.grp</code>: Define groups to combine into common plots in the report based on sample identifiers. Partial matches with sample/group names are accepted. Can be <code>'all'</code>, a vector of strings, or a list of string vectors. Note: The maximum number of sample groups (with unique condition/concentration indicators) is 50. If you have more than 50 groups, option <code>'all'</code> will produce the error <code>! Insufficient values in manual scale. [Number] needed but only 50 provided</code>.
</p>
</li>
<li> <p><code>mean.conc</code>: Define concentrations to combine into common plots in the  report. Can be a numeric vector, or a list of numeric vectors.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The template .Rmd file used within this function can be found within the QurvE package installation directory.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
## Not run: 
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = 's',
                   x_type = 'time', norm_fl = TRUE,
                   dr.parameter = 'max_slope.spline',
                   suppress.messages = TRUE,
                   parallelize = FALSE)

fl.report(res, out.dir = tempdir(), parallelize = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='fl.workflow'>Run a complete fluorescence curve analysis and dose-reponse analysis workflow.</h2><span id='topic+fl.workflow'></span>

<h3>Description</h3>

<p><code>fl.workflow</code> runs <code><a href="#topic+fl.control">fl.control</a></code> to create a <code>fl.control</code> object and then performs all computational fitting operations based on the user input. Finally, if desired, a final report is created in PDF or HTML format that summarizes all results obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fl.workflow(
  grodata = NULL,
  time = NULL,
  growth = NULL,
  fl_data = NULL,
  ec50 = TRUE,
  mean.grp = NA,
  mean.conc = NA,
  fit.opt = c("l", "s"),
  x_type = c("growth", "time"),
  norm_fl = TRUE,
  t0 = 0,
  tmax = NA,
  min.growth = 0,
  max.growth = NA,
  log.x.lin = FALSE,
  log.x.spline = FALSE,
  log.y.lin = FALSE,
  log.y.spline = FALSE,
  lin.h = NULL,
  lin.R2 = 0.97,
  lin.RSD = 0.07,
  lin.dY = 0.05,
  biphasic = FALSE,
  interactive = FALSE,
  dr.parameter = "max_slope.spline",
  dr.method = c("model", "spline"),
  dr.have.atleast = 5,
  smooth.dr = NULL,
  log.x.dr = FALSE,
  log.y.dr = FALSE,
  nboot.dr = 0,
  nboot.fl = 0,
  smooth.fl = 0.75,
  growth.thresh = 1.5,
  suppress.messages = FALSE,
  neg.nan.act = FALSE,
  clean.bootstrap = TRUE,
  report = NULL,
  out.dir = NULL,
  out.nm = NULL,
  export.fig = FALSE,
  export.res = FALSE,
  parallelize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fl.workflow_+3A_grodata">grodata</code></td>
<td>
<p>A <code>grodata</code> object created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>, containing fluorescence data and data for the independent variable (i.e., time or growth).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_time">time</code></td>
<td>
<p>(optional) A matrix containing time values for each sample (if a <code>fl_data</code> dataframe is provided as separate argument).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_growth">growth</code></td>
<td>
<p>(optional) A dataframe containing growth data (if a <code>fl_data</code> matrix is provided as separate argument).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_fl_data">fl_data</code></td>
<td>
<p>(optional) A dataframe containing fluorescence data (if a <code>time</code> matrix or <code>growth</code> dataframe is provided as separate argument).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_ec50">ec50</code></td>
<td>
<p>(Logical) Perform dose-response analysis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_mean.grp">mean.grp</code></td>
<td>
<p>(<code>"all"</code>, a string vector, or a list of string vectors) Define groups to combine into common plots in the final report based on sample identifiers (if <code>report == TRUE</code>). Partial matches with sample/group names are accepted. Note: The maximum number of sample groups (with unique condition/concentration indicators) is 50. If you have more than 50 groups, option <code>"all"</code> will produce the error <code>! Insufficient values in manual scale. [Number] needed but only 50 provided</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_mean.conc">mean.conc</code></td>
<td>
<p>(A numeric vector, or a list of numeric vectors) Define concentrations to combine into common plots in the final report (if <code>report == TRUE</code>).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_fit.opt">fit.opt</code></td>
<td>
<p>(Character or character vector) Indicates whether the program should perform a linear regression (<code>"l"</code>), model fit (<code>"m"</code>), spline fit (<code>"s"</code>), or all (<code>"a"</code>). Combinations can be freely chosen by providing a character vector, e.g. <code>fit.opt = c("l", "s")</code> Default:  <code>fit.opt = c("l", "s")</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_x_type">x_type</code></td>
<td>
<p>(Character) Which data type shall be used as independent variable? Options are <code>'growth'</code> and <code>'time'</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_norm_fl">norm_fl</code></td>
<td>
<p>(Logical) use normalized (to growth) fluorescence data in fits. Has an effect only when <code>x_type = 'time'</code></p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits (if <code>x_type = 'time'</code>).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_tmax">tmax</code></td>
<td>
<p>(Numeric) Maximum time value considered for linear and spline fits (if <code>x_type = 'time'</code>)..</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only values above a certain threshold should be considered for linear regressions or spline fits (if <code>x_type = 'growth'</code>).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_max.growth">max.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values below a certain threshold should be considered for linear regressions or spline fits (if <code>x_type = 'growth'</code>).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.x.lin">log.x.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the independent variable for <em>linear</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.x.spline">log.x.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the independent variable for <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.y.lin">log.y.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the fluorescence data for <em>linear</em> fits. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.y.spline">log.y.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the fluorescence data for <em>spline</em> fits. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_lin.h">lin.h</code></td>
<td>
<p>(Numeric) Manually define the size of the sliding window used in <code><a href="#topic+flFitLinear">flFitLinear</a></code>. If <code>NULL</code>, h is calculated for each samples based on the number of measurements in the fluorescence increase phase of the plot.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_lin.r2">lin.R2</code></td>
<td>
<p>(Numeric) R<sup>2</sup> threshold for <code><a href="#topic+flFitLinear">flFitLinear</a></code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_lin.rsd">lin.RSD</code></td>
<td>
<p>(Numeric) Relative standard deviation (RSD) threshold for the calculated slope in <code><a href="#topic+flFitLinear">flFitLinear</a></code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_lin.dy">lin.dY</code></td>
<td>
<p>(Numeric) Threshold for the minimum fraction of growth increase a linear regression window should cover. Default: 0.05 (5%).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+flFitLinear">flFitLinear</a></code> and <code><a href="#topic+flFitSpline">flFitSpline</a></code> try to extract fluorescence parameters for two different phases (as observed with, e.g., regulator-promoter systems with varying response in different growth stages) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_interactive">interactive</code></td>
<td>
<p>(Logical) Controls whether the fit for each sample and method is controlled manually by the user. If <code>TRUE</code>, each fit is visualized in the <em>Plots</em> pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+fl.drFit">fl.drFit</a></code> for further details. Default: <code>"max_slope.spline"</code>, which represents the maximum slope of the spline fit Typical options include: <code>"max_slope.linfit"</code>, <code>"dY.linfit"</code>, <code>"max_slope.spline"</code>, and <code>"dY.spline"</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Perform either a smooth spline fit on response parameter vs. concentration data (<code>"spline"</code>) or fit a biosensor response model (proposed by Meyer et al., 2019).</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_dr.have.atleast">dr.have.atleast</code></td>
<td>
<p>(Numeric) Minimum number of different values for the response parameter one should have for estimating a dose response curve. Note: All fit procedures require at least six unique values. Default: <code>6</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_smooth.dr">smooth.dr</code></td>
<td>
<p>(Numeric) Smoothing parameter used in the spline fit by smooth.spline during dose response curve estimation. Usually (not necessesary) in (0; 1]. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.x.dr">log.x.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(x+1)</code> should be applied to the concentration data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_log.y.dr">log.y.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(y+1)</code> should be applied to the response data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_nboot.dr">nboot.dr</code></td>
<td>
<p>(Numeric) Defines the number of bootstrap samples for EC50 estimation. Use <code>nboot.dr = 0</code> to disable bootstrapping. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_nboot.fl">nboot.fl</code></td>
<td>
<p>(Numeric) Number of bootstrap samples used for nonparametric curve fitting with <code><a href="#topic+flBootSpline">flBootSpline</a></code>. Use <code>nboot.fl = 0</code> to disable the bootstrap. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_smooth.fl">smooth.fl</code></td>
<td>
<p>(Numeric) Parameter describing the smoothness of the spline fit; usually (not necessary) within (0;1]. <code>smooth.gc=NULL</code> causes the program to query an optimal value via cross validation techniques. Especially for datasets with few data points the option <code>NULL</code> might cause a too small smoothing parameter. This can result a too tight fit that is susceptible to measurement errors (thus overestimating slopes) or produce an error in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or lead to overfitting. The usage of a fixed value is recommended for reproducible results across samples. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>0.55</code></p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_growth.thresh">growth.thresh</code></td>
<td>
<p>(Numeric) Define a threshold for growth. Only if any growth value in a sample is greater than <code>growth.thresh</code> (default: 1.5) times the start growth, further computations are performed. Else, a message is returned.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_suppress.messages">suppress.messages</code></td>
<td>
<p>(Logical) Indicates whether messages (information about current fluorescence curve, EC50 values etc.) should be displayed (<code>FALSE</code>) or not (<code>TRUE</code>). This option is meant to speed up the high-throughput processing data. Note: warnings are still displayed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_neg.nan.act">neg.nan.act</code></td>
<td>
<p>(Logical) Indicates whether the program should stop when negative fluorescence values or NA values appear (<code>TRUE</code>). Otherwise, the program removes these values silently (<code>FALSE</code>). Improper values may be caused by incorrect data or input errors. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_clean.bootstrap">clean.bootstrap</code></td>
<td>
<p>(Logical) Determines if negative values which occur during bootstrap should be removed (<code>TRUE</code>) or kept (<code>FALSE</code>). Note: Infinite values are always removed. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_report">report</code></td>
<td>
<p>(Character or NULL) Create a PDF (<code>'pdf'</code>) and/or HTML (<code>'html'</code>) report after running all computations. Define <code>NULL</code> if no report should be created. Default: (<code>c('pdf', 'html')</code>)</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_out.dir">out.dir</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of a folder in which all result files (tables and reports) are stored. If <code>NULL</code>, the folder will be named with a combination of &quot;FluorescenceResults_&quot; and the current date and time.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_out.nm">out.nm</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of the report files. If <code>NULL</code>, the files will be named with a combination of &quot;FluorescenceReport_&quot; and the current date and time.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_export.fig">export.fig</code></td>
<td>
<p>(Logical) Export all figures created in the report as separate PNG and PDF files (<code>TRUE</code>) or not (<code>FALSE</code>). Only effective if <code>report = TRUE</code>.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_export.res">export.res</code></td>
<td>
<p>(Logical) Create tab-separated TXT files containing calculated parameters and dose-response analysis results as well as an .RData file for the resulting <code>flFitRes</code> object.</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_parallelize">parallelize</code></td>
<td>
<p>Run linear fits and bootstrapping operations in parallel using all but one available processor cores</p>
</td></tr>
<tr><td><code id="fl.workflow_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the shiny app.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>flFitRes</code> object that contains all computation results, compatible with various plotting functions of the QurvE package and with <code><a href="#topic+fl.report">fl.report</a></code>.
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Raw time matrix passed to the function as <code>time</code> (if no <code>grofit</code> object is provided. Else, extracted from <code>grofit</code>).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Raw data dataframe passed to the function as <code>grodata</code>.</p>
</td></tr>
<tr><td><code>flFit</code></td>
<td>
<p><code>flFit</code> object created with the call of <code><a href="#topic+flFit">flFit</a></code> on fluorescence data.</p>
</td></tr>
<tr><td><code>drFit</code></td>
<td>
<p><code>drFit</code> or <code>drFitfl</code> object created with the call of <code><a href="#topic+growth.drFit">growth.drFit</a></code> or <code><a href="#topic+fl.drFit">fl.drFit</a></code> for fluorescence data (based on the <code>dr.method</code> argument in <code>control</code>; see <code><a href="#topic+fl.control">fl.control</a></code>).</p>
</td></tr>
<tr><td><code>expdesign</code></td>
<td>
<p>Experimental design table inherited from <code>grodata</code> or created from the identifier columns (columns 1-3) in <code>data</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> created with the call of <code><a href="#topic+fl.control">fl.control</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = "s",
                   x_type = "time", norm_fl = TRUE,
                   dr.parameter = "max_slope.spline",
                   suppress.messages = TRUE,
                   parallelize = FALSE)

plot(res, data.type = "raw", legend.ncol = 3, basesize = 15)

</code></pre>

<hr>
<h2 id='flBootSpline'>flBootSpline: Function to generate a bootstrap</h2><span id='topic+flBootSpline'></span>

<h3>Description</h3>

<p><code>fl.gcBootSpline</code> resamples the fluorescence-'x' value pairs in a dataset with replacement and performs a spline fit for each bootstrap sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flBootSpline(
  time = NULL,
  growth = NULL,
  fl_data,
  ID = "undefined",
  control = fl.control()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flBootSpline_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable: time (if <code>x_type = 'time'</code> in <code>fl.control</code> object.</p>
</td></tr>
<tr><td><code id="flBootSpline_+3A_growth">growth</code></td>
<td>
<p>Vector of the independent variable: growth (if <code>x_type = 'growth'</code> in <code>fl.control</code> object.</p>
</td></tr>
<tr><td><code id="flBootSpline_+3A_fl_data">fl_data</code></td>
<td>
<p>Vector of dependent variable: fluorescence.</p>
</td></tr>
<tr><td><code id="flBootSpline_+3A_id">ID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="flBootSpline_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gcBootSpline</code> object containing a distribution of fluorescence parameters and
a <code>flFitSpline</code> object for each bootstrap sample. Use <code><a href="#topic+plot.gcBootSpline">plot.gcBootSpline</a></code>
to visualize all bootstrapping splines as well as the distribution of
physiological parameters.
</p>
<table>
<tr><td><code>raw.x</code></td>
<td>
<p>Raw time values provided to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>raw.fl</code></td>
<td>
<p>Raw growth data provided to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>boot.x</code></td>
<td>
<p>Table of time values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.fl</code></td>
<td>
<p>Table of growth values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.flSpline</code></td>
<td>
<p>List of <code>flFitSpline</code> object, created by <code><a href="#topic+flFitSpline">flFitSpline</a></code> for each resample of the bootstrap.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Vector of estimated lambda (lag time) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>max_slope</code></td>
<td>
<p>Vector of estimated max_slope (maximum slope) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Vector of estimated A (maximum fluorescence) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>integral</code></td>
<td>
<p>Vector of estimated integral values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>bootFlag</code></td>
<td>
<p>(Logical) Indicates the success of the bootstrapping operation.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fluorescence fitting functions: 
<code><a href="#topic+flFitSpline">flFitSpline</a>()</code>,
<code><a href="#topic+flFit">flFit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flBootSpline(time = time,
                       fl_data = data,
                       ID = 'TestFit',
                       control = fl.control(fit.opt = 's', x_type = 'time',
                       nboot.fl = 50))

plot(TestFit, combine = TRUE, lwd = 0.5)
</code></pre>

<hr>
<h2 id='flFit'>Perform a fluorescence curve analysis on all samples in the provided dataset.</h2><span id='topic+flFit'></span>

<h3>Description</h3>

<p><code>flFit</code> performs all computational fluorescence fitting operations based on the user input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flFit(
  fl_data,
  time = NULL,
  growth = NULL,
  control = fl.control(),
  parallelize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flFit_+3A_fl_data">fl_data</code></td>
<td>
<p>Either... </p>
 <ol>
<li><p> a <code>grodata</code> object created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>,
</p>
</li>
<li><p> a list containing a <code>'time'</code> matrix (for x_type == &quot;time&quot;) or <code>'growth'</code> dataframe (for x_type == &quot;growth&quot;) and a <code>'fluorescence'</code> dataframes,
or </p>
</li>
<li><p> a dataframe containing (normalized) fluorescence values (if a <code>time</code> matrix or <code>growth</code> dataframe is provided as separate argument).</p>
</li></ol>
</td></tr>
<tr><td><code id="flFit_+3A_time">time</code></td>
<td>
<p>(optional) A matrix containing time values for each sample.</p>
</td></tr>
<tr><td><code id="flFit_+3A_growth">growth</code></td>
<td>
<p>(optional) A dataframe containing growth values for each sample and sample identifiers in the first three columns.</p>
</td></tr>
<tr><td><code id="flFit_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="flFit_+3A_parallelize">parallelize</code></td>
<td>
<p>Run linear fits and bootstrapping operations in parallel using all but one available processor cores</p>
</td></tr>
<tr><td><code id="flFit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the shiny app.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common response parameters used in dose-response analysis:<br><br><b>Linear fit:</b><br>- max_slope.linfit: Fluorescence increase rate<br>- lambda.linfit: Lag time<br>- dY.linfit: Maximum Fluorescence - Minimum Fluorescence<br>- A.linfit: Maximum fluorescence<br><br><b>Spline fit:</b><br>- max_slope.spline: Fluorescence increase rate<br>- lambda.spline: Lag time<br>- dY.spline: Maximum Fluorescence - Minimum Fluorescence<br>- A.spline: Maximum fluorescence<br>- integral.spline: Integral<br><br><b>Parametric fit:</b><br>- max_slope.model: Fluorescence increase rate<br>- lambda.model: Lag time<br>- dY.model: Maximum Fluorescence - Minimum Fluorescence<br>- A.model: Maximum fluorescence<br>- integral.model: Integral'
</p>


<h3>Value</h3>

<p>An <code>flFit</code> object that contains all fluorescence fitting results, compatible with
various plotting functions of the QurvE package.
</p>
<table>
<tr><td><code>raw.x</code></td>
<td>
<p>Raw x matrix passed to the function as <code>time</code> (for x_type = 'time') or <code>growth</code> (for x_type = 'growth').</p>
</td></tr>
<tr><td><code>raw.fl</code></td>
<td>
<p>Raw growth dataframe passed to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>flTable</code></td>
<td>
<p>Table with fluorescence parameters and related statistics for each fluorescence curve evaluation performed by the function. This table, which is also returned by the generic <code>summary.flFit</code> method applied to a <code>flFit</code> object, is used as an input for <code><a href="#topic+fl.drFit">fl.drFit</a></code>.</p>
</td></tr>
<tr><td><code>flFittedLinear</code></td>
<td>
<p>List of all <code>flFitLinear</code> objects, generated by the call of <code><a href="#topic+flFitLinear">flFitLinear</a></code>. Note: access to each object in the list via double brace: flFittedLinear[[#n]].</p>
</td></tr>
<tr><td><code>flFittedSplines</code></td>
<td>
<p>List of all <code>flFitSpline</code> objects, generated by the call of <code><a href="#topic+flFitSpline">flFitSpline</a></code>. Note: access to each object via double brace: flFittedSplines[[#n]].</p>
</td></tr>
<tr><td><code>flBootSplines</code></td>
<td>
<p>List of all <code>flBootSpline</code> objects, generated by the call of <code><a href="#topic+flBootSpline">flBootSpline</a></code>. Note: access to each object via double brace: flFittedSplines[[#n]].</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other workflows: 
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>
<p>Other fluorescence fitting functions: 
<code><a href="#topic+flBootSpline">flBootSpline</a>()</code>,
<code><a href="#topic+flFitSpline">flFitSpline</a>()</code>
</p>
<p>Other dose-response analysis functions: 
<code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a>()</code>,
<code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t" )

# Define fit controls
control &lt;- fl.control(fit.opt = "s",
             x_type = "time", norm_fl = TRUE,
             dr.parameter = "max_slope.spline",
             dr.method = "model",
             suppress.messages = TRUE)

# Run curve fitting workflow
res &lt;- flFit(fl_data = input$norm.fluorescence,
             time = input$time,
             control = control,
             parallelize = FALSE)

summary(res)

</code></pre>

<hr>
<h2 id='flFitLinear'>Data fit via a heuristic linear method</h2><span id='topic+flFitLinear'></span>

<h3>Description</h3>

<p>Determine maximum slopes from using a heuristic approach similar to the &ldquo;growth rates made easy&rdquo;-method of
Hall et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flFitLinear(
  time = NULL,
  growth = NULL,
  fl_data,
  ID = "undefined",
  quota = 0.95,
  control = fl.control(x_type = c("growth", "time"), log.x.lin = FALSE, log.y.lin =
    FALSE, t0 = 0, min.growth = NA, lin.h = NULL, lin.R2 = 0.98, lin.RSD = 0.05, lin.dY =
    0.05, biphasic = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flFitLinear_+3A_time">time</code></td>
<td>
<p>Vector of the independent time variable (if x_type = &quot;time&quot; in control object).</p>
</td></tr>
<tr><td><code id="flFitLinear_+3A_growth">growth</code></td>
<td>
<p>Vector of the independent time growth (if x_type = &quot;growth&quot; in control object).</p>
</td></tr>
<tr><td><code id="flFitLinear_+3A_fl_data">fl_data</code></td>
<td>
<p>Vector of the dependent fluorescence variable.</p>
</td></tr>
<tr><td><code id="flFitLinear_+3A_id">ID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="flFitLinear_+3A_quota">quota</code></td>
<td>
<p>(Numeric, between 0 an 1) Define what fraction of <code>max_slope</code> the slope of regression windows adjacent to the window with highest slope should have to be included in the overall linear fit.</p>
</td></tr>
<tr><td><code id="flFitLinear_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gcFitLinear</code> object with parameters of the fit. The lag time is
estimated as the intersection between the fit and the horizontal line with
<code class="reqn">y=y_0</code>, where <code>y0</code> is the first value of the dependent variable.
Use <code><a href="#topic+plot.gcFitSpline">plot.gcFitSpline</a></code> to visualize the linear fit.
</p>
<table>
<tr><td><code>raw.x</code></td>
<td>
<p>Filtered x values used for the spline fit.</p>
</td></tr>
<tr><td><code>raw.fl</code></td>
<td>
<p>Filtered fluorescence values used for the spline fit.</p>
</td></tr>
<tr><td><code>filt.x</code></td>
<td>
<p>Filtered x values.</p>
</td></tr>
<tr><td><code>filt.fl</code></td>
<td>
<p>Filtered fluorescence values.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>FUN</code></td>
<td>
<p>Linear <em>function</em> used for plotting the tangent at mumax.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p><code>lm</code> object; result of the final call of <code><a href="stats.html#topic+lm">lm</a></code> to perform the linear regression.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>List of determined fluorescence parameters:</p>
</td></tr>
</table>

<ul>
<li> <p><code>y0</code>: Minimum fluorescence value considered for the heuristic linear method.
</p>
</li>
<li> <p><code>dY</code>: Difference in maximum fluorescence and minimum fluorescence
</p>
</li>
<li> <p><code>A</code>: Maximum fluorescence
</p>
</li>
<li> <p><code>y0_lm</code>: Intersection of the linear fit with the abscissa.
</p>
</li>
<li> <p><code>max_slope</code>: Maximum slope of the linear fit.
</p>
</li>
<li> <p><code>tD</code>: Doubling time.
</p>
</li>
<li> <p><code>slope.se</code>: Standard error of the maximum slope.
</p>
</li>
<li> <p><code>lag</code>: Lag X.
</p>
</li>
<li> <p><code>x.max_start</code>: X value of the first data point within the window used for the linear regression.
</p>
</li>
<li> <p><code>x.max_end</code>: X value of the last data point within the window used for the linear regression.
</p>
</li>
<li> <p><code>x.turn</code>: For biphasic: X at the inflection point that separates two phases.
</p>
</li>
<li> <p><code>max.slope2</code>: For biphasic: Slope of the second phase.
</p>
</li>
<li> <p><code>tD2</code>: Doubling time of the second phase.
</p>
</li>
<li> <p><code>y0_lm2</code>: For biphasic: Intersection of the linear fit of the second phase with the abscissa.
</p>
</li>
<li> <p><code>lag2</code>: For biphasic: Lag time determined for the second phase..
</p>
</li>
<li> <p><code>x.max2_start</code>: For biphasic: X value of the first data point within the window used for the linear regression of the second phase.
</p>
</li>
<li> <p><code>x.max2_end</code>: For biphasic: X value of the last data point within the window used for the linear regression of the second phase.
</p>
</li></ul>

<table>
<tr><td><code>ndx</code></td>
<td>
<p>Index of data points used for the linear regression.</p>
</td></tr>
<tr><td><code>ndx2</code></td>
<td>
<p>Index of data points used for the linear regression for the second phase.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
<tr><td><code>rsquared</code></td>
<td>
R<sup>2</sup><p> of the linear regression.</p>
</td></tr>
<tr><td><code>rsquared2</code></td>
<td>
R<sup>2</sup><p> of the linear regression for the second phase.</p>
</td></tr>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether linear regression was successfully performed on the data.</p>
</td></tr>
<tr><td><code>fitFlag2</code></td>
<td>
<p>(Logical) Indicates whether a second phase was identified.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hall, BG., Acar, H, Nandipati, A and Barlow, M (2014) Growth Rates Made Easy. Mol. Biol. Evol. 31: 232-38, DOI: 10.1093/molbev/mst187
</p>
<p>Petzoldt T (2022). <em>growthrates: Estimate Growth Rates from Experimental Data</em>. R package version 0.8.3, <a href="https://CRAN.R-project.org/package=growthrates">https://CRAN.R-project.org/package=growthrates</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitLinear(time = time,
                       fl_data = data,
                       ID = "TestFit",
                       control = fl.control(fit.opt = "l", x_type = "time",
                       lin.R2 = 0.95, lin.RSD = 0.1,
                       lin.h = 20))

plot(TestFit)
</code></pre>

<hr>
<h2 id='flFitSpline'>Perform a smooth spline fit on fluorescence data</h2><span id='topic+flFitSpline'></span>

<h3>Description</h3>

<p><code>flFitSpline</code> performs a smooth spline fit on the dataset and determines
the greatest slope as the global maximum in the first derivative of the spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flFitSpline(
  time = NULL,
  growth = NULL,
  fl_data,
  ID = "undefined",
  control = fl.control(biphasic = FALSE, x_type = c("growth", "time"), log.x.spline =
    FALSE, log.y.spline = FALSE, smooth.fl = 0.75, t0 = 0, min.growth = NA)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flFitSpline_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable: time (if <code>x_type = 'time'</code> in <code>fl.control</code> object.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_growth">growth</code></td>
<td>
<p>Vector of the independent variable: growth (if <code>x_type = 'growth'</code> in <code>fl.control</code> object.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_fl_data">fl_data</code></td>
<td>
<p>Vector of dependent variable: fluorescence.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_id">ID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_control">control</code></td>
<td>
<p>A <code>fl.control</code> object created with <code><a href="#topic+fl.control">fl.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+flFitLinear">flFitLinear</a></code> and <code><a href="#topic+flFitSpline">flFitSpline</a></code> try to extract fluorescence parameters for two different phases (as observed with, e.g., regulator-promoter systems with varying response in different growth stages) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_x_type">x_type</code></td>
<td>
<p>(Character) Which data type shall be used as independent variable? Options are <code>'growth'</code> and <code>'time'</code>.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_log.x.spline">log.x.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the independent variable for <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_log.y.spline">log.y.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the fluorescence data for <em>spline</em> fits. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_smooth.fl">smooth.fl</code></td>
<td>
<p>(Numeric) Parameter describing the smoothness of the spline fit; usually (not necessary) within (0;1]. <code>smooth.gc=NULL</code> causes the program to query an optimal value via cross validation techniques. Especially for datasets with few data points the option <code>NULL</code> might cause a too small smoothing parameter. This can result a too tight fit that is susceptible to measurement errors (thus overestimating slopes) or produce an error in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or lead to overfitting. The usage of a fixed value is recommended for reproducible results across samples. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>0.55</code></p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="flFitSpline_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only values above a certain threshold should be considered for linear regressions or spline fits.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>biphasic = TRUE</code>, the following steps are performed to define a
second phase: </p>
 <ol>
<li><p> Determine local minima within the first
derivative of the smooth spline fit. </p>
</li>
<li><p> Remove the 'peak' containing the highest
value of the first derivative (i.e., <code class="reqn">mu_{max}</code>) that is flanked by two local
minima. </p>
</li>
<li><p> Repeat the smooth spline fit and identification of maximum slope for
later time values than the local minimum after <code class="reqn">mu_{max}</code>. </p>
</li>
<li><p> Repeat the
smooth spline fit and identification of maximum slope for earlier time values than
the local minimum before <code class="reqn">mu_{max}</code>. </p>
</li>
<li><p> Choose the greater of the two
independently determined slopes as <code class="reqn">mu_{max}2</code>. </p>
</li></ol>



<h3>Value</h3>

<p>A <code>flFitSpline</code> object. The lag time is estimated as the intersection between the
tangent at the maximum slope and the horizontal line with <code class="reqn">y = y_0</code>, where
<code>y0</code> is the first value of the dependent variable. Use <code><a href="#topic+plot.flFitSpline">plot.flFitSpline</a></code> to
visualize the spline fit and derivative over time.
</p>
<table>
<tr><td><code>x.in</code></td>
<td>
<p>Raw x values provided to the function as <code>time</code> or <code>growth</code>.</p>
</td></tr>
<tr><td><code>fl.in</code></td>
<td>
<p>Raw fluorescence data provided to the function as <code>fl_data</code>.</p>
</td></tr>
<tr><td><code>raw.x</code></td>
<td>
<p>Filtered x values used for the spline fit.</p>
</td></tr>
<tr><td><code>raw.fl</code></td>
<td>
<p>Filtered fluorescence values used for the spline fit.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>fit.x</code></td>
<td>
<p>Fitted x values.</p>
</td></tr>
<tr><td><code>fit.fl</code></td>
<td>
<p>Fitted fluorescence values.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>List of determined parameters.</p>
</td></tr>
</table>

<ul>
<li> <p><code>A</code>: Maximum fluorescence.
</p>
</li>
<li> <p><code>dY</code>: Difference in maximum fluorescence and minimum fluorescence.
</p>
</li>
<li> <p><code>max_slope</code>: Maximum slope of fluorescence-vs.-x data (i.e., maximum in first derivative of the spline).
</p>
</li>
<li> <p><code>x.max</code>: Time at the maximum slope.
</p>
</li>
<li> <p><code>lambda</code>: Lag time.
</p>
</li>
<li> <p><code>b.tangent</code>: Intersection of the tangent at the maximum slope with the abscissa.
</p>
</li>
<li> <p><code>max_slope2</code>: For biphasic course of fluorescence: Maximum slope of fluorescence-vs.-x data of the second phase.
</p>
</li>
<li> <p><code>lambda2</code>: For biphasic course of fluorescence: Lag time determined for the second phase.
</p>
</li>
<li> <p><code>x.max2</code>: For biphasic course of fluorescence: Time at the maximum slope of the second phase.
</p>
</li>
<li> <p><code>b.tangent2</code>: For biphasic course of fluorescence: Intersection of the tangent at the maximum slope of the second phase with the abscissa.
</p>
</li>
<li> <p><code>integral</code>: Area under the curve of the spline fit.
</p>
</li></ul>

<table>
<tr><td><code>spline</code></td>
<td>
<p><code>smooth.spline</code> object generated by the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function.</p>
</td></tr>
<tr><td><code>spline.deriv1</code></td>
<td>
<p>list of time ('x') and growth ('y') values describing the first derivative of the spline fit.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether a spline fit was successfully performed on the data.</p>
</td></tr>
<tr><td><code>fitFlag2</code></td>
<td>
<p>(Logical) Indicates whether a second phase was identified.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>fl.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other fluorescence fitting functions: 
<code><a href="#topic+flBootSpline">flBootSpline</a>()</code>,
<code><a href="#topic+flFit">flFit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitSpline(time = time,
                       fl_data = data,
                       ID = 'TestFit',
                       control = fl.control(fit.opt = 's', x_type = 'time'))

plot(TestFit)
</code></pre>

<hr>
<h2 id='growth.control'>Create a <code>grofit.control</code> object.</h2><span id='topic+growth.control'></span>

<h3>Description</h3>

<p>A <code>grofit.control</code> object is required to perform various computations on growth data stored within <code>grodata</code> objects (created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>). A <code>grofit.control</code> object is created automatically as part of <code><a href="#topic+growth.workflow">growth.workflow</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.control(
  neg.nan.act = FALSE,
  clean.bootstrap = TRUE,
  suppress.messages = FALSE,
  fit.opt = c("a"),
  t0 = 0,
  tmax = NA,
  min.growth = NA,
  max.growth = NA,
  log.x.gc = FALSE,
  log.y.lin = TRUE,
  log.y.spline = TRUE,
  log.y.model = TRUE,
  lin.h = NULL,
  lin.R2 = 0.97,
  lin.RSD = 0.1,
  lin.dY = 0.05,
  biphasic = FALSE,
  interactive = FALSE,
  nboot.gc = 0,
  smooth.gc = 0.55,
  model.type = c("logistic", "richards", "gompertz", "gompertz.exp", "huang", "baranyi"),
  dr.method = c("model", "spline"),
  dr.model = c("gammadr", "multi2", "LL.2", "LL.3", "LL.4", "LL.5", "W1.2", "W1.3",
    "W1.4", "W2.2", "W2.3", "W2.4", "LL.3u", "LL2.2", "LL2.3", "LL2.3u", "LL2.4",
    "LL2.5", "AR.2", "AR.3", "MM.2"),
  dr.have.atleast = 6,
  dr.parameter = c("mu.linfit", "lambda.linfit", "dY.linfit", "A.linfit", "mu.spline",
    "lambda.spline", "dY.spline", "A.spline", "mu.model", "lambda.model",
    "dY.orig.model", "A.orig.model"),
  smooth.dr = NULL,
  log.x.dr = FALSE,
  log.y.dr = FALSE,
  nboot.dr = 0,
  growth.thresh = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.control_+3A_neg.nan.act">neg.nan.act</code></td>
<td>
<p>(Logical) Indicates whether the program should stop when negative growth values or NA values appear (<code>TRUE</code>). Otherwise, the program removes these values silently (<code>FALSE</code>). Improper values may be caused by incorrect data or input errors. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_clean.bootstrap">clean.bootstrap</code></td>
<td>
<p>(Logical) Determines if negative values which occur during bootstrap should be removed (TRUE) or kept (FALSE). Note: Infinite values are always removed. Default: TRUE.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_suppress.messages">suppress.messages</code></td>
<td>
<p>(Logical) Indicates whether messages (information about current growth curve, EC50 values etc.) should be displayed (<code>FALSE</code>) or not (<code>TRUE</code>). This option is meant to speed up the processing of high throughput data. Note: warnings are still displayed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_fit.opt">fit.opt</code></td>
<td>
<p>(Character or character vector) Indicates whether the program should perform a linear regression (<code>'l'</code>), model fit (<code>'m'</code>), spline fit (<code>'s'</code>), or all (<code>'a'</code>). Combinations can be freely chosen by providing a character vector, e.g. <code>fit.opt = c('l', 's')</code> Default:  <code>fit.opt = c('l', 's')</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_tmax">tmax</code></td>
<td>
<p>(Numeric) Maximum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values above a certain threshold should be considered for linear regressions or spline fits.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_max.growth">max.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values below a certain threshold should be considered for linear regressions or spline fits.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.x.gc">log.x.gc</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the time data for <em>linear</em> and <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.y.lin">log.y.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>linear</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.y.spline">log.y.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>spline</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.y.model">log.y.model</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>model</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_lin.h">lin.h</code></td>
<td>
<p>(Numeric) Manually define the size of the sliding window used in <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> If <code>NULL</code>, h is calculated for each samples based on the number of measurements in the growth phase of the plot.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_lin.r2">lin.R2</code></td>
<td>
<p>(Numeric) R<sup>2</sup> threshold for <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_lin.rsd">lin.RSD</code></td>
<td>
<p>(Numeric) Relative standard deviation (RSD) threshold for the calculated slope in <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_lin.dy">lin.dY</code></td>
<td>
<p>(Numeric) Threshold for the minimum fraction of growth increase a linear regression window should cover. Default: 0.05 (5%).</p>
</td></tr>
<tr><td><code id="growth.control_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> and <code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a></code> try to extract growth parameters for two different growth phases (as observed with, e.g., diauxic shifts) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="growth.control_+3A_interactive">interactive</code></td>
<td>
<p>(Logical) Controls whether the fit of each growth curve and method is controlled manually by the user. If <code>TRUE</code>, each fit is visualized in the <em>Plots</em> pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_nboot.gc">nboot.gc</code></td>
<td>
<p>(Numeric) Number of bootstrap samples used for nonparametric growth curve fitting with <code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a></code>. Use <code>nboot.gc = 0</code> to disable the bootstrap. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_smooth.gc">smooth.gc</code></td>
<td>
<p>(Numeric) Parameter describing the smoothness of the spline fit; usually (not necessary) within (0;1]. <code>smooth.gc=NULL</code> causes the program to query an optimal value via cross validation techniques. Especially for datasets with few data points the option <code>NULL</code> might cause a too small smoothing parameter. This can result a too tight fit that is susceptible to measurement errors (thus overestimating growth rates) or produce an error in <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> or lead to overfitting. The usage of a fixed value is recommended for reproducible results across samples. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>0.55</code></p>
</td></tr>
<tr><td><code id="growth.control_+3A_model.type">model.type</code></td>
<td>
<p>(Character) Vector providing the names of the parametric models which should be fitted to the data. Default: <code>c('logistic', 'richards', 'gompertz', 'gompertz.exp', 'huang', 'baranyi')</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Define the method used to perform a dose-responde analysis: smooth spline fit (<code>'spline'</code>) or model fitting (<code>'model'</code>).</p>
</td></tr>
<tr><td><code id="growth.control_+3A_dr.model">dr.model</code></td>
<td>
<p>(Character) Provide a list of models from the R package 'drc' to include in the dose-response analysis (if <code>dr.method = 'model'</code>). If more than one model is provided, the best-fitting model will be chosen based on the Akaike Information Criterion.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_dr.have.atleast">dr.have.atleast</code></td>
<td>
<p>(Numeric) Minimum number of different values for the response parameter one should have for estimating a dose response curve. Note: All fit procedures require at least six unique values. Default: <code>6</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+growth.drFit">growth.drFit</a></code> for further details. Default: <code>'mu.linfit'</code>, which represents the maximum slope of the linear regression. Typical options include: <code>'mu.linfit'</code>, <code>'lambda.linfit'</code>, <code>'dY.linfit'</code>, <code>'mu.spline'</code>, <code>'dY.spline'</code>, <code>'mu.model'</code>, and <code>'A.model'</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_smooth.dr">smooth.dr</code></td>
<td>
<p>(Numeric) Smoothing parameter used in the spline fit by smooth.spline during dose response curve estimation. Usually (not necessesary) in (0; 1]. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.x.dr">log.x.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(x+1)</code> should be applied to the concentration data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_log.y.dr">log.y.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(y+1)</code> should be applied to the response data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_nboot.dr">nboot.dr</code></td>
<td>
<p>(Numeric) Defines the number of bootstrap samples for EC50 estimation. Use <code>nboot.dr = 0</code> to disable bootstrapping. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="growth.control_+3A_growth.thresh">growth.thresh</code></td>
<td>
<p>(Numeric) Define a threshold for growth. Only if any growth value in a sample is greater than <code>growth.thresh</code> (default: 1.5) times the start growth, further computations are performed. Else, a message is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a list with all arguments described above as entries.
</p>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default option
control_default &lt;- growth.control()
# user defined
control_manual &lt;- growth.control(fit.opt = c('s', 'm'),
                                 smooth.gc = 0.5,
                                 model.type = c('huang', 'baranyi'))
</code></pre>

<hr>
<h2 id='growth.drBootSpline'>Perform a smooth spline fit on response vs. concentration data of a single sample</h2><span id='topic+growth.drBootSpline'></span>

<h3>Description</h3>

<p><code>growth.drBootSpline</code> resamples the values in a dataset with replacement and performs a spline fit for each bootstrap sample to determine the EC50.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.drBootSpline(conc, test, drID = "undefined", control = growth.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.drBootSpline_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values.</p>
</td></tr>
<tr><td><code id="growth.drBootSpline_+3A_test">test</code></td>
<td>
<p>Vector of response parameter values of the same length as <code>conc</code>.</p>
</td></tr>
<tr><td><code id="growth.drBootSpline_+3A_drid">drID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="growth.drBootSpline_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>drBootSpline</code> containing a distribution of growth parameters and
a <code>drFitSpline</code> object for each bootstrap sample. Use <code><a href="#topic+plot.drBootSpline">plot.drBootSpline</a></code>
to visualize all bootstrapping splines as well as the distribution of EC50.
</p>
<table>
<tr><td><code>raw.conc</code></td>
<td>
<p>Raw data provided to the function as <code>conc</code>.</p>
</td></tr>
<tr><td><code>raw.test</code></td>
<td>
<p>Raw data for the response parameter provided to the function as <code>test</code>.</p>
</td></tr>
<tr><td><code>drID</code></td>
<td>
<p>(Character) Identifies the tested condition.</p>
</td></tr>
<tr><td><code>boot.conc</code></td>
<td>
<p>Table of concentration values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.test</code></td>
<td>
<p>Table of response values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.drSpline</code></td>
<td>
<p>List containing all <code>drFitSpline</code> objects generated by the call of <code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a></code>.</p>
</td></tr>
<tr><td><code>ec50.boot</code></td>
<td>
<p>Vector of estimated EC50 values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>ec50y.boot</code></td>
<td>
<p>Vector of estimated response at EC50 values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>BootFlag</code></td>
<td>
<p>(Logical) Indicates the success of the bootstrapping operation.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other dose-response analysis functions: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+rnorm(19)/50, 0)

TestRun &lt;- growth.drBootSpline(conc, response, drID = 'test',
               control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8,
                                        nboot.dr = 50))

print(summary(TestRun))
plot(TestRun, combine = TRUE)

</code></pre>

<hr>
<h2 id='growth.drFit'>Perform a dose-response analysis on response vs. concentration data</h2><span id='topic+growth.drFit'></span>

<h3>Description</h3>

<p><code>growth.drFit</code> serves to determine dose-response curves on every condition in a
dataset. The response parameter can be chosen from every physiological parameter in a
<code>gcTable</code> table which is obtained via <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>. <code><a href="#topic+growth.drFit">growth.drFit</a></code>
calls the functions <code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a></code> and <code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a></code>, or <code><a href="#topic+growth.drFitModel">growth.drFitModel</a></code> to
generate a table with estimates for EC50 and respecting statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.drFit(
  gcTable,
  control = growth.control(dr.method = "model", dr.model = c("gammadr", "multi2", "LL.2",
    "LL.3", "LL.4", "LL.5", "W1.2", "W1.3", "W1.4", "W2.2", "W2.3", "W2.4", "LL.3u",
    "LL2.2", "LL2.3", "LL2.3u", "LL2.4", "LL2.5", "AR.2", "AR.3", "MM.2"),
    dr.have.atleast = 6, dr.parameter = "mu.linear", nboot.dr = 0, smooth.dr = NULL,
    log.x.dr = FALSE, log.y.dr = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.drFit_+3A_gctable">gcTable</code></td>
<td>
<p>A dataframe containing the data for the dose-response curve estimation. Such table of class <code>gcTable</code> can be obtained by running <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Define the method used to perform a dose-responde analysis: smooth spline fit (<code>'spline'</code>) or model fitting (<code>'model'</code>).</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_dr.model">dr.model</code></td>
<td>
<p>(Character) Provide a list of models from the R package 'drc' to include in the dose-response analysis (if <code>dr.method = 'model'</code>). If more than one model is provided, the best-fitting model will be chosen based on the Akaike Information Criterion.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_dr.have.atleast">dr.have.atleast</code></td>
<td>
<p>(Numeric) Minimum number of different values for the response parameter one should have for estimating a dose response curve. Note: All fit procedures require at least six unique values. Default: <code>6</code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+growth.drFit">growth.drFit</a></code> for further details. Default: <code>'mu.linfit'</code>, which represents the maximum slope of the linear regression. Typical options include: <code>'mu.linfit'</code>, <code>'lambda.linfit'</code>, <code>'dY.linfit'</code>, <code>'mu.spline'</code>, <code>'dY.spline'</code>, <code>'mu.model'</code>, and <code>'A.model'</code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_smooth.dr">smooth.dr</code></td>
<td>
<p>(Numeric) Smoothing parameter used in the spline fit by smooth.spline during dose response curve estimation. Usually (not necessesary) in (0; 1]. See <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> for further details. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_log.x.dr">log.x.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(x+1)</code> should be applied to the concentration data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_log.y.dr">log.y.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(y+1)</code> should be applied to the response data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.drFit_+3A_nboot.dr">nboot.dr</code></td>
<td>
<p>(Numeric) Defines the number of bootstrap samples for EC50 estimation. Use <code>nboot.dr = 0</code> to disable bootstrapping. Default: <code>0</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common response parameters used in dose-response analysis:<br><br><b>Linear fit:</b><br>- mu.linfit: Growth rate<br>- lambda.linfit: Lag time<br>- dY.linfit: Density increase<br>- A.linfit: Maximum measurement<br><br><b>Spline fit:</b><br>- mu.spline: Growth rate<br>- lambda.spline: Lag time<br>- A.spline: Maximum measurement<br>- dY.spline: Density increase<br>- integral.spline: Integral<br><br><b>Parametric fit:</b><br>- mu.model: Growth rate<br>- lambda.model: Lag time<br>- A.model: Maximum measurement<br>- integral.model: Integral'
</p>


<h3>Value</h3>

<p>An object of class <code>drFit</code>.
</p>
<table>
<tr><td><code>raw.data</code></td>
<td>
<p>Data that passed to the function as <code>gcTable</code>.</p>
</td></tr>
<tr><td><code>drTable</code></td>
<td>
<p>Dataframe containing condition identifiers, fit options, and results of the dose-response analysis.</p>
</td></tr>
<tr><td><code>drBootSplines</code></td>
<td>
<p>List of all <code>drBootSpline</code> objects generated by the call of <code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a></code> for each distinct experiment.</p>
</td></tr>
<tr><td><code>drFittedSplines</code></td>
<td>
<p>List of all <code>drFitSpline</code> objects generated by the call of <code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a></code> for each distinct experiment.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other growth fitting functions: 
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

rnd.data &lt;- list()
rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = 's',
                                                suppress.messages = TRUE))

# Perform dose-response analysis
drFit &lt;- growth.drFit(gcTable = gcFit$gcTable,
             control = growth.control(dr.parameter = 'mu.spline'))

# Inspect results
summary(drFit)
plot(drFit)

</code></pre>

<hr>
<h2 id='growth.drFitModel'>Fit various models to response vs. concentration data of a single sample to determine the EC50.</h2><span id='topic+growth.drFitModel'></span>

<h3>Description</h3>

<p>Fit various models to response vs. concentration data of a single sample to determine the EC50.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.drFitModel(conc, test, drID = "undefined", control = growth.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.drFitModel_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values.</p>
</td></tr>
<tr><td><code id="growth.drFitModel_+3A_test">test</code></td>
<td>
<p>Vector of response parameter values of the same length as <code>conc</code>.</p>
</td></tr>
<tr><td><code id="growth.drFitModel_+3A_drid">drID</code></td>
<td>
<p>(Character) The name of the analyzed condition</p>
</td></tr>
<tr><td><code id="growth.drFitModel_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>drFitModel</code> object.
</p>


<h3>References</h3>

<p>Christian Ritz, Florent Baty, Jens C. Streibig, Daniel Gerhard (2015). <em>Dose-Response Analysis Using R</em>. PLoS ONE 10(12): e0146021. DOI: 10.1371/journal.pone.0146021
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+rnorm(19)/50, 0)

TestRun &lt;- growth.drFitModel(conc, response, drID = 'test')

print(summary(TestRun))
plot(TestRun)
</code></pre>

<hr>
<h2 id='growth.drFitSpline'>Perform a smooth spline fit on response vs. concentration data of a single sample to determine the EC50.</h2><span id='topic+growth.drFitSpline'></span>

<h3>Description</h3>

<p><code>growth.drFitSpline</code> performs a smooth spline fit determines the EC50 as the concentration
at the half-maximum value of the response parameter of the spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.drFitSpline(conc, test, drID = "undefined", control = growth.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.drFitSpline_+3A_conc">conc</code></td>
<td>
<p>Vector of concentration values.</p>
</td></tr>
<tr><td><code id="growth.drFitSpline_+3A_test">test</code></td>
<td>
<p>Vector of response parameter values of the same length as <code>conc</code>.</p>
</td></tr>
<tr><td><code id="growth.drFitSpline_+3A_drid">drID</code></td>
<td>
<p>(Character) The name of the analyzed condition</p>
</td></tr>
<tr><td><code id="growth.drFitSpline_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>During the spline fit with <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, higher weights are
assigned to data points with a concentration value of 0, as well as to x-y pairs with
a response parameter value of 0 and pairs at concentration values before
zero-response parameter values.
</p>


<h3>Value</h3>

<p>A <code>drFitSpline</code> object.
</p>
<table>
<tr><td><code>raw.conc</code></td>
<td>
<p>Raw data provided to the function as <code>conc</code>.</p>
</td></tr>
<tr><td><code>raw.test</code></td>
<td>
<p>Raw data for the response parameter provided to the function as <code>test</code>.</p>
</td></tr>
<tr><td><code>drID</code></td>
<td>
<p>(Character) Identifies the tested condition</p>
</td></tr>
<tr><td><code>fit.conc</code></td>
<td>
<p>Fitted concentration values.</p>
</td></tr>
<tr><td><code>fit.test</code></td>
<td>
<p>Fitted response values.</p>
</td></tr>
<tr><td><code>spline</code></td>
<td>
<p><code>smooth.spline</code> object generated by the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function.</p>
</td></tr>
<tr><td><code>spline.low</code></td>
<td>
<p><code>x</code> and <code>y</code> values of <code><a href="stats.html#topic+lowess">lowess</a></code> spline fit on raw data. Used to call <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>List of parameters estimated from dose response curve fit.</p>
</td></tr>
</table>

<ul>
<li> <p><code>EC50</code>: Concentration at half-maximal response.
</p>
</li>
<li> <p><code>yEC50</code>: Response value related to EC50.
</p>
</li>
<li> <p><code>EC50.orig</code>: EC50 value in original scale, if a transformation was applied.
</p>
</li>
<li> <p><code>yEC50.orig</code>: Response value for EC50 in original scale, if a transformation was applied.
</p>
</li></ul>

<table>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether a spline could fitted successfully to data.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>
<p>Use <code><a href="#topic+plot.drFitSpline">plot.drFitSpline</a></code> to visualize the spline fit.
</p>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>
<p>Christian Ritz, Florent Baty, Jens C. Streibig, Daniel Gerhard (2015). <em>Dose-Response Analysis Using R</em>. PLoS ONE 10(12): e0146021. DOI: 10.1371/journal.pone.0146021
</p>


<h3>See Also</h3>

<p>Other dose-response analysis functions: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+rnorm(19)/50, 0)

TestRun &lt;- growth.drFitSpline(conc, response, drID = 'test',
              control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8))

print(summary(TestRun))

plot(TestRun)
</code></pre>

<hr>
<h2 id='growth.gcBootSpline'>Perform a bootstrap on growth vs. time data followed by spline fits for each resample</h2><span id='topic+growth.gcBootSpline'></span>

<h3>Description</h3>

<p><code>growth.gcBootSpline</code> resamples the growth-time value pairs in a dataset with replacement and performs a spline fit for each bootstrap sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.gcBootSpline(time, data, gcID = "undefined", control = growth.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.gcBootSpline_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable (usually: time).</p>
</td></tr>
<tr><td><code id="growth.gcBootSpline_+3A_data">data</code></td>
<td>
<p>Vector of dependent variable (usually: growth values).</p>
</td></tr>
<tr><td><code id="growth.gcBootSpline_+3A_gcid">gcID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="growth.gcBootSpline_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gcBootSpline</code> object containing a distribution of growth parameters and
a <code>gcFitSpline</code> object for each bootstrap sample. Use <code><a href="#topic+plot.gcBootSpline">plot.gcBootSpline</a></code>
to visualize all bootstrapping splines as well as the distribution of
physiological parameters.
</p>
<table>
<tr><td><code>raw.time</code></td>
<td>
<p>Raw time values provided to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>raw.data</code></td>
<td>
<p>Raw growth data provided to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>gcID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>boot.time</code></td>
<td>
<p>Table of time values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.data</code></td>
<td>
<p>Table of growth values per column, resulting from each spline fit of the bootstrap.</p>
</td></tr>
<tr><td><code>boot.gcSpline</code></td>
<td>
<p>List of <code>gcFitSpline</code> object, created by <code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a></code> for each resample of the bootstrap.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>Vector of estimated lambda (lag time) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>Vector of estimated mu (maximum growth rate) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>Vector of estimated A (maximum growth) values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>integral</code></td>
<td>
<p>Vector of estimated integral values from each bootstrap entry.</p>
</td></tr>
<tr><td><code>bootFlag</code></td>
<td>
<p>(Logical) Indicates the success of the bootstrapping operation.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Introduce some noise into the measurements
data &lt;- data + stats::runif(97, -0.01, 0.09)

# Perform bootstrapping spline fit
TestFit &lt;- growth.gcBootSpline(time, data, gcID = 'TestFit',
              control = growth.control(fit.opt = 's', nboot.gc = 50))

plot(TestFit, combine = TRUE, lwd = 0.5)

</code></pre>

<hr>
<h2 id='growth.gcFit'>Perform a growth curve analysis on all samples in the provided dataset.</h2><span id='topic+growth.gcFit'></span>

<h3>Description</h3>

<p><code>growth.gcFit</code> performs all computational growth fitting operations based on the
user input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.gcFit(time, data, control = growth.control(), parallelize = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.gcFit_+3A_time">time</code></td>
<td>
<p>(optional) A matrix containing time values for each sample.</p>
</td></tr>
<tr><td><code id="growth.gcFit_+3A_data">data</code></td>
<td>
<p>Either... </p>
 <ol>
<li><p> a <code>grodata</code> object created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>,
</p>
</li>
<li><p> a list containing a <code>'time'</code> matrix as well as <code>'growth'</code> and, if appropriate, a <code>'fluorescence'</code> dataframes,
or </p>
</li>
<li><p> a dataframe containing growth values (if a <code>time</code> matrix is provided as separate argument).</p>
</li></ol>
</td></tr>
<tr><td><code id="growth.gcFit_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="growth.gcFit_+3A_parallelize">parallelize</code></td>
<td>
<p>Run linear fits and bootstrapping operations in parallel using all but one available processor cores</p>
</td></tr>
<tr><td><code id="growth.gcFit_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the shiny app.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gcFit</code> object that contains all growth fitting results, compatible with
various plotting functions of the QurvE package.
</p>
<table>
<tr><td><code>raw.time</code></td>
<td>
<p>Raw time matrix passed to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>raw.data</code></td>
<td>
<p>Raw growth dataframe passed to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>gcTable</code></td>
<td>
<p>Table with growth parameters and related statistics for each growth curve evaluation performed by the function. This table, which is also returned by the generic <code>summary.gcFit</code> method applied to a <code>gcFit</code> object, is used as an input for <code><a href="#topic+growth.drFit">growth.drFit</a></code>.</p>
</td></tr>
<tr><td><code>gcFittedLinear</code></td>
<td>
<p>List of all <code>gcFitLinear</code> objects, generated by the call of <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code>. Note: access to each object in the list via double brace: gcFittedLinear[[#n]].</p>
</td></tr>
<tr><td><code>gcFittedModels</code></td>
<td>
<p>List of all <code>gcFitModel</code> objects, generated by the call of <code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a></code>. Note: access to each object in the list via double brace: gcFittedModels[[#n]].</p>
</td></tr>
<tr><td><code>gcFittedSplines</code></td>
<td>
<p>List of all <code>gcFitSpline</code> objects, generated by the call of <code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a></code>. Note: access to each object via double brace: gcFittedSplines[[#n]].</p>
</td></tr>
<tr><td><code>gcBootSplines</code></td>
<td>
<p>List of all <code>gcBootSpline</code> objects, generated by the call of <code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a></code>. Note: access to each object via double brace: gcFittedSplines[[#n]].</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other workflows: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>
<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>
<p>Other dose-response analysis functions: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a>()</code>,
<code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
  rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
  rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

  rnd.data &lt;- list()
  rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
  rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
  res &lt;- growth.gcFit(time = rnd.data$time,
                      data = rnd.data$data,
                      parallelize = FALSE,
                      control = growth.control(suppress.messages = TRUE,
                                               fit.opt = 's'))



</code></pre>

<hr>
<h2 id='growth.gcFitLinear'>Fit an exponential growth model with a heuristic linear method</h2><span id='topic+growth.gcFitLinear'></span>

<h3>Description</h3>

<p>Determine maximum growth rates from the log-linear part of a growth curve using
a heuristic approach similar to the &ldquo;growth rates made easy&rdquo;-method of
Hall et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.gcFitLinear(
  time,
  data,
  gcID = "undefined",
  quota = 0.95,
  control = growth.control(t0 = 0, tmax = NA, log.x.gc = FALSE, log.y.lin = TRUE,
    min.growth = NA, max.growth = NA, lin.h = NULL, lin.R2 = 0.97, lin.RSD = 0.1, lin.dY
    = 0.05, biphasic = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.gcFitLinear_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable (usually: time).</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_data">data</code></td>
<td>
<p>Vector of dependent variable (usually: growth values).</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_gcid">gcID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_quota">quota</code></td>
<td>
<p>(Numeric, between 0 an 1) Define what fraction of <code class="reqn">mu_{max}</code> the slope of regression windows adjacent to the window with highest slope should have to be included in the overall linear fit.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_log.x.gc">log.x.gc</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the time data for <em>linear</em> and <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_log.y.lin">log.y.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>linear</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values above a certain threshold should be considered for linear regressions.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_max.growth">max.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values below a certain threshold should be considered for linear regressions.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_tmax">tmax</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_lin.h">lin.h</code></td>
<td>
<p>(Numeric) Manually define the size of the sliding window . If <code>NULL</code>, h is calculated for each samples based on the number of measurements in the growth phase of the plot.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_lin.r2">lin.R2</code></td>
<td>
<p>(Numeric) R<sup>2</sup> threshold for <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_lin.rsd">lin.RSD</code></td>
<td>
<p>(Numeric) Relative standard deviation (RSD) threshold for calculated slope in <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_lin.dy">lin.dY</code></td>
<td>
<p>(Numeric) Enter the minimum percentage of growth increase that a linear regression should cover.</p>
</td></tr>
<tr><td><code id="growth.gcFitLinear_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> try to extract growth parameters for two different growth phases (as observed with, e.g., diauxic shifts) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works as follows:
</p>

<ol>
<li><p> Fit linear regressions (Theil-Sen estimator) to all subsets of <code>h</code> consecutive, log-transformed data
points (sliding window of size <code>h</code>). If for example <code class="reqn">h=5</code>, fit a linear regression to points
1 ... 5, 2 ... 6, 3 ... 7 and so on.
</p>
</li>
<li><p> Find the subset with the highest slope <code class="reqn">mu_{max}</code>. Do the R<sup>2</sup> and relative standard deviation (RSD) values of the regression meet the in <code>lin.R2</code> and <code>lin.RSD</code> defined thresholds and do the data points within the regression window account for a fraction of at least <code>lin.dY</code> of the total growth increase? If not, evaluate the subset with the second highest slope, and so on.
</p>
</li>
<li><p> Include also the data points of adjacent subsets that have a slope of at least <code class="reqn">quota \cdot mu{max}</code>, e.g., all regression windows that have at least 95% of the maximum slope.
</p>
</li>
<li><p> Fit a new linear model to the extended data window identified in step 3.
</p>
</li></ol>

<p>If <code>biphasic = TRUE</code>, the following steps are performed to define a second growth phase:
</p>

<ol>
<li><p> Perform a smooth spline fit on the data with a smoothing factor of 0.5.
</p>
</li>
<li><p> Calculate the second derivative of the spline fit and perform a smooth spline fit of the derivative with a smoothing factor of 0.4.
</p>
</li>
<li><p> Determine local maxima and minima in the second derivative.
</p>
</li>
<li><p> Find the local minimum following <code class="reqn">mu_{max}</code> and repeat the heuristic linear method for later time values.
</p>
</li>
<li><p> Find the local maximum before <code class="reqn">mu_{max}</code> and repeat the heuristic linear method for earlier time values.
</p>
</li>
<li><p> Choose the greater of the two independently determined slopes as <code class="reqn">mu_{max}2</code>.
</p>
</li></ol>



<h3>Value</h3>

<p>A <code>gcFitLinear</code> object with parameters of the fit. The lag time is
estimated as the intersection between the fit and the horizontal line with
<code class="reqn">y=y_0</code>, where <code>y0</code> is the first value of the dependent variable.
Use <code><a href="#topic+plot.gcFitSpline">plot.gcFitSpline</a></code> to visualize the linear fit.
</p>
<table>
<tr><td><code>raw.time</code></td>
<td>
<p>Raw time values provided to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>raw.data</code></td>
<td>
<p>Raw growth data provided to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>filt.time</code></td>
<td>
<p>Filtered time values used for the heuristic linear method.</p>
</td></tr>
<tr><td><code>filt.data</code></td>
<td>
<p>Filtered growth values.</p>
</td></tr>
<tr><td><code>log.data</code></td>
<td>
<p>Log-transformed, filtered growth values used for the heuristic linear method.</p>
</td></tr>
<tr><td><code>gcID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>FUN</code></td>
<td>
<p>Linear <em>function</em> used for plotting the tangent at mumax.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p><code>lm</code> object; result of the final call of <code><a href="stats.html#topic+lm">lm</a></code> to perform the linear regression.</p>
</td></tr>
<tr><td><code>par</code></td>
<td>
<p>List of determined growth parameters:</p>
</td></tr>
</table>

<ul>
<li> <p><code>y0</code>: Minimum growth value considered for the heuristic linear method.
</p>
</li>
<li> <p><code>dY</code>: Difference in maximum growth and minimum growth.
</p>
</li>
<li> <p><code>A</code>: Maximum growth.
</p>
</li>
<li> <p><code>y0_lm</code>: Intersection of the linear fit with the abscissa.
</p>
</li>
<li> <p><code>mumax</code>: Maximum growth rate (i.e., slope of the linear fit).
</p>
</li>
<li> <p><code>tD</code>: Doubling time.
</p>
</li>
<li> <p><code>mu.se</code>: Standard error of the maximum growth rate.
</p>
</li>
<li> <p><code>lag</code>: Lag time.
</p>
</li>
<li> <p><code>tmax_start</code>: Time value of the first data point within the window used for the linear regression.
</p>
</li>
<li> <p><code>tmax_end</code>: Time value of the last data point within the window used for the linear regression.
</p>
</li>
<li> <p><code>t_turn</code>: For biphasic growth: Time of the inflection point that separates two growth phases.
</p>
</li>
<li> <p><code>mumax2</code>: For biphasic growth: Growth rate of the second growth phase.
</p>
</li>
<li> <p><code>tD2</code>: Doubling time of the second growth phase.
</p>
</li>
<li> <p><code>y0_lm2</code>: For biphasic growth: Intersection of the linear fit of the second growth phase with the abscissa.
</p>
</li>
<li> <p><code>lag2</code>: For biphasic growth: Lag time determined for the second growth phase..
</p>
</li>
<li> <p><code>tmax2_start</code>: For biphasic growth: Time value of the first data point within the window used for the linear regression of the second growth phase.
</p>
</li>
<li> <p><code>tmax2_end</code>: For biphasic growth: Time value of the last data point within the window used for the linear regression of the second growth phase.
</p>
</li></ul>

<table>
<tr><td><code>ndx</code></td>
<td>
<p>Index of data points used for the linear regression.</p>
</td></tr>
<tr><td><code>ndx2</code></td>
<td>
<p>Index of data points used for the linear regression for the second growth phase.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
<tr><td><code>rsquared</code></td>
<td>
R<sup>2</sup><p> of the linear regression.</p>
</td></tr>
<tr><td><code>rsquared2</code></td>
<td>
R<sup>2</sup><p> of the linear regression for the second growth phase.</p>
</td></tr>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether linear regression was successfully performed on the data.</p>
</td></tr>
<tr><td><code>fitFlag2</code></td>
<td>
<p>(Logical) Indicates whether a second growth phase was identified.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hall, BG., Acar, H, Nandipati, A and Barlow, M (2014) Growth Rates Made Easy. <em>Mol. Biol. Evol.</em> 31: 232-38, DOI: 10.1093/molbev/mst187
</p>
<p>Petzoldt T (2022). growthrates: Estimate Growth Rates from Experimental Data. R package version 0.8.3, <a href="https://CRAN.R-project.org/package=growthrates">https://CRAN.R-project.org/package=growthrates</a>.
</p>
<p>Theil, H.(1992). A rank-invariant method of linear and polynomial regression analysis. In: Henri Theil’s contributions to economics and econometrics. Springer, pp. 345–381. DOI: 10.1007/978-94-011-2546-8_20
</p>


<h3>See Also</h3>

<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- growth.gcFitLinear(time, data, gcID = "TestFit",
                 control = growth.control(fit.opt = "l"))

plot(TestFit)

</code></pre>

<hr>
<h2 id='growth.gcFitModel'>Fit nonlinear growth models to growth data</h2><span id='topic+growth.gcFitModel'></span>

<h3>Description</h3>

<p><code>growth.gcFitModel</code> determines a parametric growth model that best describes the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.gcFitModel(time, data, gcID = "undefined", control = growth.control())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.gcFitModel_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable (usually time).</p>
</td></tr>
<tr><td><code id="growth.gcFitModel_+3A_data">data</code></td>
<td>
<p>Vector of dependent variable (usually growth values).</p>
</td></tr>
<tr><td><code id="growth.gcFitModel_+3A_gcid">gcID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="growth.gcFitModel_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>, defining relevant fitting options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>gcFitModel</code> object that contains physiological parameters and information about the best fit. Use <code><a href="#topic+plot.gcFitModel">plot.gcFitModel</a></code> to visualize the parametric fit and growth equation.
</p>
<table>
<tr><td><code>raw.time</code></td>
<td>
<p>Raw time values provided to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>raw.data</code></td>
<td>
<p>Raw growth data provided to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>gcID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>fit.time</code></td>
<td>
<p>Fitted time values.</p>
</td></tr>
<tr><td><code>fit.data</code></td>
<td>
<p>Fitted growth values.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>List of determined growth parameters.</p>
</td></tr>
</table>

<ul>
<li> <p><code>A</code>: Maximum growth.
</p>
</li>
<li> <p><code>dY</code>: Difference in maximum growth and minimum growth of the fitted model.
</p>
</li>
<li> <p><code>mu</code>: Maximum growth rate (i.e., maximum in first derivative of the spline).
</p>
</li>
<li> <p><code>lambda</code>: Lag time.
</p>
</li>
<li> <p><code>b.tangent</code>: Intersection of the tangent at the maximum growth rate with the abscissa.
</p>
</li>
<li> <p><code>fitpar</code>: For some models: list of additional parameters used in the equations describing the growth curve.
</p>
</li>
<li> <p><code>integral</code>: Area under the curve of the parametric fit.
</p>
</li></ul>

<table>
<tr><td><code>model</code></td>
<td>
<p>(Character) The model that obtained the fit with the lowest AIC, determined by <code><a href="stats.html#topic+AIC">AIC</a></code>.</p>
</td></tr>
<tr><td><code>nls</code></td>
<td>
<p><code>nls</code> object for the chosen model generated by the <code><a href="stats.html#topic+nls">nls</a></code> function.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether a parametric model was successfully fitted on the data.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform parametric fit
TestFit &lt;- growth.gcFitModel(time, data, gcID = 'TestFit',
                 control = growth.control(fit.opt = 'm'))

plot(TestFit, basesize = 18, eq.size = 1.5)

</code></pre>

<hr>
<h2 id='growth.gcFitSpline'>Perform a smooth spline fit on growth data</h2><span id='topic+growth.gcFitSpline'></span>

<h3>Description</h3>

<p><code>growth.gcFitSpline</code> performs a smooth spline fit on the dataset and determines
the highest growth rate as the global maximum in the first derivative of the spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.gcFitSpline(
  time,
  data,
  gcID = "undefined",
  control = growth.control(biphasic = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.gcFitSpline_+3A_time">time</code></td>
<td>
<p>Vector of the independent variable (usually time).</p>
</td></tr>
<tr><td><code id="growth.gcFitSpline_+3A_data">data</code></td>
<td>
<p>Vector of dependent variable (usually: growth values).</p>
</td></tr>
<tr><td><code id="growth.gcFitSpline_+3A_gcid">gcID</code></td>
<td>
<p>(Character) The name of the analyzed sample.</p>
</td></tr>
<tr><td><code id="growth.gcFitSpline_+3A_control">control</code></td>
<td>
<p>A <code>grofit.control</code> object created with <code><a href="#topic+growth.control">growth.control</a></code>,
defining relevant fitting options.</p>
</td></tr>
<tr><td><code id="growth.gcFitSpline_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code>growth.gcFitSpline</code> try to extract growth
parameters for two different growth phases (as observed with, e.g., diauxic shifts)
(<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>biphasic = TRUE</code>, the following steps are performed to define a
second growth phase: </p>
 <ol>
<li><p> Determine local minima within the first
derivative of the smooth spline fit. </p>
</li>
<li><p> Remove the 'peak' containing the highest
value of the first derivative (i.e., <code class="reqn">mu_{max}</code>) that is flanked by two local
minima. </p>
</li>
<li><p> Repeat the smooth spline fit and identification of maximum slope for
later time values than the local minimum after <code class="reqn">mu_{max}</code>. </p>
</li>
<li><p> Repeat the
smooth spline fit and identification of maximum slope for earlier time values than
the local minimum before <code class="reqn">mu_{max}</code>. </p>
</li>
<li><p> Choose the greater of the two
independently determined slopes as <code class="reqn">mu_{max}2</code>. </p>
</li></ol>



<h3>Value</h3>

<p>A <code>gcFitSpline</code> object. The lag time is estimated as the intersection between the
tangent at the maximum slope and the horizontal line with <code class="reqn">y = y_0</code>, where
<code>y0</code> is the first value of the dependent variable. Use <code><a href="#topic+plot.gcFitSpline">plot.gcFitSpline</a></code> to
visualize the spline fit and derivative over time.
</p>
<table>
<tr><td><code>time.in</code></td>
<td>
<p>Raw time values provided to the function as <code>time</code>.</p>
</td></tr>
<tr><td><code>data.in</code></td>
<td>
<p>Raw growth data provided to the function as <code>data</code>.</p>
</td></tr>
<tr><td><code>raw.time</code></td>
<td>
<p>Filtered time values used for the spline fit.</p>
</td></tr>
<tr><td><code>raw.data</code></td>
<td>
<p>Filtered growth values used for the spline fit.</p>
</td></tr>
<tr><td><code>gcID</code></td>
<td>
<p>(Character) Identifies the tested sample.</p>
</td></tr>
<tr><td><code>fit.time</code></td>
<td>
<p>Fitted time values.</p>
</td></tr>
<tr><td><code>fit.data</code></td>
<td>
<p>Fitted growth values.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>List of determined growth parameters.</p>
</td></tr>
</table>

<ul>
<li> <p><code>A</code>: Maximum growth.
</p>
</li>
<li> <p><code>dY</code>: Difference in maximum growth and minimum growth.
</p>
</li>
<li> <p><code>mu</code>: Maximum growth rate (i.e., maximum in first derivative of the spline).
</p>
</li>
<li> <p><code>tD</code>: Doubling time.
</p>
</li>
<li> <p><code>t.max</code>: Time at the maximum growth rate.
</p>
</li>
<li> <p><code>lambda</code>: Lag time.
</p>
</li>
<li> <p><code>b.tangent</code>: Intersection of the tangent at the maximum growth rate with the abscissa.
</p>
</li>
<li> <p><code>mu2</code>: For biphasic growth: Growth rate of the second growth phase.
</p>
</li>
<li> <p><code>tD2</code>: Doubling time of the second growth phase.
</p>
</li>
<li> <p><code>lambda2</code>: For biphasic growth: Lag time determined for the second growth phase.
</p>
</li>
<li> <p><code>t.max2</code>: For biphasic growth: Time at the maximum growth rate of the second growth phase.
</p>
</li>
<li> <p><code>b.tangent2</code>: For biphasic growth: Intersection of the tangent at the maximum growth rate of the second growth phase with the abscissa.
</p>
</li>
<li> <p><code>integral</code>: Area under the curve of the spline fit.
</p>
</li></ul>

<table>
<tr><td><code>spline</code></td>
<td>
<p><code>smooth.spline</code> object generated by the <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code> function.</p>
</td></tr>
<tr><td><code>spline.deriv1</code></td>
<td>
<p>list of time ('x') and growth ('y') values describing the first derivative of the spline fit.</p>
</td></tr>
<tr><td><code>reliable</code></td>
<td>
<p>(Logical) Indicates whether the performed fit is reliable (to be set manually).</p>
</td></tr>
<tr><td><code>fitFlag</code></td>
<td>
<p>(Logical) Indicates whether a spline fit was successfully performed on the data.</p>
</td></tr>
<tr><td><code>fitFlag2</code></td>
<td>
<p>(Logical) Indicates whether a second growth phase was identified.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> containing list of options passed to the function as <code>control</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>See Also</h3>

<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>,
<code><a href="#topic+growth.workflow">growth.workflow</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform spline fit
TestFit &lt;- growth.gcFitSpline(time, data, gcID = 'TestFit',
                 control = growth.control(fit.opt = 's'))

plot(TestFit)


</code></pre>

<hr>
<h2 id='growth.report'>Create a PDF and HTML report with results from a growth curve analysis workflow</h2><span id='topic+growth.report'></span>

<h3>Description</h3>

<p><code>growth.report</code> requires a <code>grofit</code> object and creates a report in PDF and HTML format that summarizes all results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.report(
  grofit,
  out.dir = tempdir(),
  out.nm = NULL,
  ec50 = FALSE,
  format = c("pdf", "html"),
  export = FALSE,
  parallelize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.report_+3A_grofit">grofit</code></td>
<td>
<p>A <code>grofit</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code>.</p>
</td></tr>
<tr><td><code id="growth.report_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) The path or name of the folder in which the report files are created.  If <code>NULL</code>, the folder will be named with a combination of 'Report.growth_' and the current date and time.</p>
</td></tr>
<tr><td><code id="growth.report_+3A_out.nm">out.nm</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of the report files. If <code>NULL</code>, the files will be named with a combination of 'GrowthReport_' and the current date and time.</p>
</td></tr>
<tr><td><code id="growth.report_+3A_ec50">ec50</code></td>
<td>
<p>(Logical) Display results of dose-response analysis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="growth.report_+3A_format">format</code></td>
<td>
<p>(Character) Define the file format for the report, PDF (<code>'pdf'</code>) and/or HTML (<code>'html'</code>). Default: (<code>c('pdf', 'html')</code>)</p>
</td></tr>
<tr><td><code id="growth.report_+3A_export">export</code></td>
<td>
<p>(Logical) Shall all plots generated in the report be exported as individual PDF and PNG files <code>TRUE</code> or not <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="growth.report_+3A_parallelize">parallelize</code></td>
<td>
<p>(Logical) Create plots using all but one available processor cores (<code>TRUE</code>) or only a single core (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="growth.report_+3A_...">...</code></td>
<td>
<p>Further arguments passed to create a report. Currently supported:
</p>

<ul>
<li> <p><code>mean.grp</code>: Define groups to combine into common plots in the report based on sample identifiers. Partial matches with sample/group names are accepted. Can be <code>'all'</code>, a string vector, or a list of string vectors. Note: The maximum number of sample groups (with unique condition/concentration indicators) is 50. If you have more than 50 groups, option <code>'all'</code> will produce the error <code>! Insufficient values in manual scale. [Number] needed but only 50 provided</code>.
</p>
</li>
<li> <p><code>mean.conc</code>: Define concentrations to combine into common plots in the  report. Can be a numeric vector, or a list of numeric vectors.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The template .Rmd file used within this function can be found within the QurvE package installation directory.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Create random growth data set
  rnd.data &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')


  # Run growth curve analysis workflow
  res &lt;- growth.workflow(time = rnd.data$time,
                         data = rnd.data$data,
                         fit.opt = 's',
                         ec50 = FALSE,
                         export.res = FALSE,
                         suppress.messages = TRUE,
                         parallelize = FALSE)

  growth.report(res, out.dir = tempdir(), parallelize = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='growth.workflow'>Run a complete growth curve analysis and dose-reponse analysis workflow.</h2><span id='topic+growth.workflow'></span>

<h3>Description</h3>

<p><code>growth.workflow</code> runs <code><a href="#topic+growth.control">growth.control</a></code> to create a <code>grofit.control</code> object and then performs all computational fitting operations based on the user input. Finally, if desired, a final report is created in PDF or HTML format that summarizes all results obtained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth.workflow(
  grodata = NULL,
  time = NULL,
  data = NULL,
  ec50 = TRUE,
  mean.grp = NA,
  mean.conc = NA,
  neg.nan.act = FALSE,
  clean.bootstrap = TRUE,
  suppress.messages = FALSE,
  fit.opt = c("a"),
  t0 = 0,
  tmax = NA,
  min.growth = NA,
  max.growth = NA,
  log.x.gc = FALSE,
  log.y.lin = TRUE,
  log.y.spline = TRUE,
  log.y.model = TRUE,
  biphasic = FALSE,
  lin.h = NULL,
  lin.R2 = 0.97,
  lin.RSD = 0.1,
  lin.dY = 0.05,
  interactive = FALSE,
  nboot.gc = 0,
  smooth.gc = 0.55,
  model.type = c("logistic", "richards", "gompertz", "gompertz.exp", "huang", "baranyi"),
  dr.method = c("model", "spline"),
  dr.model = c("gammadr", "multi2", "LL.2", "LL.3", "LL.4", "LL.5", "W1.2", "W1.3",
    "W1.4", "W2.2", "W2.3", "W2.4", "LL.3u", "LL2.2", "LL2.3", "LL2.3u", "LL2.4",
    "LL2.5", "AR.2", "AR.3", "MM.2"),
  growth.thresh = 1.5,
  dr.have.atleast = 6,
  dr.parameter = c("mu.linfit", "lambda.linfit", "dY.linfit", "A.linfit", "mu.spline",
    "lambda.spline", "dY.spline", "A.spline", "mu.model", "lambda.model",
    "dY.orig.model", "A.orig.model"),
  smooth.dr = 0.1,
  log.x.dr = FALSE,
  log.y.dr = FALSE,
  nboot.dr = 0,
  report = NULL,
  out.dir = NULL,
  out.nm = NULL,
  export.fig = FALSE,
  export.res = FALSE,
  parallelize = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth.workflow_+3A_grodata">grodata</code></td>
<td>
<p>A <code>grodata</code> object created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>, or a list containing a <code>'time'</code> matrix as well as a <code>'growth'</code> dataframe.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_time">time</code></td>
<td>
<p>(optional) A matrix containing time values for each sample.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_data">data</code></td>
<td>
<p>(optional) A dataframe containing growth data (if a <code>time</code> matrix is provided as separate argument).</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_ec50">ec50</code></td>
<td>
<p>(Logical) Perform dose-response analysis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_mean.grp">mean.grp</code></td>
<td>
<p>(<code>'all'</code>, a string vector, or a list of string vectors) Define groups to combine into common plots in the final report based on sample identifiers (if <code>report == TRUE</code>). Partial matches with sample/group names are accepted. Note: The maximum number of sample groups (with unique condition/concentration indicators) is 50. If you have more than 50 groups, option <code>'all'</code> will produce the error <code>! Insufficient values in manual scale. [Number] needed but only 50 provided</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_mean.conc">mean.conc</code></td>
<td>
<p>(A numeric vector, or a list of numeric vectors) Define concentrations to combine into common plots in the final report (if <code>report == TRUE</code>).</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_neg.nan.act">neg.nan.act</code></td>
<td>
<p>(Logical) Indicates whether the program should stop when negative growth values or NA values appear (<code>TRUE</code>). Otherwise, the program removes these values silently (<code>FALSE</code>). Improper values may be caused by incorrect data or input errors. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_clean.bootstrap">clean.bootstrap</code></td>
<td>
<p>(Logical) Determines if negative values which occur during bootstrap should be removed (TRUE) or kept (FALSE). Note: Infinite values are always removed. Default: TRUE.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_suppress.messages">suppress.messages</code></td>
<td>
<p>(Logical) Indicates whether grofit messages (information about current growth curve, EC50 values etc.) should be displayed (<code>FALSE</code>) or not (<code>TRUE</code>). This option is meant to speed up the high-throughput processing data. Note: warnings are still displayed. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_fit.opt">fit.opt</code></td>
<td>
<p>(Character or character vector) Indicates whether the program should perform a linear regression (<code>'l'</code>), model fit (<code>'m'</code>), spline fit (<code>'s'</code>), or all (<code>'a'</code>). Combinations can be freely chosen by providing a character vector, e.g. <code>fit.opt = c('l', 's')</code> Default:  <code>fit.opt = c('l', 's')</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_t0">t0</code></td>
<td>
<p>(Numeric) Minimum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_tmax">tmax</code></td>
<td>
<p>(Numeric) Maximum time value considered for linear and spline fits.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_min.growth">min.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values above a certain threshold should be considered for linear regressions or spline fits.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_max.growth">max.growth</code></td>
<td>
<p>(Numeric) Indicate whether only growth values below a certain threshold should be considered for linear regressions or spline fits.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.x.gc">log.x.gc</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(x+1)</em> should be applied to the time data for <em>linear</em> and <em>spline</em> fits. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.y.lin">log.y.lin</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>linear</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.y.spline">log.y.spline</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>spline</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.y.model">log.y.model</code></td>
<td>
<p>(Logical) Indicates whether <em>ln(y/y0)</em> should be applied to the growth data for <em>model</em> fits. Default: <code>TRUE</code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_biphasic">biphasic</code></td>
<td>
<p>(Logical) Shall <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> and <code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a></code> try to extract growth parameters for two different growth phases (as observed with, e.g., diauxic shifts) (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_lin.h">lin.h</code></td>
<td>
<p>(Numeric) Manually define the size of the sliding window used in <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> If <code>NULL</code>, h is calculated for each samples based on the number of measurements in the growth phase of the plot.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_lin.r2">lin.R2</code></td>
<td>
<p>(Numeric) R<sup>2</sup> threshold for <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_lin.rsd">lin.RSD</code></td>
<td>
<p>(Numeric) Relative standard deviation (RSD) threshold for calculated slope in <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_lin.dy">lin.dY</code></td>
<td>
<p>(Numeric) Threshold for the minimum fraction of growth increase a linear regression window should cover. Default: 0.05 (5%).</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_interactive">interactive</code></td>
<td>
<p>(Logical) Controls whether the fit of each growth curve and method is controlled manually by the user. If <code>TRUE</code>, each fit is visualized in the <em>Plots</em> pane and the user can adjust fitting parameters and confirm the reliability of each fit per sample. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_nboot.gc">nboot.gc</code></td>
<td>
<p>(Numeric) Number of bootstrap samples used for nonparametric growth curve fitting with <code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a></code>. Use <code>nboot.gc = 0</code> to disable the bootstrap. Default: <code>0</code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_smooth.gc">smooth.gc</code></td>
<td>
<p>(Numeric) Parameter describing the smoothness of the spline fit; usually (not necessary) within (0;1]. <code>smooth.gc=NULL</code> causes the program to query an optimal value via cross validation techniques. Especially for datasets with few data points the option NULL might cause a too small smoothing parameter. This can result a too tight fit that is susceptible to measurement errors (thus overestimating growth rates) or produce an error in <code>smooth.spline</code> or lead to an overestimation. The usage of a fixed value is recommended for reproducible results across samples. See <code>?smooth.spline</code> for further details. Default: <code>0.55</code></p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_model.type">model.type</code></td>
<td>
<p>(Character) Vector providing the names of the parametric models which should be fitted to the data. Default: <code>c('logistic', 'richards', 'gompertz', 'gompertz.exp', 'huang', 'baranyi')</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_dr.method">dr.method</code></td>
<td>
<p>(Character) Define the method used to perform a dose-responde analysis: smooth spline fit (<code>'spline'</code>) or model fitting (<code>'model'</code>).</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_dr.model">dr.model</code></td>
<td>
<p>(Character) Provide a list of models from the R package 'drc' to include in the dose-response analysis (if <code>dr.method = 'model'</code>). If more than one model is provided, the best-fitting model will be chosen based on the Akaike Information Criterion.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_growth.thresh">growth.thresh</code></td>
<td>
<p>(Numeric) Define a threshold for growth. Only if any growth value in a sample is greater than <code>growth.thresh</code> (default: 1.5) times the start growth, further computations are performed. Else, a message is returned.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_dr.have.atleast">dr.have.atleast</code></td>
<td>
<p>(Numeric) Minimum number of different values for the response parameter one should have for estimating a dose response curve. Note: All fit procedures require at least six unique values. Default: <code>6</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_dr.parameter">dr.parameter</code></td>
<td>
<p>(Character or numeric) The response parameter in the output table to be used for creating a dose response curve. See <code><a href="#topic+growth.drFit">growth.drFit</a></code> for further details. Default: <code>'mu.linfit'</code>, which represents the maximum slope of the linear regression. Typical options include: <code>'mu.linfit'</code>, <code>'lambda.linfit'</code>, <code>'dY.linfit'</code>, <code>'mu.spline'</code>, <code>'dY.spline'</code>, <code>'mu.model'</code>, and <code>'A.model'</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_smooth.dr">smooth.dr</code></td>
<td>
<p>(Numeric) Smoothing parameter used in the spline fit by smooth.spline during dose response curve estimation. Usually (not necessesary) in (0; 1]. See documentation of smooth.spline for further details. Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.x.dr">log.x.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(x+1)</code> should be applied to the concentration data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_log.y.dr">log.y.dr</code></td>
<td>
<p>(Logical) Indicates whether <code>ln(y+1)</code> should be applied to the response data of the dose response curves. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_nboot.dr">nboot.dr</code></td>
<td>
<p>(Numeric) Defines the number of bootstrap samples for EC50 estimation. Use <code>nboot.dr = 0</code> to disable bootstrapping. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_report">report</code></td>
<td>
<p>(Character or NULL) Create a PDF (<code>'pdf'</code>) and/or HTML (<code>'html'</code>) report after running all computations. Define <code>NULL</code> if no report should be created. Default: (<code>c('pdf', 'html')</code>)</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_out.dir">out.dir</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of a folder in which all result files are stored. If <code>NULL</code>, the folder will be named with a combination of 'GrowthResults_' and the current date and time.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_out.nm">out.nm</code></td>
<td>
<p>Character or <code>NULL</code> Define the name of the report files. If <code>NULL</code>, the files will be named with a combination of 'GrowthReport_' and the current date and time.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_export.fig">export.fig</code></td>
<td>
<p>(Logical) Export all figures created in the report as separate PNG and PDF files (<code>TRUE</code>) or not (<code>FALSE</code>). Only effective if <code>report != NULL</code>.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_export.res">export.res</code></td>
<td>
<p>(Logical) Create tab-separated TXT files containing calculated growth parameters and dose-response analysis results as well as an .RData file for the resulting <code>grofit</code> object.</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_parallelize">parallelize</code></td>
<td>
<p>Run linear fits and bootstrapping operations in parallel using all but one available processor cores</p>
</td></tr>
<tr><td><code id="growth.workflow_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the shiny app.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Common response parameters used in dose-response analysis:<br><br><b>Linear fit:</b><br>- mu.linfit: Growth rate<br>- lambda.linfit: Lag time<br>- dY.linfit: Density increase<br>- A.linfit: Maximum measurement<br><br><b>Spline fit:</b><br>- mu.spline: Growth rate<br>- lambda.spline: Lag time<br>- A.spline: Maximum measurement<br>- dY.spline: Density increase<br>- integral.spline: Integral<br><br><b>Parametric fit:</b><br>- mu.model: Growth rate<br>- lambda.model: Lag time<br>- A.model: Maximum measurement<br>- integral.model: Integral'
</p>


<h3>Value</h3>

<p>A <code>grofit</code> object that contains all computation results, compatible with various plotting functions of the QurvE package and with <code><a href="#topic+growth.report">growth.report</a></code>.
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Raw time matrix passed to the function as <code>time</code> (if no <code>grofit</code> object is provided).</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Raw growth dataframe passed to the function as <code>data</code> (if no <code>grofit</code> object is provided).</p>
</td></tr>
<tr><td><code>gcFit</code></td>
<td>
<p><code>gcFit</code> object created with the call of <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>.</p>
</td></tr>
<tr><td><code>drFit</code></td>
<td>
<p><code>drFit</code> object created with the call of <code><a href="#topic+growth.drFit">growth.drFit</a></code>.</p>
</td></tr>
<tr><td><code>expdesign</code></td>
<td>
<p>Experimental design table inherited from <code>grodata</code> or created from the identifier columns (columns 1-3) in <code>data</code>.</p>
</td></tr>
<tr><td><code>control</code></td>
<td>
<p>Object of class <code>grofit.control</code> created with the call of <code><a href="#topic+growth.control">growth.control</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other workflows: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>
</p>
<p>Other growth fitting functions: 
<code><a href="#topic+growth.drFit">growth.drFit</a>()</code>,
<code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a>()</code>,
<code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a>()</code>,
<code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a>()</code>,
<code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>
</p>
<p>Other dose-response analysis functions: 
<code><a href="#topic+flFit">flFit</a>()</code>,
<code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a>()</code>,
<code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a>()</code>,
<code><a href="#topic+growth.gcFit">growth.gcFit</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
  rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
  rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

  rnd.data &lt;- list()
  rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
  rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

  # Run growth curve analysis workflow
  res &lt;- growth.workflow(time = rnd.data$time,
                         data = rnd.data$data,
                         fit.opt = 's',
                         ec50 = FALSE,
                         export.res = FALSE,
                         suppress.messages = TRUE,
                         parallelize = FALSE)

# Load custom dataset
  input &lt;- read_data(data.growth = system.file('2-FMA_toxicity.csv', package = 'QurvE'))

  res &lt;- growth.workflow(grodata = input,
                         fit.opt = 's',
                         ec50 = TRUE,
                         export.res = FALSE,
                         suppress.messages = TRUE,
                         parallelize = FALSE)

  plot(res)

</code></pre>

<hr>
<h2 id='inflect'>Find indices of maxima an minima in a data series</h2><span id='topic+inflect'></span>

<h3>Description</h3>

<p>Find indices of maxima an minima in a data series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflect(x, threshold = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inflect_+3A_x">x</code></td>
<td>
<p>vector of values with minima and maxima</p>
</td></tr>
<tr><td><code id="inflect_+3A_threshold">threshold</code></td>
<td>
<p>Threshold to consider minima or maxima</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with 1. a vector of minima and 2. a vector of maxima.
</p>


<h3>Author(s)</h3>

<p>Evan Friedland
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pick a desired threshold to plot up to
n &lt;- 3
# Generate Data
randomwalk &lt;- 100 + cumsum(rnorm(50, 0.2, 1)) # climbs upwards most of the time
bottoms &lt;- lapply(1:n, function(x) inflect(randomwalk, threshold = x)$minima)
tops &lt;- lapply(1:n, function(x) inflect(randomwalk, threshold = x)$maxima)
# Color functions
cf.1 &lt;- grDevices::colorRampPalette(c('pink','red'))
cf.2 &lt;- grDevices::colorRampPalette(c('cyan','blue'))
plot(randomwalk, type = 'l', main = 'Minima &amp; Maxima\nVariable Thresholds')
for(i in 1:n){
  points(bottoms[[i]], randomwalk[bottoms[[i]]], pch = 16, col = cf.1(n)[i], cex = i/1.5)
}
for(i in 1:n){
  points(tops[[i]], randomwalk[tops[[i]]], pch = 16, col = cf.2(n)[i], cex = i/1.5)
}
legend('topleft', legend = c('Minima',1:n,'Maxima',1:n),
       pch = rep(c(NA, rep(16,n)), 2), col = c(1, cf.1(n),1, cf.2(n)),
       pt.cex =  c(rep(c(1, c(1:n) / 1.5), 2)), cex = .75, ncol = 2)

</code></pre>

<hr>
<h2 id='lm_parms'>Helper functions for handling linear fits.</h2><span id='topic+lm_parms'></span><span id='topic+lm_window'></span>

<h3>Description</h3>

<p><code>lm_window</code> performs a linear regression with the Theil-Sen estimator on a subset of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_parms(m)

lm_window(x, y, i0, h = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_parms_+3A_m">m</code></td>
<td>
<p>linear model (<code>lm</code>) object</p>
</td></tr>
<tr><td><code id="lm_parms_+3A_x">x</code></td>
<td>
<p>vector of independent variable (e.g. time).</p>
</td></tr>
<tr><td><code id="lm_parms_+3A_y">y</code></td>
<td>
<p>vector of dependent variable (concentration of organisms).</p>
</td></tr>
<tr><td><code id="lm_parms_+3A_i0">i0</code></td>
<td>
<p>index of first value used for a window.</p>
</td></tr>
<tr><td><code id="lm_parms_+3A_h">h</code></td>
<td>
<p>with of the window (number of data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>linear model object of class <code>lm</code> (lm_window)
resp. vector with parameters of the fit (lm_parms).
</p>


<h3>References</h3>

<p>Hall, B. G., H. Acar and M. Barlow 2013. Growth Rates Made Easy.
Mol. Biol. Evol. 31: 232-238 <a href="https://doi.org/10.1093/molbev/mst197">doi:10.1093/molbev/mst197</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- as.numeric(rnd.dataset$data[1,-(1:3)]) # Remove identifier columns
data.log &lt;- log(data/data[1])

# Perform linear fit on 8th window of size 8
linreg &lt;- lm_window(time, data.log, 8, h=8)

summary(linreg)

lm_parms(linreg)
</code></pre>

<hr>
<h2 id='low.integrate'>Function to estimate the area under a curve given as x and y(x) values</h2><span id='topic+low.integrate'></span>

<h3>Description</h3>

<p>Function to estimate the area under a curve given as x and y(x) values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>low.integrate(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="low.integrate_+3A_x">x</code></td>
<td>
<p>Numeric vector of x values.</p>
</td></tr>
<tr><td><code id="low.integrate_+3A_y">y</code></td>
<td>
<p>Numeric vector of y values with the same length as <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the the R internal function <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>.
</p>


<h3>Value</h3>

<p>Numeric value: Area under the smoothed spline.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- as.numeric(rnd.dataset$data[1,-(1:3)]) # Remove identifier columns

plot(time, data)

print(low.integrate(time, data))

</code></pre>

<hr>
<h2 id='parse_data'>Parse raw plate reader data and convert it to a format compatible with QurvE</h2><span id='topic+parse_data'></span>

<h3>Description</h3>

<p><code>parse_data</code> takes a raw export file from a plate reader experiment (or similar device), extracts relevant information and parses it into the format required to run <code><a href="#topic+growth.workflow">growth.workflow</a></code>. If more than one read type is found the user is prompted to assign the correct reads to <code>growth</code> or <code>fluorescence</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_data(
  data.file = NULL,
  map.file = NULL,
  software = c("Gen5", "Gen6", "Biolector", "Chi.Bio", "GrowthProfiler", "Tecan",
    "VictorNivo", "VictorX3"),
  convert.time = NULL,
  sheet.data = 1,
  sheet.map = 1,
  csvsep.data = ";",
  dec.data = ".",
  csvsep.map = ";",
  dec.map = ".",
  subtract.blank = TRUE,
  calib.growth = NULL,
  calib.fl = NULL,
  calib.fl2 = NULL,
  fl.normtype = c("growth", "fl2")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_data_+3A_data.file">data.file</code></td>
<td>
<p>(Character) A table file with extension '.xlsx', '.xls', '.csv', '.tsv', or '.txt' containing raw plate reader (or similar device) data.</p>
</td></tr>
<tr><td><code id="parse_data_+3A_map.file">map.file</code></td>
<td>
<p>(Character) A table file in column format with extension '.xlsx', '.xls', '.csv', '.tsv', or '.txt'  with 'well', 'ID', 'replicate', and 'concentration' in the first row. Used to assign sample information to wells in a plate.</p>
</td></tr>
<tr><td><code id="parse_data_+3A_software">software</code></td>
<td>
<p>(Character) The name of the software/device used to export the plate reader data.</p>
</td></tr>
<tr><td><code id="parse_data_+3A_convert.time">convert.time</code></td>
<td>
<p>(<code>NULL</code> or string) Convert time values with a formula provided in the form <code>'y = function(x)'</code>.
For example: <code>convert.time = 'y = 24 * x'</code></p>
</td></tr>
<tr><td><code id="parse_data_+3A_sheet.data">sheet.data</code>, <code id="parse_data_+3A_sheet.map">sheet.map</code></td>
<td>
<p>(Numeric or Character) Number or name of the sheets in XLS or XLSX files containing experimental data or mapping information, respectively (<em>optional</em>).</p>
</td></tr>
<tr><td><code id="parse_data_+3A_csvsep.data">csvsep.data</code>, <code id="parse_data_+3A_csvsep.map">csvsep.map</code></td>
<td>
<p>(Character) separator used in CSV data files (ignored for other file types).  Default: <code>";"</code></p>
</td></tr>
<tr><td><code id="parse_data_+3A_dec.data">dec.data</code>, <code id="parse_data_+3A_dec.map">dec.map</code></td>
<td>
<p>(Character) decimal separator used in CSV, TSV or TXT files with measurements and mapping information, respectively.</p>
</td></tr>
<tr><td><code id="parse_data_+3A_subtract.blank">subtract.blank</code></td>
<td>
<p>(Logical) Shall blank values be subtracted from values within the same experiment (<a href="base.html#topic+TRUE">TRUE</a>, the default) or not (<a href="base.html#topic+FALSE">FALSE</a>).</p>
</td></tr>
<tr><td><code id="parse_data_+3A_calib.growth">calib.growth</code>, <code id="parse_data_+3A_calib.fl">calib.fl</code>, <code id="parse_data_+3A_calib.fl2">calib.fl2</code></td>
<td>
<p>(Character or <code>NULL</code>) Provide an equation in the form 'y = function(x)' (for example: 'y = x^2 * 0.3 - 0.5') to convert growth and fluorescence values. This can be used to, e.g., convert plate reader absorbance values into OD<sub>600</sub> or fluorescence intensity into molecule concentrations.
Caution!: When utilizing calibration, carefully consider whether or not blanks were subtracted to determine the calibration before selecting the input <code>subtract.blank = TRUE</code>.</p>
</td></tr>
<tr><td><code id="parse_data_+3A_fl.normtype">fl.normtype</code></td>
<td>
<p>(Character string) Normalize fluorescence values by either diving by <code>'growth'</code> or by fluorescence2 values (<code>'fl2'</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Metadata provided as <code>map.file</code> needs to have the following layout:
<img src="../help/figures/mapping-layout.png" alt="mapping-layout.png" />
</p>


<h3>Value</h3>

<p>A <code>grodata</code> object suitable to run <code><a href="#topic+growth.workflow">growth.workflow</a></code>. See <code><a href="#topic+read_data">read_data</a></code> for its structure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
grodata &lt;- parse_data(data.file = system.file("fluorescence_test_Gen5.xlsx", package = "QurvE"),
                      sheet.data = 1,
                      map.file = system.file("fluorescence_test_Gen5.xlsx", package = "QurvE"),
                      sheet.map = "mapping",
                      software = "Gen5",
                      convert.time = "y = x * 24", # convert days to hours
                      calib.growth = "y = x * 3.058") # convert absorbance to OD values
}
</code></pre>

<hr>
<h2 id='parse_Gen5Gen6'>Extract relevant data from a raw data export file generated with the &quot;Gen5&quot; or &quot;Gen6&quot; software.</h2><span id='topic+parse_Gen5Gen6'></span>

<h3>Description</h3>

<p>Extract relevant data from a raw data export file generated with the &quot;Gen5&quot; or &quot;Gen6&quot; software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_Gen5Gen6(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_Gen5Gen6_+3A_input">input</code></td>
<td>
<p>A dataframe created by reading a table file with <code><a href="#topic+read_file">read_file</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length two containing growth and/or fluorescence dataframes in the first and second element, respectively. The first column in these dataframes represents a time vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
input &lt;- read_file(filename = system.file("fluorescence_test_Gen5.xlsx", package = "QurvE") )
parsed &lt;- parse_Gen5Gen6(input)
}
</code></pre>

<hr>
<h2 id='parse_victornivo'>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor Nivo&quot; plate readers.</h2><span id='topic+parse_victornivo'></span>

<h3>Description</h3>

<p>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor Nivo&quot; plate readers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_victornivo(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_victornivo_+3A_input">input</code></td>
<td>
<p>A dataframe created by reading a table file with <code><a href="#topic+read_file">read_file</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length two containing growth and/or fluorescence dataframes in the first and second element, respectively. The first column in these dataframes represents a time vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
input &lt;- read_file(filename = system.file("nivo_output.csv", package = "QurvE"), csvsep = "," )
parsed &lt;- parse_victornivo(input)
}
</code></pre>

<hr>
<h2 id='parse_victorx3'>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor X3&quot; plate readers.</h2><span id='topic+parse_victorx3'></span>

<h3>Description</h3>

<p>Extract relevant data from a raw data export file generated from the software of Perkin Elmer's &quot;Victor X3&quot; plate readers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_victorx3(input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_victorx3_+3A_input">input</code></td>
<td>
<p>A dataframe created by reading a table file with <code><a href="#topic+read_file">read_file</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of length two containing growth and/or fluorescence dataframes in the first and second element, respectively. The first column in these dataframes represents a time vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
input &lt;- read_file(filename = system.file("victorx3_output.txt", package = "QurvE") )
parsed &lt;- parse_victorx3(input)
}
</code></pre>

<hr>
<h2 id='plot.dr_parameter'>Compare calculated dose-response parameters between conditions.</h2><span id='topic+plot.dr_parameter'></span>

<h3>Description</h3>

<p><code>plot.dr_parameter</code> gathers parameters from the results of a dose-response analysis and compares a chosen parameter between each condition in a column plot. Error bars represent the 95% confidence interval (only shown for &gt; 2 replicates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dr_parameter'
plot(
  x,
  param = c("EC50", "EC50.Estimate", "y.max", "y.min", "fc", "K", "n", "yEC50",
    "drboot.meanEC50", "drboot.meanEC50y", "EC50.orig", "yEC50.orig"),
  names = NULL,
  exclude.nm = NULL,
  basesize = 12,
  reference.nm = NULL,
  label.size = NULL,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dr_parameter_+3A_x">x</code></td>
<td>
<p>A <code>grofit</code>, <code>drFit</code>, <code>drTable</code>, or <code>flFitRes</code> object obtained with <code><a href="#topic+growth.workflow">growth.workflow</a></code>, <code><a href="#topic+growth.drFit">growth.drFit</a></code>, <code><a href="#topic+fl.drFit">fl.drFit</a></code>, or <code><a href="#topic+fl.workflow">fl.workflow</a></code>.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_param">param</code></td>
<td>
<p>(Character) The parameter used to compare different sample groups. Any name of a column containing numeric values in <code>gcTable</code> (which is stored within <code>grofit</code> or <code>gcFit</code> objects) can be used as input. Useful options are:
'y.max', 'y.min', 'fc', 'K', or 'n' for fluorescence dose-response analyses with <code>dr.type = 'model'</code> in the <code>control</code> argument,
or 'EC50', 'yEC50', 'drboot.meanEC50', 'drboot.meanEC50y'.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_reference.nm">reference.nm</code></td>
<td>
<p>(Character) Name of the reference condition, to which parameter values are normalized. Partially matching strings are tolerated as long as they can uniquely identify the condition.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_label.size">label.size</code></td>
<td>
<p>(Numeric) Font size for sample labels below x-axis.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.dr_parameter_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column plot comparing a selected parameter of a dose-response analysis between tested conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

rnd.data &lt;- list()
rnd.data[["time"]] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[["data"]] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = "s",
                                                suppress.messages = TRUE))

# Perform dose-response analysis
drFit &lt;- growth.drFit(gcTable = gcFit$gcTable,
            control = growth.control(dr.parameter = "mu.spline"))

plot.dr_parameter(drFit, param = 'EC50')


</code></pre>

<hr>
<h2 id='plot.drBootSpline'>Generic plot function for <code>gcBootSpline</code> objects.</h2><span id='topic+plot.drBootSpline'></span>

<h3>Description</h3>

<p>Generic plot function for <code>gcBootSpline</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drBootSpline'
plot(
  x,
  pch = 19,
  colData = 1,
  colSpline = "black",
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  lwd = 2,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  combine = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drBootSpline_+3A_x">x</code></td>
<td>
<p>A <code>drBootSpline</code> object created with <code><a href="#topic+growth.drBootSpline">growth.drBootSpline</a></code> or stored within a <code>grofit</code> or <code>drFit</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code> or <code><a href="#topic+growth.drFit">growth.drFit</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or Character) Color used to plot the raw data.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or Character) Color used to plot the splines.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_combine">combine</code></td>
<td>
<p>(Logical) Indicate whether both dose-response curves and parameter plots shall be shown within the same window.</p>
</td></tr>
<tr><td><code id="plot.drBootSpline_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the all dose-response spline fits from the bootstrapping operation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+stats::rnorm(19)/50, 0)

TestRun &lt;- growth.drBootSpline(conc, response, drID = "test",
        control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8, nboot.dr = 50))

print(summary(TestRun))
plot(TestRun, combine = TRUE)

</code></pre>

<hr>
<h2 id='plot.drFit'>Generic plot function for <code>drFit</code> objects.</h2><span id='topic+plot.drFit'></span>

<h3>Description</h3>

<p><code>plot.drFit</code> calls <code>plot.drFitSpline</code> for each group used in a dose-response analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFit'
plot(
  x,
  combine = TRUE,
  names = NULL,
  exclude.nm = NULL,
  pch = 16,
  cex.point = 2,
  basesize = 15,
  colors = NULL,
  lwd = 0.7,
  ec50line = TRUE,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  log.y = FALSE,
  log.x = FALSE,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drFit_+3A_x">x</code></td>
<td>
<p>object of class <code>drFit</code>, created with <code><a href="#topic+growth.drFit">growth.drFit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_combine">combine</code></td>
<td>
<p>(Logical) Combine the dose-response analysis results of all conditions into a single plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define conditions to combine into a single plot (if <code>combine = TRUE</code>). Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define conditions to exclude from the plot (if <code>combine = TRUE</code>). Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_colors">colors</code></td>
<td>
<p>(Numeric or character) Define colors for different conditions.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual splines.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_ec50line">ec50line</code></td>
<td>
<p>(Logical) Show pointed horizontal and vertical lines at the EC50 values (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_log.x">log.x</code></td>
<td>
<p>(Logical) Log-transform the x-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.drFit_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One plot per condition tested in the dose-response analysis or a single plot showing all conditions if <code>control = growth.control(dr.method = "spline")</code> was used in <code><a href="#topic+growth.drFit">growth.drFit</a></code> and <code>combine = TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

rnd.data &lt;- list()
rnd.data[["time"]] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[["data"]] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = "s",
                                                suppress.messages = TRUE))

# Perform dose-response analysis
drFit &lt;- growth.drFit(gcTable = gcFit$gcTable,
                 control = growth.control(dr.parameter = "mu.spline"))

# Inspect results
summary(drFit)

plot(drFit)

</code></pre>

<hr>
<h2 id='plot.drFitfl'>Generic plot function for <code>drFitFL</code> objects.</h2><span id='topic+plot.drFitfl'></span>

<h3>Description</h3>

<p><code>drFitfl</code> calls <code><a href="#topic+plot.drFitFLModel">plot.drFitFLModel</a></code> for each group used in a dose-response analysis with <code>dr.method = "model"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitfl'
plot(
  x,
  ec50line = TRUE,
  log = c("xy"),
  pch = 1,
  broken = TRUE,
  bp,
  n.xbreaks,
  n.ybreaks,
  colSpline = 1,
  colData = 1,
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  y.lim = NULL,
  x.lim = NULL,
  lwd = 2,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drFitfl_+3A_x">x</code></td>
<td>
<p>object of class <code>drFit</code>, created with <code><a href="#topic+growth.drFit">growth.drFit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_ec50line">ec50line</code></td>
<td>
<p>(Logical) Show pointed horizontal and vertical lines at the EC50 values (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_log">log</code></td>
<td>
<p>(Character) String which contains '&quot;x&quot;' if the x axis is to be logarithmic, '&quot;y&quot;' if the y axis is to be logarithmic and '&quot;xy&quot;' or '&quot;yx&quot;' if both axes are to be logarithmic. The default is &quot;x&quot;. The empty string &quot;&quot; yields the original axes.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_broken">broken</code></td>
<td>
<p>(Logical) If TRUE the x axis is broken provided this axis is logarithmic (using functionality in the CRAN package 'plotrix').</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_bp">bp</code></td>
<td>
<p>(Numeric) Specifying the break point below which the dose is zero (the amount of stretching on the dose axis above zero in order to create the visual illusion of a logarithmic scale including 0). The default is the base-10 value corresponding to the rounded value of the minimum of the log10 values of all positive dose values. This argument is only working for logarithmic dose axes.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_n.xbreaks">n.xbreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the x-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or character) Spline line colour.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or character) Contour color of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual splines.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drFitfl_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One plot per condition tested in the dose-response analysis (<code><a href="#topic+fl.drFit">fl.drFit</a></code> with <code>control = fl.control(dr.method = "model")</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Define fit controls
control &lt;- fl.control(fit.opt = "s",
             x_type = "time", norm_fl = TRUE,
             dr.parameter = "max_slope.spline",
             dr.method = "model",
             suppress.messages = TRUE)

# Run curve fitting workflow
res &lt;- flFit(fl_data = input$norm.fluorescence,
             time = input$time,
             parallelize = FALSE,
             control = control)

# Perform dose-response analysis with biosensor model
drFitfl &lt;- fl.drFit(flTable = res$flTable, control = control)

plot(drFitfl)

</code></pre>

<hr>
<h2 id='plot.drFitFLModel'>Generic plot function for <code>drFitFLModel</code> objects.</h2><span id='topic+plot.drFitFLModel'></span>

<h3>Description</h3>

<p>Generic plot function for <code>drFitFLModel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitFLModel'
plot(
  x,
  ec50line = TRUE,
  broken = TRUE,
  bp,
  n.xbreaks,
  n.ybreaks,
  log = c("xy"),
  pch = 1,
  colSpline = 1,
  colData = 1,
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  y.lim = NULL,
  x.lim = NULL,
  lwd = 2,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drFitFLModel_+3A_x">x</code></td>
<td>
<p>Object of class <code>drFitFLModel</code>, created with <code><a href="#topic+fl.drFitModel">fl.drFitModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_ec50line">ec50line</code></td>
<td>
<p>(Logical) Show pointed horizontal and vertical lines at the EC50 value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_broken">broken</code></td>
<td>
<p>(Logical) If TRUE the x axis is broken provided this axis is logarithmic (using functionality in the CRAN package 'plotrix').</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_bp">bp</code></td>
<td>
<p>(Numeric) Specifying the break point below which the dose is zero (the amount of stretching on the dose axis above zero in order to create the visual illusion of a logarithmic scale including 0). The default is the base-10 value corresponding to the rounded value of the minimum of the log10 values of all positive dose values. This argument is only working for logarithmic dose axes.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_n.xbreaks">n.xbreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the x-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.#' @param pch (Numeric) Size of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_log">log</code></td>
<td>
<p>(Character) String which contains '&quot;x&quot;' if the x axis is to be logarithmic, '&quot;y&quot;' if the y axis is to be logarithmic and '&quot;xy&quot;' or '&quot;yx&quot;' if both axes are to be logarithmic. The default is &quot;x&quot;. The empty string &quot;&quot; yields the original axes.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or Character) Color used to plot the splines.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or Character) Color used to plot the raw data.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drFitFLModel_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the biosensor dose-response model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create concentration values via a serial dilution
conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)

# Simulate response values via biosensor equation
response &lt;- biosensor.eq(conc, y.min = 110, y.max = 6000, K = 0.5, n = 2) +
            0.01*6000*rnorm(10)

# Perform fit
TestRun &lt;- fl.drFitModel(conc, response, drID = "test", control = fl.control())

print(summary(TestRun))
plot(TestRun)

</code></pre>

<hr>
<h2 id='plot.drFitModel'>Generic plot function for <code>drFitModel</code> objects.</h2><span id='topic+plot.drFitModel'></span>

<h3>Description</h3>

<p>Generic plot function for <code>drFitModel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitModel'
plot(
  x,
  type = c("confidence", "all", "bars", "none", "obs", "average"),
  ec50line = TRUE,
  add = FALSE,
  broken = TRUE,
  bp,
  gridsize = 200,
  log = "x",
  n.xbreaks,
  n.ybreaks,
  x.lim,
  y.lim,
  pch = 1,
  cex.point,
  cex.axis = 1,
  cex.lab = 1.3,
  col = 1,
  lwd = 2,
  lty = 2,
  xlab,
  ylab,
  legend = TRUE,
  legendText,
  legendPos,
  cex.legend = NULL,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drFitModel_+3A_x">x</code></td>
<td>
<p>object of class <code>drFitModel</code>, created with <code><a href="#topic+growth.drFitModel">growth.drFitModel</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_type">type</code></td>
<td>
<p>(Character) Specify how to plot the data. There are currently 5 options: &quot;average&quot; (averages and fitted curve(s); default), &quot;none&quot; (only the fitted curve(s)), &quot;obs&quot; (only the data points), &quot;all&quot; (all data points and fitted curve(s)), &quot;bars&quot; (averages and fitted curve(s) with model-based standard errors (see Details)), and &quot;confidence&quot; (confidence bands for fitted curve(s)).</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_ec50line">ec50line</code></td>
<td>
<p>(Logical) Show pointed horizontal and vertical lines at the EC50 values (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_add">add</code></td>
<td>
<p>(Logical) If <code>TRUE</code> then add to already existing plot.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_broken">broken</code></td>
<td>
<p>(Logical) If TRUE the x axis is broken provided this axis is logarithmic (using functionality in the CRAN package 'plotrix').</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_bp">bp</code></td>
<td>
<p>(Numeric) Specifying the break point below which the dose is zero (the amount of stretching on the dose axis above zero in order to create the visual illusion of a logarithmic scale including 0). The default is the base-10 value corresponding to the rounded value of the minimum of the log10 values of all positive dose values. This argument is only working for logarithmic dose axes.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_gridsize">gridsize</code></td>
<td>
<p>(Numeric) Number of points in the grid used for plotting the fitted curves.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_log">log</code></td>
<td>
<p>(Character) String which contains '&quot;x&quot;' if the x axis is to be logarithmic, '&quot;y&quot;' if the y axis is to be logarithmic and '&quot;xy&quot;' or '&quot;yx&quot;' if both axes are to be logarithmic. The default is &quot;x&quot;. The empty string &quot;&quot; yields the original axes.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_n.xbreaks">n.xbreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the x-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis (if not log-transformed). The breaks are generated using <code>pretty</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_col">col</code></td>
<td>
<p>(Logical or a vector of colors) If <code>TRUE</code> default colours are used. If <code>FALSE</code> (default) no colors are used.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_lty">lty</code></td>
<td>
<p>(Numeric) Specify the line type.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_xlab">xlab</code></td>
<td>
<p>(Character) An optional label for the x axis.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_ylab">ylab</code></td>
<td>
<p>(Character) An optional label for the y axis.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_legend">legend</code></td>
<td>
<p>(Logical) If <code>TRUE</code> a legend is displayed.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_legendtext">legendText</code></td>
<td>
<p>(Character) Specify the legend text (the position of the upper right corner of the legend box).</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_legendpos">legendPos</code></td>
<td>
<p>(Numeric) Vector of length 2 giving the position of the legend.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_cex.legend">cex.legend</code></td>
<td>
<p>numeric specifying the legend text size.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drFitModel_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the dose-response model fit.
</p>


<h3>References</h3>

<p>Christian Ritz, Florent Baty, Jens C. Streibig, Daniel Gerhard (2015). <em>Dose-Response Analysis Using R</em>. PLoS ONE 10(12): e0146021. DOI: 10.1371/journal.pone.0146021
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+stats::rnorm(19)/50, 0)

TestRun &lt;- growth.drFitModel(conc, response, drID = "test")

print(summary(TestRun))
plot(TestRun)
</code></pre>

<hr>
<h2 id='plot.drFitSpline'>Generic plot function for <code>drFitSpline</code> objects.</h2><span id='topic+plot.drFitSpline'></span>

<h3>Description</h3>

<p><code>plot.drFitSpline</code> generates the spline fit plot for response-parameter vs. concentration data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitSpline'
plot(
  x,
  add = FALSE,
  ec50line = TRUE,
  log = "",
  pch = 16,
  colSpline = 1,
  colData = 1,
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  lwd = 2,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.drFitSpline_+3A_x">x</code></td>
<td>
<p>object of class <code>drFitSpline</code>, created with <code><a href="#topic+growth.drFitSpline">growth.drFitSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_add">add</code></td>
<td>
<p>(Logical) Shall the fitted spline be added to an existing plot? <code>TRUE</code> is used internally by <code><a href="#topic+plot.drBootSpline">plot.drBootSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_ec50line">ec50line</code></td>
<td>
<p>(Logical) Show pointed horizontal and vertical lines at the EC50 value (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_log">log</code></td>
<td>
<p>(&quot;x&quot;, &quot;y&quot;, or &quot;xy&quot;) Display the x- or y-axis on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or character) Spline line colour.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or character) Contour color of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of spline.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.drFitSpline_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the nonparametric dose-response fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+stats::rnorm(19)/50, 0)

TestRun &lt;- growth.drFitSpline(conc, response, drID = "test",
                     control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8))

print(summary(TestRun))
plot(TestRun)
</code></pre>

<hr>
<h2 id='plot.dual'>Compare fluorescence and growth over time</h2><span id='topic+plot.dual'></span>

<h3>Description</h3>

<p><code>plot.dual</code> creates a two-panel plot in which fluorescence or growth values are shown over time, allowing for the identification of, e.g., expression patterns in different growth stages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dual'
plot(
  x,
  fluorescence = c("fl", "norm.fl"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  mean = TRUE,
  exclude.nm = NULL,
  exclude.conc = NULL,
  log.y.growth = FALSE,
  log.y.fl = FALSE,
  n.ybreaks = 6,
  colors = NULL,
  color_groups = TRUE,
  group_pals = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red",
    "Cyan", "Brown", "Mint"),
  basesize = 20,
  y.lim.growth = NULL,
  y.lim.fl = NULL,
  x.lim = NULL,
  x.title = NULL,
  y.title.growth = NULL,
  y.title.fl = NULL,
  lwd = 1.1,
  legend.position = "bottom",
  legend.ncol = 2,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dual_+3A_x">x</code></td>
<td>
<p>A <code>flFit</code>, <code>flFitRes</code>, or <code>grodata</code> object created with <code><a href="#topic+flFit">flFit</a></code>, <code><a href="#topic+fl.workflow">fl.workflow</a></code> or <code><a href="#topic+read_data">read_data</a></code></p>
</td></tr>
<tr><td><code id="plot.dual_+3A_fluorescence">fluorescence</code></td>
<td>
<p>(Character) Indicate, which type of fluorescence data should be displayed.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_mean">mean</code></td>
<td>
<p>(Logical) Display the mean and standard deviation of groups with replicates (<code>TRUE</code>) or plot each sample individually (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_log.y.growth">log.y.growth</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the growth plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_log.y.fl">log.y.fl</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the fluorescence plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_colors">colors</code></td>
<td>
<p>(vector of strings) Define a color palette used to draw the plots. If <code>NULL</code>, default palettes are chosen based on the number of groups/samples within the plot. Note: The number of provided colors should at least match the number of groups/samples.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_color_groups">color_groups</code></td>
<td>
<p>(Logical) Shall samples within the same group but with different concentrations be shown in different shades of the same color?</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_group_pals">group_pals</code></td>
<td>
<p>(String vector) Define the colors used to display sample groups with identical concentrations. The number of selected color palettes must be at least the number of displayed groups. The order of the chosen palettes corresponds to the oder of conditions in the legend. Available options: &quot;Green&quot;, &quot;Oranges&quot;, &quot;Purple&quot;, &quot;Cyan&quot;, &quot;Grey&quot;, &quot;Red&quot;, &quot;Blue&quot;, and &quot;Magenta&quot;.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_y.lim.growth">y.lim.growth</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the growth plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_y.lim.fl">y.lim.fl</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the fluorescence plot as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the x-axis of both fluorescence and growth plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_y.title.growth">y.title.growth</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth plot.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_y.title.fl">y.title.fl</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the fluorescence plot.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual plots.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_legend.position">legend.position</code></td>
<td>
<p>(Character) Position of the legend. One of &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p>(Numeric) Number of columns in the legend.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.dual_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A two-panel plot, showing raw fluorescence (<code>fluorescence = "fl"</code>) or normalized fluorescence (<code>fluorescence = "norm.fl"</code>) over time in the top panel, and growth over time in the bottom panel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = "s",
                   x_type = "time", norm_fl = TRUE,
                   dr.parameter = "max_slope.spline",
                   suppress.messages = TRUE,
                   parallelize = FALSE)

plot.dual(res, legend.ncol = 3, basesize = 15)


</code></pre>

<hr>
<h2 id='plot.flBootSpline'>Generic plot function for <code>flBootSpline</code> objects.</h2><span id='topic+plot.flBootSpline'></span>

<h3>Description</h3>

<p>Generic plot function for <code>flBootSpline</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flBootSpline'
plot(
  x,
  pch = 1,
  colData = 1,
  deriv = TRUE,
  colSpline = "dodgerblue3",
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  lwd = 2,
  y.lim = NULL,
  x.lim = NULL,
  y.lim.deriv = NULL,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  combine = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flBootSpline_+3A_x">x</code></td>
<td>
<p>Object of class <code>flBootSpline</code>, created with <code><a href="#topic+flBootSpline">flBootSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Size of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or Character) Color used to plot the raw data.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show the derivatives (i.e., slope) over time in a secondary plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or Character) Color used to plot the splines.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the fluorescence curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis of both fluorescence curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_combine">combine</code></td>
<td>
<p>(Logical) Indicate whether both growth curves and parameter plots shall be shown within the same window.</p>
</td></tr>
<tr><td><code id="plot.flBootSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single plot with the all spline fits from the bootstrapping operation and statistical distribution of parameters if <code>combine = TRUE</code> or separate plots for fits and parameter distributions (if <code>combine = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flBootSpline(time = time,
                       fl_data = data,
                       ID = "TestFit",
                       control = fl.control(fit.opt = "s", x_type = "time",
                       nboot.fl = 50))

plot(TestFit, combine = TRUE, lwd = 0.5)
</code></pre>

<hr>
<h2 id='plot.flFitLinear'>Generic plot function for <code>flcFittedLinear</code> objects. Plot the results of a linear regression on ln-transformed data</h2><span id='topic+plot.flFitLinear'></span>

<h3>Description</h3>

<p><code>plot.flFitLinear</code> shows the results of a linear regression and visualizes raw data, data points included in the fit, the tangent obtained by linear regression, and the lag time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFitLinear'
plot(
  x,
  log = "",
  which = c("fit", "diagnostics", "fit_diagnostics"),
  pch = 21,
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  lwd = 2,
  color = "firebrick3",
  y.lim = NULL,
  x.lim = NULL,
  plot = TRUE,
  export = FALSE,
  height = ifelse(which == "fit", 7, 5),
  width = ifelse(which == "fit", 9, 9),
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flFitLinear_+3A_x">x</code></td>
<td>
<p>A <code>flFittedLinear</code> object created with <code><a href="#topic+flFitLinear">flFitLinear</a></code> or stored within a <code>flFitRes</code> or <code>flFit</code> object created with <code><a href="#topic+fl.workflow">fl.workflow</a></code> or <code><a href="#topic+flFit">flFit</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_log">log</code></td>
<td>
<p>(&quot;x&quot; or &quot;y&quot;) Display the x- or y-axis on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_which">which</code></td>
<td>
<p>(&quot;fit&quot; or &quot;diagnostics&quot;) Display either the results of the linear fit on the raw data or statistical evaluation of the linear regression.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_color">color</code></td>
<td>
<p>(Character string) Enter color either by name (e.g., red, blue, coral3) or via their hexadecimal code (e.g., #AE4371, #CCFF00FF, #0066FFFF). A full list of colors available by name can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.flFitLinear_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the linear fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitLinear(time = time,
                       fl_data = data,
                       ID = "TestFit",
                       control = fl.control(fit.opt = "l", x_type = "time",
                       lin.R2 = 0.95, lin.RSD = 0.1,
                       lin.h = 20))

plot(TestFit)
</code></pre>

<hr>
<h2 id='plot.flFitRes'>Combine different groups of samples into a single plot</h2><span id='topic+plot.flFitRes'></span><span id='topic+plot.flFit'></span>

<h3>Description</h3>

<p>Visualize fluorescence, normalized fluorescence, or spline fits of multiple sample groups in a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFitRes'
plot(
  x,
  data.type = c("spline", "raw", "norm.fl"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  mean = TRUE,
  exclude.nm = NULL,
  exclude.conc = NULL,
  log.y = FALSE,
  deriv = FALSE,
  n.ybreaks = 6,
  colors = NULL,
  color_groups = TRUE,
  group_pals = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red",
    "Cyan", "Brown", "Mint"),
  basesize = 20,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  y.lim.deriv = NULL,
  y.title.deriv = NULL,
  lwd = 1.1,
  legend.position = "bottom",
  legend.ncol = 2,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)

## S3 method for class 'flFit'
plot(
  x,
  data.type = c("spline", "raw", "norm.fl"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  mean = TRUE,
  exclude.nm = NULL,
  exclude.conc = NULL,
  log.y = FALSE,
  deriv = FALSE,
  n.ybreaks = 6,
  colors = NULL,
  color_groups = TRUE,
  group_pals = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red",
    "Cyan", "Brown", "Mint"),
  basesize = 20,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  y.lim.deriv = NULL,
  y.title.deriv = NULL,
  lwd = 1.1,
  legend.position = "bottom",
  legend.ncol = 2,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flFitRes_+3A_x">x</code></td>
<td>
<p>A <code>flFitRes</code>, <code>flFit</code>, or <code>grodata</code> object created with <code><a href="#topic+fl.workflow">fl.workflow</a></code> containing fluorescence data.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_data.type">data.type</code></td>
<td>
<p>(Character) Indicate, which type of fluorescence data should be displayed.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_mean">mean</code></td>
<td>
<p>(Logical) Display the mean and standard deviation of groups with replicates (<code>TRUE</code>) or plot each sample individually (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show derivatives over time in a separate panel below the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>axisTicks()</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_colors">colors</code></td>
<td>
<p>(vector of strings) Define a color palette used to draw the plots. If <code>NULL</code>, default palettes are chosen based on the number of groups/samples within the plot. Note: The number of provided colors should at least match the number of groups/samples.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_color_groups">color_groups</code></td>
<td>
<p>(Logical) Shall samples within the same group but with different concentrations be shown in different shades of the same color?</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_group_pals">group_pals</code></td>
<td>
<p>(String vector) Define the colors used to display sample groups with identical concentrations. The number of selected color palettes must be at least the number of displayed groups. The order of the chosen palettes corresponds to the oder of conditions in the legend. Available options: &quot;Green&quot;, &quot;Oranges&quot;, &quot;Purple&quot;, &quot;Cyan&quot;, &quot;Grey&quot;, &quot;Red&quot;, &quot;Blue&quot;, and &quot;Magenta&quot;.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the fluorescence curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the x-axis of both fluorescence curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the fluorescence curve plot.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both fluorescence curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_y.title.deriv">y.title.deriv</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the derivative plot.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual plots.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_legend.position">legend.position</code></td>
<td>
<p>(Character) Position of the legend. One of &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p>(Numeric) Number of columns in the legend.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.flFitRes_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with all curves (nonparametric fits, raw fluorescence measurements, or raw normalized fluorescence over time) in a <code>flFitRes</code> object created with <code><a href="#topic+fl.workflow">fl.workflow</a></code>, with replicates combined by the group averages (if <code>mean = TRUE</code>) or not (<code>mean = FALSE</code>).
</p>
<p>A plot with all curves (raw fluorescence measurements or raw normalized fluorescence over time) in a <code>flFit</code> object with <code><a href="#topic+flFit">flFit</a></code>, with replicates combined by the group averages (if <code>mean = TRUE</code>) or not (<code>mean = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = "s",
                   x_type = "time", norm_fl = TRUE,
                   dr.parameter = "max_slope.spline",
                   suppress.messages = TRUE,
                   parallelize = FALSE)

plot(res, legend.ncol = 3, basesize = 15)


# load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run curve fitting workflow
res &lt;- flFit(fl_data = input$norm.fluorescence,
             time = input$time,
             parallelize = FALSE,
             control = fl.control(fit.opt = "s", suppress.messages = TRUE,
             x_type = "time", norm_fl = TRUE))

plot(res, legend.ncol = 3, basesize = 15)


</code></pre>

<hr>
<h2 id='plot.flFitSpline'>Generic plot function for <code>flFitSpline</code> objects.</h2><span id='topic+plot.flFitSpline'></span>

<h3>Description</h3>

<p><code>plot.flFitSpline</code> generates the spline fit plot for a single sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFitSpline'
plot(
  x,
  add = FALSE,
  raw = TRUE,
  slope = TRUE,
  deriv = TRUE,
  spline = TRUE,
  log.y = FALSE,
  basesize = 16,
  pch = 1,
  colData = 1,
  colSpline = "dodgerblue3",
  cex.point = 2,
  lwd = 0.7,
  y.lim = NULL,
  x.lim = NULL,
  y.lim.deriv = NULL,
  n.ybreaks = 6,
  y.title = NULL,
  x.title = NULL,
  y.title.deriv = NULL,
  plot = TRUE,
  export = FALSE,
  width = 8,
  height = ifelse(deriv == TRUE, 8, 6),
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.flFitSpline_+3A_x">x</code></td>
<td>
<p>Object of class <code>flFitSpline</code>, created with <code><a href="#topic+flFitSpline">flFitSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_add">add</code></td>
<td>
<p>(Logical) Shall the fitted spline be added to an existing plot? <code>TRUE</code> is used internally by <code><a href="#topic+plot.flBootSpline">plot.flBootSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_raw">raw</code></td>
<td>
<p>(Logical) Display raw growth as circles (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_slope">slope</code></td>
<td>
<p>(Logical) Show the slope at the maximum slope (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show the derivative (i.e., slope) over time in a secondary plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_spline">spline</code></td>
<td>
<p>(Logical) Only for <code>add = TRUE</code>: add the current spline to the existing plot (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or character) Contour color of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or character) Spline line colour.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the fluorescence curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis of both fluorescence curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>axisTicks()</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth curve plot.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_y.title.deriv">y.title.deriv</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the derivative plot.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.flFitSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the nonparametric fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitSpline(time = time,
                       fl_data = data,
                       ID = "TestFit",
                       control = fl.control(fit.opt = "s", x_type = "time"))

plot(TestFit)
</code></pre>

<hr>
<h2 id='plot.gcBootSpline'>Generic plot function for <code>gcBootSpline</code> objects.</h2><span id='topic+plot.gcBootSpline'></span>

<h3>Description</h3>

<p>Generic plot function for <code>gcBootSpline</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcBootSpline'
plot(
  x,
  pch = 1,
  colData = 1,
  deriv = TRUE,
  colSpline = "dodgerblue3",
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  lwd = 2,
  y.lim = NULL,
  x.lim = NULL,
  y.lim.deriv = NULL,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = 9,
  out.dir = NULL,
  combine = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcBootSpline_+3A_x">x</code></td>
<td>
<p>object of class <code>gcBootSpline</code>, created with <code><a href="#topic+growth.gcBootSpline">growth.gcBootSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or character) Contour color of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show the derivatives (i.e., slope) over time in a secondary plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or character) Spline line colour.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_combine">combine</code></td>
<td>
<p>(Logical) Indicate whether both growth curves and parameter plots shall be shown within the same window.</p>
</td></tr>
<tr><td><code id="plot.gcBootSpline_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single plot with the all spline growth fits from the bootstrapping operation and statistical distribution of growth parameters if <code>combine = TRUE</code> or separate plots for growth fits and parameter distributions (if <code>combine = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Introduce some noise into the measurements
data &lt;- data + stats::runif(97, -0.01, 0.09)

# Perform bootstrapping spline fit
TestFit &lt;- growth.gcBootSpline(time, data, gcID = "TestFit",
              control = growth.control(fit.opt = "s", nboot.gc = 50))

plot(TestFit, combine = TRUE, lwd = 0.5)
</code></pre>

<hr>
<h2 id='plot.gcFitLinear'>Generic plot function for <code>gcFittedLinear</code> objects. Plot the results of a linear regression on ln-transformed data</h2><span id='topic+plot.gcFitLinear'></span>

<h3>Description</h3>

<p><code>plot.gcFitLinear</code> shows the results of a linear regression on log-transformed data and visualizes raw data, data points included in the fit, the tangent obtained by linear regression, and the lag time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitLinear'
plot(
  x,
  log = "y",
  which = c("fit", "diagnostics", "fit_diagnostics"),
  pch = 21,
  cex.point = 1,
  cex.lab = 1.5,
  cex.axis = 1.3,
  lwd = 2,
  color = "firebrick3",
  y.lim = NULL,
  x.lim = NULL,
  plot = TRUE,
  export = FALSE,
  height = ifelse(which == "fit", 7, 5),
  width = ifelse(which == "fit", 9, 9),
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcFitLinear_+3A_x">x</code></td>
<td>
<p>A <code>gcFittedLinear</code> object created with <code><a href="#topic+growth.gcFitLinear">growth.gcFitLinear</a></code> or stored within a <code>grofit</code> or <code>gcFit</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code> or <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_log">log</code></td>
<td>
<p>(&quot;x&quot; or &quot;y&quot;) Display the x- or y-axis on a logarithmic scale.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_which">which</code></td>
<td>
<p>(&quot;fit&quot; or &quot;diagnostics&quot;) Display either the results of the linear fit on the raw data or statistical evaluation of the linear regression.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Shape of the raw data symbols.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_cex.lab">cex.lab</code></td>
<td>
<p>(Numeric) Font size of axis titles.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_cex.axis">cex.axis</code></td>
<td>
<p>(Numeric) Font size of axis annotations.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_color">color</code></td>
<td>
<p>(Character string) Enter color either by name (e.g., red, blue, coral3) or via their hexadecimal code (e.g., #AE4371, #CCFF00FF, #0066FFFF). A full list of colors available by name can be found at http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.gcFitLinear_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the linear fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- growth.gcFitLinear(time, data, gcID = "TestFit",
                 control = growth.control(fit.opt = "l"))

plot(TestFit)

</code></pre>

<hr>
<h2 id='plot.gcFitModel'>Generic plot function for <code>gcFitModel</code> objects.</h2><span id='topic+plot.gcFitModel'></span>

<h3>Description</h3>

<p>Plot the results of a parametric model fit on growth vs. time data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitModel'
plot(
  x,
  raw = TRUE,
  pch = 1,
  colData = 1,
  equation = TRUE,
  eq.size = 1,
  colModel = "forestgreen",
  basesize = 16,
  cex.point = 2,
  lwd = 0.7,
  x.lim = NULL,
  y.lim = NULL,
  n.ybreaks = 6,
  plot = TRUE,
  export = FALSE,
  height = 6,
  width = 8,
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcFitModel_+3A_x">x</code></td>
<td>
<p>A <code>gcFittedModel</code> object created with <code><a href="#topic+growth.gcFitModel">growth.gcFitModel</a></code> or stored within a <code>grofit</code> or <code>gcFit</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code> or <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_raw">raw</code></td>
<td>
<p>(Logical) Show the raw data within the plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or Character) Color used to plot the raw data.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_equation">equation</code></td>
<td>
<p>(Logical) Show the equation of the fitted model within the plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_eq.size">eq.size</code></td>
<td>
<p>(Numeric) Provide a value to scale the size of the displayed equation.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_colmodel">colModel</code></td>
<td>
<p>(Numeric or Character) Color used to plot the fitted model.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.gcFitModel_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated <code>ggplot2</code> plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the parametric fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform parametric fit
TestFit &lt;- growth.gcFitModel(time, data, gcID = "TestFit",
                 control = growth.control(fit.opt = "m"))

plot(TestFit, basesize = 18, eq.size = 1.5)

</code></pre>

<hr>
<h2 id='plot.gcFitSpline'>Generic plot function for <code>gcFitSpline</code> objects.</h2><span id='topic+plot.gcFitSpline'></span>

<h3>Description</h3>

<p><code>plot.gcFitSpline</code> generates the spline fit plot for a single sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitSpline'
plot(
  x,
  add = FALSE,
  raw = TRUE,
  slope = TRUE,
  deriv = TRUE,
  spline = TRUE,
  log.y = TRUE,
  pch = 1,
  colData = 1,
  colSpline = "dodgerblue3",
  basesize = 16,
  cex.point = 2,
  lwd = 0.7,
  y.lim = NULL,
  x.lim = NULL,
  y.lim.deriv = NULL,
  n.ybreaks = 6,
  y.title = NULL,
  x.title = NULL,
  y.title.deriv = NULL,
  plot = TRUE,
  export = FALSE,
  width = 8,
  height = ifelse(deriv == TRUE, 8, 6),
  out.dir = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.gcFitSpline_+3A_x">x</code></td>
<td>
<p>object of class <code>gcFitSpline</code>, created with <code><a href="#topic+growth.gcFitSpline">growth.gcFitSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_add">add</code></td>
<td>
<p>(Logical) Shall the fitted spline be added to an existing plot? <code>TRUE</code> is used internally by <code><a href="#topic+plot.gcBootSpline">plot.gcBootSpline</a></code>.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_raw">raw</code></td>
<td>
<p>(Logical) Display raw growth as circles (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_slope">slope</code></td>
<td>
<p>(Logical) Show the slope at the maximum growth rate (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show the derivative (i.e., slope) over time in a secondary plot (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_spline">spline</code></td>
<td>
<p>(Logical) Only for <code>add = TRUE</code>: add the current spline to the existing plot (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_pch">pch</code></td>
<td>
<p>(Numeric) Symbol used to plot data points.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_coldata">colData</code></td>
<td>
<p>(Numeric or character) Contour color of the raw data circles.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_colspline">colSpline</code></td>
<td>
<p>(Numeric or character) Spline line colour.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_cex.point">cex.point</code></td>
<td>
<p>(Numeric) Size of the raw data points.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Spline line width.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth curve plot.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_y.title.deriv">y.title.deriv</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the derivative plot.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.gcFitSpline_+3A_...">...</code></td>
<td>
<p>Further arguments to refine the generated base R plot (if <code>add = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with the nonparametric fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform spline fit
TestFit &lt;- growth.gcFitSpline(time, data, gcID = "TestFit",
                 control = growth.control(fit.opt = "s"))

plot(TestFit)

</code></pre>

<hr>
<h2 id='plot.grid'>Plot a matrix of growth curve panels</h2><span id='topic+plot.grid'></span>

<h3>Description</h3>

<p><code>plot.grid</code> takes a <code>grofit</code> or <code>flFitRes</code> object and returns a facet grid of individual growth and fluorescence plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grid'
plot(
  x,
  data.type = c("spline", "raw", "norm.fl"),
  param = c("mu.linfit", "lambda.linfit", "dY.linfit", "A.linfit", "mu2.linfit",
    "lambda2.linfit", "mu.model", "lambda.model", "A.model", "A.orig.model", "dY.model",
    "dY.orig.model", "tD.linfit", "tD2.linfit", "tD.spline", "tD2.spline", "mu.spline",
    "lambda.spline", "A.spline", "dY.spline", "integral.spline", "mu2.spline",
    "lambda2.spline", "mu.bt", "lambda.bt", "A.bt", "integral.bt", "max_slope.linfit",
    "max_slope.spline"),
  pal = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red", "Cyan",
    "Brown", "Mint"),
  invert.pal = FALSE,
  IDs = NULL,
  sort_by_ID = FALSE,
  names = NULL,
  conc = NULL,
  exclude.nm = NULL,
  exclude.conc = NULL,
  mean = TRUE,
  log.y = TRUE,
  n.ybreaks = 6,
  sort_by_conc = TRUE,
  nrow = NULL,
  basesize = 20,
  y.lim = NULL,
  x.lim = NULL,
  legend.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  lwd = 1.1,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.grid_+3A_x">x</code></td>
<td>
<p>A <code>grofit</code> or <code>flFitRes</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code> or <code><a href="#topic+fl.workflow">fl.workflow</a></code> containing spline fits.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_data.type">data.type</code></td>
<td>
<p>(Character) Plot either raw data (<code>data.type = "raw"</code>) or the spline fit results</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_param">param</code></td>
<td>
<p>(Character) The parameter used to compare different sample groups. Any name of a column containing numeric values in <code>gcTable</code> (which is stored within <code>grofit</code> or <code>gcFit</code> objects) can be used as input. Useful options are:
'mu.linfit', 'lambda.linfit', 'dY.linfit', 'A.linfit',
'mu.model', 'lambda.model', 'A.model',
'mu.spline', 'lambda.spline', 'A.spline', 'dY.spline', 'integral.spline',
'mu.bt', 'lambda.bt', 'A.bt', 'integral.bt'</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_pal">pal</code></td>
<td>
<p>(Character string) Choose one of 'Green',   'Orange',  'Purple',  'Magenta', 'Grey', 'Blue', 'Grey', 'Red', 'Cyan', 'Brown', or 'Mint' to visualize the value of the parameter chosen as <code>param</code> for each sample or condition.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_invert.pal">invert.pal</code></td>
<td>
<p>(Logical) Shall the colors in the chosen <code>pal</code> be inverted (<code>TRUE</code>) or not <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>. The order of strings within the vector defines the order of samples within the grid.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_sort_by_id">sort_by_ID</code></td>
<td>
<p>(Logical) Shall samples/conditions be ordered as entered in <code>IDs</code> (<code>TRUE</code>) or alphabetically (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_mean">mean</code></td>
<td>
<p>(Logical) Display the mean and standard deviation of groups with replicates (<code>TRUE</code>) or plot each sample individually (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?#'</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_sort_by_conc">sort_by_conc</code></td>
<td>
<p>(Logical) Shall the samples/conditions be sorted with concentrations in rows and groups in columns?</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_nrow">nrow</code></td>
<td>
<p>(Numeric) Defines the number of rows in the grid if <code>sort_by_conc</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_legend.lim">legend.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the color scale applied to <code>param</code> as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth curve plot.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual plots.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.grid_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot matrix with all growth curves (raw measurements or nonparametric fits) in a dataset, with replicates combined by the group averages (if <code>mean = TRUE</code>) or not (<code>mean = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

rnd.data &lt;- list()
rnd.data[["time"]] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[["data"]] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "s",
                       ec50 = FALSE,
                       export.res = FALSE,
                       suppress.messages = TRUE,
                       parallelize = FALSE)


plot.grid(res, param = "mu.spline")

</code></pre>

<hr>
<h2 id='plot.grodata'>Generic plot function for <code>grodata</code> objects. Plots raw growth, fluorescence, or normalized fluorescence data of multiple samples or conditions.</h2><span id='topic+plot.grodata'></span>

<h3>Description</h3>

<p><code>plot.grodata</code> calls <code><a href="#topic+plot.grofit">plot.grofit</a></code> or <code><a href="#topic+plot.flFitRes">plot.flFitRes</a></code> based on the chosen <code>data.type</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grodata'
plot(
  x,
  data.type = c("growth", "fl", "norm.fl"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  mean = TRUE,
  exclude.nm = NULL,
  exclude.conc = NULL,
  log.y = FALSE,
  n.ybreaks = 6,
  colors = NULL,
  color_groups = TRUE,
  group_pals = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red",
    "Cyan", "Brown", "Mint"),
  basesize = 20,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  lwd = 1.1,
  legend.position = "bottom",
  legend.ncol = 2,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.grodata_+3A_x">x</code></td>
<td>
<p>A <code>grodata</code> object created with <code><a href="#topic+read_data">read_data</a></code> or <code><a href="#topic+parse_data">parse_data</a></code>.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_data.type">data.type</code></td>
<td>
<p>(Character) Plot either raw growth (<code>data.type = "growth"</code>), raw fluorescence (<code>data.type = "fl"</code>), or fluorescence normalized to growth (<code>data.type = "norm.fl"</code>).</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_mean">mean</code></td>
<td>
<p>(Logical) Display the mean and standard deviation of groups with replicates (<code>TRUE</code>) or plot each sample individually (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_colors">colors</code></td>
<td>
<p>(vector of strings) Define a color palette used to draw the plots. If <code>NULL</code>, default palettes are chosen based on the number of groups/samples within the plot. Note: The number of provided colors should at least match the number of groups/samples.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_color_groups">color_groups</code></td>
<td>
<p>(Logical) Shall samples within the same group but with different concentrations be shown in different shades of the same color?</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_group_pals">group_pals</code></td>
<td>
<p>(String vector) Define the colors used to display sample groups with identical concentrations. The number of selected color palettes must be at least the number of displayed groups. The order of the chosen palettes corresponds to the oder of conditions in the legend. Available options: &quot;Green&quot;, &quot;Oranges&quot;, &quot;Purple&quot;, &quot;Cyan&quot;, &quot;Grey&quot;, &quot;Red&quot;, &quot;Blue&quot;, and &quot;Magenta&quot;.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth curve plot.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual plots.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_legend.position">legend.position</code></td>
<td>
<p>(Character) Position of the legend. One of &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p>(Numeric) Number of columns in the legend.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.grodata_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with all growth curves (raw measurements) in a dataset, with replicates combined by the group averages (if <code>mean = TRUE</code>) or not (<code>mean = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data sets
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

# Create dataframe with both data sets and a single time vector
time &lt;- as.data.frame(matrix(t(c("Time",NA,NA, rnd.data1$time[1,])),nrow=1),
             stringsAsFactors=FALSE)
colnames(time) &lt;- colnames(rnd.data1$data)
data &lt;- rbind(time, rnd.data1$data, rnd.data2$data)


# Create a grodata object
grodata &lt;- read_data(data.growth = data, data.format = "row")

plot(grodata, exclude.nm = "Test1", legend.ncol = 4)

</code></pre>

<hr>
<h2 id='plot.grofit'>Generic plot function for <code>grofit</code> objects. Combine different groups of samples into a single plot</h2><span id='topic+plot.grofit'></span>

<h3>Description</h3>

<p><code>plot.grofit</code> extracts the spline fits of a subset of samples in a <code>grofit</code> object calculates averages and standard deviations of conditions with replicates and combines them into a single plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'grofit'
plot(
  x,
  ...,
  data.type = c("spline", "raw"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  exclude.nm = NULL,
  exclude.conc = NULL,
  mean = TRUE,
  log.y = TRUE,
  deriv = TRUE,
  n.ybreaks = 6,
  colors = NULL,
  color_groups = TRUE,
  group_pals = c("Green", "Orange", "Purple", "Magenta", "Grey", "Blue", "Grey", "Red",
    "Cyan", "Brown", "Mint"),
  basesize = 20,
  y.lim = NULL,
  x.lim = NULL,
  y.title = NULL,
  x.title = NULL,
  y.lim.deriv = NULL,
  y.title.deriv = NULL,
  lwd = 1.1,
  legend.position = "bottom",
  legend.ncol = 2,
  plot = TRUE,
  export = FALSE,
  height = NULL,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.grofit_+3A_x">x</code></td>
<td>
<p>A <code>grofit</code> object created with <code><a href="#topic+growth.workflow">growth.workflow</a></code> containing spline fits.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_...">...</code></td>
<td>
<p>(<em>optional</em>) Additional <code>grofit</code> objects created in separate workflows for joint plotting in a single graph.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_data.type">data.type</code></td>
<td>
<p>(Character) Plot either raw data (<code>data.type = "raw"</code>) or the spline fit results</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_mean">mean</code></td>
<td>
<p>(Logical) Display the mean and standard deviation of groups with replicates (<code>TRUE</code>) or plot each sample individually (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_log.y">log.y</code></td>
<td>
<p>(Logical) Log-transform the y-axis of the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_deriv">deriv</code></td>
<td>
<p>(Logical) Show derivatives over time in a separate panel below the plot (<code>TRUE</code>) or not (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_n.ybreaks">n.ybreaks</code></td>
<td>
<p>(Numeric) Number of breaks on the y-axis. The breaks are generated using <code>scales::pretty_breaks</code>. Thus, the final number of breaks can deviate from the user input.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_colors">colors</code></td>
<td>
<p>(vector of strings) Define a color palette used to draw the plots. If <code>NULL</code>, default palettes are chosen based on the number of groups/samples within the plot. Note: The number of provided colors should at least match the number of groups/samples.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_color_groups">color_groups</code></td>
<td>
<p>(Logical) Shall samples within the same group but with different concentrations be shown in different shades of the same color?</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_group_pals">group_pals</code></td>
<td>
<p>(String vector) Define the colors used to display sample groups with identical concentrations. The number of selected color palettes must be at least the number of displayed groups. The order of the chosen palettes corresponds to the oder of conditions in the legend. Available options: &quot;Green&quot;, &quot;Oranges&quot;, &quot;Purple&quot;, &quot;Cyan&quot;, &quot;Grey&quot;, &quot;Red&quot;, &quot;Blue&quot;, and &quot;Magenta&quot;.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_y.lim">y.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the y-axis of the growth curve plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_x.lim">x.lim</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds of the x-axis of both growth curve and derivative plots as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_y.title">y.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the growth curve plot.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_x.title">x.title</code></td>
<td>
<p>(Character) Optional: Provide a title for the x-axis of both growth curve and derivative plots.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_y.lim.deriv">y.lim.deriv</code></td>
<td>
<p>(Numeric vector with two elements) Optional: Provide the lower (<code>l</code>) and upper (<code>u</code>) bounds on the y-axis of the derivative plot as a vector in the form <code>c(l, u)</code>. If only the lower or upper bound should be fixed, provide <code>c(l, NA)</code> or <code>c(NA, u)</code>, respectively.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_y.title.deriv">y.title.deriv</code></td>
<td>
<p>(Character) Optional: Provide a title for the y-axis of the derivative plot.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_lwd">lwd</code></td>
<td>
<p>(Numeric) Line width of the individual plots.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_legend.position">legend.position</code></td>
<td>
<p>(Character) Position of the legend. One of &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p>(Numeric) Number of columns in the legend.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.grofit_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot with all growth curves (raw measurements or nonparametric fits) in a dataset, with replicates combined by the group averages (if <code>mean = TRUE</code>) or not (<code>mean = FALSE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

rnd.data &lt;- list()
rnd.data[["time"]] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[["data"]] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "s",
                       ec50 = FALSE,
                       export.res = FALSE,
                       suppress.messages = TRUE,
                       parallelize = FALSE)


plot(res, names = "Test1", legend.ncol = 4) # Show only samples for condition "Test1"

</code></pre>

<hr>
<h2 id='plot.parameter'>Compare growth parameters between samples or conditions</h2><span id='topic+plot.parameter'></span>

<h3>Description</h3>

<p><code>plot.parameter</code> gathers physiological parameters from the results of a growth fit analysis and compares a chosen parameter between each sample or condition in a column plot. Error bars represent the 95% confidence interval (only shown for &gt; 2 replicates).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parameter'
plot(
  x,
  param = c("mu.linfit", "lambda.linfit", "dY.linfit", "A.linfit", "mu2.linfit",
    "lambda2.linfit", "mu.model", "lambda.model", "A.model", "A.orig.model", "dY.model",
    "dY.orig.model", "tD.linfit", "tD2.linfit", "tD.spline", "tD2.spline", "mu.spline",
    "lambda.spline", "A.spline", "dY.spline", "integral.spline", "mu2.spline",
    "lambda2.spline", "mu.bt", "lambda.bt", "A.bt", "integral.bt", "max_slope.linfit",
    "max_slope.spline"),
  IDs = NULL,
  names = NULL,
  conc = NULL,
  exclude.nm = NULL,
  exclude.conc = NULL,
  reference.nm = NULL,
  reference.conc = NULL,
  order_by_conc = FALSE,
  colors = NULL,
  basesize = 12,
  label.size = NULL,
  shape.size = 2.5,
  legend.position = "right",
  legend.ncol = 1,
  plot = TRUE,
  export = FALSE,
  height = 7,
  width = NULL,
  out.dir = NULL,
  out.nm = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.parameter_+3A_x">x</code></td>
<td>
<p>A <code>grofit</code>, <code>gcFit</code>, or <code>gcTable</code> object obtained with <code><a href="#topic+growth.workflow">growth.workflow</a></code> or <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_param">param</code></td>
<td>
<p>(Character) The parameter used to compare different sample groups. Any name of a column containing numeric values in <code>gcTable</code> (which is stored within <code>grofit</code> or <code>gcFit</code> objects) can be used as input. Useful options are:
'mu.linfit', 'lambda.linfit', 'dY.linfit', 'A.linfit',
'mu.model', 'lambda.model', 'A.model',
'mu.spline', 'lambda.spline', 'A.spline', 'dY.spline', 'integral.spline',
'mu.bt', 'lambda.bt', 'A.bt', 'integral.bt'</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_ids">IDs</code></td>
<td>
<p>(String or vector of strings) Define samples or groups (if <code>mean = TRUE</code>) to combine into a single plot based on exact matches with entries in the <code>label</code> or <code>condition</code> columns of <code>grofit$expdesign</code>.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_names">names</code></td>
<td>
<p>(String or vector of strings) Define groups to combine into a single plot. Partial matches with sample/group names are accepted. If <code>NULL</code>, all samples are considered. Note: Ensure to use unique substrings to extract groups of interest. If the name of one condition is included in its entirety within the name of other conditions, it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_conc">conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to combine into a single plot. If <code>NULL</code>, all concentrations are considered. Note: Ensure to use unique concentration values to extract groups of interest. If the concentration value of one condition is included in its entirety within the name of other conditions (e.g., the dataset contains '1', '10', and '100', <code>code = 10</code> will select both '10 and '100'), it cannot be extracted individually.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_exclude.nm">exclude.nm</code></td>
<td>
<p>(String or vector of strings) Define groups to exclude from the plot. Partial matches with sample/group names are accepted.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_exclude.conc">exclude.conc</code></td>
<td>
<p>(Numeric or numeric vector) Define concentrations to exclude from the plot.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_reference.nm">reference.nm</code></td>
<td>
<p>(Character) Name of the reference condition, to which parameter values are normalized. Partially matching strings are tolerated as long as they can uniquely identify the condition.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_reference.conc">reference.conc</code></td>
<td>
<p>(Numeric) Concentration of the reference condition, to which parameter values are normalized.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_order_by_conc">order_by_conc</code></td>
<td>
<p>(Logical) Shall the columns be sorted in order of ascending concentrations (<code>TRUE</code>) or by sample groups <code>FALSE</code>?</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_colors">colors</code></td>
<td>
<p>(vector of strings) Define a color palette used to draw the columns. If <code>NULL</code>, default palettes are chosen. Note: The number of provided colors should at least match the number of groups.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_basesize">basesize</code></td>
<td>
<p>(Numeric) Base font size.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_label.size">label.size</code></td>
<td>
<p>(Numeric) Font size for sample labels below x-axis.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_shape.size">shape.size</code></td>
<td>
<p>(Numeric) The size of the symbols indicating replicate values. Default: 2.5</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_legend.position">legend.position</code></td>
<td>
<p>(Character) Position of the legend. One of &quot;bottom&quot;, &quot;top&quot;, &quot;left&quot;, &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_legend.ncol">legend.ncol</code></td>
<td>
<p>(Numeric) Number of columns in the legend.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_plot">plot</code></td>
<td>
<p>(Logical) Show the generated plot in the <code>Plots</code> pane (<code>TRUE</code>) or not (<code>FALSE</code>). If <code>FALSE</code>, a ggplot object is returned.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_export">export</code></td>
<td>
<p>(Logical) Export the generated plot as PDF and PNG files (<code>TRUE</code>) or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_height">height</code></td>
<td>
<p>(Numeric) Height of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_width">width</code></td>
<td>
<p>(Numeric) Width of the exported image in inches.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_out.dir">out.dir</code></td>
<td>
<p>(Character) Name or path to a folder in which the exported files are stored. If <code>NULL</code>, a &quot;Plots&quot; folder is created in the current working directory to store the files in.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_out.nm">out.nm</code></td>
<td>
<p>(Character) The name of the PDF and PNG files if <code>export = TRUE</code>. If <code>NULL</code>, a name will be automatically generated including the chosen parameter.</p>
</td></tr>
<tr><td><code id="plot.parameter_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A column plot comparing a selected growth parameter between tested conditions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = "Test2")

rnd.data &lt;- list()
rnd.data[["time"]] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[["data"]] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "s",
                       ec50 = FALSE,
                       export.res = FALSE,
                       parallelize = FALSE,
                       suppress.messages = TRUE)


plot.parameter(res,
               param = "mu.spline",
               legend.ncol = 4,
               legend.position = "bottom",
               basesize = 15,
               label.size = 11)

</code></pre>

<hr>
<h2 id='QurvE-package'>QurvE: Robust and User-Friendly Analysis of Growth and Fluorescence Curves</h2><span id='topic+QurvE'></span><span id='topic+QurvE-package'></span>

<h3>Description</h3>

<p>High-throughput analysis of growth curves and fluorescence data using three methods: linear regression, growth model fitting, and smooth spline fit. Analysis of dose-response relationships via smoothing splines or dose-response models. Complete data analysis workflows can be executed in a single step via user-friendly wrapper functions. The results of these workflows are summarized in detailed reports as well as intuitively navigable 'R' data containers. A 'shiny' application provides access to all features without requiring any programming knowledge. The package is described in further detail in Wirth et al. (2023) <a href="https://doi.org/10.1038/s41596-023-00850-7">doi:10.1038/s41596-023-00850-7</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicolas T. Wirth <a href="mailto:mail.nicowirth@gmail.com">mail.nicowirth@gmail.com</a> (<a href="https://orcid.org/0000-0003-0799-1321">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Jonathan Funk <a href="mailto:funk.jonathan21@gmail.com">funk.jonathan21@gmail.com</a> (Co-developer of shiny app.)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Matthias Kahm (Author of 'grofit' package, whose general data structure was adopted for QurvE.) [contributor]
</p>
</li>
<li><p> Maik Kschischo (Author of 'grofit' package, whose general data structure was adopted for QurvE.) [contributor]
</p>
</li>
<li><p> Thomas Petzoldt <a href="mailto:thomas.petzoldt@tu-dresden.de">thomas.petzoldt@tu-dresden.de</a> (<a href="https://orcid.org/0000-0002-4951-6468">ORCID</a>) (Creator of the package 'growthrates', whose function for calculating linear regressions served as a template in QurvE.) [contributor]
</p>
</li>
<li><p> Andrew Stein <a href="mailto:andy.stein@gmail.com">andy.stein@gmail.com</a> (Creator of 'xgxr' package from which QurvE adopted code to plot axis ticks on log10 scale.) [contributor]
</p>
</li>
<li><p> Michael W. Kearney <a href="mailto:kearneymw@missouri.edu">kearneymw@missouri.edu</a> (Creator of 'tfse' package from which QurvE adopted the match_arg function.) [contributor]
</p>
</li>
<li><p> Santiago I. Hurtado <a href="mailto:santih@carina.fcaglp.unlp.edu.ar">santih@carina.fcaglp.unlp.edu.ar</a> (Creator of 'RobustLinearReg' package from which QurvE adopted the Theil Sehn Regression method.) [contributor]
</p>
</li>
<li><p> Mark Heckmann (Creator of the 'zipFastener' function; source: https://ryouready.wordpress.com/2009/03/27/r-zip-fastener-for-two-data-frames-combining-rows-or-columns-of-two-dataframes-in-an-alternating-manner/) [contributor]
</p>
</li>
<li><p> Nicholas Hamilton (Creator of the 'colFmt' function.) [contributor]
</p>
</li>
<li><p> Evan Friedland (Creator of the 'inflect' function.) [contributor]
</p>
</li>
<li><p> Heather Turner (Creator of the 'base_breaks' function.) [contributor]
</p>
</li>
<li><p> Georgi N. Boshnakov <a href="mailto:georgi.boshnakov@manchester.ac.uk">georgi.boshnakov@manchester.ac.uk</a> (Creator of 'gbRd' package from which functions are used to display function help pages within the shiny app.) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/NicWir/QurvE">https://github.com/NicWir/QurvE</a>
</p>
</li>
<li> <p><a href="https://nicwir.github.io/QurvE/">https://nicwir.github.io/QurvE/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/NicWir/QurvE/issues">https://github.com/NicWir/QurvE/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rdm.data'>The function calls the <code>baranyi</code> function to generate curves between time zero and <code>t</code> and adds some random noise to the x- and y-axes. The three growth parameters given as input values will be slightly changed to produce different growth curves. The resulting datasets can be used to test the <code><a href="#topic+growth.workflow">growth.workflow</a></code> function.</h2><span id='topic+rdm.data'></span>

<h3>Description</h3>

<p>The function calls the <code>baranyi</code> function to generate curves between time zero and <code>t</code> and adds some random noise to the x- and y-axes. The three growth parameters given as input values will be slightly changed to produce different growth curves. The resulting datasets can be used to test the <code><a href="#topic+growth.workflow">growth.workflow</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdm.data(d, y0 = 0.05, tmax = 24, mu = 0.6, lambda = 5, A = 3, label = "Test1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdm.data_+3A_d">d</code></td>
<td>
<p>Numeric value, number of data sets. If <code>d</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_y0">y0</code></td>
<td>
<p>Numeric value, start growth. If <code>t</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_tmax">tmax</code></td>
<td>
<p>Numeric value, number of time points per data set. If <code>t</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_mu">mu</code></td>
<td>
<p>Numeric value, maximum slope. If <code>mu</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_lambda">lambda</code></td>
<td>
<p>Numeric value, lag-phase. If <code>lambda</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_a">A</code></td>
<td>
<p>Numeric value, maximum growth. If <code>A</code> is a vector, only the first entry is used.</p>
</td></tr>
<tr><td><code id="rdm.data_+3A_label">label</code></td>
<td>
<p>Character string, condition label  If <code>label</code> is a vector, only the first entry is used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing simulated data for three tests (e.g., 'organisms'):
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>numeric matrix of size <code>d</code>x<code>t</code>, each row represent the time points for which growth data is simulated and stored in each row of <code>data</code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data.frame of size <code>d</code>x(3+<code>t</code>), 1. column, character as an experiment identifier; 2. column: Replicate number; 3. column: concentration of substrate of a compound under which the experiment is obtained; 4.-(3+t). column: growth data corresponding to the time points in <code>time</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Matthias Kahm, Guido Hasenbrink, Hella Lichtenberg-Frate, Jost Ludwig, Maik Kschischo (2010). <em>grofit: Fitting Biological Growth Curves with R</em>. Journal of Statistical Software, 33(7), 1-21. DOI: 10.18637/jss.v033.i07
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

rnd.data &lt;- list()
rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = 's',
                                                suppress.messages = TRUE))


# Perform dose-response analysis
drFit &lt;- growth.drFit(gcTable = gcFit$gcTable,
             control = growth.control(dr.parameter = 'mu.spline'))

# Inspect results
summary(drFit)
plot(drFit)


</code></pre>

<hr>
<h2 id='read_data'>Read growth and fluorescence data in table format</h2><span id='topic+read_data'></span>

<h3>Description</h3>

<p><code>read_data</code> reads table files or R dataframe objects containing growth and fluorescence data and extracts datasets, sample and group information, performs blank correction, applies data transformation (calibration), and combines technical replicates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_data(
  data.growth = NA,
  data.fl = NA,
  data.fl2 = NA,
  data.format = "col",
  csvsep = ";",
  dec = ".",
  csvsep.fl = ";",
  dec.fl = ".",
  csvsep.fl2 = ";",
  dec.fl2 = ".",
  sheet.growth = 1,
  sheet.fl = 1,
  sheet.fl2 = 1,
  fl.normtype = c("growth", "fl2"),
  subtract.blank = TRUE,
  convert.time = NULL,
  calib.growth = NULL,
  calib.fl = NULL,
  calib.fl2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_data_+3A_data.growth">data.growth</code></td>
<td>
<p>An R dataframe object or a table file with extension '.xlsx', '.xls', '.csv', '.tsv', or '.txt' containing growth data. The data must be either in the '<code>QurvE</code> custom layout' or in 'tidy' (long) format.
The first three table rows in the 'custom <code>QurvE</code> layout' contain:
</p>

<ol>
<li><p> Sample description
</p>
</li>
<li><p> Replicate number (<em>optional</em>: followed by a letter to indicate technical replicates)
</p>
</li>
<li><p> Concentration value (<em>optional</em>)
</p>
</li></ol>

<p>Data in 'tidy' format requires the following column headers:
</p>

<ol>
<li><p> &quot;Time&quot;: time values
</p>
</li>
<li><p> &quot;Description&quot;: sample description
</p>
</li>
<li><p> &quot;Replicate&quot;: replicate number (<em>optional</em>)
</p>
</li>
<li><p> &quot;Concentration&quot;: concentration value (<em>optional</em>)
</p>
</li>
<li><p> &quot;Values&quot;: growth values (e.g., optical density)
</p>
</li></ol>
</td></tr>
<tr><td><code id="read_data_+3A_data.fl">data.fl</code></td>
<td>
<p>(optional) An R dataframe object or a table file with extension '.xlsx', '.xls', '.csv', '.tsv', or '.txt' containing fluorescence data. Table layout must mimic that of <code>data.growth</code>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_data.fl2">data.fl2</code></td>
<td>
<p>(optional) An R dataframe object or a table file with extension '.xlsx', '.xls', '.csv', '.tsv', or '.txt' containing measurements from a second fluorescence channel (used only to normalize <code>fluorescence</code> data). Table layout must mimic that of <code>data.growth</code>.</p>
</td></tr>
<tr><td><code id="read_data_+3A_data.format">data.format</code></td>
<td>
<p>(Character) &quot;col&quot; for samples in columns, or &quot;row&quot; for samples in rows. Default: <code>"col"</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_csvsep">csvsep</code></td>
<td>
<p>(Character) separator used in CSV file storing growth data (ignored for other file types). Default: <code>";"</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_dec">dec</code></td>
<td>
<p>(Character) decimal separator used in CSV, TSV or TXT file storing growth data. Default: <code>"."</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_csvsep.fl">csvsep.fl</code>, <code id="read_data_+3A_csvsep.fl2">csvsep.fl2</code></td>
<td>
<p>(Character) separator used in CSV file storing fluorescence data (ignored for other file types). Default: <code>";"</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_dec.fl">dec.fl</code>, <code id="read_data_+3A_dec.fl2">dec.fl2</code></td>
<td>
<p>(Character) decimal separator used in CSV, TSV or TXT file storing fluorescence data. Default: <code>"."</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_sheet.growth">sheet.growth</code>, <code id="read_data_+3A_sheet.fl">sheet.fl</code>, <code id="read_data_+3A_sheet.fl2">sheet.fl2</code></td>
<td>
<p>(Numeric or Character) Number or name of the sheet with the respective data type in XLS or XLSX files (<em>optional</em>).</p>
</td></tr>
<tr><td><code id="read_data_+3A_fl.normtype">fl.normtype</code></td>
<td>
<p>(Character string) Normalize fluorescence values by either diving by <code>'growth'</code> or by fluorescence2 values (<code>'fl2'</code>).</p>
</td></tr>
<tr><td><code id="read_data_+3A_subtract.blank">subtract.blank</code></td>
<td>
<p>(Logical) Shall blank values be subtracted from values within the same experiment (<a href="base.html#topic+TRUE">TRUE</a>, the default) or not (<a href="base.html#topic+FALSE">FALSE</a>).</p>
</td></tr>
<tr><td><code id="read_data_+3A_convert.time">convert.time</code></td>
<td>
<p>(<code>NULL</code> or string) Convert time values with a formula provided in the form <code>'y = function(x)'</code>.
For example: <code>convert.time = 'y = 24 * x'</code></p>
</td></tr>
<tr><td><code id="read_data_+3A_calib.growth">calib.growth</code>, <code id="read_data_+3A_calib.fl">calib.fl</code>, <code id="read_data_+3A_calib.fl2">calib.fl2</code></td>
<td>
<p>(Character or <code>NULL</code>) Provide an equation in the form 'y = function(x)' (for example: 'y = x^2 * 0.3 - 0.5') to convert growth and fluorescence values. This can be used to, e.g., convert plate reader absorbance values into OD<sub>600</sub> or fluorescence intensity into molecule concentrations.
Caution!: When utilizing calibration, carefully consider whether or not blanks were subtracted to determine the calibration before selecting the input <code>subtract.blank = TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><img src="../help/figures/Data-layout.jpg" alt="Data-layout.jpg" />
</p>


<h3>Value</h3>

<p>An R list object of class <code>grodata</code> containing a <code>time</code> matrix, dataframes with growth and fluorescence data (if applicable),
and an experimental design table. The <code>grodata</code> object can be directly
used to run <code><a href="#topic+growth.workflow">growth.workflow</a></code>/<code><a href="#topic+fl.workflow">fl.workflow</a></code> or, together with a <code>growth.control</code>/<code>fl.control</code>
object, in <code><a href="#topic+growth.gcFit">growth.gcFit</a></code>/<code><a href="#topic+flFit">flFit</a></code>.
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Matrix with raw time values extracted from <code>data.growth</code>.</p>
</td></tr>
<tr><td><code>growth</code></td>
<td>
<p>Dataframe with raw growth values and sample identifiers extracted from <code>data.growth</code>.</p>
</td></tr>
<tr><td><code>fluorescence</code></td>
<td>
<p>Dataframe with raw fluorescence values and sample identifiers extracted from <code>data.fl</code>. <code>NA</code>, if no fluorescence data is provided.</p>
</td></tr>
<tr><td><code>norm.fluorescence</code></td>
<td>
<p>fluorescence data divided by growth values. <code>NA</code>, if no fluorescence data is provided.</p>
</td></tr>
<tr><td><code>expdesign</code></td>
<td>
<p>Experimental design table created from the first three identifier rows/columns (see argument <code>data.format</code>) (<code>data.growth</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load CSV file containing only growth data
data_growth &lt;- read_data(data.growth = system.file("2-FMA_toxicity.csv",
                         package = "QurvE"), csvsep = ";" )

# Load XLS file containing both growth and fluorescence data
data_growth_fl &lt;- read_data(
                    data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                    data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                    csvsep = "\t",
                    csvsep.fl = "\t")
</code></pre>

<hr>
<h2 id='read_file'>Call the appropriate function required to read a table file and return the table as a dataframe object.</h2><span id='topic+read_file'></span>

<h3>Description</h3>

<p><code>read_file</code> automatically detects the format of a file provided as <code>filename</code> and calls the appropriate function to read the table file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_file(filename, csvsep = ";", dec = ".", sheet = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_file_+3A_filename">filename</code></td>
<td>
<p>(Character) Name or path of the table file to read. Can be of type CSV, XLS, XLSX, TSV, or TXT.</p>
</td></tr>
<tr><td><code id="read_file_+3A_csvsep">csvsep</code></td>
<td>
<p>(Character) separator used in CSV file (ignored for other file types).</p>
</td></tr>
<tr><td><code id="read_file_+3A_dec">dec</code></td>
<td>
<p>(Character) decimal separator used in CSV, TSV and TXT files.</p>
</td></tr>
<tr><td><code id="read_file_+3A_sheet">sheet</code></td>
<td>
<p>(Numeric or Character) Number or name of a sheet in XLS or XLSX files (<em>optional</em>). Default: <code>";"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe object with headers in the first row.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input &lt;- read_file(filename = system.file("2-FMA_toxicity.csv", package = "QurvE"), csvsep = ";" )

</code></pre>

<hr>
<h2 id='run_app'>Run Shiny QurvE App</h2><span id='topic+run_app'></span>

<h3>Description</h3>

<p>Run Shiny QurvE App
</p>


<h3>Usage</h3>

<pre><code class='language-R'>run_app()
</code></pre>


<h3>Value</h3>

<p>Launches a browser with the shiny app
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
# Run the app
run_app()
}
</code></pre>

<hr>
<h2 id='summary.drBootSpline'>Generic summary function for drBootSpline objects</h2><span id='topic+summary.drBootSpline'></span>

<h3>Description</h3>

<p>Generic summary function for drBootSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drBootSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drBootSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>drBootSpline</code></p>
</td></tr>
<tr><td><code id="summary.drBootSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with statistical parameters extracted from the dose-response bootstrapping analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+stats::rnorm(19)/50, 0)

TestRun &lt;- growth.drBootSpline(conc, response, drID = 'test',
        control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8, nboot.dr = 50))

print(summary(TestRun))

</code></pre>

<hr>
<h2 id='summary.drFit'>Generic summary function for drFit objects</h2><span id='topic+summary.drFit'></span>

<h3>Description</h3>

<p>Generic summary function for drFit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drFit_+3A_object">object</code></td>
<td>
<p>object of class <code>drFit</code></p>
</td></tr>
<tr><td><code id="summary.drFit_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters for all samples extracted from the dose-response analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

rnd.data &lt;- list()
rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = 's',
                                                suppress.messages = TRUE))

# Perform dose-response analysis
drFit &lt;- growth.drFit(gcTable = gcFit$gcTable,
                 control = growth.control(dr.parameter = 'mu.spline'))

# Inspect results
summary(drFit)

</code></pre>

<hr>
<h2 id='summary.drFitfl'>Generic summary function for drFitfl objects</h2><span id='topic+summary.drFitfl'></span>

<h3>Description</h3>

<p>Generic summary function for drFitfl objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitfl'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drFitfl_+3A_object">object</code></td>
<td>
<p>object of class <code>drFitfl</code></p>
</td></tr>
<tr><td><code id="summary.drFitfl_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters for all samples extracted from a dose-response analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Define fit controls
control &lt;- fl.control(fit.opt = 's',
             x_type = 'time', norm_fl = TRUE,
             dr.parameter = 'max_slope.spline',
             dr.method = 'model',
             suppress.messages = TRUE)

# Run curve fitting workflow
res &lt;- flFit(fl_data = input$norm.fluorescence,
             time = input$time,
             parallelize = FALSE,
             control = control)

# Perform dose-response analysis with biosensor model
drFitfl &lt;- fl.drFit(flTable = res$flTable, control = control)

summary(drFitfl)

</code></pre>

<hr>
<h2 id='summary.drFitFLModel'>Generic summary function for drFitFLModel objects</h2><span id='topic+summary.drFitFLModel'></span>

<h3>Description</h3>

<p>Generic summary function for drFitFLModel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitFLModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drFitFLModel_+3A_object">object</code></td>
<td>
<p>object of class <code>drFitModel</code></p>
</td></tr>
<tr><td><code id="summary.drFitFLModel_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with biosensor response parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create concentration values via a serial dilution
conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)

# Simulate response values via biosensor equation
response &lt;- biosensor.eq(conc, y.min = 110, y.max = 6000, K = 0.5, n = 2) +
            0.01*6000*rnorm(10)

# Perform fit
TestRun &lt;- fl.drFitModel(conc, response, drID = 'test', control = fl.control())

print(summary(TestRun))

</code></pre>

<hr>
<h2 id='summary.drFitModel'>Generic summary function for drFitModel objects</h2><span id='topic+summary.drFitModel'></span>

<h3>Description</h3>

<p>Generic summary function for drFitModel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drFitModel_+3A_object">object</code></td>
<td>
<p>object of class <code>drFitModel</code></p>
</td></tr>
<tr><td><code id="summary.drFitModel_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from the dose-response analysis of a single sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+rnorm(19)/50, 0)

TestRun &lt;- growth.drFitModel(conc, response, drID = 'test')

print(summary(TestRun))

</code></pre>

<hr>
<h2 id='summary.drFitSpline'>Generic summary function for drFitSpline objects</h2><span id='topic+summary.drFitSpline'></span>

<h3>Description</h3>

<p>Generic summary function for drFitSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'drFitSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.drFitSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>drFitSpline</code></p>
</td></tr>
<tr><td><code id="summary.drFitSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from the dose-response analysis of a single sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>conc &lt;- c(0, rev(unlist(lapply(1:18, function(x) 10*(2/3)^x))),10)
response &lt;- c(1/(1+exp(-0.7*(4-conc[-20])))+rnorm(19)/50, 0)

TestRun &lt;- growth.drFitSpline(conc, response, drID = 'test',
              control = growth.control(log.x.dr = TRUE, smooth.dr = 0.8))

print(summary(TestRun))

</code></pre>

<hr>
<h2 id='summary.flBootSpline'>Generic summary function for flBootSpline objects</h2><span id='topic+summary.flBootSpline'></span>

<h3>Description</h3>

<p>Generic summary function for flBootSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flBootSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flBootSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>flBootSpline</code></p>
</td></tr>
<tr><td><code id="summary.flBootSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with statistical parameters extracted from a dose-response bootstrapping analysis.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flBootSpline(time = time,
                       fl_data = data,
                       ID = 'TestFit',
                       control = fl.control(fit.opt = 's', x_type = 'time',
                       nboot.fl = 50))

summary(TestFit)
</code></pre>

<hr>
<h2 id='summary.flFit'>Generic summary function for flFit objects</h2><span id='topic+summary.flFit'></span>

<h3>Description</h3>

<p>Generic summary function for flFit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flFit_+3A_object">object</code></td>
<td>
<p>object of class <code>flFit</code></p>
</td></tr>
<tr><td><code id="summary.flFit_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from all fits of a workflow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run curve fitting workflow
res &lt;- flFit(fl_data = input$norm.fluorescence,
             time = input$time,
             parallelize = FALSE,
             control = fl.control(fit.opt = 's', suppress.messages = TRUE,
             x_type = 'time', norm_fl = TRUE, nboot.fl = 20))

summary(res)

</code></pre>

<hr>
<h2 id='summary.flFitLinear'>Generic summary function for flFitLinear objects</h2><span id='topic+summary.flFitLinear'></span>

<h3>Description</h3>

<p>Generic summary function for flFitLinear objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFitLinear'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flFitLinear_+3A_object">object</code></td>
<td>
<p>object of class <code>flFitLinear</code></p>
</td></tr>
<tr><td><code id="summary.flFitLinear_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from a linear fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitLinear(time = time,
                       fl_data = data,
                       ID = 'TestFit',
                       control = fl.control(fit.opt = 'l', x_type = 'time',
                       lin.R2 = 0.95, lin.RSD = 0.1,
                       lin.h = 20))

summary(TestFit)
</code></pre>

<hr>
<h2 id='summary.flFitSpline'>Generic summary function for flFitSpline objects</h2><span id='topic+summary.flFitSpline'></span>

<h3>Description</h3>

<p>Generic summary function for flFitSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'flFitSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.flFitSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>flFitSpline</code></p>
</td></tr>
<tr><td><code id="summary.flFitSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from a nonparametric fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Extract time and normalized fluorescence data for single sample
time &lt;- input$time[4,]
data &lt;- input$norm.fluorescence[4,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- flFitSpline(time = time,
                       fl_data = data,
                       ID = 'TestFit',
                       control = fl.control(fit.opt = 's', x_type = 'time'))

summary(TestFit)
</code></pre>

<hr>
<h2 id='summary.gcBootSpline'>Generic summary function for gcBootSpline objects</h2><span id='topic+summary.gcBootSpline'></span>

<h3>Description</h3>

<p>Generic summary function for gcBootSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcBootSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcBootSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>gcBootSpline</code></p>
</td></tr>
<tr><td><code id="summary.gcBootSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with statistical parameters extracted from the spline fit bootstrapping computation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Introduce some noise into the measurements
data &lt;- data + stats::runif(97, -0.01, 0.09)

# Perform bootstrapping spline fit
TestFit &lt;- growth.gcBootSpline(time, data, gcID = 'TestFit',
              control = growth.control(fit.opt = 's', nboot.gc = 50))

summary(TestFit)

</code></pre>

<hr>
<h2 id='summary.gcFit'>Generic summary function for gcFit objects</h2><span id='topic+summary.gcFit'></span>

<h3>Description</h3>

<p>Generic summary function for gcFit objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcFit_+3A_object">object</code></td>
<td>
<p>object of class <code>gcFit</code></p>
</td></tr>
<tr><td><code id="summary.gcFit_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from all fits of a workflow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data1 &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')
rnd.data2 &lt;- rdm.data(d = 35, mu = 0.6, A = 4.5, label = 'Test2')

rnd.data &lt;- list()
rnd.data[['time']] &lt;- rbind(rnd.data1$time, rnd.data2$time)
rnd.data[['data']] &lt;- rbind(rnd.data1$data, rnd.data2$data)

# Run growth curve analysis workflow
gcFit &lt;- growth.gcFit(time = rnd.data$time,
                       data = rnd.data$data,
                       parallelize = FALSE,
                       control = growth.control(fit.opt = 's',
                                                suppress.messages = TRUE,
                                                nboot.gc = 20))
summary(gcFit)


</code></pre>

<hr>
<h2 id='summary.gcFitLinear'>Generic summary function for gcFitLinear objects</h2><span id='topic+summary.gcFitLinear'></span>

<h3>Description</h3>

<p>Generic summary function for gcFitLinear objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitLinear'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcFitLinear_+3A_object">object</code></td>
<td>
<p>object of class <code>gcFitLinear</code></p>
</td></tr>
<tr><td><code id="summary.gcFitLinear_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from the linear fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- growth.gcFitLinear(time, data, gcID = 'TestFit',
                 control = growth.control(fit.opt = 'l'))

summary(TestFit)

</code></pre>

<hr>
<h2 id='summary.gcFitModel'>Generic summary function for gcFitModel objects</h2><span id='topic+summary.gcFitModel'></span>

<h3>Description</h3>

<p>Generic summary function for gcFitModel objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitModel'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcFitModel_+3A_object">object</code></td>
<td>
<p>object of class <code>gcFitModel</code></p>
</td></tr>
<tr><td><code id="summary.gcFitModel_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from the growth model fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform parametric fit
TestFit &lt;- growth.gcFitModel(time, data, gcID = 'TestFit',
                 control = growth.control(fit.opt = 'm'))

summary(TestFit)

</code></pre>

<hr>
<h2 id='summary.gcFitSpline'>Generic summary function for gcFitSpline objects</h2><span id='topic+summary.gcFitSpline'></span>

<h3>Description</h3>

<p>Generic summary function for gcFitSpline objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gcFitSpline'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.gcFitSpline_+3A_object">object</code></td>
<td>
<p>object of class <code>gcFitSpline</code></p>
</td></tr>
<tr><td><code id="summary.gcFitSpline_+3A_...">...</code></td>
<td>
<p>Additional arguments. This has currently no effect and is only meant to fulfill the requirements of a generic function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with parameters extracted from the nonparametric fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth dataset
rnd.dataset &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = 'Test1')

# Extract time and growth data for single sample
time &lt;- rnd.dataset$time[1,]
data &lt;- rnd.dataset$data[1,-(1:3)] # Remove identifier columns

# Perform linear fit
TestFit &lt;- growth.gcFitSpline(time, data, gcID = 'TestFit',
                 control = growth.control(fit.opt = 's'))

summary(TestFit)

</code></pre>

<hr>
<h2 id='table_group_fluorescence_linear'>Generate a grouped results table for linear fits with average and standard deviations</h2><span id='topic+table_group_fluorescence_linear'></span>

<h3>Description</h3>

<p>Generate a grouped results table for linear fits with average and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_group_fluorescence_linear(flTable, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_group_fluorescence_linear_+3A_fltable">flTable</code></td>
<td>
<p>An object of class <code>flTable</code></p>
</td></tr>
<tr><td><code id="table_group_fluorescence_linear_+3A_html">html</code></td>
<td>
<p>(Logical) Should column headers contain html formatting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with grouped linear fit results. Empty cells indicate that no reliable fit could be determined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = "l",
                   x_type = "time", norm_fl = TRUE,
                   dr.parameter = "max_slope.spline",
                   suppress.messages = TRUE,
                   parallelize = FALSE)

table_group_fluorescence_linear(res$flFit$flTable)

# with HTML formatting
DT::datatable(table_group_fluorescence_linear(res$flFit$flTable, html = TRUE),
              escape = FALSE) # Do not escape HTML entities

</code></pre>

<hr>
<h2 id='table_group_fluorescence_spline'>Generate a grouped results table for spline fits with average and standard deviations</h2><span id='topic+table_group_fluorescence_spline'></span>

<h3>Description</h3>

<p>Generate a grouped results table for spline fits with average and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_group_fluorescence_spline(flTable, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_group_fluorescence_spline_+3A_fltable">flTable</code></td>
<td>
<p>An object of class <code>flTable</code></p>
</td></tr>
<tr><td><code id="table_group_fluorescence_spline_+3A_html">html</code></td>
<td>
<p>(Logical) Should column headers contain html formatting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with grouped spline fit results. Empty cells indicate that no reliable fit could be determined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
input &lt;- read_data(data.growth = system.file("lac_promoters_growth.txt", package = "QurvE"),
                   data.fl = system.file("lac_promoters_fluorescence.txt", package = "QurvE"),
                   csvsep = "\t",
                   csvsep.fl = "\t")

# Run workflow
res &lt;- fl.workflow(grodata = input, ec50 = FALSE, fit.opt = "s",
                   x_type = "time", norm_fl = TRUE,
                   dr.parameter = "max_slope.spline",
                   suppress.messages = TRUE,
                   parallelize = FALSE)

table_group_fluorescence_spline(res$flFit$flTable)

# with HTML formatting
DT::datatable(table_group_fluorescence_spline(res$flFit$flTable, html = TRUE),
              escape = FALSE) # Do not escape HTML entities

</code></pre>

<hr>
<h2 id='table_group_growth_linear'>Generate a grouped results table for linear fits with average and standard deviations</h2><span id='topic+table_group_growth_linear'></span>

<h3>Description</h3>

<p>Generate a grouped results table for linear fits with average and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_group_growth_linear(gcTable, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_group_growth_linear_+3A_gctable">gcTable</code></td>
<td>
<p>An object of class <code>gcTable</code></p>
</td></tr>
<tr><td><code id="table_group_growth_linear_+3A_html">html</code></td>
<td>
<p>(Logical) Should column headers contain html formatting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with grouped linear fit results. Empty cells indicate that no reliable fit could be determined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create random growth data set
rnd.data &lt;- rdm.data(d = 30, mu = 0.6, A = 4.5, label = "Test2")


# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "l",
                       ec50 = FALSE,
                       export.res = FALSE,
                       parallelize = FALSE,
                       suppress.messages = TRUE)

table_group_growth_linear(res$gcFit$gcTable)

# with HTML formatting
DT::datatable(table_group_growth_linear(res$gcFit$gcTable, html = TRUE),
              escape = FALSE) # Do not escape HTML entities

</code></pre>

<hr>
<h2 id='table_group_growth_model'>Generate a grouped results table for parametric fits with average and standard deviations</h2><span id='topic+table_group_growth_model'></span>

<h3>Description</h3>

<p>Generate a grouped results table for parametric fits with average and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_group_growth_model(gcTable, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_group_growth_model_+3A_gctable">gcTable</code></td>
<td>
<p>An object of class <code>gcTable</code></p>
</td></tr>
<tr><td><code id="table_group_growth_model_+3A_html">html</code></td>
<td>
<p>(Logical) Should column headers contain html formatting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with grouped model fit results. Empty cells indicate that no reliable fit could be determined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")


# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "m",
                       ec50 = FALSE,
                       export.res = FALSE,
                       parallelize = FALSE,
                       suppress.messages = TRUE)

table_group_growth_model(res$gcFit$gcTable)

# with HTML formatting
DT::datatable(table_group_growth_model(res$gcFit$gcTable, html = TRUE),
              escape = FALSE) # Do not escape HTML entities

</code></pre>

<hr>
<h2 id='table_group_growth_spline'>Generate a grouped results table for spline fits with average and standard deviations</h2><span id='topic+table_group_growth_spline'></span>

<h3>Description</h3>

<p>Generate a grouped results table for spline fits with average and standard deviations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>table_group_growth_spline(gcTable, html = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="table_group_growth_spline_+3A_gctable">gcTable</code></td>
<td>
<p>An object of class <code>gcTable</code></p>
</td></tr>
<tr><td><code id="table_group_growth_spline_+3A_html">html</code></td>
<td>
<p>(Logical) Should column headers contain html formatting?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with grouped spline fit results. Empty cells indicate that no reliable fit could be determined.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create random growth data set
rnd.data &lt;- rdm.data(d = 35, mu = 0.8, A = 5, label = "Test1")

# Run growth curve analysis workflow
res &lt;- growth.workflow(time = rnd.data$time,
                       data = rnd.data$data,
                       fit.opt = "s",
                       ec50 = FALSE,
                       export.res = FALSE,
                       parallelize = FALSE,
                       suppress.messages = TRUE)

table_group_growth_spline(res$gcFit$gcTable)

# with HTML formatting
DT::datatable(table_group_growth_spline(res$gcFit$gcTable, html = TRUE),
              escape = FALSE) # Do not escape HTML entities

</code></pre>

<hr>
<h2 id='tidy_to_custom'>Convert a tidy data frame to a custom QurvE format</h2><span id='topic+tidy_to_custom'></span>

<h3>Description</h3>

<p>This function converts a data frame in &quot;tidy&quot; format into the custom format used by QurvE (row format).
The provided &quot;tidy&quot; data has columns for &quot;Description&quot;, &quot;Concentration&quot;, &quot;Replicate&quot;, and &quot;Values&quot;, with one
row per time point and sample. Alternatively, the function converts data in custom QurvE column format into
row format (if <code>data.format = "col"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_to_custom(df, data.format = "col")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_to_custom_+3A_df">df</code></td>
<td>
<p>A data frame in tidy format, containing &quot;Time&quot;, &quot;Description&quot;, and either &quot;Values&quot; or &quot;Value&quot; columns. Optionally, meta information provided in columns &quot;Replicate&quot; and &quot;Concentration&quot; is used.</p>
</td></tr>
<tr><td><code id="tidy_to_custom_+3A_data.format">data.format</code></td>
<td>
<p>(Character string) <code>"col"</code> (the default) or <code>"row"</code>. Only relevant if data is not provided in &quot;tidy&quot; format but has been prepared into the custom QurvE data format.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame in the custom format (row format) used by QurvE.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a tidy data frame with two samples, five concentrations, three
# replicates, and five time points
samples &lt;- c("Sample 1", "Sample 2")
concentrations &lt;- c(0.1, 0.5, 1, 2, 5)
time_points &lt;- c(1, 2, 3, 4, 5)
n_replicates &lt;- 3

df &lt;- expand.grid(
   Description = c("Sample 1", "Sample 2"),
   Concentration = c(0.1, 0.5, 1, 2, 5),
   Time = c(1, 2, 3, 4, 5),
   Replicate = 1:3)

df$Value &lt;- abs(rnorm(nrow(df)))

df_formatted &lt;- tidy_to_custom(df)

</code></pre>

<hr>
<h2 id='updateResistantPopover'>Create an update-resistant popover for a Shiny element</h2><span id='topic+updateResistantPopover'></span>

<h3>Description</h3>

<p>This function creates a popover that is resistant to updates in the associated Shiny element.
It adds an event listener to the specified element, which reinstalls the popover whenever a child
of the element changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateResistantPopover(
  id,
  title,
  content,
  placement = "bottom",
  trigger = "hover",
  options = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateResistantPopover_+3A_id">id</code></td>
<td>
<p>The id of the Shiny element to which the popover is attached.</p>
</td></tr>
<tr><td><code id="updateResistantPopover_+3A_title">title</code></td>
<td>
<p>The title of the popover.</p>
</td></tr>
<tr><td><code id="updateResistantPopover_+3A_content">content</code></td>
<td>
<p>The content of the popover.</p>
</td></tr>
<tr><td><code id="updateResistantPopover_+3A_placement">placement</code></td>
<td>
<p>The placement of the popover relative to the Shiny element (default: &quot;bottom&quot;).
Possible values are &quot;top&quot;, &quot;bottom&quot;, &quot;left&quot;, and &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="updateResistantPopover_+3A_trigger">trigger</code></td>
<td>
<p>The event that triggers the display of the popover (default: &quot;hover&quot;).
Possible values are &quot;hover&quot;, &quot;focus&quot;, and &quot;click&quot;.</p>
</td></tr>
<tr><td><code id="updateResistantPopover_+3A_options">options</code></td>
<td>
<p>A list of additional options for the popover.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Shiny HTML tag that contains the JavaScript code for creating the update-resistant popover.
</p>


<h3>Author(s)</h3>

<p>K. Rohde (stack overflow)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(shiny)
library(shinyBS)

ui &lt;- shinyUI(fluidPage(
  selectInput("Main2_1","Label","abc",  selectize = TRUE, multiple = TRUE),
  updateResistantPopover("Main2_1", "Label", "content", placement = "right", trigger = "focus"),
  actionButton("destroy", "destroy!")
))

server &lt;- function(input, output, session){
  observeEvent(input$destroy, {
    updateSelectInput(session, "Main2_1", choices="foo")
  })
}

shinyApp(ui, server)

## End(Not run)
</code></pre>

<hr>
<h2 id='zipFastener'>Combine two dataframes like a zip-fastener</h2><span id='topic+zipFastener'></span>

<h3>Description</h3>

<p>Combine rows or columns of two dataframes in an alternating manner
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zipFastener(df1, df2, along = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zipFastener_+3A_df1">df1</code></td>
<td>
<p>A first dataframe.</p>
</td></tr>
<tr><td><code id="zipFastener_+3A_df2">df2</code></td>
<td>
<p>A second dataframe with the same dimensions as <code>df1</code>.</p>
</td></tr>
<tr><td><code id="zipFastener_+3A_along">along</code></td>
<td>
<p><code>1</code> to alternate rows or <code>2</code> to alternate columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with combined rows (or columns) of df1 and df2.
</p>


<h3>Author(s)</h3>

<p>Mark Heckmann
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data frames equal dimensions
df1 &lt;- plyr::rdply(3, rep('o',4))[ ,-1]
df2 &lt;- plyr::rdply(3, rep('X',4))[ ,-1]

zipFastener(df1, df2)
zipFastener(df1, df2, 2)
zipFastener(df1, df2, 1)

# data frames unequal in no. of rows
df1 &lt;- plyr::rdply(10, rep('o',4))[ ,-1]
zipFastener(df1, df2, 1)
zipFastener(df2, df1, 1)

# data frames unequal in no. of columns
df2 &lt;- plyr::rdply(10, rep('X',3))[ ,-1]
zipFastener(df1, df2)
zipFastener(df2, df1, 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
