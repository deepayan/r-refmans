<!DOCTYPE html><html lang="en"><head><title>Help for package clusterSim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {clusterSim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cluster.Description'><p>Descriptive statistics calculated separately for each cluster and variable</p></a></li>
<li><a href='#cluster.Gen'><p>Random cluster generation with known structure of clusters</p></a></li>
<li><a href='#cluster.Sim'><p>Determination of optimal clustering procedure for a data set</p></a></li>
<li><a href='#comparing.Partitions'><p>Calculate agreement indices between two partitions</p></a></li>
<li><a href='#data_binary'><p>Binary data</p></a></li>
<li><a href='#data_interval'><p>Interval data</p></a></li>
<li><a href='#data_mixed'><p>Mixed data</p></a></li>
<li><a href='#data_nominal'><p>Nominal data</p></a></li>
<li><a href='#data_ordinal'><p>Ordinal data</p></a></li>
<li><a href='#data_patternGDM1'><p>Metric data with 17 objects and 10 variables (8 stimulant variables, 2 destimulant variables)</p></a></li>
<li><a href='#data_patternGDM2'><p>Ordinal data with 27 objects and 6 variables (3 stimulant variables, 2 destimulant variables and 1 nominant variable)</p></a></li>
<li><a href='#data_ratio'><p>Ratio data</p></a></li>
<li><a href='#data_symbolic'><p>Symbolic interval data</p></a></li>
<li><a href='#data_symbolic_interval_polish_voivodships'><p>The evaluation of Polish voivodships tourism attractiveness level</p></a></li>
<li><a href='#data.Normalization'><p>Types of variable (column) and object (row) normalization formulas</p></a></li>
<li><a href='#dist.BC'><p>Calculates Bray-Curtis  distance measure for ratio data</p></a></li>
<li><a href='#dist.GDM'><p>Calculates Generalized Distance Measure</p></a></li>
<li><a href='#dist.SM'><p>Calculates Sokal-Michener distance measure for nominal variables</p></a></li>
<li><a href='#dist.Symbolic'><p>Calculates distance between interval-valued symbolic data</p></a></li>
<li><a href='#HINoV.Mod'><p>Modification of Carmone, Kara &amp; Maxwell Heuristic Identification of Noisy Variables (HINoV) method</p></a></li>
<li><a href='#HINoV.Symbolic'><p>Modification of Carmone, Kara &amp; Maxwell Heuristic Identification of Noisy Variables (HINoV) method for symbolic interval data</p></a></li>
<li><a href='#index.C'><p>Calculates Hubert &amp; Levin C index - internal cluster quality index</p></a></li>
<li><a href='#index.DB'><p>Calculates Davies-Bouldin's index</p></a></li>
<li><a href='#index.G1'><p>Calculates Calinski-Harabasz pseudo F-statistic</p></a></li>
<li><a href='#index.G2'><p>Calculates G2 internal cluster quality index</p></a></li>
<li><a href='#index.G3'><p>Calculates G3 internal cluster quality index</p></a></li>
<li><a href='#index.Gap'><p>Calculates Tibshirani, Walther and Hastie gap index</p></a></li>
<li><a href='#index.H'><p>Calculates Hartigan index</p></a></li>
<li><a href='#index.KL'><p>Calculates Krzanowski-Lai index</p></a></li>
<li><a href='#index.S'><p>Calculates Rousseeuw's Silhouette internal cluster quality index</p></a></li>
<li><a href='#initial.Centers'><p>Calculation of initial clusters centers for k-means like alghoritms</p></a></li>
<li><a href='#interval_normalization'><p>Types of normalization formulas for interval-valued symbolic variables</p></a></li>
<li><a href='#ordinalToMetric'><p>Reinforcing measurement scale for ordinal data</p></a></li>
<li><a href='#pattern.GDM1'><p>An application of GDM1 distance for metric data to compute the distances of objects from the pattern object (upper or lower)</p></a></li>
<li><a href='#pattern.GDM2'><p>An application of GDM2 distance for ordinal data to compute the distances of objects from the pattern object (upper or lower)</p></a></li>
<li><a href='#plotCategorial'><p>Plot categorial data on a scatterplot matrix</p></a></li>
<li><a href='#plotInterval'><p>Plot symbolic interval-valued data on a scatterplot matrix</p></a></li>
<li><a href='#replication.Mod'><p>Modification of replication analysis for cluster validation</p></a></li>
<li><a href='#shapes.blocks3d'><p>Generation of data set containing two clusters with untypical shapes (cube divided into two parts by main diagonal plane)</p></a></li>
<li><a href='#shapes.circles2'><p>Generation of data set containing two clusters with untypical ring shapes (circles)</p></a></li>
<li><a href='#shapes.circles3'><p>Generation of data set containing three clusters with untypical ring shapes (circles)</p></a></li>
<li><a href='#shapes.two.moon'><p>Generation of data set containing two clusters with untypical shapes (similar to waxing and waning crescent moon)</p></a></li>
<li><a href='#shapes.worms'><p>Generation of data set containing two clusters with untypical parabolic shapes (worms)</p></a></li>
<li><a href='#speccl'><p>A spectral clustering algorithm</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Searching for Optimal Clustering Procedure for a Data Set</td>
</tr>
<tr>
<td>Version:</td>
<td>0.51-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-09-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrzej Dudek &lt;andrzej.dudek@ue.wroc.pl&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), cluster, MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, e1071, grDevices, graphics, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>mlbench, testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Distance measures (GDM1, GDM2,	Sokal-Michener, Bray-Curtis, for symbolic interval-valued data), cluster quality indices (Calinski-Harabasz, Baker-Hubert, Hubert-Levine, Silhouette, Krzanowski-Lai, Hartigan, Gap,	Davies-Bouldin),	data normalization formulas (metric data, interval-valued symbolic data), data generation (typical and non-typical data), HINoV method,	replication analysis, linear ordering methods, spectral clustering, agreement indices between two partitions, plot functions (for categorical and symbolic interval-valued data). 
 (MILLIGAN, G.W., COOPER, M.C. (1985) &lt;<a href="https://doi.org/10.1007%2FBF02294245">doi:10.1007/BF02294245</a>&gt;, 
 HUBERT, L., ARABIE, P. (1985) &lt;<a href="https://doi.org/10.1007%2FBF01908075">doi:10.1007%2FBF01908075</a>&gt;, 
 RAND, W.M. (1971) &lt;<a href="https://doi.org/10.1080%2F01621459.1971.10482356">doi:10.1080/01621459.1971.10482356</a>&gt;, 
 JAJUGA, K., WALESIAK, M. (2000) &lt;<a href="https://doi.org/10.1007%2F978-3-642-57280-7_11">doi:10.1007/978-3-642-57280-7_11</a>&gt;, 
 MILLIGAN, G.W., COOPER, M.C. (1988) &lt;<a href="https://doi.org/10.1007%2FBF01897163">doi:10.1007/BF01897163</a>&gt;, 
 JAJUGA, K., WALESIAK, M., BAK, A. (2003) &lt;<a href="https://doi.org/10.1007%2F978-3-642-55721-7_12">doi:10.1007/978-3-642-55721-7_12</a>&gt;, 
 DAVIES, D.L., BOULDIN, D.W. (1979) &lt;<a href="https://doi.org/10.1109%2FTPAMI.1979.4766909">doi:10.1109/TPAMI.1979.4766909</a>&gt;, 
 CALINSKI, T., HARABASZ, J. (1974) &lt;<a href="https://doi.org/10.1080%2F03610927408827101">doi:10.1080/03610927408827101</a>&gt;,
 HUBERT, L. (1974) &lt;<a href="https://doi.org/10.1080%2F01621459.1974.10480191">doi:10.1080/01621459.1974.10480191</a>&gt;, 
 TIBSHIRANI, R., WALTHER, G., HASTIE, T. (2001) &lt;<a href="https://doi.org/10.1111%2F1467-9868.00293">doi:10.1111/1467-9868.00293</a>&gt;, 
 BRECKENRIDGE, J.N. (2000) &lt;<a href="https://doi.org/10.1207%2FS15327906MBR3502_5">doi:10.1207/S15327906MBR3502_5</a>&gt;, 
 WALESIAK, M., DUDEK, A. (2008) &lt;<a href="https://doi.org/10.1007%2F978-3-540-78246-9_11">doi:10.1007/978-3-540-78246-9_11</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-14 13:31:50 UTC; andrzej</td>
</tr>
<tr>
<td>Author:</td>
<td>Marek Walesiak <a href="https://orcid.org/0000-0003-0922-2323"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Andrzej Dudek <a href="https://orcid.org/0000-0002-4943-8703"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-14 14:50:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='cluster.Description'>Descriptive statistics calculated separately for each cluster and variable</h2><span id='topic+cluster.Description'></span>

<h3>Description</h3>

<p>Descriptive statistics calculated separately for each cluster and variable: arithmetic mean and standard deviation, median and median absolute deviation, mode </p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.Description(x, cl, sdType="sample",precission=4,modeAggregationChar=";")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.Description_+3A_x">x</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="cluster.Description_+3A_cl">cl</code></td>
<td>
<p>a vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
<tr><td><code id="cluster.Description_+3A_sdtype">sdType</code></td>
<td>
<p>type of standard deviation: for &quot;sample&quot; (n-1) or for &quot;population&quot; (n)</p>
</td></tr>
<tr><td><code id="cluster.Description_+3A_precission">precission</code></td>
<td>
<p>Number of digits on the right side of decimal mark sign</p>
</td></tr>
<tr><td><code id="cluster.Description_+3A_modeaggregationchar">modeAggregationChar</code></td>
<td>
<p>Character used for aggregation of mode values (if more than one value of mode appear in variable)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Three-dimensional array: 
</p>
<p>First dimension contains cluster number 
</p>
<p>Second dimension contains original coordinate (variable) number from matrix or data set 
</p>
<p>Third dimension contains number from 1 to 5: 
</p>
<p>1 - arithmetic mean 
</p>
<p>2 - standard deviation 
</p>
<p>3 - median 
</p>
<p>4 - median absolute deviation (mad) 
</p>
<p>5 - mode (value of the variable which has the largest observed frequency. This formula is applicable for nominal and ordinal data only). 
</p>
<p>For example: 
</p>
<p>desc&lt;-cluster.Description(x,cl) 
</p>
<p>desc[2,4,2] - standard deviation of fourth coordinate of second cluster 
</p>
<p>desc[3,1,5] - mode of first coordinate (variable) of third cluster 
</p>
<p>desc[1,,] - all statistics for all dimensions (variables) of first cluster 
</p>
<p>desc[,,3] - medians of all dimensions (variables) for each cluster
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster.Sim">cluster.Sim</a></code>, <code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+median">median</a></code>, <code><a href="stats.html#topic+mad">mad</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_ratio)
cl &lt;- pam(data_ratio,5)
desc &lt;- cluster.Description(data_ratio,cl$cluster)
print(desc)
</code></pre>

<hr>
<h2 id='cluster.Gen'>Random cluster generation with known structure of clusters</h2><span id='topic+cluster.Gen'></span>

<h3>Description</h3>

<p>Random cluster generation with known structure of clusters (optionally with noisy variables and outliers)</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.Gen(numObjects=50, means=NULL, cov=NULL, fixedCov=TRUE,
                   model=1, dataType="m",numCategories=NULL, 
                   numNoisyVar=0, numOutliers=0, rangeOutliers=
                   c(1,10), inputType="csv2", inputHeader=TRUE, 
                   inputRowNames=TRUE, outputCsv="", outputCsv2="", 
                   outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.Gen_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with the same size as <em>nrow(means)</em>,
e.g. <code>numObjects=c(50,20)</code></p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_means">means</code></td>
<td>
<p>matrix of cluster means (e.g. <code>means=matrix(c(0,8,0,8),2,2)</code>). If <code>means = NULL</code> matrix should be read from <em>means_&lt;modelNumber&gt;.csv file</em></p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_cov">cov</code></td>
<td>
<p>covariance matrix (the same for each cluster, e.g. <code>cov=matrix(c(1, 0, 0, 1), 2, 2)</code>).
If <code>cov=NULL</code> matrix should be read from
</p>
<p><em>cov_&lt;modelNumber&gt;.csv file</em>.
Note: you cannot use this argument for generation of clusters with different covariance matrices. 
Those kind of generation should be done by setting <code>fixedCov</code> to <code>FALSE</code> and using appropriate model</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_model">model</code></td>
<td>
<p>model number,
<code>model=1</code> - no cluster structure. Observations are simulated from uniform distribution over the unit hypercube in number of 
dimensions (variables) given in <code>numNoisyVar</code> argument; 
</p>
<p><code>model=2</code> - means and covariances are taken from arguments <code>means</code> and <code>cov</code> (see Example 1);
</p>
<p><code>model=3,4,...,20</code> - see file 
</p>
<p>$R_HOME\library\clusterSim\pdf\clusterGen_details.pdf; 
</p>
<p><code>model=21,22,...</code> - if <code>fixedCov=TRUE</code> <code>means</code> should be read from 
</p>
<p><em>means_&lt;modelNumber&gt;.csv</em> and  covariance matrix for all clusters should be read 
from <em>cov_&lt;modelNumber&gt;.csv</em> and if  <code>fixedCov=FALSE</code> <code>means</code> should be read from 
</p>
<p><em>means_&lt;modelNumber&gt;.csv</em> 
and covariance matrices should be read separately for each cluster 
from <em>cov_&lt;modelNumber&gt;_&lt;clusterNumber&gt;.csv</em></p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_fixedcov">fixedCov</code></td>
<td>
<p>if <code>fixedCov=TRUE</code> covariance matrix for all clusters is the same 
and if 
</p>
<p><code>fixedCov=FALSE</code> each cluster is generated from different covariance matrix - see <code>model</code></p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_datatype">dataType</code></td>
<td>
<p>&quot;m&quot; - metric (ratio, interval), &quot;o&quot; -  ordinal, &quot;s&quot; - symbolic interval</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_numcategories">numCategories</code></td>
<td>
<p>number of categories (for ordinal data only). Positive integer value or vector with the same size as <em>ncol(means)</em> plus number of noisy variables.</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_numnoisyvar">numNoisyVar</code></td>
<td>
<p>number of noisy variables. For <code>model=1</code> it means number of variables</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_numoutliers">numOutliers</code></td>
<td>
<p>number of outliers (for metric and symbolic interval data only). If a positive integer - number of outliers, if value from &lt;0,1&gt; - percentage of outliers in whole data set</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_rangeoutliers">rangeOutliers</code></td>
<td>
<p>range for outliers (for metric and symbolic interval data only). The default range is [1, 10].The outliers are generated independently for each variable for the whole data set from uniform distribution. The generated values are randomly added to maximum of <em>j</em>-th variable or subtracted from minimum of <em>j</em>-th variable</p>
</td></tr> 
<tr><td><code id="cluster.Gen_+3A_inputtype">inputType</code></td>
<td>
<p>&quot;csv&quot; - a dot as decimal point or &quot;csv2&quot; - a comma as decimal point in 
</p>
<p><em>means_&lt;modelNumber&gt;.csv</em> and <em>cov_&lt;modelNumber&gt;.csv</em> files</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_inputheader">inputHeader</code></td>
<td>
<p><code>inputHeader=TRUE</code> indicates that input files (<em>means_&lt;modelNumber&gt;.csv</em>;
</p>
<p><em>cov_&lt;modelNumber...&gt;.csv</em>) contain header row</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_inputrownames">inputRowNames</code></td>
<td>
<p><code>inputRowNames=TRUE</code> indicates that input files (<em>means_&lt;modelNumber&gt;.csv</em>; <em>cov_&lt;modelNumber...&gt;.csv</em>) contain first column with row names or with number of objects (positive integer values)</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="cluster.Gen_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\clusterGen_details.pdf for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object, for <code>model=1</code> each 
object belongs to its own cluster thus this variable contains objects numbers</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data: for metric and ordinal data - matrix with 
objects in rows and variables in columns; 
for symbolic interval data three-dimensional structure: first dimension represents object number,
second - variable number and third dimension contains lower- and upper-bounds of intervals</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Billard, L., Diday, E. (2006), <em>Symbolic data analysis. Conceptual statistics and data mining</em>, Wiley, Chichester. ISBN: 978-0-470-09016-9.
</p>
<p>Qiu, W., Joe, H. (2006), <em>Generation of random clusters with specified degree of separation</em>, &quot;Journal of Classification&quot;, vol. 23, 315-334. Available at: <a href="https://doi.org/10.1007/s00357-006-0018-y">doi:10.1007/s00357-006-0018-y</a>.
</p>
<p>Steinley, D., Henson, R. (2005), <em>OCLUS: an analytic method for generating clusters with known overlap</em>, &quot;Journal of Classification&quot;, vol. 22, 221-250. Available at: <a href="https://doi.org/10.1007/s00357-005-0015-6">doi:10.1007/s00357-005-0015-6</a>.
</p>
<p>Walesiak, M., Dudek, A. (2008), <em>Identification of noisy variables for nonmetric and symbolic data in cluster analysis</em>, In: C. Preisach, H. Burkhardt, L. Schmidt-Thieme, R. Decker (Eds.), Data analysis, machine learning and applications, Springer-Verlag, Berlin, Heidelberg, 85-92. Available at: <a href="https://doi.org/10.1007/978-3-540-78246-9_11">doi:10.1007/978-3-540-78246-9_11</a>.
</p>
<p>Walesiak, M. (2016), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R. Wydanie 2 poprawione i rozszerzone [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Example 1
library(clusterSim)
means &lt;- matrix(c(0,7,0,7),2,2)
cov &lt;- matrix(c(1,0,0,1),2,2)
grnd &lt;- cluster.Gen(numObjects=60,means=means,cov=cov,model=2,
numOutliers=8)
colornames &lt;- c("red","blue","green")
grnd$clusters[grnd$clusters==0]&lt;-length(colornames)
plot(grnd$data,col=colornames[grnd$clusters],ask=TRUE)

# Example 2
library(clusterSim)
grnd &lt;- cluster.Gen(50,model=4,dataType="m",numNoisyVar=2)
data &lt;- as.matrix(grnd$data)
colornames &lt;- c("red","blue","green")
plot(grnd$data,col=colornames[grnd$clusters],ask=TRUE)

# Example 3
library(clusterSim)
grnd&lt;-cluster.Gen(50,model=4,dataType="o",numCategories=7, numNoisyVar=2)
plotCategorial(grnd$data,,grnd$clusters,ask=TRUE)

# Example 4 (1 nonnoisy variable and 2 noisy variables, 3 clusters)
library(clusterSim)
grnd &lt;- cluster.Gen(c(40,60,20), model=2, means=c(2,14,25),
cov=c(1.5,1.5,1.5),numNoisyVar=2)
colornames &lt;- c("red","blue","green")
plot(grnd$data,col=colornames[grnd$clusters],ask=TRUE)

# Example 5
library(clusterSim)
grnd &lt;- cluster.Gen(c(20,35,20,25),model=14,dataType="m",numNoisyVar=1,
fixedCov=FALSE, numOutliers=0.1)
# or 
#grnd &lt;- cluster.Gen(c(20,35,20,25),model=14,dataType="m",numNoisyVar=1,
#fixedCov=FALSE, numOutliers=0.1, outputCsv2="data14.csv")
data &lt;- as.matrix(grnd$data)
colornames &lt;- c("red","blue","green","brown","black")
grnd$clusters[grnd$clusters==0]&lt;-length(colornames)
plot(grnd$data,col=colornames[grnd$clusters],ask=TRUE)

# Example 6 (this example needs files means_24.csv) 
# and cov_24.csv to be placed in working directory
# library(clusterSim)
# grnd&lt;-cluster.Gen(c(50,80,20),model=24,dataType="m",numNoisyVar=1, 
# numOutliers=10, rangeOutliers=c(1,5))
# print(grnd)
# data &lt;- as.data.frame(grnd$data)
# colornames&lt;-c("red","blue","green","brown")
# grnd$clusters[grnd$clusters==0]&lt;-length(colornames)
# plot(data,col=colornames[grnd$clusters],ask=TRUE)

# Example 7 (this example needs files means_25.csv and cov_25_1.csv) 
# cov_25_2.csv, cov_25_3.csv, cov_25_4.csv, cov_25_5.csv
# to be placed in working directory
# library(clusterSim)
# grnd&lt;-cluster.Gen(c(40,30,20,35,45),model=25,numNoisyVar=3,fixedCov=F)
# data &lt;- as.data.frame(grnd$data)
# colornames&lt;-c("red","blue","green","magenta","brown")
# plot(data,col=colornames[grnd$clusters],ask=TRUE)
</code></pre>

<hr>
<h2 id='cluster.Sim'>Determination of optimal clustering procedure for a data set </h2><span id='topic+cluster.Sim'></span>

<h3>Description</h3>

<p>Determination of optimal clustering procedure for a data set by varying all combinations of normalization formulas, distance measures, and clustering methods</p>


<h3>Usage</h3>

<pre><code class='language-R'>cluster.Sim (x,p,minClusterNo,maxClusterNo,icq="S",
	outputCsv="",outputCsv2="",normalizations=NULL,
	distances=NULL,methods=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cluster.Sim_+3A_x">x</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_p">p</code></td>
<td>
<p>path of simulation: 1 - ratio data, 2 - interval or mixed (ratio &amp; interval) data, 3 - ordinal data, 4 - nominal data, 5 - binary data, 6 - ratio data without normalization, 7 - interval or mixed (ratio &amp; interval) data without normalization, 8 - ratio data with k-means, 9 - interval or mixed (ratio &amp; interval) data with k-means</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_minclusterno">minClusterNo</code></td>
<td>
<p>minimal number of clusters, between 2  and no. of objects - 1 (for G3 or C: no. of objects - 2)</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_maxclusterno">maxClusterNo</code></td>
<td>
<p>maximal number of clusters, between 2 and no. of objects - 1 (for G3 or C: no. of objects - 2; for KL: no. of objects - 3), greater or equal minClusterNo</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_icq">icq</code></td>
<td>
<p>Internal cluster quality index, &quot;S&quot; - Silhouette,&quot;G1&quot; - Calinski &amp; Harabasz index, &quot;G2&quot; - Baker &amp; Hubert index ,&quot;G3&quot; - G3 index,&quot;C&quot; - C index, &quot;KL&quot; - Krzanowski &amp; Lai index </p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_outputcsv">outputCsv</code></td>
<td>
<p> optional, name of csv file with results</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p> optional, name of csv (comma as decimal point sign) file with results</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_normalizations">normalizations</code></td>
<td>
<p> optional, vector of normalization formulas that should be used in procedure</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_distances">distances</code></td>
<td>
<p> optional, vector of distance measures that should be used in procedure</p>
</td></tr>
<tr><td><code id="cluster.Sim_+3A_methods">methods</code></td>
<td>
<p> optional, vector of classification methods that should be used in procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameter <code>normalizations</code> for each path may be the subset of the following values
</p>
<p>path 1: &quot;n6&quot; to &quot;n11&quot; (if measurement scale of variables is ratio and transformed measurement scale of variables is ratio) or 
&quot;n1&quot; to &quot;n5&quot; (if measurement scale of variables is ratio and transformed measurement scale of variables is interval)
</p>
<p>path 2: &quot;n1&quot; to &quot;n5&quot;
</p>
<p>path 3 to 7 : &quot;n0&quot;
</p>
<p>path 8: &quot;n1&quot; to &quot;n11&quot;
</p>
<p>path 9: &quot;n1&quot; to &quot;n5&quot;
</p>
<p>Parameter <code>distances</code> for each path may be the subset of the following values
</p>
<p>path 1: &quot;d1&quot; to &quot;d7&quot; (if measurement scale of variables is ratio and transformed measurement scale of variables is ratio) or 
&quot;d1&quot; to &quot;d5&quot; (if measurement scale of variables is ratio and transformed measurement scale of variables is interval)
</p>
<p>path 2: &quot;d1&quot; to &quot;d5&quot;
</p>
<p>path 3: &quot;d8&quot;
</p>
<p>path 4: &quot;d9&quot;
</p>
<p>path 5: &quot;b1&quot; to &quot;b10&quot; 
</p>
<p>path 6: &quot;d1&quot; to &quot;d7&quot;
</p>
<p>path 7: &quot;d1&quot; to &quot;d5&quot;
</p>
<p>path 8 and 9: N.A.
</p>
<p>Parameter <code>methods</code> for each path may be the subset of the following values
</p>
<p>path 1 to 7 : &quot;m1&quot; to &quot;m8&quot;
</p>
<p>path 8: &quot;m9&quot;
</p>
<p>path 9: &quot;m9&quot;
</p>
<p>See file <a href="../doc/clusterSim_details.pdf">../doc/clusterSim_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>result</code></td>
<td>
<p>optimal value of icq for all classifications</p>
</td></tr>
<tr><td><code>normalization</code></td>
<td>
<p>normalization used to obtain optimal value of icq</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>distance measure used to obtain optimal value of icq</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>clustering method used to obtain optimal value of icq</p>
</td></tr>
<tr><td><code>classes</code></td>
<td>
<p>number of clusters for optimal value of icq</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>time of all calculations for path</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Everitt, B.S., Landau, E., Leese, M. (2001), <em>Cluster analysis</em>, Arnold, London. ISBN 9780340761199.
</p>
<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, p. 338. 
</p>
<p>Gordon, A.D. (1999), <em>Classification</em>, Chapman &amp; Hall/CRC, London. ISBN 9781584880134.
</p>
<p>Milligan, G.W., Cooper, M.C. (1985), <em>An examination of procedures of determining the number of cluster in a data set</em>, &quot;Psychometrika&quot;, vol. 50, no. 2, 159-179. Available at: <a href="https://doi.org/10.1007/BF02294245">doi:10.1007/BF02294245</a>.
</p>
<p>Milligan, G.W., Cooper, M.C. (1988), <em>A study of standardization of variables in cluster analysis</em>, &quot;Journal of Classification&quot;, vol. 5, 181-204. Available at: <a href="https://doi.org/10.1007/BF01897163">doi:10.1007/BF01897163</a>.
</p>
<p>Walesiak, M., Dudek, A. (2006), <em>Symulacyjna optymalizacja wyboru procedury klasyfikacyjnej dla danego typu danych - oprogramowanie komputerowe i wyniki badan</em>, Prace Naukowe AE we Wroclawiu, 1126, 120-129.
</p>
<p>Walesiak, M., Dudek, A. (2007), <em>Symulacyjna optymalizacja wyboru procedury klasyfikacyjnej dla danego typu danych - charakterystyka problemu</em>, Zeszyty Naukowe Uniwersytetu Szczecinskiego nr 450, 635-646.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Normalization">data.Normalization</a></code>, <code><a href="#topic+dist.GDM">dist.GDM</a></code>, <code><a href="#topic+dist.BC">dist.BC</a></code>, <code><a href="#topic+dist.SM">dist.SM</a></code>, <code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, 
</p>
<p><code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>, <code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#library(clusterSim)
#data(data_ratio)
#cluster.Sim(data_ratio, 1, 2, 3, "G1", outputCsv="results1")
#data(data_interval)
#cluster.Sim(data_interval, 2, 2, 4, "G1", outputCsv="results2")
#data(data_ordinal)
#cluster.Sim(data_ordinal, 3, 2, 4,"G2", outputCsv2="results3")
#data(data_nominal)
#cluster.Sim(data_nominal, p=4, 2, 4, icq="G3", outputCsv="results4", methods=c("m2","m3","m5"))
#data(data_binary)
#cluster.Sim(as.matrix(data_binary), p=5, 2, 4, icq="S", 
#outputCsv="results5", distances=c("b1","b3","b6"))
#data(data_ratio)
#cluster.Sim(data_ratio, 1, 2, 4,"G1", outputCsv="results6",normalizations=c("n1","n3"),
#distances=c("d2","d5"),methods=c("m5","m3","m1"))

</code></pre>

<hr>
<h2 id='comparing.Partitions'>Calculate agreement indices between two partitions</h2><span id='topic+comparing.Partitions'></span>

<h3>Description</h3>

<p>Calculate agreement indices between two partitions</p>


<h3>Usage</h3>

<pre><code class='language-R'>comparing.Partitions(cl1,cl2,type="nowak")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comparing.Partitions_+3A_cl1">cl1</code></td>
<td>
<p>A vector of integers (or letters) indicating the cluster to which each object is allocated for first clustering </p>
</td></tr>
<tr><td><code id="comparing.Partitions_+3A_cl2">cl2</code></td>
<td>
<p>A vector of integers (or letters) indicating the cluster to which each object is allocated for second clustering</p>
</td></tr>
<tr><td><code id="comparing.Partitions_+3A_type">type</code></td>
<td>
<p>&quot;rand&quot; - for Rand index, &quot;crand&quot; - for adjusted Rand index or &quot;nowak&quot; for Nowak index</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\comparingPartitions_details.pdf for further details.
</p>
<p>Rand and adjusted Rand indices uses <code>classAgreement</code> function from <code>e1071</code> library.
</p>


<h3>Value</h3>

<p>Returns value of index.
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Hubert, L., Arabie, P. (1985), <em>Comparing partitions</em>, &quot;Journal of Classification&quot;, no. 1, 193-218. Available at: <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.
</p>
<p>Nowak, E. (1985), <em>Wskaznik podobienstwa wynikow podzialow</em>, &quot;Przeglad Statystyczny&quot; [&quot;Statistical Review&quot;], no. 1, 41-48.
</p>
<p>Rand, W.M. (1971), <em>Objective criteria for the evaluation of clustering methods</em>, &quot;Journal of the American Statistical Association&quot;, no. 336, 846-850. Available at: <a href="https://doi.org/10.1080/01621459.1971.10482356">doi:10.1080/01621459.1971.10482356</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+replication.Mod">replication.Mod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
dataSet&lt;-cluster.Gen(model=5)
cl1&lt;-dataSet$clusters
cl2&lt;-kmeans(dataSet$data,2)$cluster
print(comparing.Partitions(cl1,cl2,type="rand"))

# Example 2
library(clusterSim)
data(data_patternGDM1)
z&lt;-data.Normalization(data_patternGDM1,type="n1")
d&lt;-dist.GDM(z,method="GDM1")
cl1&lt;-pam(d,3,diss=TRUE)$clustering
cl2&lt;-pam(d,4,diss=TRUE)$clustering
print(comparing.Partitions(cl1,cl2,type="crand"))

# Example 3
library(clusterSim)
data(data_patternGDM1)
z&lt;-data.Normalization(data_patternGDM1,type="n9")
d&lt;-dist.GDM(z,method="GDM1")
cl1&lt;-pam(d,3,diss=TRUE)$clustering
hc&lt;-hclust(d, method="complete")
cl2&lt;-cutree(hc,k=3)
print(comparing.Partitions(cl1,cl2,type="nowak"))
</code></pre>

<hr>
<h2 id='data_binary'>Binary data</h2><span id='topic+data_binary'></span>

<h3>Description</h3>

<p>Binary variables for eight people</p>


<h3>Format</h3>

<p>data.frame: 8 objects, 10 variables</p>


<h3>Source</h3>

<p>Kaufman, L., Rousseeuw, P.J. (1990), <em>Finding groups in data: an introduction to cluster analysis</em>, Wiley, New York, p. 24.</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(clusterSim)
#data(data_binary)
#cluster.Sim(as.matrix(data_binary), p=5, 2, 6, icq="S", 
#outputCsv="results5", distances=c("b1","b3","b6"))
</code></pre>

<hr>
<h2 id='data_interval'>Interval data</h2><span id='topic+data_interval'></span>

<h3>Description</h3>

<p>Artificially generated interval data</p>


<h3>Format</h3>

<p>data.frame: 75 objects, 5 variables, 5-class structure</p>


<h3>Source</h3>

<p>Artificially generated data</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(clusterSim)
#data(data_interval)
#cluster.Sim(data_interval, 2, 2, 3, "G1", outputHtml="results2")
</code></pre>

<hr>
<h2 id='data_mixed'>Mixed data</h2><span id='topic+data_mixed'></span>

<h3>Description</h3>

<p>Artificial mixed data</p>


<h3>Format</h3>

<p>data.frame: 25 objects, 4 variables (1, 3 - interval variables, 2 - ordinal variable, 4, nominal variable</p>


<h3>Source</h3>

<p>Artificial data</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_mixed)
r3 &lt;- HINoV.Mod(data_mixed, type=c("m","n","m","n"), s=2, 3, distance="d1",
     method="complete", Index="cRAND")
print(r3$stopri)
plot(r3$stopri[,2], xlab="Variable number", ylab="topri", xaxt="n")
axis(1,at=c(1:max(r3$stopri[,1])),labels=r3$stopri[,1])
</code></pre>

<hr>
<h2 id='data_nominal'>Nominal data</h2><span id='topic+data_nominal'></span>

<h3>Description</h3>

<p>Artificial nominal data</p>


<h3>Format</h3>

<p>data.frame: 26 objects, 12 variables</p>


<h3>Source</h3>

<p>Artificial data</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(clusterSim)
#data(data_nominal)
#cluster.Sim(data_nominal, p=4, 2, 5, icq="G3",
#outputHtml="results4", methods=c("m2","m3","m5"))
</code></pre>

<hr>
<h2 id='data_ordinal'>Ordinal data</h2><span id='topic+data_ordinal'></span>

<h3>Description</h3>

<p>Artificial ordinal data</p>


<h3>Format</h3>

<p>data.frame: 26 objects, 12 variables</p>


<h3>Source</h3>

<p>Artificial data</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(clusterSim)
#data(data_ordinal)
#cluster.Sim(data_ordinal, 3, 3, 12,"S", 
#outputCsv2="results3")
</code></pre>

<hr>
<h2 id='data_patternGDM1'>Metric data with 17 objects and 10 variables (8 stimulant variables, 2 destimulant variables)</h2><span id='topic+data_patternGDM1'></span>

<h3>Description</h3>

<p>Metric data with 17 objects and 10 variables (8 stimulant variables, 2 destimulant variables)
</p>
<p>Data on the Polish voivodships, owing to the conditions of the population living in cities in 2007. The analysis includes the following variables:
</p>
<p>x1 - dwellings in per cent fitted with water-line system,
</p>
<p>x2 - dwellings in per cent fitted with lavatory,
</p>
<p>x3 - dwellings in per cent fitted with bathroom,
</p>
<p>x4 - dwellings in per cent fitted with gas-line system,
</p>
<p>x5 - dwellings in per cent fitted with central heating,
</p>
<p>x6 - average number of rooms per dwelling,
</p>
<p>x7 - average number of persons per dwelling,
</p>
<p>x8 - average number of persons per room,
</p>
<p>x9 - usable floor space in square meter per dwelling,
</p>
<p>x10 - usable floor space in square meter per person.
</p>
<p>Types of performance variables:
</p>
<p>x1 - x6, x9, x10 - stimulants,
</p>
<p>x7, x8 - destimulants.
</p>


<h3>Format</h3>

<p>data.frame: 17 objects, 10 variables</p>


<h3>Source</h3>

<p>Voivodships Statistical Yearbook, Poland 2008.</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_patternGDM1)
res&lt;-pattern.GDM1(data_patternGDM1,
performanceVariable=c("s","s","s","s","s","s","d","d","s","s"),
scaleType="r",nomOptValues=NULL,weightsType&lt;-"equal",weights=NULL,
normalization&lt;-"n4",patternType&lt;-"lower",patternCoordinates&lt;-"manual",
patternManual&lt;-c(0,0,0,0,0,"min","max","max","min","min"),
nominalTransfMethod &lt;-NULL)
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(max(gdm_p),min(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)),xaxt="n",
xlab="Order of objects from the best to the worst", 
ylab="GDM distances from pattern object",lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)

# Example 2
library(clusterSim)
data(data_patternGDM1)
res&lt;-pattern.GDM1(data_patternGDM1,
performanceVariable=c("s","s","s","s","s","s","d","d","s","s"),
scaleType="r",nomOptValues=NULL,weightsType&lt;-"equal",weights=NULL,
normalization&lt;-"n2",patternType&lt;-"upper",
patternCoordinates&lt;-"dataBounds",patternManual&lt;-NULL,
nominalTransfMethod &lt;-NULL)
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(min(gdm_p),max(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)),xaxt="n",
xlab="Order of objects from the best to the worst", 
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)
</code></pre>

<hr>
<h2 id='data_patternGDM2'>Ordinal data with 27 objects and 6 variables (3 stimulant variables, 2 destimulant variables and 1 nominant variable)</h2><span id='topic+data_patternGDM2'></span>

<h3>Description</h3>

<p>Ordinal data with 27 objects and 6 variables (3 stimulant variables, 2 destimulant variables and 1 nominant variable)
</p>
<p>Residential housing properties were described by the following variables:
</p>
<p>x1 - Location of environmental land, which is linked to a dwelling (1 - poor, 2 - inadequate, 3 - satisfactory, 4 - good, 5 - very good),
</p>
<p>x2 - Standard utility of a dwelling (1 - bad, 2 - low, 3 - average, 4 - high),
</p>
<p>x3 - Living conditions occurring on the land, which is linked to a dwelling (1 - bad, 2 - average, 3 - good),
</p>
<p>x4 - Location of land, which is related to dwelling in the area of the city (1 - central, 2 - downtown, 3 - intermediate, 4 - peripheral),
</p>
<p>x5 - Type of condominium (1 - low, 2 - large),
</p>
<p>x6 - Area of land, which is related to dwelling (1 - below the contour of the building, 2 - outline of the building, 
3 - the outline of the building with the environment acceptable, such as parking, playground,
4 - the outline of the building with the environment too much).
</p>
<p>Types of performance variables:
</p>
<p>x1, x2, x3 - stimulants,
</p>
<p>x4, x5 - destimulants,
</p>
<p>x6 - nominant (the nominal category: 3).
</p>


<h3>Format</h3>

<p>data.frame: 27 objects, 6 variables</p>


<h3>Source</h3>

<p>data from real estate market</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_patternGDM2)
res&lt;-pattern.GDM2(data_patternGDM2,
performanceVariable=c("s","s","s","d","d","n"),
nomOptValues=c(NA,NA,NA,NA,NA,3), weightsType&lt;-"equal", weights=NULL,
patternType="lower", patternCoordinates="manual",
patternManual=c("min","min",0,5,"max","max"),
nominalTransfMethod="symmetrical")
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(max(gdm_p),min(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)), 
xaxt="n",xlab="Order of objects from the best to the worst",
ylab="GDM distances from pattern object",lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)

# Example 2
library(clusterSim)
data(data_patternGDM2)
res&lt;-pattern.GDM2(data_patternGDM2,
performanceVariable=c("s","s","s","d","d","n"),
nomOptValues=c(NA,NA,NA,NA,NA,3), weightsType&lt;-"equal", weights=NULL,
patternType="upper", patternCoordinates="dataBounds",
patternManual=NULL, nominalTransfMethod="database")
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p), xlim=c(min(gdm_p),max(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)), 
xaxt="n",xlab="Order of objects from the best to the worst",
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)
</code></pre>

<hr>
<h2 id='data_ratio'>Ratio data</h2><span id='topic+data_ratio'></span>

<h3>Description</h3>

<p>Artificially generated ratio data</p>


<h3>Format</h3>

<p>data.frame: 75 objects, 5 variables, 5-class structure</p>


<h3>Source</h3>

<p>Artificially generated data</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(clusterSim)
#data(data_ratio)
#c &lt;- pam(data_ratio,10)
#index.G1(data_ratio, c$clustering)
</code></pre>

<hr>
<h2 id='data_symbolic'>Symbolic interval data</h2><span id='topic+data_symbolic'></span>

<h3>Description</h3>

<p>Artificially generated symbolic interval data</p>


<h3>Format</h3>

<p>3-dimensional array: 125 objects, 6 variables, third dimension represents  begining and end of interval, 5-class structure</p>


<h3>Source</h3>

<p>Artificially generated data</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_symbolic)
r&lt;- HINoV.Symbolic(data_symbolic, u=5)
print(r$stopri)
plot(r$stopri[,2], xlab="Variable number", ylab="topri",
xaxt="n", type="b")
axis(1,at=c(1:max(r$stopri[,1])),labels=r$stopri[,1])
</code></pre>

<hr>
<h2 id='data_symbolic_interval_polish_voivodships'>The evaluation of Polish voivodships tourism attractiveness level</h2><span id='topic+data_symbolic_interval_polish_voivodships'></span>

<h3>Description</h3>

<p>The empirical study uses the statistical data referring to the attractiveness level of 18 objects (16 Polish NUTS-2 regions - voivodships, pattern and anti-pattern object). 
</p>
<p>Two-stage data collection was performed. Firstly, data on tourist attractiveness were collected for 380 counties using 9 classic metric variables (measured on a ratio scale): 
</p>
<p>x1 - beds in hotels per 1000 inhabitants of a county,
</p>
<p>x2 - number of nights spent daily by resident tourists per 1000 inhabitants of a county,
</p>
<p>x3 - number of nights spent daily by foreign tourists per 1000 inhabitants of a county, 
</p>
<p>x4 - dust pollution emission in tons per 10 km2 of a county area,
</p>
<p>x5 - gas pollution emission in tons per 1 km2 of a county area,
</p>
<p>x6 - number of criminal offences, crimes against life and health and property crimes per 1000 inhabitants of a county,
</p>
<p>x7 - forest cover of the county in 
</p>
<p>x8 - participants of mass events per 1000 inhabitants of a county,
</p>
<p>x9 - number of tourist economy entities (sections: I, N79) registered in the system REGON per 1000 inhabitants of a county. 
</p>
<p>The three variables (x4, x5 and x6) are destimulants. Other variables are stimulants.
</p>
<p>In the second step, the data were aggregated to the level of the voivodships (NUTS-2), giving the symbolic interval-valued data. The lower bound of the interval for each symbolic interval-valued variable in the voivodship was obtained by calculating the first quartile on the basis of data from counties. The upper bound of the interval was obtained by calculating the third quartile.
</p>


<h3>Format</h3>

<p>Tree-dimansional array: 18 objects (16 Polish NUTS-2 regions - voivodships, pattern and anti-pattern object), 9 symbolic interval-valued variables with lower and upper values of interval in third dimension. The coordinates of an pattern object cover the most preferred preference variable values.
The coordinates of an anti-pattern object cover the least preferred preference variable values.</p>


<h3>Source</h3>

<p>The statistical data were collected in 2016 and come from the Local Data Bank of the Central Statistical Office of Poland.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_symbolic_interval_polish_voivodships)
print(data_symbolic_interval_polish_voivodships)
</code></pre>

<hr>
<h2 id='data.Normalization'>Types of variable (column) and object (row) normalization formulas</h2><span id='topic+data.Normalization'></span>

<h3>Description</h3>

<p>Types of variable (column) and object (row) normalization formulas</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.Normalization (x,type="n0",normalization="column",...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="data.Normalization_+3A_x">x</code></td>
<td>
<p>vector, matrix or dataset</p>
</td></tr>
<tr><td><code id="data.Normalization_+3A_type">type</code></td>
<td>
<p>type of normalization:</p>
</td></tr>
</table>
<p>n0 - without normalization 
</p>
<p>n1 - standardization ((x-mean)/sd)
</p>
<p>n2 - positional standardization ((x-median)/mad)
</p>
<p>n3 - unitization ((x-mean)/range)
</p>
<p>n3a - positional unitization ((x-median)/range)
</p>
<p>n4 - unitization with zero minimum ((x-min)/range)
</p>
<p>n5 - normalization in range &lt;-1,1&gt; ((x-mean)/max(abs(x-mean)))
</p>
<p>n5a - positional normalization in range &lt;-1,1&gt; ((x-median)/max(abs(x-median)))
</p>
<p>n6 - quotient transformation (x/sd)
</p>
<p>n6a - positional quotient transformation (x/mad)
</p>
<p>n7 - quotient transformation (x/range)
</p>
<p>n8 - quotient transformation (x/max)
</p>
<p>n9 - quotient transformation (x/mean)
</p>
<p>n9a - positional quotient transformation (x/median)
</p>
<p>n10 - quotient transformation (x/sum)
</p>
<p>n11 - quotient transformation (x/sqrt(SSQ))
</p>
<p>n12 - normalization ((x-mean)/sqrt(sum((x-mean)^2)))
</p>
<p>n12a - positional normalization ((x-median)/sqrt(sum((x-median)^2)))
</p>
<p>n13 - normalization with zero being the central point ((x-midrange)/(range/2))
</p>
<table role = "presentation">
<tr><td><code id="data.Normalization_+3A_normalization">normalization</code></td>
<td>
<p>&quot;column&quot; - normalization by variable, &quot;row&quot; - normalization by object</p>
</td></tr>
<tr><td><code id="data.Normalization_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sum</code>, <code>mean</code>, <code>min</code> <code>sd</code>, <code>mad</code> and other aggregation functions. In particular: 
<code>na.rm</code> - a logical value indicating whether NA values should be stripped before the computation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/dataNormalization_details.pdf">../doc/dataNormalization_details.pdf</a> for further details
</p>
<p>Thanks Wolfgang Lederer (&lt;wolfgang.lederer@gmail.com&gt;) for reporting n4/vector error
</p>


<h3>Value</h3>

<p>Normalized data
The numeric shifts and scalings used (if any) are returned as attributes &quot;normalized:shift&quot; and &quot;normalized:scale&quot;
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Anderberg, M.R. (1973), <em>Cluster analysis for applications</em>, Academic Press, New York, San Francisco, London. ISBN 9780120576500.
</p>
<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, 35-38.
</p>
<p>Jajuga, K., Walesiak, M. (2000), <em>Standardisation of data set under different measurement scales</em>, In: R. Decker, W. Gaul (Eds.), Classification and information processing at the turn of the millennium, Springer-Verlag, Berlin, Heidelberg, 105-112. Available at: <a href="https://doi.org/10.1007/978-3-642-57280-7_11">doi:10.1007/978-3-642-57280-7_11</a>.
</p>
<p>Milligan, G.W., Cooper, M.C. (1988), <em>A study of standardization of variables in cluster analysis</em>, &quot;Journal of Classification&quot;, vol. 5, 181-204. Available at: <a href="https://doi.org/10.1007/BF01897163">doi:10.1007/BF01897163</a>.
</p>
<p>Mlodak, A. (2006), <em>Analiza taksonomiczna w statystyce regionalnej</em>, Difin, Warszawa. ISBN 83-7251-605-7.
</p>
<p>Walesiak, M. (2014), <em>Przeglad formul normalizacji wartosci zmiennych oraz ich wlasnosci w statystycznej analizie wielowymiarowej [Data normalization in multivariate data analysis. An overview and properties]</em>, &quot;Przeglad Statystyczny&quot; (&quot;Statistical Review&quot;), vol. 61, no. 4, 363-372. Available at: <a href="https://doi.org/10.5604/01.3001.0016.1740">doi:10.5604/01.3001.0016.1740</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster.Sim">cluster.Sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_ratio)
z1 &lt;- data.Normalization(data_ratio,type="n1",normalization="column",na.rm=FALSE)
z2 &lt;- data.Normalization(data_ratio,type="n10",normalization="row",na.rm=FALSE)
</code></pre>

<hr>
<h2 id='dist.BC'>Calculates Bray-Curtis  distance measure for ratio data</h2><span id='topic+dist.BC'></span>

<h3>Description</h3>

<p>Calculates Bray-Curtis distance measure for ratio data</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.BC (x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.BC_+3A_x">x</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\distBC_details.pdf for further details
</p>


<h3>Value</h3>

<p>object with calculated distance
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Cormack, R.M. (1971), <em>A review of classification (with discussion)</em>, &quot;Journal of the Royal Statistical Society&quot;, ser. A, part 3, 321-367.
</p>
<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, p. 41.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>, <code><a href="#topic+dist.SM">dist.SM</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
sampleData &lt;- cbind(c(2,3,5),c(4,5,6),c(5,3,4))
d &lt;- dist.BC(sampleData)
</code></pre>

<hr>
<h2 id='dist.GDM'>Calculates Generalized Distance Measure</h2><span id='topic+dist.GDM'></span><span id='topic+GDM'></span><span id='topic+GDM1'></span><span id='topic+GDM2'></span>

<h3>Description</h3>

<p>Calculates Generalized Distance Measure for variables measured on metric scale (ratio &amp; interval) or ordinal scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.GDM(x, method="GDM1", weightsType="equal", weights=NULL)
GDM(x, method="GDM1", weightsType="equal", weights=NULL)
GDM1(x, weightsType="equal", weights=NULL)
GDM2(x, weightsType="equal", weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.GDM_+3A_x">x</code></td>
<td>
<p>matrix or data set</p>
</td></tr>
<tr><td><code id="dist.GDM_+3A_method">method</code></td>
<td>
<p>GDM1 or GDM2</p>
</td></tr>
</table>
<p>&quot;GDM1&quot; - metric scale (ratio &amp; interval) 
</p>
<p>&quot;GDM2&quot; - ordinal scale
</p>
<table role = "presentation">
<tr><td><code id="dist.GDM_+3A_weightstype">weightsType</code></td>
<td>
<p>equal or different1 or different2</p>
</td></tr>
</table>
<p>&quot;equal&quot; - equal weights
</p>
<p>&quot;different1&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; 1] and sum of weights equals one
</p>
<p>&quot;different2&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; m] and sum of weights equals m (m - the number of variables)
</p>
<table role = "presentation">
<tr><td><code id="dist.GDM_+3A_weights">weights</code></td>
<td>
<p>vector of weights</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\distGDM_details.pdf for further details
</p>


<h3>Value</h3>

<p>object with calculated distance
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Jajuga, K., Walesiak, M., Bak, A. (2003), <em>On the general distance measure</em>, In: M. Schwaiger, O. Opitz (Eds.), Exploratory data analysis in empirical research, Springer-Verlag, Berlin, Heidelberg, 104-109. Available at: <a href="https://doi.org/10.1007/978-3-642-55721-7_12">doi:10.1007/978-3-642-55721-7_12</a>.
</p>
<p>Walesiak, M. (1999), <em>Distance Measure for Ordinal Data</em>, &quot;Argumenta Oeconomica&quot;, No. 2 (8), 167-173.
</p>
<p>Walesiak, M. (2006), <em>Uogolniona miara odleglosci w statystycznej analizie wielowymiarowej [The Generalized Distance Measure in multivariate statistical analysis]</em>, Wydawnictwo AE, Wroclaw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.BC">dist.BC</a></code>, <code><a href="#topic+dist.SM">dist.SM</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1
library(clusterSim)
data(data_ratio)
d1 &lt;- GDM(data_ratio, method="GDM1")
data(data_ordinal)
d2 &lt;- GDM(data_ordinal, method="GDM2")
d3 &lt;- GDM1(data_ratio)
d4 &lt;- GDM2(data_ordinal)

#Example 2
library(clusterSim)
data(data_ratio)
d1w &lt;- GDM(data_ratio, method="GDM1", weightsType="different1",
weights=c(0.4,0.1,0.3,0.15,0.05))
data(data_ordinal)
d2w &lt;- GDM(data_ordinal, method="GDM2", weightsType="different2",
weights=c(1,3,0.5,1.5,1.8,0.2,0.4,0.6,0.2,0.4,0.9,1.5))
</code></pre>

<hr>
<h2 id='dist.SM'>Calculates Sokal-Michener distance measure for nominal variables</h2><span id='topic+dist.SM'></span>

<h3>Description</h3>

<p>Calculates Sokal-Michener distance measure for nominal variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.SM(x)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.SM_+3A_x">x</code></td>
<td>
<p>matrix or data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\distSM_details.pdf for further details
</p>


<h3>Value</h3>

<p>object with calculated distance
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, p. 43.
</p>
<p>Kaufman, L., Rousseeuw, P.J. (1990), <em>Finding groups in data: an introduction to cluster analysis</em>, Wiley, New York, p. 28. ISBN: 978-0-471-73578-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>, <code><a href="#topic+dist.BC">dist.BC</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_nominal)
d &lt;- dist.SM(data_nominal)
</code></pre>

<hr>
<h2 id='dist.Symbolic'>Calculates distance between interval-valued symbolic data</h2><span id='topic+dist.Symbolic'></span>

<h3>Description</h3>

<p>Calculates distance between interval-valued symbolic data for four distance types</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist.Symbolic(data,type="U_2",gamma=0.5,power=2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dist.Symbolic_+3A_data">data</code></td>
<td>
<p>symbolic data</p>
</td></tr>
<tr><td><code id="dist.Symbolic_+3A_type">type</code></td>
<td>
<p>type of distance used for symbolic interval-valued data
</p>
<p>U_2 - Ichino and Yaguchi distance
</p>
<p>M - distance between points given by means of intervals (for interval-values variables), 
</p>
<p>H - Hausdorff distance, 
</p>
<p>S - sum of distances between all corresponding vertices of hyperrectangles 
given by symbolic objects with interval-valued variables
</p>
</td></tr>
<tr><td><code id="dist.Symbolic_+3A_gamma">gamma</code></td>
<td>
<p>parameter for calculating Ichino and Yaguchi distance</p>
</td></tr>
<tr><td><code id="dist.Symbolic_+3A_power">power</code></td>
<td>
<p>parameter for calculating distance: Ichino and Yaguchi distance, Hausdorff distance</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Billard, L., Diday, E. (2006), <em>Symbolic data analysis. Conceptual statistics and data mining</em>, Wiley, Chichester. ISBN: 978-0-470-09016-9.
</p>
<p>Ichino, M., Yaguchi, H. (1994), <em>Generalized Minkowski metrics for mixed feature type data analysis</em>, &quot;IEEE Transactions on Systems Man and Cybernetics&quot;, Vol. 24, Issue 4, 698-708. Http://dx.doi.org/10.1109/21.286391.
</p>


<h3>See Also</h3>

<p><code>symbolicDA::dist.SDA</code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
dataSymbolic&lt;-cluster.Gen(numObjects=10,model=5,dataType="s")$data
print(dist.Symbolic(dataSymbolic))
</code></pre>

<hr>
<h2 id='HINoV.Mod'>Modification of Carmone, Kara &amp; Maxwell Heuristic Identification of Noisy Variables (HINoV) method</h2><span id='topic+HINoV.Mod'></span>

<h3>Description</h3>

<p>Modification of Heuristic Identification of Noisy Variables (HINoV) method</p>


<h3>Usage</h3>

<pre><code class='language-R'>HINoV.Mod (x, type="metric", s = 2, u, distance=NULL, 
	method = "kmeans", Index ="cRAND")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HINoV.Mod_+3A_x">x</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_type">type</code></td>
<td>
<p>&quot;metric&quot; (default) - all variables are metric (ratio, interval),
&quot;nonmetric&quot; - all variables are nonmetric (ordinal, nominal) or
vector containing for each variable value &quot;m&quot;(metric) or &quot;n&quot;(nonmetric) for mixed variables (metric and nonmetric), e.g. type=c(&quot;m&quot;, &quot;n&quot;, &quot;n&quot;, &quot;m&quot;)
</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_s">s</code></td>
<td>
<p>for metric data only: 1 - ratio data, 2 - interval or mixed (ratio &amp; interval) data</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_u">u</code></td>
<td>
<p>number of clusters (for metric data only)</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_distance">distance</code></td>
<td>
<p>NULL for kmeans method (based on data matrix) and nonmetric data
</p>
<p>for ratio data: &quot;d1&quot; - Manhattan, &quot;d2&quot; - Euclidean, &quot;d3&quot; - Chebychev (max), &quot;d4&quot; - squared Euclidean, &quot;d5&quot; - GDM1, &quot;d6&quot; - Canberra, &quot;d7&quot; - Bray-Curtis
</p>
<p>for interval or mixed (ratio &amp; interval) data: &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_method">method</code></td>
<td>
<p>NULL for nonmetric data
</p>
<p>clustering method: &quot;kmeans&quot; (default) , &quot;single&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;pam&quot;</p>
</td></tr>
<tr><td><code id="HINoV.Mod_+3A_index">Index</code></td>
<td>
<p>&quot;cRAND&quot; - corrected Rand index (default); &quot;RAND&quot; - Rand index</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/HINoVMod_details.pdf">../doc/HINoVMod_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>parim</code></td>
<td>
<p><em>m</em> x <em>m</em> symmetric matrix (<em>m</em> - number of variables). Matrix contains pairwise corrected Rand (Rand) indices for partitions formed by the <em>j</em>-th variable with partitions formed by the <em>l</em>-th variable</p>
</td></tr>
<tr><td><code>topri</code></td>
<td>
<p>sum of rows of <code>parim</code></p>
</td></tr>
<tr><td><code>stopri</code></td>
<td>
<p>ranked values of <code>topri</code> in decreasing order</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Carmone, F.J., Kara, A., Maxwell, S. (1999), <em>HINoV: a new method to improve market segment definition by identifying noisy variables</em>, &quot;Journal of Marketing Research&quot;, November, vol. 36, 501-509.
</p>
<p>Hubert, L.J., Arabie, P. (1985), <em>Comparing partitions</em>, &quot;Journal of Classification&quot;, no. 1, 193-218. Available at: <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.
</p>
<p>Rand, W.M. (1971), <em>Objective criteria for the evaluation of clustering methods</em>, &quot;Journal of the American Statistical Association&quot;, no. 336, 846-850. Available at: <a href="https://doi.org/10.1080/01621459.1971.10482356">doi:10.1080/01621459.1971.10482356</a>.
</p>
<p>Walesiak, M. (2005), <em>Variable selection for cluster analysis - approaches, problems, methods</em>, Plenary Session of the Committee on Statistics and Econometrics of the Polish Academy of Sciences, 15 March, Wroclaw.
</p>
<p>Walesiak, M., Dudek, A. (2008), <em>Identification of noisy variables for nonmetric and symbolic data in cluster analysis</em>, In: C. Preisach, H. Burkhardt, L. Schmidt-Thieme, R. Decker (Eds.), Data analysis, machine learning and applications, Springer-Verlag, Berlin, Heidelberg, 85-92. Available at: <a href="https://doi.org/10.1007/978-3-540-78246-9_11">doi:10.1007/978-3-540-78246-9_11</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="stats.html#topic+dist">dist</a></code>, <code><a href="#topic+dist.GDM">dist.GDM</a></code>, <code><a href="#topic+dist.BC">dist.BC</a></code>, <code><a href="#topic+dist.SM">dist.SM</a></code>, 
<code><a href="#topic+cluster.Sim">cluster.Sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for metric data
library(clusterSim)
data(data_ratio)
r1&lt;- HINoV.Mod(data_ratio, type="metric", s=1, 4, method="kmeans",
     Index="cRAND")
print(r1$stopri)
plot(r1$stopri[,2],xlab="Variable number", ylab="topri",
xaxt="n", type="b")
axis(1,at=c(1:max(r1$stopri[,1])),labels=r1$stopri[,1])

# for nonmetric data
library(clusterSim)
data(data_nominal)
r2&lt;- HINoV.Mod (data_nominal, type="nonmetric", Index = "cRAND")
print(r2$stopri)
plot(r2$stopri[,2], xlab="Variable number", ylab="topri",
xaxt="n", type="b")
axis(1,at=c(1:max(r2$stopri[,1])),labels=r2$stopri[,1])

# for mixed data
library(clusterSim)
data(data_mixed)
r3&lt;- HINoV.Mod(data_mixed, type=c("m","n","m","n"), s=2, 3, distance="d1",
     method="complete", Index="cRAND")
print(r3$stopri)
plot(r3$stopri[,2], xlab="Variable number", ylab="topri",
xaxt="n", type="b")
axis(1,at=c(1:max(r3$stopri[,1])),labels=r3$stopri[,1])

</code></pre>

<hr>
<h2 id='HINoV.Symbolic'>Modification of Carmone, Kara &amp; Maxwell Heuristic Identification of Noisy Variables (HINoV) method for symbolic interval data</h2><span id='topic+HINoV.Symbolic'></span>

<h3>Description</h3>

<p>Modification of Heuristic Identification of Noisy Variables (HINoV) method for symbolic interval data</p>


<h3>Usage</h3>

<pre><code class='language-R'>HINoV.Symbolic(x, u=NULL, distance="H", method = "pam", 
	Index = "cRAND")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="HINoV.Symbolic_+3A_x">x</code></td>
<td>
<p>symbolic interval data: a 3-dimensional table, first dimension represents object number, second dimension - variable number, and third dimension contains lower- and upper-bounds of intervals</p>
</td></tr>
<tr><td><code id="HINoV.Symbolic_+3A_u">u</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="HINoV.Symbolic_+3A_distance">distance</code></td>
<td>
<p>&quot;M&quot; - minimal distance between all vertices of hyper-cubes defined by symbolic interval variables; &quot;H&quot; - Hausdorff distance; &quot;S&quot; - sum of squares of distance between all vertices of hyper-cubes defined by symbolic interval variables </p>
</td></tr>
<tr><td><code id="HINoV.Symbolic_+3A_method">method</code></td>
<td>
<p>clustering method: &quot;single&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;pam&quot; (default)</p>
</td></tr>
<tr><td><code id="HINoV.Symbolic_+3A_index">Index</code></td>
<td>
<p>&quot;cRAND&quot; - corrected Rand index (default); &quot;RAND&quot; - Rand index</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/HINoVSymbolic_details.pdf">../doc/HINoVSymbolic_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>parim</code></td>
<td>
<p><em>m</em> x <em>m</em> symmetric matrix (<em>m</em> - number of variables). Matrix contains pairwise corrected Rand (Rand) indices for partitions formed by the <em>j</em>-th variable with partitions formed by the <em>l</em>-th variable</p>
</td></tr>
<tr><td><code>topri</code></td>
<td>
<p>sum of rows of <code>parim</code></p>
</td></tr>
<tr><td><code>stopri</code></td>
<td>
<p>ranked values of <code>topri</code> in decreasing order</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Carmone, F.J., Kara, A., Maxwell, S. (1999), <em>HINoV: a new method to improve market segment definition by identifying noisy variables</em>, &quot;Journal of Marketing Research&quot;, November, vol. 36, 501-509.
</p>
<p>Hubert, L.J., Arabie, P. (1985), <em>Comparing partitions</em>, &quot;Journal of Classification&quot;, no. 1, 193-218. Available at: <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.
</p>
<p>Rand, W.M. (1971), <em>Objective criteria for the evaluation of clustering methods</em>, &quot;Journal of the American Statistical Association&quot;, no. 336, 846-850. Available at: <a href="https://doi.org/10.1080/01621459.1971.10482356">doi:10.1080/01621459.1971.10482356</a>.
</p>
<p>Walesiak, M., Dudek, A. (2008), <em>Identification of noisy variables for nonmetric and symbolic data in cluster analysis</em>, In: C. Preisach, H. Burkhardt, L. Schmidt-Thieme, R. Decker (Eds.), Data analysis, machine learning and applications, Springer-Verlag, Berlin, Heidelberg, 85-92. Available at: <a href="https://doi.org/10.1007/978-3-540-78246-9_11">doi:10.1007/978-3-540-78246-9_11</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, <code><a href="#topic+cluster.Sim">cluster.Sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_symbolic)
r&lt;- HINoV.Symbolic(data_symbolic, u=5)
print(r$stopri)
plot(r$stopri[,2], xlab="Variable number", ylab="topri",
xaxt="n", type="b")
axis(1,at=c(1:max(r$stopri[,1])),labels=r$stopri[,1])

#symbolic data from .csv file
#library(clusterSim)
#dsym&lt;-as.matrix(read.csv2(file="csv/symbolic.csv"))
#dim(dsym)&lt;-c(dim(dsym)[1],dim(dsym)[2]%/%2,2)          
#r&lt;- HINoV.Symbolic(dsym, u=5)
#print(r$stopri)
#plot(r$stopri[,2], xlab="Variable number", ylab="topri",
#xaxt="n", type="b")
#axis(1,at=c(1:max(r$stopri[,1])),labels=r$stopri[,1])

</code></pre>

<hr>
<h2 id='index.C'>Calculates Hubert &amp; Levin C index - internal cluster quality index</h2><span id='topic+index.C'></span>

<h3>Description</h3>

<p>Calculates Hubert &amp; Levin C index - internal cluster quality index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.C(d,cl)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.C_+3A_d">d</code></td>
<td>
<p>'dist' object</p>
</td></tr>
<tr><td><code id="index.C_+3A_cl">cl</code></td>
<td>
<p>A vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\indexC_details.pdf for further details
</p>
<p>Thanks to Özge Sahin from Technical University of Munich for for pointing the difference between <code><a href="#topic+index.G3">index.G3</a></code> and <code><a href="#topic+index.C">index.C</a></code>.
</p>


<h3>Value</h3>

<p>calculated C index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Hubert, L.J., Levin, J.R. (1976), A General Statistical Framework for Assessing Categorical Clustering in Free Recall, Psychological Bulletin, Vol. 83, No. 6, 1072-1080.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>,  <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.S">index.S</a></code>, 
<code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
d &lt;- dist.GDM(data_ratio)
c &lt;- pam(d, 5, diss = TRUE)
icq &lt;- index.C(d,c$clustering)
print(icq)

# Example 2
library(clusterSim)
data(data_ordinal)
d &lt;- dist.GDM(data_ordinal, method="GDM2")
# nc - number_of_clusters
min_nc=2
max_nc=6
res &lt;- array(0,c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(d, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1,2] &lt;- C &lt;- index.C(d,cl2)
clusters &lt;- rbind(clusters,cl2)
}
print(paste("min C for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min C-index")
print(clusters[which.min(res[,2]),])
#write.table(res,file="C_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="C", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.DB'>Calculates Davies-Bouldin's index</h2><span id='topic+index.DB'></span>

<h3>Description</h3>

<p>Calculates Davies-Bouldin's cluster separation measure</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.DB(x, cl, d=NULL, centrotypes="centroids", p=2, q=2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.DB_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="index.DB_+3A_cl">cl</code></td>
<td>
<p>vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
<tr><td><code id="index.DB_+3A_d">d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes=&quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.DB_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.DB_+3A_p">p</code></td>
<td>
<p>the power of the Minkowski distance between centroids or medoids of clusters: p=1 - Manhattan distance; p=2 - Euclidean distance</p>
</td></tr>
<tr><td><code id="index.DB_+3A_q">q</code></td>
<td>
<p>the power of dispersion measure of a cluster: q=1 - the average distance of objects in the r-th cluster to the centroid or medoid
of the r-th cluster; q=2 - the standard deviation of the distance of objects in the r-th cluster to the centroid or medoid of the r-th cluster</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/indexDB_details.pdf">../doc/indexDB_details.pdf</a> for further details
</p>
<p>Thanks to prof. Christian Hennig <a href="mailto:c.hennig@ucl.ac.uk">c.hennig@ucl.ac.uk</a> for finding and fixing the &quot;immutable p&quot; error  
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>DB</code></td>
<td>
<p>Davies-Bouldin's index</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>vector of maximal R values for each cluster</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>R matrix <code class="reqn">(S_r+S_s)/d_{rs}</code> </p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>matrix of distances between centroids or medoids of clusters</p>
</td></tr>
<tr><td><code>S</code></td>
<td>
<p>vector of dispersion measures for each cluster</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>coordinates of centroids or medoids for all clusters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Davies, D.L., Bouldin, D.W. (1979), <em>A cluster separation measure</em>, IEEE Transactions on Pattern Analysis and Machine Intelligence, vol. 1, no. 2, 224-227. Available at: <a href="https://doi.org/10.1109/TPAMI.1979.4766909">doi:10.1109/TPAMI.1979.4766909</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
cl1 &lt;- pam(data_ratio, 4)
d&lt;-dist(data_ratio)
print(index.DB(data_ratio, cl1$clustering,d, centrotypes="medoids"))

# Example 2
library(clusterSim)
data(data_ratio)
cl2 &lt;- pam(data_ratio, 5)
print(index.DB(data_ratio, cl2$clustering, centrotypes="centroids"))

# Example 3
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="euclidean")
# nc - number_of_clusters
min_nc=2
max_nc=8
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(md, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1, 2] &lt;- DB &lt;- index.DB(data_ratio, cl2, centrotypes="centroids")$DB
clusters &lt;- rbind(clusters, cl2)
}
print(paste("min DB for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min DB")
print(clusters[which.min(res[,2]),])
#write.table(res,file="DB_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="DB", xaxt="n")
axis(1, c(min_nc:max_nc))

# Example 4
library(clusterSim)
data(data_ordinal)
md &lt;- dist.GDM(data_ordinal, method="GDM2")
# nc - number_of_clusters
min_nc=2
max_nc=6
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(md, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1,2] &lt;- DB &lt;- index.DB(data_ordinal,cl2,d=md,centrotypes="medoids")$DB
clusters &lt;- rbind(clusters, cl2)
}
print(paste("min DB for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min DB")
print(clusters[which.min(res[,2]),])
#write.table(res,file="DB_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="DB", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.G1'>Calculates Calinski-Harabasz pseudo F-statistic</h2><span id='topic+index.G1'></span>

<h3>Description</h3>

<p>Calculates Calinski-Harabasz pseudo F-statistic</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.G1 (x,cl,d=NULL,centrotypes="centroids")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.G1_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="index.G1_+3A_cl">cl</code></td>
<td>
<p>A vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
<tr><td><code id="index.G1_+3A_d">d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes=&quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.G1_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/indexG1_details.pdf">../doc/indexG1_details.pdf</a> for further details.
</p>
<p>thank to Nejc Ilc from University of Ljubljana for fixing error for one-element clusters.
</p>


<h3>Value</h3>

<p>Calinski-Harabasz pseudo F-statistic
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Calinski, T., Harabasz, J. (1974), <em>A dendrite method for cluster analysis</em>, &quot;Communications in Statistics&quot;, vol. 3, 1-27. Available at: <a href="https://doi.org/10.1080/03610927408827101">doi:10.1080/03610927408827101</a>.
</p>
<p>Everitt, B.S., Landau, E., Leese, M. (2001), <em>Cluster analysis</em>, Arnold, London, p. 103. ISBN 9780340761199.
</p>
<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, p. 338.
</p>
<p>Gordon, A.D. (1999), <em>Classification</em>, Chapman &amp; Hall/CRC, London, p. 62. ISBN 9781584880134.
</p>
<p>Milligan, G.W., Cooper, M.C. (1985), <em>An examination of procedures of determining the number of cluster in a data set</em>, &quot;Psychometrika&quot;, vol. 50, no. 2, 159-179. Available at: <a href="https://doi.org/10.1007/BF02294245">doi:10.1007/BF02294245</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G2">index.G2</a></code>,<code><a href="#topic+index.G3">index.G3</a></code>,<code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.H">index.H</a></code>,<code><a href="#topic+index.KL">index.KL</a></code>,<code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
c&lt;- pam(data_ratio,10)
index.G1(data_ratio,c$clustering)

# Example 2
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="euclidean")
# nc - number_of_clusters
min_nc=2
max_nc=20
res &lt;- array(0,c(max_nc-min_nc+1,2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
cl2 &lt;- pam(md, nc, diss=TRUE)
res[nc-min_nc+1,2] &lt;- G1 &lt;- index.G1(data_ratio,cl2$cluster,centrotypes="centroids")
clusters &lt;- rbind(clusters, cl2$cluster)
}
print(paste("max G1 for",(min_nc:max_nc)[which.max(res[,2])],"clusters=",max(res[,2])))
print("clustering for max G1")
print(clusters[which.max(res[,2]),])
#write.table(res,file="G1_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="G1", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.G2'>Calculates G2 internal cluster quality index</h2><span id='topic+index.G2'></span>

<h3>Description</h3>

<p>Calculates G2 internal cluster quality index - Baker &amp; Hubert adaptation of Goodman &amp; Kruskal's Gamma statistic</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.G2(d,cl)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.G2_+3A_d">d</code></td>
<td>
<p>'dist' object</p>
</td></tr>
<tr><td><code id="index.G2_+3A_cl">cl</code></td>
<td>
<p>A vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\indexG2_details.pdf for further details
</p>


<h3>Value</h3>

<p>calculated G2 index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Everitt, B.S., Landau, E., Leese, M. (2001), <em>Cluster analysis</em>, Arnold, London, p. 104. ISBN 9780340761199.
</p>
<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, p. 339.
</p>
<p>Gordon, A.D. (1999), <em>Classification</em>, Chapman &amp; Hall/CRC, London, p. 62. ISBN 9781584880134.
</p>
<p>Hubert, L. (1974), <em>Approximate evaluation technique for the single-link and complete-link hierarchical clustering procedures</em>, &quot;Journal of the American Statistical Association&quot;, vol. 69, no. 347, 698-704. Available at: <a href="https://doi.org/10.1080/01621459.1974.10480191">doi:10.1080/01621459.1974.10480191</a>.
</p>
<p>Milligan, G.W., Cooper, M.C. (1985), <em>An examination of procedures of determining the number of cluster in a data set</em>, &quot;Psychometrika&quot;, vol. 50, no. 2, 159-179. Available at: <a href="https://doi.org/10.1007/BF02294245">doi:10.1007/BF02294245</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.H">index.H</a></code>, 
<code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.C">index.C</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
d &lt;- dist.GDM(data_ratio)
c &lt;- pam(d, 5, diss = TRUE)
icq &lt;- index.G2(d,c$clustering)
#print(icq)

# Example 2
library(clusterSim)
data(data_ordinal)
d &lt;- dist.GDM(data_ordinal, method="GDM2")
# nc - number_of_clusters
min_nc=2
max_nc=6
res &lt;- array(0,c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
  cl2 &lt;- pam(d, nc, diss=TRUE)
  res[nc-min_nc+1,2] &lt;- G2 &lt;- index.G2(d,cl2$cluster)
  clusters &lt;- rbind(clusters,cl2$cluster)
}
print(paste("max G2 for",(min_nc:max_nc)[which.max(res[,2])],"clusters=",max(res[,2])))
print("clustering for max G2")
print(clusters[which.max(res[,2]),])
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="G2", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.G3'>Calculates G3 internal cluster quality index</h2><span id='topic+index.G3'></span>

<h3>Description</h3>

<p>Calculates G3 internal cluster quality index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.G3(d,cl)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.G3_+3A_d">d</code></td>
<td>
<p>'dist' object</p>
</td></tr>
<tr><td><code id="index.G3_+3A_cl">cl</code></td>
<td>
<p>A vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\indexG3_details.pdf for further details
</p>


<h3>Value</h3>

<p>calculated G3 index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Gordon, A.D. (1999), <em>Classification</em>, Chapman &amp; Hall/CRC, London, p. 62. ISBN 9781584880134.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
d &lt;- dist.GDM(data_ratio)
c &lt;- pam(d, 5, diss = TRUE)
icq &lt;- index.G3(d,c$clustering)
print(icq)

# Example 2
library(clusterSim)
data(data_ordinal)
d &lt;- dist.GDM(data_ordinal, method="GDM2")
# nc - number_of_clusters
min_nc=2
max_nc=6
res &lt;- array(0,c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
hc &lt;- hclust(d, method="complete")
cl2 &lt;- cutree(hc, k=nc)
res[nc-min_nc+1,2] &lt;- G3 &lt;- index.G3(d,cl2)
clusters &lt;- rbind(clusters,cl2)
}
print(paste("min G3 for",(min_nc:max_nc)[which.min(res[,2])],"clusters=",min(res[,2])))
print("clustering for min G3")
print(clusters[which.min(res[,2]),])
#write.table(res,file="G3_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="G3", xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.Gap'>Calculates Tibshirani, Walther and Hastie gap index</h2><span id='topic+index.Gap'></span>

<h3>Description</h3>

<p>Calculates Tibshirani, Walther and Hastie gap index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.Gap (x, clall, reference.distribution="unif", B=10, 
	method="pam",d=NULL,centrotypes="centroids")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.Gap_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_clall">clall</code></td>
<td>
<p>Two vectors of integers indicating the cluster to which each object is allocated in partition of n objects into u, and u+1 clusters</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_reference.distribution">reference.distribution</code></td>
<td>
<p>&quot;unif&quot; - generate each reference variable uniformly over the range of the observed values for that variable
or
&quot;pc&quot; - generate the reference variables from a uniform distribution over a box aligned with the principal components of the data. In detail, if <code class="reqn">X=\{x_{ij}\}</code>  is our   n x m data matrix, assume that the columns have mean 0 and compute the singular value decomposition $X=UDV^T$. We transform via $X'=XV$ and then draw uniform features Z'  over the ranges of the columns of X' , as in method a) above. Finally we back-transform via $Z=Z'V^T$   to give reference data Z 
</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_b">B</code></td>
<td>
<p>the number of simulations used to compute the gap statistic</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_method">method</code></td>
<td>
<p>the cluster analysis method to be used. This should be one of: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;pam&quot;, &quot;k-means&quot;,&quot;diana&quot;</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_d">d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes=&quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.Gap_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/indexGap_details.pdf">../doc/indexGap_details.pdf</a> for further details
</p>
<p>Thanks to dr Michael P. Fay from National Institute of Allergy and Infectious Diseases for finding &quot;one column error&quot;.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>Gap</code></td>
<td>
<p>Tibshirani, Walther and Hastie gap index for u clusters</p>
</td></tr>
<tr><td><code>diffu</code></td>
<td>
<p>necessary value for choosing correct number of clusters via gap statistic Gap(u)-[Gap(u+1)-s(u+1)]</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Tibshirani, R., Walther, G., Hastie, T. (2001), <em>Estimating the number of clusters in a data set via the gap statistic</em>, &quot;Journal of the Royal Statistical Society&quot;, ser. B, vol. 63, part 2, 411-423. Available at: <a href="https://doi.org/10.1111/1467-9868.00293">doi:10.1111/1467-9868.00293</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
cl1&lt;-pam(data_ratio,4)
cl2&lt;-pam(data_ratio,5)
clall&lt;-cbind(cl1$clustering,cl2$clustering)
g&lt;-index.Gap(data_ratio, clall, reference.distribution="unif", B=10,
   method="pam")
print(g)

# Example 2
library(clusterSim)
means &lt;- matrix(c(0,2,4,0,3,6), 3, 2)
cov &lt;- matrix(c(1,-0.9,-0.9,1), 2, 2)
x &lt;- cluster.Gen(numObjects=40, means=means, cov=cov, model=2)
x &lt;- x$data
md &lt;- dist(x, method="euclidean")^2
# nc - number_of_clusters
min_nc=1
max_nc=5
min &lt;- 0
clopt &lt;- NULL
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
found &lt;- FALSE
for (nc in min_nc:max_nc){
  cl1 &lt;- pam(md, nc, diss=TRUE)
  cl2 &lt;- pam(md, nc+1, diss=TRUE)
  clall &lt;- cbind(cl1$clustering, cl2$clustering)
  gap &lt;- index.Gap(x,clall,B=20,method="pam",centrotypes="centroids")
  res[nc-min_nc+1, 2] &lt;- diffu &lt;- gap$diffu
  if ((res[nc-min_nc+1, 2] &gt;=0) &amp;&amp; (!found)){
    nc1 &lt;- nc
    min &lt;- diffu
    clopt &lt;- cl1$cluster
    found &lt;- TRUE
  }
}
if (found){
print(paste("Minimal nc where diffu&gt;=0 is",nc1,"for diffu=",round(min,4)),quote=FALSE)
}else{
print("I have not found clustering with diffu&gt;=0", quote=FALSE)
}
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="diffu",xaxt="n")
abline(h=0, untf=FALSE)
axis(1, c(min_nc:max_nc))

# Example 3
library(clusterSim)
means &lt;- matrix(c(0,2,4,0,3,6), 3, 2)
cov &lt;- matrix(c(1,-0.9,-0.9,1), 2, 2)
x &lt;- cluster.Gen(numObjects=40, means=means, cov=cov, model=2)
x &lt;- x$data
md &lt;- dist(x, method="euclidean")^2
# nc - number_of_clusters
min_nc=1
max_nc=5
min &lt;- 0
clopt &lt;- NULL
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
found &lt;- FALSE
for (nc in min_nc:max_nc){
  cl1 &lt;- pam(md, nc, diss=TRUE)
  cl2 &lt;- pam(md, nc+1, diss=TRUE)
  clall &lt;- cbind(cl1$clustering, cl2$clustering)
  gap &lt;- index.Gap(x,clall,B=20,method="pam",d=md,centrotypes="medoids")
  res[nc-min_nc+1, 2] &lt;- diffu &lt;- gap$diffu
  if ((res[nc-min_nc+1, 2] &gt;=0) &amp;&amp; (!found)){
    nc1 &lt;- nc
    min &lt;- diffu
    clopt &lt;- cl1$cluster
    found &lt;- TRUE
  }
}
if (found){
print(paste("Minimal nc where diffu&gt;=0 is",nc1,"for diffu=",round(min,4)),quote=FALSE)
}else{
print("I have not found clustering with diffu&gt;=0",quote=FALSE)
}
plot(res, type="p", pch=0, xlab="Number of clusters", ylab="diffu", xaxt="n")
abline(h=0, untf=FALSE)
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.H'>Calculates Hartigan index</h2><span id='topic+index.H'></span>

<h3>Description</h3>

<p>Calculates Hartigan index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.H (x,clall,d=NULL,centrotypes="centroids")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.H_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="index.H_+3A_clall">clall</code></td>
<td>
<p>Two vectors of integers indicating the cluster to which each object is allocated in partition of n objects into u and u+1 clusters</p>
</td></tr>
<tr><td><code id="index.H_+3A_d">d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes=&quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.H_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\indexH_details.pdf for further details
</p>


<h3>Value</h3>

<p>Hartigan index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Hartigan, J. (1975), <em>Clustering algorithms</em>, Wiley, New York. ISBN 047135645X. 
</p>
<p>Milligan, G.W., Cooper, M.C. (1985), <em>An examination of procedures of determining the number of cluster in a data set</em>, &quot;Psychometrika&quot;, vol. 50, no. 2, 159-179. Available at: <a href="https://doi.org/10.1007/BF02294245">doi:10.1007/BF02294245</a>.
</p>
<p>Tibshirani, R., Walther, G., Hastie, T. (2001), <em>Estimating the number of clusters in a data set via the gap statistic</em>, &quot;Journal of the Royal Statistical Society&quot;, ser. B, vol. 63, part 2, 411-423. Available at: <a href="https://doi.org/10.1111/1467-9868.00293">doi:10.1111/1467-9868.00293</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
cl1&lt;-pam(data_ratio,4)
cl2&lt;-pam(data_ratio,5)
clall&lt;-cbind(cl1$clustering,cl2$clustering)
index.H(data_ratio,clall)

# Example 2
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="euclidean")
# nc - number_of_clusters
min_nc=1
max_nc=20
min &lt;- 0
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
found &lt;- FALSE
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
	print(nc)
	hc &lt;- hclust(md, method="complete")
	cl1 &lt;- cutree(hc, k=nc)
	cl2 &lt;- cutree(hc, k=nc+1)
	clall &lt;- cbind(cl1,cl2)
	res[nc-min_nc+1,2] &lt;- H &lt;- index.H(data_ratio,clall,centrotypes="centroids")
	if ((res[nc-min_nc+1, 2]&lt;10) &amp;&amp; (!found)){
       nc1 &lt;- nc
       min &lt;- H
       clopt &lt;- cl1
		   found &lt;- TRUE
	}
}
if (found)
{
	print(paste("minimal nc for H&lt;=10 equals",nc1,"for H=",min))
	print("clustering for minimal nc where H&lt;=10")
	print(clopt)
}else
{
	print("Clustering not found with H&lt;=10")
}
#write.table(res,file="H_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="H",xaxt="n")
abline(h=10, untf=FALSE)
axis(1, c(min_nc:max_nc))

# Example 3
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="manhattan")
# nc - number_of_clusters
min_nc=1
max_nc=20
min &lt;- 0
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
found &lt;- FALSE
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
	print(nc)
	hc &lt;- hclust(md, method="complete")
	cl1 &lt;- cutree(hc, k=nc)
	cl2 &lt;- cutree(hc, k=nc+1)
	clall &lt;- cbind(cl1,cl2)
	res[nc-min_nc+1,2] &lt;- H &lt;- index.H(data_ratio,clall,d=md,centrotypes="medoids")
	if ((res[nc-min_nc+1, 2]&lt;10) &amp;&amp; (!found)){
       nc1 &lt;- nc
       min &lt;- H
       clopt &lt;- cl1
		   found &lt;- TRUE
	}
}
if (found)
{
	print(paste("minimal nc for H&lt;=10 equals",nc1,"for H=",min))
	print("clustering for minimal nc where H&lt;=10")
	print(clopt)
}else
{
	print("Clustering not found with H&lt;=10")
}
#write.table(res,file="H_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="H",xaxt="n")
abline(h=10, untf=FALSE)
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.KL'>Calculates Krzanowski-Lai index</h2><span id='topic+index.KL'></span>

<h3>Description</h3>

<p>Calculates Krzanowski-Lai index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.KL (x,clall,d=NULL,centrotypes="centroids")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.KL_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="index.KL_+3A_clall">clall</code></td>
<td>
<p>Three vectors of integers indicating the cluster to which each object is allocated in partition of n objects into u-1, u, and u+1 clusters</p>
</td></tr>
<tr><td><code id="index.KL_+3A_d">d</code></td>
<td>
<p>optional distance matrix, used for calculations if centrotypes=&quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="index.KL_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/indexKL_details.pdf">../doc/indexKL_details.pdf</a> for further details
</p>


<h3>Value</h3>

<p>Krzanowski-Lai index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Krzanowski, W.J., Lai, Y.T. (1988), <em>A criterion for determining the number of groups in a data set using sum of squares clustering</em>, &quot;Biometrics&quot;, 44, 23-34.
</p>
<p>Milligan, G.W., Cooper, M.C. (1985), <em>An examination of procedures of determining the number of cluster in a data set</em>, &quot;Psychometrika&quot;, vol. 50, no. 2, 159-179. Available at: <a href="https://doi.org/10.1007/BF02294245">doi:10.1007/BF02294245</a>.
</p>
<p>Tibshirani, R., Walther, G., Hastie, T. (2001), <em>Estimating the number of clusters in a data set via the gap statistic</em>, &quot;Journal of the Royal Statistical Society&quot;, ser. B, vol. 63, part 2, 411-423. Available at: <a href="https://doi.org/10.1111/1467-9868.00293">doi:10.1111/1467-9868.00293</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.S">index.S</a></code>, <code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
cl1&lt;-pam(data_ratio,4)
cl2&lt;-pam(data_ratio,5)
cl3&lt;-pam(data_ratio,6)
clall&lt;-cbind(cl1$clustering,cl2$clustering,cl3$clustering)
index.KL(data_ratio,clall)

# Example 2
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="manhattan")
# nc - number_of_clusters
min_nc=2
max_nc=15
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
  if(nc-1==1){
    clustering1&lt;-rep(1,nrow(data_ratio))
  }
  else{
    clustering1 &lt;- pam(md, nc-1, diss=TRUE)$clustering
  }
  clustering2 &lt;- pam(md, nc, diss=TRUE)$clustering
  clustering3 &lt;- pam(md, nc+1, diss=TRUE)$clustering
  clall&lt;- cbind(clustering1, clustering2, clustering3)
  res[nc-min_nc+1,2] &lt;- KL &lt;- index.KL(data_ratio,clall,centrotypes="centroids")
  clusters &lt;- rbind(clusters, clustering2)
} 
print(paste("max KL for",(min_nc:max_nc)[which.max(res[,2])],"clusters=",max(res[,2])))
print("clustering for max KL")
print(clusters[which.max(res[,2]),])
#write.table(res,file="KL_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="KL",xaxt="n")
axis(1, c(min_nc:max_nc))

# Example 3
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="manhattan")
# nc - number_of_clusters
min_nc=2
max_nc=15
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
  if(nc-1==1){
    clustering1&lt;-rep(1,nrow(data_ratio))
  }
  else{
    clustering1 &lt;- pam(md, nc-1, diss=TRUE)$clustering
  }
  clustering2 &lt;- pam(md, nc, diss=TRUE)$clustering
  clustering3 &lt;- pam(md, nc+1, diss=TRUE)$clustering
  clall&lt;- cbind(clustering1, clustering2, clustering3)
  res[nc-min_nc+1,2] &lt;- KL &lt;- index.KL(data_ratio,clall,d=md,centrotypes="medoids")
  clusters &lt;- rbind(clusters, clustering2)
} 
print(paste("max KL for",(min_nc:max_nc)[which.max(res[,2])],"clusters=",max(res[,2])))
print("clustering for max KL")
print(clusters[which.max(res[,2]),])
#write.table(res,file="KL_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="KL",xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='index.S'>Calculates Rousseeuw's Silhouette internal cluster quality index</h2><span id='topic+index.S'></span>

<h3>Description</h3>

<p>Calculates Rousseeuw's Silhouette internal cluster quality index</p>


<h3>Usage</h3>

<pre><code class='language-R'>index.S(d,cl,singleObject=0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index.S_+3A_d">d</code></td>
<td>
<p>'dist' object</p>
</td></tr>
<tr><td><code id="index.S_+3A_cl">cl</code></td>
<td>
<p>A vector of integers indicating the cluster to which each object is allocated</p>
</td></tr>
<tr><td><code id="index.S_+3A_singleobject">singleObject</code></td>
<td>
<p>0 - s(i)=0 or 1 - s(i)=1. When cluster contains a single object, it is unclear how a(i) of Silhouette index should be defined (see Kaufman &amp; Rousseeuw (1990), p. 85).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file $R_HOME\library\clusterSim\pdf\indexS_details.pdf for further details
</p>


<h3>Value</h3>

<p>calculated Silhouette index
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Gatnar, E., Walesiak, M. (Eds.) (2004), <em>Metody statystycznej analizy wielowymiarowej w badaniach marketingowych [Multivariate statistical analysis methods in marketing research]</em>, Wydawnictwo AE, Wroclaw, 342-343, erratum.
</p>
<p>Kaufman, L., Rousseeuw, P.J. (1990), <em>Finding groups in data: an introduction to cluster analysis</em>, Wiley, New York, pp. 83-88. ISBN: 978-0-471-73578-6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+index.G1">index.G1</a></code>, <code><a href="#topic+index.G2">index.G2</a></code>, <code><a href="#topic+index.G3">index.G3</a></code>, <code><a href="#topic+index.C">index.C</a></code>,
<code><a href="#topic+index.KL">index.KL</a></code>, <code><a href="#topic+index.H">index.H</a></code>, <code><a href="#topic+index.Gap">index.Gap</a></code>, <code><a href="#topic+index.DB">index.DB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ratio)
d &lt;- dist.GDM(data_ratio)
c &lt;- pam(d, 5, diss = TRUE)
icq &lt;- index.S(d,c$clustering)
print(icq)

# Example 2
library(clusterSim)
data(data_ratio)
md &lt;- dist(data_ratio, method="manhattan")
# nc - number_of_clusters
min_nc=2
max_nc=20
res &lt;- array(0, c(max_nc-min_nc+1, 2))
res[,1] &lt;- min_nc:max_nc
clusters &lt;- NULL
for (nc in min_nc:max_nc)
{
cl2 &lt;- pam(md, nc, diss=TRUE)
res[nc-min_nc+1, 2] &lt;- S &lt;- index.S(md,cl2$cluster)
clusters &lt;- rbind(clusters, cl2$cluster)
}
print(paste("max S for",(min_nc:max_nc)[which.max(res[,2])],"clusters=",max(res[,2])))
print("clustering for max S")
print(clusters[which.max(res[,2]),])
#write.table(res,file="S_res.csv",sep=";",dec=",",row.names=TRUE,col.names=FALSE)
plot(res,type="p",pch=0,xlab="Number of clusters",ylab="S",xaxt="n")
axis(1, c(min_nc:max_nc))
</code></pre>

<hr>
<h2 id='initial.Centers'>Calculation of initial clusters centers for k-means like alghoritms</h2><span id='topic+initial.Centers'></span>

<h3>Description</h3>

<p>Function calculates initial clusters centers for k-means like alghoritms with the following alghoritm (similar to SPSS QuickCluster function)
</p>
<p>(a) if the distance between <code class="reqn">x_k</code> and its closest cluster center is greater
than the distance between the two closest centers (<code class="reqn">M_m</code> and <code class="reqn">M_n</code> ), then <code class="reqn">x_k</code>
replaces either <code class="reqn">M_m</code> or <code class="reqn">M_n</code>, whichever is closer to <code class="reqn">x_k</code>.
</p>
<p>(b) If <code class="reqn">x_k</code> does not replace a cluster initial center in (a), a second test is made:
If that distance <code class="reqn">d_q</code>  greater than the distance between <code class="reqn">M_q</code> and its closest
<code class="reqn">M_i</code>, then <code class="reqn">x_k</code> replaces <code class="reqn">M_q</code>. 
</p>
<p>where:
</p>
<p><code class="reqn">M_i</code> - initial center of <em>i-th</em> cluster
</p>
<p><code class="reqn">x_k</code> - vector of <em>k-th</em> observation
</p>
<p><code class="reqn">d(...,...)</code> - Euclidean distance
</p>
<p><code class="reqn">d_{mn}</code> = <code class="reqn">min_{ij}  d(M_i,M_j)</code>
</p>
<p><code class="reqn">d_q  = min_i d(x_k,M_i)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initial.Centers(x, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initial.Centers_+3A_x">x</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="initial.Centers_+3A_k">k</code></td>
<td>
<p>number of initial cluster centers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numbers of objects choosen as initial cluster centers 
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Hartigan, J. (1975), <em>Clustering algorithms</em>, Wiley, New York. ISBN 0-471-35645-X.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster.Sim">cluster.Sim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example 1 (numbers of objects choosen as initial cluster centers)
library(clusterSim)
data(data_ratio)
ic &lt;- initial.Centers(data_ratio, 10)
print(ic)

#Example 2 (application with kmeans algorithm)
library(clusterSim)
data(data_ratio)
kmeans(data_ratio,data_ratio[initial.Centers(data_ratio, 10),]) 

</code></pre>

<hr>
<h2 id='interval_normalization'>Types of normalization formulas for interval-valued symbolic variables</h2><span id='topic+interval_normalization'></span>

<h3>Description</h3>

<p>Types of normalization formulas for interval-valued symbolic variables</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_normalization(x,dataType="simple",type="n0",y=NULL,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_normalization_+3A_x">x</code></td>
<td>
<p>matrix dataset or symbolic table object</p>
</td></tr>
<tr><td><code id="interval_normalization_+3A_datatype">dataType</code></td>
<td>
<p>Type of symbolic data table passed to function, 
</p>
<p>'sda' - full symbolicDA format object; 
</p>
<p>'simple' - three dimensional array with lower and upper bound of intervals in third dimension;
</p>
<p>'separate_tables' - lower bounds of intervals in <code>x</code>, upper bounds in  <code>y</code>;
</p>
<p>'rows' - lower and upper bound of intervals in neighbouring rows;
</p>
<p>'columns' - lower and upper bound of intervals in neighbouring columns
</p>
</td></tr>
<tr><td><code id="interval_normalization_+3A_type">type</code></td>
<td>
<p>type of normalization:</p>
</td></tr>
</table>
<p>n0 - without normalization 
</p>
<p>n1 - standardization ((x-mean)/sd)
</p>
<p>n2 - positional standardization ((x-median)/mad)
</p>
<p>n3 - unitization ((x-mean)/range)
</p>
<p>n3a - positional unitization ((x-median)/range)
</p>
<p>n4 - unitization with zero minimum ((x-min)/range)
</p>
<p>n5 - normalization in range &lt;-1,1&gt; ((x-mean)/max(abs(x-mean)))
</p>
<p>n5a - positional normalization in range &lt;-1,1&gt; ((x-median)/max(abs(x-median)))
</p>
<p>n6 - quotient transformation (x/sd)
</p>
<p>n6a - positional quotient transformation (x/mad)
</p>
<p>n7 - quotient transformation (x/range)
</p>
<p>n8 - quotient transformation (x/max)
</p>
<p>n9 - quotient transformation (x/mean)
</p>
<p>n9a - positional quotient transformation (x/median)
</p>
<p>n10 - quotient transformation (x/sum)
</p>
<p>n11 - quotient transformation (x/sqrt(SSQ))
</p>
<p>n12 - normalization ((x-mean)/sqrt(sum((x-mean)^2)))
</p>
<p>n12a - positional normalization ((x-median)/sqrt(sum((x-median)^2)))
</p>
<p>n13 - normalization with zero being the central point ((x-midrange)/(range/2))
</p>
<table role = "presentation">
<tr><td><code id="interval_normalization_+3A_y">y</code></td>
<td>
<p>matrix or dataset with upper bounds of intervals if argument <code>dataType</code> is uuqual to &quot;separate_tables&quot;</p>
</td></tr>
<tr><td><code id="interval_normalization_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>sum</code>, <code>mean</code>, <code>min</code> <code>sd</code>, <code>mad</code> and other aggregation functions. In particular: 
<code>na.rm</code> - a logical value indicating whether NA values should be stripped before the computation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized data
</p>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Jajuga, K., Walesiak, M. (2000), <em>Standardisation of data set under different measurement scales</em>, In: R. Decker, W. Gaul (Eds.), Classification and information processing at the turn of the millennium, Springer-Verlag, Berlin, Heidelberg, 105-112. Available at: <a href="https://doi.org/10.1007/978-3-642-57280-7_11">doi:10.1007/978-3-642-57280-7_11</a>.
</p>
<p>Milligan, G.W., Cooper, M.C. (1988), <em>A study of standardization of variables in cluster analysis</em>, &quot;Journal of Classification&quot;, vol. 5, 181-204. Available at: <a href="https://doi.org/10.1007/BF01897163">doi:10.1007/BF01897163</a>.
</p>
<p>Walesiak, M. (2014), <em>Przeglad formul normalizacji wartosci zmiennych oraz ich wlasnosci w statystycznej analizie wielowymiarowej [Data normalization in multivariate data analysis. An overview and properties]</em>, &quot;Przeglad Statystyczny&quot; (&quot;Statistical Review&quot;), vol. 61, no. 4, 363-372. Available at: <a href="https://doi.org/10.5604/01.3001.0016.1740">doi:10.5604/01.3001.0016.1740</a>.
</p>
<p>Walesiak, M., Dudek, A. (2017), <em>Selecting the Optimal Multidimensional Scaling Procedure for Metric Data with R Environment</em>, „STATISTICS IN TRANSITION new series”, September, Vol. 18, No. 3, pp. 521-540. Available at: <a href="https://doi.org/10.59170/stattrans-2017-027">doi:10.59170/stattrans-2017-027</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data.Normalization">data.Normalization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_symbolic_interval_polish_voivodships)
n&lt;-interval_normalization(data_symbolic_interval_polish_voivodships,dataType="simple",type="n2")
plotInterval(n$simple)
</code></pre>

<hr>
<h2 id='ordinalToMetric'>Reinforcing measurement scale for ordinal data</h2><span id='topic+ordinalToMetric'></span>

<h3>Description</h3>

<p>Reinforcing measurement scale for ordinal data (ordinal to metric scale)</p>


<h3>Usage</h3>

<pre><code class='language-R'>ordinalToMetric(data,scaleType="o",patternCoordinates)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ordinalToMetric_+3A_data">data</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="ordinalToMetric_+3A_scaletype">scaleType</code></td>
<td>
<p>&quot;o&quot; - variables measured on ordinal scale, &quot;m&quot; - variables measured on metric scale, 
&quot;o/m&quot; - vector with mixed variables - e.g. c(&quot;o&quot;,&quot;m&quot;,&quot;m&quot;,&quot;o&quot;,&quot;o&quot;,&quot;m&quot;)</p>
</td></tr>
<tr><td><code id="ordinalToMetric_+3A_patterncoordinates">patternCoordinates</code></td>
<td>
<p>vector containing pattern coordinates c(...) given by the reaseracher for data (for metric variables - NA,
for ordinal variables - one of the categories for each ordinal variable (e.g. maximum category))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/ordinalToMetric_details.pdf">../doc/ordinalToMetric_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pdata</code></td>
<td>
<p>raw (primary) data matrix</p>
</td></tr>
<tr><td><code>tdata</code></td>
<td>
<p>data matrix after transformation of ordinal variables into metric variables</p>
</td></tr>
<tr><td><code>cpattern</code></td>
<td>
<p>vector containing pattern coordinates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, Wroclaw University of Economics, Poland
</p>


<h3>References</h3>

<p>Jajuga, K., Walesiak, M., Bak, A. (2003), <em>On the general distance measure</em>, In: M. Schwaiger, O. Opitz (Eds.), Exploratory data analysis in empirical research, Springer-Verlag, Berlin, Heidelberg, 104-109. Available at: <a href="https://doi.org/10.1007/978-3-642-55721-7_12">doi:10.1007/978-3-642-55721-7_12</a>.
</p>
<p>Walesiak, M. (1993), <em>Statystyczna analiza wielowymiarowa w badaniach marketingowych [Multivariate statistical analysis in marketing research]</em>. Wroclaw University of Economics, Research Papers no. 654.
</p>
<p>Walesiak, M. (1999), <em>Distance Measure for Ordinal Data</em>, &quot;Argumenta Oeconomica&quot;, No. 2 (8), 167-173.
</p>
<p>Walesiak, M. (2011), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>
<p>Walesiak, M. (2014), <em>Wzmacnianie skali pomiaru dla danych porządkowych w statystycznej analizie wielowymiarowej [Reinforcing measurement scale for ordinal data in multivariate statistical analysis]</em>, Taksonomia 22, Prace Naukowe Uniwersytetu Ekonomicznego we Wrocławiu no. 327, 60-68.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_patternGDM2)
res1&lt;-ordinalToMetric(data_patternGDM2,scaleType="o",patternCoordinates=c(5,4,3,1,1,3))
print(res1)

# Example 2
library(clusterSim)
data(data_patternGDM2)
res2&lt;-ordinalToMetric(data_patternGDM2,scaleType="o",patternCoordinates=c(5,4,3,4,2,4))
print(res2)
</code></pre>

<hr>
<h2 id='pattern.GDM1'>An application of GDM1 distance for metric data to compute the distances of objects from the pattern object (upper or lower)</h2><span id='topic+pattern.GDM1'></span>

<h3>Description</h3>

<p>An application of GDM1 distance for metric data to compute the distances of objects from the upper (ideal point co-ordinates) or lower (anti-ideal point co-ordinates) pattern object</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern.GDM1(data, performanceVariable, scaleType="i",
nomOptValues=NULL, weightsType="equal", weights=NULL,
normalization="n0", patternType="upper",
patternCoordinates="dataBounds", patternManual=NULL,
nominalTransfMethod=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pattern.GDM1_+3A_data">data</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_performancevariable">performanceVariable</code></td>
<td>
<p>vector containing three types of performance variables:
</p>
<p><code>s</code> for stimulants where higher value means better performance
</p>
<p><code>d</code> for destimulants where low values indicate better performance 
</p>
<p><code>n</code> for nominants where the best value is implied. Object performance is positively assessed if the measure has implied value</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_scaletype">scaleType</code></td>
<td>
<p>&quot;i&quot; - variables measured on interval scale, &quot;r&quot; - variables measured on ratio scale, &quot;r/i&quot; - vector with mixed variables</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_nomoptvalues">nomOptValues</code></td>
<td>
<p>vector containing optimal values for nominant variables and NA values for stimulants and destimulants. If <code>performanceVariable</code> do not contain nominant variables this <code>nomOptValues</code> may be set to NULL</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_weightstype">weightsType</code></td>
<td>
<p>equal or different1 or different2
</p>
<p>&quot;equal&quot; - equal weights
</p>
<p>&quot;different1&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; 1] and sum of weights equals one
</p>
<p>&quot;different2&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; m] and sum of weights equals m (m - the number of variables)
</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_normalization">normalization</code></td>
<td>
<p>normalization formulas as in <code>data.Normalization</code> function</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_weights">weights</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_patterntype">patternType</code></td>
<td>
<p>&quot;upper&quot; - ideal point co-ordinates consists of the best variables' values
</p>
<p>&quot;lower&quot; - anti-ideal point co-ordinates consists of the worst variables' values
</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_patterncoordinates">patternCoordinates</code></td>
<td>

<p>&quot;dataBounds&quot; - pattern should be calculated as following: &quot;upper&quot; pattern (maximum for stimulants, minimum for destimulants), &quot;lower&quot; pattern (minimum for stimulants, maximum for destimulants)
</p>
<p>&quot;manual&quot; - pattern should be given in <code>patternManual</code> variable</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_patternmanual">patternManual</code></td>
<td>
<p>Pattern co-ordinates contain:
</p>
<p>real numbers 
</p>
<p>&quot;min&quot; - for minimal value of variable
</p>
<p>&quot;max&quot; - for maximal value of variable
</p>
</td></tr>
<tr><td><code id="pattern.GDM1_+3A_nominaltransfmethod">nominalTransfMethod</code></td>
<td>
<p>method of transformation of nominant to stimulant variable:
</p>
<p>&quot;q&quot; - quotient transformation
</p>
<p>&quot;d&quot; - difference transformation
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/patternGDM1_details.pdf">../doc/patternGDM1_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pdata</code></td>
<td>
<p>raw (primary) data matrix</p>
</td></tr>
<tr><td><code>tdata</code></td>
<td>
<p>data matrix after transformation of nominant variables (with pattern in last row)</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data matrix after normalization (with pattern in last row)</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>GDM1 distances from pattern object</p>
</td></tr>
<tr><td><code>sortedDistances</code></td>
<td>
<p>sorted GDM1 distances from pattern object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Jajuga, K., Walesiak, M., Bak, A. (2003), <em>On the general distance measure</em>, In: M. Schwaiger, O. Opitz (Eds.), Exploratory data analysis in empirical research, Springer-Verlag, Berlin, Heidelberg, 104-109. Available at: <a href="https://doi.org/10.1007/978-3-642-55721-7_12">doi:10.1007/978-3-642-55721-7_12</a>.
</p>
<p>Walesiak, M. (1993), <em>Statystyczna analiza wielowymiarowa w badaniach marketingowych [Multivariate statistical analysis in marketing research]</em>. Wroclaw University of Economics, Research Papers no. 654.
</p>
<p>Walesiak, M. (2006), <em>Uogolniona miara odleglosci w statystycznej analizie wielowymiarowej [The Generalized Distance Measure in multivariate statistical analysis]</em>, Wydawnictwo AE, Wroclaw.
</p>
<p>Walesiak, M. (2011), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>
<p>Walesiak, M. (2016), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R. Wydanie 2 poprawione i rozszerzone [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>,<code><a href="#topic+data.Normalization">data.Normalization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_patternGDM1)
res&lt;-pattern.GDM1(data_patternGDM1,
performanceVariable=c("s","s","s","s","s","s","d","d","s","s"),
scaleType="r",nomOptValues=NULL,weightsType&lt;-"equal",weights=NULL,
normalization&lt;-"n4",patternType&lt;-"lower",patternCoordinates&lt;-"manual",
patternManual&lt;-c("min","min","min","min","min","min","max","max","min","min"),
nominalTransfMethod &lt;-NULL)
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(max(gdm_p),min(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)),xaxt="n",
xlab="Order of objects from the best to the worst", 
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)

# Example 2
library(clusterSim)
data(data_patternGDM1)
res&lt;-pattern.GDM1(data_patternGDM1,
performanceVariable=c("s","s","s","s","s","s","d","d","s","s"),
scaleType="r",nomOptValues=NULL,weightsType&lt;-"equal",weights=NULL,
normalization&lt;-"n2",patternType&lt;-"upper",
patternCoordinates&lt;-"dataBounds",patternManual&lt;-NULL,
nominalTransfMethod&lt;-NULL)
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(min(gdm_p),max(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)),xaxt="n",
xlab="Order of objects from the best to the worst", 
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)

# Example 3
library(clusterSim)
data(data_patternGDM1)
res&lt;-pattern.GDM1(data_patternGDM1,
performanceVariable=c("s","s","s","s","s","s","d","d","s","s"),
scaleType="r",nomOptValues=NULL,weightsType&lt;-"different2",
weights=c(1.1,1.15,1.15,1.1,1.1,0.7,0.7,1.2,0.8,1.0),
normalization&lt;-"n6",patternType&lt;-"upper",patternCoordinates&lt;-"manual",
patternManual&lt;-c(100,100,100,100,100,"max","min","min","max","max"),
nominalTransfMethod &lt;-NULL)
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(min(gdm_p),max(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)),xaxt="n",
xlab="Order of objects from the best to the worst", 
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)
</code></pre>

<hr>
<h2 id='pattern.GDM2'>An application of GDM2 distance for ordinal data to compute the distances of objects from the pattern object (upper or lower)</h2><span id='topic+pattern.GDM2'></span>

<h3>Description</h3>

<p>An application of GDM2 distance for ordinal data to compute the distances of objects from the upper (ideal point co-ordinates) or lower (anti-ideal point co-ordinates) pattern object</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern.GDM2(data, performanceVariable, nomOptValues=NULL,
weightsType="equal", weights=NULL, patternType="upper",
patternCoordinates="dataBounds", patternManual=NULL,
nominalTransfMethod=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pattern.GDM2_+3A_data">data</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_performancevariable">performanceVariable</code></td>
<td>
<p>vector containing three types of performance variables:
</p>
<p><code>s</code> for stimulants where higher value means better performance
</p>
<p><code>d</code> for destimulants where low values indicate better performance 
</p>
<p><code>n</code> for nominants where the best value is implied. Object performance is positively assessed if the measure has implied value</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_nomoptvalues">nomOptValues</code></td>
<td>
<p>vector containing optimal values for nominant variables and NA values for stimulants and destimulants. If <code>performanceVariable</code> do not contain nominant variables this <code>nomOptValues</code> may be set to NULL</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_weightstype">weightsType</code></td>
<td>
<p>equal or different1 or different2
</p>
<p>&quot;equal&quot; - equal weights
</p>
<p>&quot;different1&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; 1] and sum of weights equals one
</p>
<p>&quot;different2&quot; - vector of different weights should satisfy conditions: each weight takes value from interval [0; m] and sum of weights equals m (m - the number of variables)
</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_weights">weights</code></td>
<td>
<p>vector of weights</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_patterntype">patternType</code></td>
<td>
<p>&quot;upper&quot; - ideal point co-ordinates consists of the best variables' values
</p>
<p>&quot;lower&quot; - anti-ideal point co-ordinates consists of the worst variables' values
</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_patterncoordinates">patternCoordinates</code></td>
<td>

<p>&quot;dataBounds&quot; - pattern should be calculated as following: &quot;upper&quot; pattern (maximum for stimulants, minimum for destimulants, nominal value for nominants), &quot;lower&quot; pattern (minimum for stimulants, maximum for destimulants)
</p>
<p>&quot;manual&quot; - pattern should be given in <code>patternManual</code> variable</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_patternmanual">patternManual</code></td>
<td>
<p>Pattern co-ordinates contain:
</p>
<p>real numbers 
</p>
<p>&quot;min&quot; - for minimal value of variable
</p>
<p>&quot;max&quot; - for maximal value of variable
</p>
<p>&quot;nom&quot; - for nominal value of variable (for upper pattern only - given in <code>nomOptValues</code> vector)
</p>
</td></tr>
<tr><td><code id="pattern.GDM2_+3A_nominaltransfmethod">nominalTransfMethod</code></td>
<td>
<p>method of transformation of nominant to destimulant variable for patternType=&quot;lower&quot;:
</p>
<p>&quot;database&quot; - for each nominant separately GDM2 distance is calculated between each nominant observation (with repetitions - all variable values are used in calculation) and nominal value. Next the variable observations are replaced by those distances
</p>
<p>&quot;symmetrical&quot; - for each nominant separately GDM2 distance is calculated between each nominant observation (without repetition - each observation is used once) and nominal value. Next the variable observations are replaced by those distances
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/patternGDM2_details.pdf">../doc/patternGDM2_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>pdata</code></td>
<td>
<p>raw (primary) data matrix</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>data matrix after transformation of nominant variables (with pattern in last row)</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p>GDM2 distances from pattern object</p>
</td></tr>
<tr><td><code>sortedDistances</code></td>
<td>
<p>sorted GDM2 distances from pattern object</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>epartment of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Jajuga, K., Walesiak, M., Bak, A. (2003), <em>On the general distance measure</em>, In: M. Schwaiger, O. Opitz (Eds.), Exploratory data analysis in empirical research, Springer-Verlag, Berlin, Heidelberg, 104-109. Available at: <a href="https://doi.org/10.1007/978-3-642-55721-7_12">doi:10.1007/978-3-642-55721-7_12</a>.
</p>
<p>Walesiak, M. (1993), <em>Statystyczna analiza wielowymiarowa w badaniach marketingowych [Multivariate statistical analysis in marketing research]</em>. Wroclaw University of Economics, Research Papers no. 654.
</p>
<p>Walesiak, M. (1999), <em>Distance Measure for Ordinal Data</em>, &quot;Argumenta Oeconomica&quot;, No. 2 (8), 167-173.
</p>
<p>Walesiak, M. (2006), <em>Uogolniona miara odleglosci w statystycznej analizie wielowymiarowej [The Generalized Distance Measure in multivariate statistical analysis]</em>, Wydawnictwo AE, Wroclaw.
</p>
<p>Walesiak, M. (2011), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>
<p>Walesiak, M. (2016), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R. Wydanie 2 poprawione i rozszerzone [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_patternGDM2)
res&lt;-pattern.GDM2(data_patternGDM2,
performanceVariable=c("s","s","s","d","d","n"),
nomOptValues=c(NA,NA,NA,NA,NA,3), weightsType&lt;-"equal", weights=NULL,
patternType="lower", patternCoordinates="manual",
patternManual=c("min","min",0,5,"max","max"),
nominalTransfMethod="symmetrical")
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p),xlim=c(max(gdm_p),min(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)), 
xaxt="n",xlab="Order of objects from the best to the worst",
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)

# Example 2
library(clusterSim)
data(data_patternGDM2)
res&lt;-pattern.GDM2(data_patternGDM2,
performanceVariable=c("s","s","s","d","d","n"),
nomOptValues=c(NA,NA,NA,NA,NA,3), weightsType&lt;-"equal", weights=NULL,
patternType="upper", patternCoordinates="dataBounds",
patternManual=NULL, nominalTransfMethod="database")
print(res)
gdm_p&lt;-res$distances
plot(cbind(gdm_p,gdm_p), xlim=c(min(gdm_p),max(gdm_p)),
ylim=c(min(gdm_p),max(gdm_p)), 
xaxt="n",xlab="Order of objects from the best to the worst",
ylab="GDM distances from pattern object", lwd=1.6)
axis(1, at=gdm_p,labels=names(gdm_p), cex.axis=0.5)
</code></pre>

<hr>
<h2 id='plotCategorial'>Plot categorial data on a scatterplot matrix</h2><span id='topic+plotCategorial'></span>

<h3>Description</h3>

<p>Plot categorial data on a scatterplot matrix (optionally with clusters)</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCategorial(x, pairsofVar=NULL, cl=NULL, clColors=NULL,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotCategorial_+3A_x">x</code></td>
<td>
<p>data matrix (rows correspond to observations and columns correspond to variables)</p>
</td></tr>
<tr><td><code id="plotCategorial_+3A_pairsofvar">pairsofVar</code></td>
<td>
<p>pairs of variables - all variables (<code>pairsofVar=NULL</code>) or selected variables, e.g. <code>pairsofVar=c(1,3,4)</code></p>
</td></tr>
<tr><td><code id="plotCategorial_+3A_cl">cl</code></td>
<td>
<p>cluster membership vector</p>
</td></tr>
<tr><td><code id="plotCategorial_+3A_clcolors">clColors</code></td>
<td>
<p>The colors of clusters. The colors are given arbitrary (<code>clColors=TRUE</code>) or by hand, e.g. <code>clColors=c("red","blue","green")</code>. The number of colors equals the number of clusters</p>
</td></tr>
<tr><td><code id="plotCategorial_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="graphics.html#topic+pairs">pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_ordinal)
plotCategorial(data_ordinal, pairsofVar=c(1,3,4,9), cl=NULL, 
clColors = NULL)

# Example 2
library(clusterSim)
grnd &lt;- cluster.Gen(50,model=5,dataType="o",numCategories=5)
plotCategorial(grnd$data, pairsofVar=NULL, cl=grnd$clusters, 
clColors=TRUE)

# Example 3
library(clusterSim)
grnd&lt;-cluster.Gen(50,model=4,dataType="o",numCategories=7, numNoisyVar=2)
plotCategorial(grnd$data, pairsofVar=NULL, cl=grnd$clusters, 
clColors = c("red","blue","green"))

</code></pre>

<hr>
<h2 id='plotInterval'>Plot symbolic interval-valued data on a scatterplot matrix</h2><span id='topic+plotInterval'></span>

<h3>Description</h3>

<p>Plot symbolic interval-valued data on a scatterplot matrix (optionally with clusters)</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotInterval(x, pairsofsVar=NULL, cl=NULL, clColors=NULL,...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotInterval_+3A_x">x</code></td>
<td>
<p>symbolic interval-valued data</p>
</td></tr>
<tr><td><code id="plotInterval_+3A_pairsofsvar">pairsofsVar</code></td>
<td>
<p>pairs of symbolic interval variables - all variables (<code>pairsofsVar=NULL</code>) or selected variables, e.g. <code>pairsofsVar=c(1,3,4)</code></p>
</td></tr>
<tr><td><code id="plotInterval_+3A_cl">cl</code></td>
<td>
<p>cluster membership vector</p>
</td></tr>
<tr><td><code id="plotInterval_+3A_clcolors">clColors</code></td>
<td>
<p>The colors of clusters. The colors are given arbitrary (<code>clColors=TRUE</code>) or by hand, e.g. <code>clColors=c("red","blue","green")</code>. The number of colors equals the number of clusters</p>
</td></tr>
<tr><td><code id="plotInterval_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotCategorial">plotCategorial</a></code>, <code><a href="grDevices.html#topic+colors">colors</a></code>, <code><a href="graphics.html#topic+pairs">pairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
library(clusterSim)
data(data_symbolic)
plotInterval(data_symbolic, pairsofsVar=c(1,3,4,6), cl=NULL,
clColors=NULL)

# Example 2
library(clusterSim)
grnd &lt;- cluster.Gen(60, model=5, dataType="s", numNoisyVar=1, 
numOutliers=10, rangeOutliers=c(1,5))
grnd$clusters[grnd$clusters==0] &lt;- max(grnd$clusters)+1			
# To colour outliers
plotInterval(grnd$data, pairsofsVar=NULL, cl=grnd$clusters,
clColors=TRUE)

# Example 3
library(clusterSim)
grnd &lt;- cluster.Gen(50, model=4, dataType="s", numNoisyVar=2, 
numOutliers=10, rangeOutliers=c(1,4))
grnd$clusters[grnd$clusters==0] &lt;- max(grnd$clusters)+1			
# To colour outliers
plotInterval(grnd$data, pairsofsVar=NULL, cl=grnd$clusters, 
clColors=c("red","blue","green","yellow"))
</code></pre>

<hr>
<h2 id='replication.Mod'>Modification of replication analysis for cluster validation </h2><span id='topic+replication.Mod'></span>

<h3>Description</h3>

<p>Modification of replication analysis for cluster validation</p>


<h3>Usage</h3>

<pre><code class='language-R'>replication.Mod(x, v="m", u=2, centrotypes="centroids", 
	normalization=NULL, distance=NULL, method="kmeans", 
	S=10, fixedAsample=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replication.Mod_+3A_x">x</code></td>
<td>
<p>data matrix</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_v">v</code></td>
<td>
<p>type of data: metric (&quot;r&quot; - ratio, &quot;i&quot; - interval, &quot;m&quot; - mixed), nonmetric (&quot;o&quot; - ordinal, &quot;n&quot; - multi-state nominal, &quot;b&quot; - binary)</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_u">u</code></td>
<td>
<p>number of clusters given arbitrary</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_centrotypes">centrotypes</code></td>
<td>
<p>&quot;centroids&quot; or &quot;medoids&quot;</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_normalization">normalization</code></td>
<td>
<p>optional, normalization formulas for metric data (normalization by variable):
</p>
<p>for ratio data: &quot;n0&quot; - without normalization, &quot;n6&quot; - (x/sd), &quot;n6a&quot; - (x/mad), &quot;n7&quot; - (x/range), &quot;n8&quot; - (x/max), &quot;n9&quot; - (x/mean),
&quot;n9a&quot; - (x/median), &quot;n10&quot; - (x/sum), &quot;n11&quot; - x/sqrt(SSQ)
</p>
<p>for interval or mixed data: &quot;n0&quot; - without normalization, &quot;n1&quot; - (x-mean)/sd, &quot;n2&quot; - (x-median)/mad, &quot;n3&quot; - (x-mean)/range, &quot;n3a&quot; - positional unitization (x-median)/range,
&quot;n4&quot; - (x-min)/range, &quot;n5&quot; - (x-mean)/max[abs(x-mean)], &quot;n5a&quot; - (x-median)/max[abs(x-median)], &quot;n12&quot; - normalization (x - mean)/(sum(x - mean)^2)^0.5,
&quot;n12a&quot; - positional normalization (x - median)/(sum(x - median)^2)^0.5, &quot;n13&quot; - normalization with zero being the central point ((x-midrange)/(range/2))
</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_distance">distance</code></td>
<td>
<p>distance measures
</p>
<p>NULL for &quot;kmeans&quot; method (based on data matrix),
</p>
<p>for ratio data: &quot;d1&quot; - Manhattan, &quot;d2&quot; - Euclidean, &quot;d3&quot; - Chebychev (max), &quot;d4&quot; - squared Euclidean, &quot;d5&quot; - GDM1, &quot;d6&quot; - Canberra, &quot;d7&quot; - Bray-Curtis
</p>
<p>for interval or mixed (ratio &amp; interval) data: &quot;d1&quot;, &quot;d2&quot;, &quot;d3&quot;, &quot;d4&quot;, &quot;d5&quot;
</p>
<p>for ordinal data: &quot;d8&quot; - GDM2
</p>
<p>for multi-state nominal: &quot;d9&quot; - Sokal &amp; Michener
</p>
<p>for binary data: &quot;b1&quot; = Jaccard; &quot;b2&quot; = Sokal &amp; Michener; &quot;b3&quot; = Sokal &amp; Sneath (1); &quot;b4&quot; = Rogers &amp; Tanimoto; &quot;b5&quot; = Czekanowski; &quot;b6&quot; = Gower &amp; Legendre (1); &quot;b7&quot; = Ochiai; &quot;b8&quot; = Sokal &amp; Sneath (2); &quot;b9&quot; = Phi of Pearson; &quot;b10&quot; = Gower &amp; Legendre (2)
</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_method">method</code></td>
<td>
<p>clustering method: &quot;kmeans&quot; (default), &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;, &quot;mcquitty&quot;, &quot;median&quot;, &quot;centroid&quot;, &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;pam&quot;, &quot;diana&quot;</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_s">S</code></td>
<td>
<p>the number of simulations used to compute mean corrected Rand index</p>
</td></tr>
<tr><td><code id="replication.Mod_+3A_fixedasample">fixedAsample</code></td>
<td>
<p>if NULL <em>A</em> sample is generated randomly, otherwise this parameter contains object numbers arbitrarily assigned to <em>A</em> sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/replication.Mod_details.pdf">../doc/replication.Mod_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>A</code></td>
<td>
<p>3-dimensional array containing data matrices for A sample of objects in each simulation (first dimension represents simulation number, second - object number, third - variable number)</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>3-dimensional array containing data matrices for B sample of objects in each simulation (first dimension represents simulation number, second - object number, third - variable number)</p>
</td></tr>
<tr><td><code>centroid</code></td>
<td>
<p>3-dimensional array containing centroids of u clusters for A sample of objects in each simulation (first dimension represents simulation number, second - cluster number, third - variable number)</p>
</td></tr>
<tr><td><code>medoid</code></td>
<td>
<p>3-dimensional array containing matrices of observations on u representative objects (medoids) for A sample of objects in each simulation (first dimension represents simulation number, second - cluster number, third - variable number)</p>
</td></tr>
<tr><td><code>clusteringA</code></td>
<td>
<p>2-dimensional array containing cluster numbers for A sample of objects in each simulation (first dimension represents simulation number, second - object number)</p>
</td></tr>
<tr><td><code>clusteringB</code></td>
<td>
<p>2-dimensional array containing cluster numbers for B sample of objects in each simulation (first dimension represents simulation number, second - object number)</p>
</td></tr>
<tr><td><code>clusteringBB</code></td>
<td>
<p>2-dimensional array containing cluster numbers for B sample of objects in each simulation according to 4 step of replication analysis procedure (first dimension represents simulation number, second - object number)</p>
</td></tr>
<tr><td><code>cRand</code></td>
<td>
<p>value of mean corrected Rand index for S simulations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>References</h3>

<p>Breckenridge, J.N. (2000), <em>Validating cluster analysis: consistent replication and symmetry</em>, &quot;Multivariate Behavioral Research&quot;, 35 (2), 261-285. Available at: <a href="https://doi.org/10.1207/S15327906MBR3502_5">doi:10.1207/S15327906MBR3502_5</a>.
</p>
<p>Gordon, A.D. (1999), <em>Classification</em>, Chapman and Hall/CRC, London. ISBN 9781584880134.
</p>
<p>Hubert, L., Arabie, P. (1985), <em>Comparing partitions</em>, &quot;Journal of Classification&quot;, no. 1, 193-218. Available at: <a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.
</p>
<p>Milligan, G.W. (1996), <em>Clustering validation: results and implications for applied analyses</em>, In P. Arabie, L.J. Hubert, G. de Soete (Eds.), <em>Clustering and classification</em>, World Scientific, Singapore, 341-375. ISBN 9789810212872.
</p>
<p>Walesiak, M. (2008), <em>Ocena stabilnosci wynikow klasyfikacji z wykorzystaniem analizy replikacji</em>, In: J. Pociecha (Ed.), <em>Modelowanie i prognozowanie zjawisk spoleczno-gospodarczych</em>, Wydawnictwo AE, Krakow, 67-72.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cluster.Sim">cluster.Sim</a></code>, <code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>,  <code><a href="stats.html#topic+dist">dist</a></code>,
<code><a href="#topic+dist.BC">dist.BC</a></code>, <code><a href="#topic+dist.SM">dist.SM</a></code>, <code><a href="#topic+dist.GDM">dist.GDM</a></code>, 
</p>
<p><code><a href="#topic+data.Normalization">data.Normalization</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
data(data_ratio)
w &lt;- replication.Mod(data_ratio, u=5, S=10)
print(w)

library(clusterSim)
data(data_binary)
replication.Mod(data_binary,"b", u=2, "medoids", NULL,"b1", "pam", fixedAsample=c(1,3,6,7))
</code></pre>

<hr>
<h2 id='shapes.blocks3d'>Generation of data set containing two clusters with untypical shapes (cube divided into two parts by main diagonal plane)</h2><span id='topic+shapes.blocks3d'></span>

<h3>Description</h3>

<p>Generation of data set containing two clusters with untypical shapes (cube starting at point (0,0,0) divided into two parts by main diagonal plane)</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes.blocks3d(numObjects=180,shapesUnitSize=0.5, shape2coordinateX=1.2,
shape2coordinateY=1.2,shape2coordinateZ=1.2, outputCsv="", outputCsv2="", 
outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes.blocks3d_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with length=2</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_shapesunitsize">shapesUnitSize</code></td>
<td>
<p>length of one unit for shape (maximal heigth, width and depth of shape is 2*shapesUnitSize)</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_shape2coordinatex">shape2coordinateX</code></td>
<td>
<p>maximal value for second shape in first (<code>X</code>) dimension</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_shape2coordinatey">shape2coordinateY</code></td>
<td>
<p>maximal value for second shape in second (<code>Y</code>) dimension</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_shape2coordinatez">shape2coordinateZ</code></td>
<td>
<p>maximal value for second shape in third (<code>Z</code>) dimension</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="shapes.blocks3d_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data - matrix with objects in rows and variables in columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes.worms">shapes.worms</a></code>,<code><a href="#topic+shapes.circles2">shapes.circles2</a></code>,<code><a href="#topic+shapes.circles3">shapes.circles3</a></code>,<code><a href="#topic+shapes.bulls.eye">shapes.bulls.eye</a></code>,<code><a href="#topic+shapes.two.moon">shapes.two.moon</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
#library(rgl)
sb3d&lt;-shapes.blocks3d(300,1,3,3,3)
#plot3d(sb3d$data,col=rainbow(2)[sb3d$clusters])
</code></pre>

<hr>
<h2 id='shapes.circles2'>Generation of data set containing two clusters with untypical ring shapes (circles)</h2><span id='topic+shapes.circles2'></span><span id='topic+shapes.bulls.eye'></span>

<h3>Description</h3>

<p>Generation of data set containing two clusters with untypical ring shapes. For each point first random radius <code>r</code> from given interval is generated then random angle <code>alpha</code> and finally the coordinates of point are calculated as (<code>r*cos(alpha)</code>,<code>r*sin(alpha)</code>). For bull's eye data set second shape is filled circle (<code>r</code> starts from 0)</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes.circles2(numObjects=180, shape1rFrom=0.75,shape1rTo=0.9,shape2rFrom=0.35,
shape2rTo=0.5,outputCsv="", outputCsv2="", outputColNames=TRUE,  outputRowNames=TRUE)
shapes.bulls.eye(numObjects=180, shape1rFrom=0.75,shape1rTo=0.95,shape2rTo=0.45,
outputCsv="", outputCsv2="", outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes.circles2_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with length=2</p>
</td></tr></table>
<p>,
</p>
<table role = "presentation">
<tr><td><code id="shapes.circles2_+3A_shape1rfrom">shape1rFrom</code></td>
<td>
<p>minimal value of radius for first ring</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_shape1rto">shape1rTo</code></td>
<td>
<p>maximal value of radius for first ring</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_shape2rfrom">shape2rFrom</code></td>
<td>
<p>minimal value of radius for second ring</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_shape2rto">shape2rTo</code></td>
<td>
<p>maximal value of radius for second ring</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="shapes.circles2_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data - matrix with objects in rows and variables in columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes.worms">shapes.worms</a></code>,<code><a href="#topic+shapes.circles3">shapes.circles3</a></code>,<code><a href="#topic+shapes.bulls.eye">shapes.bulls.eye</a></code>,<code><a href="#topic+shapes.two.moon">shapes.two.moon</a></code>,<code><a href="#topic+shapes.blocks3d">shapes.blocks3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example1
library(clusterSim)
sc2&lt;-shapes.circles2(180)
plot(sc2$data,col=rainbow(2)[sc2$clusters])

#Example2
library(clusterSim)
sbe&lt;-shapes.bulls.eye(numObjects=c(120,60))
plot(sbe$data,col=rainbow(2)[sbe$clusters])
</code></pre>

<hr>
<h2 id='shapes.circles3'>Generation of data set containing three clusters with untypical ring shapes (circles)</h2><span id='topic+shapes.circles3'></span>

<h3>Description</h3>

<p>Generation of data set containing three clusters with untypical ring shapes. For each point first random radius <code>r</code> from given interval is generated then random angle <code>alpha</code> and finally the coordinates of point are calculated as (<code>r*cos(alpha)</code>,<code>r*sin(alpha)</code>)</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes.circles3(numObjects=180,shape1rFrom=0.15,shape1rTo=0.3,
shape2rFrom=0.55,shape2rTo=0.7,shape3rFrom=1.15,shape3rTo=1.3,
outputCsv="", outputCsv2="", outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes.circles3_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with length=3</p>
</td></tr></table>
<p>,
</p>
<table role = "presentation">
<tr><td><code id="shapes.circles3_+3A_shape1rfrom">shape1rFrom</code></td>
<td>
<p>minimal value of radius for first ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_shape1rto">shape1rTo</code></td>
<td>
<p>maximal value of radius for first ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_shape2rfrom">shape2rFrom</code></td>
<td>
<p>minimal value of radius for second ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_shape2rto">shape2rTo</code></td>
<td>
<p>maximal value of radius for second ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_shape3rfrom">shape3rFrom</code></td>
<td>
<p>minimal value of radius for third ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_shape3rto">shape3rTo</code></td>
<td>
<p>maximal value of radius for third ring</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="shapes.circles3_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data - matrix with objects in rows and variables in columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes.worms">shapes.worms</a></code>,<code><a href="#topic+shapes.circles2">shapes.circles2</a></code>,<code><a href="#topic+shapes.bulls.eye">shapes.bulls.eye</a></code>,<code><a href="#topic+shapes.two.moon">shapes.two.moon</a></code>,<code><a href="#topic+shapes.blocks3d">shapes.blocks3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Example1
library(clusterSim)
sc3a&lt;-shapes.circles3(180)
plot(sc3a$data,col=rainbow(3)[sc3a$clusters])

#Example2
library(clusterSim)
sc3b&lt;-shapes.circles3(numObjects=c(120,180,240))
plot(sc3b$data,col=rainbow(3)[sc3b$clusters])
</code></pre>

<hr>
<h2 id='shapes.two.moon'>Generation of data set containing two clusters with untypical shapes (similar to waxing and waning crescent moon)</h2><span id='topic+shapes.two.moon'></span>

<h3>Description</h3>

<p>Generation of data set containing two clusters with untypical shapes (similar to waxing and waning crescent moon). For each point first random radius <code>r</code> from given interval is generated then random angle <code>alpha</code> and finally the coordinates of point are calculated as (<code>a+abs(r*cos(alpha))</code>,<code>r*sin(alpha)</code> for first shape and (<code>-abs(r*cos(alpha))</code>,<code>r*sin(alpha)-b</code> for second shape</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes.two.moon(numObjects=180,shape1a=-0.4,shape2b=1,shape1rFrom=0.8,
shape1rTo=1.2,shape2rFrom=0.8, shape2rTo=1.2, outputCsv="", outputCsv2="", 
outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes.two.moon_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with length=2</p>
</td></tr></table>
<p>,
</p>
<table role = "presentation">
<tr><td><code id="shapes.two.moon_+3A_shape1a">shape1a</code></td>
<td>
<p>parameter <code>a</code> for first shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_shape2b">shape2b</code></td>
<td>
<p>parameter <code>b</code> for first shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_shape1rfrom">shape1rFrom</code></td>
<td>
<p>minimal value of radius for first shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_shape1rto">shape1rTo</code></td>
<td>
<p>maximal value of radius for first shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_shape2rfrom">shape2rFrom</code></td>
<td>
<p>minimal value of radius for second shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_shape2rto">shape2rTo</code></td>
<td>
<p>maximal value of radius for second shape</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="shapes.two.moon_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data - matrix with objects in rows and variables in columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes.worms">shapes.worms</a></code>,<code><a href="#topic+shapes.circles2">shapes.circles2</a></code>,<code><a href="#topic+shapes.circles3">shapes.circles3</a></code>,<code><a href="#topic+shapes.bulls.eye">shapes.bulls.eye</a></code>,<code><a href="#topic+shapes.blocks3d">shapes.blocks3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
stm&lt;-shapes.two.moon(180)
plot(stm$data,col=rainbow(2)[stm$clusters])
</code></pre>

<hr>
<h2 id='shapes.worms'>Generation of data set containing two clusters with untypical parabolic shapes (worms)</h2><span id='topic+shapes.worms'></span>

<h3>Description</h3>

<p>Generation of data set containing two clusters with untypical parabolic shapes (first is given by y=x^2, second by y=-(x-a)^2+b with distortion from &lt;-tol,+tol&gt;)</p>


<h3>Usage</h3>

<pre><code class='language-R'>shapes.worms(numObjects=180,shape1x1=-2,shape1x2=2,shape2x1=-0.5,
shape2x2=2.5,shape2a=1.5,shape2b=5.5,tol=0.1,outputCsv="", outputCsv2="", 
outputColNames=TRUE, outputRowNames=TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapes.worms_+3A_numobjects">numObjects</code></td>
<td>
<p>number of objects in each cluster - positive integer value or vector with length=2</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape1x1">shape1x1</code></td>
<td>
<p>starting value on abscissa axis for shape 1</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape1x2">shape1x2</code></td>
<td>
<p>end value on abscissa axis for shape 1</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape2x1">shape2x1</code></td>
<td>
<p>starting value on abscissa axis for shape 2</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape2x2">shape2x2</code></td>
<td>
<p>end value on abscissa axis for shape 2</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape2a">shape2a</code></td>
<td>
<p>parameter <code>a</code> of shape 2</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_shape2b">shape2b</code></td>
<td>
<p>parameter <code>b</code> of shape 2</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_tol">tol</code></td>
<td>
<p>tolerance - each generated point is randomized by adding runif(1,0,tol)</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_outputcsv">outputCsv</code></td>
<td>
<p>optional, name of csv file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_outputcsv2">outputCsv2</code></td>
<td>
<p>optional, name of csv (a comma as decimal point and a semicolon as field separator) file with generated data (first column contains id, second - number of cluster and others - data)</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_outputcolnames">outputColNames</code></td>
<td>
<p><code>outputColNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains first row with column names</p>
</td></tr>
<tr><td><code id="shapes.worms_+3A_outputrownames">outputRowNames</code></td>
<td>
<p><code>outputRowNames=TRUE</code> indicates that output file (given by <code>outputCsv</code> and <code>outputCsv2</code> parameters) contains a vector of row names</p>
</td></tr></table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusters</code></td>
<td>
<p>cluster number for each object</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>generated data - matrix with objects in rows and variables in columns</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, University of Economics, Wroclaw, Poland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+shapes.worms">shapes.worms</a></code>,<code><a href="#topic+shapes.circles2">shapes.circles2</a></code>,<code><a href="#topic+shapes.circles3">shapes.circles3</a></code>,<code><a href="#topic+shapes.bulls.eye">shapes.bulls.eye</a></code>,<code><a href="#topic+shapes.two.moon">shapes.two.moon</a></code>,<code><a href="#topic+shapes.blocks3d">shapes.blocks3d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(clusterSim)
sw&lt;-shapes.worms(180)
plot(sw$data,col=rainbow(2)[sw$clusters])
</code></pre>

<hr>
<h2 id='speccl'>A spectral clustering algorithm</h2><span id='topic+speccl'></span>

<h3>Description</h3>

<p>A spectral clustering algorithm. Cluster analysis is performed by embedding the data into the subspace of the eigenvectors of an affinity matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>speccl(data,nc,distance="GDM1",sigma="automatic",sigma.interval="default",
mod.sample=0.75,R=10,iterations=3,na.action=na.omit,...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="speccl_+3A_data">data</code></td>
<td>
<p>matrix or dataset</p>
</td></tr>
<tr><td><code id="speccl_+3A_nc">nc</code></td>
<td>
<p>the number of clusters</p>
</td></tr>
<tr><td><code id="speccl_+3A_distance">distance</code></td>
<td>
<p>distance function used to calculate affinity matrix: &quot;sEuclidean&quot; - squared Euclidean distance, &quot;euclidean&quot; - Euclidean distance, &quot;manhattan&quot; - city block distance,
&quot;maximum&quot; - Chebyshev distance, &quot;canberra&quot; - Lance and Williams Canberra distance, &quot;BC&quot; - Bray-Curtis distance measure for ratio data, &quot;GDM1&quot; - GDM distance for metric data,
&quot;GDM2&quot; - GDM distance for ordinal data, &quot;SM&quot; - Sokal-Michener distance measure for nominal variables</p>
</td></tr>
<tr><td><code id="speccl_+3A_sigma">sigma</code></td>
<td>
<p>scale parameter used to calculate affinity matrix: sigma=&quot;automatic&quot; - an algorithm for searching optimal value of sigma parameter; sigma=200 - value of sigma parameter given
by researcher, e.g. 200</p>
</td></tr>
<tr><td><code id="speccl_+3A_sigma.interval">sigma.interval</code></td>
<td>
<p>sigma.interval=&quot;default&quot; - from zero to square root of sum of all distances in lower triangle of distance matrix for &quot;sEuclidean&quot; and from zero to sum of all distances
in lower triangle of distance matrix for other distances; sigma.interval=1000 - from zero to value given by researcher, e.g. 1000</p>
</td></tr> 
<tr><td><code id="speccl_+3A_mod.sample">mod.sample</code></td>
<td>
<p>proportion of data to use when estimating sigma (default: 0.75)</p>
</td></tr>
<tr><td><code id="speccl_+3A_r">R</code></td>
<td>
<p>the number of intervals examined in each step of searching optimal value of sigma parameter algorithm 
</p>
<p>(See <a href="../doc/speccl_details.pdf">../doc/speccl_details.pdf</a>)</p>
</td></tr>
<tr><td><code id="speccl_+3A_iterations">iterations</code></td>
<td>
<p>the maximum number of iterations (rounds) allowed in algorithm of searching optimal value of sigma parameter</p>
</td></tr>
<tr><td><code id="speccl_+3A_na.action">na.action</code></td>
<td>
<p>the action to perform on NA</p>
</td></tr>
<tr><td><code id="speccl_+3A_...">...</code></td>
<td>
<p>arguments passed to kmeans procedure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See file <a href="../doc/speccl_details.pdf">../doc/speccl_details.pdf</a> for further details
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>scdist</code></td>
<td>
<p>returns the lower triangle of the distance matrix</p>
</td></tr> 
<tr><td><code>clusters</code></td>
<td>
<p>a vector of integers indicating the cluster to which each object is allocated</p>
</td></tr> 
<tr><td><code>size</code></td>
<td>
<p>the number of objects in each cluster</p>
</td></tr>
<tr><td><code>withinss</code></td>
<td>
<p>the within-cluster sum of squared distances for each cluster</p>
</td></tr>
<tr><td><code>Ematrix</code></td>
<td>
<p>data matrix n x u (n - the number of objects, u - the number of eigenvectors)</p>
</td></tr>
<tr><td><code>Ymatrix</code></td>
<td>
<p>normalized data matrix n x u (n - the number of objects, u - the number of eigenvectors)</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>the value of scale parameter given by searching algorithm</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marek Walesiak <a href="mailto:marek.walesiak@ue.wroc.pl">marek.walesiak@ue.wroc.pl</a>, Andrzej Dudek <a href="mailto:andrzej.dudek@ue.wroc.pl">andrzej.dudek@ue.wroc.pl</a> 
</p>
<p>Department of Econometrics and Computer Science, Wroclaw University of Economics, Poland
</p>


<h3>References</h3>

<p>Karatzoglou, A. (2006), <em>Kernel methods. Software, algorithms and applications</em>, Dissertation, Wien, Technical University.
</p>
<p>Ng, A., Jordan, M., Weiss, Y. (2002), <em>On spectral clustering: analysis and an algorithm</em>, In: T. Dietterich, S. Becker, Z. Ghahramani (Eds.), Advances in Neural Information Processing Systems 14. MIT Press, 849-856. Available at:
</p>
<p><a href="https://papers.nips.cc/paper/2092-on-spectral-clustering-analysis-and-an-algorithm.pdf">https://papers.nips.cc/paper/2092-on-spectral-clustering-analysis-and-an-algorithm.pdf</a>.
</p>
<p>Walesiak, M. (2011), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>
<p>Walesiak, M. (2012), <em>Klasyfikacja spektralna a skale pomiaru zmiennych [Spectral clustering and measurement scales of variables]</em>, Przeglad Statystyczny (Statistical Review), no. 1, 13-31. Spectral Clustering and Measurement Scales of Variables
Marek Walesiak Przegląd Statystyczny. Statistical Review, vol. 59, 2012, 1, pages: 13-31. Available at: <a href="https://doi.org/10.59139/ps.2012.01.2">doi:10.59139/ps.2012.01.2</a>.
</p>
<p>Walesiak, M. (2016), <em>Uogólniona miara odległości GDM w statystycznej analizie wielowymiarowej z wykorzystaniem programu R. Wydanie 2 poprawione i rozszerzone [The Generalized Distance Measure GDM in multivariate statistical analysis with R]</em>, Wydawnictwo Uniwersytetu Ekonomicznego, Wroclaw.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dist.GDM">dist.GDM</a></code>,<code><a href="stats.html#topic+kmeans">kmeans</a></code>,<code><a href="stats.html#topic+dist">dist</a></code>,<code><a href="ade4.html#topic+dist.binary">dist.binary</a></code>,<code><a href="#topic+dist.SM">dist.SM</a></code>,<code><a href="#topic+dist.BC">dist.BC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Commented due to long execution time
# Example 1
#library(clusterSim)
#library(mlbench)
#data&lt;-mlbench.spirals(100,1,0.03)
#plot(data)
#x&lt;-data$x
#res1&lt;-speccl(x,nc=2,distance="GDM1",sigma="automatic",
#sigma.interval="default",mod.sample=0.75,R=10,iterations=3)
#clas1&lt;-res1$cluster
#print(data$classes)
#print(clas1)
#cRand&lt;-classAgreement(table(as.numeric(as.vector(data$classes)),
#res1$clusters))$crand
#print(res1$sigma)
#print(cRand)

# Example 2
#library(clusterSim)
#grnd2&lt;-cluster.Gen(50,model=4,dataType="m",numNoisyVar=1)
#data&lt;-as.matrix(grnd2$data)
#colornames&lt;-c("red","blue","green")
#grnd2$clusters[grnd2$clusters==0]&lt;-length(colornames)
#plot(grnd2$data,col=colornames[grnd2$clusters])
#us&lt;-nrow(data)*nrow(data)/2
#res2&lt;-speccl(data,nc=3,distance="sEuclidean",sigma="automatic",
#sigma.interval=us,mod.sample=0.75,R=10,iterations=3)
#cRand&lt;-comparing.Partitions(grnd2$clusters,res2$clusters,type="crand")
#print(res2$sigma)
#print(cRand)

# Example 3
#library(clusterSim)
#grnd3&lt;-cluster.Gen(40,model=4,dataType="o",numCategories=7)
#data&lt;-as.matrix(grnd3$data)
#plotCategorial(grnd3$data,pairsofVar=NULL,cl=grnd3$clusters,
#clColors=c("red","blue","green"))
#res3&lt;-speccl(data,nc=3,distance="GDM2",sigma="automatic",
#sigma.interval="default",mod.sample=0.75,R=10,iterations=3)
#cRand&lt;-comparing.Partitions(grnd3$clusters,res3$clusters,type="crand")
#print(res3$sigma)
#print(cRand)

# Example 4
library(clusterSim)
data(data_nominal)
res4&lt;-speccl(data_nominal,nc=4,distance="SM",sigma="automatic",
sigma.interval="default",mod.sample=0.75,R=10,iterations=3)
print(res4)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
