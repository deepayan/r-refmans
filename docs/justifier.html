<!DOCTYPE html><html lang="en"><head><title>Help for package justifier</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {justifier}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_graph_theme'><p>Apply multiple DiagrammeR global graph attributes</p></a></li>
<li><a href='#base30toNumeric'><p>Conversion between base10 and base30 &amp; base36</p></a></li>
<li><a href='#c.justifierElement'><p>Programmatically constructing justifier elements</p></a></li>
<li><a href='#c.justifierStructuredObject'><p>Concatenate two or more structured justifier objects</p></a></li>
<li><a href='#cat0'><p>Concatenate to screen without spaces</p></a></li>
<li><a href='#clean_workspace'><p>Clean your workspace</p></a></li>
<li><a href='#export_justification'><p>Export justification as YAML</p></a></li>
<li><a href='#export_to_json'><p>Export a justifier specification to JSON</p></a></li>
<li><a href='#flatten'><p>Flatten a justifier tree</p></a></li>
<li><a href='#generate_id'><p>Generate unique identifier(s)</p></a></li>
<li><a href='#get_workspace'><p>Get your justifier workspace identifier</p></a></li>
<li><a href='#get_workspace_id'><p>Get your justifier workspace identifier</p></a></li>
<li><a href='#idRef'><p>Create a reference to one or more justifier objects</p></a></li>
<li><a href='#ifelseObj'><p>Conditional returning of an object</p></a></li>
<li><a href='#import_from_json'><p>Import a structured justifier object from JSON</p></a></li>
<li><a href='#load_justifications'><p>Load Justifications from a file or multiple files</p></a></li>
<li><a href='#log_decision'><p>Document a decision</p></a></li>
<li><a href='#merge_specLists'><p>Merging to justifier specification lists</p></a></li>
<li><a href='#opts'><p>Options for the justifier package</p></a></li>
<li><a href='#parse_justifications'><p>Parsing justifications</p></a></li>
<li><a href='#randomSlug'><p>Generate a random slug</p></a></li>
<li><a href='#repeatStr'><p>Repeat a string a number of times</p></a></li>
<li><a href='#sanitize_for_DiagrammeR'><p>Sanitize for DiagrammeR</p></a></li>
<li><a href='#save_workspace'><p>Save your workspace</p></a></li>
<li><a href='#set_workspace_id'><p>Set your justifier workspace identifier</p></a></li>
<li><a href='#to_specList'><p>Producing a list of specifications</p></a></li>
<li><a href='#vecTxt'><p>Easily parse a vector into a character value</p></a></li>
<li><a href='#workspace'><p>Show your workspace contents</p></a></li>
<li><a href='#wrapVector'><p>Wrap all elements in a vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Human and Machine-Readable Justifications and Justified
Decisions Based on 'YAML'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gjalt-Jorn Peters &lt;justifier@opens.science&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Leverages the 'yum' package to
             implement a 'YAML' ('YAML Ain't Markup Language', a human
             friendly standard for data serialization; see &lt;https:yaml.org&gt;)
             standard for documenting justifications, such as for decisions
             taken during the planning, execution and analysis of a study
             or during the development of a behavior change intervention
             as illustrated by Marques &amp; Peters (2019)
             &lt;<a href="https://doi.org/10.17605%2Fosf.io%2Fndxha">doi:10.17605/osf.io/ndxha</a>&gt;. These justifications are both
             human- and machine-readable, facilitating efficient extraction
             and organisation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://r-packages.gitlab.io/justifier">https://r-packages.gitlab.io/justifier</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://gitlab.com/r-packages/justifier/-/issues">https://gitlab.com/r-packages/justifier/-/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>data.tree (&ge; 0.7.8), DiagrammeR (&ge; 1.0.0), DiagrammeRsvg (&ge;
0.1), purrr (&ge; 0.3.0), yaml (&ge; 2.2.0), yum (&ge; 0.0.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, here, jsonlite (&ge; 1.7), knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-05 10:00:12 UTC; gjalt</td>
</tr>
<tr>
<td>Author:</td>
<td>Gjalt-Jorn Peters <a href="https://orcid.org/0000-0002-0336-9589"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Szilvia Zorgo <a href="https://orcid.org/0000-0002-6916-2097"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-05 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_graph_theme'>Apply multiple DiagrammeR global graph attributes</h2><span id='topic+apply_graph_theme'></span>

<h3>Description</h3>

<p>Apply multiple DiagrammeR global graph attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_graph_theme(graph, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_graph_theme_+3A_graph">graph</code></td>
<td>
<p>The <a href="DiagrammeR.html#topic+DiagrammeR">DiagrammeR::DiagrammeR</a> graph to apply the attributes to.</p>
</td></tr>
<tr><td><code id="apply_graph_theme_+3A_...">...</code></td>
<td>
<p>One or more character vectors of length three, where the first element is
the attribute, the second the value, and the third, the attribute type (<code>graph</code>,
<code>node</code>, or <code>edge</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <a href="DiagrammeR.html#topic+DiagrammeR">DiagrammeR::DiagrammeR</a> graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleJustifier &lt;- '
---
assertion:
  -
    id: assertion_id
    label: "An assertion"
decision:
  -
    id: decision_id
    label: "A decision"
    justification:
      -
        id: justification_id
        label: "A justification"
        assertion:
          -
            id: assertion_id
            description: "A description of an assertion"
            source:
              -
                id: source1_id
                label: "First source"
              -
                id: source2_id
                label: "second source"
---
';
justifications &lt;-
  justifier::load_justifications(text=exampleJustifier);
miniGraph_original &lt;-
  justifications$decisionGraphs[[1]];
miniGraph &lt;-
  justifier::apply_graph_theme(
  miniGraph_original,
  c("color", "#0000AA", "node"),
  c("shape", "triangle", "node"),
  c("fontcolor", "#FF0000", "node")
);
### This line shouldn't be run when executing this example as test,
### because rendering a DiagrammeR graph takes quite long
## Not run: 
DiagrammeR::render_graph(miniGraph);

## End(Not run)
</code></pre>

<hr>
<h2 id='base30toNumeric'>Conversion between base10 and base30 &amp; base36</h2><span id='topic+base30toNumeric'></span><span id='topic+base30and36conversion'></span><span id='topic+numericToBase30'></span>

<h3>Description</h3>

<p>The conversion functions from base10 to base30 are
used by the <code><a href="#topic+generate_id">generate_id()</a></code> functions; the base36
functions are just left here for convenience.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base30toNumeric(x)

numericToBase30(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base30toNumeric_+3A_x">x</code></td>
<td>
<p>The vector to convert (numeric for the <code>numericTo</code> functions,
character for the <code>base30to</code> and <code>base36to</code> funtions).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symbols to represent the 'base 30' system are the 0-9
followed by the alphabet without vowels but including the y. This
vector is available as <code>base30</code>.
</p>


<h3>Value</h3>

<p>The converted vector (numeric for the <code>base30to</code> and <code>base36to</code> funtions,
character for the <code>numericTo</code> functions).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>numericToBase30(654321);
base30toNumeric(numericToBase30(654321));
</code></pre>

<hr>
<h2 id='c.justifierElement'>Programmatically constructing justifier elements</h2><span id='topic+c.justifierElement'></span><span id='topic+c.justifierStructured'></span><span id='topic+source'></span><span id='topic+dcsn'></span><span id='topic+jstf'></span><span id='topic+asrt'></span><span id='topic+srce'></span><span id='topic+decide'></span><span id='topic+decision'></span><span id='topic+assert'></span><span id='topic+justify'></span>

<h3>Description</h3>

<p>These functions can be used to programmatically construct justifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'justifierElement'
c(...)

## S3 method for class 'justifierStructured'
c(...)

source(label, description = NULL, type = NULL, id = NULL, xdoi = NULL, ...)

assert(label, description = "", type = NULL, id = NULL, source = NULL, ...)

justify(label, description = "", type = NULL, id = NULL, assertion = NULL, ...)

decide(
  label,
  description = NULL,
  type = NULL,
  id = NULL,
  alternatives = NULL,
  justification = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.justifierElement_+3A_...">...</code></td>
<td>
<p>Additional fields and values to store in the element.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_label">label</code></td>
<td>
<p>A human-readable label for the <code>decision</code>, <code>justification</code>,
<code>assertion</code>, or <code>source</code>. Labels are brief summaries of the core of the
decision, justification, assertion, or source. More details, background
information, context, and other comments can be placed in the description.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_description">description</code></td>
<td>
<p>A human-readable description. This can be used to
elaborate on the label. Note that the label should be reader-friendly and
self-contained; but because they also have to be as short as possible,
descriptions can be used to provide definitions, context, background
information, or add any other metadata or comments.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_type">type</code></td>
<td>
<p>Types are used when working with a framework. Frameworks define
type identifiers, consisting of letters, digits, and underscores. By
specifying these identifiers the type of a decision, justification,
assertion, or source. Source types can be, for example, types of documents
or other data providers, such as &quot;empirical evidence', 'expert consensus',
'personal opinion', or 'that one meeting that we had in May'. Assertion
types can be, for example, data types or types of facts, such as 'number',
'prevalence', 'causal relationship', or 'contact information'.
Justification types can be, for example, types of reasoning or logical
expressions, such as 'deduction', 'induction', or 'intersection'. Decision
types are the most framework-specific, heavily depend on the specific
context of the decision, and are used by frameworks to organise the
decisions in a project. Examples of decision types are the decision to
recruit a certain number of participants in a scientific study; the decision
to target a certain belief in a behavior change intervention; the decision
to merge two codes in a qualitative study; the decision to hire a staff
member; or the decision to make a certain purchase.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_id">id</code></td>
<td>
<p>The identifier (randomly generated if omitted).</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_xdoi">xdoi</code></td>
<td>
<p>For <code>source</code>s, XDOI identifier (a DOI, or, if that does not
exist, ISBN or other unique identifier of the source).</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_source">source</code></td>
<td>
<p>In assertions, the source (or sources) that the assertion
is based on can be specified using <code>srce()</code>.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_assertion">assertion</code></td>
<td>
<p>In justifications, the assertion (or assertions) that
the justification is based on can be specified using <code>asrt()</code>.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_alternatives">alternatives</code></td>
<td>
<p>The alternatives that were considered in a decision.</p>
</td></tr>
<tr><td><code id="c.justifierElement_+3A_justification">justification</code></td>
<td>
<p>In decisions, the justification (or justifications)
that the decision is based on can be specified using <code>jstf()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Programmatically create a partial justification object
justifierAssertion &lt;-
  justifier::assert(
    "This is an assertion",
    source = c(
      justifier::source('This is a first source'),
      justifier::source('This is a second source')));

### Programmatically create a justification with two assertions
### but without sources
justifierJustification &lt;-
  justifier::justify(
    "Icecream will make me feel less fit",
    assertion = c(
      justifier::assert('Icecream is rich in energy'),
      justifier::assert('Consuming high-energy foods makes me feel less fit')
    ),
    weight = -.5
  );

### Show it
justifierJustification;

### Programmatically create a simple decision
simpleDecision &lt;-
  justifier::decide(
    "decision",
    justification = justifier::jstf(
      "justification",
      assertion = justifierAssertion
    )
  );

### Programmatically create a justification object for a full decision
fullJustifierObject &lt;-
  justifier::decide(
    "I decide to go get an icecream",
    justification = c(
      justifier::justify(
        "Having an icecream now would make me happy",
        assertion = c(
          justifier::assert(
            "Decreasing hunger increases happiness",
            source = justifier::source(
              "My past experiences"
            )
          ),
          justifier::assert(
            "I feel hungry",
            source = justifier::source(
              "Bodily sensations"
            )
          )
        ),
        weight = 1
      ),
      justifierJustification,
      justifier::justify(
        "I can afford to buy an icecream.",
        assertion = c(
          justifier::assert(
            "My bank account balance is over 300 euro.",
            source = justifier::source(
              "My bank app"
            )
          ),
          justifier::assert(
            "I need to keep at least 100 euro in my bank account.",
            source = justifier::source(
              "Parental advice"
            )
          )
        ),
        weight = .3
      )
    )
  );

### Show the full object
fullJustifierObject;

### Combine both into a list of decisions
twoDecisions &lt;-
  c(simpleDecision,
    fullJustifierObject);

### Show the combination
twoDecisions;

</code></pre>

<hr>
<h2 id='c.justifierStructuredObject'>Concatenate two or more structured justifier objects</h2><span id='topic+c.justifierStructuredObject'></span>

<h3>Description</h3>

<p>Concatenate two or more structured justifier objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'justifierStructuredObject'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.justifierStructuredObject_+3A_...">...</code></td>
<td>
<p>Structured justifier objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the concatenated list
</p>

<hr>
<h2 id='cat0'>Concatenate to screen without spaces</h2><span id='topic+cat0'></span>

<h3>Description</h3>

<p>The cat0 function is to cat what paste0 is to paste; it
simply makes concatenating many strings without a separator easier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cat0(..., sep = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cat0_+3A_...">...</code></td>
<td>
<p>The character vector(s) to print; passed to <a href="base.html#topic+cat">cat</a>.</p>
</td></tr>
<tr><td><code id="cat0_+3A_sep">sep</code></td>
<td>
<p>The separator to pass to <a href="base.html#topic+cat">cat</a>, of course, <code>""</code> by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing (invisible <code>NULL</code>, like <a href="base.html#topic+cat">cat</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cat0("The first variable is '", names(mtcars)[1], "'.");
</code></pre>

<hr>
<h2 id='clean_workspace'>Clean your workspace</h2><span id='topic+clean_workspace'></span>

<h3>Description</h3>

<p>Clean your workspace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_workspace(force = FALSE, silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_workspace_+3A_force">force</code></td>
<td>
<p>Whether to force cleaning the workspace</p>
</td></tr>
<tr><td><code id="clean_workspace_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or silent.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### Without `force=TRUE`, presents a query to the user in
### interactive mode:
clean_workspace(silent=FALSE);

### Set `force=TRUE` to force clean the workspace
clean_workspace(force = TRUE, silent=FALSE);
</code></pre>

<hr>
<h2 id='export_justification'>Export justification as YAML</h2><span id='topic+export_justification'></span>

<h3>Description</h3>

<p>Export justification as YAML
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_justification(
  x,
  file = NULL,
  encoding = "UTF-8",
  append = TRUE,
  preventOverwriting = TRUE,
  silent = justifier::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_justification_+3A_x">x</code></td>
<td>
<p>The justification, either loaded from one or more files or
programmatically constructed. This can be one or more decisions,
justifications, assertions, or sources.</p>
</td></tr>
<tr><td><code id="export_justification_+3A_file">file</code></td>
<td>
<p>If specified, the file to export the justification to.</p>
</td></tr>
<tr><td><code id="export_justification_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the file.</p>
</td></tr>
<tr><td><code id="export_justification_+3A_append">append</code></td>
<td>
<p>Whether to append to the file, or replace its contents.</p>
</td></tr>
<tr><td><code id="export_justification_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting an existing file.</p>
</td></tr>
<tr><td><code id="export_justification_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The generated YAML, invisibly, unless file is NULL.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Programmatically create a simple justification object
justifierObject &lt;-
  justifier::asrt(
    "assertion",
    source = c(
      justifier::srce('source1'),
      justifier::srce('source2')));

### Export to YAML
justifierYAML &lt;-
  justifier::export_justification(
    justifierObject,
    file=NULL);

### Show YAML
cat(justifierYAML, sep="\n");
</code></pre>

<hr>
<h2 id='export_to_json'>Export a justifier specification to JSON</h2><span id='topic+export_to_json'></span><span id='topic+export_to_json.justifierStructuredObject'></span><span id='topic+print.justifier_json'></span>

<h3>Description</h3>

<p>Export a justifier specification to JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_to_json(x, file = NULL, wrap_in_html = FALSE)

## S3 method for class 'justifierStructuredObject'
export_to_json(x, file = NULL, wrap_in_html = FALSE)

## S3 method for class 'justifier_json'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_to_json_+3A_x">x</code></td>
<td>
<p>The justifier specification.</p>
</td></tr>
<tr><td><code id="export_to_json_+3A_file">file</code></td>
<td>
<p>Optionally, a file to save the JSON to.</p>
</td></tr>
<tr><td><code id="export_to_json_+3A_wrap_in_html">wrap_in_html</code></td>
<td>
<p>Whether to wrap the JSON in an HTML element.</p>
</td></tr>
<tr><td><code id="export_to_json_+3A_...">...</code></td>
<td>
<p>Any additional arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If a file is specified to write, to, <code>x</code> will be returned invisibly
to allow building a pipe chain; if <code>file=NULL</code>, the resulting JSON
will be returned as a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Programmatically create a justification with two assertions
### but without sources; flatten it; and show the json
justifier::justify(
  "Icecream will make me feel less fit",
  assertion = c(
    justifier::assert('Icecream is rich in energy'),
    justifier::assert('Consuming high-energy foods makes me feel less fit')
  ),
  weight = -.5
) |&gt;
  justifier::flatten() |&gt;
  justifier::export_to_json();
</code></pre>

<hr>
<h2 id='flatten'>Flatten a justifier tree</h2><span id='topic+flatten'></span><span id='topic+flatten.multipleJustifierElements'></span><span id='topic+flatten.singleJustifierElement'></span>

<h3>Description</h3>

<p>Flattening takes all justifications, assertions, and sources from their
parents and returns a structured justifier object containing these
elements in separate lists, with each occurrence replaced with a reference
to the corresponding identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten(x, ..., recursionLevel = 0, silent = justifier::opts$get("silent"))

## S3 method for class 'multipleJustifierElements'
flatten(x, ..., recursionLevel = 0, silent = justifier::opts$get("silent"))

## S3 method for class 'singleJustifierElement'
flatten(x, ..., recursionLevel = 0, silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flatten_+3A_x">x</code></td>
<td>
<p>The justifier object or objects.</p>
</td></tr>
<tr><td><code id="flatten_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the methods.</p>
</td></tr>
<tr><td><code id="flatten_+3A_recursionlevel">recursionLevel</code></td>
<td>
<p>The depth of the recursion</p>
</td></tr>
<tr><td><code id="flatten_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A flattened justifier object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Programmatically create a justification with two assertions
### but without sources
justifierJustification &lt;-
  justifier::justify(
    "Icecream will make me feel less fit",
    assertion = c(
      justifier::assert('Icecream is rich in energy'),
      justifier::assert('Consuming high-energy foods makes me feel less fit')
    ),
    weight = -.5
  );

### Flatten it into a structures justifier object
structuredJustification &lt;-
  justifier::flatten(
    justifierJustification
  );

### Check it
str(structuredJustification, 1);
</code></pre>

<hr>
<h2 id='generate_id'>Generate unique identifier(s)</h2><span id='topic+generate_id'></span>

<h3>Description</h3>

<p>Convenience function to generate a unique identifiers for
sources, assertions, justifications, and decisions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_id(
  type,
  prefix = paste(sample(letters, 4), collapse = ""),
  stopOnIllegalChars = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate_id_+3A_type">type</code></td>
<td>
<p>The type of the justifier object; <code>D</code>, <code>J</code>, <code>A</code> or <code>S</code>.</p>
</td></tr>
<tr><td><code id="generate_id_+3A_prefix">prefix</code></td>
<td>
<p>An identifier prefix.</p>
</td></tr>
<tr><td><code id="generate_id_+3A_stoponillegalchars">stopOnIllegalChars</code></td>
<td>
<p>Whether to <code><a href="base.html#topic+stop">base::stop()</a></code> or produce a <code><a href="base.html#topic+warning">base::warning()</a></code>
when encountering illegal characters (i.e. anything other than a letter or
underscore).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector containing the identifier(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>generate_id(type = "S", 'sourceExample');
generate_id(type = "A", 'assertionExample');
</code></pre>

<hr>
<h2 id='get_workspace'>Get your justifier workspace identifier</h2><span id='topic+get_workspace'></span>

<h3>Description</h3>

<p>This is used to be able to log decisions programmatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_workspace(silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_workspace_+3A_silent">silent</code></td>
<td>
<p>Whether to be suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the workspace identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>justifier::get_workspace_id();
</code></pre>

<hr>
<h2 id='get_workspace_id'>Get your justifier workspace identifier</h2><span id='topic+get_workspace_id'></span>

<h3>Description</h3>

<p>This is used to be able to log decisions programmatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_workspace_id(silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_workspace_id_+3A_silent">silent</code></td>
<td>
<p>Whether to be suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the workspace identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>justifier::get_workspace_id();
</code></pre>

<hr>
<h2 id='idRef'>Create a reference to one or more justifier objects</h2><span id='topic+idRef'></span><span id='topic+idRef.singleJustifierElement'></span><span id='topic+idRef.multipleJustifierElements'></span><span id='topic+idRef.justifierIdRef'></span><span id='topic+idRef.character'></span><span id='topic+idRef.justifierStructured'></span>

<h3>Description</h3>

<p>Create a reference to one or more justifier objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idRef(x, what = NULL, silent = justifier::opts$get("silent"))

## S3 method for class 'singleJustifierElement'
idRef(x, what = NULL, silent = justifier::opts$get("silent"))

## S3 method for class 'multipleJustifierElements'
idRef(x, what = NULL, silent = justifier::opts$get("silent"))

## S3 method for class 'justifierIdRef'
idRef(x, what = NULL, silent = justifier::opts$get("silent"))

## S3 method for class 'character'
idRef(x, what = NULL, silent = justifier::opts$get("silent"))

## S3 method for class 'justifierStructured'
idRef(x, what = NULL, silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="idRef_+3A_x">x</code></td>
<td>
<p>The identifier(s)</p>
</td></tr>
<tr><td><code id="idRef_+3A_what">what</code></td>
<td>
<p>Optionally, what <code>x</code> is (<code>decision</code>, <code>justification</code>,
<code>assertion</code>, or <code>source</code>).</p>
</td></tr>
<tr><td><code id="idRef_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The justifier id reference object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleSource &lt;-
  justifier::source("This is a book about R.");

exampleAssertion &lt;- justifier::assert(
  "R is a functional language",
  source = justifier::idRef(exampleSource)
);

### Get and show the reference
(sourceId &lt;- exampleAssertion$source);

sourceId &lt;- as.character(sourceId);

### Manually assign an identifier
justifier::idRef(sourceId);

### Repeat while specifying what we're passing
justifier::idRef(sourceId, what="source");
</code></pre>

<hr>
<h2 id='ifelseObj'>Conditional returning of an object</h2><span id='topic+ifelseObj'></span>

<h3>Description</h3>

<p>The ifelseObj function just evaluates a condition, returning
one object if it's true, and another if it's false.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifelseObj(condition, ifTrue, ifFalse)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ifelseObj_+3A_condition">condition</code></td>
<td>
<p>Condition to evaluate.</p>
</td></tr>
<tr><td><code id="ifelseObj_+3A_iftrue">ifTrue</code></td>
<td>
<p>Object to return if the condition is true.</p>
</td></tr>
<tr><td><code id="ifelseObj_+3A_iffalse">ifFalse</code></td>
<td>
<p>Object to return if the condition is false.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>One of the two objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- ifelseObj(sample(c(TRUE, FALSE), 1), mtcars, Orange);

</code></pre>

<hr>
<h2 id='import_from_json'>Import a structured justifier object from JSON</h2><span id='topic+import_from_json'></span>

<h3>Description</h3>

<p>Import a structured justifier object from JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_from_json(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_from_json_+3A_x">x</code></td>
<td>
<p>Either a path to an existing file, or a character vector with the
JSON to import.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The justifier object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Programmatically create a justification with two assertions
### but without sources; flatten it; and show the json
justifier::justify(
  "Icecream will make me feel less fit",
  assertion = c(
    justifier::assert('Icecream is rich in energy'),
    justifier::assert('Consuming high-energy foods makes me feel less fit')
  ),
  weight = -.5
) |&gt;
  justifier::flatten() -&gt; originalObject;

originalObject |&gt;
  justifier::export_to_json() -&gt;
  exportedJSON;

### And import it again
importedFromJSON &lt;-
  justifier::import_from_json(
    exportedJSON
  );
</code></pre>

<hr>
<h2 id='load_justifications'>Load Justifications from a file or multiple files</h2><span id='topic+load_justifications'></span><span id='topic+load_justifications_dir'></span><span id='topic+print.justifications'></span><span id='topic+plot.justifications'></span>

<h3>Description</h3>

<p>These function load justifications from the YAML fragments
in one (<code>load_justifications</code>) or multiple files (<code>load_justifications_dir</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>load_justifications(
  text = NULL,
  file = NULL,
  delimiterRegEx = "^---$",
  justificationContainer = c("justifier", "justification", "decision", "assertion",
    "source"),
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  storeDecisionGraphSvg = TRUE,
  silent = TRUE
)

load_justifications_dir(
  path,
  recursive = TRUE,
  extension = "jmd",
  regex = NULL,
  justificationContainer = c("justifier", "justification", "decision", "assertion",
    "source"),
  delimiterRegEx = "^---$",
  ignoreOddDelimiters = FALSE,
  encoding = "UTF-8",
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="load_justifications_+3A_text">text</code>, <code id="load_justifications_+3A_file">file</code></td>
<td>
<p>As <code>text</code> or <code>file</code>, you can specify a <code>file</code> to read with
encoding <code>encoding</code>, which will then be read using <code><a href="base.html#topic+readLines">base::readLines()</a></code>. If the
argument is named <code>text</code>, whether it is the path to an existing file is checked
first, and if it is, that file is read. If the argument is named <code>file</code>, and it
does not point to an existing file, an error is produced (useful if calling
from other functions). A <code>text</code> should be a character vector where every
element is a line of the original source (like provided by <code><a href="base.html#topic+readLines">base::readLines()</a></code>);
although if a character vector of one element <em>and</em> including at least one
newline character (<code style="white-space: pre;">&#8288;\\n&#8288;</code>) is provided as <code>text</code>, it is split at the newline
characters using <code><a href="base.html#topic+strsplit">base::strsplit()</a></code>. Basically, this behavior means that the
first argument can be either a character vector or the path to a file; and if
you're specifying a file and you want to be certain that an error is thrown if
it doesn't exist, make sure to name it <code>file</code>.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_delimiterregex">delimiterRegEx</code></td>
<td>
<p>The regular expression used to locate YAML
fragments</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_justificationcontainer">justificationContainer</code></td>
<td>
<p>The container of the justifications in the YAML
fragments. Because only justifications are read that are stored in
this container, the files can contain YAML fragments with other data, too,
without interfering with the parsing of the justifications.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_ignoreodddelimiters">ignoreOddDelimiters</code></td>
<td>
<p>Whether to throw an error (FALSE) or
delete the last delimiter (TRUE) if an odd number of delimiters is
encountered.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when calling <code><a href="base.html#topic+readLines">readLines()</a></code>. Set to
NULL to let <code><a href="base.html#topic+readLines">readLines()</a></code> guess.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_storedecisiongraphsvg">storeDecisionGraphSvg</code></td>
<td>
<p>Whether to also produce (and return) the SVG
for the decision graph.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent (TRUE) or informative (FALSE).</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_path">path</code></td>
<td>
<p>The path containing the files to read.</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_recursive">recursive</code></td>
<td>
<p>Whether to also process subdirectories (<code>TRUE</code>)
or not (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_extension">extension</code></td>
<td>
<p>The extension of the files to read; files with other extensions will
be ignored. Multiple extensions can be separated by a pipe (<code>|</code>).</p>
</td></tr>
<tr><td><code id="load_justifications_+3A_regex">regex</code></td>
<td>
<p>Instead of specifing an extension, it's also possible to specify a regular
expression; only files matching this regular expression are read. If specified, <code>regex</code>
takes precedece over <code>extension</code>,</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>load_justifications_dir</code> simply identifies all files and then calls
<code>load_justifications</code> for each of them. <code>load_justifications</code> loads the
YAML fragments containing the justifications using
<code><a href="yum.html#topic+load_yaml_fragments">yum::load_yaml_fragments()</a></code> and then parses the justifications
into a visual representation as a
<a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> graph and Markdown documents with
overviews.
</p>


<h3>Value</h3>

<p>An object with the <a href="ggplot2.html#topic+ggplot">ggplot2::ggplot</a> graph stored
in <code>output$graph</code> and the overview in <code>output$overview</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exampleMinutes &lt;- 'This is an example of minutes that include
a source, an assertion, and a justification. For example, in
the meeting, we can discuss the assertion that sleep deprivation
affects decision making. We could quickly enter this assertion in
a machine-readable way in this manner:

---
assertion:
  -
    id: assertion_SD_decision
    label: Sleep deprivation affects the decision making proces.
    source:
      id: source_Harrison
---

Because it is important to refer to sources, we cite a source as well.
We have maybe specified that source elsewhere, for example in the
minutes of our last meeting. That specification may have looked
like this:

---
source:
  -
    id: source_Harrison
    label: "Harrison &amp; Horne (2000) The impact of sleep deprivation on decision making: A review."
    xdoi: "doi:10.1037/1076-898x.6.3.236"
    type: "Journal article"
---

We can now refer to these two specifications later on, for
example to justify decisions we take.
';

justifier::load_justifications(text=exampleMinutes);

### To load a directory with justifications

examplePath &lt;-
  file.path(system.file(package="justifier"),
            'extdata');
justifier::load_justifications_dir(path=examplePath);

</code></pre>

<hr>
<h2 id='log_decision'>Document a decision</h2><span id='topic+log_decision'></span>

<h3>Description</h3>

<p>Used to programmatically document decisions - note that you have to
store them to a file to not lose them (i.e. if used interactively).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_decision(
  label,
  description = "",
  alternatives = "",
  date = as.character(Sys.Date()),
  id = NULL,
  justification = "",
  silent = justifier::opts$get("silent"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_decision_+3A_label">label</code></td>
<td>
<p>A human-readable label for the <code>decision</code>,</p>
</td></tr>
<tr><td><code id="log_decision_+3A_description">description</code></td>
<td>
<p>A human-readable description.</p>
</td></tr>
<tr><td><code id="log_decision_+3A_alternatives">alternatives</code></td>
<td>
<p>The alternatives between which was chosen.</p>
</td></tr>
<tr><td><code id="log_decision_+3A_date">date</code></td>
<td>
<p>The date of the decision.</p>
</td></tr>
<tr><td><code id="log_decision_+3A_id">id</code></td>
<td>
<p>Optionally, a manually specified id (otherwise, randomly
generated).</p>
</td></tr>
<tr><td><code id="log_decision_+3A_justification">justification</code></td>
<td>
<p>A justification specified using <code><a href="#topic+jstf">jstf()</a></code>, or
more than one, combined with the <code>c</code> operator.</p>
</td></tr>
<tr><td><code id="log_decision_+3A_silent">silent</code></td>
<td>
<p>Whether to print messages.</p>
</td></tr>
<tr><td><code id="log_decision_+3A_...">...</code></td>
<td>
<p>Any additional options will be stored in the decision.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the decision as a <code>justifier</code> object (generated by
<code><a href="#topic+dcsn">dcsn()</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clean_workspace(force = TRUE, silent=FALSE);
log_decision("First we start using `justifier`.",
             silent=FALSE);
log_decision(paste0("Then we start documenting our ",
                    "decisions and justifications."),
             silent=FALSE);
log_decision("Then we start learning from ourselves.",
             silent=FALSE);
workspace();
</code></pre>

<hr>
<h2 id='merge_specLists'>Merging to justifier specification lists</h2><span id='topic+merge_specLists'></span>

<h3>Description</h3>

<p>Merging to justifier specification lists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_specLists(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="merge_specLists_+3A_x">x</code>, <code id="merge_specLists_+3A_y">y</code></td>
<td>
<p>The two justifier specification lists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A merged justifier specification list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Add example
</code></pre>

<hr>
<h2 id='opts'>Options for the justifier package</h2><span id='topic+opts'></span><span id='topic+set'></span><span id='topic+get'></span><span id='topic+reset'></span>

<h3>Description</h3>

<p>The <code>justifier::opts</code> object contains three functions to set, get, and reset
options used by the escalc package. Use <code>justifier::opts$set</code> to set options,
<code>justifier::opts$get</code> to get options, or <code>justifier::opts$reset</code> to reset specific or
all options to their default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opts
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 4.
</p>


<h3>Details</h3>

<p>If you use justifier to programmatically document your decisions in an
R file, there is one option that you common use: <code>workspace_id</code> and
<code>workspace_option_name</code>
</p>
<p>It is normally not necessary to get or set <code>justifier</code> options.
</p>
<p>The following arguments can be passed:
</p>

<dl>
<dt>...</dt><dd><p>For <code>justifier::opts$set</code>, the dots can be used to specify the options
to set, in the format <code>option = value</code>, for example,
<code>EFFECTSIZE_POINTESTIMATE_NAME_IN_DF = "\n"</code>. For
<code>justifier::opts$reset</code>, a list of options to be reset can be passed.</p>
</dd>
<dt>option</dt><dd><p>For <code>justifier::opts$set</code>, the name of the option to set.</p>
</dd>
<dt>default</dt><dd><p>For <code>justifier::opts$get</code>, the default value to return if the
option has not been manually specified.</p>
</dd>
</dl>

<p>The following options can be set:
</p>

<dl>
<dt>regExReplacements</dt><dd><p>Default regex replacements when sanitizing for DiagrammeR</p>
</dd>
<dt>weight_fieldName</dt><dd><p>When creating the diagram showing the justification for a
decision, the name of the field with the weight.</p>
</dd>
<dt>negWeight_color</dt><dd><p>When creating the diagram showing the justification for a
decision, the colour to use for edges with negative weights</p>
</dd>
<dt>posWeight_color</dt><dd><p>When creating the diagram showing the justification for a
decision, the colour to use for edges with positive weights</p>
</dd>
<dt>node_color</dt><dd><p>When creating the diagram showing the justification for a
decision, the color for nodes</p>
</dd>
<dt>edge_color</dt><dd><p>When creating the diagram showing the justification for a
decision, the color for edges</p>
</dd>
<dt>penwidth</dt><dd><p>When creating the diagram showing the justification for a
decision, the pen widht</p>
</dd>
<dt>workspace_id</dt><dd><p>The default identifier for the workspace (when
nothing else is specified)</p>
</dd>
<dt>workspace</dt><dd><p>The name of the default workspace</p>
</dd>
<dt>silent</dt><dd><p>Whether to be chatty or silent</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>### Get the default 'silent' setting
justifier::opts$get('silent');

### Set to FALSE
justifier::opts$set(silent = FALSE);

### Check that it worked
justifier::opts$get('silent');

### Reset this option to its default value
justifier::opts$reset('silent');

### Check that the reset worked, too
justifier::opts$get('silent');

</code></pre>

<hr>
<h2 id='parse_justifications'>Parsing justifications</h2><span id='topic+parse_justifications'></span><span id='topic+print.justifierDecisionGraph'></span><span id='topic+plot.justifierDecisionGraph'></span>

<h3>Description</h3>

<p>This function is normally called by <code><a href="#topic+load_justifications">load_justifications()</a></code>; however,
sometimes it may be desirable to parse justifications embedded in more
complex objects, for example as provided by <code><a href="yum.html#topic+load_and_simplify">yum::load_and_simplify()</a></code>.
Therefore, this function can also be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_justifications(
  x,
  justifierFields = "^date$|^framework$",
  fromFile = NULL,
  path = NULL,
  storeDecisionGraphSvg = FALSE,
  silent = TRUE
)

## S3 method for class 'justifierDecisionGraph'
print(x, ...)

## S3 method for class 'justifierDecisionGraph'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_justifications_+3A_x">x</code></td>
<td>
<p>An object resulting from a call to <code><a href="yum.html#topic+load_and_simplify">yum::load_and_simplify()</a></code>.</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_justifierfields">justifierFields</code></td>
<td>
<p>Which fields to copy from <code>justifier</code> metadata to
the elements within the specified scope.</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_fromfile">fromFile</code></td>
<td>
<p>The file from which the <code>justifier</code> specifications were read.</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_path">path</code></td>
<td>
<p>The path holding these <code>justifier</code> specifications (not necessary
if <code>fromFile</code> is provided).</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_storedecisiongraphsvg">storeDecisionGraphSvg</code></td>
<td>
<p>Whether to also produce (and return) the SVG
for the decision graph.</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or quiet.</p>
</td></tr>
<tr><td><code id="parse_justifications_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed on to <code><a href="graphics.html#topic+plot.default">graphics::plot()</a></code> for the
<code>print</code> method or to <code><a href="DiagrammeR.html#topic+render_graph">DiagrammeR::render_graph()</a></code> for the <code>plot</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While there is some flexibility in how justifications can be specified,
they are most easily processed further if they all follow the same
conventions. This function ensures this. The convention is as follows:
</p>

<ul>
<li><p> all specifications are provided in four 'flat' lists, named after the
types of elements they contain;
</p>
</li>
<li><p> all elements have  a unique identifier
</p>
</li>
<li><p> all references to other elements are indeed only references to the other
elements' id's in these 'flat lists'
</p>
</li></ul>



<h3>Value</h3>

<p>The parsed <code>justifier</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Specify an example text
exampleFile &lt;-
  system.file("extdata",
              "simple-example.jmd",
              package="justifier");

### Show contents
cat(readLines(exampleFile), sep="\n");

### Load it with yum::load_and_simplify()
loadedMinutes &lt;- yum::load_and_simplify(exampleFile);

### Show contents
names(loadedMinutes);

### Parse 'manually'
parsedJustifications &lt;- justifier::parse_justifications(loadedMinutes);

### Show contents
names(parsedJustifications);

</code></pre>

<hr>
<h2 id='randomSlug'>Generate a random slug</h2><span id='topic+randomSlug'></span><span id='topic+idSlug'></span>

<h3>Description</h3>

<p>idSlug is a convenience function with swapped argument order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomSlug(x = 10, id = NULL, chars = c(letters, LETTERS, 0:9))

idSlug(id = NULL, x = 10, chars = c(letters, LETTERS, 0:9))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="randomSlug_+3A_x">x</code></td>
<td>
<p>Length of slug</p>
</td></tr>
<tr><td><code id="randomSlug_+3A_id">id</code></td>
<td>
<p>If not NULL, prepended to slug (separated with a dash) as id; in
that case, it's also braces and a hash is added.</p>
</td></tr>
<tr><td><code id="randomSlug_+3A_chars">chars</code></td>
<td>
<p>Characters to sample from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>randomSlug();
idSlug("identifier");
</code></pre>

<hr>
<h2 id='repeatStr'>Repeat a string a number of times</h2><span id='topic+repeatStr'></span><span id='topic+repStr'></span>

<h3>Description</h3>

<p>Repeat a string a number of times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatStr(n = 1, str = " ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repeatStr_+3A_n">n</code>, <code id="repeatStr_+3A_str">str</code></td>
<td>
<p>Normally, respectively the frequency with which to
repeat the string and the string to repeat; but the order of the
inputs can be switched as well.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### 10 spaces:
repStr(10);

### Three euro symbols:
repStr("\u20ac", 3);
</code></pre>

<hr>
<h2 id='sanitize_for_DiagrammeR'>Sanitize for DiagrammeR</h2><span id='topic+sanitize_for_DiagrammeR'></span>

<h3>Description</h3>

<p>Basically a wrapper for <code><a href="base.html#topic+gsub">gsub()</a></code> to sanitize a string for
DiagrammeR
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_for_DiagrammeR(
  x,
  regExReplacements = justifier::opts$get("regExReplacements")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sanitize_for_DiagrammeR_+3A_x">x</code></td>
<td>
<p>The string or vector</p>
</td></tr>
<tr><td><code id="sanitize_for_DiagrammeR_+3A_regexreplacements">regExReplacements</code></td>
<td>
<p>A list of two-element character vectors; first element
should be the element to search, and the second element, the replacement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The sanitized character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>justifier::sanitize_for_DiagrammeR("This is or isn't problematic");
</code></pre>

<hr>
<h2 id='save_workspace'>Save your workspace</h2><span id='topic+save_workspace'></span>

<h3>Description</h3>

<p>Save your workspace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_workspace(
  file = NULL,
  encoding = "UTF-8",
  append = FALSE,
  preventOverwriting = TRUE,
  silent = justifier::opts$get("silent")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="save_workspace_+3A_file">file</code></td>
<td>
<p>If specified, the file to export the justification to.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_encoding">encoding</code></td>
<td>
<p>The encoding to use when writing the file.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_append">append</code></td>
<td>
<p>Whether to append to the file, or replace its contents.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_preventoverwriting">preventOverwriting</code></td>
<td>
<p>Whether to prevent overwriting an existing file.</p>
</td></tr>
<tr><td><code id="save_workspace_+3A_silent">silent</code></td>
<td>
<p>Whether to be silent or chatty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of a call to <code><a href="#topic+export_justification">export_justification()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clean_workspace(force = TRUE, silent=FALSE);
log_decision("First we start using `justifier`.",
             silent=FALSE);
log_decision(paste0("Then we start documenting our ",
                    "decisions and justifications."),
             silent=FALSE);
log_decision("Then we start learning from ourselves.",
             silent=FALSE);
save_workspace();
</code></pre>

<hr>
<h2 id='set_workspace_id'>Set your justifier workspace identifier</h2><span id='topic+set_workspace_id'></span>

<h3>Description</h3>

<p>This is used to be able to log decisions programmatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_workspace_id(id, silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_workspace_id_+3A_id">id</code></td>
<td>
<p>The workspace identifier</p>
</td></tr>
<tr><td><code id="set_workspace_id_+3A_silent">silent</code></td>
<td>
<p>Whether to be suppress messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, the passed <code>id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set_workspace_id("my_workspace");
</code></pre>

<hr>
<h2 id='to_specList'>Producing a list of specifications</h2><span id='topic+to_specList'></span>

<h3>Description</h3>

<p>This function is for internal use, but has been exported in
case it's useful for people working 'manually' with
lists of justifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_specList(x, types, type, idsRequired = TRUE, silent = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="to_specList_+3A_x">x</code></td>
<td>
<p>The list to parse.</p>
</td></tr>
<tr><td><code id="to_specList_+3A_types">types</code></td>
<td>
<p>The class to assign to the specification
list (the <code>justifierSpecList</code> object to return).</p>
</td></tr>
<tr><td><code id="to_specList_+3A_type">type</code></td>
<td>
<p>The class to assign to each specification
(in addition to <code>justifierSpec</code>).</p>
</td></tr>
<tr><td><code id="to_specList_+3A_idsrequired">idsRequired</code></td>
<td>
<p>Whether to require identifiers.</p>
</td></tr>
<tr><td><code id="to_specList_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or silent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of classes <code>c("justifierSpecList", types)</code> where
each element is a specification of class
<code>c("justifierSpec", type)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Specify an example text
exampleFile &lt;-
  system.file("extdata",
              "simple-example.jmd",
              package="justifier");

### Show contents
cat(readLines(exampleFile), sep="\n");

### Load it with yum::load_and_simplify()
loadedMinutes &lt;- yum::load_and_simplify(exampleFile);

### Show contents
names(loadedMinutes);

### Show classes
class(loadedMinutes["assertion"]);

### Convert to specification list
res &lt;- to_specList(loadedMinutes["assertion"],
                   type="assertion",
                   types="assertions");
### Show classes
class(res);

### Show original and parsed objects
loadedMinutes["assertion"];
res;

</code></pre>

<hr>
<h2 id='vecTxt'>Easily parse a vector into a character value</h2><span id='topic+vecTxt'></span><span id='topic+vecTxtQ'></span>

<h3>Description</h3>

<p>Easily parse a vector into a character value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vecTxt(
  vector,
  delimiter = ", ",
  useQuote = "",
  firstDelimiter = NULL,
  lastDelimiter = " &amp; ",
  firstElements = 0,
  lastElements = 1,
  lastHasPrecedence = TRUE
)

vecTxtQ(vector, useQuote = "'", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vecTxt_+3A_vector">vector</code></td>
<td>
<p>The vector to process.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_delimiter">delimiter</code>, <code id="vecTxt_+3A_firstdelimiter">firstDelimiter</code>, <code id="vecTxt_+3A_lastdelimiter">lastDelimiter</code></td>
<td>
<p>The delimiters
to use for respectively the middle, first
<code>firstElements</code>, and last <code>lastElements</code> elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_usequote">useQuote</code></td>
<td>
<p>This character string is pre- and appended to all elements;
so use this to quote all elements (<code>useQuote="'"</code>), doublequote all
elements (<code>useQuote='"'</code>), or anything else (e.g. <code>useQuote='|'</code>).
The only difference between <code>vecTxt</code> and <code>vecTxtQ</code> is that the
latter by default quotes the elements.</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_firstelements">firstElements</code>, <code id="vecTxt_+3A_lastelements">lastElements</code></td>
<td>
<p>The number of elements for which to use
the first respective last delimiters</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_lasthasprecedence">lastHasPrecedence</code></td>
<td>
<p>If the vector is very short, it's possible that the
sum of firstElements and lastElements is larger than the vector length. In
that case, downwardly adjust the number of elements to separate with the
first delimiter (<code>TRUE</code>) or the number of elements to separate with the
last delimiter (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="vecTxt_+3A_...">...</code></td>
<td>
<p>Any addition arguments to <code>vecTxtQ</code> are passed on to
<code>vecTxt</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of length 1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vecTxtQ(names(mtcars));
</code></pre>

<hr>
<h2 id='workspace'>Show your workspace contents</h2><span id='topic+workspace'></span>

<h3>Description</h3>

<p>Show your workspace contents
</p>


<h3>Usage</h3>

<pre><code class='language-R'>workspace(silent = justifier::opts$get("silent"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="workspace_+3A_silent">silent</code></td>
<td>
<p>Whether to be chatty or silent.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The workspace contents.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>justifier::clean_workspace(force = TRUE, silent=FALSE);
justifier::log_decision(
  "First we start using `justifier`.",
  silent=FALSE
);
justifier::log_decision(
  paste0("Then we start documenting our ",
         "decisions and justifications."),
  silent=FALSE
);
justifier::log_decision(
  "Then we start learning from ourselves.",
  silent=FALSE
);
justifier::workspace();
</code></pre>

<hr>
<h2 id='wrapVector'>Wrap all elements in a vector</h2><span id='topic+wrapVector'></span>

<h3>Description</h3>

<p>Wrap all elements in a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrapVector(x, width = 0.9 * getOption("width"), sep = "\n", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wrapVector_+3A_x">x</code></td>
<td>
<p>The character vector</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_width">width</code></td>
<td>
<p>The number of</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_sep">sep</code></td>
<td>
<p>The glue with which to combine the new lines</p>
</td></tr>
<tr><td><code id="wrapVector_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to <code><a href="base.html#topic+strwrap">strwrap()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- wrapVector(
  c(
    "This is a sentence ready for wrapping",
    "So is this one, although it's a bit longer"
  ),
  width = 10
);

print(res);
cat(res, sep="\n");
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
