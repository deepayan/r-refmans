<!DOCTYPE html><html><head><title>Help for package ICSNP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ICSNP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#duembgen.shape'><p> Duembgen's Shape Matrix</p></a></li>
<li><a href='#duembgen.shape.wt'><p> Weighted Duembgen's Shape Matrix</p></a></li>
<li><a href='#hl.loc'><p> Hodges - Lehmann Estimator of Location</p></a></li>
<li><a href='#HotellingsT2'><p>Hotelling's T2 Test</p></a></li>
<li><a href='#HP.loc.test'>
<p>Hallin and Paindaveine Signed-Rank Tests</p></a></li>
<li><a href='#HP1.shape'><p> One Step Rank Scatter Estimator</p></a></li>
<li><a href='#HR.Mest'><p>Simultaneous</p>
Affine Equivariant Estimation of Multivariate Median and Tyler's Shape
Matrix</a></li>
<li><a href='#ICSNP-package'>
<p>Tools for Multivariate Nonparametrics</p></a></li>
<li><a href='#ind.ctest'><p>Test of Independece based on Marginal Ranks</p></a></li>
<li><a href='#ind.ictest'><p>Test of Independence based on Marginal Ranks in a Symmetric IC Model</p></a></li>
<li><a href='#LASERI'>
<p>Cardiovascular Responses to Head-up Tilt</p></a></li>
<li><a href='#pair.diff'><p>Pairwise Differences</p></a></li>
<li><a href='#pair.prod'><p> Pairwise Products</p></a></li>
<li><a href='#pair.sum'><p>Pairwise Sums</p></a></li>
<li><a href='#pulmonary'><p> Change in Pulmonary Response after Exposure to Cotton Dust</p></a></li>
<li><a href='#rank.ctest'><p> One, Two and C Sample Rank Tests for Location based on Marginal Ranks</p></a></li>
<li><a href='#rank.ictest'><p> One Sample Location Test based on Marginal Ranks in the Independent Component Model</p></a></li>
<li><a href='#spatial.median'><p> Spatial Median</p></a></li>
<li><a href='#spatial.sign'><p>Spatial Signs</p></a></li>
<li><a href='#symm.huber'><p> Symmetrized Huber Scatter Matrix</p></a></li>
<li><a href='#symm.huber.wt'><p> Weighted Symmetrized Huber Scatter Matrix</p></a></li>
<li><a href='#tyler.shape'><p> Tyler's Shape Matrix</p></a></li>
<li><a href='#vdw.loc'><p> Van der Waerden Estimator of Location</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tools for Multivariate Nonparametrics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-18</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Nordhausen <a href="https://orcid.org/0000-0002-3758-8501"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Seija Sirkia [aut],
  Hannu Oja <a href="https://orcid.org/0000-0002-4945-5976"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  David E. Tyler [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>mvtnorm, ICS</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for multivariate nonparametrics, as location tests based on marginal ranks, spatial median and spatial signs computation, Hotelling's T-test, estimates of shape are implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-18 11:39:25 UTC; admin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-18 12:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='duembgen.shape'> Duembgen's Shape Matrix </h2><span id='topic+duembgen.shape'></span>

<h3>Description</h3>

<p>Iterative algorithm to estimate Duembgen's shape matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duembgen.shape(X, init = NULL, steps = Inf, eps = 1e-06, 
               maxiter = 100, in.R = FALSE, na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duembgen.shape_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_init">init</code></td>
<td>
<p>an optional matrix giving the starting value for the iteration. Otherwise the regular covariance is used after transforming it to a shape matrix wit determinant 1.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_steps">steps</code></td>
<td>
<p>a fixed number of iteration steps to take. See details.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_eps">eps</code></td>
<td>
<p> convergence tolerance.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_in.r">in.R</code></td>
<td>
<p>logical. If TRUE R-code (and not C) is used in the iteration</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
<tr><td><code id="duembgen.shape_+3A_...">...</code></td>
<td>
<p> other arguments passed on to  <code><a href="#topic+tyler.shape">tyler.shape</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Duembgen's shape matrix can be seen as <code><a href="#topic+tyler.shape">tyler.shape</a></code>'s matrix wrt to the origin for the pairwise differences of the observations.
Therefore this shape matrix needs no location parameter.
</p>
<p>The function is, however, slow if the dataset is large.
</p>
<p>The algorithm also allows for a k-step version where the iteration is run for a fixed number of steps instead of until convergence. If <code>steps</code> is finite that number of steps is taken and <code>maxiter</code> is ignored.
</p>
<p>A better implementation is available in the package fastM as the function <code>DUEMBGENshape</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen, Seija Sirkia, and some of the C++ is based on work by Jari Miettinen</p>


<h3>References</h3>

<p><cite>Duembgen, L. (1998), On Tyler's M-functional of scatter in high dimension, <em>Annals of Institute of Statistical Mathematics</em>, <b>50</b>,  471&ndash;491. </cite>  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+tyler.shape">tyler.shape</a></code>, <code><a href="#topic+duembgen.shape.wt">duembgen.shape.wt</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
cov.matrix/det(cov.matrix)^(1/3)
duembgen.shape(X)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='duembgen.shape.wt'> Weighted Duembgen's Shape Matrix</h2><span id='topic+duembgen.shape.wt'></span>

<h3>Description</h3>

<p>Iterative algorithm to estimate the weighted version of Duembgen's shape matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>duembgen.shape.wt(X, wt = rep(1, nrow(X)), init = NULL, 
                  eps = 1e-06, maxiter = 100, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duembgen.shape.wt_+3A_x">X</code></td>
<td>
<p> numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="duembgen.shape.wt_+3A_wt">wt</code></td>
<td>
<p>vector of weights. Should be nonnegative and at least one larger than zero.</p>
</td></tr>
<tr><td><code id="duembgen.shape.wt_+3A_init">init</code></td>
<td>
<p>an optional matrix giving the starting value for the iteration.</p>
</td></tr>
<tr><td><code id="duembgen.shape.wt_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="duembgen.shape.wt_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="duembgen.shape.wt_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted Duembgen shape matrix can be seen as <code><a href="#topic+tyler.shape">tyler.shape</a></code>'s matrix wrt to the origin for the weighted pairwise differences of the observations.
Therefore this shape matrix needs no location parameter.
</p>
<p>Note that this function is memory comsuming and slow for large data sets since the matrix is based on all pairwise difference of the observations.
</p>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Sirkia, S., Taskinen, S. and Oja, H. (2007), Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, <b>98</b>, 1611&ndash;1629. </cite> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+duembgen.shape">duembgen.shape</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
cov.matrix.1 &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol = 3)
X.1 &lt;- rmvnorm(100, c(0,0,0), cov.matrix.1)
cov.matrix.2 &lt;- diag(1,3)
X.2 &lt;- rmvnorm(50, c(1,1,1), cov.matrix.2)
X &lt;- rbind(X.1, X.2)

D1 &lt;-  duembgen.shape.wt(X, rep(c(0,1), c(100,50)))
D2 &lt;-  duembgen.shape.wt(X, rep(c(1,0), c(100,50)))

D1
D2

rm(.Random.seed)
</code></pre>

<hr>
<h2 id='hl.loc'> Hodges - Lehmann Estimator of Location</h2><span id='topic+hl.loc'></span>

<h3>Description</h3>

<p>Function to compute the Hodges - Lehmann estimator of location in the one sample case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hl.loc(x, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hl.loc_+3A_x">x</code></td>
<td>
<p> a numeric vector.</p>
</td></tr>
<tr><td><code id="hl.loc_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Hodges - Lehmann estimator is the median of the combined data points and Walsh averages.
It is the same as the Pseudo Median returned as a by-product of the function <code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>.
</p>


<h3>Value</h3>

<p>the Hodges - Lehmann estimator of location.
</p>


<h3>Author(s)</h3>

<p> Klaus Nordhausen </p>


<h3>References</h3>

 <p><cite>Hettmansperger, T.P. and McKean, J.W. (1998), <em>Robust Nonparametric Statistical Methods</em>,
London, Arnold. </cite>
</p>
<p><cite>Hodges, J.L., and Lehmann, E.L. (1963), Estimates of location based on rank tests. <em>The Annals of Mathematical Statistics</em>, <b>34</b>, 598&ndash;611. </cite>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rt(100, df = 3)
hl.loc(x)
# same as
wilcox.test(x,  conf.int = TRUE)$estimate
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='HotellingsT2'>Hotelling's T2 Test</h2><span id='topic+HotellingsT2'></span><span id='topic+HotellingsT2.default'></span><span id='topic+HotellingsT2.formula'></span>

<h3>Description</h3>

<p>Hotelling's T2 test for the one and two sample case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> HotellingsT2(X, ...)

## Default S3 method:
HotellingsT2(X, Y = NULL, mu = NULL, test = "f",
             na.action = na.fail, ...)

## S3 method for class 'formula'
HotellingsT2(formula, na.action = na.fail, ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HotellingsT2_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_y">Y</code></td>
<td>
<p>an optional numeric data frame or matrix for the two sample test. If NULL a one sample test is performed.</p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_mu">mu</code></td>
<td>
<p>a vector indicating the hypothesized value of the mean (or difference
in means if a two sample test is performed). NULL represents origin or no difference between the groups. </p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_test">test</code></td>
<td>
<p>if 'f', the decision is based on the F-distribution, if 'chi' a chi-squared approximation is used. </p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>X ~ g</code> where <code>X</code>
is a numeric matrix giving the data values and <code>g</code> a factor
with two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's. Default is to fail. </p>
</td></tr>
<tr><td><code id="HotellingsT2_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The classical test for testing the location of a multivariate population or for testing the mean
difference for two multivariate populations. When <code>test = "f"</code> the F-distribution is used for
the test statistic and it is assumed that the data are normally distributed. If the chisquare
approximation is used, the normal assumption can be relaxed to existence of second moments.
In the two sample case both populations are assumed to have the same covariance matrix.
</p>
<p>The formula interface is only applicable for the 2-sample tests.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the T2-statistic. (That is the scaled value of the statistic that has an 
F distribution or a chisquare distribution depending on the value of <code>test</code>).</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the T2-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean difference
depending on whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data (and grouping vector).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Anderson, T.W. (2003), <em>An introduction to
multivariate analysis</em>, New Jersey: Wiley. </cite>  </p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# one sample test:

data(pulmonary)

HotellingsT2(pulmonary) 
HotellingsT2(pulmonary, mu = c(0,0,2), test = "chi")

# two sample test:

set.seed(123456)
X &lt;- rmvnorm(20, c(0, 0, 0, 0), diag(1:4))
Y &lt;- rmvnorm(30, c(0.5, 0.5, 0.5, 0.5), diag(1:4))
Z &lt;- rbind(X, Y)
g &lt;- factor(rep(c(1,2),c(20,30)))

HotellingsT2(X, Y)
HotellingsT2(Z ~ g, mu = rep(-0.5,4))

rm(.Random.seed) </code></pre>

<hr>
<h2 id='HP.loc.test'>
Hallin and Paindaveine Signed-Rank Tests
</h2><span id='topic+HP.loc.test'></span>

<h3>Description</h3>

<p>This function implements the signed-rank location tests as suggested by Hallin and Paindaveine (2002a, 2002b).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HP.loc.test(X, mu = NULL, score = "rank", angles = "tyler", 
            method = "approximation", n.perm = 1000, 
            na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HP.loc.test_+3A_x">X</code></td>
<td>

<p>a numeric data frame or matrix.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_mu">mu</code></td>
<td>

<p>a vector indicating the hypothesized value of the location. NULL represents the origin.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_score">score</code></td>
<td>

<p>score for the pseudo mahalanobis distance. Options are 'rank', 'sign' and 'normal' scores.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_angles">angles</code></td>
<td>

<p>which angle to use. Possible are 'tyler' for spatial sign type anlges or 'interdirections'. Note however that currently only 'tyler' is implemented.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_method">method</code></td>
<td>

<p>defines the method used for the computation of the p-value. The possibilites are
'approximation' or 'permutation'.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_n.perm">n.perm</code></td>
<td>

<p>if <code>method="permutation"</code> specifies this the number of replications used in the permutation procedure.
</p>
</td></tr>
<tr><td><code id="HP.loc.test_+3A_na.action">na.action</code></td>
<td>

<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test based on interdirections is described in Hallin and Paindaveine (2002a) and the test based on Tyler's angles is described in Hallin and Paindaveine (2002b).
The two different tests are asymptotically equivalent and
in both cases is assumed that the data comes from an elliptic distribution.
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Q-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the Q-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the location.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen
</p>


<h3>References</h3>

<p><cite>Hallin, M. and Paindaveine, D. (2002a), Optimal tests for multivariate location based on interdirections and pseudo-Mahalanobis ranks, <em>Annals of Statistics</em>, <b>30</b>,  1103&ndash;1133. </cite> 
</p>
<p><cite>Hallin, M. and Paindaveine, D. (2002b), Randles' interdirections or Tyler's angles?, In Y. Dodge, Ed. <em>Statistical data analysis based on the L1-norm and related methods</em>,  271&ndash;282. </cite> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tyler.shape">tyler.shape</a></code>, <code><a href="#topic+spatial.sign">spatial.sign</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- rmvnorm(100, c(0,0,0.1)) 
HP.loc.test(X)
HP.loc.test(X, score="s")
HP.loc.test(X, score="n")
</code></pre>

<hr>
<h2 id='HP1.shape'> One Step Rank Scatter Estimator  </h2><span id='topic+HP1.shape'></span>

<h3>Description</h3>

<p>one step M-estimator of the scatter matrix based on ranks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HP1.shape(X, location = "Estimate", na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HP1.shape_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix. </p>
</td></tr>
<tr><td><code id="HP1.shape_+3A_location">location</code></td>
<td>
<p> if 'Estimate' the location and scatter matrix used for computing the spatial signs are estimated simultaneously using <code><a href="#topic+HR.Mest">HR.Mest</a></code>,
if 'Origin' or numeric <code><a href="#topic+tyler.shape">tyler.shape</a></code> is used with respect to origin or the given value, respectively, to obtain the spatial signs.   </p>
</td></tr>
<tr><td><code id="HP1.shape_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
<tr><td><code id="HP1.shape_+3A_...">...</code></td>
<td>
<p> arguments that can be passed on to <code><a href="#topic+tyler.shape">tyler.shape</a></code> or <code><a href="#topic+HR.Mest">HR.Mest</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a one step M-estimator of shape which is standardized in such a way that the determinant is 1.
</p>
<p>The exact formula is:
</p>
<p style="text-align: center;"><code class="reqn">V = V_{0}^{\frac{1}{2}} ave\{a(\frac{R_{i}}{n+1})u_{i}'u_{i} \} V_{0}^{\frac{1}{2}}.</code>
</p>

<p>where <code class="reqn">V_{0}</code> is Tyler's shape matrix, <code class="reqn">u_{i}=||z_{i}||^{-1} z_{i}</code> is the spatial sign of <code class="reqn">z_{i}=(x_{i}-\mu) V_{0}^{-\frac{1}{2}}</code>
and <code class="reqn">R_{i}</code>
gives the rank of <code class="reqn">||z_{i}||</code> among <code class="reqn">||z_{1}||,\ldots,||z_{n}||</code>. The van der Warden score function <code class="reqn">a(.)</code> is the inverse of the cdf of a chi-squared distribution with p degrees of freedom.
</p>
<p>This scatter matrix is based on the test for shape developed in the paper by Hallin and Paindaveine (2006), its usage with respect to the origin is demonstrated in Nordhausen et al. (2006).
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Hallin, M. and Paindaveine, D. (2006), Semiparametrically efficient rank-based inference for shape. I. Optimal rank-based tests for sphericity, <em>Annals of Statistics</em>, <b>34</b>,  2707&ndash;2756. </cite>
</p>
<p><cite>Nordhausen, K., Oja, H. and Paindaveine, D. (2009), Signed-rank tests for location in the symmetric independent component model, <em>Journal of Multivariate Analysis</em>, <b>100</b>,  821&ndash;834. </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
HP1.shape(X)
HP1.shape(X, location="Origin")
cov.matrix/det(cov.matrix)^(1/3)
rm(.Random.seed)
         </code></pre>

<hr>
<h2 id='HR.Mest'>Simultaneous
Affine Equivariant Estimation of Multivariate Median and Tyler's Shape
Matrix</h2><span id='topic+HR.Mest'></span>

<h3>Description</h3>

<p>iterative algorithm that finds the affine equivariant multivariate median by estimating <code><a href="#topic+tyler.shape">tyler.shape</a></code> simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HR.Mest(X, maxiter = 100, eps.scale = 1e-06, eps.center = 1e-06,
        na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HR.Mest_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix.  </p>
</td></tr>
<tr><td><code id="HR.Mest_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations. </p>
</td></tr>
<tr><td><code id="HR.Mest_+3A_eps.scale">eps.scale</code></td>
<td>
<p>convergence tolerance for the Tyler's shape matrix subroutine.</p>
</td></tr>
<tr><td><code id="HR.Mest_+3A_eps.center">eps.center</code></td>
<td>
<p>convergence tolerance for the location estimate.</p>
</td></tr>
<tr><td><code id="HR.Mest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm follows the idea of Hettmansperger and Randles (2002). There are, however, some differences. This algorithm
has the vector of marginal medians as starting point for the location and the starting shape matrix is Tyler's shape
matrix based on the vector of marginal medians and has then a location step and a shape step which are:
</p>

<dl>
<dt>location step k+1:</dt><dd><p>transforming the data as <code class="reqn">y=x V_{k}^{-\frac{1}{2}}</code> and
computing the spatial median <code class="reqn">\mu_y</code> of y using the function <code>spatial.median</code>. Then
retransforming <code class="reqn">\mu_y</code> to the original scale <code class="reqn">\mu_{x,k+1}=\mu_y V_{k}^{\frac{1}{2}} </code>.
</p>
</dd>
<dt>shape step k+1:</dt><dd><p>computing Tyler's shape matrix  <code class="reqn">V_{k+1}</code> with respect to <code class="reqn">\mu_{x,k+1}</code> by using the function <code>tyler.shape</code>.</p>
</dd>
</dl>

<p>The algorithm stops when the difference between two subsequent location estimates is smaller than <code>eps.center</code>.
</p>
<p>There is no proof that the algorithm converges.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>center</code></td>
<td>
<p>vector with the estimated loaction.</p>
</td></tr>
<tr><td><code>scatter</code></td>
<td>
<p>matrix of the estimated scatter.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen and Seija Sirkia</p>


<h3>References</h3>

<p><cite>Hettmansperger, T.P. and Randles, R.H. (2002), A practical affine equivariant multivariate median, <em>Biometrika</em>, <b>89</b>,  851&ndash;860. </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
res &lt;- HR.Mest(X)
colMeans(X)
res$center
cov.matrix/det(cov.matrix)^(1/3)
res$scatter
rm(.Random.seed)
         </code></pre>

<hr>
<h2 id='ICSNP-package'>
Tools for Multivariate Nonparametrics
</h2><span id='topic+ICSNP-package'></span><span id='topic+ICSNP'></span>

<h3>Description</h3>

<p>Tools for multivariate nonparametrics, as location tests based on marginal ranks, spatial median and spatial signs computation, Hotelling's T-test, estimates of shape are implemented.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ICSNP</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Tools for Multivariate Nonparametrics</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-09-18</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> 
    c(person("Klaus", "Nordhausen", 
             email = "klausnordhausenR@gmail.com",
             role = c("aut", "cre"),
             comment = c(ORCID = "0000-0002-3758-8501")),
      person("Seija", "Sirkia", 
             role = c("aut")),
      person("Hannu", "Oja", 
             role = c("aut"),
             comment = c(ORCID = "0000-0002-4945-5976")),
      person("David E.", "Tyler", 
             role = c("aut")))</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> 
    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Seija Sirkia [aut], 
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    David E. Tyler [aut]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> mvtnorm, ICS</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Tools for multivariate nonparametrics, as location tests based on marginal ranks, spatial median and spatial signs computation, Hotelling's T-test, estimates of shape are implemented.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Archs: </td><td style="text-align: left;"> x64</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package contains tools for nonparametric multivariate analysis, including the estimation of location and shape as well as some tests for location and independece.
Shape matrices from this package can be used as one of the scatter matrices needed in the package <code><a href="ICS.html#topic+ICS-package">ICS</a></code> whereas the tests of this package
can be used for testing in the framework of invariant coordinates or independent components obtained from the package <code><a href="ICS.html#topic+ICS-package">ICS</a></code>.
The parametric Hotelling's T test serves as a reference for the nonparametric location tests.
</p>

<p>Index of help topics:
</p>
<pre>
HP.loc.test             Hallin and Paindaveine Signed-Rank Tests
HP1.shape               One Step Rank Scatter Estimator
HR.Mest                 Simultaneous Affine Equivariant Estimation of
                        Multivariate Median and Tyler's Shape Matrix
HotellingsT2            Hotelling's T2 Test
ICSNP-package           Tools for Multivariate Nonparametrics
LASERI                  Cardiovascular Responses to Head-up Tilt
duembgen.shape          Duembgen's Shape Matrix
duembgen.shape.wt       Weighted Duembgen's Shape Matrix
hl.loc                  Hodges - Lehmann Estimator of Location
ind.ctest               Test of Independece based on Marginal Ranks
ind.ictest              Test of Independence based on Marginal Ranks in
                        a Symmetric IC Model
pair.diff               Pairwise Differences
pair.prod               Pairwise Products
pair.sum                Pairwise Sums
pulmonary               Change in Pulmonary Response after Exposure to
                        Cotton Dust
rank.ctest              One, Two and C Sample Rank Tests for Location
                        based on Marginal Ranks
rank.ictest             One Sample Location Test based on Marginal
                        Ranks in the Independent Component Model
spatial.median          Spatial Median
spatial.sign            Spatial Signs
symm.huber              Symmetrized Huber Scatter Matrix
symm.huber.wt           Weighted Symmetrized Huber Scatter Matrix
tyler.shape             Tyler's Shape Matrix
vdw.loc                 Van der Waerden Estimator of Location
</pre>


<h3>Author(s)</h3>


<p>    Klaus Nordhausen [aut, cre] (&lt;https://orcid.org/0000-0002-3758-8501&gt;),
    Seija Sirkia [aut], 
    Hannu Oja [aut] (&lt;https://orcid.org/0000-0002-4945-5976&gt;),
    David E. Tyler [aut]
</p>
<p>Maintainer: Klaus Nordhausen &lt;klausnordhausenR@gmail.com&gt;
</p>


<h3>See Also</h3>

<p><code><a href="ICS.html#topic+ICS-package">ICS</a></code>
</p>

<hr>
<h2 id='ind.ctest'>Test of Independece based on Marginal Ranks</h2><span id='topic+ind.ctest'></span>

<h3>Description</h3>

<p>Performs the test that a group of variables is independent of an other based on marginal ranks. Three different score functions are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.ctest(X, index1, index2 = NULL, scores = "rank", 
          na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.ctest_+3A_x">X</code></td>
<td>
<p>a data frame or matrix. </p>
</td></tr>
<tr><td><code id="ind.ctest_+3A_index1">index1</code></td>
<td>
<p>integer vector that selects the columns of <code>X</code> that form group one. Only numeric columns can be selected. </p>
</td></tr>
<tr><td><code id="ind.ctest_+3A_index2">index2</code></td>
<td>
<p>integer vector that selects the columns of <code>X</code> that form group two. Only numeric columns can be selected.
If <code>NULL</code>, all remaining columns of X will be selected.</p>
</td></tr>
<tr><td><code id="ind.ctest_+3A_scores">scores</code></td>
<td>
<p>if 'sign', a sign test is performed, if 'rank' a rank test is performed or if 'normal'
a normal score test is performed.</p>
</td></tr>
<tr><td><code id="ind.ctest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test tests if X[ , index1] is independent of X[ , index2] and is described in great detail in Puri and Sen (1971).
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the W-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the W-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

<p><cite>Puri , M.L. and Sen, P.K. (1971), <em>Nonparametric Methods in Multivariate Analysis</em>, New York: Wiley.   </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>A1 &lt;- matrix(c(4, 4, 5, 4, 6, 6, 5, 6, 7), ncol = 3)
A2 &lt;- matrix(c(0.5, -0.3, -0.3, 0.7), ncol = 2)
X &lt;- cbind(rmvnorm(100, c(-1, 0, 1), A1), rmvnorm(100, c(0, 0), A2))
ind.ctest(X,1:3)
ind.ctest(X, c(1, 5), c(2, 3), scores = "normal")
</code></pre>

<hr>
<h2 id='ind.ictest'>Test of Independence based on Marginal Ranks in a Symmetric IC Model</h2><span id='topic+ind.ictest'></span>

<h3>Description</h3>

<p>Performs the test that a group of variables is independent of an other based on marginal ranks. It is assumed that the 
data follows a symmetric IC model. Three different score functions are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ind.ictest(X, index1, index2 = NULL, scores = "rank", 
           method = "approximation", n.simu = 1000, 
           ..., na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ind.ictest_+3A_x">X</code></td>
<td>
<p>a data frame or matrix.</p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_index1">index1</code></td>
<td>
<p>integer vector that selects the columns of <code>X</code> that form group one. Only numeric columns can be selected. </p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_index2">index2</code></td>
<td>
<p>integer vector that selects the columns of <code>X</code> that form group two. Only numeric columns can be selected.
If <code>NULL</code>, all remaining columns of X will be selected.</p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_scores">scores</code></td>
<td>
<p>if 'sign', a sign test is performed, if 'rank' a signed rank test is performed or if 'normal'
a normal score test is performed.</p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_method">method</code></td>
<td>
<p> defines the method used for the computation of the p-value. The possobilites are
&quot;approximation&quot; (default), &quot;simulation&quot; or &quot;permutation&quot;. Details below.</p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_n.simu">n.simu</code></td>
<td>
<p>if '<code>method</code> = &quot;simulation&quot;' or '<code>method</code> = &quot;permutation&quot;' this specifies the number of replications used in the
simulation or permutation procedure. </p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the function <code><a href="ICS.html#topic+ics">ics</a></code></p>
</td></tr>
<tr><td><code id="ind.ictest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumed is here that <code>X[ , index1]</code> comes from a symmetric independent component model which in turn is independent from <code>X[ , index2]</code> which has also
an underlying symmetric independent component model. This function recovers the independent components using the function <code><a href="ICS.html#topic+ics">ics</a></code>, centers them by a marginal
loaction estimate based on the same scores that will be used in the actual test. The test is described in Oja, Paindaveine and Taskinen (2009). 
The asymptotic chi-square distibution is however even for large sample sizes inadequat and therefore p-values can be simulated by resampling the test statistic under the null
hypothesis or by permuting the rows of the independent components of <code>X[ , index2]</code>. Both alternatives are also described in Oja, Paindaveine and Taskinen (2009).
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Q-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the Q-statistic or the number of replications depending on the chosen method.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Oja, H. and Paindaveine, D. and Taskinen, S. (2016), Affine-invariant rank tests for multivariate independence in independent component models, <em>Electronic Journal of Statistics</em>, <b>10</b>,  2372&ndash;2419. </cite>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>Z1&lt;-cbind(rt(500,5),rnorm(500),runif(500))
Z2&lt;-cbind(rt(500,8),rbeta(500,2,2))
A1 &lt;- matrix(c(4, 4, 5, 4, 6, 6, 5, 6, 7), ncol = 3)
A2 &lt;- matrix(c(0.5, -0.3, -0.3, 0.7), ncol = 2)

X &lt;- cbind(Z1 %*% t(A1), Z2 %*% t(A2))

ind.ictest(X,1:3)
ind.ictest(X,1:3,method="simu")

ind.ictest(X,1:2,3:5,method="perm", S1=tyler.shape,S2=cov)

</code></pre>

<hr>
<h2 id='LASERI'>
Cardiovascular Responses to Head-up Tilt
</h2><span id='topic+LASERI'></span>

<h3>Description</h3>

<p>This data set contains the cardiovascular responses to a passive head-up tilt for 223 subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LASERI)</code></pre>


<h3>Format</h3>

<p>A data frame with 223 observations on the following 32 variables.
</p>

<dl>
<dt><code>Sex</code></dt><dd><p>a factor with levels <code>Female</code> and <code>Male</code>.</p>
</dd>
<dt><code>Age</code></dt><dd><p>Age in years.</p>
</dd>
<dt><code>Height</code></dt><dd><p>Height in cm.</p>
</dd>
<dt><code>Weight</code></dt><dd><p>Weight in kg.</p>
</dd>
<dt><code>Waist</code></dt><dd><p>Waist circumference in cm.</p>
</dd>
<dt><code>Hip</code></dt><dd><p>Hip circumference in cm.</p>
</dd>
<dt><code>BMI</code></dt><dd><p>Body mass index.</p>
</dd>
<dt><code>WHR</code></dt><dd><p>Waist hip ratio.</p>
</dd>
<dt><code>HRT1</code></dt><dd><p>Average heart rate in the tenth minute of rest.</p>
</dd>
<dt><code>HRT2</code></dt><dd><p>Average heart rate in the second minute during the tilt.</p>
</dd>
<dt><code>HRT3</code></dt><dd><p>Average heart rate in the fifth minute during the tilt.</p>
</dd>
<dt><code>HRT4</code></dt><dd><p>Average heart rate in the fifth minute after the tilt.</p>
</dd>
<dt><code>COT1</code></dt><dd><p>Average cardiac output in the tenth minute of rest.</p>
</dd>
<dt><code>COT2</code></dt><dd><p>Average cardiac output in the second minute during the tilt.</p>
</dd>
<dt><code>COT3</code></dt><dd><p>Average cardiac output in the fifth minute during the tilt.</p>
</dd>
<dt><code>COT4</code></dt><dd><p>Average cardiac output in the fifth minute after the tilt.</p>
</dd>
<dt><code>SVRIT1</code></dt><dd><p>Average systemic vascular resistance index in the tenth minute of rest.</p>
</dd>
<dt><code>SVRIT2</code></dt><dd><p>Average systemic vascular resistance index in the second minute during the tilt.</p>
</dd>
<dt><code>SVRIT3</code></dt><dd><p>Average systemic vascular resistance index in the fifth minute during the tilt.</p>
</dd>
<dt><code>SVRIT4</code></dt><dd><p>Average systemic vascular resistance index in the fifth minute after the tilt.</p>
</dd>
<dt><code>PWVT1</code></dt><dd><p>Average pulse wave velocity in the tenth minute of rest.</p>
</dd>
<dt><code>PWVT2</code></dt><dd><p>Average pulse wave velocity in the second minute during the tilt.</p>
</dd>
<dt><code>PWVT3</code></dt><dd><p>Average pulse wave velocity in the fifth minute during the tilt.</p>
</dd>
<dt><code>PWVT4</code></dt><dd><p>Average pulse wave velocity in the fifth minute after the tilt.</p>
</dd>
<dt><code>HRT1T2</code></dt><dd><p>Difference <code>HRT1</code> - <code>HRT2</code>.</p>
</dd>
<dt><code>COT1T2</code></dt><dd><p>Difference <code>COT1</code> - <code>COT2</code>.</p>
</dd>
<dt><code>SVRIT1T2</code></dt><dd><p>Difference <code>SVRIT1</code> - <code>SVRIT2</code>.</p>
</dd>
<dt><code>PWVT1T2</code></dt><dd><p>Difference <code>PWVT1</code> - <code>PWVT2</code>.</p>
</dd>
<dt><code>HRT1T4</code></dt><dd><p>Difference <code>HRT1</code> - <code>HRT4</code>.</p>
</dd>
<dt><code>COT1T4</code></dt><dd><p>Difference <code>COT1</code> - <code>COT4</code>.</p>
</dd>
<dt><code>SVRIT1T4</code></dt><dd><p>Difference <code>SVRIT1</code> - <code>SVRIT4</code>.</p>
</dd>
<dt><code>PWVT1T4</code></dt><dd><p>Difference <code>PWVT1</code> - <code>PWVT4</code>.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data is a subset of hemodynamic data collected as a part of the LASERI
study (English title: &ldquo;Cardivascular risk in young Finns study&rdquo;) using
whole-body impedance cardiography and plethysmographic blood pressure
recordings from fingers. The data given here comes from 223 healthy subjects
between 26 and 42 years of age, who participated in the recording of the
hemodynamic variables both in a supine position and during a passive head-up
tilt on a motorized table. During that experiment the subject spent the
first ten minutes in a supine position, then the motorized table was tilted
to a head-up position (60 degrees) for five minutes, and for the last five
minutes the table was again returned to the supine position.
</p>
<p>Of interest in this data is for example if the values 5 minutes after the
tilt are already returned to their pre-tilt levels.
</p>


<h3>Source</h3>

<p>Data courtesy of the LASERI study <br /> (<a href="https://youngfinnsstudy.utu.fi/">https://youngfinnsstudy.utu.fi/</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for example testing if the location before the tilt is the same as 
# 5 minutes after the tilt:
data(LASERI)
DIFFS.T1T4 &lt;- subset(LASERI,select=c(HRT1T4,COT1T4,SVRIT1T4))
rank.ctest(DIFFS.T1T4)
rank.ctest(DIFFS.T1T4, score="s")
</code></pre>

<hr>
<h2 id='pair.diff'>Pairwise Differences</h2><span id='topic+pair.diff'></span>

<h3>Description</h3>

<p>Computes pairwise differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.diff(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.diff_+3A_x">X</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes all differences of row i and row j with i &lt; j. The function is a wrapper to a C function to do the computation quickly and does no checks concerning the input.
</p>


<h3>Value</h3>

<p>Matrix containing the differences.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.prod">pair.prod</a></code>, <code><a href="#topic+pair.sum">pair.sum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:10, ncol = 2, byrow = FALSE)
pair.diff(X)
</code></pre>

<hr>
<h2 id='pair.prod'> Pairwise Products </h2><span id='topic+pair.prod'></span>

<h3>Description</h3>

<p>Computes pairwise elementwise products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.prod(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.prod_+3A_x">X</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes all elementwise products of row i and row j with i &lt; j. The function is a wrapper to a C function to do the computation quickly and does no checks concerning the input. 
</p>


<h3>Value</h3>

<p>Matrix containing the products.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.diff">pair.diff</a></code>, <code><a href="#topic+pair.sum">pair.sum</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:10, ncol = 2, byrow = FALSE)
pair.prod(X)
</code></pre>

<hr>
<h2 id='pair.sum'>Pairwise Sums</h2><span id='topic+pair.sum'></span>

<h3>Description</h3>

<p>Computes pairwise sums.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pair.sum(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pair.sum_+3A_x">X</code></td>
<td>
<p>a numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes all sums of row i and row j with i &lt; j. The function is a wrapper to a C function to do the computation quickly and does no checks concerning the input. 
</p>


<h3>Value</h3>

<p>Matrix containing the sums.
</p>


<h3>Author(s)</h3>

<p>Seija Sirkia</p>


<h3>See Also</h3>

<p><code><a href="#topic+pair.diff">pair.diff</a></code>, <code><a href="#topic+pair.prod">pair.prod</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- matrix(1:10, ncol = 2, byrow = FALSE)
pair.sum(X)
</code></pre>

<hr>
<h2 id='pulmonary'> Change in Pulmonary Response after Exposure to Cotton Dust</h2><span id='topic+pulmonary'></span>

<h3>Description</h3>

<p>Changes in pulmonary function of 12 workers after 6 hours of exposure to cotton dust. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pulmonary)</code></pre>


<h3>Format</h3>

<p>A data frame with 12 observations on the following 3 variables.
</p>

<dl>
<dt><code>FVC</code></dt><dd><p>change in FVC (forced vital capacity) after 6 hours.</p>
</dd>
<dt><code>FEV</code></dt><dd><p>change in FEV_3 (forced expiratory volume) after 6 hours.</p>
</dd>
<dt><code>CC</code></dt><dd><p>change in CC (closing capacity) after 6 hours.</p>
</dd>
</dl>



<h3>Note</h3>

<p>There is also a different version of this data set around. In the different version the FVC value of subject 11 is -0.01 instead of -0.10.
</p>


<h3>Source</h3>

<p><cite>Merchant, J. A., Halprin, G. M., Hudson, A. R. Kilburn, K. H., McKenzie, W. N., Hurst, D. J. and Bermazohnm P. (1975), 
Responses to cotton dust, <em>Archives of Environmental Health</em>, <b>30</b>,  222&ndash;229, Table 5. </cite> 
</p>
<p>Reprinted with permission of the Helen Dwight Reid Educational Foundation.  
Published by Heldref Publications, 1319 Eighteenth St., NW, Washington, DC 20036-1802. 
</p>


<h3>References</h3>

<p><cite>Hettmansperger, T. P. and McKean, J. W. (1998), <em>Robust Nonparametric Statistical Methods</em>, London: Arnold.  </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pulmonary)
plot(pulmonary)
</code></pre>

<hr>
<h2 id='rank.ctest'> One, Two and C Sample Rank Tests for Location based on Marginal Ranks </h2><span id='topic+rank.ctest'></span><span id='topic+rank.ctest.default'></span><span id='topic+rank.ctest.formula'></span><span id='topic+rank.ctest.ics'></span>

<h3>Description</h3>

<p>Performs the one, two or c sample location test based on marginal ranks. Three different score functions are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.ctest(X, ...)

## Default S3 method:
rank.ctest(X, Y = NULL, mu = NULL, scores = "rank", 
           na.action = na.fail, ...)

## S3 method for class 'formula'
rank.ctest(formula, na.action = na.fail, ...)

## S3 method for class 'ics'
rank.ctest(X, g = NULL, index = NULL, na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.ctest_+3A_x">X</code></td>
<td>
<p>a numeric data frame or matrix or an ics object. </p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_y">Y</code></td>
<td>
<p>an optional numeric data frame or matrix for the two sample test. If NULL a one sample test is performed.</p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_mu">mu</code></td>
<td>
<p>a vector indicating the hypothesized value of the mean (or difference
in means if you are performing a two sample test). NULL represents origin or no difference between the groups.
For more than two groups <code>mu</code> should be 0 or not be specified at all.</p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_scores">scores</code></td>
<td>
<p> if 'sign', a sign test is performed, if 'rank' a signed rank test is performed or if 'normal'
a normal score test is performed. </p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>X ~ g</code> where <code>X</code>
is a numeric matrix giving the data values and <code>g</code> a factor
with at least two levels giving the corresponding groups.</p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_g">g</code></td>
<td>
<p>a grouping factor with at least two levels.</p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_index">index</code></td>
<td>
<p>an integer vector that gives the columns to choose the invariant coordinates form the 'ics' object. The default uses all columns.</p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_na.action">na.action</code></td>
<td>
<p>  a function which indicates what should happen when the data
contain 'NA's.  Default is to fail. </p>
</td></tr>
<tr><td><code id="rank.ctest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These tests are well described in Puri and Sen (1971). The tests are based on the marginal ranks for which three score functions are available. The scores are
also used to estimate the covariance matrices. In the multisample case it is assumed that the distribution of the different populations differs only in their location.
</p>
<p>The ics interface provides an invariant test based on the invariant coordinate selection. The assymptotic distribution is however still an open question
when more than one component is used, though the chi-square approximation works well also for several components as shown in Nordhausen, Oja and Tyler (2006).</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the T-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the T-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the mean or mean difference depending on whether it was a one-sample test or a two-sample test.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data (and grouping vector).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Puri , M.L. and Sen, P.K. (1971), <em>Nonparametric Methods in Multivariate Analysis</em>, New York: Wiley.  </cite>
</p>
<p><cite>Nordhausen, K., Oja, H. and Tyler, D.E. (2006), On the Efficiency of Invariant Multivariate Sign and Rank Tests, in 
<em>Festschrift of Tarmo Pukkila on his 60th Birthday</em>, 217&ndash;231.</cite></p>


<h3>Examples</h3>

<pre><code class='language-R'># one sample tests:

data(pulmonary)

rank.ctest(pulmonary, scores = "sign")
rank.ctest(pulmonary, mu = c(0,0,2))

# two sample tests:

set.seed(123456)
X &lt;- rmvnorm(20, c(0,0,0,0), diag(1:4))
Y &lt;- rmvnorm(30, c(0.5,0.5,0.5,0.5), diag(1:4))
Z &lt;- rbind(X,Y)
g &lt;- factor(rep(c(1,2), c(20,30)))

rank.ctest(X, Y, scores = "normal")
rank.ctest(Z~g, scores = "sign", mu = rep(-0.5,4))

# c sample test:

W &lt;- rmvnorm(30, c(0,0,0,0), diag(1:4))
Z2 &lt;- rbind(X,Y,W)
g2 &lt;- factor(rep(1:3, c(20,30,30)))

rank.ctest(Z2~g2, scores = "normal")

# in an invariant coordinate system

rank.ctest(ics(Z2,covOrigin, cov4, S2args=list(location =
           "Origin")), index = c(1,4), scores = "sign")

rank.ctest(ics(Z), g, index = 4)

rank.ctest(ics(Z2), g2, scores = "normal",index = 4)

rm(.Random.seed)
         </code></pre>

<hr>
<h2 id='rank.ictest'> One Sample Location Test based on Marginal Ranks in the Independent Component Model </h2><span id='topic+rank.ictest'></span><span id='topic+rank.ictest.default'></span><span id='topic+rank.ictest.ics'></span>

<h3>Description</h3>

<p>marginal rank test for the location problem in the one sample case when the margins are assumed independent.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank.ictest(X, ...)

## Default S3 method:
rank.ictest(X, mu = NULL, scores = "rank", method = "approximation",
            n.simu = 1000, na.action = na.fail, ...)

## S3 method for class 'ics'
rank.ictest(X, index = NULL, na.action = na.fail, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank.ictest_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix or an ics object.</p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_mu">mu</code></td>
<td>
<p> a vector indicating the hypothesized value of the location. NULL represents the origin.</p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_scores">scores</code></td>
<td>
<p> options are 'rank' for the signed rank test, 'sign' for the sign test and 'normal' for the normal score test. </p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_method">method</code></td>
<td>
<p>defines the method used for the computation of the p-value. The possibilites are
&quot;approximation&quot; (default), &quot;simulation&quot; or &quot;permutation&quot;. Details below.</p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_n.simu">n.simu</code></td>
<td>
<p>if '<code>method</code>=simulation' or '<code>method</code>=permutation' this specifies the number of replications used in the
simulation or permutation procedure. </p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_index">index</code></td>
<td>
<p>an integer vector that gives the columns to choose from invariant coordinates form the 'ics' object. The default uses all columns.</p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail. </p>
</td></tr>
<tr><td><code id="rank.ictest_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test is normally used to test for location in the symmetric independent component model.
</p>
<p>By default the limiting distribution is used to compute the p-values. However for moderate sample sizes (N=50) was observed in 
Nordhausen et al. (2009) that the normal score test can be sometimes slightly biased. Therefore the argument <code>method</code>
can be used to get p-values based on simulations from a multivariate normal under the null or by permuting the signs of the centered
observations.  
</p>


<h3>Value</h3>

<p>A list with class 'htest' containing the following components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Q-statistic.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the degrees of freedom for the Q-statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the specified hypothesized value of the location.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>a character string with the value 'two.sided'.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name of the data.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Nordhausen, K., Oja, H. and Paindaveine, D. (2009), Signed-rank tests for location in the symmetric independent component model, <em>Journal of Multivariate Analysis</em>, <b>100</b>,  821&ndash;834. </cite>  </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(555)
X &lt;- cbind(rt(30,8), rnorm(30,0.5), runif(30,-3,3))
mix.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X.mixed &lt;- X %*% t(mix.matrix)
ica.X &lt;- ics(X, covOrigin, cov4, S2args = list(location = "Origin"))
rank.ictest(ica.X)
rank.ictest(ica.X, scores = "normal", method = "simu")
rank.ictest(ics.components(ica.X), scores = "normal", method = "perm")
rm(.Random.seed)
         </code></pre>

<hr>
<h2 id='spatial.median'> Spatial Median </h2><span id='topic+spatial.median'></span>

<h3>Description</h3>

<p>iterative algorithm to compute the spatial median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'> 
spatial.median(X, init = NULL, maxiter = 500, eps = 1e-06, 
               print.it = FALSE, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.median_+3A_x">X</code></td>
<td>
<p>a numeric data frame or data matrix.  </p>
</td></tr>
<tr><td><code id="spatial.median_+3A_init">init</code></td>
<td>
<p> Starting value for the alogrihtm, if 'NULL', the vector of marginal medians is used. </p>
</td></tr>
<tr><td><code id="spatial.median_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations.  </p>
</td></tr>
<tr><td><code id="spatial.median_+3A_eps">eps</code></td>
<td>
<p> convergence tolerance. </p>
</td></tr>
<tr><td><code id="spatial.median_+3A_print.it">print.it</code></td>
<td>
<p>logical. If TRUE prints the number of iterations, otherwise not.</p>
</td></tr>
<tr><td><code id="spatial.median_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Follows the algorithm of Vardi and Zhang.
</p>


<h3>Value</h3>

<p>vector of the spatial median.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen and Seija Sirkia</p>


<h3>References</h3>

<p><cite>Vardi, Y. and Zhang, C.-H. (1999), The multivariate L1-median and associated data depth, <em>PNAS</em>, <b>97</b>,  1423&ndash;1426. </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
spatial.median(X)
rm(.Random.seed)
         </code></pre>

<hr>
<h2 id='spatial.sign'>Spatial Signs </h2><span id='topic+spatial.sign'></span>

<h3>Description</h3>

<p>Function to obtain the spatial signs of a multivariate dataset. The function can compute the spatial signs also with respect to a given or estimated loacation and scale.
If both location and scale have to be estimated the <code><a href="#topic+HR.Mest">HR.Mest</a></code> function is used, if only one has to be estimated the, estimation is done using
<code><a href="#topic+spatial.median">spatial.median</a></code> or <code><a href="#topic+tyler.shape">tyler.shape</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.sign(X, center = TRUE, shape = TRUE, 
             na.action = na.fail, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.sign_+3A_x">X</code></td>
<td>
<p> a numeric data frame or matrix.   </p>
</td></tr>
<tr><td><code id="spatial.sign_+3A_center">center</code></td>
<td>
<p> either a logical value or a numeric vector of length equal to
the number of columns of 'X'. See below for more information. </p>
</td></tr>
<tr><td><code id="spatial.sign_+3A_shape">shape</code></td>
<td>
<p> either a logical value or a square numeric matrix with number of columns equal to
the number of columns of 'X'. See below for more information.</p>
</td></tr>
<tr><td><code id="spatial.sign_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
<tr><td><code id="spatial.sign_+3A_...">...</code></td>
<td>
<p> arguments that can be passed on to functions used for the estimation of location
and shape.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial signs U of X with location <code class="reqn">\mu</code> and shape V are given by
</p>
<p style="text-align: center;"><code class="reqn">u_{i}=\frac{(x_{i}-\mu)V^{-\frac{1}{2}}}{\| (x_{i}-\mu)V^{-\frac{1}{2}} \|}.</code>
</p>
 
<p>If a numeric value is given as 'center' and/or 'shape' these are used as <code class="reqn">\mu</code> and/or V in the above formula. 
If 'center' and/or 'shape' are 'TRUE' the values for <code class="reqn">\mu</code> and/or V are estimated, if 'FALSE' the origin is used as the 
value of <code class="reqn">\mu</code> and/or the identity matrix as the value of V.
</p>
<p>In the special case of univariate data the univariate signs of the data (centered if requested) are returned and the shape parameter is redundant.
</p>


<h3>Value</h3>

<p>a matrix with the spatial signs of the data as rows or the univariate signs as a px1 matrix. The
centering vector and scaling matrix used are returned as attributes
'center' and 'shape'.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen and Seija Sirkia</p>


<h3>See Also</h3>

  <p><code><a href="#topic+HR.Mest">HR.Mest</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(15, c(1,0,-1), cov.matrix)
spatial.sign(X)
spatial.sign(X, center=FALSE, shape=FALSE)
spatial.sign(X, center=colMeans(X), shape=cov(X))
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='symm.huber'> Symmetrized Huber Scatter Matrix</h2><span id='topic+symm.huber'></span>

<h3>Description</h3>

<p>Iterative algorithm to estimate the symmetrized Huber scatter matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm.huber(X, qg = 0.9, init = NULL, eps = 1e-06, maxiter = 100, 
           na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm.huber_+3A_x">X</code></td>
<td>
<p> numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="symm.huber_+3A_qg">qg</code></td>
<td>
<p>tuning parameter. Should be between 0 and 1. The default is 0.9.</p>
</td></tr>
<tr><td><code id="symm.huber_+3A_init">init</code></td>
<td>
<p>an optional matrix giving the starting value for the iteration.</p>
</td></tr>
<tr><td><code id="symm.huber_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="symm.huber_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="symm.huber_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The symmetrized Huber scatter matrix is the regular Huber scatter matrix for the pairwise differences of the observations taken wrt to the origin.
</p>
<p>Note that this function might be memory comsuming and slow for large data sets since the matrix is based on all pairwise difference of the observations.
</p>
<p>The function <code>symmhuber</code> in the package <span class="pkg">SpatialNP</span> offers also a k-step option. The <span class="pkg">SpatialNP</span> package contains also the function <code>mvhuberM</code> for the regular multivariate Huber location
and scatter estimatior.
</p>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen and Jari Miettinen</p>


<h3>References</h3>

 <p><cite>Sirkia, S., Taskinen, S. and Oja, H. (2007), Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, <b>98</b>, 1611&ndash;1629. </cite> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+symm.huber.wt">symm.huber.wt</a></code>, <code>symmhuber</code>, <code>mvhuberM</code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
symm.huber(X)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='symm.huber.wt'> Weighted Symmetrized Huber Scatter Matrix </h2><span id='topic+symm.huber.wt'></span>

<h3>Description</h3>

<p>Iterative algorithm to estimate the weighted symmetrized Huber scatter matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symm.huber.wt(X, wt = rep(1, nrow(X)), qg = 0.9, init = NULL, 
              eps = 1e-06, maxiter = 100, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="symm.huber.wt_+3A_x">X</code></td>
<td>
<p> numeric data frame or matrix.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_wt">wt</code></td>
<td>
<p>vector of weights. Should be nonnegative and at least one larger than zero.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_qg">qg</code></td>
<td>
<p>tuning parameter. Should be between 0 and 1. The default is 0.9.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_init">init</code></td>
<td>
<p>an optional matrix giving the starting value for the iteration.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="symm.huber.wt_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The weighted symmetrized Huber scatter matrix is the regular Huber scatter matrix for the weighted pairwise differences of the observations taken wrt to the origin.
</p>
<p>Note that this function is memory comsuming and slow for large data sets since the matrix is based on all pairwise difference of the observations.
</p>


<h3>Value</h3>

<p>a matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Sirkia, S., Taskinen, S. and Oja, H. (2007), Symmetrised M-estimators of scatter. <em>Journal of Multivariate Analysis</em>, <b>98</b>, 1611&ndash;1629. </cite> </p>


<h3>See Also</h3>

 <p><code><a href="#topic+symm.huber">symm.huber</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
cov.matrix.1 &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol = 3)
X.1 &lt;- rmvnorm(100, c(0,0,0), cov.matrix.1)
cov.matrix.2 &lt;- diag(1,3)
X.2 &lt;- rmvnorm(50, c(1,1,1), cov.matrix.2)
X &lt;- rbind(X.1, X.2)

D1 &lt;-  symm.huber.wt(X, rep(c(0,1), c(100,50)))
D2 &lt;-  symm.huber.wt(X, rep(c(1,0), c(100,50)))

D1
D2

rm(.Random.seed)
</code></pre>

<hr>
<h2 id='tyler.shape'> Tyler's Shape Matrix</h2><span id='topic+tyler.shape'></span>

<h3>Description</h3>

<p>Iterative algorithm to estimate Tyler's shape matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tyler.shape(X, location = NULL, init = NULL, steps = Inf, eps = 1e-06, 
            maxiter = 100, in.R = FALSE, print.it = FALSE, 
            na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tyler.shape_+3A_x">X</code></td>
<td>
<p>numeric data matrix or dataframe.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_location">location</code></td>
<td>
<p>if NULL the sample mean is used, otherwise a vector with the location can be specified.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_init">init</code></td>
<td>
<p>an optional matrix giving the starting value for the iteration</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_steps">steps</code></td>
<td>
<p>a fixed number of iteration steps to take. See details.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_eps">eps</code></td>
<td>
<p>convergence tolerance.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_in.r">in.R</code></td>
<td>
<p>logical. If TRUE R-code (and not C) is used in the iteration</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_print.it">print.it</code></td>
<td>
<p>logical. If TRUE prints the number of iterations, otherwise not.</p>
</td></tr>
<tr><td><code id="tyler.shape_+3A_na.action">na.action</code></td>
<td>
<p> a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most robust M-estimator of shape. It is proportional to the regular covariance matrix for elliptical contoured distributions. 
The estimate is in such a way standardized, that its determinate is 1.
</p>
<p>The algorithm requires an estimate of location, if none is provided, the sample mean is used. Observations which are equal to the location estimate are removed form the data.
</p>
<p>The algorithm also allows for a k-step version where the iteration is run for a fixed number of steps instead of until convergence. If <code>steps</code> is finite that number of steps is taken and <code>maxiter</code> is ignored.
</p>
<p>A different implementation is available in the package fastM as the function <code>TYLERshape</code>.
</p>


<h3>Value</h3>

<p>A matrix.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen, and Seija Sirkia</p>


<h3>References</h3>

<p><cite>Tyler, D.E. (1987), A distribution-free M-estimator of scatter, <em>Annals of Statistics</em>, <b>15</b>,  234&ndash;251. </cite>  
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+duembgen.shape">duembgen.shape</a></code>, <code><a href="#topic+HR.Mest">HR.Mest</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(654321)
cov.matrix &lt;- matrix(c(3,2,1,2,4,-0.5,1,-0.5,2), ncol=3)
X &lt;- rmvnorm(100, c(0,0,0), cov.matrix)
tyler.shape(X)
tyler.shape(X, location=0)
cov.matrix/det(cov.matrix)^(1/3)
rm(.Random.seed)
</code></pre>

<hr>
<h2 id='vdw.loc'> Van der Waerden Estimator of Location</h2><span id='topic+vdw.loc'></span>

<h3>Description</h3>

<p>Iterative algorithm to compute the location estimator based on van der Waerden scores (sometimes also referred to as normal scores).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vdw.loc(x, int.diff = 10, maxiter = 1000, na.action = na.fail)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vdw.loc_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="vdw.loc_+3A_int.diff">int.diff</code></td>
<td>
<p>number of observations in internal interval when the estimate is searched. </p>
</td></tr>
<tr><td><code id="vdw.loc_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="vdw.loc_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen when the data
contain 'NA's.  Default is to fail.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm searches among the observations and all Walsh averages for the  two points nearest around the root of the van der Waerden score criterion. Since the criterion function
is monotone first the <code>int.diff</code> of the sorted data points are searched that contain the root. After then determining there the two points of question a linear interpolation is used as an estimate.    
</p>


<h3>Value</h3>

<p>the van der Waerden score estimator of location.
</p>


<h3>Author(s)</h3>

<p>Klaus Nordhausen</p>


<h3>References</h3>

 <p><cite>Hettmansperger, T.P. and McKean, J.W. (1998), <em>Robust Nonparametric Statistical Methods</em>,
London, Arnold. </cite></p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- rt(100, df = 3)
vdw.loc(x)
rm(.Random.seed)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
