<!DOCTYPE html><html lang="en-US"><head><title>Help for package detrendr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {detrendr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#detrendr'><p>detrendr: Image detrending in R.</p></a></li>
<li><a href='#apply_on_pillars'><p>Apply a function to each pillar of a 3-dimensional array.</p></a></li>
<li><a href='#best_degree'><p>Find the best polynomial degree for polynomial detrending.</p></a></li>
<li><a href='#best_l'><p>Find the best length parameter for boxcar detrending.</p></a></li>
<li><a href='#best_swaps'><p>Find the best <code>swaps</code> parameter for <em>Robin Hood</em> detrending.</p></a></li>
<li><a href='#best_tau'><p>Find the best tau parameter for exponential smoothing detrending.</p></a></li>
<li><a href='#brightness_pillars'><p>Get the brightness of pillars of a 3d array.</p></a></li>
<li><a href='#detrend-directory'><p>Detrend all TIFF images in an entire folder.</p></a></li>
<li><a href='#detrended_img'><p>Detrended image class.</p></a></li>
<li><a href='#detrending'><p>Detrend images.</p></a></li>
<li><a href='#mean_frames'><p>Get the sums/means of frames in a 3-dimensional array.</p></a></li>
<li><a href='#pillar-stats'><p>Get the sums/means/medians/variances of pillars of an</p>
ijtiff_img-style array.</a></li>
<li><a href='#rfromboxes'><p>Randomly draw balls from boxes.</p></a></li>
<li><a href='#rtoboxes'><p>Randomly place balls in boxes.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Detrend Images</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rory Nolan &lt;rorynoolan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Detrend fluorescence microscopy image series for fluorescence
    fluctuation and correlation spectroscopy ('FCS' and 'FFS') analysis.
    This package contains functionality published in a 2016 paper
    &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtx434">doi:10.1093/bioinformatics/btx434</a>&gt; but it has been extended since
    then with the Robin Hood algorithm and thus contains unpublished work.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-3-Clause">BSD_3_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rorynolan.github.io/detrendr/">https://rorynolan.github.io/detrendr/</a>,
<a href="https://github.com/rorynolan/detrendr#readme">https://github.com/rorynolan/detrendr#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rorynolan/detrendr/issues">https://github.com/rorynolan/detrendr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>arrayhelpers (&ge; 1.1.0), autothresholdr (&ge; 1.3.11), checkmate
(&ge; 1.9.3), doParallel, dplyr, filesstrings (&ge; 3.2.4),
foreach, ijtiff (&ge; 2.2), iterators, magrittr (&ge; 1.5),
parallel, plyr, purrr, Rcpp (&ge; 1.0.10), RcppParallel (&ge;
5.1.7), rlang (&ge; 0.3.3), stringr (&ge; 1.4), tools, withr (&ge;
2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>abind, covr, ggplot2, glue (&ge; 1.3.0), graphics, gridExtra,
knitr, lattice, MASS, matrixStats, mgcv, pacman, R.utils,
rmarkdown, spelling, testthat (&ge; 3.0), tidyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.10), RcppParallel (&ge; 5.1.7)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-04 19:13:16 UTC; rnolan</td>
</tr>
<tr>
<td>Author:</td>
<td>Rory Nolan <a href="https://orcid.org/0000-0002-5239-4043"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Luis Alvarez <a href="https://orcid.org/0000-0003-1316-1906"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb, cph],
  Sergi Padilla-Parra
    <a href="https://orcid.org/0000-0002-8010-9481"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb, ths,
    cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-04 21:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='detrendr'>detrendr: Image detrending in R.</h2><span id='topic+detrendr'></span><span id='topic+detrendr-package'></span>

<h3>Description</h3>

<p>The <code>detrendr</code> package gives functions for detrending images, most often used
for preprocessing in fluorescence fluctuation and correlation spectroscopy
(FFS and FCS).
</p>


<h3>References</h3>

<p>Rory Nolan, Luis A. J. Alvarez, Jonathan Elegheert, Maro
Iliopoulou, G. Maria Jakobsdottir, Marina Rodriguez-Muñoz, A. Radu
Aricescu, Sergi Padilla-Parra; nandb—number and brightness in R with a
novel automatic detrending algorithm, Bioinformatics,
https://doi.org/10.1093/bioinformatics/btx434.
</p>

<hr>
<h2 id='apply_on_pillars'>Apply a function to each pillar of a 3-dimensional array.</h2><span id='topic+apply_on_pillars'></span>

<h3>Description</h3>

<p>Define a 'pillar' of a 3-dimensional array as pillar <code style="white-space: pre;">&#8288;i,j&#8288;</code> off array
<code>arr</code> being <code>arr[i, j, ]</code>. This function applies a specified
function to each pillar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_on_pillars(arr3d, FUN)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_on_pillars_+3A_arr3d">arr3d</code></td>
<td>
<p>A 3-dimensional array.</p>
</td></tr>
<tr><td><code id="apply_on_pillars_+3A_fun">FUN</code></td>
<td>
<p>A function which takes a vector as input and, for a given input
length, outputs a vector of constant length (can be 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>FUN</code> is returning length 1 vectors, a matrix whereby
<code>mat[i, j] = FUN(arr3d[i, j, ])</code>. If FUN is returning vectors of
length <code>l &gt; 1</code>, a 3-dimensional array whereby <code>arr[i, j, ] =
  FUN(arr3d[i, j, ])</code>.
</p>

<hr>
<h2 id='best_degree'>Find the best polynomial degree for polynomial detrending.</h2><span id='topic+best_degree'></span>

<h3>Description</h3>

<p>Use Nolan's algorithm to find the ideal polynomial degree for polynomial
detrending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_degree(img, parallel = FALSE, purpose = c("FCS", "FFS"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_degree_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="best_degree_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="best_degree_+3A_purpose">purpose</code></td>
<td>
<p>What type of calculation do you intend to perform on the
detrended image? If it is an FFS (fluorescence fluctuation spectroscopy)
calculation (like number and brightness), choose 'FFS'. If it is an FCS
(fluorescence correlation spectroscopy) calculation (like cross-correlated
number and brightness or autocorrelation), choose 'FCS'. The difference is
that if <code>purpose</code> is 'FFS', the time series is corrected for non-stationary
mean and variance, whereas if <code>purpose</code> is 'FCS', the time series is
corrected for non-stationary mean only. <code>purpose</code> is not required for
<em>Robin Hood</em> detrending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no detrend is necessary, this function returns <code>NA</code>. If a detrend
is required, this function returns a natural number which is the ideal
polynomial degree for polynomial detrending. If there are multiple
channels, the function returns a vector, one <code>degree</code> parameter for each
channel.
</p>


<h3>References</h3>

<p>Rory Nolan, Luis A. J. Alvarez, Jonathan Elegheert, Maro
Iliopoulou, G. Maria Jakobsdottir, Marina Rodriguez-Muñoz, A. Radu
Aricescu, Sergi Padilla-Parra; nandb—number and brightness in R with a
novel automatic detrending algorithm, Bioinformatics,
https://doi.org/10.1093/bioinformatics/btx434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples are not run on CRAN because they take too long.
## You can still try them for yourself.
img &lt;- ijtiff::read_tif(system.file("extdata", "bleached.tif",
  package = "detrendr"
))
best_degree(img, parallel = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='best_l'>Find the best length parameter for boxcar detrending.</h2><span id='topic+best_l'></span>

<h3>Description</h3>

<p>Use Nolan's algorithm to find the ideal length parameter for boxcar
detrending. Boxcar detrending is also referred to as 'running average'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_l(img, parallel = FALSE, purpose = c("FCS", "FFS"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_l_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="best_l_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="best_l_+3A_purpose">purpose</code></td>
<td>
<p>What type of calculation do you intend to perform on the
detrended image? If it is an FFS (fluorescence fluctuation spectroscopy)
calculation (like number and brightness), choose 'FFS'. If it is an FCS
(fluorescence correlation spectroscopy) calculation (like cross-correlated
number and brightness or autocorrelation), choose 'FCS'. The difference is
that if <code>purpose</code> is 'FFS', the time series is corrected for non-stationary
mean and variance, whereas if <code>purpose</code> is 'FCS', the time series is
corrected for non-stationary mean only. <code>purpose</code> is not required for
<em>Robin Hood</em> detrending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no detrend is necessary, this function returns <code>NA</code>. If a detrend
is required, this function returns a natural number which is the ideal
length parameter for boxcar detrending. If there are multiple channels, the
function returns a vector, one <code>l</code> parameter for each channel.
</p>


<h3>References</h3>

<p>Rory Nolan, Luis A. J. Alvarez, Jonathan Elegheert, Maro
Iliopoulou, G. Maria Jakobsdottir, Marina Rodriguez-Muñoz, A. Radu
Aricescu, Sergi Padilla-Parra; nandb—number and brightness in R with a
novel automatic detrending algorithm, Bioinformatics,
https://doi.org/10.1093/bioinformatics/btx434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples are not run on CRAN because they take too long.
## You can still try them for yourself.
img &lt;- ijtiff::read_tif(system.file("extdata", "bleached.tif",
  package = "detrendr"
))
best_l(img, parallel = 2, purpose = "FFS")

## End(Not run)

</code></pre>

<hr>
<h2 id='best_swaps'>Find the best <code>swaps</code> parameter for <em>Robin Hood</em> detrending.</h2><span id='topic+best_swaps'></span>

<h3>Description</h3>

<p>Use Nolan's algorithm to find the ideal <code>swaps</code> parameter for <em>Robin Hood</em>
detrending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_swaps(img, quick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_swaps_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="best_swaps_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A natural number. The ideal <code>swaps</code> parameter for boxcar detrending.
If there are multiple channels, the function returns a vector, one <code>swaps</code>
parameter for each channel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples are not run on CRAN because they take too long.
## You can still try them for yourself.
img &lt;- ijtiff::read_tif(system.file("extdata", "bleached.tif",
  package = "detrendr"
))
best_swaps(img)

## End(Not run)

</code></pre>

<hr>
<h2 id='best_tau'>Find the best tau parameter for exponential smoothing detrending.</h2><span id='topic+best_tau'></span>

<h3>Description</h3>

<p>Use Nolan's algorithm to find the ideal tau parameter for exponential
smoothing detrending.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_tau(img, cutoff = 0.05, parallel = FALSE, purpose = c("FCS", "FFS"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_tau_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="best_tau_+3A_cutoff">cutoff</code></td>
<td>
<p>In <em>exponential filtering</em> detrending, for the weighted
average, every point gets a weight. This can slow down the computation
massively. However, many of the weights will be approximately zero. With
cutoff, we say that any point with weight less than or equal to <code>cutoff</code>
times the maximum weight may be ignored; so with <code>cutoff = 0.05</code>, any
weight less than 5\
value of this parameter is sensible and its value should not be set to
anything else without good reason.</p>
</td></tr>
<tr><td><code id="best_tau_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="best_tau_+3A_purpose">purpose</code></td>
<td>
<p>What type of calculation do you intend to perform on the
detrended image? If it is an FFS (fluorescence fluctuation spectroscopy)
calculation (like number and brightness), choose 'FFS'. If it is an FCS
(fluorescence correlation spectroscopy) calculation (like cross-correlated
number and brightness or autocorrelation), choose 'FCS'. The difference is
that if <code>purpose</code> is 'FFS', the time series is corrected for non-stationary
mean and variance, whereas if <code>purpose</code> is 'FCS', the time series is
corrected for non-stationary mean only. <code>purpose</code> is not required for
<em>Robin Hood</em> detrending.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no detrend is necessary, this function returns <code>NA</code>. If a detrend
is required, this function returns a natural number which is the ideal
<code>tau</code> parameter for exponential smoothing detrending. If there are multiple
channels, the function returns a vector, one <code>tau</code> parameter for each
channel.
</p>


<h3>References</h3>

<p>Rory Nolan, Luis A. J. Alvarez, Jonathan Elegheert, Maro
Iliopoulou, G. Maria Jakobsdottir, Marina Rodriguez-Muñoz, A. Radu
Aricescu, Sergi Padilla-Parra; nandb—number and brightness in R with a
novel automatic detrending algorithm, Bioinformatics,
https://doi.org/10.1093/bioinformatics/btx434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples are not run on CRAN because they take too long.
## You can still try them for yourself.
img &lt;- ijtiff::read_tif(system.file("extdata", "bleached.tif",
  package = "detrendr"
))[, , 1, ]
best_tau(img, parallel = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='brightness_pillars'>Get the brightness of pillars of a 3d array.</h2><span id='topic+brightness_pillars'></span>

<h3>Description</h3>

<p>For an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array <code>img</code> (indexed as <code>img[y, x, channel, frame]</code>),  3-dimensional array <code>mat3d</code>, pillar <code>xy</code>  of channel
<code>ch</code> is defined as <code>img[y, x, ch, ]</code>. This function computes the brightness,
of each pillar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brightness_pillars(img, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brightness_pillars_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="brightness_pillars_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array <code>arr</code> with
one frame. <code>arr[y, x, ch, 1]</code> is equal to <code>var(img[y, x, ch, ]) / mean(img[y, x, ch, ])</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aaa &lt;- array(1:16, dim = c(2, 2, 4))
brightness_pillars(aaa)
</code></pre>

<hr>
<h2 id='detrend-directory'>Detrend all TIFF images in an entire folder.</h2><span id='topic+detrend-directory'></span><span id='topic+dir_detrend_robinhood'></span><span id='topic+dir_detrend_rh'></span><span id='topic+dir_detrend_boxcar'></span><span id='topic+dir_detrend_exp'></span><span id='topic+dir_detrend_polynom'></span>

<h3>Description</h3>

<p>Batch processing. Apply any of the available detrending routines to detrend
all of the TIFF images in a folder, saving the detrended images as TIFF files
in the same folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir_detrend_robinhood(
  folder_path = ".",
  swaps = "auto",
  thresh = NULL,
  quick = FALSE,
  msg = TRUE
)

dir_detrend_rh(
  folder_path = ".",
  swaps = "auto",
  thresh = NULL,
  quick = FALSE,
  msg = TRUE
)

dir_detrend_boxcar(
  folder_path = ".",
  l,
  purpose = c("FCS", "FFS"),
  thresh = NULL,
  parallel = FALSE,
  msg = TRUE
)

dir_detrend_exp(
  folder_path = ".",
  tau,
  purpose = c("FCS", "FFS"),
  thresh = NULL,
  parallel = FALSE,
  msg = TRUE
)

dir_detrend_polynom(
  folder_path = ".",
  degree,
  purpose = c("FCS", "FFS"),
  thresh = NULL,
  parallel = FALSE,
  msg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detrend-directory_+3A_folder_path">folder_path</code></td>
<td>
<p>The path (relative or absolute) to the folder you wish to
process.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_swaps">swaps</code></td>
<td>
<p>The number of swaps (giving of one count from rich to poor) to
perform during the <em>Robin Hood</em> detrending. Set this to &quot;auto&quot; (the
default) to use Nolan's algorithm to automatically find a suitable value
for this parameter (recommended). For multi-channel images, it is possible
to have a different <code>swaps</code> for each channel by specifying <code>swaps</code> as a
vector or list.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_thresh">thresh</code></td>
<td>
<p>The threshold or thresholding method (see
<code><a href="autothresholdr.html#topic+mean_stack_thresh">autothresholdr::mean_stack_thresh()</a></code>) to use on the image prior to
detrending.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_msg">msg</code></td>
<td>
<p>Receive messages to tell you how the processing of the directory
is going? Default is yes.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_l">l</code></td>
<td>
<p>The length parameter for <em>boxcar</em> detrending. The size of the
sliding window will be <code>2 * l + 1</code>. This must be a positive integer. Set
this to &quot;auto&quot; to use Nolan's algorithm to automatically find a suitable
value for this parameter (recommended). For multi-channel images, it is
possible to have a different <code>l</code> for each channel by specifying <code>l</code> as a
vector or list.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_purpose">purpose</code></td>
<td>
<p>What type of calculation do you intend to perform on the
detrended image? If it is an FFS (fluorescence fluctuation spectroscopy)
calculation (like number and brightness), choose 'FFS'. If it is an FCS
(fluorescence correlation spectroscopy) calculation (like cross-correlated
number and brightness or autocorrelation), choose 'FCS'. The difference is
that if <code>purpose</code> is 'FFS', the time series is corrected for non-stationary
mean and variance, whereas if <code>purpose</code> is 'FCS', the time series is
corrected for non-stationary mean only. <code>purpose</code> is not required for
<em>Robin Hood</em> detrending.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_tau">tau</code></td>
<td>
<p>The <code class="reqn">tau</code> parameter for <em>exponential filtering</em> detrending.
This must be a positive number. Set this to &quot;auto&quot; to use Nolan's algorithm
to automatically find a suitable value for this parameter (recommended).
For multi-channel images, it is possible to have a different <code>tau</code> for each
channel by specifying <code>tau</code> as a vector or list.</p>
</td></tr>
<tr><td><code id="detrend-directory_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial to use for the polynomial
detrending. This must be a positive integer. Set this to &quot;auto&quot; to use
Nolan's algorithm to automatically find a suitable value for this parameter
(recommended). For multi-channel images, it is possible to have a different
<code>degree</code> for each channel by specifying <code>degree</code> as a vector or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions include a thresholding option, unlike their non-batch
processing counterparts which they wrap (i.e. <a href="#topic+img_detrend_boxcar">img_detrend_boxcar</a>,
<a href="#topic+img_detrend_exp">img_detrend_exp</a> and <a href="#topic+img_detrend_polynom">img_detrend_polynom</a>). This is because, when working
interactively, it's easy to threshold and then detrend, but for batch
processing, it's not so easy to efficiently do one after the other, so it's
nice to have that taken care of should you want it.
</p>


<h3>Value</h3>

<p>Silently, a character vector of the paths to the detrended images.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
setwd(tempdir())
file.copy(
  c(
    system.file("extdata", "bleached.tif", package = "detrendr"),
    system.file("img", "2ch_ij.tif", package = "ijtiff")
  ),
  "."
)
dir_detrend_robinhood(thresh = "huang")
dir_detrend_boxcar(l = "auto", thresh = "tri", purpose = "FFS")
dir_detrend_exp(tau = "auto", thresh = "tri", purpose = "FCS")
dir_detrend_polynom(degree = "auto", thresh = "huang", purpose = "FFS")

## End(Not run)
</code></pre>

<hr>
<h2 id='detrended_img'>Detrended image class.</h2><span id='topic+detrended_img'></span>

<h3>Description</h3>

<p>A <a href="#topic+detrended_img">detrended_img</a> is a 4-dimensional array of positive integers in the style
of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>) which is the result of a detrending routine. It has 4 attributes:
</p>
<dl>
<dt><code>method</code></dt><dd><p>The detrending method used. This must be one of
<code>"boxcar"</code>, <code>"exponential"</code> or <code>"polynomial"</code>. </p>
</dd> <dt><code>parameter</code></dt><dd><p>The value
of the parameter used. This will be the <code>l</code>, <code>tau</code> or <code>degree</code> parameter for
the respective methods.</p>
</dd> <dt><code>auto</code></dt><dd><p>A boolean that is <code>TRUE</code> if the
parameter was found automatically or <code>FALSE</code> if it was manually selected. </p>
</dd>
<dt><code>purpose</code></dt><dd><p>Either <code>"FCS"</code> or <code>"FFS"</code> to denote whether the detrending
was done for the purpose of fluorescence correlation spectroscopy or
fluorescence fluctuation spectroscopy calculations respectively. <code>purpose</code> is
not required for <em>Robin Hood</em> detrending.</p>
</dd></dl>



<h3>Usage</h3>

<pre><code class='language-R'>detrended_img(img, method, parameter, auto, purpose = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detrended_img_+3A_img">img</code></td>
<td>
<p>The detrended image series. A 4-dimensional array of non-negative
integers in the style of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>, or a
3-dimensional array of non-negative integers which represents a single
channel of an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array (indexed by
<code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="detrended_img_+3A_method">method</code></td>
<td>
<p>The method used. One of <code>"robinhood"</code>,<code> "boxcar"</code>,
<code>"exponential"</code> or <code>"polynomial"</code>.</p>
</td></tr>
<tr><td><code id="detrended_img_+3A_parameter">parameter</code></td>
<td>
<p>A number. The detrend parameter used. One per channel.</p>
</td></tr>
<tr><td><code id="detrended_img_+3A_auto">auto</code></td>
<td>
<p>Logical. Was automatic detrending used? One per channel.</p>
</td></tr>
<tr><td><code id="detrended_img_+3A_purpose">purpose</code></td>
<td>
<p>Either <code>"FCS"</code> or <code>"FFS"</code>. Was the image detrended for the
purpose of doing FCS or FFS calculations? See <a href="#topic+detrending">detrending</a>. <code>purpose</code> is
not required for <em>Robin Hood</em> detrending.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes when detrending, you can get slight negative values in the
detrended image. These values should really just be zero, so this constructor
function sets negative values of <code>img</code> to zero.
</p>


<h3>Value</h3>

<p>An object of class <code>detrended_img</code>.
</p>

<hr>
<h2 id='detrending'>Detrend images.</h2><span id='topic+detrending'></span><span id='topic+img_detrend_robinhood'></span><span id='topic+img_detrend_rh'></span><span id='topic+img_detrend_boxcar'></span><span id='topic+img_detrend_exp'></span><span id='topic+img_detrend_polynom'></span>

<h3>Description</h3>

<p>Correct images for bleaching (or any other effect that introduces an unwanted
trend) by <em>detrending</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img_detrend_robinhood(img, swaps = "auto", quick = FALSE)

img_detrend_rh(img, swaps = "auto", quick = FALSE)

img_detrend_boxcar(img, l, purpose = c("FCS", "FFS"), parallel = FALSE)

img_detrend_exp(
  img,
  tau,
  cutoff = 0.05,
  purpose = c("FCS", "FFS"),
  parallel = FALSE
)

img_detrend_polynom(img, degree, purpose = c("FCS", "FFS"), parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detrending_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="detrending_+3A_swaps">swaps</code></td>
<td>
<p>The number of swaps (giving of one count from rich to poor) to
perform during the <em>Robin Hood</em> detrending. Set this to &quot;auto&quot; (the
default) to use Nolan's algorithm to automatically find a suitable value
for this parameter (recommended). For multi-channel images, it is possible
to have a different <code>swaps</code> for each channel by specifying <code>swaps</code> as a
vector or list.</p>
</td></tr>
<tr><td><code id="detrending_+3A_quick">quick</code></td>
<td>
<p>If <code>FALSE</code> (the default), the swap finding routine is run
several times to get a consensus for the best parameter. If <code>TRUE</code>, the
swap finding routine is run only once.</p>
</td></tr>
<tr><td><code id="detrending_+3A_l">l</code></td>
<td>
<p>The length parameter for <em>boxcar</em> detrending. The size of the
sliding window will be <code>2 * l + 1</code>. This must be a positive integer. Set
this to &quot;auto&quot; to use Nolan's algorithm to automatically find a suitable
value for this parameter (recommended). For multi-channel images, it is
possible to have a different <code>l</code> for each channel by specifying <code>l</code> as a
vector or list.</p>
</td></tr>
<tr><td><code id="detrending_+3A_purpose">purpose</code></td>
<td>
<p>What type of calculation do you intend to perform on the
detrended image? If it is an FFS (fluorescence fluctuation spectroscopy)
calculation (like number and brightness), choose 'FFS'. If it is an FCS
(fluorescence correlation spectroscopy) calculation (like cross-correlated
number and brightness or autocorrelation), choose 'FCS'. The difference is
that if <code>purpose</code> is 'FFS', the time series is corrected for non-stationary
mean and variance, whereas if <code>purpose</code> is 'FCS', the time series is
corrected for non-stationary mean only. <code>purpose</code> is not required for
<em>Robin Hood</em> detrending.</p>
</td></tr>
<tr><td><code id="detrending_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="detrending_+3A_tau">tau</code></td>
<td>
<p>The <code class="reqn">tau</code> parameter for <em>exponential filtering</em> detrending.
This must be a positive number. Set this to &quot;auto&quot; to use Nolan's algorithm
to automatically find a suitable value for this parameter (recommended).
For multi-channel images, it is possible to have a different <code>tau</code> for each
channel by specifying <code>tau</code> as a vector or list.</p>
</td></tr>
<tr><td><code id="detrending_+3A_cutoff">cutoff</code></td>
<td>
<p>In <em>exponential filtering</em> detrending, for the weighted
average, every point gets a weight. This can slow down the computation
massively. However, many of the weights will be approximately zero. With
cutoff, we say that any point with weight less than or equal to <code>cutoff</code>
times the maximum weight may be ignored; so with <code>cutoff = 0.05</code>, any
weight less than 5\
value of this parameter is sensible and its value should not be set to
anything else without good reason.</p>
</td></tr>
<tr><td><code id="detrending_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial to use for the polynomial
detrending. This must be a positive integer. Set this to &quot;auto&quot; to use
Nolan's algorithm to automatically find a suitable value for this parameter
(recommended). For multi-channel images, it is possible to have a different
<code>degree</code> for each channel by specifying <code>degree</code> as a vector or list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are 4 detrending methods available: <em>Robin Hood</em>, <em>boxcar</em>,
<em>exponential filtering</em> and <em>polynomial</em>. <em>Robin Hood</em> is described in Nolan
et al., 2018. The others are described in Nolan et al., 2017. </p>
<ul>
<li>
<p><em>Robin Hood</em> is a method whereby counts are taken from frames with higher
mean intensity and given directly to frames of lower intensity. </p>
</li>
<li>
<p><em>Boxcar</em> detrending with parameter <code class="reqn">l</code> is a moving average detrending
method using a sliding window of size <code class="reqn">2l + 1</code>. </p>
</li>
<li> <p><em>Exponential
filtering</em> detrending is a moving weighted average method where for parameter
<code class="reqn">tau</code> the weights are calculated as exp<code class="reqn">(- t / tau)</code> where <code class="reqn">t</code> is
the distance from the point of interest. </p>
</li>
<li> <p><em>Polynomial</em> detrending works
by fitting a polynomial line to a series of points and then correcting the
series to remove the trend detailed by this polynomial fit.</p>
</li></ul>



<h3>Value</h3>

<p>The detrended image, an object of class <a href="#topic+detrended_img">detrended_img</a>.
</p>


<h3>References</h3>

<p>Rory Nolan, Luis A. J. Alvarez, Jonathan Elegheert, Maro
Iliopoulou, G. Maria Jakobsdottir, Marina Rodriguez-Muñoz, A. Radu
Aricescu, Sergi Padilla-Parra; nandb—number and brightness in R with a
novel automatic detrending algorithm, Bioinformatics,
https://doi.org/10.1093/bioinformatics/btx434.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples are not run on CRAN because they take too long.
## You can still try them for yourself.

img &lt;- ijtiff::read_tif(system.file("extdata", "bleached.tif",
  package = "detrendr"
))
corrected &lt;- img_detrend_rh(img)
corrected &lt;- img_detrend_boxcar(img, "auto", purpose = "fcs", parallel = 2)
corrected10 &lt;- img_detrend_boxcar(img, 10, purpose = "fcs", parallel = 2)
corrected50 &lt;- img_detrend_boxcar(img, 50, purpose = "fcs", parallel = 2)
corrected &lt;- img_detrend_exp(img, "auto", purpose = "ffs", parallel = 2)
corrected10 &lt;- img_detrend_exp(img, 10, purpose = "ffs", parallel = 2)
corrected50 &lt;- img_detrend_exp(img, 50, purpose = "fcs", parallel = 2)
corrected &lt;- img_detrend_polynom(img, "auto", purpose = "ffs", parallel = 2)
corrected2 &lt;- img_detrend_polynom(img, 2, purpose = "ffs", parallel = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='mean_frames'>Get the sums/means of frames in a 3-dimensional array.</h2><span id='topic+mean_frames'></span><span id='topic+sum_frames'></span>

<h3>Description</h3>

<p>Frame <code>i</code> of a 3-dimensional array <code>arr3d</code> is defined as <code>arr3d[, , i]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_frames(arr3d, na_rm = FALSE)

sum_frames(arr3d, na_rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_frames_+3A_arr3d">arr3d</code></td>
<td>
<p>A 3-dimensional numeric array.</p>
</td></tr>
<tr><td><code id="mean_frames_+3A_na_rm">na_rm</code></td>
<td>
<p>Do you want <code>NA</code> values to be excluded from calculations?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- array(seq_len(2^3), dim = rep(2, 3))
sum_frames(a)
mean_frames(a)
</code></pre>

<hr>
<h2 id='pillar-stats'>Get the sums/means/medians/variances of pillars of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array.</h2><span id='topic+pillar-stats'></span><span id='topic+sum_pillars'></span><span id='topic+mean_pillars'></span><span id='topic+median_pillars'></span><span id='topic+var_pillars'></span>

<h3>Description</h3>

<p>For an <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array <code>img</code> (indexed as <code>img[y, x, channel, frame]</code>), pillar <code>xy</code> of channel
<code>ch</code> is defined as <code>img[y, x, ch, ]</code>. These functions compute the mean,
median and variance of each pillar for each channel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_pillars(img, parallel = FALSE)

mean_pillars(img, parallel = FALSE)

median_pillars(img, parallel = FALSE)

var_pillars(img, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pillar-stats_+3A_img">img</code></td>
<td>
<p>A 4-dimensional array in the style of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, channel, frame]</code>)
or a 3-dimensional array which is a single channel of an
<a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a> (indexed by <code>img[y, x, frame]</code>).</p>
</td></tr>
<tr><td><code id="pillar-stats_+3A_parallel">parallel</code></td>
<td>
<p>Would you like to use multiple cores to speed up this
function? If so, set the number of cores here, or to use all available
cores, use <code>parallel = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <a href="ijtiff.html#topic+ijtiff_img">ijtiff_img</a>-style array <code>arr</code> with one frame.
<code>arr[y, x, ch, 1]</code> is equal to <code>mean(img[y, x, ch, ])</code>, <code>median(img[y, x, ch, ])</code>, or <code>var(img[y, x, ch, ])</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aaa &lt;- array(seq_len(2^4), dim = rep(2, 4)) # a 2-channel, 2-frame array
sum_pillars(aaa)
mean_pillars(aaa)
median_pillars(aaa)
var_pillars(aaa)
</code></pre>

<hr>
<h2 id='rfromboxes'>Randomly draw balls from boxes.</h2><span id='topic+rfromboxes'></span>

<h3>Description</h3>

<p>Given a number of boxes with a specified number of balls in each, randomly
draw a number of balls from these boxes, recording how many balls was drawn
from each. An empty box cannot be drawn from.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfromboxes(n, balls, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rfromboxes_+3A_n">n</code></td>
<td>
<p>A natural number. The number of balls to draw.</p>
</td></tr>
<tr><td><code id="rfromboxes_+3A_balls">balls</code></td>
<td>
<p>A vector of natural numbers. The number of balls in each box to
begin with.</p>
</td></tr>
<tr><td><code id="rfromboxes_+3A_weights">weights</code></td>
<td>
<p>A non-negative numeric vector the same length as <code>balls</code>. The
relative probabilities of drawing a ball from each box. Default is each box
is equally likely to be drawn from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of natural numbers with the same length as <code>balls</code>. The
number of balls drawn from each box.
</p>


<h3>See Also</h3>

<p>rtoboxes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>balls &lt;- 1:10
rfromboxes(40, balls)
rfromboxes(40, balls, weights = c(rep(1, 9), 0))
</code></pre>

<hr>
<h2 id='rtoboxes'>Randomly place balls in boxes.</h2><span id='topic+rtoboxes'></span>

<h3>Description</h3>

<p>Given a number of boxes, randomly distribute <em>n</em> balls into these boxes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtoboxes(n, boxes, weights = NULL, capacities = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rtoboxes_+3A_n">n</code></td>
<td>
<p>A natural number. The number of balls to put into the boxes.</p>
</td></tr>
<tr><td><code id="rtoboxes_+3A_boxes">boxes</code></td>
<td>
<p>A natural number. The number of boxes.</p>
</td></tr>
<tr><td><code id="rtoboxes_+3A_weights">weights</code></td>
<td>
<p>A non-negative numeric vector. The relative probabilities of
putting a ball in each box. Default is each box is equally likely.</p>
</td></tr>
<tr><td><code id="rtoboxes_+3A_capacities">capacities</code></td>
<td>
<p>A vector of natural numbers. The capacity of each box.
Default is each box has infinite capacity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of natural numbers with the same length as <code>boxes</code>. The
number of balls placed in each box.
</p>


<h3>See Also</h3>

<p>rfromboxes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rtoboxes(30, 7)
rtoboxes(30, 7, capacities = c(rep(1, 3), rep(7, 4)))
rtoboxes(30, 7,
  capacities = c(rep(1, 3), rep(70, 4)),
  weights = c(rep(0.1, 6), 1)
)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
