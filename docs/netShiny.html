<!DOCTYPE html><html lang="en"><head><title>Help for package netShiny</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {netShiny}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#netShiny'><p>This function launches the netShiny Shiny app.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Tool for Comparison and Visualization of Multiple Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>We developed a comprehensive tool that helps with visualization and analysis of networks with the same variables across multiple factor levels. The 'netShiny' contains most of the popular network features such as centrality measures, modularity, and other summary statistics (e.g. clustering coefficient). It also contains known tools to look at the (dis)similarities between two networks, such as pairwise distance measures between networks, set operations on the nodes of the networks, distribution of the weights of the edges and a network representing the difference between two correlation matrices. The package 'netShiny' also contains tools to perform bootstrapping and find clusters in networks. See the 'netShiny' manual for more information, documentation and examples.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>colourpicker (&ge; 1.1.1), DT (&ge; 0.24), future (&ge; 1.27.0),
future.callr (&ge; 0.8.0), ggplot2 (&ge; 3.3.6), ggVennDiagram (&ge;
1.2.0), igraph (&ge; 1.3.4), ipc (&ge; 0.1.3), magrittr (&ge; 2.0.3),
Matrix (&ge; 1.4.1), netgwas (&ge; 1.14), plotly (&ge; 4.10.0),
promises (&ge; 1.2.0.1), readxl (&ge; 1.4.0), shinycssloaders (&ge;
1.0.0), shinyjs (&ge; 2.1.0), shinyscreenshot (&ge; 0.2.0),
shinyWidgets (&ge; 0.7.2), stats (&ge; 4.2.1), utils (&ge; 4.2.1),
visNetwork (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>shinyBS (&ge; 0.61.1), shiny (&ge; 1.7.2), shinydashboard (&ge;
0.7.2)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-18 10:50:56 UTC; behro001</td>
</tr>
<tr>
<td>Author:</td>
<td>Rocherno de Jongh [aut],
  Pariya Behrouzi <a href="https://orcid.org/0000-0001-6762-5433"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pariya Behrouzi &lt;pariya.behrouzi@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-22 09:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='netShiny'>This function launches the netShiny Shiny app.</h2><span id='topic+netShiny'></span>

<h3>Description</h3>

<p>This function launches the netShiny Shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netShiny(Net.obj = NULL, mapping = NULL, resamples = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="netShiny_+3A_net.obj">Net.obj</code></td>
<td>
<p>A list of (sparse) matrices corresponding to the networks that need to be visualized. Net.obj can also be a list of dataframes with data to be used to reconstruct networks.  Or, Net.obj can be a combination of (sparse) matrices and dataframes. If items in list are names, these names will be used, otherwise automatic names will be generated.</p>
</td></tr>
<tr><td><code id="netShiny_+3A_mapping">mapping</code></td>
<td>
<p>A dataframe containing order for each node. There should be a column with the names of the nodes and a column with the corresponding group that the nodes belong to. The app will automatically choose the column representing the grouping of the nodes by looking at the first two columns, and choosing the column with the less number of factor levels as the columns containing the grouping of the nodes.</p>
</td></tr>
<tr><td><code id="netShiny_+3A_resamples">resamples</code></td>
<td>
<p>If an user has resampling information corresponding to the networks to be visualized the user can also include this in the function, which will incorporate it into the app.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function opens the shiny app, netShiny. All of the arguments in netShiny are optional, so netShiny can be called without any arguments. Users are prompted with a series of modal dialogs after running the netShiny function. The first modal dialog gives users the possibility to upload files to the app and show the dataframes that already uploaded in a datatable. Users can choose files which contain information to reconstruct networks from them. The next modal dialog let users reconstruct networks using the dataframes that were uploaded. netShiny uses the functions netphenogeno and selectnet from the package netgwas for graph structure learning from non-Gaussian data. The next modal let users optionally choose a file containing the ordering of the nodes. If a dataframe containing the ordering of the nodes was already passed to mapping argument, this modal will visualize this in a datatable. The last modal let users choose the mode they want the app to run in, GxE (Genetic-by-Environment) or general mode. In GxE mode the language used in netShiny is more Genetic-by-Environment related. Users need to input the number of traits if GxE mode is chosen, and optionally, manually input a grouping for the traits.
</p>


<h3>Value</h3>

<p>A Shiny app.
</p>


<h3>Author(s)</h3>

<p>Rocherno de Jongh and Pariya Behrouzi <br />
Maintainer: Rocherno de Jongh <a href="mailto:rocherno.dejongh@hotmail.com">rocherno.dejongh@hotmail.com</a>
</p>


<h3>References</h3>

<p>Behrouzi, P., and Wit, E. C. (2017c). netgwas: An R Package for Network-Based Genome-Wide Association Studies. arXiv preprint, arXiv:1710.01236.
</p>


<h3>See Also</h3>

<p><code><a href="netgwas.html#topic+netphenogeno">netphenogeno</a></code>, <code><a href="netgwas.html#topic+selectnet">selectnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {
    netShiny()
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
