<!DOCTYPE html><html lang="en"><head><title>Help for package dvmisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dvmisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dvmisc'><p>Convenience Functions, Moving Window Statistics, and Graphics</p></a></li>
<li><a href='#bmi3'><p>Convert Continuous BMI Values into 3-Level Factor</p></a></li>
<li><a href='#bmi4'><p>Convert Continuous BMI Values into 4-Level Factor</p></a></li>
<li><a href='#clean_glm'><p>Create a Clean Summary Table from a glm Object</p></a></li>
<li><a href='#cleancut'><p>Convert Numeric to Factor with Convenient Interface</p></a></li>
<li><a href='#create_qgroups'><p>Create Quantile Groups</p></a></li>
<li><a href='#create_qgroups_svy'><p>Create Quantile Groups (Complex Survey Data)</p></a></li>
<li><a href='#cut_decreasing'><p>Cut with Decreasing Factor Levels</p></a></li>
<li><a href='#dots_bars'><p>Plot Points +/- Error Bars</p></a></li>
<li><a href='#expand_grid'><p>Similar to expand.grid but with Sequences Reversed and Ability to Treat</p>
Variables as Sets</a></li>
<li><a href='#gammareg'><p>Constant-Scale Gamma Model for Y vs. Covariates with Y Potentially Subject</p>
to Multiplicative Lognormal Errors</a></li>
<li><a href='#get_mse'><p>Extract Mean Squared Error (MSE) from Fitted Regression Model</p></a></li>
<li><a href='#headtail'><p>Return the First and Last Part of an Object</p></a></li>
<li><a href='#histo'><p>Histogram with Added Options</p></a></li>
<li><a href='#inside'><p>Check Whether Numeric Value Falls Inside Two Other Numeric Values</p></a></li>
<li><a href='#interval_groups'><p>Split Continuous Variable into Equal-Width Groups</p></a></li>
<li><a href='#iterate'><p>Iterate Function Over All Combinations of User-Specified Inputs, Potentially</p>
Multiple Times</a></li>
<li><a href='#list_override'><p>Add Elements of Second List to First List, Replacing Elements with Same Name</p></a></li>
<li><a href='#logit_prob'><p>Convert Logit to Probability</p></a></li>
<li><a href='#lognormalreg'><p>Linear Regression of log(Y) vs. Covariates with Y Potentially Subject to</p>
Multiplicative Lognormal Errors</a></li>
<li><a href='#logodds_graph'><p>Graph Log-Odds of Binary Variable Across A Grouping Variable</p></a></li>
<li><a href='#max_n'><p>Maximum of Numeric Values</p></a></li>
<li><a href='#mean_i'><p>Mean of Integer Values</p></a></li>
<li><a href='#means_graph'><p>Graph Means Across a Grouping Variable</p></a></li>
<li><a href='#min_n'><p>Minimum of Numeric Values</p></a></li>
<li><a href='#mle_gamma'><p>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Gamma(alpha, beta)</p></a></li>
<li><a href='#mle_gamma_lnorm'><p>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Gamma(alpha, beta) Lognormal(mu, sigsq)</p></a></li>
<li><a href='#mle_lnorm'><p>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Lognormal(mu, sigsq)</p></a></li>
<li><a href='#mle_lnorm_lnorm'><p>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Lognormal(mu1, sigsq1)</p>
Lognormal(mu2, sigsq2)</a></li>
<li><a href='#moving_mean'><p>Moving Averages</p></a></li>
<li><a href='#n_2t_equal'><p>Calculate Per-Group Sample Size for Two-Sample Equal Variance T-Test</p></a></li>
<li><a href='#n_2t_unequal'><p>Calculate Per-Group Sample Size for Two-Sample Unequal Variance T-Test</p></a></li>
<li><a href='#odds_prob'><p>Convert Odds to Probability</p></a></li>
<li><a href='#plot_ll'><p>Plot Log-Likelihood vs. Values of One Parameter</p></a></li>
<li><a href='#pooled_var'><p>Pooled Sample Variance</p></a></li>
<li><a href='#power_2t_equal'><p>Calculate Power for Two-Sample Equal Variance T-Test</p></a></li>
<li><a href='#power_2t_unequal'><p>Calculate Power for Two-Sample Unequal Variance T-Test</p></a></li>
<li><a href='#prob_logit'><p>Convert Probability to Logit</p></a></li>
<li><a href='#prob_odds'><p>Convert Probability to Odds</p></a></li>
<li><a href='#quant_groups'><p>Split Continuous Variable into Quantile Groups</p></a></li>
<li><a href='#quant_groups_svy'><p>Split Continuous Variable into Quantile Groups (Survey Version)</p></a></li>
<li><a href='#reverse_cut'><p>Reverse Cut</p></a></li>
<li><a href='#sliding_cor'><p>Moving Correlations as Short Vector Slides Across Long Vector</p></a></li>
<li><a href='#sliding_cov'><p>Moving Covariance as Short Vector Slides Across Long Vector</p></a></li>
<li><a href='#sum_i'><p>Sum of Integer Values</p></a></li>
<li><a href='#sumsim'><p>Summarize Simulation Results</p></a></li>
<li><a href='#trim'><p>Trim Tail Values off of a Vector</p></a></li>
<li><a href='#truerange'><p>Range of a Vector (Not Min/Max!)</p></a></li>
<li><a href='#which_max_im'><p>Return (Row, Column) Index of (First) Maximum of an Integer Matrix</p></a></li>
<li><a href='#which_max_iv'><p>Return Index of (First) Maximum of an Integer Vector</p></a></li>
<li><a href='#which_max_nm'><p>Return (Row, Column) Index of (First) Maximum of a Numeric Matrix</p></a></li>
<li><a href='#which_max_nv'><p>Return Index of (First) Maximum of a Numeric Vector</p></a></li>
<li><a href='#which_min_im'><p>Return (Row, Column) Index of (First) Minimum of an Integer Matrix</p></a></li>
<li><a href='#which_min_iv'><p>Return Index of (First) Minimum of an Integer Vector</p></a></li>
<li><a href='#which_min_nm'><p>Return (Row, Column) Index of (First) Minimum of a Numeric Matrix</p></a></li>
<li><a href='#which_min_nv'><p>Return Index of (First) Minimum of a Numeric Vector</p></a></li>
<li><a href='#which.max2'><p>Return Index of (First) Maximum of a Vector</p></a></li>
<li><a href='#which.min2'><p>Return Index of (First) Minimum of a Vector</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Convenience Functions, Moving Window Statistics, and Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Dane R. Van Domelen</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dane R. Van Domelen &lt;vandomed@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions that do something convenient (e.g. create BMI categories), functions for calculating moving-window statistics efficiently, and functions for generating various figures (e.g. histograms with fitted probability mass/density function).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>rbenchmark, dplyr</td>
</tr>
<tr>
<td>Imports:</td>
<td>cubature, data.table, ggplot2, graphics, MASS, mvtnorm,
pracma, Rcpp (&ge; 0.12.15), stats, survey, tab, utils</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, microbenchmark, printr, rmarkdown, RcppRoll</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-16 12:10:25 UTC; vando</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-16 20:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='dvmisc'>Convenience Functions, Moving Window Statistics, and Graphics</h2><span id='topic+dvmisc'></span><span id='topic+dvmisc-package'></span>

<h3>Description</h3>

<p>Contains functions that do something convenient (e.g. create BMI categories), 
functions for calculating moving-window statistics efficiently, and functions 
for generating various figures (e.g. histograms with fitted probability 
mass/density function).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> dvmisc </td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package </td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1.4 </td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-15 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See <a href="https://cran.r-project.org/package=dvmisc">CRAN documentation</a> for 
full list of functions.
</p>


<h3>Author(s)</h3>

<p>Dane R. Van Domelen <br /> <a href="mailto:vandomed@gmail.com">vandomed@gmail.com</a>
</p>


<h3>References</h3>

<p>Eddelbuettel, D. and Francois, R. (2011) Rcpp: Seamless R and C++ 
Integration. Journal of Statistical Software, 40(8), 1-18. 
<a href="http://www.jstatsoft.org/v40/i08/">http://www.jstatsoft.org/v40/i08/</a>.
</p>
<p>Eddelbuettel, D. (2013) Seamless R and C++ Integration with Rcpp. Springer, 
New York. ISBN 978-1-4614-6867-7.
</p>
<p>Eddelbuettel, D. and Balamuta, J.J. (2017). Extending R with C++: A Brief 
Introduction to Rcpp. PeerJ Preprints 5:e3188v1. 
<a href="https://doi.org/10.7287/peerj.preprints.3188v1">https://doi.org/10.7287/peerj.preprints.3188v1</a>.
</p>
<p>Acknowledgment: This material is based upon work supported by the 
National Science Foundation Graduate Research Fellowship under Grant No. 
DGE-0940903.
</p>

<hr>
<h2 id='bmi3'>Convert Continuous BMI Values into 3-Level Factor</h2><span id='topic+bmi3'></span>

<h3>Description</h3>

<p>Converts a continuous BMI variable into a 3-level factor variable: Normal 
weight if <code>[-Inf, 25)</code>, Overweight if <code>[25, 30)</code>, and Obese if 
<code>[30, Inf)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmi3(x, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmi3_+3A_x">x</code></td>
<td>
<p>Numeric vector of BMI values.</p>
</td></tr>
<tr><td><code id="bmi3_+3A_labels">labels</code></td>
<td>
<p>If <code>TRUE</code>, factor levels are labeled 
<code>"Normal weight"</code>, <code>"Overweight"</code>, and <code>"Obese"</code>; if 
<code>FALSE</code>, factor levels are <code>[-Inf, 25)</code>, <code>[25, 30)</code>, and 
<code>[30, Inf)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable with 3 levels.
</p>

<hr>
<h2 id='bmi4'>Convert Continuous BMI Values into 4-Level Factor</h2><span id='topic+bmi4'></span>

<h3>Description</h3>

<p>Converts a continuous BMI variable into a 4-level factor variable: 
Underweight if <code>[-Inf, 18.5)</code>, Normal weight if <code>[18.5, 25)</code>, 
Overweight if <code>[25, 30)</code>, and Obese if <code>[30, Inf)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bmi4(x, labels = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bmi4_+3A_x">x</code></td>
<td>
<p>Numeric vector of BMI values.</p>
</td></tr>
<tr><td><code id="bmi4_+3A_labels">labels</code></td>
<td>
<p>If <code>TRUE</code>, factor levels are labeled <code>"Underweight"</code>, 
<code>"Normal weight"</code>, <code>"Overweight"</code>, and <code>"Obese"</code>; if 
<code>FALSE</code>, factor levels are <code>[-Inf, 18.5)</code>, <code>[18.5, 25)</code>, 
<code>[25, 30)</code>, and <code>[30, Inf)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable with 4 levels.
</p>

<hr>
<h2 id='clean_glm'>Create a Clean Summary Table from a glm Object</h2><span id='topic+clean_glm'></span>

<h3>Description</h3>

<p>Formats a <code><a href="stats.html#topic+glm">glm</a></code> object for printing to console or
inputting to <code><a href="knitr.html#topic+kable">kable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_glm(fit, columns = NULL, expand_factors = TRUE,
  variable_labels = NULL, prep_kable = FALSE, decimals = 2,
  formatp_list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_glm_+3A_fit">fit</code></td>
<td>
<p>Object returned from <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_columns">columns</code></td>
<td>
<p>Character vector specifying what columns to include. Choices
for each element are <code>"beta"</code>, <code>"se"</code>, <code>"betaci"</code>,
<code>"beta_se"</code>, <code>"beta_ci"</code> <code>"or"</code>, <code>"orci"</code>, <code>"or_ci"</code>,
<code>"hr"</code>, <code>"hrci"</code>, <code>"hr_ci")</code>, <code>"z"</code>, <code>"t"</code>, and
<code>"p"</code>.</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_expand_factors">expand_factors</code></td>
<td>
<p>Logical value for whether to include two blank rows for
factor variables (name of variable and reference group).</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_variable_labels">variable_labels</code></td>
<td>
<p>Character vector in case you want labels other than
the variable names.</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_prep_kable">prep_kable</code></td>
<td>
<p>Logical value for whether to prepare for
printing via <code><a href="knitr.html#topic+kable">kable</a></code>. Right now, it just adds forward
slashes so factor levels are indented, which only applies if there are factor
variables and <code>expand_factors = TRUE</code>.</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_decimals">decimals</code></td>
<td>
<p>Numeric value of vector specifying number of decimal places for
each column.</p>
</td></tr>
<tr><td><code id="clean_glm_+3A_formatp_list">formatp_list</code></td>
<td>
<p>Arguments to pass to <code><a href="tab.html#topic+formatp">formatp</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- glm(mpg ~ wt + as.factor(cyl) + hp, data = mtcars)
clean_glm(fit)
fit %&gt;% clean_glm(prep_kable = TRUE) %&gt;% knitr::kable()

</code></pre>

<hr>
<h2 id='cleancut'>Convert Numeric to Factor with Convenient Interface</h2><span id='topic+cleancut'></span>

<h3>Description</h3>

<p>So you can stop guess-and-checking with <code><a href="base.html#topic+cut">cut</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleancut(x, breaks, labels = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleancut_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="cleancut_+3A_breaks">breaks</code></td>
<td>
<p>Character string, e.g. <code>"[-Inf, 0), [0, 10], (10, Inf)"</code>.</p>
</td></tr>
<tr><td><code id="cleancut_+3A_labels">labels</code></td>
<td>
<p>Character vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor or integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- cleancut(x, "(-Inf, -1), [-1, 1], (1, Inf)")
tapply(x, y, range)

y &lt;- cleancut(x, "(-Inf, -1), [-1, 1], (1, Inf)", c("&lt;-1", "-1 to 1", "&gt;1"))
tapply(x, y, range)

</code></pre>

<hr>
<h2 id='create_qgroups'>Create Quantile Groups</h2><span id='topic+create_qgroups'></span>

<h3>Description</h3>

<p>Combines <code><a href="stats.html#topic+quantile">quantile</a></code> and <code><a href="base.html#topic+cut">cut</a></code> into a 
single function, with strata-specific quantiles possible. For example, you 
could create sex-specific height tertiles with 
<code>create_qgroups(height, groups = 3, strata = sex)</code>. Compatible with 
<strong>dplyr</strong> functions like <code><a href="dplyr.html#topic+mutate">mutate</a></code> and 
<code><a href="dplyr.html#topic+mutate">transmute</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_qgroups(x, groups = 4, probs = seq(1/groups, 1 - 1/groups,
  1/groups), strata = NULL, quantile_list = list(na.rm = TRUE),
  cut_list = list(include.lowest = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_qgroups_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="create_qgroups_+3A_groups">groups</code></td>
<td>
<p>Numeric value, e.g. 3 for tertiles, 4 for quartiles, etc.</p>
</td></tr>
<tr><td><code id="create_qgroups_+3A_probs">probs</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="create_qgroups_+3A_strata">strata</code></td>
<td>
<p>Factor specifying subgroups to calculate quantiles within. For 
multivariable subgroups, you can use <code><a href="base.html#topic+interaction">interaction</a></code>.</p>
</td></tr>
<tr><td><code id="create_qgroups_+3A_quantile_list">quantile_list</code></td>
<td>
<p>Arguments to pass to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="create_qgroups_+3A_cut_list">cut_list</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In mtcars dataset, create tertiles for mpg
mtcars$mpg_tertiles &lt;- create_qgroups(mtcars$mpg, groups = 3)
table(mtcars$mpg_tertiles)

# Define tertile cutpoints separately for 4-, 6-, and 8-cylinder vehicles
mtcars$mpg_tertiles &lt;- create_qgroups(mtcars$mpg, groups = 3, strata = mtcars$cyl)
table(mtcars$mpg_tertiles)

# Works with dplyr functions like mutate
mtcars &lt;- mtcars %&gt;% 
  dplyr::mutate(mpg_tertiles = create_qgroups(mpg, groups = 3, strata = cyl))
table(mtcars$mpg_tertiles)

# Can embed in lm, glm, etc.
summary(lm(mpg ~ create_qgroups(wt), data = mtcars))

</code></pre>

<hr>
<h2 id='create_qgroups_svy'>Create Quantile Groups (Complex Survey Data)</h2><span id='topic+create_qgroups_svy'></span>

<h3>Description</h3>

<p>Complex survey version of <code><a href="#topic+create_qgroups">create_qgroups</a></code>. Relies heavily on the 
<strong>survey</strong> package [1,2].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_qgroups_svy(x, groups = 4, probs = seq(1/groups, 1 - 1/groups,
  1/groups), strata = NULL, design, svyquantile_list = list(na.rm =
  TRUE), cut_list = list(include.lowest = TRUE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_qgroups_svy_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_groups">groups</code></td>
<td>
<p>Numeric value, e.g. 3 for tertiles, 4 for quartiles, etc.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_probs">probs</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_strata">strata</code></td>
<td>
<p>Factor specifying subgroups to calculate quantiles within. For 
multivariable subgroups, you can use <code><a href="base.html#topic+interaction">interaction</a></code>.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_design">design</code></td>
<td>
<p>Survey design object.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_svyquantile_list">svyquantile_list</code></td>
<td>
<p>Arguments to pass to 
<code><a href="survey.html#topic+svyquantile">svyquantile</a></code>.</p>
</td></tr>
<tr><td><code id="create_qgroups_svy_+3A_cut_list">cut_list</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>References</h3>

<p>1. Therneau, T. (2015). A Package for Survival Analysis in S. R package
version 2.38. <a href="https://cran.r-project.org/package=survival">https://cran.r-project.org/package=survival</a>.
</p>
<p>2. Therneau, T.M. and Grambsch, P.M. (2000). Modeling Survival Data:
Extending the Cox Model. Springer, New York. ISBN 0-387-98784-3.
</p>

<hr>
<h2 id='cut_decreasing'>Cut with Decreasing Factor Levels</h2><span id='topic+cut_decreasing'></span>

<h3>Description</h3>

<p>Convenience function to get decreasing factor levels from <code><a href="base.html#topic+cut">cut</a></code>. 
Currently requires specifying <code>breaks</code> as vector of cutpoints rather 
than number of desired intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_decreasing(x, breaks, include.lowest = FALSE, right = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_decreasing_+3A_x">x</code>, <code id="cut_decreasing_+3A_breaks">breaks</code>, <code id="cut_decreasing_+3A_include.lowest">include.lowest</code>, <code id="cut_decreasing_+3A_right">right</code></td>
<td>
<p>See <code><a href="base.html#topic+cut">cut</a></code>.
specifying number of intervals is not currently supported).</p>
</td></tr>
<tr><td><code id="cut_decreasing_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In mtcars dataset, create 3 mpg groups
table(cut(mtcars$mpg, breaks = c(-Inf, 15, 20, Inf)))

# Repeat with cut_decreasing to get factor levels ordered from high to low. 
# To match cut here, need to specify right = FALSE
table(cut_decreasing(mtcars$mpg, breaks = c(Inf, 20, 15, -Inf), right = FALSE))

# You can specify breaks from low to high, but then include.lowest and right 
# arguments get confusing
table(cut_decreasing(mtcars$mpg, breaks = c(-Inf, 15, 20, Inf), right = TRUE))

</code></pre>

<hr>
<h2 id='dots_bars'>Plot Points +/- Error Bars</h2><span id='topic+dots_bars'></span>

<h3>Description</h3>

<p>Creates plot showing user-specified points (e.g. means, medians, regression 
coefficients) along with user-specified error bars (e.g. standard deviations, 
min/max, 95% confidence intervals).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dots_bars(y = NULL, bars = NULL, bars.lower = y - bars,
  bars.upper = y + bars, truth = NULL, group.labels = NULL,
  group.dividers = TRUE, subgroup.spacing = 1,
  subgroup.labels = NULL, subgroup.pch = NULL, subgroup.col = NULL,
  points.list = NULL, arrows.list = NULL, xaxis.list = NULL,
  yaxis.list = xaxis.list, abline.dividers.list = NULL,
  abline.truth.list = NULL, legend.list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dots_bars_+3A_y">y</code></td>
<td>
<p>Numeric vector of y-values for different groups, or numeric matrix 
where each column contains y-values for clustered subgroups within a group.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_bars">bars</code></td>
<td>
<p>Numeric vector or matrix (matching whichever type <code>y</code> is) 
specifying the length of the error bar for each group/subgroup (i.e. distance 
from point to one end of error bar).</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_bars.lower">bars.lower</code></td>
<td>
<p>Numeric vector or matrix (matching whichever type <code>y</code> 
is) specifying the position of the lower end of the error bar for each 
group/subgroup.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_bars.upper">bars.upper</code></td>
<td>
<p>Numeric vector or matrix (matching whichever type <code>y</code> 
is) specifying the position of the upper end of the error bar for each 
group/subgroup.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_truth">truth</code></td>
<td>
<p>Numeric value specifying true value of parameter being 
estimated. If specified, a horizontal reference line is added to the plot.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_group.labels">group.labels</code></td>
<td>
<p>Character vector of labels for the groups.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_group.dividers">group.dividers</code></td>
<td>
<p>Logical value for whether to add vertical lines 
distinguishing the groups.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_subgroup.spacing">subgroup.spacing</code></td>
<td>
<p>Numeric value controlling the amount of spacing 
between subgroups, with values &gt; 1 corresponding to more spacing.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_subgroup.labels">subgroup.labels</code></td>
<td>
<p>Character vector giving labels for the subgroups.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_subgroup.pch">subgroup.pch</code></td>
<td>
<p>Plotting symbol for different subgroups within each 
group.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_subgroup.col">subgroup.col</code></td>
<td>
<p>Plotting color for different subgroups within each group.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_points.list">points.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_arrows.list">arrows.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+arrows">arrows</a></code>.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_xaxis.list">xaxis.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+axis">axis</a></code> for x-axis.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_yaxis.list">yaxis.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+axis">axis</a></code> for y-axis.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_abline.dividers.list">abline.dividers.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+abline">abline</a></code> for group dividers. Only used if 
<code>group.dividers = TRUE</code>.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_abline.truth.list">abline.truth.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+abline">abline</a></code> for horizontal line at true value of 
parameter. Only used if <code>truth</code> is specified.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_legend.list">legend.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="dots_bars_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="graphics.html#topic+plot">plot</a></code> 
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot showing points +/- error bars across groups/subgroups.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 100 values from normal distributions with different means, and 
# graph mean +/- standard deviation across groups 
dat &lt;- cbind(rnorm(100, 2), rnorm(100, 2.5), rnorm(100, 1.75))
means &lt;- apply(dat, 2, mean)
sds &lt;- apply(dat, 2, sd)
fig1 &lt;- dots_bars(y = means, bars = sds, main = "Mean +/- SD by Group",
                  ylab = "Mean +/- SD")
                  
# Simulate BMI values for males and females in 3 different age groups, and 
# graph mean +/- 95% CI
sex &lt;- as.factor(c(rep("Male", 300), rep("Female", 300)))
age &lt;- as.factor(rep(c("Young", "Middle", "Old"), 2))
bmi &lt;- c(rnorm(100, 25, 4), rnorm(100, 26, 4.25), rnorm(100, 27, 4.5),
         rnorm(100, 26.5, 4.5), rnorm(100, 27.25, 4.75), rnorm(100, 28, 5))
dat &lt;- data.frame(sex = sex, age = age, bmi = bmi)
means &lt;- tapply(dat$bmi, dat[, c("sex", "age")], mean)
ci.lower &lt;- tapply(dat$bmi, dat[, c("sex", "age")],
                   function(x) t.test(x)$conf.int[1])
ci.upper &lt;- tapply(dat$bmi, dat[, c("sex", "age")],
                   function(x) t.test(x)$conf.int[2])
fig2 &lt;- dots_bars(y = means, bars.lower = ci.lower, bars.upper = ci.upper,
                  main = "BMI by Sex and Age",
                  ylab = "BMI (mean +/- CI)",
                  xlab = "Age group")

</code></pre>

<hr>
<h2 id='expand_grid'>Similar to expand.grid but with Sequences Reversed and Ability to Treat 
Variables as Sets</h2><span id='topic+expand_grid'></span>

<h3>Description</h3>

<p>Loops over the last argument, then the second-last, and so on. It should be 
faster than <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_grid(..., together = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_grid_+3A_...">...</code></td>
<td>
<p>Vectors you want all combinations of.</p>
</td></tr>
<tr><td><code id="expand_grid_+3A_together">together</code></td>
<td>
<p>Data frame of vectors, where each row is a set of parameter 
values that are always kept together.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple example of expand.grid vs. expand_grid
expand.grid(x = c("a", "b", "c"), y = c(1, 2), z = c(TRUE, FALSE))
expand_grid(x = c("a", "b", "c"), y = c(1, 2), z = c(TRUE, FALSE))

# How to keep certain variables together
expand_grid(x = 1: 5, 
            together = data.frame(y = c("1a", "2a"), z = c("1b", "2b")))

</code></pre>

<hr>
<h2 id='gammareg'>Constant-Scale Gamma Model for Y vs. Covariates with Y Potentially Subject 
to Multiplicative Lognormal Errors</h2><span id='topic+gammareg'></span>

<h3>Description</h3>

<p>Uses maximum likelihood to fit
Y|<strong>X</strong> ~ Gamma(exp(beta_0 + <strong>beta_x</strong>^T <strong>X</strong>), b), with the
shape-scale (as opposed to shape-rate) parameterization described in
<code><a href="stats.html#topic+GammaDist">GammaDist</a></code>. Y can be precisely measured or subject to 
multiplicative mean-1 lognormal errors, in which case replicates can be 
incorporated by specifying <code>y</code> as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammareg(y, x = NULL, merror = FALSE, integrate_tol = 1e-08,
  integrate_tol_hessian = integrate_tol, estimate_var = TRUE,
  fix_posdef = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammareg_+3A_y">y</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix. If <code>NULL</code>, model reduces to marginal
Gamma model Y ~ Gamma(exp(beta_0), b).</p>
</td></tr>
<tr><td><code id="gammareg_+3A_merror">merror</code></td>
<td>
<p>Logical value for whether to model multiplicative lognormal 
measurement errors in Y.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_integrate_tol">integrate_tol</code></td>
<td>
<p>Numeric value specifying the <code>tol</code> input to
<code><a href="cubature.html#topic+hcubature">hcubature</a></code>. Only used if <code>merror = TRUE</code>.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_integrate_tol_hessian">integrate_tol_hessian</code></td>
<td>
<p>Same as <code>integrate_tol</code>, but for use when
estimating the Hessian matrix only. Sometimes more precise integration
(i.e. smaller tolerance) than used for maximizing the likelihood helps
prevent cases where the inverse Hessian is not positive definite.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_fix_posdef">fix_posdef</code></td>
<td>
<p>Logical value for whether to repeatedly reduce
<code>integrate_tol_hessian</code> by factor of 5 and re-estimate Hessian to try
to avoid non-positive definite variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="gammareg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>


<hr>
<h2 id='get_mse'>Extract Mean Squared Error (MSE) from Fitted Regression Model</h2><span id='topic+get_mse'></span>

<h3>Description</h3>

<p>The MSE, defined as the sum of the squared residuals divided by <code>n-p</code> 
(<code>n</code> = number of observations, <code>p</code> = number of regression 
coefficients), is an unbiased estimator for the error variance in a linear 
regression model. This is a convenience function that extracts the MSE from 
a fitted <code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code> object. The code is 
<code>rev(anova(model.fit)$"Mean Sq")[1]</code> if <code>model.fit</code> is a 
<code><a href="stats.html#topic+lm">lm</a></code> object and 
<code>sum(model.fit$residuals^2) / model.fit$df.residual</code> if <code>model.fit</code> 
is a <code><a href="stats.html#topic+glm">glm</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mse(model.fit, var.estimate = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mse_+3A_model.fit">model.fit</code></td>
<td>
<p>Fitted regression model returned from 
<code><a href="stats.html#topic+lm">lm</a></code> or <code><a href="stats.html#topic+glm">glm</a></code>.</p>
</td></tr>
<tr><td><code id="get_mse_+3A_var.estimate">var.estimate</code></td>
<td>
<p>If <code>TRUE</code>, function returns a variance estimate for 
the error variance, defined as <code>2 * MSE^2 / (n - p)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>var.estimate = FALSE</code>, numeric value indicating the MSE; if 
<code>var.estimate = TRUE</code>, named numeric vector indicating both the MSE and 
a variance estimate for the error variance.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate 100 values: Y = 0.5 + 1.25 X + e, e ~ N(0, 1)
set.seed(123)
x &lt;- rnorm(100)
y &lt;- 0.5 + 1.25 * x + rnorm(100, sd = 1)

# Fit regression model using lm and using glm
lm.fit &lt;- lm(y ~ x)
glm.fit &lt;- glm(y ~ x)

# Extract MSE from lm.fit and glm.fit
get_mse(lm.fit)
get_mse(glm.fit)

</code></pre>

<hr>
<h2 id='headtail'>Return the First and Last Part of an Object</h2><span id='topic+headtail'></span>

<h3>Description</h3>

<p>Simply <code><a href="utils.html#topic+head">head</a></code> and <code><a href="utils.html#topic+head">tail</a></code> 
combined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>headtail(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="headtail_+3A_x">x</code></td>
<td>
<p>Input object.</p>
</td></tr>
<tr><td><code id="headtail_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="utils.html#topic+head">head</a></code> and 
<code><a href="utils.html#topic+head">tail</a></code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same class as <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from N(0, 1), sort, and look at smallest and largest 3 values
x &lt;- rnorm(1000)
x.sorted &lt;- sort(x)
headtail(x.sorted, 3)

</code></pre>

<hr>
<h2 id='histo'>Histogram with Added Options</h2><span id='topic+histo'></span>

<h3>Description</h3>

<p>Similar to base R function <code><a href="graphics.html#topic+hist">hist</a></code>, but with two added
features: (1) Can overlay one or more fitted probability density/mass
functions (PDFs/PMFs) for any univariate distribution supported in R (see
<code><a href="stats.html#topic+Distributions">Distributions</a></code>); and (2) Can generate more of a barplot
type histogram, where each possible value gets its own bin centered over its
value (useful for discrete variables with not too many possible values).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histo(x, dis = "none", dis_shift = NULL, integer_breaks = NULL,
  colors = rep("black", length(dis)), lty = 1:length(dis),
  legend_form = ifelse(length(dis) == 1, 0, 1), aic_decimals = 1,
  points_list = NULL, axis_list = NULL, legend_list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="histo_+3A_x">x</code></td>
<td>
<p>Numeric vector of values.</p>
</td></tr>
<tr><td><code id="histo_+3A_dis">dis</code></td>
<td>
<p>Character vector indicating which distributions should be used to
add fitted PDF/PMF to the histogram. If not <code>"none"</code>, choices for each
element are:
</p>
<p><code>"beta"</code>
</p>
<p><code>"binom"</code> (must specify <code>size</code>)
</p>
<p><code>"cauchy"</code>
</p>
<p><code>"chisq"</code>
</p>
<p><code>"exp"</code>
</p>
<p><code>"f"</code>
</p>
<p><code>"gamma"</code>
</p>
<p><code>"geom"</code>
</p>
<p><code>"hyper"</code> (must specify total number of balls in urn, <code>N</code>, and
number of balls drawn each time, <code>k</code>)
</p>
<p><code>"lnorm"</code>
</p>
<p><code>"nbinom"</code> (must specify <code>size</code>)
</p>
<p><code>"norm"</code>
</p>
<p><code>"pois"</code>,
</p>
<p><code>"t"</code>
</p>
<p><code>"unif"</code>
</p>
<p><code>"weibull"</code></p>
</td></tr>
<tr><td><code id="histo_+3A_dis_shift">dis_shift</code></td>
<td>
<p>Numeric value for shifting the fitted PDF/PMF along the
x-axis of the histogram.</p>
</td></tr>
<tr><td><code id="histo_+3A_integer_breaks">integer_breaks</code></td>
<td>
<p>If <code>TRUE</code>, integers covering the range of <code>x</code>
are used for breaks, so there is one bin for each integer. Useful for
discrete distributions that don't take on too many unique values.</p>
</td></tr>
<tr><td><code id="histo_+3A_colors">colors</code></td>
<td>
<p>Character vector of colors for each PDF/PMF.</p>
</td></tr>
<tr><td><code id="histo_+3A_lty">lty</code></td>
<td>
<p>Integer vector specifying line types for each curve.</p>
</td></tr>
<tr><td><code id="histo_+3A_legend_form">legend_form</code></td>
<td>
<p>Integer value controlling what type of legend to include.
Choices are 0 for no legend, 1 for legend naming each distribution, and 2 for
legend naming each distribution and the corresponding AIC.</p>
</td></tr>
<tr><td><code id="histo_+3A_aic_decimals">aic_decimals</code></td>
<td>
<p>Integer value for number of decimals for AIC.</p>
</td></tr>
<tr><td><code id="histo_+3A_points_list">points_list</code></td>
<td>
<p>Optional list of inputs to pass to
<code><a href="graphics.html#topic+points">points</a></code> function, which is used to add the fitted
PDF/PMF.</p>
</td></tr>
<tr><td><code id="histo_+3A_axis_list">axis_list</code></td>
<td>
<p>Optional list of inputs to pass to
<code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
<tr><td><code id="histo_+3A_legend_list">legend_list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="histo_+3A_...">...</code></td>
<td>
<p>May include arguments to pass to <code><a href="graphics.html#topic+hist">hist</a></code>
and/or parameter values needed for certain distributions (<code>size</code> if
<code>dis = "binom"</code> or <code>dis = "nbinom"</code>, <code>N</code> and <code>k</code> if
<code>dis = "hyper"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>x</code> takes on whole numbers, you typically want to set
<code>dis_shift = -0.5</code> if <code>right = TRUE</code>
(<code><a href="graphics.html#topic+hist">hist</a></code>'s default) and <code>dis_shift = 0.5</code> if
<code>right = FALSE</code>. The function will do this internally by default.
</p>
<p>To illustrate, suppose a particular bin represents <code>(7, 10]</code>. Its
midpoint will be at <code>x = 8.5</code> on the graph. But if input values are
whole numbers, this bin really only includes values of 8, 9, and 10, which
have a mean of 9. So you really want <code>f(9)</code> to appear at <code>x = 8.5</code>.
This requires shifting the curve to the left 0.5 units, i.e. setting
<code>dis_shift = -0.5</code>.
</p>
<p>When <code>x</code> takes on whole numbers with not too many unique values, you may
want the histogram to show one bin for each integer. You can do this by
setting <code>integer_breaks = TRUE</code>. By default, the function sets
<code>integer_breaks = TRUE</code> if <code>x</code> contains whole numbers with 10 or
fewer unique values.
</p>


<h3>Value</h3>

<p>Histogram with fitted PDFs/PMFs if requested.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sample 10,000 Poisson(2) values and commpare default hist vs. histo
set.seed(123)
x &lt;- rpois(n = 10000, lambda = 2)
par(mfrow = c(1, 2))
hist(x, main = "hist function")
histo(x, main = "histo function")

# Sample 10,000 lognormal(0, 0.35) values. Create histogram with curves
# showing fitted lognormal, normal, and Gamma PDFs.
set.seed(123)
x &lt;- rlnorm(n = 10000, meanlog = 0, sdlog = 0.35)
par(mfrow = c(1, 1))
histo(x, c("lnorm", "norm", "gamma"), main = "X ~ Lognormal(0, 0.35)")

# Generate 10,000 Binomial(8, 0.25) values. Create histogram, specifying
# size = 5, with blue line/points showing fitted PMF.
set.seed(123)
x &lt;- rbinom(n = 10000, size = 5, prob = 0.25)
par(mfrow = c(1, 1))
histo(x, dis = "binom", size = 5, colors = "blue", 
      points_list = list(type = "b"))

</code></pre>

<hr>
<h2 id='inside'>Check Whether Numeric Value Falls Inside Two Other Numeric Values</h2><span id='topic+inside'></span>

<h3>Description</h3>

<p>Returns <code>TRUE</code> if <code>x</code> falls inside range defined by <code>ends</code>
and <code>FALSE</code> otherwise. Also works for multiple sets of values and/or
endpoints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside(x, ends, inclusive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inside_+3A_x">x</code></td>
<td>
<p>Numeric value or vector of numeric values.</p>
</td></tr>
<tr><td><code id="inside_+3A_ends">ends</code></td>
<td>
<p>Numeric vector of length 2 specifying the endpoints for the 
interval, or a 2-column numeric matrix where each row specifies a pair of 
endpoints.</p>
</td></tr>
<tr><td><code id="inside_+3A_inclusive">inclusive</code></td>
<td>
<p>Logical value indicating whether endpoints should be 
included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value or vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check whether 2 is inside [0, 2.5]
inside(1, c(0, 2.5))

# Check whether 2 and 3 are inside (0, 3)
inside(c(2, 3), c(0, 3), inclusive = FALSE)

# Check whether 1 is inside [1, 2] and [3, 4]
inside(1, rbind(c(1, 2), c(3, 4)))

</code></pre>

<hr>
<h2 id='interval_groups'>Split Continuous Variable into Equal-Width Groups</h2><span id='topic+interval_groups'></span>

<h3>Description</h3>

<p>Splits a continuous variable into equal-width groups. Useful for assessing
linearity in regression models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interval_groups(x, groups = 5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="interval_groups_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="interval_groups_+3A_groups">groups</code></td>
<td>
<p>Numeric value specifying number of groups to create.</p>
</td></tr>
<tr><td><code id="interval_groups_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert values from N(0, 1) into 6 equal-width groups
x &lt;- rnorm(1000)
groups &lt;- interval_groups(x, 6)
table(groups)

# Use interval_groups to detect non-linearity
set.seed(123)
x &lt;- rnorm(1000)
y &lt;- 1.5 + 1.25 * x + 0.25 * x^2 + rnorm(1000)
plot(tapply(y, interval_groups(x), mean))

</code></pre>

<hr>
<h2 id='iterate'>Iterate Function Over All Combinations of User-Specified Inputs, Potentially 
Multiple Times</h2><span id='topic+iterate'></span>

<h3>Description</h3>

<p>Same idea as <strong>purrr</strong>::<em>pmap</em>, but with some different 
functionality. It can runs all combinations of vector-valued arguments in 
<code>...</code> or the 1st set, 2nd set, and so forth, and multiple trials can be 
run for each scenario, which can be useful for simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate(f, ..., all_combinations = TRUE, fix = NULL, trials = 1,
  varnames = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="iterate_+3A_f">f</code></td>
<td>
<p>A function.</p>
</td></tr>
<tr><td><code id="iterate_+3A_...">...</code></td>
<td>
<p>Arguments to <code>f</code>, any of which can be vector-valued.</p>
</td></tr>
<tr><td><code id="iterate_+3A_all_combinations">all_combinations</code></td>
<td>
<p>Logical value for whether to iterate over all 
combinations of arguments in <code>...</code>, or just use the first set of 
elements, then the second, and so on.</p>
</td></tr>
<tr><td><code id="iterate_+3A_fix">fix</code></td>
<td>
<p>List of arguments to <code>f</code> to hold fixed rather than loop over.</p>
</td></tr>
<tr><td><code id="iterate_+3A_trials">trials</code></td>
<td>
<p>Numeric value.</p>
</td></tr>
<tr><td><code id="iterate_+3A_varnames">varnames</code></td>
<td>
<p>Character vector of names for values that <code>f</code> returns, 
to avoid generic labels (V1, V2, ...).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Define function to generate data from N(mu, sigsq) and perform t-test.
f &lt;- function(n = 100, mu = 0, sigsq = 1, alpha = 0.05) {
  x &lt;- rnorm(n = n, mean = mu, sd = sqrt(sigsq))
  fit &lt;- t.test(x = x, alpha = alpha)
  return(list(t = fit$statistic, p = fit$p.value))
}

# Call f once for various sample sizes and means
f %&gt;% iterate(n = c(100, 500), mu = c(0.1, 0.25))

# Run 100 trials for each scenario and calculate empirical power
f %&gt;% iterate(n = c(100, 500), mu = c(0.1, 0.25), trials = 100) %&gt;%
  group_by(n, mu) %&gt;%
  summarise(mean(p &lt; 0.05))

</code></pre>

<hr>
<h2 id='list_override'>Add Elements of Second List to First List, Replacing Elements with Same Name</h2><span id='topic+list_override'></span>

<h3>Description</h3>

<p>Adds each element of <code>list2</code> to <code>list1</code>, overriding any elements of 
the same name. Similar to <code>modifyList</code> function in 
<span class="pkg">utils</span> package, but either list can be <code>NULL</code>. Useful for 
<code><a href="base.html#topic+do.call">do.call</a></code> statements, when you want to combine a list of 
default inputs with a list of user-specified inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_override(list1, list2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_override_+3A_list1">list1</code></td>
<td>
<p>Initial list that has some number of named elements. Can be 
<code>NULL</code> or an empty list.</p>
</td></tr>
<tr><td><code id="list_override_+3A_list2">list2</code></td>
<td>
<p>List with named elements that will be added to <code>list1</code>, 
replacing any elements with the same name. Can be <code>NULL</code> or an empty 
list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing the named elements initially in <code>list1</code> and not 
in <code>list2</code>, any additional named elements in <code>list2</code>, and any named 
elements in <code>list1</code> that were replaced by elements of the same name in
<code>list2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create list that has default inputs to the plot function
list.defaults &lt;- list(x = 1: 5, y = 1: 5, type = "l", lty = 1)

# Create list of user-specified inputs to the plot function
list.user &lt;- list(main = "A Straight Line", lty = 2, lwd = 1.25)

# Combine the two lists into one, giving priority to list.user
list.combined &lt;- list_override(list.defaults, list.user)

# Plot data using do.call
do.call(plot, list.combined)

</code></pre>

<hr>
<h2 id='logit_prob'>Convert Logit to Probability</h2><span id='topic+logit_prob'></span>

<h3>Description</h3>

<p>Defined as: <code>exp_x &lt;- exp(x); out &lt;- exp_x / (1 + exp_x)</code>. This 2-step 
approach is faster than <code>exp(x) / (1 + exp(x))</code> because the exponentials 
only have to be calculated once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit_prob(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_prob_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>

<hr>
<h2 id='lognormalreg'>Linear Regression of log(Y) vs. Covariates with Y Potentially Subject to 
Multiplicative Lognormal Errors</h2><span id='topic+lognormalreg'></span>

<h3>Description</h3>

<p>Uses maximum likelihood to fit
Y|<strong>X</strong> ~ Lognormal(beta_0 + <strong>beta_x</strong>^T <strong>X</strong>, sigsq). Y 
can be precisely measured or subject to multiplicative mean-1 lognormal 
errors, in which case replicates can be incorporated by specifying <code>y</code> 
as a list).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lognormalreg(y, x = NULL, merror = FALSE, estimate_var = TRUE,
  fix_posdef = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lognormalreg_+3A_y">y</code></td>
<td>
<p>Numeric vector or list.</p>
</td></tr>
<tr><td><code id="lognormalreg_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix. If <code>NULL</code>, model reduces to marginal
lognormal model Y ~ Lognormal(beta_0, sigsq).</p>
</td></tr>
<tr><td><code id="lognormalreg_+3A_merror">merror</code></td>
<td>
<p>Logical value for whether to model multiplicative lognormal 
measurement errors in Y.</p>
</td></tr>
<tr><td><code id="lognormalreg_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="lognormalreg_+3A_fix_posdef">fix_posdef</code></td>
<td>
<p>Logical value for whether to repeatedly reduce
<code>integrate_tol_hessian</code> by factor of 5 and re-estimate Hessian to try
to avoid non-positive definite variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="lognormalreg_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>


<hr>
<h2 id='logodds_graph'>Graph Log-Odds of Binary Variable Across A Grouping Variable</h2><span id='topic+logodds_graph'></span>

<h3>Description</h3>

<p>Creates plot showing sample log-odds of binary Y variable across levels of a
grouping variable, with customizable error bars. Observations with missing 
values for <code>y</code> and/or <code>group</code> are dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logodds_graph(y, group, error.bars = "none", alpha = 0.05,
  p.legend = "chi", plot.list = NULL, lines.list = NULL,
  axis.list = NULL, legend.list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logodds_graph_+3A_y">y</code></td>
<td>
<p>Vector of values for binary response variable. Must take on 2 
values, but can be any type (e.g. numeric, character, factor, logical). 
Function plots log-odds of second value returned by <code>table(y)</code>.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_group">group</code></td>
<td>
<p>Vector of values indicating what group each <code>y</code> observation 
belongs to. Function plots group levels across x-axis in same order as 
<code>table(group)</code>.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_error.bars">error.bars</code></td>
<td>
<p>Character string indicating what the error bars should 
represent. Possible values are <code>"exact.ci"</code> for exact 95% confidence 
interval based on binomial distribution, <code>"z.ci"</code> for approximate 95% 
confidence interval based on Z distribution, and <code>"none"</code> for no error 
bars.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value indicating what alpha should be set to for 
confidence intervals. Only used if <code>error.bars</code> is <code>"exact.ci"</code> or 
<code>"z.ci"</code>.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_p.legend">p.legend</code></td>
<td>
<p>Character string controlling what p-value is printed in a 
legend. Possible values are <code>"chi"</code> for Chi-square test of association, 
<code>"fisher"</code> for Fisher's exact test, and <code>"none"</code> for no legend at 
all.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_plot.list">plot.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_lines.list">lines.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_axis.list">axis.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+axis">axis</a></code> function.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_legend.list">legend.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+legend">legend</a></code> function.</p>
</td></tr>
<tr><td><code id="logodds_graph_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+chisq.test">chisq.test</a></code> or
<code><a href="stats.html#topic+fisher.test">fisher.test</a></code> functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot showing log-odds of <code>y</code> across levels of <code>group</code>.
</p>

<hr>
<h2 id='max_n'>Maximum of Numeric Values</h2><span id='topic+max_n'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than <code>max</code> for large 
numeric vectors/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_n(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="max_n_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For large objects, max_n is faster than max
x &lt;- rnorm(100000)
max(x) == max_n(x)
benchmark(max(x), max_n(x), replications = 1000)

# For smaller objects, max_n is slower than max
x &lt;- rnorm(100)
max(x) == max_n(x)
benchmark(max(x), max_n(x), replications = 1000)

</code></pre>

<hr>
<h2 id='mean_i'>Mean of Integer Values</h2><span id='topic+mean_i'></span>

<h3>Description</h3>

<p>Written in C++, this function runs faster than <code><a href="base.html#topic+mean">mean</a></code> for 
large integer vectors/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_i(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mean_i_+3A_x">x</code></td>
<td>
<p>Integer vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For very large integer objects, sum_i is faster than sum
x &lt;- rpois(100000, lambda = 5)
mean(x) == mean_i(x)
benchmark(mean(x), mean_i(x), replications = 1000)

# For smaller integer objects, sum_i is slower than sum 
x &lt;- rpois(1000, lambda = 5)
mean(x) == mean_i(x)
benchmark(mean(x), mean_i(x), replications = 1000)

</code></pre>

<hr>
<h2 id='means_graph'>Graph Means Across a Grouping Variable</h2><span id='topic+means_graph'></span>

<h3>Description</h3>

<p>Creates plot showing mean of Y variable across levels of a grouping variable,
with customizable error bars. Observations with missing values for <code>y</code> 
and/or <code>group</code> are dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>means_graph(y, group, error.bars = "t.ci", alpha = 0.05,
  p.legend = TRUE, plot.list = NULL, lines.list = NULL,
  axis.list = NULL, legend.list = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="means_graph_+3A_y">y</code></td>
<td>
<p>Numeric vector of values for the continuous variable.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_group">group</code></td>
<td>
<p>Vector of values indicating what group each <code>y</code> observation 
belongs to. Function plots group levels across x-axis in same order as 
<code>table(group)</code>.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_error.bars">error.bars</code></td>
<td>
<p>Character string indicating what the error bars should 
represent. Possible values are <code>"sd"</code> for +/- one standard deviation, 
<code>"se"</code> for +/- one standard error, <code>"t.ci"</code> for 95% confidence 
interval based on t distribution, <code>"z.ci"</code> for 95% confidence interval 
based on Z distribution, and <code>"none"</code> for no error bars.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value indicating what alpha should be set to for 
confidence intervals. Only used if <code>error.bars</code> is <code>"t.ci"</code> or 
<code>"z.ci"</code>.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_p.legend">p.legend</code></td>
<td>
<p>If <code>TRUE</code>, p-value (from <code><a href="stats.html#topic+t.test">t.test</a></code> 
function if group has 2 levels, otherwise <code><a href="stats.html#topic+aov">aov</a></code> function) 
is printed in a legend.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_plot.list">plot.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+plot">plot</a></code> function.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_lines.list">lines.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_axis.list">axis.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+axis">axis</a></code> function.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_legend.list">legend.list</code></td>
<td>
<p>Optional list of inputs to pass to 
<code><a href="graphics.html#topic+legend">legend</a></code> function.</p>
</td></tr>
<tr><td><code id="means_graph_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+t.test">t.test</a></code> or 
<code><a href="stats.html#topic+aov">aov</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot showing mean of <code>y</code> across levels of <code>group</code>.
</p>

<hr>
<h2 id='min_n'>Minimum of Numeric Values</h2><span id='topic+min_n'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than <code>min</code> for large 
numeric vectors/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_n(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="min_n_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For large objects, min_n is faster than min
x &lt;- rnorm(100000)
min(x) == min_n(x)
benchmark(min(x), min_n(x), replications = 1000)

# For smaller objects, min_n is slower than min
x &lt;- rnorm(100)
min(x) == min_n(x)
benchmark(min(x), min_n(x), replications = 20000)

</code></pre>

<hr>
<h2 id='mle_gamma'>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Gamma(alpha, beta)</h2><span id='topic+mle_gamma'></span>

<h3>Description</h3>

<p>Performs maximization via <code><a href="stats.html#topic+nlminb">nlminb</a></code>. alpha and beta 
correspond to the shape and scale (not shape and rate) parameters described 
in <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_gamma(x, alpha = NULL, beta = NULL, estimate_var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_gamma_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="mle_gamma_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying known alpha.</p>
</td></tr>
<tr><td><code id="mle_gamma_+3A_beta">beta</code></td>
<td>
<p>Numeric value specifying known beta.</p>
</td></tr>
<tr><td><code id="mle_gamma_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="mle_gamma_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Generate 1,000 values from Gamma(0.5, 1) and estimate alpha and beta
set.seed(123)
x &lt;- rgamma(1000, shape = 0.5, scale = 1)
mle_gamma(x)


</code></pre>

<hr>
<h2 id='mle_gamma_lnorm'>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Gamma(alpha, beta) Lognormal(mu, sigsq)</h2><span id='topic+mle_gamma_lnorm'></span>

<h3>Description</h3>

<p>Each observation is assumed to be the product of a Gamma(alpha, beta) and 
Lognormal(mu, sigsq) random variable. Performs maximization via 
<code><a href="stats.html#topic+nlminb">nlminb</a></code>. alpha and beta correspond to the shape and scale 
(not shape and rate) parameters described in <code><a href="stats.html#topic+GammaDist">GammaDist</a></code>, 
and mu and sigsq correspond to meanlog and sdlog^2 in 
<code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_gamma_lnorm(x, gamma_mean1 = FALSE, lnorm_mean1 = TRUE,
  integrate_tol = 1e-08, estimate_var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_gamma_lnorm_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="mle_gamma_lnorm_+3A_gamma_mean1">gamma_mean1</code></td>
<td>
<p>Whether to use restriction that the Gamma variable is 
mean-1.</p>
</td></tr>
<tr><td><code id="mle_gamma_lnorm_+3A_lnorm_mean1">lnorm_mean1</code></td>
<td>
<p>Whether to use restriction that the lognormal variable is 
mean-1.</p>
</td></tr>
<tr><td><code id="mle_gamma_lnorm_+3A_integrate_tol">integrate_tol</code></td>
<td>
<p>Numeric value specifying the <code>tol</code> input to
<code><a href="cubature.html#topic+hcubature">hcubature</a></code>.</p>
</td></tr>
<tr><td><code id="mle_gamma_lnorm_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="mle_gamma_lnorm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Generate 1,000 values from Gamma(0.5, 1) x Lognormal(-1.5/2, 1.5) and 
# estimate parameters
## Not run: 
set.seed(123)
x &lt;- rgamma(1000, 0.5, 1) * rlnorm(1000, -1.5/2, sqrt(1.5))
mle_gamma_lnorm(x, control = list(trace = 1))

## End(Not run)


</code></pre>

<hr>
<h2 id='mle_lnorm'>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Lognormal(mu, sigsq)</h2><span id='topic+mle_lnorm'></span>

<h3>Description</h3>

<p>Performs maximization via <code><a href="stats.html#topic+nlminb">nlminb</a></code>. mu and sigsq 
correspond to meanlog and sdlog^2 in <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_lnorm(x, mu = NULL, sigsq = NULL, estimate_var = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_lnorm_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="mle_lnorm_+3A_mu">mu</code></td>
<td>
<p>Numeric value specifying known mu.</p>
</td></tr>
<tr><td><code id="mle_lnorm_+3A_sigsq">sigsq</code></td>
<td>
<p>Numeric value specifying known sigsq.</p>
</td></tr>
<tr><td><code id="mle_lnorm_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="mle_lnorm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Generate 1,000 values from Lognormal(0.5, 1) and estimate mu and sigsq
set.seed(123)
x &lt;- rlnorm(1000, meanlog = 0.5, sdlog = sqrt(1))
mle_lnorm(x)


</code></pre>

<hr>
<h2 id='mle_lnorm_lnorm'>Maximum Likelihood Estimation for X[1], ..., X[n] ~ Lognormal(mu1, sigsq1) 
Lognormal(mu2, sigsq2)</h2><span id='topic+mle_lnorm_lnorm'></span>

<h3>Description</h3>

<p>Each observation is assumed to be the product of a Lognormal(mu1, sigsq1) and 
Lognormal(mu2, sigsq2) random variable, with mu2 and sigsq2 known. Performs 
maximization via <code><a href="stats.html#topic+nlminb">nlminb</a></code>. mu and sigsq correspond to 
meanlog and sdlog^2 in <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_lnorm_lnorm(x, mu2 = NULL, sigsq2 = NULL, estimate_var = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_lnorm_lnorm_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="mle_lnorm_lnorm_+3A_mu2">mu2</code></td>
<td>
<p>Numeric value specifying known mu2.</p>
</td></tr>
<tr><td><code id="mle_lnorm_lnorm_+3A_sigsq2">sigsq2</code></td>
<td>
<p>Numeric value specifying known sigsq2.</p>
</td></tr>
<tr><td><code id="mle_lnorm_lnorm_+3A_estimate_var">estimate_var</code></td>
<td>
<p>Logical value for whether to return Hessian-based
variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="mle_lnorm_lnorm_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing:
</p>

<ol>
<li><p> Numeric vector of parameter estimates.
</p>
</li>
<li><p> Variance-covariance matrix (if <code>estimate_var = TRUE</code>).
</p>
</li>
<li><p> Returned <code><a href="stats.html#topic+nlminb">nlminb</a></code> object from maximizing the
log-likelihood function.
</p>
</li>
<li><p> Akaike information criterion (AIC).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># Generate 1,000 values from Lognormal(0.5, 1) x Lognormal(0.75, 1.5) and 
# estimate parameters based on known mu and sigsq for one of them
set.seed(123)
x &lt;- rlnorm(1000, 0.5, sqrt(1)) * rlnorm(1000, 0.75, sqrt(1.5))
mle_lnorm_lnorm(x, mu2 = 0.75, sigsq2 = 1.5)


</code></pre>

<hr>
<h2 id='moving_mean'>Moving Averages</h2><span id='topic+moving_mean'></span>

<h3>Description</h3>

<p>Calculates moving averages or maximum moving average. For optimal speed, use 
<code>integer = TRUE</code> if <code>x</code> is an integer vector and 
<code>integer = FALSE</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moving_mean(x, window, integer = FALSE, max = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="moving_mean_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector.</p>
</td></tr>
<tr><td><code id="moving_mean_+3A_window">window</code></td>
<td>
<p>Integer value specifying window length.</p>
</td></tr>
<tr><td><code id="moving_mean_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector.</p>
</td></tr>
<tr><td><code id="moving_mean_+3A_max">max</code></td>
<td>
<p>Logical value for whether to return maximum moving average (as 
opposed to vector of moving averages).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or vector depending on <code>max</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 5-unit moving average for integer vector of length 10
x &lt;- rpois(10, lambda = 3)
moving_mean(x, 5)


</code></pre>

<hr>
<h2 id='n_2t_equal'>Calculate Per-Group Sample Size for Two-Sample Equal Variance T-Test</h2><span id='topic+n_2t_equal'></span>

<h3>Description</h3>

<p>Same idea as <code><a href="stats.html#topic+power.t.test">power.t.test</a></code>. Less flexible, but faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_2t_equal(d, sigsq, alpha = 0.05, beta = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_2t_equal_+3A_d">d</code></td>
<td>
<p>Numeric value specifying true difference in group means.</p>
</td></tr>
<tr><td><code id="n_2t_equal_+3A_sigsq">sigsq</code></td>
<td>
<p>Numeric value specifying the variance of observations.</p>
</td></tr>
<tr><td><code id="n_2t_equal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying type-1 error rate.</p>
</td></tr>
<tr><td><code id="n_2t_equal_+3A_beta">beta</code></td>
<td>
<p>Numeric value specifying type-2 error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value indicating per-group sample size, rounded up to the
nearest whole number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Per-group sample size for 90% power to detect difference of 0.2 with
# sigsq = 1
n_2t_equal(d = 0.2, sigsq = 1, beta = 0.1)


</code></pre>

<hr>
<h2 id='n_2t_unequal'>Calculate Per-Group Sample Size for Two-Sample Unequal Variance T-Test</h2><span id='topic+n_2t_unequal'></span>

<h3>Description</h3>

<p>Unequal variance version of <code><a href="#topic+n_2t_equal">n_2t_equal</a></code>. Assumes an equal sample
size for both groups, which is actually not optimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_2t_unequal(d, sigsq1, sigsq2, alpha = 0.05, beta = 0.2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_2t_unequal_+3A_d">d</code></td>
<td>
<p>Numeric value specifying true difference in group means.</p>
</td></tr>
<tr><td><code id="n_2t_unequal_+3A_sigsq1">sigsq1</code>, <code id="n_2t_unequal_+3A_sigsq2">sigsq2</code></td>
<td>
<p>Numeric value specifying the variance of observations in each group.</p>
</td></tr>
<tr><td><code id="n_2t_unequal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying type-1 error rate.</p>
</td></tr>
<tr><td><code id="n_2t_unequal_+3A_beta">beta</code></td>
<td>
<p>Numeric value specifying type-2 error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value indicating per-group sample size, rounded up to the
nearest whole number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Per-group sample size for 90% power to detect difference of 0.2 with
# sigsq's of 1 and 1.25
n_2t_unequal(d = 0.2, sigsq1 = 1, sigsq2 = 1.25, beta = 0.1)


</code></pre>

<hr>
<h2 id='odds_prob'>Convert Odds to Probability</h2><span id='topic+odds_prob'></span>

<h3>Description</h3>

<p>Defined simply as <code>log(x / (x + 1))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odds_prob(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="odds_prob_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>

<hr>
<h2 id='plot_ll'>Plot Log-Likelihood vs. Values of One Parameter</h2><span id='topic+plot_ll'></span>

<h3>Description</h3>

<p>Generates plot of log-likelihood vs. one parameter of interest while other
parameters are held fixed at certain values (e.g. MLEs). This is not a 
profile likelihood, and is mainly intended for use with a Shiny app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_ll(start, objective, lower = -Inf, upper = Inf, xaxis_param = 1,
  xaxis_range = NULL, param_values = NULL, mles = NULL,
  return_info = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_ll_+3A_start">start</code></td>
<td>
<p>See <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_objective">objective</code></td>
<td>
<p>See <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_lower">lower</code></td>
<td>
<p>See <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_upper">upper</code></td>
<td>
<p>See <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_xaxis_param">xaxis_param</code></td>
<td>
<p>Integer value specifying which parameter should be plotted
on the x-axis.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_xaxis_range">xaxis_range</code></td>
<td>
<p>Numeric vector specifying x-axis range over which to vary 
the parameter of interest. Only values with likelihood ratio &gt; 0.01 are 
ultimately plotted.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_param_values">param_values</code></td>
<td>
<p>Numeric vector of values to use for other parameters in
model, in case you want an additional curve for log-likelihood function vs.
parameter of interest at certain non-MLE values for other parameters. For
example, if there are 3 parameters and <code>xaxis_param = 2</code>, you could set
<code>param_values = c(0, NA, 0)</code>.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_mles">mles</code></td>
<td>
<p>Numeric vector of previously obtained maximum likelihood
estimates.</p>
</td></tr>
<tr><td><code id="plot_ll_+3A_return_info">return_info</code></td>
<td>
<p>Logical value for whether to return the estimated MLEs and 
99.99% confidence intervals for parameters rather than create the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>objective</code> should be the negative log-likelihood function, 
since internal optimization uses (<code><a href="stats.html#topic+nlminb">nlminb</a></code>), which does 
minimization.
</p>


<h3>Value</h3>

<p>Plot of log-likelihood vs. value of parameter of interest, generated
by <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate normal data, define log-likelihood function, and plot likelihood
set.seed(123)
x &lt;- rnorm(100, mean = 0.5, sd = sqrt(0.25))
ll.f &lt;- function(theta) {
  return(-sum(dnorm(x, log = TRUE, mean = theta[1], sd = sqrt(theta[2]))))
}
plot_ll(start = c(0, 1), objective = ll.f, lower = c(-Inf, 1e-6))


</code></pre>

<hr>
<h2 id='pooled_var'>Pooled Sample Variance</h2><span id='topic+pooled_var'></span>

<h3>Description</h3>

<p>Calculates pooled sample variance used in equal variance two-sample t-test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooled_var(x, y, integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pooled_var_+3A_x">x</code>, <code id="pooled_var_+3A_y">y</code></td>
<td>
<p>Integer or numeric vectors.</p>
</td></tr>
<tr><td><code id="pooled_var_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> and <code>y</code> are integer 
vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>

<hr>
<h2 id='power_2t_equal'>Calculate Power for Two-Sample Equal Variance T-Test</h2><span id='topic+power_2t_equal'></span>

<h3>Description</h3>

<p>Same idea as <code><a href="stats.html#topic+power.t.test">power.t.test</a></code>. Less flexible, but faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_2t_equal(n = 100, d, sigsq, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_2t_equal_+3A_n">n</code></td>
<td>
<p>Numeric value specifying per-group sample size.</p>
</td></tr>
<tr><td><code id="power_2t_equal_+3A_d">d</code></td>
<td>
<p>Numeric value specifying true difference in group means. Should be
positive.</p>
</td></tr>
<tr><td><code id="power_2t_equal_+3A_sigsq">sigsq</code></td>
<td>
<p>Numeric value specifying the variance of observations.</p>
</td></tr>
<tr><td><code id="power_2t_equal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying type-1 error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Power to detect difference of 0.2 with 100 subjects per group and sigsq = 1
power_2t_equal(n = 100, d = 0.2, sigsq = 1)

</code></pre>

<hr>
<h2 id='power_2t_unequal'>Calculate Power for Two-Sample Unequal Variance T-Test</h2><span id='topic+power_2t_unequal'></span>

<h3>Description</h3>

<p>Unequal variance version of <code><a href="#topic+power_2t_equal">power_2t_equal</a></code>. Assumes an equal
sample size for both groups, which is actually not optimal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>power_2t_unequal(n = 100, d, sigsq1, sigsq2, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="power_2t_unequal_+3A_n">n</code></td>
<td>
<p>Numeric value specifying per-group sample size.</p>
</td></tr>
<tr><td><code id="power_2t_unequal_+3A_d">d</code></td>
<td>
<p>Numeric value specifying true difference in group means. Should be
positive.</p>
</td></tr>
<tr><td><code id="power_2t_unequal_+3A_sigsq1">sigsq1</code>, <code id="power_2t_unequal_+3A_sigsq2">sigsq2</code></td>
<td>
<p>Numeric value specifying the variance of observations in
each group.</p>
</td></tr>
<tr><td><code id="power_2t_unequal_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying type-1 error rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Power to detect difference of 0.2 with 100 subjects per group and sigsq's
# of 1 and 1.25
power_2t_unequal(n = 100, d = 0.2, sigsq1 = 1, sigsq2 = 1.25)

</code></pre>

<hr>
<h2 id='prob_logit'>Convert Probability to Logit</h2><span id='topic+prob_logit'></span>

<h3>Description</h3>

<p>Defined simply as <code>log(x / (1 - x))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_logit(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_logit_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>

<hr>
<h2 id='prob_odds'>Convert Probability to Odds</h2><span id='topic+prob_odds'></span>

<h3>Description</h3>

<p>Defined simply as <code>x / (1 - x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prob_odds(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prob_odds_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>

<hr>
<h2 id='quant_groups'>Split Continuous Variable into Quantile Groups</h2><span id='topic+quant_groups'></span>

<h3>Description</h3>

<p>Splits a continuous variable into quantiles groups. Basically combines 
<code><a href="stats.html#topic+quantile">quantile</a></code> and <code><a href="base.html#topic+cut">cut</a></code> into a single 
function. Note that <code><a href="#topic+create_qgroups">create_qgroups</a></code> will likely supersede this 
function in future versions of <strong>dvmisc</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant_groups(x, groups = 4, probs = NULL, quantile.list = NULL,
  cut.list = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quant_groups_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="quant_groups_+3A_groups">groups</code></td>
<td>
<p>Numeric value specifying number of quantile groups.</p>
</td></tr>
<tr><td><code id="quant_groups_+3A_probs">probs</code></td>
<td>
<p>Numeric vector specifying probabilities.</p>
</td></tr>
<tr><td><code id="quant_groups_+3A_quantile.list">quantile.list</code></td>
<td>
<p>Arguments to pass to <code><a href="stats.html#topic+quantile">quantile</a></code>.</p>
</td></tr>
<tr><td><code id="quant_groups_+3A_cut.list">cut.list</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert values from N(0, 1) into quintiles (i.e. 5 groups)
x &lt;- rnorm(1000)
groups &lt;- quant_groups(x, 5)
table(groups)

</code></pre>

<hr>
<h2 id='quant_groups_svy'>Split Continuous Variable into Quantile Groups (Survey Version)</h2><span id='topic+quant_groups_svy'></span>

<h3>Description</h3>

<p>Complex survey version of <code><a href="#topic+quant_groups">quant_groups</a></code>. Speeds up process of 
creating quantile groups based on survey weighted percentiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant_groups_svy(x, by = NULL, groups = 4, probs = NULL, design)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quant_groups_svy_+3A_x">x</code></td>
<td>
<p>Formula, e.g. <code>~varname</code>.</p>
</td></tr>
<tr><td><code id="quant_groups_svy_+3A_by">by</code></td>
<td>
<p>Formula, e.g. <code>~varname</code>.</p>
</td></tr>
<tr><td><code id="quant_groups_svy_+3A_groups">groups</code></td>
<td>
<p>Numeric value specifying number of quantile groups.</p>
</td></tr>
<tr><td><code id="quant_groups_svy_+3A_probs">probs</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="quant_groups_svy_+3A_design">design</code></td>
<td>
<p>A <code>svydesign</code> or <code>svrepdesign</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>

<hr>
<h2 id='reverse_cut'>Reverse Cut</h2><span id='topic+reverse_cut'></span>

<h3>Description</h3>

<p>Convenience function to get reversed factor levels from <code><a href="base.html#topic+cut">cut</a></code>. 
Currently requires specifying <code>breaks</code> as vector of cutpoints rather 
than number of desired intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse_cut(x, breaks, include.lowest = FALSE, right = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_cut_+3A_x">x</code>, <code id="reverse_cut_+3A_breaks">breaks</code>, <code id="reverse_cut_+3A_include.lowest">include.lowest</code>, <code id="reverse_cut_+3A_right">right</code></td>
<td>
<p>See <code><a href="base.html#topic+cut">cut</a></code>.
specifying number of intervals is not currently supported).</p>
</td></tr>
<tr><td><code id="reverse_cut_+3A_...">...</code></td>
<td>
<p>Arguments to pass to <code><a href="base.html#topic+cut">cut</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Factor variable.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In mtcars dataset, create 3 mpg groups
table(cut(mtcars$mpg, breaks = c(-Inf, 15, 20, Inf)))

# Repeat with reverse_cut to get factor levels ordered from high to low
table(reverse_cut(mtcars$mpg, breaks = c(Inf, 20, 15, -Inf)))

# You can specify breaks from low to high, but then include.lowest and right 
# arguments get confusing
table(reverse_cut(mtcars$mpg, breaks = c(-Inf, 15, 20, Inf), right = TRUE))

</code></pre>

<hr>
<h2 id='sliding_cor'>Moving Correlations as Short Vector Slides Across Long Vector</h2><span id='topic+sliding_cor'></span>

<h3>Description</h3>

<p>Uses C++ code for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliding_cor(short, long)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sliding_cor_+3A_short">short</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="sliding_cor_+3A_long">long</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>short &lt;- rnorm(4)
long &lt;- rnorm(10)
sliding_cor(short, long)


</code></pre>

<hr>
<h2 id='sliding_cov'>Moving Covariance as Short Vector Slides Across Long Vector</h2><span id='topic+sliding_cov'></span>

<h3>Description</h3>

<p>Uses C++ code for efficiency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliding_cov(short, long)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sliding_cov_+3A_short">short</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="sliding_cov_+3A_long">long</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>short &lt;- rnorm(4)
long &lt;- rnorm(10)
sliding_cov(short, long)


</code></pre>

<hr>
<h2 id='sum_i'>Sum of Integer Values</h2><span id='topic+sum_i'></span>

<h3>Description</h3>

<p>Written in C++, this function runs faster than <code><a href="base.html#topic+sum">sum</a></code> for 
large integer vectors/matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_i(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sum_i_+3A_x">x</code></td>
<td>
<p>Integer vector or matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For very large integer objects, sum_i is faster than sum
x &lt;- rpois(100000, lambda = 5)
sum(x) == sum_i(x)
benchmark(sum(x), sum_i(x), replications = 1000)

# For smaller integer objects, sum_i is slower than sum 
x &lt;- rpois(1000, lambda = 5)
sum(x) == sum_i(x)
benchmark(sum(x), sum_i(x), replications = 1000)

</code></pre>

<hr>
<h2 id='sumsim'>Summarize Simulation Results</h2><span id='topic+sumsim'></span>

<h3>Description</h3>

<p>Creates table summarizing results of statistical simulations, providing 
common metrics of performance like mean bias, standard deviation, mean 
standard error, mean squared error, and confidence interval coverage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumsim(estimates, ses = NULL, truth = NULL, theta_0 = 0,
  statistics = c("mean_bias", "sd", "mean_se", "mse", "coverage"),
  alpha = 0.05, digits = 3, listwise_deletion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumsim_+3A_estimates">estimates</code></td>
<td>
<p>Numeric matrix where each column gives the point estimates 
for a particular method across multiple trials.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_ses">ses</code></td>
<td>
<p>Numeric matrix where each column gives the standard errors for 
a particular method across multiple trials.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_truth">truth</code></td>
<td>
<p>Numeric value specifying the true value of the parameter 
being estimated.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_theta_0">theta_0</code></td>
<td>
<p>Numeric value specifying null value for hypothesis test
<code>H_0: theta = theta_0</code>. Only used for calculating empirical power.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_statistics">statistics</code></td>
<td>
<p>Numeric vector specifying which performance metrics should 
be calculated. Possible values are <code>"n"</code> for number of trials, 
<code>"mean"</code>, <code>"median"</code>, <code>"mean_bias"</code>, <code>"median_bias"</code>, 
<code>"sd"</code>, <code>"iqr"</code>, <code>"mean_se"</code> (for mean standard error), 
<code>"mse"</code> (for mean squared error), <code>"coverage"</code> (for confidence 
interval coverage), <code>"ci_width"</code> for median confidence interval width, 
and <code>"power"</code> for empirical power.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_alpha">alpha</code></td>
<td>
<p>Numeric value specifying alpha for confidence interval. Set to 
<code>0.05</code> for the usual 95% CI, <code>0.1</code> for a 90% CI, and so forth.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_digits">digits</code></td>
<td>
<p>Numeric value or vector specifying the number of decimal places 
to include.</p>
</td></tr>
<tr><td><code id="sumsim_+3A_listwise_deletion">listwise_deletion</code></td>
<td>
<p>Logical value for whether to remove trials in which 
any of the estimators have missing values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For X ~ N(mu, sigma^2), the MLE for sigma^2 is the sample variance with n 
# in the denominator, but the unbiased version with (n - 1) is typically used 
# for its unbiasedness. Compare these estimators in 1,000 trials with n = 25. 
MLE &lt;- c()
Unbiased &lt;- c()
for (ii in 1: 1000) {
   x &lt;- rnorm(n = 25)
   MLE[ii] &lt;- sum((x - mean(x))^2) / 25
   Unbiased[ii] &lt;- sum((x - mean(x))^2) / 24
 }
sumsim(estimates = cbind(MLE, Unbiased), truth = 1)

</code></pre>

<hr>
<h2 id='trim'>Trim Tail Values off of a Vector</h2><span id='topic+trim'></span>

<h3>Description</h3>

<p>Returns input vector with tail values trimmed off of it. User can specify 
tail probability to trim or lower and upper cutpoints for values to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim(x, p = NULL, tails = "both", cutpoints = NULL,
  keep.edge = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
<tr><td><code id="trim_+3A_p">p</code></td>
<td>
<p>Numeric value giving tail probability to trim from <code>x</code>. Can 
leave as <code>NULL</code> if you specify <code>cutpoints</code>.</p>
</td></tr>
<tr><td><code id="trim_+3A_tails">tails</code></td>
<td>
<p>Numeric value indicating which tail should be trimmed. Possible 
values are <code>"both"</code>, <code>"lower"</code>, and <code>"upper"</code>.</p>
</td></tr>
<tr><td><code id="trim_+3A_cutpoints">cutpoints</code></td>
<td>
<p>Numeric vector indicating what range of values should be 
retained. For example, set to <code>c(0, 1)</code> to trim all values below 0 or 
greater than 1. Can leave as <code>NULL</code> if you specify <code>p</code>.</p>
</td></tr>
<tr><td><code id="trim_+3A_keep.edge">keep.edge</code></td>
<td>
<p>Logical value indicating whether values in <code>x</code> that are 
on the edge of being trimmed (i.e. equal to one of the endpoints) should be 
retained.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+inside">inside</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate data from N(0, 1) and then trim the lower and upper 1\%
x &lt;- rnorm(1000)
y &lt;- trim(x, p = 0.01)

# Generate data from N(0, 1) and then trim values outside of (-1.5, 1.5)
x &lt;- rnorm(100000)
y &lt;- trim(x, cutpoints = c(-1.5, 1.5))

</code></pre>

<hr>
<h2 id='truerange'>Range of a Vector (Not Min/Max!)</h2><span id='topic+truerange'></span>

<h3>Description</h3>

<p>The base R function <code><a href="base.html#topic+range">range</a></code> returns the minimum and maximum 
of a vector, but the &quot;range&quot; is actually defined as the difference between 
the minimum and maximum. This function calculates the actual range. It is 
equivalent to the base R code <code>diff(range(x))</code>, but a bit simpler and 
much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truerange(x, integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truerange_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector.</p>
</td></tr>
<tr><td><code id="truerange_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer or numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># truerange vs. diff(range()) for integer vector
x &lt;- rpois(1000, lambda = 5)
all.equal(diff(range(x)), truerange(x, TRUE))
benchmark(diff(range(x)), truerange(x, TRUE), replications = 2000)

# truerange vs. diff(range()) for numeric vector
x &lt;- rnorm(1000)
all.equal(diff(range(x)), truerange(x))
benchmark(diff(range(x)), truerange(x), replications = 2000)


</code></pre>

<hr>
<h2 id='which_max_im'>Return (Row, Column) Index of (First) Maximum of an Integer Matrix</h2><span id='topic+which_max_im'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run much faster than the equivalent 
(if maximum is unique) base R solution 
<code>which(x == max(x), arr.ind = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_max_im(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_max_im_+3A_x">x</code></td>
<td>
<p>Integer matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_max_nv">which_max_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_max_iv">which_max_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_max_nm">which_max_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_max_im">which_max_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which_max_im is typically much faster than 
# which(x == max(x), arr.ind = TRUE)
x &lt;- matrix(rpois(100, lambda = 15), ncol = 10)
all(which(x == max(x), arr.ind = TRUE) == which_max_im(x))
benchmark(which(x == max(x), arr.ind = TRUE), which_max_im(x), 
          replications = 5000)

</code></pre>

<hr>
<h2 id='which_max_iv'>Return Index of (First) Maximum of an Integer Vector</h2><span id='topic+which_max_iv'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than <code>which.max</code> for 
large integer vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_max_iv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_max_iv_+3A_x">x</code></td>
<td>
<p>Integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_max_nv">which_max_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_max_iv">which_max_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_max_nm">which_max_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_max_im">which_max_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For long vectors, which_max_iv is faster than which.max
x &lt;- rpois(10000, lambda = 15)
which.max(x) == which_max_iv(x)
benchmark(which.max(x), which_max_iv(x), replications = 5000)

# For shorter vectors, which_max_iv is slower than which.max
x &lt;- rpois(100, lambda = 15)
which.max(x) == which_max_iv(x)
benchmark(which.max(x), which_max_iv(x), replications = 20000)

</code></pre>

<hr>
<h2 id='which_max_nm'>Return (Row, Column) Index of (First) Maximum of a Numeric Matrix</h2><span id='topic+which_max_nm'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run much faster than the equivalent 
(if maximum is unique) base R solution 
<code>which(x == max(x), arr.ind = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_max_nm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_max_nm_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_max_nv">which_max_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_max_iv">which_max_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_max_nm">which_max_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_max_im">which_max_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which_max_nm is typically much faster than 
# which(x == max(x), arr.ind = TRUE)
x &lt;- matrix(rnorm(100), ncol = 10)
all(which(x == max(x), arr.ind = TRUE) == which_max_nm(x))
benchmark(which(x == max(x), arr.ind = TRUE), which_max_nm(x),
          replications = 5000)

</code></pre>

<hr>
<h2 id='which_max_nv'>Return Index of (First) Maximum of a Numeric Vector</h2><span id='topic+which_max_nv'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than <code>which.max</code> for 
large numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_max_nv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_max_nv_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_max_nv">which_max_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_max_iv">which_max_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_max_nm">which_max_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_max_im">which_max_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For long vectors, which_max_nv is faster than which.max
x &lt;- rnorm(100000)
which.max(x) == which_max_nv(x)
benchmark(which.max(x), which_max_nv(x), replications = 500)

# For shorter vectors, which_max_nv is slower than which.max
x &lt;- rnorm(100)
which.max(x) == which_max_nv(x)
benchmark(which.max(x), which_max_nv(x), replications = 10000)

</code></pre>

<hr>
<h2 id='which_min_im'>Return (Row, Column) Index of (First) Minimum of an Integer Matrix</h2><span id='topic+which_min_im'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run much faster than the equivalent 
(if minimum is unique) base R solution 
<code>which(x == min(x), arr.ind = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_im(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_min_im_+3A_x">x</code></td>
<td>
<p>Integer matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_min_nv">which_min_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_min_iv">which_min_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_min_nm">which_min_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_min_im">which_min_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which_min_im is typically much faster than 
# which(x == min(x), arr.ind = TRUE)
x &lt;- matrix(rpois(100, lambda = 10), ncol = 10)
all(which(x == min(x), arr.ind = TRUE) == which_min_im(x))
benchmark(which(x == min(x), arr.ind = TRUE), which_min_im(x),
          replications = 5000)

</code></pre>

<hr>
<h2 id='which_min_iv'>Return Index of (First) Minimum of an Integer Vector</h2><span id='topic+which_min_iv'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than 
<code><a href="base.html#topic+which.min">which.min</a></code> for large integer vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_iv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_min_iv_+3A_x">x</code></td>
<td>
<p>Integer vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_min_nv">which_min_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_min_iv">which_min_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_min_nm">which_min_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_min_im">which_min_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For long vectors, which_min_iv is faster than which.min 
x &lt;- rpois(10000, lambda = 15)
which.min(x) == which_min_iv(x)
benchmark(which.min(x), which_min_iv(x), replications = 5000)

# For shorter vectors, which_min_iv is slower than which.min
x &lt;- rpois(100, lambda = 15)
which.min(x) == which_min_iv(x)
benchmark(which.min(x), which_min_iv(x), replications = 20000)

</code></pre>

<hr>
<h2 id='which_min_nm'>Return (Row, Column) Index of (First) Minimum of a Numeric Matrix</h2><span id='topic+which_min_nm'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run much faster than the equivalent 
(if minimum is unique) base R solution 
<code>which(x == min(x), arr.ind = TRUE)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_nm(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_min_nm_+3A_x">x</code></td>
<td>
<p>Numeric matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_min_nv">which_min_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_min_iv">which_min_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_min_nm">which_min_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_min_im">which_min_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which_min_nm is typically much faster than 
# which(x == min(x), arr.ind = TRUE)
x &lt;- matrix(rnorm(100), ncol = 10)
all(which(x == min(x), arr.ind = TRUE) == which_min_nm(x))
benchmark(which(x == min(x), arr.ind = TRUE), which_min_nm(x), 
          replications = 5000)

</code></pre>

<hr>
<h2 id='which_min_nv'>Return Index of (First) Minimum of a Numeric Vector</h2><span id='topic+which_min_nv'></span>

<h3>Description</h3>

<p>Written in C++, this function tends to run faster than 
<code><a href="base.html#topic+which.min">which.min</a></code> for large numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which_min_nv(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which_min_nv_+3A_x">x</code></td>
<td>
<p>Numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For optimal speed, choose the version of this function that matches the 
class of your <code>x</code>:
</p>
<p><code><a href="#topic+which_min_nv">which_min_nv</a></code> for numeric vector. <br />
<code><a href="#topic+which_min_iv">which_min_iv</a></code> for integer vector. <br />
<code><a href="#topic+which_min_nm">which_min_nm</a></code> for numeric matrix. <br />
<code><a href="#topic+which_min_im">which_min_im</a></code> for integer matrix.
</p>


<h3>Value</h3>

<p>Integer value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For long vectors, which_min_nv is faster than which.min
x &lt;- rnorm(100000)
which.min(x) == which_min_nv(x)
benchmark(which.min(x), which_min_nv(x), replications = 1000)

# For shorter vectors, which_min_nv is slower than which.min
x &lt;- rnorm(100)
which.min(x) == which_min_nv(x)
benchmark(which.min(x), which_min_nv(x), replications = 10000)

</code></pre>

<hr>
<h2 id='which.max2'>Return Index of (First) Maximum of a Vector</h2><span id='topic+which.max2'></span>

<h3>Description</h3>

<p>Returns index of maximum for vectors and index or (row, column) position for 
matrices. For optimal speed, use <code>integer = TRUE</code> if <code>x</code> is an 
integer vector/matrix and <code>integer = FALSE</code> otherwise. Typically faster 
than <code><a href="base.html#topic+which.min">which.max</a></code> for matrices and for large 
vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.max2(x, arr.ind = FALSE, integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.max2_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector/matrix.</p>
</td></tr>
<tr><td><code id="which.max2_+3A_arr.ind">arr.ind</code></td>
<td>
<p>Logical value for whether to return (row, col) position rather 
than vector position, if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="which.max2_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which.max2 vs. which.max for integer vector
x &lt;- rpois(10000, lambda = 5)
all.equal(which.max(x), which.max2(x, integer = TRUE))
benchmark(which.max(x), which.max2(x, integer = TRUE), replications = 10000)

# which.max2 vs. which.max for numeric vector
x &lt;- rnorm(10000)
all.equal(which.max(x), which.max2(x))
benchmark(which.max(x), which.max2(x), replications = 10000)


</code></pre>

<hr>
<h2 id='which.min2'>Return Index of (First) Minimum of a Vector</h2><span id='topic+which.min2'></span>

<h3>Description</h3>

<p>Returns index of minimum for vectors and index or (row, column) position for 
matrices. For optimal speed, use <code>integer = TRUE</code> if <code>x</code> is an 
integer vector/matrix and <code>integer = FALSE</code> otherwise. Typically faster 
than <code><a href="base.html#topic+which.min">which.min</a></code> for matrices and for large vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>which.min2(x, arr.ind = FALSE, integer = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="which.min2_+3A_x">x</code></td>
<td>
<p>Integer or numeric vector/matrix.</p>
</td></tr>
<tr><td><code id="which.min2_+3A_arr.ind">arr.ind</code></td>
<td>
<p>Logical value for whether to return (row, col) position rather 
than vector position, if <code>x</code> is a matrix.</p>
</td></tr>
<tr><td><code id="which.min2_+3A_integer">integer</code></td>
<td>
<p>Logical value for whether <code>x</code> is an integer vector/matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># which.min2 vs. which.min for integer vector
x &lt;- rpois(10000, lambda = 10)
all.equal(which.min(x), which.min2(x, integer = TRUE))
benchmark(which.min(x), which.min2(x, integer = TRUE), replications = 10000)

# which.min2 vs. which.min for numeric vector
x &lt;- rnorm(10000)
all.equal(which.min(x), which.min2(x))
benchmark(which.min(x), which.min2(x), replications = 10000)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
