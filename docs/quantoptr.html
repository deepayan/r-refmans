<!DOCTYPE html><html><head><title>Help for package quantoptr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quantoptr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abso_diff_est'><p>Estimate the Gini's mean difference/mean absolute difference(MAD) for a Given Treatment Regime</p></a></li>
<li><a href='#augX'><p>Generate Pseudo-Responses Based on Conditional Quantile Regression</p>
Models</a></li>
<li><a href='#DR_Qopt'><p>The Doubly Robust Estimator of the Quantile-Optimal Treatment Regime</p></a></li>
<li><a href='#dr_quant_est'><p>The Doubly Robust Quantile Estimator for a Given Treatment Regime</p></a></li>
<li><a href='#get_os'><p>Get the OS from R</p></a></li>
<li><a href='#IPWE_MADopt'><p>Estimation of the Optimal Treatment Regime defined as Minimizing</p>
Gini's Mean Differences</a></li>
<li><a href='#IPWE_Mopt'><p>Estimate the Mean-optimal Treatment Regime</p></a></li>
<li><a href='#IPWE_Qopt'><p>Estimate the Quantile-optimal Treatment Regime</p></a></li>
<li><a href='#mean_est'><p>The Inverse Probability Weighted Estimator of the Marginal Mean Given a Specific Treatment Regime</p></a></li>
<li><a href='#mestimate'><p>The Mean-Optimal Treatment Regime Wrapper Function</p></a></li>
<li><a href='#qestimate'><p>The Quantile-Optimal Treatment Regime Wrapper Function</p></a></li>
<li><a href='#quant_est'><p>Estimate the Marginal Quantile Given a Specific Treatment Regime</p></a></li>
<li><a href='#TwoStg_Mopt'><p>Estimate the Two-stage Mean-Optimal Treatment Regime</p></a></li>
<li><a href='#TwoStg_Qopt'><p>Estimate the Two-stage Quantile-optimal Treatment Regime</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Algorithms for Quantile- And Mean-Optimal Treatment Regimes</td>
</tr>
<tr>
<td>Author:</td>
<td>Yu Zhou [cre, aut],
  Lan Wang [ctb],
  Ben Sherwood [ctb],
  Rui Song [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yu Zhou &lt;zhou0269@umn.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimation methods for optimal treatment regimes under three different criteria, namely marginal quantile, marginal mean, and mean absolute difference. For the first two criteria, both one-stage and two-stage estimation method are implemented. A doubly robust estimator for estimating the quantile-optimal treatment regime is also included. </td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, rgenoud (&ge; 5.7), quantreg (&ge; 5.18), parallel,
methods, Rdpack</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2), stats, utils</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-02-05 05:24:52 UTC; yuzhou</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-02-05 05:56:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='abso_diff_est'>Estimate the Gini's mean difference/mean absolute difference(MAD) for a Given Treatment Regime</h2><span id='topic+abso_diff_est'></span>

<h3>Description</h3>

<p>Estimate the MAD if the entire population follows a 
treatment regime indexed by the given parameters.
This function supports the <code><a href="#topic+IPWE_MADopt">IPWE_MADopt</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abso_diff_est(beta, x, y, a, prob, Cnobs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abso_diff_est_+3A_beta">beta</code></td>
<td>
<p>a vector indexing the treatment regime.
It indexes a linear treatment regime:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\}.
</code>
</p>
</td></tr>
<tr><td><code id="abso_diff_est_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.
This is important that columns in <code>x</code> matches with <code>beta</code>.</p>
</td></tr>
<tr><td><code id="abso_diff_est_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="abso_diff_est_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="abso_diff_est_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
<tr><td><code id="abso_diff_est_+3A_cnobs">Cnobs</code></td>
<td>
<p>A matrix with two columns, enumerating all possible combinations of
pairs of indexes. This can be generated by <code>combn(1:n, 2)</code>,
where <code>n</code> is the number of unique observations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+IPWE_MADopt">IPWE_MADopt</a></code> is based on this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(stats)
GenerateData.MAD &lt;- function(n)
{
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  tp &lt;- exp(-1+1*(x1+x2))/(1+exp(-1+1*(x1+x2)))
  a&lt;-rbinom(n = n, size = 1, prob=tp)
  error &lt;- rnorm(length(x1))
  y &lt;- (1 + a*0.3*(-1+x1+x2&lt;0) +  a*-0.3*(-1+x1+x2&gt;0)) * error
  return(data.frame(x1=x1,x2=x2,a=a,y=y))
}



n &lt;- 500
testData &lt;- GenerateData.MAD(n)
logistic.model.tx &lt;- glm(formula = a~x1+x2, data = testData, family=binomial)
ph &lt;- as.vector(logistic.model.tx$fit)
Cnobs &lt;- combn(1:n, 2)
abso_diff_est(beta=c(1,2,-1), 
              x=model.matrix(a~x1+x2, testData),
              y=testData$y,
              a=testData$a,
              prob=ph,
              Cnobs = Cnobs)

</code></pre>

<hr>
<h2 id='augX'>Generate Pseudo-Responses Based on Conditional Quantile Regression
Models</h2><span id='topic+augX'></span>

<h3>Description</h3>

<p>This function supports the <code><a href="#topic+DR_Qopt">DR_Qopt</a></code> function.
For every observation, we generate pseudo-observations corresponding
to treatment 0 and 1 respectively based on working conditional quantile models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>augX(raw.data, length.out = 200, txVec, moCondQuant_0, moCondQuant_1,
  nlCondQuant_0 = FALSE, nlCondQuant_1 = FALSE, start_0 = NULL,
  start_1 = NULL, clnodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="augX_+3A_raw.data">raw.data</code></td>
<td>
<p>A data frame, must contain all the variables that appear in 
<code>moCondQuant_0</code> and <code>moCondQuant_1</code>.</p>
</td></tr>
<tr><td><code id="augX_+3A_length.out">length.out</code></td>
<td>
<p>an integer greater than 1.  If one of the conditional quantile
model is set to be nonlinear, this argument will be triggered and we will fit 
<code>length.out</code> models across quantiles equally spaced between 0.001 and 0.999.
The larger this value, the more refined the performance of this method.
Default is 200.</p>
</td></tr>
<tr><td><code id="augX_+3A_txvec">txVec</code></td>
<td>
<p>a numeric vector of observed treatment levels coded 0L and 1L.</p>
</td></tr>
<tr><td><code id="augX_+3A_mocondquant_0">moCondQuant_0</code></td>
<td>
<p>A formula, used to specify the formula for the conditional
quantile function when treatment = 0.</p>
</td></tr>
<tr><td><code id="augX_+3A_mocondquant_1">moCondQuant_1</code></td>
<td>
<p>A formula, used to specify the formula for the conditional
quantile function when treatment = 1.</p>
</td></tr>
<tr><td><code id="augX_+3A_nlcondquant_0">nlCondQuant_0</code></td>
<td>
<p>logical.
When <code>nlCondQuant_0 = TRUE</code>, it is indicated that <code>moCondQuant_0</code> is nonlinear.
The default value of this variable is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augX_+3A_nlcondquant_1">nlCondQuant_1</code></td>
<td>
<p>logical.
When <code>nlCondQuant_1 = TRUE</code>, it is indicated that <code>moCondQuant_1</code> is nonlinear.
The default value of this variable is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="augX_+3A_start_0">start_0</code></td>
<td>
<p>either a list object, providing the starting value in estimating 
the parameters in the nonlinear conditional quantile model, given that treatment=0. 
Default is <code>NULL</code>, corresponding to the case when <code>nlCondQuant_0=FALSE</code>.</p>
</td></tr>
<tr><td><code id="augX_+3A_start_1">start_1</code></td>
<td>
<p>either a list object, providing the starting value in estimating 
the parameters in the nonlinear conditional quantile model, given that treatment=0. 
Default is <code>NULL</code>, corresponding to the case when <code>nlCondQuant_1=FALSE</code>.</p>
</td></tr>
<tr><td><code id="augX_+3A_clnodes">clnodes</code></td>
<td>
<p>Either a cluster object to enable parallel computation or 
<code>NULL</code>. If <code>NULL</code>, no parallel computation will be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the algorithm to generate individual level pseudo responses 
for two treatment levels respectively.
</p>
<p>For each observation, two independent random variables from 
<code class="reqn">{unif}[0,1]</code> are generated. Denote them by <code class="reqn">u_0</code> 
and <code class="reqn">u_1</code>. Approximately, this function then estimates the <code class="reqn">u_0</code>th quantile
of this observation were treatment level 0 is applied via the conditional <code class="reqn">u_0</code>th quantile regression. 
This estimated quantile will be the pseudo-response for treatment 0. 
Similarly, this function the pseudo-response for treatment 1 will be estimated and returned.
</p>
<p>See the reference paper for a more formal explanation.
</p>


<h3>Value</h3>

<p>It returns a list object, consisting of the following elements:
</p>

<ol>
<li> <p><code>y.a.0</code>, the vector of estimated individual level pseudo outcomes,
given the treatment is 0;
</p>
</li>
<li> <p><code>y.a.1</code>, the vector of estimated individual level pseudo outcomes, 
given the treatment is 1;
</p>
</li>
<li> <p><code>nlCondQuant_0</code>, logical, indicating whether the <code>y.a.0</code>
is generated based on a nonlinear conditional quantile model.
</p>
</li>
<li> <p><code>nlCondQuant_1</code>, logical, indicating whether the <code>y.a.1</code>
is generated based on a nonlinear conditional quantile model.
</p>
</li></ol>



<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ilogit &lt;- function(x) exp(x)/(1 + exp(x))
GenerateData.DR &lt;- function(n)
{
  x1 &lt;- runif(n,min=-1.5,max=1.5)
  x2 &lt;- runif(n,min=-1.5,max=1.5)
  tp &lt;- ilogit( 1 - 1*x1^2 - 1* x2^2)
  a &lt;-rbinom(n,1,tp)
  y &lt;- a * exp(0.11 - x1- x2) + x1^2 + x2^2 +  a*rgamma(n, shape=2*x1+3, scale = 1) +
       (1-a)*rnorm(n, mean = 2*x1 + 3, sd = 0.5)
  return(data.frame(x1=x1,x2=x2,a=a,y=y))
}
regimeClass = as.formula(a ~ x1+x2)
moCondQuant_0 = as.formula(y ~ x1+x2+I(x1^2)+I(x2^2))
moCondQuant_1 = as.formula(y ~ exp( 0.11 - x1 - x2)+ x1^2 + p0 + p1*x1
+ p2*x1^2 + p3*x1^3 +p4*x1^4 )
start_1 = list(p0=0, p1=1.5, p2=1, p3 =0,p4=0)

## Not run: 
n&lt;-200
testdata &lt;- GenerateData.DR(n)
fit1 &lt;- augX(raw.data=testdata, txVec = testdata$a,
             moCondQuant_0=moCondQuant_0, moCondQuant_1=moCondQuant_1,
             nlCondQuant_0=FALSE,   nlCondQuant_1=TRUE,
             start_1=start_1, 
             clnodes=NULL)  
 
# How to use parallel computing in AugX(): ##
 
# on Mac OSX/linux
 clnodes &lt;- parallel::makeForkCluster(nnodes =getOption("mc.cores",2))
 fit2 &lt;- augX(raw.data=testdata, length.out = 5, txVec = testdata$a,
             moCondQuant_0=moCondQuant_0, moCondQuant_1=moCondQuant_1,
             nlCondQuant_0=FALSE,   nlCondQuant_1=TRUE,
             start_1=start_1, 
             clnodes=clnodes)  
  
# on Windows
 clnodes &lt;- parallel::makeCluster(2, type="PSOCK")
 fit3 &lt;- augX(raw.data=testdata, length.out = 5, txVec = testdata$a,
             moCondQuant_0=moCondQuant_0, moCondQuant_1=moCondQuant_1,
             nlCondQuant_0=FALSE,   nlCondQuant_1=TRUE,
             start_1=start_1, 
             clnodes=clnodes)  
 
## End(Not run)
 
 
 
</code></pre>

<hr>
<h2 id='DR_Qopt'>The Doubly Robust Estimator of the Quantile-Optimal Treatment Regime</h2><span id='topic+DR_Qopt'></span>

<h3>Description</h3>

<p><code>DR_Qopt</code> implements the doubly robust estimation method to
estimate the quantile-optimal treatment regime. The double robustness
property means that it is consistent when either the propensity score model 
is correctly specified, or the conditional quantile function is correctly specified.
Both linear and nonlinear conditional quantile models are considered. See 'Examples'
for an illustrative example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DR_Qopt(data, regimeClass, tau, moPropen = "BinaryRandom",
  nlCondQuant_0 = FALSE, nlCondQuant_1 = FALSE, moCondQuant_0,
  moCondQuant_1, max = TRUE, length.out = 200, s.tol, it.num = 8,
  cl.setup = 1, p_level = 1, pop.size = 3000, hard_limit = FALSE,
  start_0 = NULL, start_1 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DR_Qopt_+3A_data">data</code></td>
<td>
<p>a data frame, must contain all the variables that appear in <code>moPropen</code>,
<code>RegimeClass</code>,  <code>moCondQuant_0</code>,  <code>moCondQuant_1</code>, and a column named
<code>y</code> as the observed response.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x)=I\left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
       </code>
</p>

<p>Polynomial arguments are also supported.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_nlcondquant_0">nlCondQuant_0</code></td>
<td>
<p>Logical. When <code>nlCondQuant_0=TRUE</code>,
this means the prespecified model for
the conditional quantile function given a=0 is nonlinear,
so the provided <code>moCondQuant_0</code>
should be nonlinear.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_nlcondquant_1">nlCondQuant_1</code></td>
<td>
<p>Logical. When <code>nlCondQuant_1=TRUE</code>,
this means the prespecified model for the conditional quantile function
given a=1 is nonlinear,
so the provided <code>moCondQuant_1</code>
should be nonlinear.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_mocondquant_0">moCondQuant_0</code></td>
<td>
<p>Either a formula or a string representing
the parametric form of the conditional quantile function given that treatment=0.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_mocondquant_1">moCondQuant_1</code></td>
<td>
<p>Either a formula or a string representing
the parametric form of the conditional quantile function given that treatment=1.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
quantile; if <code>max=FALSE</code>, we wish to minimize the marginal quantile. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_length.out">length.out</code></td>
<td>
<p>an integer greater than 1.  If one of the conditional quantile
model is set to be nonlinear, this argument will be triggered and we will fit 
<code>length.out</code> models across quantiles equally spaced between 0.001 and 0.999.
Default is 200.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_start_0">start_0</code></td>
<td>
<p>a named list or named numeric vector of starting estimates for
the conditional quantile function when <code>treatment = 0</code>. This is required when
<code>nlCondQuant_0=TRUE</code>.</p>
</td></tr>
<tr><td><code id="DR_Qopt_+3A_start_1">start_1</code></td>
<td>
<p>a named list or named numeric vector of starting estimates for
the conditional quantile function when <code>treatment = 1</code>. This is required when
<code>nlCondQuant_1=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Standardization on covariates AND explanation on the differences between
the two returned regime parameters.
</p>
<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>This estimated parameters indexing the quantile-optimal treatment regime are returned <em>in two scales:</em>
</p>

<ol>
<li><p> The returned <code>coefficients</code> is the set of parameters after covariates <code class="reqn">X</code> 
are standardized to be in the interval [0, 1]. To be exact, every covariate is 
subtracted by the smallest observed value and divided by the difference between 
the largest and the smallest value.  Next, we carried out the algorithm in Wang 2016 to get the estimated
regime parameters, <code>coefficients</code>, based on the standardized data. 
For the identifiability issue, we force the Euclidean norm of <code>coefficients</code>
to be 1.
</p>
</li>
<li><p> In contrast, <code>coef.orgn.scale</code> corresponds to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\hat{\beta}_0 + \hat{\beta}_1 x_1 + ... + \hat{\beta}_k x_k &gt; 0\}.</code>
</p>

<p>The estimated <code class="reqn">\bm{\hat{\beta}}</code> is returned as <code>coef.orgn.scale</code>.
The same as <code>coefficients</code>, we force the Euclidean norm of <code>coef.orgn.scale</code>
to be 1.
</p>
</li></ol>

<p>If, for each input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coefficients</code> and <code>coef.orgn.scale</code> will render identical.
</p>
</li>
<li><p> Property of the doubly robust(DR) estimator. The DR estimator <code>DR_Qopt</code>
is consistent if either the propensity score model or the conditional quantile
regression model is correctly specified. (Wang et. al. 2016)
</p>
</li></ul>



<h3>Value</h3>

<p>This function returns an object with 9 objects. Both <code>coefficients</code>
and <code>coef.orgn.scale</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coefficients</code></dt><dd><p>the parameters indexing the estimated 
quantile-optimal treatment regime for 
standardized covariates. </p>
</dd>
<dt><code>coef.orgn.scale</code></dt><dd><p>the parameter indexing the estimated 
quantile-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>tau</code></dt><dd><p>the quantile of interest</p>
</dd>
<dt><code>hatQ</code></dt><dd><p>the estimated marginal tau-th quantile when the treatment 
regime indexed by <code>coef.orgn.scale</code> is applied on everyone.
See the 'details' for connection between <code>coef.orgn.scale</code> and
<code>coefficient</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen</code></dt><dd><p>the user specified propensity score model</p>
</dd>
<dt><code>regimeClass</code></dt><dd><p>the user specified class of treatment regimes</p>
</dd>
<dt><code>moCondQuant_0</code></dt><dd><p>the user specified conditional quantile model for treatment 0</p>
</dd>
<dt><code>moCondQuant_1</code></dt><dd><p>the user specified conditional quantile model for treatment 1</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a>
</p>


<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dr_quant_est">dr_quant_est</a></code>, <code><a href="#topic+augX">augX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ilogit &lt;- function(x) exp(x)/(1 + exp(x))
GenerateData.DR &lt;- function(n)
{
 x1 &lt;- runif(n,min=-1.5,max=1.5)
 x2 &lt;- runif(n,min=-1.5,max=1.5)
 tp &lt;- ilogit( 1 - 1*x1^2 - 1* x2^2)
 a &lt;-rbinom(n,1,tp)
 y &lt;- a * exp(0.11 - x1- x2) + x1^2 + x2^2 +  a*rgamma(n, shape=2*x1+3, scale = 1) +
 (1-a)*rnorm(n, mean = 2*x1 + 3, sd = 0.5)
 return(data.frame(x1=x1,x2=x2,a=a,y=y))
}

regimeClass &lt;- as.formula(a ~ x1+x2)
moCondQuant_0 &lt;- as.formula(y ~ x1+x2+I(x1^2)+I(x2^2))
moCondQuant_1 &lt;- as.formula(y ~ exp( 0.11 - x1 - x2)+ x1^2 + p0 + p1*x1
                           + p2*x1^2 + p3*x1^3 +p4*x1^4 )
start_1 = list(p0=0, p1=1.5, p2=1, p3 =0,p4=0)



n &lt;- 400
testdata &lt;- GenerateData.DR(n)

## Examples below correctly specified both the propensity model and 
##  the conditional quantile model.
  
 system.time(
 fit1 &lt;- DR_Qopt(data=testdata, regimeClass = regimeClass, 
                 tau = 0.25,
                 moPropen = a~I(x1^2)+I(x2^2),
                 moCondQuant_0 = moCondQuant_0,
                 moCondQuant_1 = moCondQuant_1,
                 nlCondQuant_1 = TRUE,  start_1=start_1,
                 pop.size = 1000))
 fit1
 ## Go parallel for the same fit. It would save a lot of time.
 ### Could even change the cl.setup to larger values 
 ### if more cores are available.
  
 system.time(fit2 &lt;- DR_Qopt(data=testdata, regimeClass = regimeClass, 
                 tau = 0.25,
                 moPropen = a~I(x1^2)+I(x2^2),
                 moCondQuant_0 = moCondQuant_0,
                 moCondQuant_1 = moCondQuant_1,
                 nlCondQuant_1 = TRUE,  start_1=start_1,
                 pop.size = 1000, cl.setup=2))
 fit2

</code></pre>

<hr>
<h2 id='dr_quant_est'>The Doubly Robust Quantile Estimator for a Given Treatment Regime</h2><span id='topic+dr_quant_est'></span>

<h3>Description</h3>

<p>Given a fixed treatment regime, this doubly robust estimator
estimates the marginal quantile of responses when it is followed by
every unit in the target population. It took advantages of conditional
quantile functions for different treatment levels when they are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dr_quant_est(beta, x, y, a, prob, tau, y.a.0, y.a.1, num_min = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dr_quant_est_+3A_beta">beta</code></td>
<td>
<p>a vector indexing the treatment regime.
It indexes a linear treatment regime:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\}.
</code>
</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.
This is important that columns in <code>x</code> matches with <code>beta</code>.</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_tau">tau</code></td>
<td>
<p>The quantile of interest</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_y.a.0">y.a.0</code></td>
<td>
<p>Estimated conditional potential outcome given that treatment = 0,
which can be calculated by the function <code>augX</code>.</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_y.a.1">y.a.1</code></td>
<td>
<p>Estimated conditional potential outcome given that treatment = 1,
which can be calculated by the function <code>augX</code>.</p>
</td></tr>
<tr><td><code id="dr_quant_est_+3A_num_min">num_min</code></td>
<td>
<p>logical. If <code>TRUE</code>, the number of global minimizers for the 
objective function is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The double robustness property means that it can consistently estimate
the marginal quantile when either the propensity score model is correctly
specified, or the conditional quantile function is correctly specified.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augX">augX</a></code>
</p>

<hr>
<h2 id='get_os'>Get the OS from R</h2><span id='topic+get_os'></span>

<h3>Description</h3>

<p>Get the type of the operating system. The returned value is used in configuring
parallel computation for the implemented algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_os()
</code></pre>


<h3>References</h3>

<p>This function is adapted from <a href="https://www.r-bloggers.com/identifying-the-os-from-r/">https://www.r-bloggers.com/identifying-the-os-from-r/</a>
</p>

<hr>
<h2 id='IPWE_MADopt'>Estimation of the Optimal Treatment Regime defined as Minimizing
Gini's Mean Differences</h2><span id='topic+IPWE_MADopt'></span>

<h3>Description</h3>

<p><code>IPWE_MADopt</code> seeks to estimated the treatment regime which <b>minimizes</b>
the Gini's Mean difference defined below.
</p>
<p>Besides mean and quantile criterion, in some applications
people seek minimization of dispersion in the outcome, which, for example, can
be described by Gini's mean difference. Formally, it is defined as the absolute
differences of two random variables <code class="reqn">Y_1</code> and <code class="reqn">Y_2</code> drawn independently
from the same distribution: </p>
<p style="text-align: center;"><code class="reqn">MAD:= E(|Y_1-Y_2|).</code>
</p>

<p>Given a treatment regime <code class="reqn">d</code>, define the potential outcome of a subject
following the treatment recommended by <code>d</code> as
<code class="reqn">Y^{*}(d)</code>. When <code class="reqn">d</code> is followed by everyone in the target population,
the Gini's mean absolute difference is
</p>
<p style="text-align: center;"><code class="reqn">MAD(d):= E(| Y_1^{*}(d)-Y_2^{*}(d) |).</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>IPWE_MADopt(data, regimeClass, moPropen = "BinaryRandom", s.tol, it.num = 8,
  hard_limit = FALSE, cl.setup = 1, p_level = 1, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IPWE_MADopt_+3A_data">data</code></td>
<td>
<p>a data frame, containing variables in the <code>moPropen</code> and <code>RegimeClass</code> and 
a component <code>y</code> as the response.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x)=I\left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
       </code>
</p>

<p>Polynomial arguments are also supported.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="IPWE_MADopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>This estimated parameters indexing the MAD-optimal treatment regime are returned 
<em>in two scales:</em>
</p>

<ol>
<li><p> The returned <code>coefficients</code> is the set of parameters after covariates <code class="reqn">X</code> 
are standardized to be in the interval [0, 1]. To be exact, every covariate is 
subtracted by the smallest observed value and divided by the difference between 
the largest and the smallest value.  Next, we carried out the algorithm in Wang et al. 2017 to get the estimated
regime parameters, <code>coefficients</code>, based on the standardized data. 
For the identifiability issue, we force the Euclidean norm of <code>coefficients</code>
to be 1.
</p>
</li>
<li><p> In contrast, <code>coef.orgn.scale</code> corresponds to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x;\bm{\hat{\beta}})= I\{\hat{\beta}_0 + \hat{\beta}_1 x_1 + ... + \hat{\beta}_k x_k &gt; 0\}.</code>
</p>

<p>The estimated <code class="reqn">\bm{\hat{\beta}}</code> is returned as <code>coef.orgn.scale</code>.
The same as <code>coefficients</code>, we force the Euclidean norm of <code>coef.orgn.scale</code>
to be 1.
</p>
</li></ol>

<p>If, for every input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coefficients</code> and <code>coef.orgn.scale</code> will render identical.
</p>


<h3>Value</h3>

<p>This function returns an object with 6 objects. Both <code>coefficients</code>
and <code>coef.orgn.scale</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coefficients</code></dt><dd><p>the parameters indexing the estimated 
MAD-optimal treatment regime for 
standardized covariates.</p>
</dd>
<dt><code>coef.orgn.scale</code></dt><dd><p>the parameter indexing the estimated 
MAD-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>hat_MAD</code></dt><dd><p>the estimated MAD when a treatment regime indexed by
<code>coef.orgn.scale</code> is applied on everyone. See the 'details' for
connection between <code>coef.orgn.scale</code> and
<code>coefficient</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen</code></dt><dd><p>the user specified propensity score model</p>
</dd>
<dt><code>regimeClass</code></dt><dd><p>the user specified class of treatment regimes</p>
</dd>
</dl>



<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData.MAD &lt;- function(n)
{
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  tp &lt;- exp(-1+1*(x1+x2))/(1+exp(-1+1*(x1+x2)))
  a&lt;-rbinom(n = n, size = 1, prob=tp)
  error &lt;- rnorm(length(x1))
  y &lt;- (1 + a*0.6*(-1+x1+x2&lt;0) +  a*-0.6*(-1+x1+x2&gt;0)) * error
  return(data.frame(x1=x1,x2=x2,a=a,y=y))
}
# The true MAD optimal treatment regime for this generative model
# can be deduced trivially, and it is:  c( -0.5773503,  0.5773503,  0.5773503).


# With correctly specified propensity model   ####

n &lt;- 400
testData &lt;- GenerateData.MAD(n)
fit1 &lt;- IPWE_MADopt(data = testData, regimeClass = a~x1+x2,
                    moPropen=a~x1+x2, cl.setup=2)
fit1

             


# With incorrectly specified propensity model ####

fit2 &lt;- IPWE_MADopt(data = testData, regimeClass = a~x1+x2,
                    moPropen="BinaryRandom", cl.setup=2)
fit2


</code></pre>

<hr>
<h2 id='IPWE_Mopt'>Estimate the Mean-optimal Treatment Regime</h2><span id='topic+IPWE_Mopt'></span>

<h3>Description</h3>

<p><code>IPWE_Mopt</code> aims at estimating the treatment regime which
maximizes the marginal mean of the potential outcomes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Mopt(data, regimeClass, moPropen = "BinaryRandom", max = TRUE,
  s.tol = 1e-04, cl.setup = 1, p_level = 1, it.num = 10,
  hard_limit = FALSE, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IPWE_Mopt_+3A_data">data</code></td>
<td>
<p>a data frame, containing variables in the <code>moPropen</code> and <code>RegimeClass</code> and 
a component <code>y</code> as the response.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x)=I\left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
       </code>
</p>

<p>Polynomial arguments are also supported.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
mean; If <code>max=FALSE</code>, we wish to minimize the marginal mean. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Mopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>This functions returns the estimated parameters indexing the 
mean-optimal treatment regime under two scales. 
</p>
<p>The returned <code>coefficients</code> is the set of parameters when covariates are 
all standardized to be in the interval [0, 1] by subtracting the smallest observed
value and divided by the difference between the largest and the smallest value. 
</p>
<p>While the returned <code>coef.orgn.scale</code> corresponds to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\hat{\beta}_0 + \hat{\beta}_1 x_1 + ... + \hat{\beta}_k x_k &gt; 0\}.</code>
</p>

<p>The estimated <code class="reqn">\bm{\hat{\beta}}</code> is returned as <code>coef.orgn.scale</code>.
</p>
<p>If, for every input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coefficients</code> and <code>coef.orgn.scale</code> will render identical.
</p>


<h3>Value</h3>

<p>This function returns an object with 6 objects. Both <code>coefficients</code>
and <code>coef.orgn.scale</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coefficients</code></dt><dd><p>the parameters indexing the estimated 
mean-optimal treatment regime for 
standardized covariates.</p>
</dd>
<dt><code>coef.orgn.scale</code></dt><dd><p>the parameter indexing the estimated 
mean-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>hatM</code></dt><dd><p>the estimated marginal mean  when a treatment regime indexed by
<code>coef.orgn.scale</code> is applied on everyone. See the 'details' for
connection between <code>coef.orgn.scale</code> and
<code>coefficient</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen</code></dt><dd><p>the user specified propensity score model</p>
</dd>
<dt><code>regimeClass</code></dt><dd><p>the user specified class of treatment regimes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a>, with substantial contribution from Ben Sherwood.
</p>


<h3>References</h3>

<p>Zhang B, Tsiatis AA, Laber EB and Davidian M (2012).
&ldquo;A robust method for estimating optimal treatment regimes.&rdquo;
<em>Biometrics</em>, <b>68</b>(4), pp. 1010&ndash;1018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData.test.IPWE_Mopt &lt;- function(n)
{
  x1 &lt;- runif(n)
  x2 &lt;- runif(n)
  tp &lt;- exp(-1+1*(x1+x2))/(1+exp(-1+1*(x1+x2)))
  error &lt;- rnorm(length(x1), sd=0.5)
  a &lt;- rbinom(n = n, size = 1, prob=tp)
  y &lt;- 1+x1+x2 +  a*(3 - 2.5*x1 - 2.5*x2) + 
        (0.5 + a*(1+x1+x2)) * error
  return(data.frame(x1=x1,x2=x2,a=a,y=y))
}

n &lt;- 500
testData &lt;- GenerateData.test.IPWE_Mopt(n)
fit &lt;- IPWE_Mopt(data=testData, regimeClass = a~x1+x2, 
                 moPropen=a~x1+x2, 
                 pop.size=1000)
fit



</code></pre>

<hr>
<h2 id='IPWE_Qopt'>Estimate the Quantile-optimal Treatment Regime</h2><span id='topic+IPWE_Qopt'></span>

<h3>Description</h3>

<p>Estimate the Quantile-optimal Treatment Regime by inverse probability of weighting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IPWE_Qopt(data, regimeClass, tau, moPropen = "BinaryRandom", max = TRUE,
  s.tol, it.num = 8, hard_limit = FALSE, cl.setup = 1, p_level = 1,
  pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IPWE_Qopt_+3A_data">data</code></td>
<td>
<p>a data frame, containing variables in the <code>moPropen</code> and <code>RegimeClass</code> and 
a component <code>y</code> as the response.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_regimeclass">regimeClass</code></td>
<td>
<p>a formula specifying the class of treatment regimes to search,
e.g. if <code>regimeClass = a~x1+x2</code>, and then this function will search the class of treatment regimes
of the form 
</p>
<p style="text-align: center;"><code class="reqn">d(x)=I\left(\beta_0 +\beta_1  x_1 + \beta_2  x_2 &gt; 0\right).
       </code>
</p>

<p>Polynomial arguments are also supported.
See also 'Details'.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_mopropen">moPropen</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1.
When <code>moPropen</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
quantile; if <code>max=FALSE</code>, we wish to minimize the marginal quantile. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="IPWE_Qopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>This estimated parameters indexing the quantile-optimal treatment regime are returned <em>in two scales:</em>
</p>

<ol>
<li><p> The returned <code>coefficients</code> is the set of parameters after covariates <code class="reqn">X</code> 
are standardized to be in the interval [0, 1]. To be exact, every covariate is 
subtracted by the smallest observed value and divided by the difference between 
the largest and the smallest value.  Next, we carried out the algorithm in Wang et al. 2017 to get the estimated
regime parameters, <code>coefficients</code>, based on the standardized data. 
For the identifiability issue, we force the Euclidean norm of <code>coefficients</code>
to be 1.
</p>
</li>
<li><p> In contrast, <code>coef.orgn.scale</code> corresponds to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\hat{\beta}_0 + \hat{\beta}_1 x_1 + ... + \hat{\beta}_k x_k &gt; 0\}.</code>
</p>

<p>The estimated <code class="reqn">\bm{\hat{\beta}}</code> is returned as <code>coef.orgn.scale</code>.
The same as <code>coefficients</code>, we force the Euclidean norm of <code>coef.orgn.scale</code>
to be 1.
</p>
</li></ol>

<p>If, for every input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coefficients</code> and <code>coef.orgn.scale</code> will render identical.
</p>


<h3>Value</h3>

<p>This function returns an object with 7 objects. Both <code>coefficients</code>
and <code>coef.orgn.scale</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coefficients</code></dt><dd><p>the parameters indexing the estimated 
quantile-optimal treatment regime for 
standardized covariates.</p>
</dd>
<dt><code>coef.orgn.scale</code></dt><dd><p>the parameter indexing the estimated 
quantile-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>tau</code></dt><dd><p>the quantile of interest</p>
</dd>
<dt><code>hatQ</code></dt><dd><p>the estimated marginal tau-th quantile when the treatment 
regime indexed by <code>coef.orgn.scale</code> is applied on everyone.
See the 'details' for connection between <code>coef.orgn.scale</code> and
<code>coefficient</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen</code></dt><dd><p>the user specified propensity score model</p>
</dd>
<dt><code>regimeClass</code></dt><dd><p>the user specified class of treatment regimes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a> with substantial contribution from Ben Sherwood.
</p>


<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GenerateData &lt;- function(n)
{
  x1 &lt;- runif(n, min=-0.5,max=0.5)
  x2 &lt;- runif(n, min=-0.5,max=0.5)
  error &lt;- rnorm(n, sd= 0.5)
  tp &lt;- exp(-1+1*(x1+x2))/(1+exp(-1+1*(x1+x2)))
  a &lt;- rbinom(n = n, size = 1, prob=tp)
  y &lt;-  1+x1+x2 +  a*(3 - 2.5*x1 - 2.5*x2) +  (0.5 + a*(1+x1+x2)) * error
  return(data.frame(x1=x1,x2=x2,a=a,y=y))
}
n &lt;- 300
testData &lt;- GenerateData(n)

# 1. Estimate the 0.25th-quantile optimal treatment regime. ###

fit1 &lt;- IPWE_Qopt(data = testData, regimeClass = "a~x1+x2",
           tau = 0.25, moPropen="a~x1+x2")
fit1


# 2. Go parallel. This saves time in calculation. ###

fit2 &lt;- IPWE_Qopt(data = testData, regimeClass = "a~x1+x2",
           tau = 0.25, moPropen="a~x1+x2", cl.setup=2)
fit2




# 3. Set a quardratic term in the class #######################

fit3 &lt;- IPWE_Qopt(data = testData, regimeClass = "a~x1+x2+I(x1^2)",
                  tau = 0.25, moPropen="a~x1+x2", pop.size=1000)
fit3


# 4. Set screen prints level. #######################
# Set the p_level to be 0, 
# then all screen prints from the genetic algorithm will be suppressed.

fit4 &lt;- IPWE_Qopt(data = testData, regimeClass = "a~x1+x2",
           tau = 0.25, moPropen="a~x1+x2", cl.setup=2, p_level=0)
fit4

</code></pre>

<hr>
<h2 id='mean_est'>The Inverse Probability Weighted Estimator of the Marginal Mean Given a Specific Treatment Regime</h2><span id='topic+mean_est'></span>

<h3>Description</h3>

<p>Estimate the marginal mean of the response when the entire population
follows a treatment regime. This function implements the inverse probability weighted
estimator proposed by Baqun Zhang et. al..
</p>
<p>This function supports the <code><a href="#topic+mestimate">mestimate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_est(beta, x, a, y, prob)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_est_+3A_beta">beta</code></td>
<td>
<p>a vector indexing the treatment regime.
It indexes a linear treatment regime:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\}.
</code>
</p>
</td></tr>
<tr><td><code id="mean_est_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.
This is important that columns in <code>x</code> matches with <code>beta</code>.</p>
</td></tr>
<tr><td><code id="mean_est_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="mean_est_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="mean_est_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zhang B, Tsiatis AA, Laber EB and Davidian M (2012).
&ldquo;A robust method for estimating optimal treatment regimes.&rdquo;
<em>Biometrics</em>, <b>68</b>(4), pp. 1010&ndash;1018.
</p>

<hr>
<h2 id='mestimate'>The Mean-Optimal Treatment Regime Wrapper Function</h2><span id='topic+mestimate'></span>

<h3>Description</h3>

<p>The wrapper function for mean-optimal treatment regime that calls a genetic algorithm.
This function supports the <code><a href="#topic+IPWE_Mopt">IPWE_Mopt</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mestimate(x, y, a, prob, p_level, nvars, hard_limit = FALSE, max = TRUE,
  cl.setup = 1, s.tol = 1e-04, it.num = 8, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mestimate_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="mestimate_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="mestimate_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
<tr><td><code id="mestimate_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="mestimate_+3A_nvars">nvars</code></td>
<td>
<p>an integer. The number of parameters indexing a treatment regime.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. This logical variable determines if the
max.generations variable is a binding constraint for genoud.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
mean; If <code>max=FALSE</code>, we wish to minimize the marginal mean. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="mestimate_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zhang B, Tsiatis AA, Laber EB and Davidian M (2012).
&ldquo;A robust method for estimating optimal treatment regimes.&rdquo;
<em>Biometrics</em>, <b>68</b>(4), pp. 1010&ndash;1018.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+IPWE_Mopt">IPWE_Mopt</a></code> is based on this function.
</p>

<hr>
<h2 id='qestimate'>The Quantile-Optimal Treatment Regime Wrapper Function</h2><span id='topic+qestimate'></span>

<h3>Description</h3>

<p>The wrapper function for quantile-optimal treatment regime that calls a genetic algorithm.
This function supports the <code><a href="#topic+IPWE_Qopt">IPWE_Qopt</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qestimate(tau, x, y, a, prob, p_level, nvars, hard_limit, max = TRUE,
  cl.setup = 1, s.tol = 1e-04, it.num = 8, pop.size = 3000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qestimate_+3A_tau">tau</code></td>
<td>
<p>a numeric value between 0 and 1. The quantile level of interest.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="qestimate_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="qestimate_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
<tr><td><code id="qestimate_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="qestimate_+3A_nvars">nvars</code></td>
<td>
<p>an integer. The number of parameters indexing a treatment regime.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. This logical variable determines if the max.generations
variable is a binding constraint for <code>rgenoud::genoud()</code>.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
quantile; if <code>max=FALSE</code>, we wish to minimize the marginal quantile. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="qestimate_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+IPWE_Qopt">IPWE_Qopt</a></code> is based on this function.
</p>

<hr>
<h2 id='quant_est'>Estimate the Marginal Quantile Given a Specific Treatment Regime</h2><span id='topic+quant_est'></span>

<h3>Description</h3>

<p>Estimate the marginal quantile if the entire population follows a 
treatment regime indexed by the given parameters.
This function supports the <code><a href="#topic+qestimate">qestimate</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quant_est(beta, x, y, a, prob, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quant_est_+3A_beta">beta</code></td>
<td>
<p>a vector indexing the treatment regime.
It indexes a linear treatment regime:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\}.
</code>
</p>
</td></tr>
<tr><td><code id="quant_est_+3A_x">x</code></td>
<td>
<p>a matrix of observed covariates from the sample. 
Notice that we assumed the class of treatment regimes is linear.
This is important that columns in <code>x</code> matches with <code>beta</code>.</p>
</td></tr>
<tr><td><code id="quant_est_+3A_y">y</code></td>
<td>
<p>a vector, the observed responses from a sample</p>
</td></tr>
<tr><td><code id="quant_est_+3A_a">a</code></td>
<td>
<p>a vector of 0s and 1s, the observed treatments from a sample</p>
</td></tr>
<tr><td><code id="quant_est_+3A_prob">prob</code></td>
<td>
<p>a vector, the propensity scores of getting treatment 1 in the samples</p>
</td></tr>
<tr><td><code id="quant_est_+3A_tau">tau</code></td>
<td>
<p>a numeric value between 0 and 1. The quantile level of interest.</p>
</td></tr>
</table>

<hr>
<h2 id='TwoStg_Mopt'>Estimate the Two-stage Mean-Optimal Treatment Regime</h2><span id='topic+TwoStg_Mopt'></span>

<h3>Description</h3>

<p>This function implements the estimator of 
two-stage mean-optimal treatment regime by inverse probability of weighting 
proposed by Baqun Zhang. As there are more than one stage, the second stage
treatment regime could take into account the evolving status of an individual
after the first stage
and the treatment level received in the first stage. We assume the options at 
the two stages are both binary and take the form:
</p>
<p style="text-align: center;"><code class="reqn">d_1(x_{stage1})=I\left(\beta_{10} +\beta_{11}  x_{11} +...+ \beta_{1k}  x_{1k} &gt; 0\right), 
</code>
</p>

<p style="text-align: center;"><code class="reqn">d_2(x_{stage2})=I\left(\beta_{20} +\beta_{21}  x_{21} +...+ \beta_{2j}  x_{2j} &gt; 0\right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>TwoStg_Mopt(data, regimeClass.stg1, regimeClass.stg2,
  moPropen1 = "BinaryRandom", moPropen2 = "BinaryRandom", max = TRUE,
  s.tol, cl.setup = 1, p_level = 1, it.num = 10, pop.size = 3000,
  hard_limit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoStg_Mopt_+3A_data">data</code></td>
<td>
<p>a data frame, containing variables in the <code>moPropen</code> and <code>RegimeClass</code> and 
a component <code>y</code> as the response.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_regimeclass.stg1">regimeClass.stg1</code></td>
<td>
<p>a formula or a string specifying the Class of treatment regimes
at stage 1, e.g. <code>a1~x1+x2</code></p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_regimeclass.stg2">regimeClass.stg2</code></td>
<td>
<p>a formula or a string specifying the Class of treatment regimes
at stage 2, e.g. <code>a2~x1+a1+x2</code></p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_mopropen1">moPropen1</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1 at the first stage .
When <code>moPropen1</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample at the first stage will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function 
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_mopropen2">moPropen2</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1 at the second stage .
When <code>moPropen2</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample at the second stage will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string,  based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a2~x1+a1+x2</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
mean; if <code>max=FALSE</code>, we wish to minimize the marginal mean. 
The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="TwoStg_Mopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>For every stage <code>k</code>, <code class="reqn">k=1,2</code>, this estimated parameters indexing the two-stage mean-optimal treatment regime
are returned <em>in two scales:</em>
</p>

<ol>
<li><p> , the returned <code>coef.k</code> 
is the set of parameters that we estimated after standardizing
every covariate available for decision-making
at stage <code>k</code> to be in the interval [0, 1]. To be exact, every covariate is 
subtracted by the smallest observed value and divided by the difference between 
the largest and the smallest value.  Next, we carried out the algorithm in Wang 2016 to get the estimated
regime parameters, <code>coef.k</code>, based on the standardized data. 
For the identifiability issue, we force the Euclidean norm of <code>coef.k</code>
to be 1.
</p>
</li>
<li><p> The difference between <code>coef.k</code> and <code>coef.orgn.scale.k</code> is that the latter
set of parameters correspond to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\},</code>
</p>

<p>where the <code class="reqn">\beta</code> values are returned as <code>coef.orgn.scale.k</code>, and the
the vector <code class="reqn">(1, x_1,...,x_k)</code> corresponds to the specified class of treatment
regimes in the <code>k</code>th stage.
</p>
</li></ol>

<p>If, for every input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coef.k</code> and <code>coef.orgn.scale.k</code> will render identical.
</p>


<h3>Value</h3>

<p>This function returns an object with 6 objects. Both <code>coef.1</code>, <code>coef.2</code>
and <code>coef.orgn.scale.1</code>, <code>coef.orgn.scale.2</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coef.1</code>, <code>coef.2</code></dt><dd><p>the set of parameters indexing the estimated 
mean-optimal treatment regime for 
standardized covariates.</p>
</dd>
<dt><code>coef.orgn.scale.1</code>, <code>coef.orgn.scale.2</code></dt><dd><p>the set of parameter 
indexing the estimated mean-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>hatM</code></dt><dd><p>the estimated marginal mean when the treatment 
regime indexed by <code>coef.orgn.scale.1</code> and <code>coef.orgn.scale.2</code> 
is applied on the entire population.
See the 'details' for connection between <code>coef.orgn.scale.k</code> and
<code>coef.k</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen1</code>, <code>moPropen2</code></dt><dd><p>the user specified propensity score models
for the first and the second stage respectively</p>
</dd>
<dt><code>regimeClass.stg1</code>,  <code>regimeClass.stg2</code></dt><dd><p>the user specified 
class of treatment regimes for the first and the second stage respectively</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a>
</p>


<h3>References</h3>

<p>Zhang B, Tsiatis AA, Laber EB and Davidian M (2013).
&ldquo;Robust estimation of optimal dynamic treatment regimes for sequential treatment decisions.&rdquo;
<em>Biometrika</em>, <b>100</b>(3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ilogit &lt;- function(x) exp(x)/(1 + exp(x))
GenerateData.2stg &lt;- function(n){
 x1 &lt;- runif(n)
 p1 &lt;- ilogit(-0.5+x1)
 a1 &lt;- rbinom(n, size=1, prob=p1)
 
 x2 &lt;- runif(n, x1, x1+1)
 p2 &lt;- ilogit(-1 + x2)
 a2 &lt;- rbinom(n, size=1, prob=p2)
 
 mean &lt;- 1+x1+a1*(1-3*(x1-0.2)^2) +x2 + a2*(1-x2-x1)
 y &lt;- mean + (1+a1*(x1-0.5)+0.5*a2*(x2-1))*rnorm(n,0,sd = 1)
 return(data.frame(x1,a1,x2,a2,y))
}

n &lt;- 400
testdata &lt;- GenerateData.2stg(n)

fit &lt;- TwoStg_Mopt(data=testdata, 
                   regimeClass.stg1="a1~x1", regimeClass.stg2="a2~x1+a1+x2",
                   moPropen1="a1~x1", moPropen2="a2~x2",
                   cl.setup=2)
fit

fit2 &lt;- TwoStg_Mopt(data=testdata, 
                   regimeClass.stg1="a1~x1", regimeClass.stg2="a2~a1+x1*x2",
                   moPropen1="a1~x1", moPropen2="a2~x2",
                   cl.setup=2)
fit2




</code></pre>

<hr>
<h2 id='TwoStg_Qopt'>Estimate the Two-stage Quantile-optimal Treatment Regime</h2><span id='topic+TwoStg_Qopt'></span>

<h3>Description</h3>

<p>This function implements the estimator of 
two-stage quantile-optimal treatment regime by inverse probability of weighting 
proposed by Lan Wang, et al. As there are more than one stage, the second stage
treatment regime could take into account the evolving status of an individual
after the first stage
and the treatment level received in the first stage. We assume the options at 
the two stages are both binary and take the form:
</p>
<p style="text-align: center;"><code class="reqn">d_1(x)=I\left(\beta_{10} +\beta_{11}  x_{11} +...+ \beta_{1k}  x_{1k} &gt; 0\right), 
</code>
</p>

<p style="text-align: center;"><code class="reqn">d_2(x)=I\left(\beta_{20} +\beta_{21}  x_{21} +...+ \beta_{2p}  x_{2p} &gt; 0\right)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>TwoStg_Qopt(data, tau, regimeClass.stg1, regimeClass.stg2,
  moPropen1 = "BinaryRandom", moPropen2 = "BinaryRandom", s.tol = 1e-04,
  it.num = 8, max = TRUE, cl.setup = 1, p_level = 1, pop.size = 1000,
  hard_limit = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TwoStg_Qopt_+3A_data">data</code></td>
<td>
<p>a data frame, containing variables in the <code>moPropen</code> and <code>RegimeClass</code> and 
a component <code>y</code> as the response.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_tau">tau</code></td>
<td>
<p>a value between 0 and 1. This is the quantile of interest.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_regimeclass.stg1">regimeClass.stg1</code></td>
<td>
<p>a formula or a string specifying the Class of treatment regimes
at stage 1, e.g. <code>a1~x1+x2</code></p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_regimeclass.stg2">regimeClass.stg2</code></td>
<td>
<p>a formula or a string specifying the Class of treatment regimes
at stage 2, e.g. <code>a2~x1+a1+x2</code></p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_mopropen1">moPropen1</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1 at the first stage .
When <code>moPropen1</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample at the first stage will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string, based on which this function 
will fit a logistic regression on the treatment level.  e.g. <code>a1~x1</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_mopropen2">moPropen2</code></td>
<td>
<p>The propensity score model for the probability of receiving 
treatment level 1 at the second stage .
When <code>moPropen2</code> equals the string &quot;BinaryRandom&quot;,  the proportion of observations
receiving treatment level 1 in the sample at the second stage will be employed
as a good estimate of the probability for each observation.
Otherwise, this argument should be a formula/string,  based on which this function
will fit a logistic regression on the treatment level.  e.g. <code>a2~x1+a1+x2</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_s.tol">s.tol</code></td>
<td>
<p>This is the tolerance level used by <code>genoud</code>. 
Default is <code class="reqn">10^{-5}</code> times the difference between
the largest and the smallest value in the observed responses.
This is particularly important when it comes to evaluating <code>it.num</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_it.num">it.num</code></td>
<td>
<p>integer &gt; 1. This argument will be used in <code>rgeound::geound</code> function.
If there is no improvement in the objective function in this number of generations,
<code>rgenoud::genoud</code> will think that it has found the optimum.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_max">max</code></td>
<td>
<p>logical. If <code>max=TRUE</code>, it indicates we wish to maximize the marginal
quantile; if <code>max=FALSE</code>, we wish to minimize the marginal quantile. The default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_cl.setup">cl.setup</code></td>
<td>
<p>the number of nodes. &gt;1 indicates choosing parallel computing option in 
<code>rgenoud::genoud</code>. Default is 1.</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_p_level">p_level</code></td>
<td>
<p>choose between 0,1,2,3 to indicate different levels of output
from the genetic function. Specifically, 0 (minimal printing),
1 (normal), 2 (detailed), and 3 (debug.)</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_pop.size">pop.size</code></td>
<td>
<p>an integer with the default set to be 3000. This is the population number for the first generation
in the genetic algorithm (<code>rgenoud::genoud</code>).</p>
</td></tr>
<tr><td><code id="TwoStg_Qopt_+3A_hard_limit">hard_limit</code></td>
<td>
<p>logical. When it is true the maximum number of generations
in  <code>rgeound::geound</code> cannot exceed 100. Otherwise, in this function, only
<code>it.num</code> softly controls when <code>genoud</code> stops. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that all estimation functions in this package use the same type
of standardization on covariates. Doing so would allow us to provide a bounded 
domain of parameters for searching in the genetic algorithm.
</p>
<p>For every stage <code>k</code>, <code class="reqn">k=1,2</code>, this estimated parameters indexing the 
two-stage quantile-optimal treatment regime are returned <em>in two scales:</em>
</p>

<ol>
<li><p> , the returned <code>coef.k</code> 
is the set of parameters that we estimated after standardizing
every covariate available for decision-making
at stage <code>k</code> to be in the interval [0, 1]. To be exact, every covariate is 
subtracted by the smallest observed value and divided by the difference between 
the largest and the smallest value.  Next, we carried out the algorithm in Wang et. al. 2017 to get the estimated
regime parameters, <code>coef.k</code>, based on the standardized data. 
For the identifiability issue, we force the Euclidean norm of <code>coef.k</code>
to be 1.
</p>
</li>
<li><p> The difference between <code>coef.k</code> and <code>coef.orgn.scale.k</code> is that the latter
set of parameters correspond to the original covariates,
so the associated decision rule can be applied directly to novel observations. 
In other words, let <code class="reqn">\beta</code> denote the estimated parameter in the original 
scale, then the estimated treatment regime is:  
</p>
<p style="text-align: center;"><code class="reqn"> d(x)= I\{\beta_0 + \beta_1 x_1 + ... + \beta_k x_k &gt; 0\},</code>
</p>

<p>where the <code class="reqn">\beta</code> values are returned as <code>coef.orgn.scale.k</code>, and the
the vector <code class="reqn">(1, x_1,...,x_k)</code> corresponds to the specified class of treatment
regimes in the <code>k</code>th stage.
</p>
</li></ol>

<p>If, for every input covariate, the smallest observed value is exactly 0 and the range 
(i.e. the largest number minus the smallest number) is exactly 1, then the estimated 
<code>coef.k</code> and <code>coef.orgn.scale.k</code> will render identical.
</p>


<h3>Value</h3>

<p>This function returns an object with 7 objects. Both <code>coefficients</code>
and <code>coef.orgn.scale</code>  were normalized to have unit euclidean norm.
</p>

<dl>
<dt><code>coef.1</code>, <code>coef.2</code></dt><dd><p>the set of parameters indexing the estimated 
quantile-optimal treatment regime for 
standardized covariates.</p>
</dd>
<dt><code>coef.orgn.scale.1</code>, <code>coef.orgn.scale.2</code></dt><dd><p>the set of parameter 
indexing the estimated quantile-optimal treatment regime for the original input covariates.</p>
</dd>
<dt><code>tau</code></dt><dd><p>the quantile of interest</p>
</dd>
<dt><code>hatQ</code></dt><dd><p>the estimated marginal quantile when the treatment 
regime indexed by <code>coef.orgn.scale.1</code> and <code>coef.orgn.scale.2</code> 
is applied on the entire population.
See the 'details' for connection between <code>coef.orgn.scale.k</code> and
<code>coef.k</code>.</p>
</dd>
<dt><code>call</code></dt><dd><p>the user's call.</p>
</dd>
<dt><code>moPropen1</code>, <code>moPropen2</code></dt><dd><p>the user specified propensity score models
for the first and the second stage respectively</p>
</dd>
<dt><code>regimeClass.stg1</code>,  <code>regimeClass.stg2</code></dt><dd><p>the user specified 
class of treatment regimes for the first and the second stage respectively</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Yu Zhou, <a href="mailto:zhou0269@umn.edu">zhou0269@umn.edu</a>
</p>


<h3>References</h3>

<p>Wang L, Zhou Y, Song R and Sherwood B (2017).
&ldquo;Quantile-Optimal Treatment Regimes.&rdquo;
<em>Journal of the American Statistical Association</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ilogit &lt;- function(x) exp(x)/(1 + exp(x))
GenerateData.2stg &lt;- function(n){
 x1 &lt;- runif(n)
 p1 &lt;- ilogit(-0.5+x1)
 a1 &lt;- rbinom(n, size=1, prob=p1)
 
 x2 &lt;- runif(n,x1,x1+1)
 p2 &lt;- ilogit(-1 + x2)
 a2 &lt;- rbinom(n, size=1, prob=p2)
 
 mean &lt;- 1+x1+a1*(1-3*(x1-0.2)^2) +x2 + a2*(1-x2-x1)
 y &lt;- mean + (1+a1*(x1-0.5)+0.5*a2*(x2-1))*rnorm(n,0,sd = 1)
 return(data.frame(x1,a1,x2,a2,y))
}

n &lt;- 400
testdata &lt;- GenerateData.2stg(n)
fit &lt;- TwoStg_Qopt(data=testdata, tau=0.2,
                   regimeClass.stg1=a1~x1, regimeClass.stg2=a2~x1+a1+x2,
                   moPropen1=a1~x1, moPropen2=a2 ~ x2,
                   cl.setup=2)
fit



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
