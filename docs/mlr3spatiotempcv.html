<!DOCTYPE html><html lang="en"><head><title>Help for package mlr3spatiotempcv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mlr3spatiotempcv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mlr3spatiotempcv-package'><p>mlr3spatiotempcv: Spatiotemporal Resampling Methods for 'mlr3'</p></a></li>
<li><a href='#as_task_classif_st'><p>Convert to a Spatiotemporal Classification Task</p></a></li>
<li><a href='#as_task_regr_st.TaskClassifST'><p>Convert to a Spatiotemporal Regression Task</p></a></li>
<li><a href='#assert_spatial_task'><p>Check spatial task</p></a></li>
<li><a href='#autoplot'><p>Re-export of <code>autoplot</code></p></a></li>
<li><a href='#autoplot_multi_fold_dt'><p>Autoplot helper</p></a></li>
<li><a href='#autoplot.ResamplingCustomCV'><p>Visualization Functions for Non-Spatial CV Methods.</p></a></li>
<li><a href='#autoplot.ResamplingCV'><p>Visualization Functions for Non-Spatial CV Methods.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVBlock'><p>Visualization Functions for SpCV Block Methods.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVBuffer'><p>Visualization Functions for SpCV Buffer Methods.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVCoords'><p>Visualization Functions for SpCV Coords Methods.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVDisc'><p>Visualization Functions for SpCV Disc Method.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVEnv'><p>Visualization Functions for SpCV Env Methods.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVKnndm'><p>Visualization Functions for SpCV knndm Method.</p></a></li>
<li><a href='#autoplot.ResamplingSpCVTiles'><p>Visualization Functions for SpCV Tiles Method.</p></a></li>
<li><a href='#autoplot.ResamplingSptCVCstf'><p>Visualization Functions for SptCV Cstf Methods.</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_block'><p>(blockCV) Repeated spatial block resampling</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_coords'><p>(sperrorest) Repeated coordinate-based k-means clustering</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_disc'><p>(sperrorest) Repeated spatial &quot;disc&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_env'><p>(blockCV) Repeated &quot;environmental blocking&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_knndm'><p>(CAST) Repeated K-fold Nearest Neighbour Distance Matching</p></a></li>
<li><a href='#mlr_resamplings_repeated_spcv_tiles'><p>(sperrorest) Repeated spatial &quot;tiles&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_repeated_sptcv_cstf'><p>(CAST) Repeated spatiotemporal &quot;leave-location-and-time-out&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_spcv_block'><p>(blockCV) Spatial block resampling</p></a></li>
<li><a href='#mlr_resamplings_spcv_buffer'><p>(blockCV) Spatial buffering resampling</p></a></li>
<li><a href='#mlr_resamplings_spcv_coords'><p>(sperrorest) Coordinate-based k-means clustering</p></a></li>
<li><a href='#mlr_resamplings_spcv_disc'><p>(sperrorest) Spatial &quot;disc&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_spcv_env'><p>(blockCV) &quot;Environmental blocking&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_spcv_knndm'><p>(CAST) K-fold Nearest Neighbour Distance Matching</p></a></li>
<li><a href='#mlr_resamplings_spcv_tiles'><p>(sperrorest) Spatial &quot;Tiles&quot; resampling</p></a></li>
<li><a href='#mlr_resamplings_sptcv_cstf'><p>(CAST) Spatiotemporal &quot;Leave-location-and-time-out&quot; resampling</p></a></li>
<li><a href='#mlr_tasks_cookfarm_mlr3'><p>Cookfarm Profiles Regression Task</p></a></li>
<li><a href='#mlr_tasks_diplodia'><p>Diplodia Classification Task</p></a></li>
<li><a href='#mlr_tasks_ecuador'><p>Ecuador Classification Task</p></a></li>
<li><a href='#strat_sample_folds'><p>Stratified random sampling</p></a></li>
<li><a href='#TaskClassifST'><p>Create a Spatiotemporal Classification Task</p></a></li>
<li><a href='#TaskRegrST'><p>Create a Spatiotemporal Regression Task</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Spatiotemporal Resampling Methods for 'mlr3'</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Extends the mlr3 machine learning framework with
    spatio-temporal resampling methods to account for the presence of
    spatiotemporal autocorrelation (STAC) in predictor variables. STAC may
    cause highly biased performance estimates in cross-validation if
    ignored. A JSS article is available at &lt;<a href="https://doi.org/10.18637%2Fjss.v111.i07">doi:10.18637/jss.v111.i07</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mlr3spatiotempcv.mlr-org.com/">https://mlr3spatiotempcv.mlr-org.com/</a>,
<a href="https://github.com/mlr-org/mlr3spatiotempcv">https://github.com/mlr-org/mlr3spatiotempcv</a>,
<a href="https://mlr3book.mlr-org.com">https://mlr3book.mlr-org.com</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mlr-org/mlr3spatiotempcv/issues">https://github.com/mlr-org/mlr3spatiotempcv/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>mlr3 (&ge; 0.12.0), R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate, data.table, ggplot2 (&ge; 3.4.0), mlr3misc (&ge;
0.11.0), paradox, R6, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bbotk, blockCV (&ge; 3.1.2), caret, CAST (&ge; 0.8.0), ggsci,
ggtext, here, knitr, lgr, mlr3filters (&ge; 0.7.0.9000),
mlr3pipelines, mlr3spatial, mlr3tuning, patchwork, plotly,
rmarkdown, rpart, sf, sperrorest, terra, testthat (&ge; 3.0.0),
twosamples, vdiffr (&ge; 1.0.0), withr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'aaa.R' 'ResamplingRepeatedSpCVBlock.R'
'ResamplingRepeatedSpCVCoords.R' 'ResamplingRepeatedSpCVDisc.R'
'ResamplingRepeatedSpCVEnv.R' 'ResamplingRepeatedSpCVTiles.R'
'ResamplingRepeatedSpCVknndm.R' 'ResamplingRepeatedSptCVCstf.R'
'ResamplingSpCVBlock.R' 'ResamplingSpCVBuffer.R'
'ResamplingSpCVCoords.R' 'ResamplingSpCVDisc.R'
'ResamplingSpCVEnv.R' 'ResamplingSpCVKnndm.R'
'ResamplingSpCVTiles.R' 'ResamplingSptCVCstf.R'
'TaskClassifST.R' 'TaskRegrST.R' 'Task_classif_diplodia.R'
'Task_classif_ecuador.R' 'Task_regr_cookfarm_profiles.R'
'as_task_classif_st.R' 'as_task_regr_st.R' 'autoplot.R'
'autoplot_all_folds_dt.R' 'autoplot_all_folds_list.R'
'autoplot_multi_fold_dt.R' 'autoplot_multi_fold_list.R'
'autoplot_spcv_cstf.R' 'bibentries.R' 'helper.R'
'helper_DataBackend.R' 'helper_autoplot.R' 'reexports.R'
'zzz.R'</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-29 12:51:06 UTC; pjs</td>
</tr>
<tr>
<td>Author:</td>
<td>Patrick Schratz <a href="https://orcid.org/0000-0003-0748-6624"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Marc Becker <a href="https://orcid.org/0000-0002-8115-0400"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Jannes Muenchow <a href="https://orcid.org/0000-0001-7834-4717"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Michel Lang <a href="https://orcid.org/0000-0001-9754-0393"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Patrick Schratz &lt;patrick.schratz@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-29 13:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mlr3spatiotempcv-package'>mlr3spatiotempcv: Spatiotemporal Resampling Methods for 'mlr3'</h2><span id='topic+mlr3spatiotempcv'></span><span id='topic+mlr3spatiotempcv-package'></span>

<h3>Description</h3>

<p>Extends the mlr3 machine learning framework with spatio-temporal resampling methods to account for the presence of spatiotemporal autocorrelation (STAC) in predictor variables. STAC may cause highly biased performance estimates in cross-validation if ignored. A JSS article is available at <a href="https://doi.org/10.18637/jss.v111.i07">doi:10.18637/jss.v111.i07</a>.
</p>


<h3>Main resources</h3>


<ul>
<li><p> Book on mlr3: <a href="https://mlr3book.mlr-org.com">https://mlr3book.mlr-org.com</a>
</p>
</li>
<li><p> mlr3book section about spatiotemporal data: <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#spatiotemp-cv">https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#spatiotemp-cv</a>
</p>
</li>
<li><p> package vignettes: <a href="https://mlr3spatiotempcv.mlr-org.com/dev/articles/">https://mlr3spatiotempcv.mlr-org.com/dev/articles/</a>
</p>
</li></ul>



<h4>Miscellaneous <span class="pkg">mlr3</span> content</h4>


<ul>
<li><p> Use cases and examples: <a href="https://mlr3gallery.mlr-org.com">https://mlr3gallery.mlr-org.com</a>
</p>
</li>
<li><p> More classification and regression tasks: <a href="https://CRAN.R-project.org/package=mlr3data"><span class="pkg">mlr3data</span></a>
</p>
</li>
<li><p> Connector to <a href="https://www.openml.org">OpenML</a>: <a href="https://CRAN.R-project.org/package=mlr3oml"><span class="pkg">mlr3oml</span></a>
</p>
</li>
<li><p> More classification and regression learners: <a href="https://CRAN.R-project.org/package=mlr3learners"><span class="pkg">mlr3learners</span></a>
</p>
</li>
<li><p> Even more learners: <a href="https://github.com/mlr-org/mlr3extralearners">https://github.com/mlr-org/mlr3extralearners</a>
</p>
</li>
<li><p> Preprocessing and machine learning pipelines: <a href="https://CRAN.R-project.org/package=mlr3pipelines"><span class="pkg">mlr3pipelines</span></a>
</p>
</li>
<li><p> Tuning of hyperparameters: <a href="https://CRAN.R-project.org/package=mlr3tuning"><span class="pkg">mlr3tuning</span></a>
</p>
</li>
<li><p> Visualizations for many <span class="pkg">mlr3</span> objects: <a href="https://CRAN.R-project.org/package=mlr3viz"><span class="pkg">mlr3viz</span></a>
</p>
</li>
<li><p> Survival analysis and probabilistic regression: <a href="https://CRAN.R-project.org/package=mlr3proba"><span class="pkg">mlr3proba</span></a>
</p>
</li>
<li><p> Cluster analysis: <a href="https://CRAN.R-project.org/package=mlr3cluster"><span class="pkg">mlr3cluster</span></a>
</p>
</li>
<li><p> Feature selection filters: <a href="https://CRAN.R-project.org/package=mlr3filters"><span class="pkg">mlr3filters</span></a>
</p>
</li>
<li><p> Feature selection wrappers: <a href="https://CRAN.R-project.org/package=mlr3fselect"><span class="pkg">mlr3fselect</span></a>
</p>
</li>
<li><p> Interface to real (out-of-memory) data bases: <a href="https://CRAN.R-project.org/package=mlr3db"><span class="pkg">mlr3db</span></a>
</p>
</li>
<li><p> Performance measures as plain functions: <a href="https://CRAN.R-project.org/package=mlr3measures"><span class="pkg">mlr3measures</span></a>
</p>
</li>
<li><p> Parallelization framework: <a href="https://CRAN.R-project.org/package=future"><span class="pkg">future</span></a>
</p>
</li>
<li><p> Progress bars: <a href="https://CRAN.R-project.org/package=progressr"><span class="pkg">progressr</span></a>
</p>
</li></ul>




<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Patrick Schratz <a href="mailto:patrick.schratz@gmail.com">patrick.schratz@gmail.com</a> (<a href="https://orcid.org/0000-0003-0748-6624">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Marc Becker <a href="mailto:marcbecker@posteo.de">marcbecker@posteo.de</a> (<a href="https://orcid.org/0000-0002-8115-0400">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Jannes Muenchow <a href="mailto:jannes.muenchow@uni-jena.de">jannes.muenchow@uni-jena.de</a> (<a href="https://orcid.org/0000-0001-7834-4717">ORCID</a>) [contributor]
</p>
</li>
<li><p> Michel Lang <a href="mailto:michellang@gmail.com">michellang@gmail.com</a> (<a href="https://orcid.org/0000-0001-9754-0393">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Schratz P, Muenchow J, Iturritxa E, Richter J, Brenning A (2019).
&ldquo;Hyperparameter tuning and performance assessment of statistical and machine-learning algorithms using spatial data.&rdquo;
<em>Ecological Modelling</em>, <b>406</b>, 109&ndash;120.
<a href="https://doi.org/10.1016/j.ecolmodel.2019.06.002">doi:10.1016/j.ecolmodel.2019.06.002</a>.
</p>
<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>
<p>Meyer H, Reudenbach C, Hengl T, Katurji M, Nauss T (2018).
&ldquo;Improving performance of spatio-temporal machine learning models using forward feature selection and target-oriented validation.&rdquo;
<em>Environmental Modelling &amp; Software</em>, <b>101</b>, 1&ndash;9.
<a href="https://doi.org/10.1016/j.envsoft.2017.12.001">doi:10.1016/j.envsoft.2017.12.001</a>.
</p>
<p>Zhao Y, Karypis G (2002).
&ldquo;Evaluation of Hierarchical Clustering Algorithms for Document Datasets.&rdquo;
<em>11th Conference of Information and Knowledge Management (CIKM)</em>, 51-524.
<a href="https://doi.org/10.1145/584792.584877">doi:10.1145/584792.584877</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://mlr3spatiotempcv.mlr-org.com/">https://mlr3spatiotempcv.mlr-org.com/</a>
</p>
</li>
<li> <p><a href="https://github.com/mlr-org/mlr3spatiotempcv">https://github.com/mlr-org/mlr3spatiotempcv</a>
</p>
</li>
<li> <p><a href="https://mlr3book.mlr-org.com">https://mlr3book.mlr-org.com</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mlr-org/mlr3spatiotempcv/issues">https://github.com/mlr-org/mlr3spatiotempcv/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as_task_classif_st'>Convert to a Spatiotemporal Classification Task</h2><span id='topic+as_task_classif_st'></span><span id='topic+as_task_classif_st.TaskClassifST'></span><span id='topic+as_task_classif_st.data.frame'></span><span id='topic+as_task_classif_st.DataBackend'></span><span id='topic+as_task_classif_st.sf'></span>

<h3>Description</h3>

<p>Convert an object to a <a href="#topic+TaskClassifST">TaskClassifST</a>.
This is a S3 generic for the following objects:
</p>

<ol>
<li> <p><a href="#topic+TaskClassifST">TaskClassifST</a>: Ensure the identity.
</p>
</li>
<li> <p><code><a href="base.html#topic+data.frame">data.frame()</a></code> and <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>: Provides an alternative to the
constructor of <a href="#topic+TaskClassifST">TaskClassifST</a>.
</p>
</li>
<li> <p><a href="sf.html#topic+sf">sf::sf</a>: Extracts spatial meta data before construction.
</p>
</li>
<li> <p><a href="mlr3.html#topic+TaskRegr">mlr3::TaskRegr</a>: Calls <code><a href="mlr3.html#topic+convert_task">mlr3::convert_task()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>as_task_classif_st(x, ...)

## S3 method for class 'TaskClassifST'
as_task_classif_st(x, clone = FALSE, ...)

## S3 method for class 'data.frame'
as_task_classif_st(
  x,
  target,
  id = deparse(substitute(x)),
  positive = NULL,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'DataBackend'
as_task_classif_st(
  x,
  target,
  id = deparse(substitute(x)),
  positive = NULL,
  coordinate_names,
  crs,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'sf'
as_task_classif_st(
  x,
  target = NULL,
  id = deparse(substitute(x)),
  positive = NULL,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_task_classif_st_+3A_x">x</code></td>
<td>
<p>(any)<br />
Object to convert.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_clone">clone</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, ensures that the returned object is not the same as the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_target">target</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Id for the new task.
Defaults to the (deparsed and substituted) name of the data argument.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_positive">positive</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Only for binary classification: Name of the positive class.
The levels of the target columns are reordered accordingly, so that the
first element of <code style="white-space: pre;">&#8288;$class_names&#8288;</code> is the positive class, and the second
element is the negative class.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_coordinate_names">coordinate_names</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_crs">crs</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_coords_as_features">coords_as_features</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</td></tr>
<tr><td><code id="as_task_classif_st_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance. Shown in <code>as.data.table(mlr_tasks)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+TaskClassifST">TaskClassifST</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces(c("sf"), quietly = TRUE)) {
  library("mlr3")
  data("ecuador", package = "mlr3spatiotempcv")

  # data.frame
  as_task_classif_st(ecuador, target = "slides", positive = "TRUE",
    coords_as_features = FALSE,
    crs = "+proj=utm +zone=17 +south +datum=WGS84 +units=m +no_defs",
    coordinate_names = c("x", "y"))

  # sf
  ecuador_sf = sf::st_as_sf(ecuador, coords = c("x", "y"), crs = 32717)
  as_task_classif_st(ecuador_sf, target = "slides", positive = "TRUE")
}
</code></pre>

<hr>
<h2 id='as_task_regr_st.TaskClassifST'>Convert to a Spatiotemporal Regression Task</h2><span id='topic+as_task_regr_st.TaskClassifST'></span><span id='topic+as_task_regr_st'></span><span id='topic+as_task_regr_st.TaskRegrST'></span><span id='topic+as_task_regr_st.data.frame'></span><span id='topic+as_task_regr_st.DataBackend'></span><span id='topic+as_task_regr_st.sf'></span>

<h3>Description</h3>

<p>Convert object to a <a href="#topic+TaskRegrST">TaskRegrST</a>.
</p>
<p>This is a S3 generic, specialized for at least the following objects:
</p>

<ol>
<li> <p><a href="#topic+TaskRegrST">TaskRegrST</a>: Ensure the identity.
</p>
</li>
<li> <p><code><a href="base.html#topic+data.frame">data.frame()</a></code> and <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>: Provides an alternative to the
constructor of <a href="#topic+TaskRegrST">TaskRegrST</a>.
</p>
</li>
<li> <p><a href="sf.html#topic+sf">sf::sf</a>: Extracts spatial meta data before construction.
</p>
</li>
<li> <p><a href="mlr3.html#topic+TaskClassif">mlr3::TaskClassif</a>: Calls <code><a href="mlr3.html#topic+convert_task">mlr3::convert_task()</a></code>.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'TaskClassifST'
as_task_regr_st(
  x,
  target = NULL,
  drop_original_target = FALSE,
  drop_levels = TRUE,
  ...
)

as_task_regr_st(x, ...)

## S3 method for class 'TaskRegrST'
as_task_regr_st(x, clone = FALSE, ...)

## S3 method for class 'data.frame'
as_task_regr_st(
  x,
  target,
  id = deparse(substitute(x)),
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'DataBackend'
as_task_regr_st(
  x,
  target,
  id = deparse(substitute(x)),
  positive = NULL,
  coordinate_names,
  crs,
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'sf'
as_task_regr_st(
  x,
  target = NULL,
  id = deparse(substitute(x)),
  coords_as_features = FALSE,
  label = NA_character_,
  ...
)

## S3 method for class 'TaskClassifST'
as_task_regr_st(
  x,
  target = NULL,
  drop_original_target = FALSE,
  drop_levels = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_x">x</code></td>
<td>
<p>(any)<br />
Object to convert.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_target">target</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_drop_original_target">drop_original_target</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>FALSE</code> (default), the original target is added as a feature.
Otherwise the original target is dropped.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_drop_levels">drop_levels</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code> (default), unused levels of the new target variable are dropped.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_...">...</code></td>
<td>
<p>(any)<br />
Additional arguments.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_clone">clone</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, ensures that the returned object is not the same as the input <code>x</code>.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_id">id</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Id for the new task.
Defaults to the (deparsed and substituted) name of the data argument.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_coordinate_names">coordinate_names</code></td>
<td>
<p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_crs">crs</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_coords_as_features">coords_as_features</code></td>
<td>
<p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_label">label</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Label for the new instance. Shown in <code>as.data.table(mlr_tasks)</code>.</p>
</td></tr>
<tr><td><code id="as_task_regr_st.TaskClassifST_+3A_positive">positive</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Only for binary classification: Name of the positive class.
The levels of the target columns are reordered accordingly, so that the
first element of <code style="white-space: pre;">&#8288;$class_names&#8288;</code> is the positive class, and the second
element is the negative class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><a href="#topic+TaskRegrST">TaskRegrST</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf"), quietly = TRUE)) {
  library("mlr3")
  data("cookfarm_mlr3", package = "mlr3spatiotempcv")

  # data.frame
  as_task_regr_st(cookfarm_mlr3, target = "PHIHOX",
    coords_as_features = FALSE, crs = 26911,
    coordinate_names = c("x", "y"))

  # sf
  cookfarm_sf = sf::st_as_sf(cookfarm_mlr3, coords = c("x", "y"), crs = 26911)
  as_task_regr_st(cookfarm_sf, target = "PHIHOX")
}

</code></pre>

<hr>
<h2 id='assert_spatial_task'>Check spatial task</h2><span id='topic+assert_spatial_task'></span>

<h3>Description</h3>

<p>Assertion helper for spatial mlr3 tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_spatial_task(task)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assert_spatial_task_+3A_task">task</code></td>
<td>
<p>(<a href="mlr3.html#topic+Task">Task</a>).</p>
</td></tr>
</table>

<hr>
<h2 id='autoplot'>Re-export of <code>autoplot</code></h2><span id='topic+autoplot'></span>

<h3>Description</h3>

<p>See <code><a href="ggplot2.html#topic+autoplot">ggplot2::autoplot()</a></code>.
</p>

<hr>
<h2 id='autoplot_multi_fold_dt'>Autoplot helper</h2><span id='topic+autoplot_multi_fold_dt'></span>

<h3>Description</h3>

<p>Autoplot helper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autoplot_multi_fold_dt(
  task,
  resampling,
  resampling_mod,
  sample_fold_n,
  fold_id,
  repeats_id,
  plot_as_grid,
  show_omitted,
  show_blocks,
  show_labels,
  label_size,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot_multi_fold_dt_+3A_resampling">resampling</code></td>
<td>
<p>Actual resampling object (needed for spcv_block with
&quot;show_blocks = TRUE&quot;)</p>
</td></tr>
<tr><td><code id="autoplot_multi_fold_dt_+3A_resampling_mod">resampling_mod</code></td>
<td>
<p>Modified resampling object (normal data.table)</p>
</td></tr>
</table>

<hr>
<h2 id='autoplot.ResamplingCustomCV'>Visualization Functions for Non-Spatial CV Methods.</h2><span id='topic+autoplot.ResamplingCustomCV'></span><span id='topic+plot.ResamplingCustomCV'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingCustomCV'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingCustomCV'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="mlr3.html#topic+mlr_resamplings_custom_cv">mlr3::ResamplingCustomCV</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCustomCV_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="mlr3.html#topic+mlr_resamplings_custom_cv">mlr3::ResamplingCustomCV</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces(c("sf", "patchwork"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  breaks = quantile(task$data()$dem, seq(0, 1, length = 6))
  zclass = cut(task$data()$dem, breaks, include.lowest = TRUE)

  resampling = rsmp("custom_cv")
  resampling$instantiate(task, f = zclass)

  autoplot(resampling, task) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
  autoplot(resampling, task, fold_id = 1)
  autoplot(resampling, task, fold_id = c(1, 2)) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}
</code></pre>

<hr>
<h2 id='autoplot.ResamplingCV'>Visualization Functions for Non-Spatial CV Methods.</h2><span id='topic+autoplot.ResamplingCV'></span><span id='topic+autoplot.ResamplingRepeatedCV'></span><span id='topic+plot.ResamplingCV'></span><span id='topic+plot.ResamplingRepeatedCV'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingCV'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedCV'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingCV'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedCV'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingCV_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="mlr3.html#topic+mlr_resamplings_cv">mlr3::ResamplingCV</a> or
<a href="mlr3.html#topic+mlr_resamplings_repeated_cv">mlr3::ResamplingRepeatedCV</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingCV_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="mlr3.html#topic+mlr_resamplings_cv">mlr3::ResamplingCV</a> or
<a href="mlr3.html#topic+mlr_resamplings_repeated_cv">mlr3::ResamplingRepeatedCV</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "patchwork", "ggtext", "ggsci"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("cv")
  resampling$instantiate(task)

  autoplot(resampling, task) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
  autoplot(resampling, task, fold_id = 1)
  autoplot(resampling, task, fold_id = c(1, 2)) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVBlock'>Visualization Functions for SpCV Block Methods.</h2><span id='topic+autoplot.ResamplingSpCVBlock'></span><span id='topic+autoplot.ResamplingRepeatedSpCVBlock'></span><span id='topic+plot.ResamplingSpCVBlock'></span><span id='topic+plot.ResamplingRepeatedSpCVBlock'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVBlock'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  show_blocks = FALSE,
  show_labels = FALSE,
  sample_fold_n = NULL,
  label_size = 2,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVBlock'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  show_blocks = FALSE,
  show_labels = FALSE,
  sample_fold_n = NULL,
  label_size = 2,
  ...
)

## S3 method for class 'ResamplingSpCVBlock'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVBlock'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a> or
<a href="#topic+ResamplingRepeatedSpCVBlock">ResamplingRepeatedSpCVBlock</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_show_blocks">show_blocks</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Whether to show an overlay of the spatial blocks polygons.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_show_labels">show_labels</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Whether to show an overlay of the spatial block IDs.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_label_size">label_size</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric(1)]&#8288;</code><br />
Label size of block labels. Only applies for <code>show_labels = TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBlock_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object. One of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>,
<a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a>, <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a>, <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default a plot is returned; if <code>fold_id</code> is set, a gridded plot is
created. If <code>plot_as_grid = FALSE</code>, a list of plot objects is returned.
This can be used to align the plots individually.
</p>
<p>When no single fold is selected, the <code><a href="ggsci.html#topic+scale_ucscgb">ggsci::scale_color_ucscgb()</a></code> palette
is used to display all partitions.
If you want to change the colors, call <code style="white-space: pre;">&#8288;&lt;plot&gt; + &lt;color-palette&gt;()&#8288;</code>.
</p>


<h3>Value</h3>

<p><code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> or list of ggplot2 objects.
</p>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_block", range = 1000L)
  resampling$instantiate(task)

  ## list of ggplot2 resamplings
  plot_list = autoplot(resampling, task,
    crs = 4326,
    fold_id = c(1, 2), plot_as_grid = FALSE)

  ## Visualize all partitions
  autoplot(resampling, task) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))

  ## Visualize the train/test split of a single fold
  autoplot(resampling, task, fold_id = 1) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))

  ## Visualize train/test splits of multiple folds
  autoplot(resampling, task,
    fold_id = c(1, 2),
    show_blocks = TRUE) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVBuffer'>Visualization Functions for SpCV Buffer Methods.</h2><span id='topic+autoplot.ResamplingSpCVBuffer'></span><span id='topic+plot.ResamplingSpCVBuffer'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVBuffer'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  show_omitted = FALSE,
  ...
)

## S3 method for class 'ResamplingSpCVBuffer'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_show_omitted">show_omitted</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to show points not used in train or test set for the current fold.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVBuffer_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_buffer", theRange = 1000)
  resampling$instantiate(task)

  ## single fold
  autoplot(resampling, task, fold_id = 1) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))

  ## multiple folds
  autoplot(resampling, task, fold_id = c(1, 2)) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVCoords'>Visualization Functions for SpCV Coords Methods.</h2><span id='topic+autoplot.ResamplingSpCVCoords'></span><span id='topic+autoplot.ResamplingRepeatedSpCVCoords'></span><span id='topic+plot.ResamplingSpCVCoords'></span><span id='topic+plot.ResamplingRepeatedSpCVCoords'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVCoords'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVCoords'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingSpCVCoords'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVCoords'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a> or
<a href="#topic+ResamplingRepeatedSpCVCoords">ResamplingRepeatedSpCVCoords</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVCoords_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a> or
<a href="#topic+ResamplingRepeatedSpCVCoords">ResamplingRepeatedSpCVCoords</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces(c("sf"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_coords")
  resampling$instantiate(task)

  autoplot(resampling, task) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
  autoplot(resampling, task, fold_id = 1)
  autoplot(resampling, task, fold_id = c(1, 2)) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}
</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVDisc'>Visualization Functions for SpCV Disc Method.</h2><span id='topic+autoplot.ResamplingSpCVDisc'></span><span id='topic+autoplot.ResamplingRepeatedSpCVDisc'></span><span id='topic+plot.ResamplingSpCVDisc'></span><span id='topic+plot.ResamplingRepeatedSpCVDisc'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVDisc'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  repeats_id = NULL,
  show_omitted = FALSE,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVDisc'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  show_omitted = FALSE,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingSpCVDisc'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVDisc'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a> or
<a href="#topic+ResamplingRepeatedSpCVBlock">ResamplingRepeatedSpCVBlock</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_show_omitted">show_omitted</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to show points not used in train or test set for the current fold.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVDisc_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object. One of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>,
<a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a>, <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a>, <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method requires to set argument <code>fold_id</code> and no plot containing all
partitions can be created. This is because the method does not make use of
all observations but only a subset of them (many observations are left out).
Hence, train and test sets of one fold are not re-used in other folds as in
other methods and plotting these without a train/test indicator would not
make sense.
</p>


<h3>2D vs 3D plotting</h3>

<p>This method has both a 2D and a 3D plotting method.
The 2D method returns a <span class="pkg">ggplot</span> with x and y axes representing the spatial
coordinates.
The 3D method uses <span class="pkg">plotly</span> to create an interactive 3D plot.
Set <code>plot3D = TRUE</code> to use the 3D method.
</p>
<p>Note that spatiotemporal datasets usually suffer from overplotting in 2D
mode.
</p>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li><p> Vignette <a href="https://mlr3spatiotempcv.mlr-org.com/articles/spatiotemp-viz.html">Spatiotemporal Visualization</a>.
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces("sf", quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_disc",
    folds = 5, radius = 200L, buffer = 200L)
  resampling$instantiate(task)

  autoplot(resampling, task,
    fold_id = 1,
    show_omitted = TRUE, size = 0.7) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVEnv'>Visualization Functions for SpCV Env Methods.</h2><span id='topic+autoplot.ResamplingSpCVEnv'></span><span id='topic+autoplot.ResamplingRepeatedSpCVEnv'></span><span id='topic+plot.ResamplingSpCVEnv'></span><span id='topic+plot.ResamplingRepeatedSpCVEnv'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVEnv'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVEnv'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingSpCVEnv'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVEnv'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a> or
<a href="#topic+ResamplingRepeatedSpCVEnv">ResamplingRepeatedSpCVEnv</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVEnv_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a> or
<a href="#topic+ResamplingRepeatedSpCVEnv">ResamplingRepeatedSpCVEnv</a>.</p>
</td></tr>
</table>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSptCVCstf">autoplot.ResamplingSptCVCstf()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_env", folds = 4, features = "dem")
  resampling$instantiate(task)

  autoplot(resampling, task) +
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
  autoplot(resampling, task, fold_id = 1)
  autoplot(resampling, task, fold_id = c(1, 2)) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVKnndm'>Visualization Functions for SpCV knndm Method.</h2><span id='topic+autoplot.ResamplingSpCVKnndm'></span><span id='topic+autoplot.ResamplingRepeatedSpCVKnndm'></span><span id='topic+plot.ResamplingSpCVKnndm'></span><span id='topic+plot.ResamplingRepeatedSpCVKnndm'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVKnndm'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  repeats_id = NULL,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVKnndm'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingSpCVKnndm'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVKnndm'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a> or
<a href="#topic+ResamplingRepeatedSpCVBlock">ResamplingRepeatedSpCVBlock</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVKnndm_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object. One of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>,
<a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a>, <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a>, <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method requires to set argument <code>fold_id</code> and no plot containing all
partitions can be created. This is because the method does not make use of
all observations but only a subset of them (many observations are left out).
Hence, train and test sets of one fold are not re-used in other folds as in
other methods and plotting these without a train/test indicator would not
make sense.
</p>


<h3>2D vs 3D plotting</h3>

<p>This method has both a 2D and a 3D plotting method.
The 2D method returns a <span class="pkg">ggplot</span> with x and y axes representing the spatial
coordinates.
The 3D method uses <span class="pkg">plotly</span> to create an interactive 3D plot.
Set <code>plot3D = TRUE</code> to use the 3D method.
</p>
<p>Note that spatiotemporal datasets usually suffer from overplotting in 2D
mode.
</p>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li><p> Vignette <a href="https://mlr3spatiotempcv.mlr-org.com/articles/spatiotemp-viz.html">Spatiotemporal Visualization</a>.
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVTiles">autoplot.ResamplingSpCVTiles()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("CAST", "sf"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  points = sf::st_as_sf(task$coordinates(), crs = task$crs, coords = c("x", "y"))
  modeldomain = sf::st_as_sfc(sf::st_bbox(points))

  resampling = rsmp("spcv_knndm",
    folds = 5, modeldomain = modeldomain)
  resampling$instantiate(task)

  autoplot(resampling, task,
    fold_id = 1, size = 0.7) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSpCVTiles'>Visualization Functions for SpCV Tiles Method.</h2><span id='topic+autoplot.ResamplingSpCVTiles'></span><span id='topic+autoplot.ResamplingRepeatedSpCVTiles'></span><span id='topic+plot.ResamplingSpCVTiles'></span><span id='topic+plot.ResamplingRepeatedSpCVTiles'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSpCVTiles'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  repeats_id = NULL,
  show_omitted = FALSE,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSpCVTiles'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  show_omitted = FALSE,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingSpCVTiles'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSpCVTiles'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a> or
<a href="#topic+ResamplingRepeatedSpCVBlock">ResamplingRepeatedSpCVBlock</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_show_omitted">show_omitted</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to show points not used in train or test set for the current fold.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_...">...</code></td>
<td>
<p>Passed to <code>geom_sf()</code>. Helpful for adjusting point sizes and
shapes.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSpCVTiles_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object. One of class <a href="#topic+ResamplingSpCVBuffer">ResamplingSpCVBuffer</a>,
<a href="#topic+ResamplingSpCVBlock">ResamplingSpCVBlock</a>, <a href="#topic+ResamplingSpCVCoords">ResamplingSpCVCoords</a>, <a href="#topic+ResamplingSpCVEnv">ResamplingSpCVEnv</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specific combinations of arguments of <code>"spcv_tiles"</code> remove some
observations, hence <code>show_omitted</code> has an effect in some cases.
</p>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#sec-spatiotemporal">&quot;Spatial Analysis&quot;</a>
</p>
</li>
<li><p> Vignette <a href="https://mlr3spatiotempcv.mlr-org.com/articles/spatiotemp-viz.html">Spatiotemporal Visualization</a>.
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVDisc">autoplot.ResamplingSpCVDisc()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "sperrorest"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task = tsk("ecuador")
  resampling = rsmp("spcv_tiles",
    nsplit = c(4L, 3L), reassign = FALSE)
  resampling$instantiate(task)

  autoplot(resampling, task,
    fold_id = 1,
    show_omitted = TRUE, size = 0.7) *
    ggplot2::scale_x_continuous(breaks = seq(-79.085, -79.055, 0.01))
}

</code></pre>

<hr>
<h2 id='autoplot.ResamplingSptCVCstf'>Visualization Functions for SptCV Cstf Methods.</h2><span id='topic+autoplot.ResamplingSptCVCstf'></span><span id='topic+autoplot.ResamplingRepeatedSptCVCstf'></span><span id='topic+plot.ResamplingSptCVCstf'></span><span id='topic+plot.ResamplingRepeatedSptCVCstf'></span>

<h3>Description</h3>

<p>Generic S3 <code>plot()</code> and <code>autoplot()</code> (ggplot2) methods to
visualize mlr3 spatiotemporal resampling objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ResamplingSptCVCstf'
autoplot(
  object,
  task,
  fold_id = NULL,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  repeats_id = NULL,
  tickformat_date = "%Y-%m",
  nticks_x = 3,
  nticks_y = 3,
  point_size = 3,
  axis_label_fontsize = 11,
  static_image = FALSE,
  show_omitted = FALSE,
  plot3D = NULL,
  plot_time_var = NULL,
  sample_fold_n = NULL,
  ...
)

## S3 method for class 'ResamplingRepeatedSptCVCstf'
autoplot(
  object,
  task,
  fold_id = NULL,
  repeats_id = 1,
  plot_as_grid = TRUE,
  train_color = "#0072B5",
  test_color = "#E18727",
  tickformat_date = "%Y-%m",
  nticks_x = 3,
  nticks_y = 3,
  point_size = 3,
  axis_label_fontsize = 11,
  plot3D = NULL,
  plot_time_var = NULL,
  ...
)

## S3 method for class 'ResamplingSptCVCstf'
plot(x, ...)

## S3 method for class 'ResamplingRepeatedSptCVCstf'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_object">object</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSptCVCstf">ResamplingSptCVCstf</a> or
<a href="#topic+ResamplingRepeatedSptCVCstf">ResamplingRepeatedSptCVCstf</a>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_task">task</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[TaskClassifST]/[TaskRegrST]&#8288;</code><br />
mlr3 task object.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_fold_id">fold_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Fold IDs to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_plot_as_grid">plot_as_grid</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical(1)]&#8288;</code><br />
Should a gridded plot using via <a href="https://CRAN.R-project.org/package=patchwork"><span class="pkg">patchwork</span></a> be created? If <code>FALSE</code>
a list with of <a href="https://CRAN.R-project.org/package=ggplot2"><span class="pkg">ggplot2</span></a> objects is returned.
Only applies if a numeric vector is passed to argument <code>fold_id</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_train_color">train_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the training set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_test_color">test_color</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character(1)]&#8288;</code><br />
The color to use for the test set observations.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_repeats_id">repeats_id</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Repetition ID to plot.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_tickformat_date">tickformat_date</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code><br />
Date format for z-axis.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_nticks_x">nticks_x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of x axis breaks.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_nticks_y">nticks_y</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of y axis breaks.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_point_size">point_size</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[numeric]&#8288;</code><br />
Point size of markers.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_axis_label_fontsize">axis_label_fontsize</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Font size of axis labels.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_static_image">static_image</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to create a static image from the plotly plot via <code>plotly::orca()</code>.
This requires the <code>orca</code> utility to be available.
See <a href="https://github.com/plotly/orca">https://github.com/plotly/orca</a> for
more information.
When used, by default a file named <code>plot.png</code> is created in the current
working directory.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_show_omitted">show_omitted</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to show points not used in train or test set for the current fold.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_plot3d">plot3D</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[logical]&#8288;</code><br />
Whether to create a 2D image via <span class="pkg">ggplot2</span> or a 3D plot via
<span class="pkg">plotly</span>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_plot_time_var">plot_time_var</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[character]&#8288;</code><br />
The variable to use for the z-axis (time).
Remove the column role <code>feature</code> for this variable to only use
it for plotting.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_sample_fold_n">sample_fold_n</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[integer]&#8288;</code><br />
Number of points in a random sample stratified over partitions.
This argument aims to keep file sizes of resulting plots reasonable and
reduce overplotting in dense datasets.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_...">...</code></td>
<td>
<p>Passed down to <code>plotly::orca()</code>. Only effective when
<code>static_image = TRUE</code>.</p>
</td></tr>
<tr><td><code id="autoplot.ResamplingSptCVCstf_+3A_x">x</code></td>
<td>
<p><code style="white-space: pre;">&#8288;[Resampling]&#8288;</code><br />
mlr3 spatial resampling object of class <a href="#topic+ResamplingSptCVCstf">ResamplingSptCVCstf</a> or
<a href="#topic+ResamplingRepeatedSptCVCstf">ResamplingRepeatedSptCVCstf</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method requires to set argument <code>fold_id</code>.
No plot showing all folds in one plot can be created.
This is because the LLTO method does not make use of all observations but only
a subset of them (many observations are omitted).
Hence, train and test sets of one fold are not re-used in other folds as in
other methods and plotting these without a train/test indicator would be
misleading.
</p>


<h3>2D vs 3D plotting</h3>

<p>This method has both a 2D and a 3D plotting method.
The 2D method returns a <span class="pkg">ggplot</span> with x and y axes representing the spatial
coordinates.
The 3D method uses <span class="pkg">plotly</span> to create an interactive 3D plot.
Set <code>plot3D = TRUE</code> to use the 3D method.
</p>
<p>Note that spatiotemporal datasets usually suffer from overplotting in 2D
mode.
</p>


<h3>See Also</h3>


<ul>
<li><p> mlr3book chapter on <a href="https://mlr3book.mlr-org.com/chapters/chapter13/beyond_regression_and_classification.html#spatiotemp-cv">&quot;Spatiotemporal Visualization&quot;</a>
</p>
</li>
<li><p> Vignette <a href="https://mlr3spatiotempcv.mlr-org.com/articles/spatiotemp-viz.html">Spatiotemporal Visualization</a>.
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBlock">autoplot.ResamplingSpCVBlock()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVBuffer">autoplot.ResamplingSpCVBuffer()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVCoords">autoplot.ResamplingSpCVCoords()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingSpCVEnv">autoplot.ResamplingSpCVEnv()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+autoplot.ResamplingCV">autoplot.ResamplingCV()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "plotly"), quietly = TRUE)) {
  library(mlr3)
  library(mlr3spatiotempcv)
  task_st = tsk("cookfarm_mlr3")
  task_st$set_col_roles("SOURCEID", "space")
  task_st$set_col_roles("Date", "time")
  resampling = rsmp("sptcv_cstf", folds = 5)
  resampling$instantiate(task_st)

  # with both `"space"` and `"time"` column roles set (LLTO), the omitted
  # observations per fold can be shown by setting `show_omitted = TRUE`
  autoplot(resampling, task_st, fold_id = 1, show_omitted = TRUE)
}

</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_block'>(blockCV) Repeated spatial block resampling</h2><span id='topic+mlr_resamplings_repeated_spcv_block'></span><span id='topic+ResamplingRepeatedSpCVBlock'></span>

<h3>Description</h3>

<p>This function creates spatially separated folds based on a distance to number of row and/or column.
It assigns blocks to the training and testing folds <strong>randomly</strong>, <strong>systematically</strong> or
in a <strong>checkerboard pattern</strong>. The distance (<code>size</code>)
should be in <strong>metres</strong>, regardless of the unit of the reference system of
the input data (for more information see the details section). By default,
the function creates blocks according to the extent and shape of the spatial sample data (<code>x</code> e.g.
the species occurrence), Alternatively, blocks can be created based on <code>r</code> assuming that the
user has considered the landscape for the given species and case study.
Blocks can also be offset so the origin is not at the outer corner of the rasters.
Instead of providing a distance, the blocks can also be created by specifying a number of rows and/or
columns and divide the study area into vertical or horizontal bins, as presented in Wenger &amp; Olden (2012)
and Bahn &amp; McGill (2012). Finally, the blocks can be specified by a user-defined spatial polygon layer.
</p>


<h3>Details</h3>

<p>To maintain consistency, all functions in this package use <strong>meters</strong> as their unit of
measurement. However, when the input map has a geographic coordinate system (in decimal degrees),
the block size is calculated by dividing the <code>size</code> parameter by <code>deg_to_metre</code> (which
defaults to 111325 meters, the standard distance of one degree of latitude on the Equator).
In reality, this value varies by a factor of the cosine of the latitude. So, an alternative sensible
value could be <code>cos(mean(sf::st_bbox(x)[c(2,4)]) * pi/180) * 111325</code>.
</p>
<p>The <code>offset</code> can be used to change the spatial position of the blocks. It can also be used to
assess the sensitivity of analysis results to shifting in the blocking arrangements.
These options are available when <code>size</code> is defined. By default the region is
located in the middle of the blocks and by setting the offsets, the blocks will shift.
</p>
<p>Roberts et. al. (2017) suggest that blocks should be substantially bigger than the range of spatial
autocorrelation (in model residual) to obtain realistic error estimates, while a buffer with the size of
the spatial autocorrelation range would result in a good estimation of error. This is because of the so-called
edge effect (O'Sullivan &amp; Unwin, 2014), whereby points located on the edges of the blocks of opposite sets are
not separated spatially. Blocking with a buffering strategy overcomes this issue (see <code><a href="blockCV.html#topic+cv_buffer">cv_buffer</a></code>).
</p>


<h3>mlr3spatiotempcv notes</h3>

<p>By default <code><a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial()</a></code> does not allow the creation of multiple
repetitions. <code>mlr3spatiotempcv</code> adds support for this when using the <code>size</code>
argument for fold creation. When supplying a vector of <code>length(repeats)</code> for
argument <code>size</code>, these different settings will be used to create folds which
differ among the repetitions.
</p>
<p>Multiple repetitions are not possible when using the &quot;row &amp; cols&quot; approach
because the created folds will always be the same.
</p>
<p>The 'Description' and 'Details' fields are inherited from the respective
upstream function.
</p>
<p>For a list of available arguments, please see <a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial</a>.
</p>
<p><code>blockCV</code> &gt;= 3.0.0 changed the argument names of the implementation. For backward compatibility, <code>mlr3spatiotempcv</code> is still using the old ones.
Here's a list which shows the mapping between <code>blockCV</code> &lt; 3.0.0 and <code>blockCV</code> &gt;= 3.0.0:
</p>

<ul>
<li> <p><code>range</code> -&gt; <code>size</code>
</p>
</li>
<li> <p><code>rasterLayer</code> -&gt; <code>r</code>
</p>
</li>
<li> <p><code>speciesData</code> -&gt; <code>points</code>
</p>
</li>
<li> <p><code>showBlocks</code> -&gt; <code>plot</code>
</p>
</li>
<li> <p><code>cols</code> and <code>rows</code> -&gt; <code>rows_cols</code>
</p>
</li></ul>

<p>The default of argument <code>hexagon</code> is different in <code>mlr3spatiotempcv</code> (<code>FALSE</code> instead of <code>TRUE</code>) to create square blocks instead of hexagonal blocks by default.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVBlock</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>blocks</code></dt><dd><p><code style="white-space: pre;">&#8288;sf | list of sf objects&#8288;</code><br />
Polygons (<code>sf</code> objects) as returned by <span class="pkg">blockCV</span> which grouped
observations into partitions.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVBlock-new"><code>ResamplingRepeatedSpCVBlock$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVBlock-folds"><code>ResamplingRepeatedSpCVBlock$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVBlock-repeats"><code>ResamplingRepeatedSpCVBlock$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVBlock-instantiate"><code>ResamplingRepeatedSpCVBlock$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVBlock-clone"><code>ResamplingRepeatedSpCVBlock$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVBlock-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;spatial block&quot; repeated resampling instance.
</p>
<p>For a list of available arguments, please see <a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVBlock$new(id = "repeated_spcv_block")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVBlock-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVBlock$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVBlock-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVBlock$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVBlock-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVBlock$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVBlock-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVBlock$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  task = tsk("diplodia")

  # Instantiate Resampling
  rrcv = rsmp("repeated_spcv_block",
    folds = 3, repeats = 2,
    range = c(5000L, 10000L))
  rrcv$instantiate(task)

  # Individual sets:
  rrcv$iters
  rrcv$folds(1:6)
  rrcv$repeats(1:6)

  # Individual sets:
  rrcv$train_set(1)
  rrcv$test_set(1)
  intersect(rrcv$train_set(1), rrcv$test_set(1))

  # Internal storage:
  rrcv$instance # table
}

## End(Not run)
</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_coords'>(sperrorest) Repeated coordinate-based k-means clustering</h2><span id='topic+mlr_resamplings_repeated_spcv_coords'></span><span id='topic+ResamplingRepeatedSpCVCoords'></span>

<h3>Description</h3>

<p>Splits data by clustering in the coordinate space.
See the upstream implementation at <code>sperrorest::partition_kmeans()</code> and
Brenning (2012) for further information.
</p>


<h3>Details</h3>

<p>Universal partitioning method that splits the data in the coordinate space.
Useful for spatially homogeneous datasets that cannot be split well with
rectangular approaches like <code>ResamplingSpCVBlock</code>.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li></ul>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVCoords</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVCoords-new"><code>ResamplingRepeatedSpCVCoords$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVCoords-folds"><code>ResamplingRepeatedSpCVCoords$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVCoords-repeats"><code>ResamplingRepeatedSpCVCoords$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVCoords-instantiate"><code>ResamplingRepeatedSpCVCoords$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVCoords-clone"><code>ResamplingRepeatedSpCVCoords$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVCoords-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;coordinate-based&quot; repeated resampling instance.
</p>
<p>For a list of available arguments, please see <a href="sperrorest.html#topic+partition_cv">sperrorest::partition_cv</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVCoords$new(id = "repeated_spcv_coords")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVCoords-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVCoords$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVCoords-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVCoords$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVCoords-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVCoords$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVCoords-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVCoords$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
task = tsk("diplodia")

# Instantiate Resampling
rrcv = rsmp("repeated_spcv_coords", folds = 3, repeats = 5)
rrcv$instantiate(task)

# Individual sets:
rrcv$iters
rrcv$folds(1:6)
rrcv$repeats(1:6)

# Individual sets:
rrcv$train_set(1)
rrcv$test_set(1)
intersect(rrcv$train_set(1), rrcv$test_set(1))

# Internal storage:
rrcv$instance # table
</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_disc'>(sperrorest) Repeated spatial &quot;disc&quot; resampling</h2><span id='topic+mlr_resamplings_repeated_spcv_disc'></span><span id='topic+ResamplingRepeatedSpCVDisc'></span>

<h3>Description</h3>

<p>(sperrorest) Repeated spatial &quot;disc&quot; resampling
</p>
<p>(sperrorest) Repeated spatial &quot;disc&quot; resampling
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVDisc</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVDisc-new"><code>ResamplingRepeatedSpCVDisc$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVDisc-folds"><code>ResamplingRepeatedSpCVDisc$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVDisc-repeats"><code>ResamplingRepeatedSpCVDisc$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVDisc-instantiate"><code>ResamplingRepeatedSpCVDisc$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVDisc-clone"><code>ResamplingRepeatedSpCVDisc$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVDisc-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spatial 'Disc' resampling&quot; resampling instance.
</p>
<p>For a list of available arguments, please see
<a href="sperrorest.html#topic+partition_disc">sperrorest::partition_disc</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVDisc$new(id = "repeated_spcv_disc")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVDisc-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVDisc$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVDisc-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVDisc$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVDisc-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVDisc$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVDisc-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVDisc$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
task = tsk("ecuador")

# Instantiate Resampling
rrcv = rsmp("repeated_spcv_disc",
  folds = 3L, repeats = 2,
  radius = 200L, buffer = 200L)
rrcv$instantiate(task)

# Individual sets:
rrcv$iters
rrcv$folds(1:6)
rrcv$repeats(1:6)

# Individual sets:
rrcv$train_set(1)
rrcv$test_set(1)
intersect(rrcv$train_set(1), rrcv$test_set(1))

# Internal storage:
rrcv$instance # table
</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_env'>(blockCV) Repeated &quot;environmental blocking&quot; resampling</h2><span id='topic+mlr_resamplings_repeated_spcv_env'></span><span id='topic+ResamplingRepeatedSpCVEnv'></span>

<h3>Description</h3>

<p>Splits data by clustering in the feature space.
See the upstream implementation at <code>blockCV::cv_cluster()</code> and
Valavi et al. (2018) for further information.
</p>


<h3>Details</h3>

<p>Useful when the dataset is supposed to be split on environmental information
which is present in features.
The method allows for a combination of multiple features for clustering.
</p>
<p>The input of raster images directly as in <code>blockCV::cv_cluster()</code> is not
supported. See <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> and its raster DataBackends for such
support in <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>features</code> (<code>character()</code>)<br />
The features to use for clustering.
</p>
</li></ul>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVEnv</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVEnv-new"><code>ResamplingRepeatedSpCVEnv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVEnv-folds"><code>ResamplingRepeatedSpCVEnv$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVEnv-repeats"><code>ResamplingRepeatedSpCVEnv$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVEnv-instantiate"><code>ResamplingRepeatedSpCVEnv$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVEnv-clone"><code>ResamplingRepeatedSpCVEnv$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVEnv-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;Environmental Block&quot; repeated resampling instance.
</p>
<p>For a list of available arguments, please see <a href="blockCV.html#topic+cv_cluster">blockCV::cv_cluster</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVEnv$new(id = "repeated_spcv_env")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVEnv-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVEnv$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVEnv-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVEnv$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVEnv-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVEnv$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVEnv-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVEnv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rrcv = rsmp("repeated_spcv_env", folds = 4, repeats = 2)
  rrcv$instantiate(task)

  # Individual sets:
  rrcv$train_set(1)
  rrcv$test_set(1)
  intersect(rrcv$train_set(1), rrcv$test_set(1))

  # Internal storage:
  rrcv$instance
}

</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_knndm'>(CAST) Repeated K-fold Nearest Neighbour Distance Matching</h2><span id='topic+mlr_resamplings_repeated_spcv_knndm'></span><span id='topic+ResamplingRepeatedSpCVKnndm'></span>

<h3>Description</h3>

<p>This function implements the kNNDM algorithm and returns the necessary
indices to perform a k-fold NNDM CV for map validation.
</p>


<h3>Details</h3>

<p>knndm is a k-fold version of NNDM LOO CV for medium and large datasets. Brielfy, the algorithm tries to
find a k-fold configuration such that the integral of the absolute differences (Wasserstein W statistic)
between the empirical nearest neighbour distance distribution function between the test and training data during CV (Gj*),
and the empirical nearest neighbour distance distribution function between the prediction and training points (Gij),
is minimised. It does so by performing clustering of the training points' coordinates for different numbers of
clusters that range from k to N (number of observations), merging them into k final folds,
and selecting the configuration with the lowest W.
</p>
<p>Using a projected CRS in 'knndm' has large computational advantages since fast nearest neighbour search can be
done via the 'FNN' package, while working with geographic coordinates requires computing the full
spherical distance matrices. As a clustering algorithm, 'kmeans' can only be used for
projected CRS while 'hierarchical' can work with both projected and geographical coordinates, though it requires
calculating the full distance matrix of the training points even for a projected CRS.
</p>
<p>In order to select between clustering algorithms and number of folds 'k', different 'knndm' configurations can be run
and compared, being the one with a lower W statistic the one that offers a better match. W statistics between 'knndm'
runs are comparable as long as 'tpoints' and 'predpoints' or 'modeldomain' stay the same.
</p>
<p>Map validation using 'knndm' should be used using 'CAST::global_validation', i.e. by stacking all out-of-sample
predictions and evaluating them all at once. The reasons behind this are 1) The resulting folds can be
unbalanced and 2) nearest neighbour functions are constructed and matched using all CV folds simultaneously.
</p>
<p>If training data points are very clustered with respect to the prediction area and the presented 'knndm'
configuration still show signs of Gj* &gt; Gij, there are several things that can be tried. First, increase
the 'maxp' parameter; this may help to control for strong clustering (at the cost of having unbalanced folds).
Secondly, decrease the number of final folds 'k', which may help to have larger clusters.
</p>
<p>The 'modeldomain' is either a sf polygon that defines the prediction area, or alternatively a SpatRaster out of which a polygon,
transformed into the CRS of the training points, is defined as the outline of all non-NA cells.
Then, the function takes a regular point sample (amount defined by 'samplesize') from the spatial extent.
As an alternative use 'predpoints' instead of 'modeldomain', if you have already defined the prediction locations (e.g. raster pixel centroids).
When using either 'modeldomain' or 'predpoints', we advise to plot the study area polygon and the training/prediction points as a previous step to ensure they are aligned.
</p>
<p>'knndm' can also be performed in the feature space by setting 'space' to &quot;feature&quot;.
Euclidean distances or Mahalanobis distances can be used for distance calculation, but only Euclidean are tested.
In this case, nearest neighbour distances are calculated in n-dimensional feature space rather than in geographical space.
'tpoints' and 'predpoints' can be data frames or sf objects containing the values of the features. Note that the names of 'tpoints' and 'predpoints' must be the same.
'predpoints' can also be missing, if 'modeldomain' is of class SpatRaster. In this case, the values of of the SpatRaster will be extracted to the 'predpoints'.
In the case of any categorical features, Gower distances will be used to calculate the Nearest Neighbour distances [Experimental]. If categorical
features are present, and 'clustering' = &quot;kmeans&quot;, K-Prototype clustering will be performed instead.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>stratify</code><br />
If <code>TRUE</code>, stratify on the target column.
</p>
</li></ul>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVKnndm</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-new"><code>ResamplingRepeatedSpCVKnndm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-folds"><code>ResamplingRepeatedSpCVKnndm$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-repeats"><code>ResamplingRepeatedSpCVKnndm$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-instantiate"><code>ResamplingRepeatedSpCVKnndm$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVKnndm-clone"><code>ResamplingRepeatedSpCVKnndm$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;K-fold Nearest Neighbour Distance Matching&quot; resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$new(id = "repeated_spcv_knndm")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVKnndm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVKnndm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Linnenbrink, J., Mila, C., Ludwig, M., Meyer, H. (2023).
&ldquo;kNNDM: k-fold Nearest Neighbour Distance Matching Cross-Validation for map accuracy estimation.&rdquo;
<em>EGUsphere</em>, <b>2023</b>, 1&ndash;16.
<a href="https://doi.org/10.5194/egusphere-2023-1308">doi:10.5194/egusphere-2023-1308</a>, <a href="https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/">https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
library(mlr3spatial)
set.seed(42)
simarea = list(matrix(c(0, 0, 0, 100, 100, 100, 100, 0, 0, 0), ncol = 2, byrow = TRUE))
simarea = sf::st_polygon(simarea)
train_points = sf::st_sample(simarea, 1000, type = "random")
train_points = sf::st_as_sf(train_points)
train_points$target = as.factor(sample(c("TRUE", "FALSE"), 1000, replace = TRUE))
pred_points = sf::st_sample(simarea, 1000, type = "regular")

task = mlr3spatial::as_task_classif_st(sf::st_as_sf(train_points), "target", positive = "TRUE")

cv_knndm = rsmp("repeated_spcv_knndm", predpoints = pred_points, repeats = 2)
cv_knndm$instantiate(task)
#' ### Individual sets:
# cv_knndm$train_set(1)
# cv_knndm$test_set(1)
# check that no obs are in both sets
intersect(cv_knndm$train_set(1), cv_knndm$test_set(1)) # good!

# Internal storage:
# cv_knndm$instance # table
</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_spcv_tiles'>(sperrorest) Repeated spatial &quot;tiles&quot; resampling</h2><span id='topic+mlr_resamplings_repeated_spcv_tiles'></span><span id='topic+ResamplingRepeatedSpCVTiles'></span>

<h3>Description</h3>

<p>Spatial partitioning using rectangular tiles.
Small partitions can optionally be merged into adjacent ones to avoid
partitions with too few observations.
This method is similar to <code>ResamplingSpCVBlock</code> by making use of
rectangular zones in the coordinate space.
See the upstream implementation at <code>sperrorest::partition_disc()</code> and
Brenning (2012) for further information.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>dsplit</code> (<code>integer(2)</code>)<br />
Equidistance of splits in (possibly rotated) x direction (<code>dsplit[1]</code>) and y direction (<code>dsplit[2]</code>) used to define tiles.
If dsplit is of length 1, its value is recycled.
Either <code>dsplit</code> or <code>nsplit</code> must be specified.
</p>
</li>
<li> <p><code>nsplit</code> (<code>integer(2)</code>)<br />
Number of splits in (possibly rotated) x direction (<code>nsplit[1]</code>) and y direction (<code>nsplit[2]</code>) used to define tiles.
If <code>nsplit</code> is of length 1, its value is recycled.
</p>
</li>
<li> <p><code>rotation</code> (<code>character(1)</code>)<br />
Whether and how the rectangular grid should be rotated; random rotation is only possible between -45 and +45 degrees.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_rotation</code> (<code>character(1)</code>)<br />
Only used when <code>rotation = "user"</code>.
Angle(s) (in degrees) by which the rectangular grid is to be rotated in
each repetition.
Either a vector of same length as <code>repeats</code>, or a single number that
will be replicated <code>length(repeats)</code> times.
</p>
</li>
<li> <p><code>offset</code> (<code>logical(1)</code>)<br />
Whether and how the rectangular grid should be shifted by an offset.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_offset</code> (<code>logical(1)</code>)<br />
Only used when <code>offset = "user"</code>.
A list (or vector) of two components specifying a shift of the rectangular
grid in (possibly rotated) x and y direction.
The offset values are relative values, a value of 0.5 resulting in a
one-half tile shift towards the left, or upward.
If this is a list, its first (second) component refers to the rotated
x (y) direction, and both components must have same length as <code>repeats</code>
(or length 1).
If a vector of length 2 (or list components have length 1), the two values
will be interpreted as relative shifts in (rotated) x and y direction,
respectively, and will therefore be recycled as needed (<code>length(repeats)</code>
times each).
</p>
</li>
<li> <p><code>reassign</code> (<code>logical(1)</code>)<br />
If <code>TRUE</code>, 'small' tiles (as per <code>min_frac</code> and <code>min_n</code>) are merged with
(smallest) adjacent tiles.
If <code>FALSE</code>, small tiles are 'eliminated', i.e., set to <code>NA.</code>
</p>
</li>
<li> <p><code>min_frac</code> (<code>numeric(1)</code>)<br />
Value must be &gt;=0, &lt;1.
Minimum relative size of partition as percentage of sample.
</p>
</li>
<li> <p><code>min_n</code> (<code>integer(1)</code>)<br />
Minimum number of samples per partition.
</p>
</li>
<li> <p><code>iterate</code> (<code>integer(1)</code>)<br />
Passed down to <code><a href="sperrorest.html#topic+tile_neighbors">sperrorest::tile_neighbors()</a></code>.
</p>
</li></ul>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSpCVTiles</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSpCVTiles-new"><code>ResamplingRepeatedSpCVTiles$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVTiles-folds"><code>ResamplingRepeatedSpCVTiles$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVTiles-repeats"><code>ResamplingRepeatedSpCVTiles$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVTiles-instantiate"><code>ResamplingRepeatedSpCVTiles$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSpCVTiles-clone"><code>ResamplingRepeatedSpCVTiles$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSpCVTiles-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spatial 'Tiles' resampling&quot; resampling instance.
</p>
<p>For a list of available arguments, please see
<a href="sperrorest.html#topic+partition_tiles">sperrorest::partition_tiles</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVTiles$new(id = "repeated_spcv_tiles")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVTiles-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVTiles$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVTiles-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVTiles$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVTiles-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVTiles$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSpCVTiles-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSpCVTiles$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>See Also</h3>

<p>ResamplingSpCVBlock
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces("sperrorest", quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rrcv = rsmp("repeated_spcv_tiles",
    repeats = 2,
    nsplit = c(4L, 3L), reassign = FALSE)
  rrcv$instantiate(task)

  # Individual sets:
  rrcv$iters
  rrcv$folds(10:12)
  rrcv$repeats(10:12)

  # Individual sets:
  rrcv$train_set(1)
  rrcv$test_set(1)
  intersect(rrcv$train_set(1), rrcv$test_set(1))

  # Internal storage:
  rrcv$instance # table
}
</code></pre>

<hr>
<h2 id='mlr_resamplings_repeated_sptcv_cstf'>(CAST) Repeated spatiotemporal &quot;leave-location-and-time-out&quot; resampling</h2><span id='topic+mlr_resamplings_repeated_sptcv_cstf'></span><span id='topic+ResamplingRepeatedSptCVCstf'></span>

<h3>Description</h3>

<p>Splits data using Leave-Location-Out (LLO), Leave-Time-Out (LTO) and
Leave-Location-and-Time-Out (LLTO) partitioning.
See the upstream implementation at <code>CreateSpacetimeFolds()</code>
(package <a href="https://CRAN.R-project.org/package=CAST"><span class="pkg">CAST</span></a>) and Meyer et al. (2018) for further information.
</p>


<h3>Details</h3>

<p>LLO predicts on unknown locations i.e. complete locations are left out in the
training sets.
The <code>"space"</code> role in <code>Task$col_roles</code> identifies spatial units.
If <code>stratify</code> is <code>TRUE</code>, the target distribution is similar in each fold.
This is useful for land cover classification when the observations
are polygons.
In this case, LLO with stratification should be used to hold back complete
polygons and have a similar target distribution in each fold.
LTO leaves out complete temporal units which are identified by the
<code>"time"</code> role in <code>Task$col_roles</code>.
LLTO leaves out spatial and temporal units.
See the examples.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>stratify</code><br />
If <code>TRUE</code>, stratify on the target column.
</p>
</li></ul>


<ul>
<li> <p><code>repeats</code> (<code>integer(1)</code>)<br />
Number of repeats.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingRepeatedSptCVCstf</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingRepeatedSptCVCstf-new"><code>ResamplingRepeatedSptCVCstf$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSptCVCstf-folds"><code>ResamplingRepeatedSptCVCstf$folds()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSptCVCstf-repeats"><code>ResamplingRepeatedSptCVCstf$repeats()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSptCVCstf-instantiate"><code>ResamplingRepeatedSptCVCstf$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingRepeatedSptCVCstf-clone"><code>ResamplingRepeatedSptCVCstf$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingRepeatedSptCVCstf-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spacetime Folds&quot; resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSptCVCstf$new(id = "repeated_sptcv_cstf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSptCVCstf-folds"></a>



<h4>Method <code>folds()</code></h4>

<p>Translates iteration numbers to fold number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSptCVCstf$folds(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSptCVCstf-repeats"></a>



<h4>Method <code>repeats()</code></h4>

<p>Translates iteration numbers to repetition number.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSptCVCstf$repeats(iters)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer()</code><br />
Iteration number.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSptCVCstf-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSptCVCstf$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingRepeatedSptCVCstf-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingRepeatedSptCVCstf$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Zhao Y, Karypis G (2002).
&ldquo;Evaluation of Hierarchical Clustering Algorithms for Document Datasets.&rdquo;
<em>11th Conference of Information and Knowledge Management (CIKM)</em>, 51-524.
<a href="https://doi.org/10.1145/584792.584877">doi:10.1145/584792.584877</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mlr3)
task = tsk("cookfarm_mlr3")
task$set_col_roles("SOURCEID", roles = "space")
task$set_col_roles("Date", roles = "time")

# Instantiate Resampling
rcv = rsmp("repeated_sptcv_cstf", folds = 5, repeats = 2)
rcv$instantiate(task)

### Individual sets:
# rcv$train_set(1)
# rcv$test_set(1)
# check that no obs are in both sets
intersect(rcv$train_set(1), rcv$test_set(1)) # good!

# Internal storage:
# rcv$instance # table

</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_block'>(blockCV) Spatial block resampling</h2><span id='topic+mlr_resamplings_spcv_block'></span><span id='topic+ResamplingSpCVBlock'></span>

<h3>Description</h3>

<p>This function creates spatially separated folds based on a distance to number of row and/or column.
It assigns blocks to the training and testing folds <strong>randomly</strong>, <strong>systematically</strong> or
in a <strong>checkerboard pattern</strong>. The distance (<code>size</code>)
should be in <strong>metres</strong>, regardless of the unit of the reference system of
the input data (for more information see the details section). By default,
the function creates blocks according to the extent and shape of the spatial sample data (<code>x</code> e.g.
the species occurrence), Alternatively, blocks can be created based on <code>r</code> assuming that the
user has considered the landscape for the given species and case study.
Blocks can also be offset so the origin is not at the outer corner of the rasters.
Instead of providing a distance, the blocks can also be created by specifying a number of rows and/or
columns and divide the study area into vertical or horizontal bins, as presented in Wenger &amp; Olden (2012)
and Bahn &amp; McGill (2012). Finally, the blocks can be specified by a user-defined spatial polygon layer.
</p>


<h3>Details</h3>

<p>To maintain consistency, all functions in this package use <strong>meters</strong> as their unit of
measurement. However, when the input map has a geographic coordinate system (in decimal degrees),
the block size is calculated by dividing the <code>size</code> parameter by <code>deg_to_metre</code> (which
defaults to 111325 meters, the standard distance of one degree of latitude on the Equator).
In reality, this value varies by a factor of the cosine of the latitude. So, an alternative sensible
value could be <code>cos(mean(sf::st_bbox(x)[c(2,4)]) * pi/180) * 111325</code>.
</p>
<p>The <code>offset</code> can be used to change the spatial position of the blocks. It can also be used to
assess the sensitivity of analysis results to shifting in the blocking arrangements.
These options are available when <code>size</code> is defined. By default the region is
located in the middle of the blocks and by setting the offsets, the blocks will shift.
</p>
<p>Roberts et. al. (2017) suggest that blocks should be substantially bigger than the range of spatial
autocorrelation (in model residual) to obtain realistic error estimates, while a buffer with the size of
the spatial autocorrelation range would result in a good estimation of error. This is because of the so-called
edge effect (O'Sullivan &amp; Unwin, 2014), whereby points located on the edges of the blocks of opposite sets are
not separated spatially. Blocking with a buffering strategy overcomes this issue (see <code><a href="blockCV.html#topic+cv_buffer">cv_buffer</a></code>).
</p>


<h3>mlr3spatiotempcv notes</h3>

<p>By default <code><a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial()</a></code> does not allow the creation of multiple
repetitions. <code>mlr3spatiotempcv</code> adds support for this when using the <code>size</code>
argument for fold creation. When supplying a vector of <code>length(repeats)</code> for
argument <code>size</code>, these different settings will be used to create folds which
differ among the repetitions.
</p>
<p>Multiple repetitions are not possible when using the &quot;row &amp; cols&quot; approach
because the created folds will always be the same.
</p>
<p>The 'Description' and 'Details' fields are inherited from the respective
upstream function.
</p>
<p>For a list of available arguments, please see <a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial</a>.
</p>
<p><code>blockCV</code> &gt;= 3.0.0 changed the argument names of the implementation. For backward compatibility, <code>mlr3spatiotempcv</code> is still using the old ones.
Here's a list which shows the mapping between <code>blockCV</code> &lt; 3.0.0 and <code>blockCV</code> &gt;= 3.0.0:
</p>

<ul>
<li> <p><code>range</code> -&gt; <code>size</code>
</p>
</li>
<li> <p><code>rasterLayer</code> -&gt; <code>r</code>
</p>
</li>
<li> <p><code>speciesData</code> -&gt; <code>points</code>
</p>
</li>
<li> <p><code>showBlocks</code> -&gt; <code>plot</code>
</p>
</li>
<li> <p><code>cols</code> and <code>rows</code> -&gt; <code>rows_cols</code>
</p>
</li></ul>

<p>The default of argument <code>hexagon</code> is different in <code>mlr3spatiotempcv</code> (<code>FALSE</code> instead of <code>TRUE</code>) to create square blocks instead of hexagonal blocks by default.
</p>


<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVBlock</code>
</p>


<h3>Public fields</h3>

<div class="r6-fields">

<dl>
<dt><code>blocks</code></dt><dd><p><code style="white-space: pre;">&#8288;sf | list of sf objects&#8288;</code><br />
Polygons (<code>sf</code> objects) as returned by <span class="pkg">blockCV</span> which grouped
observations into partitions.</p>
</dd>
</dl>

</div>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVBlock-new"><code>ResamplingSpCVBlock$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVBlock-instantiate"><code>ResamplingSpCVBlock$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVBlock-clone"><code>ResamplingSpCVBlock$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVBlock-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;spatial block&quot; resampling instance.
</p>
<p>For a list of available arguments, please see
<code><a href="blockCV.html#topic+cv_spatial">blockCV::cv_spatial()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBlock$new(id = "spcv_block")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVBlock-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBlock$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVBlock-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBlock$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rcv = rsmp("spcv_block", range = 3000L, folds = 3)
  rcv$instantiate(task)

  # Individual sets:
  rcv$train_set(1)
  rcv$test_set(1)
  intersect(rcv$train_set(1), rcv$test_set(1))

  # Internal storage:
  rcv$instance
}

</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_buffer'>(blockCV) Spatial buffering resampling</h2><span id='topic+mlr_resamplings_spcv_buffer'></span><span id='topic+ResamplingSpCVBuffer'></span>

<h3>Description</h3>

<p>This function generates spatially separated train and test folds by considering buffers of
the specified distance (<code>size</code> parameter) around each observation point.
This approach is a form of <em>leave-one-out</em> cross-validation. Each fold is generated by excluding
nearby observations around each testing point within the specified distance (ideally the range of
spatial autocorrelation, see <code><a href="blockCV.html#topic+cv_spatial_autocor">cv_spatial_autocor</a></code>). In this method, the testing set never
directly abuts a training sample (e.g. presence or absence; 0s and 1s). For more information see the details section.
</p>


<h3>Details</h3>

<p>When working with presence-background (presence and pseudo-absence) species distribution
data (should be specified by <code>presence_bg = TRUE</code> argument), only presence records are used
for specifying the folds (recommended). Consider a target presence point. The buffer is defined around this target point,
using the specified range (<code>size</code>). By default, the testing fold comprises only the target presence point (all background
points within the buffer are also added when <code>add_bg = TRUE</code>).
Any non-target presence points inside the buffer are excluded.
All points (presence and background) outside of buffer are used for the training set.
The methods cycles through all the <em>presence</em> data, so the number of folds is equal to
the number of presence points in the dataset.
</p>
<p>For presence-absence data (and all other types of data), folds are created based on all records, both
presences and absences. As above, a target observation (presence or absence) forms a test point, all
presence and absence points other than the target point within the buffer are ignored, and the training
set comprises all presences and absences outside the buffer. Apart from the folds, the number
of <em>training-presence</em>, <em>training-absence</em>, <em>testing-presence</em> and <em>testing-absence</em>
records is stored and returned in the <code>records</code> table. If <code>column = NULL</code> and <code>presence_bg = FALSE</code>,
the procedure is like presence-absence data. All other data types (continuous, count or multi-class responses) should be
done by <code>presence_bg = FALSE</code>.
</p>


<h3>mlr3spatiotempcv notes</h3>

<p>The 'Description' and 'Details' fields are inherited from the respective
upstream function.
For a list of available arguments, please see <a href="blockCV.html#topic+cv_buffer">blockCV::cv_buffer</a>.
</p>
<p><code>blockCV</code> &gt;= 3.0.0 changed the argument names of the implementation. For backward compatibility, <code>mlr3spatiotempcv</code> is still using the old ones.
Here's a list which shows the mapping between <code>blockCV</code> &lt; 3.0.0 and <code>blockCV</code> &gt;= 3.0.0:
</p>

<ul>
<li> <p><code>theRange</code> -&gt; <code>size</code>
</p>
</li>
<li> <p><code>addBG</code> -&gt; <code>add_bg</code>
</p>
</li>
<li> <p><code>spDataType</code> (character vector) -&gt; <code>presence_bg</code> (boolean)
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVBuffer</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVBuffer-new"><code>ResamplingSpCVBuffer$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVBuffer-instantiate"><code>ResamplingSpCVBuffer$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVBuffer-clone"><code>ResamplingSpCVBuffer$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVBuffer-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;Environmental Block&quot; resampling instance.
</p>
<p>For a list of available arguments, please see
<code><a href="blockCV.html#topic+cv_buffer">blockCV::cv_buffer()</a></code>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBuffer$new(id = "spcv_buffer")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVBuffer-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBuffer$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVBuffer-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVBuffer$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>


<h3>See Also</h3>

<p>ResamplingSpCVDisc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rcv = rsmp("spcv_buffer", theRange = 10000)
  rcv$instantiate(task)

  # Individual sets:
  rcv$train_set(1)
  rcv$test_set(1)
  intersect(rcv$train_set(1), rcv$test_set(1))

  # Internal storage:
  # rcv$instance
}

</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_coords'>(sperrorest) Coordinate-based k-means clustering</h2><span id='topic+mlr_resamplings_spcv_coords'></span><span id='topic+ResamplingSpCVCoords'></span>

<h3>Description</h3>

<p>Splits data by clustering in the coordinate space.
See the upstream implementation at <code>sperrorest::partition_kmeans()</code> and
Brenning (2012) for further information.
</p>


<h3>Details</h3>

<p>Universal partitioning method that splits the data in the coordinate space.
Useful for spatially homogeneous datasets that cannot be split well with
rectangular approaches like <code>ResamplingSpCVBlock</code>.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVCoords</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVCoords-new"><code>ResamplingSpCVCoords$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVCoords-instantiate"><code>ResamplingSpCVCoords$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVCoords-clone"><code>ResamplingSpCVCoords$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVCoords-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;coordinate-based&quot; repeated resampling instance.
</p>
<p>For a list of available arguments, please see <a href="sperrorest.html#topic+partition_cv">sperrorest::partition_cv</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVCoords$new(id = "spcv_coords")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVCoords-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVCoords$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVCoords-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVCoords$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
task = tsk("ecuador")

# Instantiate Resampling
rcv = rsmp("spcv_coords", folds = 5)
rcv$instantiate(task)

# Individual sets:
rcv$train_set(1)
rcv$test_set(1)
# check that no obs are in both sets
intersect(rcv$train_set(1), rcv$test_set(1)) # good!

# Internal storage:
rcv$instance # table
</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_disc'>(sperrorest) Spatial &quot;disc&quot; resampling</h2><span id='topic+mlr_resamplings_spcv_disc'></span><span id='topic+ResamplingSpCVDisc'></span>

<h3>Description</h3>

<p>Spatial partitioning using circular test areas of one of more observations.
Optionally, a buffer around the test area can be used to exclude observations.
See the upstream implementation at <code>sperrorest::partition_disc()</code> and
Brenning (2012) for further information.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>radius</code> (<code>numeric(1)</code>)<br />
Radius of test area disc.
</p>
</li>
<li> <p><code>buffer</code> (<code>integer(1)</code>)<br />
Radius around test area disc which is excluded from training or test set.
</p>
</li>
<li> <p><code>prob</code> (<code>integer(1)</code>)<br />
Optional argument passed down to <code>sample()</code>.
</p>
</li>
<li> <p><code>replace</code> (<code>logical(1)</code>)<br />
Optional argument passed down to <code>sample()</code>. Sample with or without
replacement.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVDisc</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVDisc-new"><code>ResamplingSpCVDisc$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVDisc-instantiate"><code>ResamplingSpCVDisc$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVDisc-clone"><code>ResamplingSpCVDisc$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVDisc-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spatial 'Disc' resampling&quot; resampling instance.
</p>
<p>For a list of available arguments, please see
<a href="sperrorest.html#topic+partition_disc">sperrorest::partition_disc</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVDisc$new(id = "spcv_disc")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVDisc-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVDisc$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVDisc-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVDisc$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(mlr3)
task = tsk("ecuador")

# Instantiate Resampling
rcv = rsmp("spcv_disc", folds = 3L, radius = 200L, buffer = 200L)
rcv$instantiate(task)

# Individual sets:
rcv$train_set(1)
rcv$test_set(1)
# check that no obs are in both sets
intersect(rcv$train_set(1), rcv$test_set(1)) # good!

# Internal storage:
rcv$instance # table
</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_env'>(blockCV) &quot;Environmental blocking&quot; resampling</h2><span id='topic+mlr_resamplings_spcv_env'></span><span id='topic+ResamplingSpCVEnv'></span>

<h3>Description</h3>

<p>Splits data by clustering in the feature space.
See the upstream implementation at <code>blockCV::cv_cluster()</code> and
Valavi et al. (2018) for further information.
</p>


<h3>Details</h3>

<p>Useful when the dataset is supposed to be split on environmental information
which is present in features.
The method allows for a combination of multiple features for clustering.
</p>
<p>The input of raster images directly as in <code>blockCV::cv_cluster()</code> is not
supported. See <a href="https://CRAN.R-project.org/package=mlr3spatial"><span class="pkg">mlr3spatial</span></a> and its raster DataBackends for such
support in <a href="https://CRAN.R-project.org/package=mlr3"><span class="pkg">mlr3</span></a>.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>features</code> (<code>character()</code>)<br />
The features to use for clustering.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVEnv</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVEnv-new"><code>ResamplingSpCVEnv$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVEnv-instantiate"><code>ResamplingSpCVEnv$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVEnv-clone"><code>ResamplingSpCVEnv$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVEnv-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create an &quot;Environmental Block&quot; resampling instance.
</p>
<p>For a list of available arguments, please see <a href="blockCV.html#topic+cv_cluster">blockCV::cv_cluster</a>.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVEnv$new(id = "spcv_env")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVEnv-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVEnv$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVEnv-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVEnv$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Valavi R, Elith J, Lahoz-Monfort JJ, Guillera-Arroita G (2018).
&ldquo;blockCV: an R package for generating spatially or environmentally separated folds for k-fold cross-validation of species distribution models.&rdquo;
<em>bioRxiv</em>.
<a href="https://doi.org/10.1101/357798">doi:10.1101/357798</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rcv = rsmp("spcv_env", folds = 4)
  rcv$instantiate(task)

  # Individual sets:
  rcv$train_set(1)
  rcv$test_set(1)
  intersect(rcv$train_set(1), rcv$test_set(1))

  # Internal storage:
  rcv$instance
}

</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_knndm'>(CAST) K-fold Nearest Neighbour Distance Matching</h2><span id='topic+mlr_resamplings_spcv_knndm'></span><span id='topic+ResamplingSpCVKnndm'></span>

<h3>Description</h3>

<p>This function implements the kNNDM algorithm and returns the necessary
indices to perform a k-fold NNDM CV for map validation.
</p>


<h3>Details</h3>

<p>knndm is a k-fold version of NNDM LOO CV for medium and large datasets. Brielfy, the algorithm tries to
find a k-fold configuration such that the integral of the absolute differences (Wasserstein W statistic)
between the empirical nearest neighbour distance distribution function between the test and training data during CV (Gj*),
and the empirical nearest neighbour distance distribution function between the prediction and training points (Gij),
is minimised. It does so by performing clustering of the training points' coordinates for different numbers of
clusters that range from k to N (number of observations), merging them into k final folds,
and selecting the configuration with the lowest W.
</p>
<p>Using a projected CRS in 'knndm' has large computational advantages since fast nearest neighbour search can be
done via the 'FNN' package, while working with geographic coordinates requires computing the full
spherical distance matrices. As a clustering algorithm, 'kmeans' can only be used for
projected CRS while 'hierarchical' can work with both projected and geographical coordinates, though it requires
calculating the full distance matrix of the training points even for a projected CRS.
</p>
<p>In order to select between clustering algorithms and number of folds 'k', different 'knndm' configurations can be run
and compared, being the one with a lower W statistic the one that offers a better match. W statistics between 'knndm'
runs are comparable as long as 'tpoints' and 'predpoints' or 'modeldomain' stay the same.
</p>
<p>Map validation using 'knndm' should be used using 'CAST::global_validation', i.e. by stacking all out-of-sample
predictions and evaluating them all at once. The reasons behind this are 1) The resulting folds can be
unbalanced and 2) nearest neighbour functions are constructed and matched using all CV folds simultaneously.
</p>
<p>If training data points are very clustered with respect to the prediction area and the presented 'knndm'
configuration still show signs of Gj* &gt; Gij, there are several things that can be tried. First, increase
the 'maxp' parameter; this may help to control for strong clustering (at the cost of having unbalanced folds).
Secondly, decrease the number of final folds 'k', which may help to have larger clusters.
</p>
<p>The 'modeldomain' is either a sf polygon that defines the prediction area, or alternatively a SpatRaster out of which a polygon,
transformed into the CRS of the training points, is defined as the outline of all non-NA cells.
Then, the function takes a regular point sample (amount defined by 'samplesize') from the spatial extent.
As an alternative use 'predpoints' instead of 'modeldomain', if you have already defined the prediction locations (e.g. raster pixel centroids).
When using either 'modeldomain' or 'predpoints', we advise to plot the study area polygon and the training/prediction points as a previous step to ensure they are aligned.
</p>
<p>'knndm' can also be performed in the feature space by setting 'space' to &quot;feature&quot;.
Euclidean distances or Mahalanobis distances can be used for distance calculation, but only Euclidean are tested.
In this case, nearest neighbour distances are calculated in n-dimensional feature space rather than in geographical space.
'tpoints' and 'predpoints' can be data frames or sf objects containing the values of the features. Note that the names of 'tpoints' and 'predpoints' must be the same.
'predpoints' can also be missing, if 'modeldomain' is of class SpatRaster. In this case, the values of of the SpatRaster will be extracted to the 'predpoints'.
In the case of any categorical features, Gower distances will be used to calculate the Nearest Neighbour distances [Experimental]. If categorical
features are present, and 'clustering' = &quot;kmeans&quot;, K-Prototype clustering will be performed instead.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>stratify</code><br />
If <code>TRUE</code>, stratify on the target column.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVKnndm</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVKnndm-new"><code>ResamplingSpCVKnndm$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVKnndm-instantiate"><code>ResamplingSpCVKnndm$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVKnndm-clone"><code>ResamplingSpCVKnndm$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVKnndm-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;K-fold Nearest Neighbour Distance Matching&quot; resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVKnndm$new(id = "spcv_knndm")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVKnndm-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVKnndm$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVKnndm-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVKnndm$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Linnenbrink, J., Mila, C., Ludwig, M., Meyer, H. (2023).
&ldquo;kNNDM: k-fold Nearest Neighbour Distance Matching Cross-Validation for map accuracy estimation.&rdquo;
<em>EGUsphere</em>, <b>2023</b>, 1&ndash;16.
<a href="https://doi.org/10.5194/egusphere-2023-1308">doi:10.5194/egusphere-2023-1308</a>, <a href="https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/">https://egusphere.copernicus.org/preprints/2023/egusphere-2023-1308/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces(c("sf", "CAST"), quietly = TRUE)) {
  library(mlr3)
  library(sf)

  set.seed(42)
  task = tsk("ecuador")
  points = sf::st_as_sf(task$coordinates(), crs = task$crs, coords = c("x", "y"))
  modeldomain = sf::st_as_sfc(sf::st_bbox(points))

  set.seed(42)
  cv_knndm = rsmp("spcv_knndm", modeldomain = modeldomain)
  cv_knndm$instantiate(task)

  #' ### Individual sets:
  # cv_knndm$train_set(1)
  # cv_knndm$test_set(1)
  # check that no obs are in both sets
  intersect(cv_knndm$train_set(1), cv_knndm$test_set(1)) # good!

  # Internal storage:
  # cv_knndm$instance # table
}
</code></pre>

<hr>
<h2 id='mlr_resamplings_spcv_tiles'>(sperrorest) Spatial &quot;Tiles&quot; resampling</h2><span id='topic+mlr_resamplings_spcv_tiles'></span><span id='topic+ResamplingSpCVTiles'></span>

<h3>Description</h3>

<p>Spatial partitioning using rectangular tiles.
Small partitions can optionally be merged into adjacent ones to avoid
partitions with too few observations.
This method is similar to <code>ResamplingSpCVBlock</code> by making use of
rectangular zones in the coordinate space.
See the upstream implementation at <code>sperrorest::partition_disc()</code> and
Brenning (2012) for further information.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>dsplit</code> (<code>integer(2)</code>)<br />
Equidistance of splits in (possibly rotated) x direction (<code>dsplit[1]</code>) and y direction (<code>dsplit[2]</code>) used to define tiles.
If dsplit is of length 1, its value is recycled.
Either <code>dsplit</code> or <code>nsplit</code> must be specified.
</p>
</li>
<li> <p><code>nsplit</code> (<code>integer(2)</code>)<br />
Number of splits in (possibly rotated) x direction (<code>nsplit[1]</code>) and y direction (<code>nsplit[2]</code>) used to define tiles.
If <code>nsplit</code> is of length 1, its value is recycled.
</p>
</li>
<li> <p><code>rotation</code> (<code>character(1)</code>)<br />
Whether and how the rectangular grid should be rotated; random rotation is only possible between -45 and +45 degrees.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_rotation</code> (<code>character(1)</code>)<br />
Only used when <code>rotation = "user"</code>.
Angle(s) (in degrees) by which the rectangular grid is to be rotated in
each repetition.
Either a vector of same length as <code>repeats</code>, or a single number that
will be replicated <code>length(repeats)</code> times.
</p>
</li>
<li> <p><code>offset</code> (<code>logical(1)</code>)<br />
Whether and how the rectangular grid should be shifted by an offset.
Accepted values: One of <code>c("none", "random", "user")</code>.
</p>
</li>
<li> <p><code>user_offset</code> (<code>logical(1)</code>)<br />
Only used when <code>offset = "user"</code>.
A list (or vector) of two components specifying a shift of the rectangular
grid in (possibly rotated) x and y direction.
The offset values are relative values, a value of 0.5 resulting in a
one-half tile shift towards the left, or upward.
If this is a list, its first (second) component refers to the rotated
x (y) direction, and both components must have same length as <code>repeats</code>
(or length 1).
If a vector of length 2 (or list components have length 1), the two values
will be interpreted as relative shifts in (rotated) x and y direction,
respectively, and will therefore be recycled as needed (<code>length(repeats)</code>
times each).
</p>
</li>
<li> <p><code>reassign</code> (<code>logical(1)</code>)<br />
If <code>TRUE</code>, 'small' tiles (as per <code>min_frac</code> and <code>min_n</code>) are merged with
(smallest) adjacent tiles.
If <code>FALSE</code>, small tiles are 'eliminated', i.e., set to <code>NA.</code>
</p>
</li>
<li> <p><code>min_frac</code> (<code>numeric(1)</code>)<br />
Value must be &gt;=0, &lt;1.
Minimum relative size of partition as percentage of sample.
</p>
</li>
<li> <p><code>min_n</code> (<code>integer(1)</code>)<br />
Minimum number of samples per partition.
</p>
</li>
<li> <p><code>iterate</code> (<code>integer(1)</code>)<br />
Passed down to <code><a href="sperrorest.html#topic+tile_neighbors">sperrorest::tile_neighbors()</a></code>.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSpCVTiles</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSpCVTiles-new"><code>ResamplingSpCVTiles$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVTiles-instantiate"><code>ResamplingSpCVTiles$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSpCVTiles-clone"><code>ResamplingSpCVTiles$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSpCVTiles-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spatial 'Tiles' resampling&quot; resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$new(id = "spcv_tiles")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.
For a list of available arguments, please see
<a href="sperrorest.html#topic+partition_tiles">sperrorest::partition_tiles</a>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVTiles-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSpCVTiles-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSpCVTiles$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Brenning A (2012).
&ldquo;Spatial cross-validation and bootstrap for the assessment of prediction rules in remote sensing: The R package sperrorest.&rdquo;
In <em>2012 IEEE International Geoscience and Remote Sensing Symposium</em>.
<a href="https://doi.org/10.1109/igarss.2012.6352393">doi:10.1109/igarss.2012.6352393</a>.
</p>


<h3>See Also</h3>

<p>ResamplingSpCVBlock
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (mlr3misc::require_namespaces("sperrorest", quietly = TRUE)) {
  library(mlr3)
  task = tsk("ecuador")

  # Instantiate Resampling
  rcv = rsmp("spcv_tiles", nsplit = c(4L, 3L), reassign = FALSE)
  rcv$instantiate(task)

  # Individual sets:
  rcv$train_set(1)
  rcv$test_set(1)
  # check that no obs are in both sets
  intersect(rcv$train_set(1), rcv$test_set(1)) # good!

  # Internal storage:
  rcv$instance # table
}
</code></pre>

<hr>
<h2 id='mlr_resamplings_sptcv_cstf'>(CAST) Spatiotemporal &quot;Leave-location-and-time-out&quot; resampling</h2><span id='topic+mlr_resamplings_sptcv_cstf'></span><span id='topic+ResamplingSptCVCstf'></span>

<h3>Description</h3>

<p>Splits data using Leave-Location-Out (LLO), Leave-Time-Out (LTO) and
Leave-Location-and-Time-Out (LLTO) partitioning.
See the upstream implementation at <code>CreateSpacetimeFolds()</code>
(package <a href="https://CRAN.R-project.org/package=CAST"><span class="pkg">CAST</span></a>) and Meyer et al. (2018) for further information.
</p>


<h3>Details</h3>

<p>LLO predicts on unknown locations i.e. complete locations are left out in the
training sets.
The <code>"space"</code> role in <code>Task$col_roles</code> identifies spatial units.
If <code>stratify</code> is <code>TRUE</code>, the target distribution is similar in each fold.
This is useful for land cover classification when the observations
are polygons.
In this case, LLO with stratification should be used to hold back complete
polygons and have a similar target distribution in each fold.
LTO leaves out complete temporal units which are identified by the
<code>"time"</code> role in <code>Task$col_roles</code>.
LLTO leaves out spatial and temporal units.
See the examples.
</p>


<h3>Parameters</h3>


<ul>
<li> <p><code>folds</code> (<code>integer(1)</code>)<br />
Number of folds.
</p>
</li>
<li> <p><code>stratify</code><br />
If <code>TRUE</code>, stratify on the target column.
</p>
</li></ul>



<h3>Super class</h3>

<p><code><a href="mlr3.html#topic+Resampling">mlr3::Resampling</a></code> -&gt; <code>ResamplingSptCVCstf</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>iters</code></dt><dd><p><code>integer(1)</code><br />
Returns the number of resampling iterations, depending on the
values stored in the <code>param_set</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-ResamplingSptCVCstf-new"><code>ResamplingSptCVCstf$new()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSptCVCstf-instantiate"><code>ResamplingSptCVCstf$instantiate()</code></a>
</p>
</li>
<li> <p><a href="#method-ResamplingSptCVCstf-clone"><code>ResamplingSptCVCstf$clone()</code></a>
</p>
</li></ul>



<details open><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="format"><a href='../../mlr3/html/Resampling.html#method-Resampling-format'><code>mlr3::Resampling$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="help"><a href='../../mlr3/html/Resampling.html#method-Resampling-help'><code>mlr3::Resampling$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="print"><a href='../../mlr3/html/Resampling.html#method-Resampling-print'><code>mlr3::Resampling$print()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="test_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-test_set'><code>mlr3::Resampling$test_set()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Resampling" data-id="train_set"><a href='../../mlr3/html/Resampling.html#method-Resampling-train_set'><code>mlr3::Resampling$train_set()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-ResamplingSptCVCstf-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a &quot;Spacetime Folds&quot; resampling instance.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSptCVCstf$new(id = "sptcv_cstf")</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p><code>character(1)</code><br />
Identifier for the resampling strategy.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSptCVCstf-instantiate"></a>



<h4>Method <code>instantiate()</code></h4>

<p>Materializes fixed training and test splits for a given task.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSptCVCstf$instantiate(task)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>task</code></dt><dd><p><a href="mlr3.html#topic+Task">mlr3::Task</a><br />
A task to instantiate.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-ResamplingSptCVCstf-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>ResamplingSptCVCstf$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>References</h3>

<p>Meyer H, Reudenbach C, Hengl T, Katurji M, Nauss T (2018).
&ldquo;Improving performance of spatio-temporal machine learning models using forward feature selection and target-oriented validation.&rdquo;
<em>Environmental Modelling &amp; Software</em>, <b>101</b>, 1&ndash;9.
<a href="https://doi.org/10.1016/j.envsoft.2017.12.001">doi:10.1016/j.envsoft.2017.12.001</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(mlr3)
task = tsk("cookfarm_mlr3")
task$set_col_roles("SOURCEID", roles = "space")
task$set_col_roles("Date", roles = "time")

# Instantiate Resampling
rcv = rsmp("sptcv_cstf", folds = 5)
rcv$instantiate(task)

### Individual sets:
# rcv$train_set(1)
# rcv$test_set(1)
# check that no obs are in both sets
intersect(rcv$train_set(1), rcv$test_set(1)) # good!

# Internal storage:
# rcv$instance # table

</code></pre>

<hr>
<h2 id='mlr_tasks_cookfarm_mlr3'>Cookfarm Profiles Regression Task</h2><span id='topic+mlr_tasks_cookfarm_mlr3'></span><span id='topic+cookfarm_mlr3'></span>

<h3>Description</h3>

<p>The R.J. Cook Agronomy Farm (cookfarm) is a Long-Term Agroecosystem Research
Site operated by Washington State University, located near Pullman,
Washington, USA. Contains spatio-temporal (3D+T) measurements of three soil
properties and a number of spatial and temporal regression covariates.
</p>
<p>Here, only the &quot;Profiles&quot; dataset is used from the collection.
The <code>Date</code> column was appended from the <code>readings</code> dataset.
In addition coordinates were appended to the task as variables <code>"x"</code> and <code>"y"</code>.
</p>
<p>The dataset was borrowed and adapted from package GSIF which was on archived on
CRAN in 2021-03.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cookfarm_mlr3)
</code></pre>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> inheriting from <a href="mlr3.html#topic+TaskRegr">mlr3::TaskRegr</a>.
</p>


<h3>Usage</h3>

<div class="sourceCode"><pre>mlr_tasks$get("cookfarm")
tsk("cookfarm_mlr3")
</pre></div>


<h3>Column roles</h3>

<p>The task has set column roles &quot;space&quot; and &quot;time&quot; for variables <code>"Date"</code> and
<code>"SOURCEID"</code>, respectively.
These are used by certain methods during partitioning, e.g.,
<code>mlr_resamplings_sptcv_cstf</code> with variant &quot;Leave-location-and-time-out&quot;.
If only one of space or time should left out, the column roles must be
adjusted by the user!
</p>


<h3>References</h3>

<p>Gasch, C.K., Hengl, T., Gräler, B., Meyer, H., Magney, T., Brown, D.J., 2015.
Spatio-temporal interpolation of soil water, temperature, and electrical
conductivity in 3D+T: the Cook Agronomy Farm data set. Spatial Statistics,
14, pp.70–90.
</p>
<p>Gasch, C.K., D.J. Brown, E.S. Brooks, M. Yourek, M. Poggio, D.R. Cobos, C.S.
Campbell, 2016? Retroactive calibration of soil moisture sensors using a
two-step, soil-specific correction. Submitted to Vadose Zone Journal.
</p>
<p>Gasch, C.K., D.J. Brown, C.S. Campbell, D.R. Cobos, E.S. Brooks, M. Chahal,
M. Poggio, 2016? A field-scale sensor network data set for monitoring and
modeling the spatial and temporal variation of soil moisture in a dryland
agricultural field. Submitted to Water Resources Research.
</p>


<h3>See Also</h3>

<p><a href="mlr3misc.html#topic+Dictionary">Dictionary</a> of <a href="mlr3.html#topic+Task">Tasks</a>: <a href="mlr3.html#topic+mlr_tasks">mlr3::mlr_tasks</a>
</p>
<p><code>as.data.table(mlr_tasks)</code> for a complete table of all (also dynamically created) <a href="mlr3.html#topic+Task">Tasks</a>.
</p>
<p>Other Task: 
<code><a href="#topic+TaskClassifST">TaskClassifST</a></code>,
<code><a href="#topic+TaskRegrST">TaskRegrST</a></code>,
<code><a href="#topic+mlr_tasks_diplodia">mlr_tasks_diplodia</a></code>,
<code><a href="#topic+mlr_tasks_ecuador">mlr_tasks_ecuador</a></code>
</p>

<hr>
<h2 id='mlr_tasks_diplodia'>Diplodia Classification Task</h2><span id='topic+mlr_tasks_diplodia'></span><span id='topic+diplodia'></span>

<h3>Description</h3>

<p>Data set created by Patrick Schratz, University of Jena
(Germany) and Eugenia Iturritxa, NEIKER, Vitoria-Gasteiz (Spain). This
dataset should be cited as Schratz et al. (2019) (see reference below). The
publication also contains additional information on data collection. The
data set provided here shows infections of trees by the pathogen <em>Diplodia
Sapinea</em> in the Basque Country in Spain. Predictors are environmental
variables like temperature, precipitation, soil and more.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(diplodia)
</code></pre>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> inheriting from <a href="mlr3.html#topic+TaskClassif">mlr3::TaskClassif</a>.
</p>


<h3>Usage</h3>

<div class="sourceCode"><pre>mlr_tasks$get("diplodia")
tsk("diplodia")
</pre></div>


<h3>References</h3>

<p>Schratz P, Muenchow J, Iturritxa E, Richter J, Brenning A (2019).
&ldquo;Hyperparameter tuning and performance assessment of statistical and machine-learning algorithms using spatial data.&rdquo;
<em>Ecological Modelling</em>, <b>406</b>, 109&ndash;120.
<a href="https://doi.org/10.1016/j.ecolmodel.2019.06.002">doi:10.1016/j.ecolmodel.2019.06.002</a>.
</p>


<h3>See Also</h3>

<p><a href="mlr3misc.html#topic+Dictionary">Dictionary</a> of <a href="mlr3.html#topic+Task">Tasks</a>: <a href="mlr3.html#topic+mlr_tasks">mlr3::mlr_tasks</a>
</p>
<p><code>as.data.table(mlr_tasks)</code> for a complete table of all (also dynamically created) <a href="mlr3.html#topic+Task">Tasks</a>.
</p>
<p>Other Task: 
<code><a href="#topic+TaskClassifST">TaskClassifST</a></code>,
<code><a href="#topic+TaskRegrST">TaskRegrST</a></code>,
<code><a href="#topic+mlr_tasks_cookfarm_mlr3">mlr_tasks_cookfarm_mlr3</a></code>,
<code><a href="#topic+mlr_tasks_ecuador">mlr_tasks_ecuador</a></code>
</p>

<hr>
<h2 id='mlr_tasks_ecuador'>Ecuador Classification Task</h2><span id='topic+mlr_tasks_ecuador'></span><span id='topic+ecuador'></span>

<h3>Description</h3>

<p>Data set created by Jannes Muenchow, University of Erlangen-Nuernberg,
Germany. This dataset should be cited as Muenchow et al. (2012) (see reference
below). The publication also contains additional information on data
collection and the geomorphology of the area. The data set provided here is (a
subset of) the one from the 'natural' part of the RBSF area and corresponds
to landslide distribution in the year 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ecuador)
</code></pre>


<h3>Format</h3>

<p><a href="R6.html#topic+R6Class">R6::R6Class</a> inheriting from <a href="mlr3.html#topic+TaskClassif">mlr3::TaskClassif</a>.
</p>


<h3>Usage</h3>

<div class="sourceCode"><pre>mlr_tasks$get("ecuador")
tsk("ecuador")
</pre></div>


<h3>References</h3>

<p>Muenchow, J., Brenning, A., Richter, M., 2012. Geomorphic process
rates of landslides along a humidity gradient in the tropical Andes.
Geomorphology, 139-140: 271-284.
</p>


<h3>See Also</h3>

<p><a href="mlr3misc.html#topic+Dictionary">Dictionary</a> of <a href="mlr3.html#topic+Task">Tasks</a>: <a href="mlr3.html#topic+mlr_tasks">mlr3::mlr_tasks</a>
</p>
<p><code>as.data.table(mlr_tasks)</code> for a complete table of all (also dynamically created) <a href="mlr3.html#topic+Task">Tasks</a>.
</p>
<p>Other Task: 
<code><a href="#topic+TaskClassifST">TaskClassifST</a></code>,
<code><a href="#topic+TaskRegrST">TaskRegrST</a></code>,
<code><a href="#topic+mlr_tasks_cookfarm_mlr3">mlr_tasks_cookfarm_mlr3</a></code>,
<code><a href="#topic+mlr_tasks_diplodia">mlr_tasks_diplodia</a></code>
</p>

<hr>
<h2 id='strat_sample_folds'>Stratified random sampling</h2><span id='topic+strat_sample_folds'></span>

<h3>Description</h3>

<p>Stratified random sampling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strat_sample_folds(data, col, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strat_sample_folds_+3A_data">data</code></td>
<td>
<p>(<code>data.table</code>)<br />
Data</p>
</td></tr>
<tr><td><code id="strat_sample_folds_+3A_col">col</code></td>
<td>
<p>(<code>character(1)</code>)<br />
Column to stratify on.</p>
</td></tr>
<tr><td><code id="strat_sample_folds_+3A_n">n</code></td>
<td>
<p>(<code>integer</code>)<br />
Sample size per group</p>
</td></tr>
</table>

<hr>
<h2 id='TaskClassifST'>Create a Spatiotemporal Classification Task</h2><span id='topic+TaskClassifST'></span>

<h3>Description</h3>

<p>This task specializes <a href="mlr3.html#topic+Task">mlr3::Task</a> and <a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a> for
spatiotemporal classification problems. The target column is assumed to be a
factor. The <code>task_type</code> is set to <code>"classif"</code> and <code>"spatiotemporal"</code>.
</p>
<p>A spatial example task is available via <code>tsk("ecuador")</code>, a spatiotemporal
one via <code>tsk("cookfarm_mlr3")</code>.
</p>
<p>The coordinate reference system passed during initialization must match the
one which was used during data creation, otherwise offsets of multiple meters
may occur. By default, coordinates are not used as features. This can be
changed by setting <code>coords_as_features = TRUE</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3.html#topic+Task">mlr3::Task</a></code> -&gt; <code><a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a></code> -&gt; <code><a href="mlr3.html#topic+TaskClassif">mlr3::TaskClassif</a></code> -&gt; <code>TaskClassifST</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Returns coordinate reference system of task.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character()</code>)<br />
Coordinate names.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TaskClassifST-new"><code>TaskClassifST$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-coordinates"><code>TaskClassifST$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-print"><code>TaskClassifST$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskClassifST-clone"><code>TaskClassifST$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="add_strata"><a href='../../mlr3/html/Task.html#method-Task-add_strata'><code>mlr3::Task$add_strata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="cbind"><a href='../../mlr3/html/Task.html#method-Task-cbind'><code>mlr3::Task$cbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="data"><a href='../../mlr3/html/Task.html#method-Task-data'><code>mlr3::Task$data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="divide"><a href='../../mlr3/html/Task.html#method-Task-divide'><code>mlr3::Task$divide()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="filter"><a href='../../mlr3/html/Task.html#method-Task-filter'><code>mlr3::Task$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="format"><a href='../../mlr3/html/Task.html#method-Task-format'><code>mlr3::Task$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="formula"><a href='../../mlr3/html/Task.html#method-Task-formula'><code>mlr3::Task$formula()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="head"><a href='../../mlr3/html/Task.html#method-Task-head'><code>mlr3::Task$head()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="help"><a href='../../mlr3/html/Task.html#method-Task-help'><code>mlr3::Task$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="levels"><a href='../../mlr3/html/Task.html#method-Task-levels'><code>mlr3::Task$levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="missings"><a href='../../mlr3/html/Task.html#method-Task-missings'><code>mlr3::Task$missings()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rbind"><a href='../../mlr3/html/Task.html#method-Task-rbind'><code>mlr3::Task$rbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rename"><a href='../../mlr3/html/Task.html#method-Task-rename'><code>mlr3::Task$rename()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="select"><a href='../../mlr3/html/Task.html#method-Task-select'><code>mlr3::Task$select()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_col_roles"><a href='../../mlr3/html/Task.html#method-Task-set_col_roles'><code>mlr3::Task$set_col_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_levels"><a href='../../mlr3/html/Task.html#method-Task-set_levels'><code>mlr3::Task$set_levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_row_roles"><a href='../../mlr3/html/Task.html#method-Task-set_row_roles'><code>mlr3::Task$set_row_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskClassif" data-id="droplevels"><a href='../../mlr3/html/TaskClassif.html#method-TaskClassif-droplevels'><code>mlr3::TaskClassif$droplevels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskClassif" data-id="truth"><a href='../../mlr3/html/TaskClassif.html#method-TaskClassif-truth'><code>mlr3::TaskClassif$truth()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TaskClassifST-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new spatiotemporal resampling Task
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$new(
  id,
  backend,
  target,
  positive = NULL,
  label = NA_character_,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  extra_args = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>backend</code></dt><dd><p>(<a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>)<br />
Either a <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>, or any object which is convertible to a
<a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> with <code>as_data_backend()</code>.
E.g., am <code>sf</code> will be converted to a <a href="mlr3.html#topic+DataBackendDataTable">mlr3::DataBackendDataTable</a>.</p>
</dd>
<dt><code>target</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</dd>
<dt><code>positive</code></dt><dd><p>(<code>character(1)</code>)<br />
Only for binary classification: Name of the positive class.
The levels of the target columns are reordered accordingly, so that the
first element of <code style="white-space: pre;">&#8288;$class_names&#8288;</code> is the positive class, and the second
element is the negative class.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for the new instance. Shown in <code>as.data.table(mlr_tasks)</code>.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</dd>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</dd>
<dt><code>extra_args</code></dt><dd><p>(named <code>list()</code>)<br />
Named list of constructor arguments, required for converting task types
via <code><a href="mlr3.html#topic+convert_task">mlr3::convert_task()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskClassifST-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>

<p>Returns coordinates of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$coordinates(row_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>row_ids</code></dt><dd><p>(<code>integer()</code>)<br />
Vector of rows indices as subset of <code>task$row_ids</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-TaskClassifST-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the task.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to the <code style="white-space: pre;">&#8288;$print()&#8288;</code> method of the superclass.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskClassifST-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskClassifST$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Task: 
<code><a href="#topic+TaskRegrST">TaskRegrST</a></code>,
<code><a href="#topic+mlr_tasks_cookfarm_mlr3">mlr_tasks_cookfarm_mlr3</a></code>,
<code><a href="#topic+mlr_tasks_diplodia">mlr_tasks_diplodia</a></code>,
<code><a href="#topic+mlr_tasks_ecuador">mlr_tasks_ecuador</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (mlr3misc::require_namespaces(c("sf", "blockCV"), quietly = TRUE)) {
  task = as_task_classif_st(ecuador,
    target = "slides",
    positive = "TRUE", coordinate_names = c("x", "y")
  )

  # passing objects of class 'sf' is also supported
  data_sf = sf::st_as_sf(ecuador, coords = c("x", "y"))
  task = as_task_classif_st(data_sf, target = "slides", positive = "TRUE")

  task$task_type
  task$formula()
  task$class_names
  task$positive
  task$negative
  task$coordinates()
  task$coordinate_names
}

</code></pre>

<hr>
<h2 id='TaskRegrST'>Create a Spatiotemporal Regression Task</h2><span id='topic+TaskRegrST'></span>

<h3>Description</h3>

<p>This task specializes <a href="mlr3.html#topic+Task">mlr3::Task</a> and <a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a> for spatiotemporal
classification problems.
</p>
<p>A spatial example task is available via <code>tsk("ecuador")</code>, a spatiotemporal
one via <code>tsk("cookfarm_mlr3")</code>.
</p>
<p>The coordinate reference system passed during initialization must match the
one which was used during data creation, otherwise offsets of multiple meters
may occur. By default, coordinates are not used as features. This can be
changed by setting <code>coords_as_features = TRUE</code>.
</p>


<h3>Super classes</h3>

<p><code><a href="mlr3.html#topic+Task">mlr3::Task</a></code> -&gt; <code><a href="mlr3.html#topic+TaskSupervised">mlr3::TaskSupervised</a></code> -&gt; <code><a href="mlr3.html#topic+TaskRegr">mlr3::TaskRegr</a></code> -&gt; <code>TaskRegrST</code>
</p>


<h3>Active bindings</h3>

<div class="r6-active-bindings">

<dl>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Returns coordinate reference system of task.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character()</code>)<br />
Coordinate names.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</dd>
</dl>

</div>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-TaskRegrST-new"><code>TaskRegrST$new()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-coordinates"><code>TaskRegrST$coordinates()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-print"><code>TaskRegrST$print()</code></a>
</p>
</li>
<li> <p><a href="#method-TaskRegrST-clone"><code>TaskRegrST$clone()</code></a>
</p>
</li></ul>



<details><summary>Inherited methods</summary>
<ul>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="add_strata"><a href='../../mlr3/html/Task.html#method-Task-add_strata'><code>mlr3::Task$add_strata()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="cbind"><a href='../../mlr3/html/Task.html#method-Task-cbind'><code>mlr3::Task$cbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="data"><a href='../../mlr3/html/Task.html#method-Task-data'><code>mlr3::Task$data()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="divide"><a href='../../mlr3/html/Task.html#method-Task-divide'><code>mlr3::Task$divide()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="droplevels"><a href='../../mlr3/html/Task.html#method-Task-droplevels'><code>mlr3::Task$droplevels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="filter"><a href='../../mlr3/html/Task.html#method-Task-filter'><code>mlr3::Task$filter()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="format"><a href='../../mlr3/html/Task.html#method-Task-format'><code>mlr3::Task$format()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="formula"><a href='../../mlr3/html/Task.html#method-Task-formula'><code>mlr3::Task$formula()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="head"><a href='../../mlr3/html/Task.html#method-Task-head'><code>mlr3::Task$head()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="help"><a href='../../mlr3/html/Task.html#method-Task-help'><code>mlr3::Task$help()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="levels"><a href='../../mlr3/html/Task.html#method-Task-levels'><code>mlr3::Task$levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="missings"><a href='../../mlr3/html/Task.html#method-Task-missings'><code>mlr3::Task$missings()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rbind"><a href='../../mlr3/html/Task.html#method-Task-rbind'><code>mlr3::Task$rbind()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="rename"><a href='../../mlr3/html/Task.html#method-Task-rename'><code>mlr3::Task$rename()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="select"><a href='../../mlr3/html/Task.html#method-Task-select'><code>mlr3::Task$select()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_col_roles"><a href='../../mlr3/html/Task.html#method-Task-set_col_roles'><code>mlr3::Task$set_col_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_levels"><a href='../../mlr3/html/Task.html#method-Task-set_levels'><code>mlr3::Task$set_levels()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="Task" data-id="set_row_roles"><a href='../../mlr3/html/Task.html#method-Task-set_row_roles'><code>mlr3::Task$set_row_roles()</code></a></span></li>
<li><span class="pkg-link" data-pkg="mlr3" data-topic="TaskRegr" data-id="truth"><a href='../../mlr3/html/TaskRegr.html#method-TaskRegr-truth'><code>mlr3::TaskRegr$truth()</code></a></span></li>
</ul>
</details>

<hr>
<a id="method-TaskRegrST-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new spatiotemporal resampling Task
Returns coordinates of observations.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$new(
  id,
  backend,
  target,
  label = NA_character_,
  coordinate_names,
  crs = NA_character_,
  coords_as_features = FALSE,
  extra_args = list()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>id</code></dt><dd><p>(<code>character(1)</code>)<br />
Identifier for the new instance.</p>
</dd>
<dt><code>backend</code></dt><dd><p>(<a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>)<br />
Either a <a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a>, or any object which is convertible to a
<a href="mlr3.html#topic+DataBackend">mlr3::DataBackend</a> with <code>as_data_backend()</code>.
E.g., am <code>sf</code> will be converted to a <a href="mlr3.html#topic+DataBackendDataTable">mlr3::DataBackendDataTable</a>.</p>
</dd>
<dt><code>target</code></dt><dd><p>(<code>character(1)</code>)<br />
Name of the target column.</p>
</dd>
<dt><code>label</code></dt><dd><p>(<code>character(1)</code>)<br />
Label for the new instance. Shown in <code>as.data.table(mlr_tasks)</code>.</p>
</dd>
<dt><code>coordinate_names</code></dt><dd><p>(<code>character(1)</code>)<br />
The column names of the coordinates in the data.</p>
</dd>
<dt><code>crs</code></dt><dd><p>(<code>character(1)</code>)<br />
Coordinate reference system.
WKT2 or EPSG string.</p>
</dd>
<dt><code>coords_as_features</code></dt><dd><p>(<code>logical(1)</code>)<br />
If <code>TRUE</code>, coordinates are used as features.
This is a shortcut for
<code>task$set_col_roles(c("x", "y"), role = "feature")</code> with the assumption
that the coordinates in the data are named <code>"x"</code> and <code>"y"</code>.</p>
</dd>
<dt><code>extra_args</code></dt><dd><p>(named <code>list()</code>)<br />
Named list of constructor arguments, required for converting task types
via <code><a href="mlr3.html#topic+convert_task">mlr3::convert_task()</a></code>.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskRegrST-coordinates"></a>



<h4>Method <code>coordinates()</code></h4>



<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$coordinates(row_ids = NULL)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>row_ids</code></dt><dd><p>(<code>integer()</code>)<br />
Vector of rows indices as subset of <code>task$row_ids</code>.</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p><code><a href="data.table.html#topic+data.table">data.table::data.table()</a></code>
</p>


<hr>
<a id="method-TaskRegrST-print"></a>



<h4>Method <code>print()</code></h4>

<p>Print the task.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$print(...)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>...</code></dt><dd><p>Arguments passed to the <code style="white-space: pre;">&#8288;$print()&#8288;</code> method of the superclass.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-TaskRegrST-clone"></a>



<h4>Method <code>clone()</code></h4>

<p>The objects of this class are cloneable with this method.
</p>


<h5>Usage</h5>

<div class="r"><pre>TaskRegrST$clone(deep = FALSE)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>deep</code></dt><dd><p>Whether to make a deep clone.</p>
</dd>
</dl>

</div>




<h3>See Also</h3>

<p>Other Task: 
<code><a href="#topic+TaskClassifST">TaskClassifST</a></code>,
<code><a href="#topic+mlr_tasks_cookfarm_mlr3">mlr_tasks_cookfarm_mlr3</a></code>,
<code><a href="#topic+mlr_tasks_diplodia">mlr_tasks_diplodia</a></code>,
<code><a href="#topic+mlr_tasks_ecuador">mlr_tasks_ecuador</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
