<!DOCTYPE html><html><head><title>Help for package multivator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multivator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multivator-package'><p>A multivariate emulator</p></a></li>
<li><a href='#apart'>
<p>Decompose a matrix with multiple columns of dependent variables</p></a></li>
<li><a href='#as.separate'>
<p>Split an object of class <code>experiment</code> into a list of univariate datasets</p></a></li>
<li><a href='#betahat'>
<p>Various intermediate expressions needed by the multivariate emulator</p></a></li>
<li><a href='#compatible'>
<p>Are two objects compatible?</p></a></li>
<li><a href='#default_LoF'>
<p>Default List of functions</p></a></li>
<li><a href='#e3mg'>
<p>Output from computer model e3mg</p></a></li>
<li><a href='#experiment'>
<p>Multivatriate hyperparameter (mhp) objects</p></a></li>
<li><a href='#head'><p>Head and tail</p></a></li>
<li><a href='#ipd'>
<p>Positive definite matrices</p></a></li>
<li><a href='#mcneall'>
<p>Dataset due to McNeall</p></a></li>
<li><a href='#mdm'>
<p>Multivariate design matrices</p></a></li>
<li><a href='#mhp'>
<p>Multivatriate hyperparameter (mhp) objects</p></a></li>
<li><a href='#mtoys'><p>Toy datasets</p></a></li>
<li><a href='#multem'>
<p>The multivariate emulator</p></a></li>
<li><a href='#multivator-internal'><p>Internal multivator objects</p></a></li>
<li><a href='#obs_maker'>
<p>Create observations</p></a></li>
<li><a href='#optimal_params'>
<p>Optimization of the hyperparameters</p></a></li>
<li><a href='#Print'><p>Methods for printing mhp and mdm objects</p></a></li>
<li><a href='#showmap'>
<p>Function to plot the McNeall dataset</p></a></li>
<li><a href='#ss'>
<p>Overall variance matrix</p></a></li>
<li><a href='#toy_mm_maker'>
<p>Make a toy mm object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Multivariate Emulator</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-11</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.0.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>utils, emulator (&ge; 1.2-15), mvtnorm, methods, mathjaxr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>abind</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A multivariate generalization of the emulator package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/multivator">https://github.com/RobinHankin/multivator</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/multivator">https://github.com/RobinHankin/multivator</a></td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 23:50:55 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 07:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='multivator-package'>A multivariate emulator</h2><span id='topic+multivator-package'></span><span id='topic+multivator'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>A multivariate generalization of the emulator package.
</p>


<h3>Details</h3>

<p>A generalization of the emulator as discussed in Hankin 2005; to cite
the work in publications please use Hankin 2012.
</p>
<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> multivator</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> A Multivariate Emulator</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-11</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R(&gt;= 3.0.1)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> utils, emulator (&gt;= 1.2-15), mvtnorm, methods, mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> abind</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> A multivariate generalization of the emulator package.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyData: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/multivator</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/multivator</td>
</tr>
<tr>
 <td style="text-align: left;">
RdMacros: </td><td style="text-align: left;"> mathjaxr</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
apart                   Decompose a matrix with multiple columns of
                        dependent variables
as.separate             Split an object of class 'experiment' into a
                        list of univariate datasets
beta_hat                Various intermediate expressions needed by the
                        multivariate emulator
compatible              Are two objects compatible?
default_LoF             Default List of functions
e3mg                    Output from computer model e3mg
experiment              Multivatriate hyperparameter (mhp) objects
head                    Head and tail
ipd                     Positive definite matrices
mcneall                 Dataset due to McNeall
mdm                     Multivariate design matrices
mhp                     Multivatriate hyperparameter (mhp) objects
mtoys                   Toy datasets
multem                  The multivariate emulator
multivator-package      A multivariate emulator
obs_maker               Create observations
optimal_params          Optimization of the hyperparameters
print.mdm               Methods for printing mhp and mdm objects
showmap                 Function to plot the McNeall dataset
ss                      Overall variance matrix
toy_mm_maker            Make a toy mm object
</pre>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>

<p>R. K. S. Hankin 2005.  &ldquo;Introducing BACCO, an R bundle for
Bayesian Analysis of Computer Code Output&rdquo;.  <em>Journal of Statistical
Software</em>, 14(16).
</p>
<p>R. K. S. Hankin (2012). &ldquo;Introducing multivator: A Multivariate Emulator&rdquo;
<em>Journal of Statistical Software</em>, 46(8), 1-20.
<a href="https://doi.org/10.18637/jss.v046.i08">doi:10.18637/jss.v046.i08</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multem">multem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
d &lt;- obs_maker(toy_mm, toy_mhp, toy_LoF, toy_beta)

ex &lt;- experiment(toy_mm,d)

multem(toy_mm2, ex, toy_mhp, toy_LoF,give=TRUE)


</code></pre>

<hr>
<h2 id='apart'>
Decompose a matrix with multiple columns of dependent variables
</h2><span id='topic+apart'></span>

<h3>Description</h3>

<p>Decomposes a matrix with multiple columns of dependent variables into a
<code>mdm</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apart(X, dependent, use_rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apart_+3A_x">X</code></td>
<td>

<p>A matrix with columns corresponding to either independent variables
or dependent variables.  The names of the independent variables are
taken from the column names of <code>X</code>
</p>
</td></tr>
<tr><td><code id="apart_+3A_dependent">dependent</code></td>
<td>
<p>Vector of length <code>ncol(X)</code>.  If numeric,
interpret as the column numbers of the dependent variable.  If
logical, <code>TRUE</code> elements correspond to dependent variables</p>
</td></tr>
<tr><td><code id="apart_+3A_use_rownames">use_rownames</code></td>
<td>

<p>Boolean, with default <code>TRUE</code> meaning to use the rownames of
<code>X</code> to create rownames in the returned value
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>experiment</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.list">as.list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(e3mg)
apart(e3mg , 6:7)

a &lt;- round(emulator::latin.hypercube(6,5),2)
rownames(a) &lt;- c("first","second","third","fourth","fifth","sixth")
colnames(a) &lt;- c(letters[1:3],"length","depth")
jj_expt &lt;- apart(a,4:5)    # use of apart()

x &lt;- get_mdm(jj_expt[c(1,7)])
xold(x) &lt;- 0.5

multem(x,jj_expt,hp=as.mhp(x),give=TRUE)

</code></pre>

<hr>
<h2 id='as.separate'>
Split an object of class <code>experiment</code> into a list of univariate datasets
</h2><span id='topic+as.separate'></span>

<h3>Description</h3>

<p>Split an <code>experiment</code> object into univariate designs; 
return a list with elements suitable
for univariate analysis with the <code>emulator</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.separate(expt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.separate_+3A_expt">expt</code></td>
<td>

<p>Object of class <code>experiment</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(emulator)

data(mtoys)
d &lt;- obs_maker(toy_mm, toy_mhp, toy_LoF, toy_beta)

ex &lt;- experiment(toy_mm, d)
jj &lt;- as.separate(ex)   #list of 3: temp,rain,humidity


# now use it in a univariate emulator:
kk &lt;- jj$temp
interpolant.quick(x=latin.hypercube(3,4),d=kk$obs,xold=kk$val,scales=rep(1,4))





</code></pre>

<hr>
<h2 id='betahat'>
Various intermediate expressions needed by the multivariate emulator
</h2><span id='topic+beta_hat'></span><span id='topic+betahat_mult'></span><span id='topic+betahat_mult_Sigma'></span><span id='topic+cstar'></span><span id='topic+regressor'></span><span id='topic+var.matrix'></span><span id='topic+eq2.36'></span><span id='topic+eq2.36_Sigma'></span>

<h3>Description</h3>

<p>Various intermediate expressions needed by the multivariate emulator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regressor(x,LoF)
beta_hat(expt,hp,LoF, ...)
betahat_mult(H, Sigmainv, d)
betahat_mult_Sigma(H, Sigma, d)
cstar(x1, x2=x1 , expt, hp,  LoF = NULL, Sigmainv=NULL, ...)
eq2.36(H, Sigmainv, d, log=TRUE)
eq2.36_Sigma(H, Sigma, d)
var.matrix(x1,x2=x1,hp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betahat_+3A_x">x</code>, <code id="betahat_+3A_x1">x1</code>, <code id="betahat_+3A_x2">x2</code></td>
<td>

<p>Objects of class <code>mdm</code>: multivariate design matrix
</p>
</td></tr>
<tr><td><code id="betahat_+3A_h">H</code></td>
<td>

<p>Matrix of regressors (create this with <code>regressor()</code>)
</p>
</td></tr>
<tr><td><code id="betahat_+3A_d">d</code></td>
<td>

<p>Vector of observations, possibly not all of the same
dimensions (eg some elements might
be Kelvin, others millimeters of rain per year)
</p>
</td></tr>
<tr><td><code id="betahat_+3A_expt">expt</code></td>
<td>
<p>Object of class <code>experiment</code></p>
</td></tr>
<tr><td><code id="betahat_+3A_sigma">Sigma</code></td>
<td>
<p>The variance matrix of <code>d</code></p>
</td></tr>
<tr><td><code id="betahat_+3A_log">log</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return the logarithm
of the answer</p>
</td></tr>
<tr><td><code id="betahat_+3A_sigmainv">Sigmainv</code></td>
<td>

<p>The inverse of the variance matrix of <code>d</code>, with
default <code>NULL</code> meaning to calculate it directly using
<code>var.matrix()</code>
</p>
</td></tr>
<tr><td><code id="betahat_+3A_lof">LoF</code></td>
<td>

<p>A list of functions with default <code>NULL</code> meaning to use
<code>default_LoF()</code>
</p>
</td></tr>
<tr><td><code id="betahat_+3A_hp">hp</code></td>
<td>
<p>Object of class <code>mhp</code>: multivariate hyperparameters</p>
</td></tr>
<tr><td><code id="betahat_+3A_...">...</code></td>
<td>
<p>Extra arguments which are
passed (via <code>var.matrix()</code>) to <code>corr.matrix()</code> of the
emulator package</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>regressor()</code> creates a (sort of) direct sum of
regressor matrices for an overall regressor matrix.  It returns a
matrix whose rows are the regressor functions for each row in the
<code>df</code> argument.  Each type of observation has its own
&lsquo;slot&rsquo; of columns, the others being filled with zeros.
</p>
<p>The emulator package <em>should</em> have used this method (rather than
messing about with <code>regressor.basis()</code> and
<code>regressor.multi()</code>).
</p>
<p>To get the regression coefficients, the user should use function
<code>beta_hat()</code>, which is the user-friendly version.  It is a
wrapper for function <code>betahat_mult_Sigma()</code>.
</p>
<p>The equation for <code>var.matrix()</code> is
</p>
\[
    c^*\left(x,x'\right)=
    c\left(x,x'\right) - t(x)^TA^{-1}t(x') + \left\lbrace h(x)^T - t(x)^TA^{-1}H\right\rbrace
    \left(H^TA^{-1}H\right)^{-1}\left\lbrace h(x')^T -
    t(x')^TA^{-1}H\right\rbrace ^T
  \]


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multem">multem</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtoys)

H &lt;- regressor(toy_mm, toy_LoF)
Sigma &lt;- var.matrix(toy_mm, hp=toy_mhp)
Sigmainv &lt;- solve(Sigma)


jj &lt;- toy_mm_maker(34,35,36)
expt  &lt;- experiment(jj,obs_maker(jj,toy_mhp,toy_LoF,toy_beta))

x1 &lt;- jj[c(20,40,100),]
xold(x1) &lt;- 0.2

x2 &lt;- jj[c(11,21:24,40:42),]
xold(x2) &lt;- xold(x2)+0.1

#primary function of package:
multem(x=x1, expt, hp=toy_mhp, LoF=toy_LoF)

# conditional covariance matrix:
cstar(x1,x2, expt, hp=toy_mhp, LoF=toy_LoF)
 
</code></pre>

<hr>
<h2 id='compatible'>
Are two objects compatible?
</h2><span id='topic+compatible'></span>

<h3>Description</h3>

<p>Function to detect whether two objects are compatible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compatible(x1,x2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compatible_+3A_x1">x1</code>, <code id="compatible_+3A_x2">x2</code></td>
<td>

<p>Two objects with <code>names</code> and <code>levels</code>.  Typically either
objects of class <code>mhp</code> or <code>mdm</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here, &ldquo;compatible&rdquo; means have the same names and levels.  If an
<code>mdm</code> object and <code>mhp</code> object are compatible, then they may
be supplied to (eg) <code>var.matrix()</code>.
</p>
<p>The function uses <code>identical()</code> to compare the names and levels.
</p>


<h3>Value</h3>

<p>Returns a Boolean.
</p>


<h3>Note</h3>

<p>Cannot yet compare <code>LoF</code> objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
stopifnot(compatible(toy_mhp, toy_mm))
</code></pre>

<hr>
<h2 id='default_LoF'>
Default List of functions
</h2><span id='topic+default_LoF'></span>

<h3>Description</h3>

<p>Creates a default List of Functions for use with <code>regressor()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>default_LoF(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="default_LoF_+3A_x">x</code></td>
<td>

<p>Object with <code>names</code> and <code>levels</code> methods; typically of
class <code>mdm</code> or <code>mhp</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a named list with each element giving the regressor functions
for that level.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regressor">regressor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)

default_LoF(toy_mm)  # note list names == levels(toy_mm)

regressor(toy_mm)           # use default
regressor(toy_mm , toy_LoF) # use a bespoke set
</code></pre>

<hr>
<h2 id='e3mg'>
Output from computer model e3mg
</h2><span id='topic+e3mg'></span><span id='topic+e3mg_LoF'></span>

<h3>Description</h3>

<p>Output from computer model e3mg detailing the depth of the recession and
its length as a function of four exogenous parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(e3mg)</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>e3mg</code> is a matrix with 843 rows and 6 columns.
Four of the columns are exogenous variables (<code>oil.price</code>,
<code>direct.tax</code>, <code>interest.rate</code>, and <code>saving.ratio</code>)
and two are model outputs: <code>rec_len</code>, the length (in years) of
the recession, and <code>dep_rec</code>, the depth of the recession.
</p>
</li>
<li> <p><code>e3mg_LoF</code> is a list of functions suitable for use with
the <code>e3mg</code> dataset
</p>
</li></ul>



<h3>Details</h3>

<p>The data comprises 843 runs of the e3mg econometric model, used to
predict the recession precipitated by the banking crisis.
</p>
<p>The depth of the recession is defined as the maximum difference between
predicted post-crash GDP and GDP immediately pre-crash.
</p>
<p>The length of the recession is defined as the time in years required for
GDP to return to pre-crash levels.
</p>


<h3>Source</h3>

<p>Data kindly provided by Cambridge Econometrics
</p>


<h3>See Also</h3>

<p><code><a href="#topic+apart">apart</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(e3mg)
a &lt;- lm(rec_len~oil.price*direct.tax + direct.tax*saving.ratio + investment,data=data.frame(e3mg))
b &lt;- lm(rec_dep~oil.price*direct.tax + direct.tax*saving.ratio + investment,data=data.frame(e3mg))
plot(residuals(a),residuals(b))  # correlated!



# define an experiment object and find optimal prarams
e3mg_expt &lt;- apart(e3mg[1:20,],6:7)
opt &lt;- optimal_params(e3mg_expt, e3mg_LoF, option='c')


# now a point in parameter space:
center &lt;- get_mdm(e3mg_expt)[c(1,40),]
rownames(center) &lt;- c('center_dep','center_len')
xold(center) &lt;- 0


#now predict the behaviour at the center:
multem(center, e3mg_expt, hp=opt, e3mg_LoF, give = TRUE)


</code></pre>

<hr>
<h2 id='experiment'>
Multivatriate hyperparameter (mhp) objects
</h2><span id='topic+experiment'></span><span id='topic+print.experiment'></span><span id='topic+get_mdm'></span><span id='topic+get_obs'></span><span id='topic+head+2Cexperiment-method'></span><span id='topic+tail+2Cexperiment-method'></span><span id='topic++5B+2Cexperiment-method'></span><span id='topic+as.data.frame+2Cexperiment-method'></span><span id='topic+as.data.frame+2Cexperiment+2CANY+2CANY-method'></span><span id='topic+experiment-class'></span>

<h3>Description</h3>

<p>Create and manipulate multivariate hyperparameter (mhp) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>experiment(mm,obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="experiment_+3A_mm">mm</code></td>
<td>
<p>Object of class <code>mdm</code></p>
</td></tr>
<tr><td><code id="experiment_+3A_obs">obs</code></td>
<td>
<p>Vector of observations, with elements corresponding to the
rows of <code>mm</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>An &ldquo;experiment&rdquo; is an ordered pair of a multivariate design
matrix and a vector of observations with entries corresponding to the
rows of the design matrix.
</p>
<p>It functions as a container for the design matrix and observations. It
is intended to simplify the calls to many functions in the package
which require a design matrix and vector of observations.
</p>
<p>There are two get methods, <code>get_mdm()</code> and <code>get_obs()</code>, for
the design matrix and observations respectively.  Note the deliberate
absence of set methods.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>experiment</code>, which is used as input to
many of the functions in the package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(mtoys)
jj_expt &lt;- experiment(toy_mm,toy_d)


# accessor methods:
get_obs(jj_expt)
get_mdm(jj_expt)


# estimation of coefficients:
beta_hat(jj_expt, toy_mhp, toy_LoF)

# use multem():
multem(toy_mm3, jj_expt, toy_mhp, toy_LoF,give=TRUE)


</code></pre>

<hr>
<h2 id='head'>Head and tail</h2><span id='topic+head'></span><span id='topic+tail'></span><span id='topic+head+2Cmdm-method'></span><span id='topic+tail+2Cmdm-method'></span>

<h3>Description</h3>

<p>Print the first few, or last few, lines of a mdm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'mdm'
head(x, n = 6, ...)
## S4 method for signature 'mdm'
tail(x, n = 6, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="head_+3A_x">x</code></td>
<td>
<p>object of class <code>mdm</code></p>
</td></tr>
<tr><td><code id="head_+3A_n">n</code></td>
<td>
<p>number of lines to print as per same argument in
<code>head()</code> and <code>tail()</code></p>
</td></tr>
<tr><td><code id="head_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>head()</code> or <code>tail()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a truncated <code>mdm</code> object.  The levels of the types are unchanged.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("mtoys")

head(toy_mm)
tail(toy_mm,3)

</code></pre>

<hr>
<h2 id='ipd'>
Positive definite matrices
</h2><span id='topic+ipd'></span>

<h3>Description</h3>

<p>Is a matrix symmetric positive-definite?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipd(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipd_+3A_mat">mat</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns either <code>TRUE</code> if symmetric positive-definite; or <code>FALSE</code>, printing a diagnostic message.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
stopifnot(ipd(crossprod(matrix(rnorm(30),10))))
stopifnot(ipd(M(toy_mhp)))
</code></pre>

<hr>
<h2 id='mcneall'>
Dataset due to McNeall
</h2><span id='topic+mcneall'></span><span id='topic+landmask'></span><span id='topic+mcneall_temps'></span><span id='topic+mean_temp'></span><span id='topic+mcneall_pc'></span><span id='topic+eigenmaps'></span><span id='topic+opt_mcneall'></span>

<h3>Description</h3>

<p>Data, due to McNeall, from 92 runs of a climate model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mcneall)</code></pre>


<h3>Details</h3>

<p>McNeall used a numerical climate model and ran it 92 times, on a design
matrix specified on 16 independent variables as detailed in McNeall
2008.
</p>
<p>The model output is a temperature distribution over the surface of the
Earth.  The model gives 2048 temperatures, corresponding to 2048 grid
squares distributed over the Earth.  A vector of 2048 temperatures may
be displayed on a global map using the <code>showmap()</code> function.
</p>
<p>The 92 model runs are presented in the form of a 2048 by 92 matrix
<code>mcneall_temps</code>, each column of which corresponds to a run.  A row
of 92 temperatures corresponds to the temperature at a particular place
on the earth as predicted by each of the 92 model runs.
</p>
<p>Following McNeall, a principal component analysis on the maps was
performed.  The first four were used.  Matrix <code>eigenmaps</code> is a 2048
by 4 matrix, with columns corresponding to the four principal
components.  
</p>
<p>Matrix <code>mcneall_pc</code> is a 92-by-20 matrix.  The first 16 columns
correspond to the independent variables (ie the design matrix); columns
17-20 correspond to the first four principal components of the model
output.  The 92 rows correspond to the 92 model runs.
</p>
<p>The package can be used on the <code>mcneall_temps</code> matrix; use
<code>apart()</code> to generate a <code>mdm</code> object.  A reasonably optimized
hyperparameters object of class <code>mhp</code> is given as
<code>opt_mcneall</code>.
</p>


<h3>References</h3>

<p>D. McNeall 2008.  &quot;Dimension Reduction in the Bayesian analysis of a
numerical climate model&quot;.  PhD thesis, University of Southampton.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showmap">showmap</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcneall)

showmap(mcneall_temps[,1], pc=FALSE,landmask=landmask)

</code></pre>

<hr>
<h2 id='mdm'>
Multivariate design matrices
</h2><span id='topic+mdm'></span><span id='topic+mdm-class'></span><span id='topic+as.mdm'></span><span id='topic+is.mdm'></span><span id='topic+as.list'></span><span id='topic+as.matrix'></span><span id='topic+as.data.frame'></span><span id='topic+types'></span><span id='topic+types+3C-'></span><span id='topic+names+3C-'></span><span id='topic+xold'></span><span id='topic+xold+2Cmdm-method'></span><span id='topic+xold+3C-'></span><span id='topic+xold+3C-+2Cmdm-method'></span><span id='topic+as.list+2Cmdm-method'></span><span id='topic+types+2Cmdm-method'></span><span id='topic+types+3C-+2Cmdm-method'></span><span id='topic++5B+2Cmdm-method'></span><span id='topic++5B+3C-+2Cmdm-method'></span><span id='topic+levels+2Cmdm-method'></span><span id='topic+levels+3C-+2Cmdm-method'></span><span id='topic+levels+2Cexperiment-method'></span><span id='topic+names+2Cmdm-method'></span><span id='topic+names+3C-+2Cmdm-method'></span><span id='topic+rbind+2Cmdm-method'></span><span id='topic+rownames+2Cmdm-method'></span><span id='topic+rownames+3C-+2Cmdm-method'></span><span id='topic+as.matrix+2Cmdm-method'></span><span id='topic+nrow+2Cmdm-method'></span><span id='topic+ncol+2Cmdm-method'></span><span id='topic+dim+2Cmdm-method'></span><span id='topic+as.mdm+2Cmhp-method'></span><span id='topic+as.data.frame+2Cmhp-method'></span><span id='topic+as.data.frame+2Cmdm+2Cmissing+2Cmissing-method'></span><span id='topic+rbind+2Cmdm-method'></span><span id='topic+rbind'></span>

<h3>Description</h3>

<p>Multivariate design matrices are represented using objects of class
<code>mdm</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mdm(xold, types)
as.mdm(x, ...)
is.mdm(x)
as.list(x, ...)
as.matrix(x, ...)
## S4 method for signature 'mdm,missing,missing'
as.data.frame(x, row.names=NULL,optional=TRUE, ...)
## S4 method for signature 'mdm'
rbind(x, ..., deparse.level=1)
types(x)
xold(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdm_+3A_xold">xold</code></td>
<td>

<p>Matrix of design points, each row being a point in parameter space
</p>
</td></tr>
<tr><td><code id="mdm_+3A_types">types</code></td>
<td>

<p>A factor holding the types of each observation
</p>
</td></tr>
<tr><td><code id="mdm_+3A_x">x</code></td>
<td>
<p>An object of class <code>mdm</code>
</p>
</td></tr>
<tr><td><code id="mdm_+3A_row.names">row.names</code>, <code id="mdm_+3A_optional">optional</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="mdm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>NextMethod()</code></p>
</td></tr>
<tr><td><code id="mdm_+3A_deparse.level">deparse.level</code></td>
<td>
<p>As for <code>rbind()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Various functionality for creating and manipulating objects of class
<code>mdm</code> (Multivariate Design Matrix).
</p>


<h3>Note</h3>

<p>The internal representation has two slots, one for the design matrix
proper (a matrix), and one for the types of observation (a factor).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mhp">mhp</a></code>,<code><a href="#topic+apart">apart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mm &lt;- toy_mm_maker(7,8,9)
is.mdm(mm)
xold(mm) &lt;- matrix(rnorm(108),27,4)
mm[1,1] &lt;- 0.3

data(mtoys)
obs_maker(mm,toy_mhp,toy_LoF,toy_beta)

</code></pre>

<hr>
<h2 id='mhp'>
Multivatriate hyperparameter (mhp) objects
</h2><span id='topic+mhp'></span><span id='topic+mhp-class'></span><span id='topic+is.mhp'></span><span id='topic+M'></span><span id='topic+B'></span><span id='topic+M+3C-'></span><span id='topic+B+3C-'></span><span id='topic+as.mhp'></span><span id='topic+as.mhp+2Cmdm-method'></span><span id='topic+as.mhp+2Cexperiment-method'></span><span id='topic+names'></span><span id='topic+summary+2Cmhp-method'></span><span id='topic+summary'></span><span id='topic+names+2Cmhp-method'></span><span id='topic+names+3C-+2Cmhp-method'></span><span id='topic+levels'></span><span id='topic+levels+2Cmhp-method'></span><span id='topic+levels+3C-+2Cmhp-method'></span><span id='topic+types+2Cmhp-method'></span><span id='topic+types+3C-+2Cmhp-method'></span><span id='topic+print.mhpSummary'></span>

<h3>Description</h3>

<p>Create and manipulate multivatriate hyperparameter (mhp) objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mhp(M, B, levels = NULL, names = NULL)
is.mhp(x)
M(x)
M(x) &lt;- value
B(x)
B(x) &lt;- value
levels(x)
summary(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mhp_+3A_m">M</code></td>
<td>
<p>Variance matrix (must be positive definite)</p>
</td></tr>
<tr><td><code id="mhp_+3A_b">B</code></td>
<td>
<p>Array of roughness parameters.  Each slice (ie <code>B[,,i]</code>) must
be positive-definite</p>
</td></tr>
<tr><td><code id="mhp_+3A_levels">levels</code></td>
<td>
<p>Character vector holding the levels.  Default
<code>NULL</code> means to use <code>rownames(M)</code> or
<code>dimnames(B[[3]])</code></p>
</td></tr> 
<tr><td><code id="mhp_+3A_names">names</code></td>
<td>
<p>Character vector holding the names of the dimensions.
Default of <code>NULL</code> means to use <code>dimnames(B[[1]])</code></p>
</td></tr>
<tr><td><code id="mhp_+3A_x">x</code>, <code id="mhp_+3A_object">object</code></td>
<td>
<p>Object of class <code>mhp</code></p>
</td></tr>
<tr><td><code id="mhp_+3A_value">value</code></td>
<td>
<p>Replacement object</p>
</td></tr>
<tr><td><code id="mhp_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>summary</code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>mhp</code> object <em>must</em> have <code>names</code> and <code>levels</code>, so
either provide them explicitly with the eponymous arguments, or give
named arrays to <code>M</code> and <code>B</code>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>mhp</code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mdm">mdm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
hp &lt;- mhp(M=diag(2),B=array(c(diag(3),diag(3)),c(3,3,2)),
names=letters[1:3],levels=c("oak","ash"))
M(hp)
B(hp)[1,1,1] &lt;- 30  # try a negative value and see what happens
names(hp)
names(hp) &lt;-  c("Alice","Zachy","Annabel")
levels(hp) &lt;- c("squid","snail")
summary(hp)

</code></pre>

<hr>
<h2 id='mtoys'>Toy datasets</h2><span id='topic+mtoys'></span><span id='topic+toy_LoF'></span><span id='topic+toy_M'></span><span id='topic+toy_B'></span><span id='topic+toy_d'></span><span id='topic+toy_d2'></span><span id='topic+toy_expt'></span><span id='topic+toy_mm'></span><span id='topic+toy_mm2'></span><span id='topic+toy_mm3'></span><span id='topic+toy_mm4'></span><span id='topic+toy_mhp'></span><span id='topic+toy_point'></span><span id='topic+toy_beta'></span>

<h3>Description</h3>

<p>Toy datasets that illustrate the package</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy_LoF
toy_mm
toy_mm2
toy_mm3
toy_mhp
</code></pre>


<h3>Format</h3>


<ul>
<li>
<p><code>toy_LoF</code> is a list of three functions that work with
<code>regressor()</code> and <code>toy_df</code>
</p>
</li>
<li> <p><code>toy_M</code> is an example <code class="reqn">M</code> matrix for use with
<code>mhp()</code>
</p>
</li>
<li> <p><code>toy_B</code> is an example of a <code class="reqn">B</code> array of
roughness coefficients for use with <code>mhp()</code>
</p>
</li>
<li> <p><code>toy_mm</code> and <code>toy_mm2</code> are examples of a <code>mdm</code>
object, generated with function <code>toy_mm_maker()</code>.  These
objects are marginals from the <em>same</em> multivariate observation.
</p>
</li>
<li> <p><code>toy_mm3</code> and <code>toy_mm4</code> are small examples of
<code>mdm</code> objects
</p>
</li>
<li> <p><code>toy_mhp</code> is an example of a <code>mhp</code> object
</p>
</li>
<li> <p><code>toy_beta</code> is a numeric vector that works with the above objects
</p>
</li></ul>



<h3>Details</h3>

<p>These objects are intended as simple working &lsquo;toy&rsquo; examples  of
the various things needed to use the emulator.
</p>
<p>Note that <code>toy_d</code> and <code>toy_d2</code> are the marginals of the
<em>same</em> observation (see the vignette).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>R. K. S. Hankin 2005. <em>Introducing BACCO, an R bundle for
Bayesian analysis of computer code output</em>, Journal of Statistical
Software, 14(16)
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+toy_mm_maker">toy_mm_maker</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
obs_maker(toy_mm, toy_mhp, toy_LoF, toy_beta)

multem(toy_mm2,toy_expt,toy_mhp,toy_LoF,give=TRUE)


</code></pre>

<hr>
<h2 id='multem'>
The multivariate emulator
</h2><span id='topic+multem'></span>

<h3>Description</h3>

<p>A multivariate generalization of the <code>interpolant()</code> function of
the <code>emulator</code> package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multem(x, expt, hp,  LoF = NULL, give=FALSE, Sigmainv=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multem_+3A_x">x</code></td>
<td>
<p>Points at which the function is to be estimated
in the form of an object of class <code>mdm</code>
</p>
</td></tr>
<tr><td><code id="multem_+3A_expt">expt</code></td>
<td>
<p>Points at which the code
has been evaluated (<code>x_known</code>), in the form of an object of
class <code>experiment</code>
</p>
</td></tr>
<tr><td><code id="multem_+3A_hp">hp</code></td>
<td>
<p>hyperparameter object, of class <code>mhp</code>
</p>
</td></tr>
<tr><td><code id="multem_+3A_give">give</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to return extra
information and default <code>FALSE</code> meaning to return just the mean</p>
</td></tr>
<tr><td><code id="multem_+3A_sigmainv">Sigmainv</code></td>
<td>

<p>The inverse of the variance matrix of the observations with default
<code>NULL</code> meaning to calculate using <code>var.matrix()</code>
</p>
</td></tr>
<tr><td><code id="multem_+3A_lof">LoF</code></td>
<td>
<p>List of regressor functions</p>
</td></tr>
<tr><td><code id="multem_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>var.matrix()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the central function of the package.  It is the analogue of
<code>interpolant()</code> of the emulator package.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+betahat_mult">betahat_mult</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
d &lt;- obs_maker(toy_mm, toy_mhp, toy_LoF, toy_beta)
ex &lt;- experiment(toy_mm , d)

Sigmainv &lt;- solve(var.matrix(toy_mm,hp=toy_mhp))
multem(x=toy_mm2, expt=ex, hp=toy_mhp,LoF=toy_LoF, give=TRUE)

</code></pre>

<hr>
<h2 id='multivator-internal'>Internal multivator objects</h2><span id='topic+.mdm_print'></span><span id='topic+.mdm_valid'></span><span id='topic+.mhp_print'></span><span id='topic+.mhp_valid'></span><span id='topic+.Random.seed'></span><span id='topic+.required'></span>

<h3>Description</h3>

<p>Internal multivator objects</p>


<h3>Details</h3>

<p>These are not to be called by the user</p>

<hr>
<h2 id='obs_maker'>
Create observations
</h2><span id='topic+obs_maker'></span>

<h3>Description</h3>

<p>A function to create observations using known parameters and hyperparameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obs_maker(x, hp, LoF, beta, Sigma=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obs_maker_+3A_x">x</code></td>
<td>

<p>Object of class <code>mdm</code>: each row is a point in parameter space
</p>
</td></tr>
<tr><td><code id="obs_maker_+3A_hp">hp</code></td>
<td>

<p>Object of class <code>mhp</code>
</p>
</td></tr>
<tr><td><code id="obs_maker_+3A_lof">LoF</code></td>
<td>

<p>List of functions
</p>
</td></tr>
<tr><td><code id="obs_maker_+3A_beta">beta</code></td>
<td>

<p>Vector of regression coefficients
</p>
</td></tr>
<tr><td><code id="obs_maker_+3A_sigma">Sigma</code></td>
<td>

<p>Variance matrix, with default <code>NULL</code> meaning to use
<code>var.matrix(x,hp)</code>
</p>
</td></tr>
<tr><td><code id="obs_maker_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>var.matrix()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the <code>mvtnorm</code> package to generate observations directly from
the parameters and hyperparameters as a Gaussian process.
</p>


<h3>Value</h3>

<p>Returns a (named) vector of observations.  Note that the observations
may have different units (eg temperature in Kelvin, rainfall in
millimeters per year).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+toy_mm_maker">toy_mm_maker</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
d &lt;- obs_maker(toy_mm , toy_mhp, toy_LoF, toy_beta)
d &lt;- obs_maker(toy_mm_maker(6,7,8) , toy_mhp, toy_LoF, toy_beta)



</code></pre>

<hr>
<h2 id='optimal_params'>
Optimization of the hyperparameters
</h2><span id='topic+optimal_params'></span><span id='topic+optimal_B'></span><span id='topic+optimal_identical_B'></span><span id='topic+optimal_diag_M'></span><span id='topic+optimal_M'></span>

<h3>Description</h3>

<p>Optimization of the hyperparameters using a sequence of subfunctions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimal_params     (expt, LoF, start_hp, option = "a", ...)
optimal_B          (expt, LoF, start_hp, option = "a", verbose=FALSE, ...)
optimal_identical_B(expt, LoF, start_hp, verbose=FALSE, ...)
optimal_diag_M     (expt, LoF, start_hp)
optimal_M          (expt, LoF, start_hp, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimal_params_+3A_expt">expt</code></td>
<td>

<p>Object of class <code>experiment</code>
</p>
</td></tr>
<tr><td><code id="optimal_params_+3A_lof">LoF</code></td>
<td>

<p>List of functions
</p>
</td></tr>
<tr><td><code id="optimal_params_+3A_start_hp">start_hp</code></td>
<td>

<p>Start value for the hyperparameters, an object of class <code>mhp</code>.
The various optimization routines use the different parts of
<code>start_hp</code> as start points, and incrementally update it
</p>
</td></tr>
<tr><td><code id="optimal_params_+3A_option">option</code></td>
<td>

<p>In function <code>optimal_B()</code> and consequently
<code>optimal_params()</code>, a character indicating whether to allow the
scales to differ or not.
</p>

<ul>
<li><p> Default option &ldquo;<code>a</code>&rdquo; is the simplest: each
univariate <code>B</code> matrix is a multiple of the identity matrix.
</p>
</li>
<li><p> Option &ldquo;<code>b</code>&rdquo; allows the <code>B</code> matrices to be
any (positive definite) diagonal matrix.
</p>
</li>
<li><p> Option &ldquo;<code>c</code>&rdquo; specifies that <code>B[,,j]</code> is
diagonal for each <code>j</code> and furthermore that
<code>B[i,i,1]=B[i,i,2]=...=B[i,i,r]</code>.  This option calls
<code>optimal_identical_B()</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="optimal_params_+3A_verbose">verbose</code></td>
<td>

<p>In function <code>optimal_B()</code>, Boolean with <code>TRUE</code> meaning
to print debugging information and default	<code>FALSE</code> meaning not
to print anything
</p>
</td></tr>
<tr><td><code id="optimal_params_+3A_...">...</code></td>
<td>

<p>Further arguments passed to the optimization routine
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user-friendly wrapper function is <code>optimal_params()</code>.  This
calls function <code>optimal_B()</code> first, as most of the analysis is
conditional on <code>B</code>.  Then <code>optimal_diag_M()</code> is called; this
places the maximum likelihood estimate for <code class="reqn">\sigma^2</code> on
the diagonal of <code>M</code>.  Finally, <code>optimal_M()</code> is called,
which assigns the off-diagonal elements of <code>M</code>.
</p>
<p>Each of the subfunctions returns an object appropriate for insertion
into a <code>mhp</code> object.
</p>
<p>The &ldquo;meat&rdquo; of <code>optimal_params()</code> is
</p>
<pre>
       B(out)  &lt;- optimal_B     (mm, d, LoF, start_hp=out, option=option, ...)
  diag(M(out)) &lt;- optimal_diag_M(mm, d, LoF, start_hp=out, ...)
       M(out)  &lt;- optimal_M     (mm, d, LoF, start_hp=out, ...)
  return(out)
</pre>
<p>See how object <code>out</code> is modified sequentially, it being used as a
start point for the next function.
</p>


<h3>Value</h3>

<p>Returns a <code>mhp</code> object.
</p>


<h3>Note</h3>

<p>Function <code>optimal_diag_M()</code> uses MLEs for the diagonals, but using
each type of observation separately.  It is conceivable that there is 
information that is not being used here.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)

optimal_params(toy_expt,toy_LoF,toy_mhp,option='c',control=list(maxit=1))
</code></pre>

<hr>
<h2 id='Print'>Methods for printing mhp and mdm objects</h2><span id='topic+print.mdm'></span><span id='topic+print.mhp'></span><span id='topic+show+2Cmdm-method'></span><span id='topic+show+2Cmhp-method'></span>

<h3>Description</h3>

<p>Methods for printing nicely
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdm'
print(x, ...)
## S3 method for class 'mhp'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Print_+3A_x">x</code></td>
<td>
<p>An object of class <code>mdm</code> or <code>mhp</code></p>
</td></tr>
<tr><td><code id="Print_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
a &lt;- as.mhp(toy_mm)
a
</code></pre>

<hr>
<h2 id='showmap'>
Function to plot the McNeall dataset
</h2><span id='topic+showmap'></span>

<h3>Description</h3>

<p>A small wrapper function to plot a global map of temperature, which is
useful when analyzing the McNeall dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showmap(z, pc, landmask, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showmap_+3A_z">z</code></td>
<td>

<p>A vector of length 2048 corresponding to temperatures on the Earth's
surface</p>
</td></tr>
<tr><td><code id="showmap_+3A_pc">pc</code></td>
<td>
<p>Boolean, with <code>TRUE</code> meaning to interpret <code>z</code> as
a principal component and <code>FALSE</code> meaning to interpret <code>z</code>
as a temperature map</p>
</td></tr>
<tr><td><code id="showmap_+3A_landmask">landmask</code></td>
<td>
<p>A matrix of zeros and ones corresponding to the
Earth's surface with zero indicating sea and one indicating land;
use <code>data(mcneall)</code></p>
</td></tr>
<tr><td><code id="showmap_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <code>filled.contour()</code>
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcneall">mcneall</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mcneall)
showmap(mcneall_temps[,1],pc=FALSE,landmask=landmask)
</code></pre>

<hr>
<h2 id='ss'>
Overall variance matrix
</h2><span id='topic+ss'></span><span id='topic+ss_matrix'></span><span id='topic+ss_matrix_simple'></span>

<h3>Description</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Calculates the maximum correlations possible consistent with the
roughness parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss(A, B, Ainv, Binv)
ss_matrix(hp,useM=TRUE)
ss_matrix_simple(hp,useM=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss_+3A_a">A</code>, <code id="ss_+3A_b">B</code></td>
<td>

<p>Positive-definite matrices (roughness parameters)
</p>
</td></tr>
<tr><td><code id="ss_+3A_ainv">Ainv</code>, <code id="ss_+3A_binv">Binv</code></td>
<td>

<p>The inverses of <code>A</code> and <code>B</code>; if missing, compute explicitly
</p>
</td></tr>
<tr><td><code id="ss_+3A_hp">hp</code></td>
<td>
<p>An object of class <code>mhp</code></p>
</td></tr>
<tr><td><code id="ss_+3A_usem">useM</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to multiply
(pointwise) by <i>M</i> and <code>FALSE</code> meaning not to (so giving the
maximum correlation consistent with the roughness matrices <i>B</i>)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>ss()</code> calculates the maximum possible correlation
between observations of two Gaussian processes at the same point
(equation 24 of the vignette):
</p>
\[
    \left|
    \left( 
    \frac{1}{2}B_r+\frac{1}{2}B_s\vphantom{\frac{1}{2}B_r^{-1}}
    \right)\left(
    \frac{1}{2}B_r^{-1}+\frac{1}{2}B_s^{-1}
    \right)
    \right|^{-1/4}
  \]
<p>Functions <code>ss_matrix()</code> and <code>ss_matrix_simple()</code> calculate
the maximum covariances among the types of object specified in the
<code>hp</code> argument, an object of class <code>mhp</code>.  Function
<code>ss_matrix()</code> is the preferred form; function
<code>ss_matrix_simple()</code> is a less efficient, but more transparent,
version.  The two functions should return identical output.
</p>


<h3>Value</h3>

<p>Function <code>ss()</code> returns a scalar, <code>ss_matrix()</code> a matrix
of covariances.
</p>


<h3>Note</h3>

<p>Thanks to Stephen Stretton for a crucial insight here
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(mtoys)
ss_matrix(toy_mhp)
</code></pre>

<hr>
<h2 id='toy_mm_maker'>
Make a toy mm object
</h2><span id='topic+toy_mm_maker'></span>

<h3>Description</h3>

<p>Create a toy <code>mhp</code> object with three levels: temperature, rainfall,
and humidity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toy_mm_maker(na, nb, nc, include_first = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toy_mm_maker_+3A_na">na</code>, <code id="toy_mm_maker_+3A_nb">nb</code>, <code id="toy_mm_maker_+3A_nc">nc</code></td>
<td>

<p>Numbers of observations for each level
</p>
</td></tr>
<tr><td><code id="toy_mm_maker_+3A_include_first">include_first</code></td>
<td>

<p>Boolean, with default <code>TRUE</code> meaning to include an extra
observation of each level at the midpoint of the domain
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>mhp</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toy_mm_maker(4,5,6,FALSE)
toy_mm_maker(1,1,2,TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
