<!DOCTYPE html><html><head><title>Help for package polyqtlR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {polyqtlR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#polyqtlR-package'><p>QTL analysis in polyploid species using posterior genotype probabilities</p></a></li>
<li><a href='#BLUE'><p>Calculate Best Linear Unbiased Estimates using linear mixed model from <code>nlme</code> package</p></a></li>
<li><a href='#BLUEs.pheno'><p>Best Linear Unbiased Estimates of phenotype</p></a></li>
<li><a href='#check_cofactors'><p>Build a multi-QTL model using step-wise procedure of checking genetic co-factors.</p></a></li>
<li><a href='#convert_mappoly_to_phased.maplist'><p>Function to extract the phased map from a mappoly.map object</p></a></li>
<li><a href='#count_recombinations'><p>Predict recombination breakpoints using IBD probabilities</p></a></li>
<li><a href='#estimate_GIC'><p>Estimate the Genotypic Information Coefficient (GIC)</p></a></li>
<li><a href='#estimate_IBD'><p>Generate IBD probabilities from marker genotypes and a phased linkage map</p></a></li>
<li><a href='#exploreQTL'><p>Explore the possible segregation type of a QTL peak using Schwarz Information Criterion</p></a></li>
<li><a href='#findPeak'><p>Function to find the position of maximum LOD on a particular linkage group</p></a></li>
<li><a href='#findSupport'><p>Function to find a LOD - x support interval around a QTL position</p></a></li>
<li><a href='#GIC_4x'><p>Genotypic Information Coefficient for example tetraploid</p></a></li>
<li><a href='#IBD_4x'><p>Identical by descent probabilities for example tetraploid</p></a></li>
<li><a href='#import_IBD'><p>Import IBD probabilities as estimated by TetraOrigin or PolyOrigin</p></a></li>
<li><a href='#impute_dosages'><p>Re-estimate marker dosages given IBD input estimated using a high error prior.</p></a></li>
<li><a href='#maxL_IBD'><p>Wrapper function to run estimate_IBD function over multiple error priors</p></a></li>
<li><a href='#meiosis_report'><p>Generate a 'report' of predicted meiotic behaviour in an F1 population</p></a></li>
<li><a href='#mr.ls'><p>Example output of meiosis report function</p></a></li>
<li><a href='#phased_maplist.4x'><p>Phased maplist for example tetraploid</p></a></li>
<li><a href='#Phenotypes_4x'><p>Phenotypes for example tetraploid</p></a></li>
<li><a href='#plotQTL'><p>Plot the results of QTL scan.</p></a></li>
<li><a href='#plotRecLS'><p>Plot the recombination landscape across the genome</p></a></li>
<li><a href='#PVE'><p>Function to determine the percentage variance explained (PVE) of a (maximal) QTL model, and explore sub-models.</p></a></li>
<li><a href='#qtl_LODs.4x'><p>QTL output for example tetraploid</p></a></li>
<li><a href='#QTLscan'><p>General QTL function that allows for co-factors, completely randomised block designs and the possibility to derive LOD thresholds using a permutation test</p></a></li>
<li><a href='#Rec_Data_4x'><p>Recombination data for example tetraploid</p></a></li>
<li><a href='#segList_2x'><p>Expected segregation for all markers types of a diploid cross</p></a></li>
<li><a href='#segList_3x'><p>Expected segregation for all markers types of a triploid cross (4 x 2)</p></a></li>
<li><a href='#segList_3x_24'><p>Expected segregation for all markers types of a triploid cross (2 x 4)</p></a></li>
<li><a href='#segList_4x'><p>Expected segregation for all markers types of a tetraploid cross</p></a></li>
<li><a href='#segList_6x'><p>Expected segregation for all markers types of a hexaploid cross</p></a></li>
<li><a href='#segMaker'><p>Create a list of possible QTL segregation types</p></a></li>
<li><a href='#singleMarkerRegression'><p>Run a single marker regression using marker dosages</p></a></li>
<li><a href='#SNP_dosages.4x'><p>SNP marker dosage data for example tetraploid</p></a></li>
<li><a href='#spline_IBD'><p>Fit splines to IBD probabilities</p></a></li>
<li><a href='#thinmap'><p>Thin out map data</p></a></li>
<li><a href='#visualiseGIC'><p>Visualise Genotypic Information Coefficient</p></a></li>
<li><a href='#visualiseHaplo'><p>Visualise haplotypes in certain individuals in a certain region</p></a></li>
<li><a href='#visualisePairing'><p>Visualise pairing of parental homologues</p></a></li>
<li><a href='#visualiseQTLeffects'><p>Visualise QTL homologue effects around a QTL position</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>QTL Analysis in Autopolyploid Bi-Parental F1 Populations</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Bourke &lt;pbourkey@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantitative trait loci (QTL) analysis and exploration of meiotic patterns in 
    autopolyploid bi-parental F1 populations. 
    For all ploidy levels, identity-by-descent (IBD) probabilities can be estimated.
    Significance thresholds, exploring QTL allele effects and visualising results are provided. 
    For more background and to reference the package see &lt;<a href="https://doi.org/10.1093%2Fbioinformatics%2Fbtab574">doi:10.1093/bioinformatics/btab574</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, doParallel, foreach, grDevices, graphics, Hmisc, knitr,
nlme, RColorBrewer, Rcpp (&ge; 0.12.19), reshape2, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph, mappoly (&ge; 0.3.0), polymapR, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 08:02:35 UTC; bourk001</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Bourke [aut, cre],
  Christine Hackett [ctb],
  Chris Maliepaard [ctb],
  Geert van Geest [ctb],
  Roeland Voorrips [ctb],
  Johan Willemsen [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-09 08:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='polyqtlR-package'>QTL analysis in polyploid species using posterior genotype probabilities</h2><span id='topic+polyqtlR'></span><span id='topic+polyqtlR-package'></span>

<h3>Description</h3>

<p>Quantitative trait loci (QTL) analysis and exploration of meiotic patterns in autopolyploid bi-parental F1 populations. For all ploidy levels, identity-by-descent (IBD) probabilities can be estimated. Significance thresholds, exploring QTL allele effects and visualising results are provided. For more background and to reference the package see <a href="https://doi.org/10.1093/bioinformatics/btab574">doi:10.1093/bioinformatics/btab574</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Peter Bourke <a href="mailto:pbourkey@gmail.com">pbourkey@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Christine Hackett [contributor]
</p>
</li>
<li><p> Chris Maliepaard [contributor]
</p>
</li>
<li><p> Geert van Geest [contributor]
</p>
</li>
<li><p> Roeland Voorrips [contributor]
</p>
</li>
<li><p> Johan Willemsen [contributor]
</p>
</li></ul>


<hr>
<h2 id='BLUE'>Calculate Best Linear Unbiased Estimates using linear mixed model from <code>nlme</code> package</h2><span id='topic+BLUE'></span>

<h3>Description</h3>

<p>Calculation of BLUEs from data frame of genotype names and phenotypes (assuming repeated measurements)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLUE(data, model, random, genotype.ID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLUE_+3A_data">data</code></td>
<td>
<p>Data frame of genotype codes and corresponding phenotypes</p>
</td></tr>
<tr><td><code id="BLUE_+3A_model">model</code></td>
<td>
<p>The model specification of fixed terms, eg. Yield ~ Clones</p>
</td></tr>
<tr><td><code id="BLUE_+3A_random">random</code></td>
<td>
<p>The random component of the model (repeat structure, can be nested), eg. ~1 | Blocks if only Blocks are used</p>
</td></tr>
<tr><td><code id="BLUE_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname used to describe genotypes, e.g. &quot;Clones&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data-frame with columns &quot;geno&quot; for the genotype names, and &quot;blue&quot; for the BLUEs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Phenotypes_4x")
blue &lt;- BLUE(data = Phenotypes_4x,model = pheno~geno,random = ~1|year,genotype.ID = "geno")
</code></pre>

<hr>
<h2 id='BLUEs.pheno'>Best Linear Unbiased Estimates of phenotype</h2><span id='topic+BLUEs.pheno'></span>

<h3>Description</h3>

<p>Best Linear Unbiased Estimates of phenotype
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLUEs.pheno
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 50 rows and 2 columns.
</p>

<hr>
<h2 id='check_cofactors'>Build a multi-QTL model using step-wise procedure of checking genetic co-factors.</h2><span id='topic+check_cofactors'></span>

<h3>Description</h3>

<p>The function <code>check_cofactors</code> initially fits all significant QTL positions as co-factors, both individually and in combination. Significance thresholds
are re-estimated each time, yielding threshold-corrected LOD scores. If this leads to a change in the estimated position of QTL, or detection of subsequent peaks, a second 
round of co-factor inclusion is performed for all new QTL or novel QTL combinations. Finally, the multi-QTL model that maximises the individual significance of each
QTL is returned as a data.frame. This can be directly passed to the function <code><a href="#topic+PVE">PVE</a></code> to estimate the percentage variance explained by the full
multi-QTL model and all possible sub-models. 
Note: this function estimates the most likely QTL positions by maximising the threshold-corrected LOD at QTL peaks.
Non-additive interactions between QTL may be missed as a result. It is recommended to run a manual co-factor analysis as well,
as described in the package vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_cofactors(
  IBD_list,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  LOD_data = NULL,
  min_res = 20,
  test_full_model = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_cofactors_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD_probabilities as estimated using one of the various methods available (e.g. <code><a href="#topic+estimate_IBD">estimate_IBD</a></code>).</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the population identifiers (F1 names) (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function. Since v.0.1.0 this argument is optional - function will re-run a <code>QTLscan</code> if not provided. Indeed, it may be desirable
to not specify <code>LOD_data</code> if argument <code>test_full_model</code> is <code>TRUE</code>, as this will first combine the best results using additive-effects or allelic interaction-effects models before
searching for additional QTL.</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_min_res">min_res</code></td>
<td>
<p>The minimum genetic distance (resolution) assumed possible to consider 2 linked QTL (on the same linkage group) as independent. By default a value of 20 cM is used.
This is not to suggest that 20 cM is a realistic resolution in a practical mapping study, but it provides the function with a criterion to consider 2 significant QTL within this distance as one and the same. 
For this purpose, 20 cM seems a reasonable value to use. In practice, closely linked QTL will generally &quot;explain&quot; all the variation at nearby positions, making it unlikely to
be able to disentangle their effects. QTL positions will vary slightly when co-factors are introduced, but again this variation is presumed not to exceed 20 cM either side.</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_test_full_model">test_full_model</code></td>
<td>
<p>By default <code>FALSE</code>, in which case the normal additive-effects model is used in <code><a href="#topic+QTLscan">QTLscan</a></code>. If set to <code>TRUE</code>,
then both the additive and full models are run for each genome-wide scan.</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_verbose">verbose</code></td>
<td>
<p>Logical, by default <code>TRUE</code> - should progress messages be printed to the console?</p>
</td></tr>
<tr><td><code id="check_cofactors_+3A_...">...</code></td>
<td>
<p>Option to pass extra arguments to <code>QTLscan</code>, for example specifying <code>ncores</code> for parallel processing, or changing
the default settings of the permutation test (by default the number of permutations to perform = 1000 and alpha = 0.05). For a full list of options see the documentation of <code><a href="#topic+QTLscan">QTLscan</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with the following columns:
</p>

<dl>
<dt>LG</dt><dd><p>Linkage group identifier</p>
</dd>
<dt>cM</dt><dd><p>CentiMorgan position</p>
</dd>
<dt>deltaLOD</dt><dd><p>The difference between the LOD score at the peak and the significance threshold (always positive, otherwise the QTL would not be significant)</p>
</dd>
<dt>CofactorID</dt><dd><p>An identifier giving the co-factor model used in detecting the QTL (if no co-factors were included then <code>NA</code>). The co-factor model is described
by concatenating all co-factor positions with a '+', so for example 1_10+4_20 would mean a co-factor model with 2 positions included as co-factors, namely 10 cM on linkage
group 1 and 20 cM on linkage group 4.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x","BLUEs.pheno","qtl_LODs.4x")
check_cofactors(IBD_list=IBD_4x,Phenotype.df=BLUEs.pheno,
genotype.ID="Geno",trait.ID="BLUE",LOD_data=qtl_LODs.4x)
</code></pre>

<hr>
<h2 id='convert_mappoly_to_phased.maplist'>Function to extract the phased map from a mappoly.map object</h2><span id='topic+convert_mappoly_to_phased.maplist'></span>

<h3>Description</h3>

<p>Convert MAPpoly.map object into a phased maplist, needed for IBD estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert_mappoly_to_phased.maplist(mappoly_object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_mappoly_to_phased.maplist_+3A_mappoly_object">mappoly_object</code></td>
<td>
<p>An object of class 'mappoly.map', for example output of the function <code>mappoly::est_rf_hmm_sequential</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A phased.maplist, with linkage group names LG1 etc. Each list item is a data.frame with columns marker, position followed
by the phased map, coded in 1 and 0 for presence/absence of SNP (alternative) allele on parental homologues (h) numbered 1:ploidy for parent 1
and ploidy + 1 : 2*ploidy for parent 2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library("mappoly")
phased.maplist &lt;- convert_mappoly_to_phased.maplist(maps.hexafake)

## End(Not run)
</code></pre>

<hr>
<h2 id='count_recombinations'>Predict recombination breakpoints using IBD probabilities</h2><span id='topic+count_recombinations'></span>

<h3>Description</h3>

<p>The function <code>count_recombinations</code> returns a list of all predicted recombination breakpoints. The output can be passed 
using the argument <code>recombination_data</code> to the function <code><a href="#topic+visualiseHaplo">visualiseHaplo</a></code>, where the predicted breakpoints overlay the haplotypes. 
Alternatively, a genome-wide visualisation of the recombination landscape both per linkage group and per individual can be generated using the function <code><a href="#topic+plotRecLS">plotRecLS</a></code>, 
which can be useful in identifying problematic areas of the linkage maps, or problematic individuals in the population. Currently, recombination break-points
are only estimated from bivalents in meiosis; any offspring resulting from a predicted multivalent is excluded from the analysis and will be returned with a <code>NA</code> value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_recombinations(IBD_list, plausible_pairing_prob = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_recombinations_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD_probabilities as estimated using one of the various methods available (e.g. <code><a href="#topic+estimate_IBD">estimate_IBD</a></code>).</p>
</td></tr>
<tr><td><code id="count_recombinations_+3A_plausible_pairing_prob">plausible_pairing_prob</code></td>
<td>
<p>The minimum probability of a pairing configuration needed to analyse an individual's IBD data.
The default setting of 0.3 accommodates scenarios where e.g. two competing plausible pairing scenarios are possible.
In such situations, both pairing configurations (also termed &quot;valencies&quot;) would be expected to have a probability close to 0.5. Both are then considered,
and the output contains the probability of both situations. These can then be used to generate a probabilistic recombination landscape. In some cases,
it may not be possible to discern the pairing in one of the parents due to a lack of recombination (ie. full parental haplotypes were transmitted). In such cases, 
having a lower threshold here will allow more offspring to be analysed without affecting the quality of the predictions. If a more definite 
set of predictions is required, simply increase <code>plausible_pairing_prob</code> to eliminate such uncertainty. These individuals will then be 
returned with a <code>NA</code> value.
In any case, it is always helpful to visualise the output using the function <code><a href="#topic+visualiseHaplo">visualiseHaplo</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list corresponding to each linkage group. Within each LG, a list with 3 items is returned, specifying the <code>plausible_pairing_prob</code>, the <code>map</code> and 
the predicted <code>recombinations</code> in each individual in the mapping population. Per individual, all valencies with a probability greater than
<code>plausible_pairing_prob</code> are returned, specifying both the <code>Valent_probability</code> and the best estimate of the cM position of the
<code>recombination_breakpoints</code> involving pairs of homologues A, B, C etc. (in the order parent 1, parent 2). 
If no recombinations are predicted, a <code>NA</code> value is given instead.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x")
recom.ls &lt;- count_recombinations(IBD_4x)
</code></pre>

<hr>
<h2 id='estimate_GIC'>Estimate the Genotypic Information Coefficient (GIC)</h2><span id='topic+estimate_GIC'></span>

<h3>Description</h3>

<p>Function to estimate the GIC per homologue using IBD probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_GIC(IBD_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_GIC_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list; each list element (per linkage group) contains the following items:
</p>

<dl>
<dt>GIC : </dt><dd><p>Matrix of GIC values estimated from the IBD probabilities</p>
</dd>
<dt>map : </dt><dd><p>Integrated linkage map positions of markers used in IBD calculation</p>
</dd>
<dt>parental_phase : </dt><dd><p>The parental marker phasing, coded in 1 and 0's</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x")
GIC_4x &lt;- estimate_GIC(IBD_list = IBD_4x)
</code></pre>

<hr>
<h2 id='estimate_IBD'>Generate IBD probabilities from marker genotypes and a phased linkage map</h2><span id='topic+estimate_IBD'></span>

<h3>Description</h3>

<p><code>estimate_IBD</code> is a function for creating identity-by-descent (IBD) probabilities. Two computational methods are offered:
by default IBD probabilites are estimated using hidden Markov models, but a heuristic method based on Bourke et al. (2014) is also included.
Basic input data for this function are marker genotypes (either discrete marker dosages (ie scores 0, 1, ..., ploidy representing the number of copies of the marker allele),
or the probabilities of these dosages) and a phased linkage map. Details on each of the methods are included under <code>method</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_IBD(
  input_type = "discrete",
  genotypes,
  phased_maplist,
  method = "hmm",
  remove_markers = NULL,
  ploidy,
  ploidy2 = NULL,
  parent1 = "P1",
  parent2 = "P2",
  individuals = "all",
  log = NULL,
  map_function = "haldane",
  bivalent_decoding = TRUE,
  error = 0.01,
  full_multivalent_hexa = FALSE,
  verbose = FALSE,
  ncores = 1,
  fix_threshold = 0.1,
  factor_dist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_IBD_+3A_input_type">input_type</code></td>
<td>
<p>Can be either one of 'discrete' or 'probabilistic'. For the former (default), <code>dosage_matrix</code> must be supplied,
while for the latter <code>probgeno_df</code> must be supplied. Note that probabilistic genotypes can only be accepted if the <code>method</code> is default ('hmm').</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_genotypes">genotypes</code></td>
<td>
<p>Marker genotypes, either a 2d matrix of integer marker scores or a data.frame of dosage probabilities. 
Details are as follows:
</p>

<dl>
<dt>discrete : </dt><dd>
<p>If <code>input_type</code> is 'discrete', <code>genotypes</code> is a matrix of marker dosage scores with markers in rows and individuals in columns.
Both (marker) rownames and (individual or sample) colnames are needed.
</p>
</dd>
<dt>probabilistic : </dt><dd>
<p>If <code>input_type</code> is 'probabilistic', <code>genotypes</code> is a data frame as read from the scores file produced by function <code>saveMarkerModels</code> of R package 
<code>fitPoly</code>, or alternatively, a data frame containing at least the following columns:
</p>

<dl>
<dt>SampleName : </dt><dd>
<p>Name of the sample (individual)
</p>
</dd>
<dt>MarkerName : </dt><dd>
<p>Name of the marker
</p>
</dd>
<dt>P0 : </dt><dd>
<p>Probabilities of dosage score '0'
</p>
</dd>
<dt>P1, P2... etc. : </dt><dd>
<p>Probabilities of dosage score '1' etc. (up to max offspring dosage, e.g. P4 for tetraploid population)
</p>
</dd>
</dl>

</dd>
</dl>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_phased_maplist">phased_maplist</code></td>
<td>
<p>A list of phased linkage maps, the output of <code>polymapR::create_phased_maplist</code></p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_method">method</code></td>
<td>
<p>The method used to estimate IBD probabilities, either <code>"hmm"</code> or <code>"heur"</code>. By default, the Hidden Markov Model (hmm) method is used.
This uses an approach developed by Zheng et al (2016), and implemented in the 'TetraOrigin' package. However, unlike the original TetraOrigin software, it does not 
re-estimate parental linkage phase, as this is assumed to have been generated during map construction. Alternatively, a heuristic algorithm can be employed (<code>method = "heur"</code>), providing
computational efficiency at higher ploidy levels (hexaploid, octoploid etc.), but at the cost of some accuracy. 
If <code>method = "hmm"</code> is specified, only diploid, triploid, autotetraploid and autohexaploid populations are currently allowed, while <code>method = "heur"</code> 
caters for all possible ploidy levels. Furthermore, the argument <code>bivalent_decoding</code> can only be set to <code>FALSE</code> in the case of 
the 'hmm' method (i.e. allowing for the possibility of multivalent formation and double reduction).</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_remove_markers">remove_markers</code></td>
<td>
<p>Optional vector of marker names to remove from the maps. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_ploidy">ploidy</code></td>
<td>
<p>Integer. Ploidy of the organism.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_ploidy2">ploidy2</code></td>
<td>
<p>Optional integer, by default <code>NULL</code>. Ploidy of parent 2, if different from parent 1.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_parent1">parent1</code></td>
<td>
<p>Identifier of parent 1, by default assumed to be <code>"P1"</code></p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_parent2">parent2</code></td>
<td>
<p>Identifier of parent 2, by default assumed to be <code>"P2"</code></p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_individuals">individuals</code></td>
<td>
<p>By default &quot;all&quot; offspring are included, but otherwise a subset can be selected, using a vector of offspring indexing numbers (1,2, etc.)
according to their order in <code>dosage_matrix</code></p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_map_function">map_function</code></td>
<td>
<p>Mapping function to use when converting map distances to recombination frequencies.
Currently only <code>"haldane"</code> or <code>"kosambi"</code> are allowed.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_bivalent_decoding">bivalent_decoding</code></td>
<td>
<p>Option to consider only bivalent pairing during formation of gametes (ignored for diploid populations, as only bivalents possible there), by default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_error">error</code></td>
<td>
<p>The (prior) probability of errors in the offspring dosages, usually assumed to be small but non-zero</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_full_multivalent_hexa">full_multivalent_hexa</code></td>
<td>
<p>Option to allow multivalent pairing in both parents at the hexaploid level, by default <code>FALSE</code>. Note that if <code>TRUE</code>,
a very large available RAM may be required (&gt;= 32Gb) to process the data.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_verbose">verbose</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should progress messages be written?</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_ncores">ncores</code></td>
<td>
<p>How many CPU cores should be used in the evaluation? By default 1 core is used.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_fix_threshold">fix_threshold</code></td>
<td>
<p>If <code>method = "heur"</code>, the threshold to fix the IBD probabilities while correcting for the sum of probabilities.</p>
</td></tr>
<tr><td><code id="estimate_IBD_+3A_factor_dist">factor_dist</code></td>
<td>
<p>If <code>method = "heur"</code>, the factor by which to increase or decrease the recombination frequencies as calculated from the map distances.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of IBD probabilities, organised by linkage group (as given in the input <code>phased_maplist</code>). Each
list item is itself a list containing the following:
</p>

<dl>
<dt>IBDtype</dt><dd><p>The type of IBD; for this function only &quot;genotypeIBD&quot; are calculated.</p>
</dd>
<dt>IBDarray</dt><dd><p>A 3d array of IBD probabilities, with dimensions marker, genotype-class and F1 individual.</p>
</dd>
<dt>map</dt><dd><p>A 3-column data-frame specifying chromosome, marker and position (in cM)</p>
</dd>
<dt>parental_phase</dt><dd><p>Phasing of the markers in the parents, as given in the input <code>phased_maplist</code></p>
</dd>
<dt>marginal.likelihoods</dt><dd><p>A list of marginal likelihoods of different valencies if method &quot;hmm&quot; was used, otherwise <code>NULL</code></p>
</dd>
<dt>valency</dt><dd><p>The predicted valency that maximised the marginal likelihood, per offspring. For method &quot;heur&quot;, <code>NULL</code></p>
</dd>
<dt>offspring</dt><dd><p>Offspring names</p>
</dd>
<dt>biv_dec</dt><dd><p>Logical, whether bivalent decoding was used in the estimation of the F1 IBD probabilities.</p>
</dd>
<dt>gap</dt><dd><p>The size of the gap (in cM) used when interpolating the IBD probabilities. See function <code><a href="#topic+spline_IBD">spline_IBD</a></code> for details.</p>
</dd>
<dt>genocodes</dt><dd><p>Ordered list of genotype codes used to represent different genotype classes.</p>
</dd>
<dt>pairing</dt><dd><p>log likelihoods of each of the different pairing scenarios considered (can be used e.g. for post-mapping check of preferential pairing)</p>
</dd>
<dt>ploidy</dt><dd><p>ploidy of parent 1</p>
</dd>
<dt>ploidy2</dt><dd><p>ploidy of parent 2</p>
</dd>
<dt>method</dt><dd><p>The method used, either &quot;hmm&quot; (default) or &quot;heur&quot;. See argument <code>method</code></p>
</dd>
<dt>error</dt><dd><p>The error prior used, if method &quot;hmm&quot; was used, otherwise <code>NULL</code></p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p>Durbin R, Eddy S, Krogh A, Mitchison G (1998) Biological sequence analysis: Probabilistic models of proteins and nucleic acids. Cambridge: Cambridge University Press.
</p>
</li>
<li><p>Hackett et al. (2013) Linkage analysis and QTL mapping using SNP dosage data in a tetraploid potato mapping population. PLoS One 8(5): e63939
</p>
</li>
<li><p>Zheng et al. (2016) Probabilistic multilocus haplotype reconstruction in outcrossing tetraploids. Genetics 203: 119-131
</p>
</li>
<li><p>Bourke P.M. (2014) QTL analysis in polyploids: Model testing and power calculations. Wageningen University (MSc thesis)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("phased_maplist.4x", "SNP_dosages.4x")
estimate_IBD(phased_maplist=phased_maplist.4x,genotypes=SNP_dosages.4x,ploidy=4)
</code></pre>

<hr>
<h2 id='exploreQTL'>Explore the possible segregation type of a QTL peak using Schwarz Information Criterion</h2><span id='topic+exploreQTL'></span>

<h3>Description</h3>

<p>Function to explore the possible segregation type at a QTL position using the Schwarz Information Criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exploreQTL(
  IBD_list,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  linkage_group,
  LOD_data,
  cM = NULL,
  QTLconfig = NULL,
  plotBIC = TRUE,
  deltaBIC = 6,
  testAllele_Effects = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exploreQTL_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the population identifiers (F1 names) (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_linkage_group">linkage_group</code></td>
<td>
<p>Numeric identifier of the linkage group being tested, based on the order of <code>IBD_list</code>.
Only a single linkage group is allowed.</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_cm">cM</code></td>
<td>
<p>By default <code>NULL</code>, in which case the position of maximum LOD score is taken as the position of interest. 
Otherwise, the cM position to be explored.</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_qtlconfig">QTLconfig</code></td>
<td>
<p>Nested list of homologue configurations and modes of action of QTL to be explored and compared, the output of <code><a href="#topic+segMaker">segMaker</a></code>.
Note that a default List is available of all possible bi-allelic QTL if none is provided.
Each list element is itself a list with components
</p>

<dl>
<dt>homs : </dt><dd><p> a vector of length at least 1, describing the proposed homologues the functional allele Q is on</p>
</dd>
<dt>mode : </dt><dd><p> Vector of same length as <code>homs</code> with codes &quot;a&quot; for additive and &quot;d&quot; for dominant.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="exploreQTL_+3A_plotbic">plotBIC</code></td>
<td>
<p>Logical, with default <code>TRUE</code> - should the calculated BIC values be plotted?</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_deltabic">deltaBIC</code></td>
<td>
<p>Numeric, by default 6. Configurations within this distance of the minimum BIC are considered plausible.</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_testallele_effects">testAllele_Effects</code></td>
<td>
<p>Logical, with default <code>TRUE</code> - should the effects of the different alleles be tested
using the most likely QTL configuration?</p>
</td></tr>
<tr><td><code id="exploreQTL_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following items:
</p>

<dl>
<dt>linkage_group</dt><dd><p>Linkage group of the QTL peak being explored</p>
</dd>
<dt>cM</dt><dd><p>CentiMorgan position of the locus being explored</p>
</dd>
<dt>BIC</dt><dd><p>Vector of BIC values corresponding to elements of <code>QTLconfig</code> provided for testing</p>
</dd>
<dt>Allele.effects</dt><dd><p>Summary of the means and standard errors of groups with (+)
and without(-) the specified allele combinations for the most likely QTLconfig
if <code>testAllele_Effects</code> = <code>TRUE</code> (<code>NULL</code> otherwise).</p>
</dd>
<dt>genotype.means</dt><dd><p>A one-column matrix of mean phenotype values of offspring classes, with rownames
corresponding to the genotype class. If the probability of certain genotype classes is 0 (e.g. double reduction
classes where no double reduction occurred), then the genotype mean for that class will be <code>NA</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x","BLUEs.pheno","qtl_LODs.4x")
exploreQTL(IBD_list = IBD_4x,
           Phenotype.df = BLUEs.pheno,
           genotype.ID = "Geno",
           trait.ID = "BLUE",
           linkage_group = 1,
           LOD_data = qtl_LODs.4x)
</code></pre>

<hr>
<h2 id='findPeak'>Function to find the position of maximum LOD on a particular linkage group</h2><span id='topic+findPeak'></span>

<h3>Description</h3>

<p>Given QTL output, this function returns the position of maximum LOD for a specified linkage group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findPeak(LOD_data, linkage_group, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findPeak_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function.</p>
</td></tr>
<tr><td><code id="findPeak_+3A_linkage_group">linkage_group</code></td>
<td>
<p>Numeric identifier of the linkage group being tested, based on the order of <code>IBD_list</code>.
Only a single linkage group is allowed.</p>
</td></tr>
<tr><td><code id="findPeak_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be written to standard output? By default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("qtl_LODs.4x")
findPeak(LOD_data=qtl_LODs.4x,linkage_group=1)
</code></pre>

<hr>
<h2 id='findSupport'>Function to find a LOD - x support interval around a QTL position</h2><span id='topic+findSupport'></span>

<h3>Description</h3>

<p>Given QTL output, this function returns the LOD - x support for a specified linkage group, taking the 
maximum LOD position as the desired QTL peak.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findSupport(LOD_data, linkage_group, LOD_support = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findSupport_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function.</p>
</td></tr>
<tr><td><code id="findSupport_+3A_linkage_group">linkage_group</code></td>
<td>
<p>Numeric identifier of the linkage group being tested, based on the order of <code>IBD_list</code>.
Only a single linkage group is allowed.</p>
</td></tr>
<tr><td><code id="findSupport_+3A_lod_support">LOD_support</code></td>
<td>
<p>The level of support around a QTL peak, by default 2 (giving a LOD - 2 support interval, the 
range of positions with a LOD score within 2 LOD units of the maximum LOD on that linkage group).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data("qtl_LODs.4x")
findSupport(LOD_data=qtl_LODs.4x,linkage_group=1)
</code></pre>

<hr>
<h2 id='GIC_4x'>Genotypic Information Coefficient for example tetraploid</h2><span id='topic+GIC_4x'></span>

<h3>Description</h3>

<p>Genotypic Information Coefficient for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GIC_4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='IBD_4x'>Identical by descent probabilities for example tetraploid</h2><span id='topic+IBD_4x'></span>

<h3>Description</h3>

<p>Identical by descent probabilities for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBD_4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='import_IBD'>Import IBD probabilities as estimated by TetraOrigin or PolyOrigin</h2><span id='topic+import_IBD'></span>

<h3>Description</h3>

<p>Imports the IBD probability output of TetraOrigin (Mathematica software) or PolyOrigin (julia software) into the same
format as natively-estimated IBD probabilities from the polyqtlR package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_IBD(
  method,
  folder = NULL,
  filename,
  bivalent_decoding = TRUE,
  error = 0.01,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import_IBD_+3A_method">method</code></td>
<td>
<p>The method used for IBD estimation, either &quot;TO&quot; for TetraOrigin or &quot;PO&quot; for PolyOrigin</p>
</td></tr>
<tr><td><code id="import_IBD_+3A_folder">folder</code></td>
<td>
<p>The path to the folder in which the Tetra/PolyOrigin (ie. TetraOrigin or PolyOrigin) output is contained, 
default is <code>NULL</code> if files are in working directory.</p>
</td></tr>
<tr><td><code id="import_IBD_+3A_filename">filename</code></td>
<td>
<p>If method = &quot;TO&quot;, the (vector of) character filename stem(s) of the <code>.csv</code> file(s) containing the output of TetraOrigin (stem = without &quot;.csv&quot;). 
Should be in order according to LG/chromosome numbering. If method = &quot;PO&quot;, then simply specify the PolyOrigin filename stem here (as the output is not split into separate linkage
groups in PolyOrigin). A PolyOrigin file with name &lt;filename&gt;_polyancestry.csv and its corresponding log file &lt;filename&gt;.log will then be searched for.</p>
</td></tr>
<tr><td><code id="import_IBD_+3A_bivalent_decoding">bivalent_decoding</code></td>
<td>
<p>Logical, if method = &quot;TO&quot; you must specify <code>TRUE</code> if only bivalent pairing was allowed in TetraOrigin (in offspring deciding step),
otherwise specify <code>FALSE</code> if multivalent pairing was also allowed. If method = &quot;PO&quot;, this will be automatically detected, so no need to specify (will be ignored).</p>
</td></tr>
<tr><td><code id="import_IBD_+3A_error">error</code></td>
<td>
<p>If method = &quot;TO&quot;, the offspring error prior used in the offspring decoding step of TetraOrigin, by default assumed to be 0.01. For method = &quot;PO&quot;, this is automatically read in.</p>
</td></tr>
<tr><td><code id="import_IBD_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list with the following items:
</p>
<table>
<tr><td><code>IBDtype :</code></td>
<td>
<p>Always &quot;genotypeIBD&quot; for the output of TetraOrigin</p>
</td></tr>
<tr><td><code>IBDarray :</code></td>
<td>
<p>An array of IBD probabilities. The dimensions of the array are: markers, genotype classes and individuals.</p>
</td></tr>
<tr><td><code>map :</code></td>
<td>
<p>Integrated linkage map positions of markers used in IBD calculation</p>
</td></tr>
<tr><td><code>parental_phase :</code></td>
<td>
<p>The parental marker phasing as used by TetraOrigin, recoded in 1 and 0's</p>
</td></tr>
<tr><td><code>marginal.likelihoods :</code></td>
<td>
<p>A list of marginal likelihoods of different valencies, currently <code>NULL</code></p>
</td></tr>
<tr><td><code>valency :</code></td>
<td>
<p>The predicted valency that maximised the marginal likelihood, per offspring. Currently <code>NULL</code></p>
</td></tr>
<tr><td><code>offspring :</code></td>
<td>
<p>Offspring names</p>
</td></tr>
<tr><td><code>biv_dec :</code></td>
<td>
<p>Logical, the bivalent_decoding parameter specified.</p>
</td></tr>
<tr><td><code>gap :</code></td>
<td>
<p>The gap size used in IBD interpolation if performed by <code><a href="#topic+spline_IBD">spline_IBD</a></code>. At this stage, <code>NULL</code></p>
</td></tr>
<tr><td><code>genocodes :</code></td>
<td>
<p>Ordered list of genotype codes used to represent different genotype classes.</p>
</td></tr>
<tr><td><code>pairing :</code></td>
<td>
<p>log likelihoods of each of the different pairing scenarios considered 
(can be used e.g. for post-mapping check of preferential pairing)</p>
</td></tr>
<tr><td><code>ploidy :</code></td>
<td>
<p>The ploidy of parent 1, by default assumed to be 4</p>
</td></tr>
<tr><td><code>ploidy2 :</code></td>
<td>
<p>The ploidy of parent 2, by default assumed to be 4</p>
</td></tr>
<tr><td><code>method :</code></td>
<td>
<p>The method used, either &quot;hmm_TO&quot; (TetraOrigin) or &quot;hmm_PO&quot; (PolyOrigin)</p>
</td></tr>
<tr><td><code>error :</code></td>
<td>
<p>The error prior used in the calculation in TetraOrigin, assumed to be 0.01</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## These examples demonstrate the function call for both methods, but won't run without input files
## from either package, hence this call will normally result in an Error:
IBD_TO &lt;- import_IBD(method = "TO", filename = paste0("test_LinkageGroup",1:5,"_Summary"),
bivalent_decoding = FALSE, error = 0.05)
## Equivalent call for PolyOrigin output:
IBD_PO &lt;- import_IBD(method = "PO",filename = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='impute_dosages'>Re-estimate marker dosages given IBD input estimated using a high error prior.</h2><span id='topic+impute_dosages'></span>

<h3>Description</h3>

<p>Function to correct marker dosage scores given a list of previously estimated IBD probabilities. This may
prove useful to correct genotyping errors. Running the <code><a href="#topic+estimate_IBD">estimate_IBD</a></code> function with a high error prior will 
result in suppressed predictions of double recombination events, associated with genotyping errors. By forcing the HMM to penalise 
double recombinations heavily, a smoothed haplotype landscape is achieved in which individual genotype observations are down-weighted. 
This smoothed output is then used to re-estimate marker dosages, dependent on (correct) parental scores. 
An alternative strategy is to use the function <code><a href="#topic+maxL_IBD">maxL_IBD</a></code> over a range of error priors first, and use the resulting <code>$maxL_IBD</code> output 
as input here (as the <code>IBD_list</code>). In this case, set the argument <code>min_error_prior</code> to a low value (0.005 say) to avoid issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_dosages(
  IBD_list,
  dosage_matrix,
  parent1 = "P1",
  parent2 = "P2",
  rounding_error = 0.05,
  min_error_prior = 0.1,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_dosages_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns. Note that probabilistic genotypes are not currently catered for here.</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_parent1">parent1</code></td>
<td>
<p>The identifier of parent 1, by default &quot;P1&quot;</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_parent2">parent2</code></td>
<td>
<p>The identifier of parent 2, by default &quot;P2&quot;</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_rounding_error">rounding_error</code></td>
<td>
<p>The maximum deviation from an integer value that an inputed value can have, by default 0.05. For example, an imputed
score of 2.97 or 3.01 would both be rounded to a dosage of 3, while 2.87 would be deemed too far from an integer score, and would be made missing.
If you find the output contains too many missing values, a possibility would be to increase the <code>rounding_error</code>. However this may
also introduce more errors in the output!</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_min_error_prior">min_error_prior</code></td>
<td>
<p>Suggestion for a suitably high error prior to be used in IBD calculations to ensure IBD smoothing is achieved. If IBD probabilities were estimated 
with a smaller error prior, the function aborts.</p>
</td></tr>
<tr><td><code id="impute_dosages_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be written to standard output?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Toy example only, as this will result in an Error: the original error prior was too low
data("IBD_4x","SNP_dosages.4x")
impute_dosages(IBD_list=IBD_4x,dosage_matrix=SNP_dosages.4x)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxL_IBD'>Wrapper function to run estimate_IBD function over multiple error priors</h2><span id='topic+maxL_IBD'></span>

<h3>Description</h3>

<p>Function to run the <code><a href="#topic+estimate_IBD">estimate_IBD</a></code> function over a range of possible error priors. The function returns
a merged set of results that maximise the marginal likelihood per individual, i.e. allowing a per-individual error rate within the options
provided in the errors argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxL_IBD(errors = c(0.01, 0.05, 0.1, 0.2), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxL_IBD_+3A_errors">errors</code></td>
<td>
<p>Vector of offspring error priors to test (each between 0 and 1)</p>
</td></tr>
<tr><td><code id="maxL_IBD_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+estimate_IBD">estimate_IBD</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt>maxL_IBD</dt><dd><p>A nested list as would have been returned by the estimate_IBD function, but composite across error priors to maximise the 
marginal likelihoods. Note that the $error values per linkage group are now the average error prior across the population per linkage group</p>
</dd>
<dt>MML</dt><dd><p>A 3d array of the maximal marginal likelihoods, per error prior. Dimensions are individuals, linkage groups, error priors.</p>
</dd>
<dt>error_per_ind</dt><dd><p>A matrix of the most likely genotyping error rates per individual (in rows) for each linkage group (in columns)</p>
</dd>
<dt>errors</dt><dd><p>The error priors used (i.e. the input vector is returned for later reference.)</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("phased_maplist.4x","SNP_dosages.4x")
maxL_IBD(phased_maplist=phased_maplist.4x,genotypes=SNP_dosages.4x,
ploidy=4,errors=c(0.01,0.02,0.05,0.1))

## End(Not run)
</code></pre>

<hr>
<h2 id='meiosis_report'>Generate a 'report' of predicted meiotic behaviour in an F1 population</h2><span id='topic+meiosis_report'></span>

<h3>Description</h3>

<p>Function to extract the chromosome pairing predictions as estimated by <code><a href="#topic+estimate_IBD">estimate_IBD</a></code>. 
Apart from producing an overview of the pairing during parental meiosis (including counts of multivalents, per linkage group per parent),
the function also applies a simple chi-squared test to look for evidence of non-random pairing behaviour from the bivalent counts (deviations from a polysomic model)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meiosis_report(IBD_list, visualise = FALSE, precision = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meiosis_report_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities as estimated by <code><a href="#topic+estimate_IBD">estimate_IBD</a></code> using method 'hmm', or externally (e.g. using TetraOrigin)</p>
</td></tr>
<tr><td><code id="meiosis_report_+3A_visualise">visualise</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, a plot of the pairing results is produced per LG. In order to 
flag extreme deviations from the expected numbers (associated with polysomic inheritance, considered the Null hypothesis),
barplots are coloured according to the level of significance of the X2 test. Plots showing red bars indicate extreme deviations from
a polysomic pattern.</p>
</td></tr>
<tr><td><code id="meiosis_report_+3A_precision">precision</code></td>
<td>
<p>To how many decimal places should summed probabilities per bivalent pairing be rounded? By default 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a nested list, with one element per linkage group in the same order as the input IBD list.
Per linkage group, a list is returned containing the following components:
</p>

<dl>
<dt>P1_multivalents</dt><dd><p>The count of multivalents in parent 1 (only relevant if <code>bivalent_decoding = FALSE</code> during IBD calculation)</p>
</dd>
<dt>P2_multivalents</dt><dd><p>Similarly, the count of multivalents in parent 2</p>
</dd>
<dt>P1_pairing</dt><dd><p>The counts of each bivalent pairing predicted in parent 1, with an extra column Pr(X2) which gives the p-value of 
the X2 test of the off-diagonal terms in the matrix. In the case of a tetraploid, pairing A with B automatically implies C with D pairing,
so the count table contains a lot of redundancy. The table should be read using both row and column names, so row A and column B corresponds
to the count of individuals with A and B pairing (and hence C and D pairing). In a hexaploid, A-B pairing does not imply a particular pairing
configuration in the remaining homologues. In this case, row A and column B is the count of individuals where A and B were predicted to have paired,
summed over all three bivalent configurations with A and B paired (AB-CD-EF, AB-CE-DF, AB-CF,DE).</p>
</dd>
<dt>P2_pairing</dt><dd><p>Same as P1_pairing, except using parent 2</p>
</dd>
<dt>ploidy</dt><dd><p>The ploidy of parent 1</p>
</dd>
<dt>ploidy2</dt><dd><p>The ploidy of parent 2</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x")
mr.ls&lt;-meiosis_report(IBD_list = IBD_4x)
</code></pre>

<hr>
<h2 id='mr.ls'>Example output of meiosis report function</h2><span id='topic+mr.ls'></span>

<h3>Description</h3>

<p>Example output of meiosis report function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mr.ls
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='phased_maplist.4x'>Phased maplist for example tetraploid</h2><span id='topic+phased_maplist.4x'></span>

<h3>Description</h3>

<p>Phased maplist for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phased_maplist.4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='Phenotypes_4x'>Phenotypes for example tetraploid</h2><span id='topic+Phenotypes_4x'></span>

<h3>Description</h3>

<p>Phenotypes for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Phenotypes_4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 150 rows and 3 columns.
</p>

<hr>
<h2 id='plotQTL'>Plot the results of QTL scan.</h2><span id='topic+plotQTL'></span><span id='topic+plotLinearQTL'></span><span id='topic+plotLinearQTL_list'></span>

<h3>Description</h3>

<p>Up to package v.0.0.9, there were three plotting functions for the output of <code>QTLscan</code>, namely <code>plotQTL</code>, <code>plotLinearQTL</code> and <code>plotLinearQTL_list</code>.
Since release 0.1.0, the functionality of all three functions has been combined into a single general plotting function, named <code>plotQTL</code>.
The plot layout is now specified by a new argument <code>layout</code>, allowing the user to plot results for single chromosomes separately, or together either adjacently or in a grid layout.
Results from multiple analyses can be overlaid. Previously, it was possible to call the function <code>plotQTL</code> multiple times and overlay subsequent plots using the argument <code>overlay = TRUE</code>.
This approach is no longer supported. Instead, if multiple results are to be overlaid, they can be provided as a list of <code>QTLscan</code> or <code>singleMarkerRegression</code> outputs. Note however that this
is only possible using the default layout. If significance thresholds are
present, the default behaviour is to rescale LOD values so that multiple plots can be combined with overlapping signficance thresholds. This rescaling behaviour can also be
disabled (by setting <code>rescale = FALSE</code>). Note that not all arguments may be appropriate for all layouts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQTL(
  LOD_data,
  layout = "l",
  inter_chm_gap = 5,
  ylimits = NULL,
  sig.unit = "LOD",
  plot_type = "lines",
  colour = c("black", "red", "dodgerblue", "sienna4"),
  add_xaxis = TRUE,
  add_rug = TRUE,
  add_thresh = TRUE,
  override_thresh = NULL,
  thresh.lty = 3,
  thresh.lwd = 2,
  thresh.col = "darkred",
  return_plotData = FALSE,
  show_thresh_CI = FALSE,
  use_LG_names = TRUE,
  axis_label.cex = 1,
  custom_LG_names = NULL,
  LGdiv.col = "gray42",
  ylab.at = 2.5,
  highlight_positions = NULL,
  mainTitle = FALSE,
  rescale = TRUE,
  ...
)

plotLinearQTL(
  LOD_data,
  layout = "l",
  inter_chm_gap = 5,
  ylimits = NULL,
  sig.unit = "LOD",
  plot_type = "lines",
  colour = c("black", "red", "dodgerblue", "sienna4"),
  add_xaxis = TRUE,
  add_rug = TRUE,
  add_thresh = TRUE,
  override_thresh = NULL,
  thresh.lty = 3,
  thresh.lwd = 2,
  thresh.col = "darkred",
  return_plotData = FALSE,
  show_thresh_CI = FALSE,
  use_LG_names = TRUE,
  axis_label.cex = 1,
  custom_LG_names = NULL,
  LGdiv.col = "gray42",
  ylab.at = 2.5,
  highlight_positions = NULL,
  mainTitle = FALSE,
  rescale = TRUE,
  ...
)

plotLinearQTL_list(
  LOD_data,
  layout = "l",
  inter_chm_gap = 5,
  ylimits = NULL,
  sig.unit = "LOD",
  plot_type = "lines",
  colour = c("black", "red", "dodgerblue", "sienna4"),
  add_xaxis = TRUE,
  add_rug = TRUE,
  add_thresh = TRUE,
  override_thresh = NULL,
  thresh.lty = 3,
  thresh.lwd = 2,
  thresh.col = "darkred",
  return_plotData = FALSE,
  show_thresh_CI = FALSE,
  use_LG_names = TRUE,
  axis_label.cex = 1,
  custom_LG_names = NULL,
  LGdiv.col = "gray42",
  ylab.at = 2.5,
  highlight_positions = NULL,
  mainTitle = FALSE,
  rescale = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQTL_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function. If you wish to overlay multiple genome-wide <code>QTLscan</code> outputs, then first compile these into a single list and 
pass this to <code>LOD_data</code>, for example <code>LOD_data = list(qtl_res1, qtl_res2)</code>. If this is passed as a named list and <code>add_legend = TRUE</code>, these names will be used
in the legend as well.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_layout">layout</code></td>
<td>
<p>There are three possible plot layouts - single chromosome plots (&quot;s&quot;), genome-wide plots arranged adjacently in a linear fashion (&quot;l&quot;) which is
also the default, and genome-wide plots arranged in a grid (&quot;g&quot;), i.e. a grid of single chromosome plots. In the latter case, a suitable grid dimension will be determined
based on the number of linkage groups detected in <code>LOD_data</code>. If you wish to overlay results from multiple multi-chromosome analyses, use the default layout.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_inter_chm_gap">inter_chm_gap</code></td>
<td>
<p>The gap size (in units of cM) between successive chromosomes when <code>layout = "l"</code>. By default a gap of 5 cM is used. Normally the user should not need to change this.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_ylimits">ylimits</code></td>
<td>
<p>Use to specify ylimits of plot region, though by default <code>NULL</code> in which case a suitable plot region is automatically used.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_sig.unit">sig.unit</code></td>
<td>
<p>Label to use on the y-axis for significance units, by default assumed to be LOD score.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_plot_type">plot_type</code></td>
<td>
<p>Plots can be either in line drawings (&quot;lines&quot;, default) or scatter plot format (&quot;points&quot;).</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_colour">colour</code></td>
<td>
<p>Vector of colours to be used in the plotting. A default set of 4 colours is provided, the first of which is used when results from a single QTL scan are to be plotted.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_add_xaxis">add_xaxis</code></td>
<td>
<p>Should an x-axis be drawn? If multiple QTL analyses are performed on different traits, specifying this to be <code>FALSE</code>
and using <code>par(mar=c(0,4.1,4.1,2.1))</code> allows subsequent plots to be neatly stacked.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_add_rug">add_rug</code></td>
<td>
<p>Logical, by default <code>TRUE</code> - should original marker points be added to plot?</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_add_thresh">add_thresh</code></td>
<td>
<p>Logical, by default <code>TRUE</code> - should a significance threshold be added to plot?</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_override_thresh">override_thresh</code></td>
<td>
<p>By default <code>NULL</code>. Can be used to specify a (numeric) value for the significance threshold, overriding any stored in <code>LOD_data</code>. If you wish to override
thresholds for multiple analyses (so, when <code>LOD_data</code> is a list of QTL outputs), can also provide a vector of numeric values here.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_thresh.lty">thresh.lty</code></td>
<td>
<p>Gives user control over the line type of the significance threshold to be drawn. Default threshold lty is 3.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_thresh.lwd">thresh.lwd</code></td>
<td>
<p>Gives user control over the line width of the significance threshold to be drawn. Default threshold lwd is 2.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_thresh.col">thresh.col</code></td>
<td>
<p>Gives user control over the line colour of the significance threshold to be drawn. Default threshold colour is dark red. If plotting multiple analyses with <code>rescale = FALSE</code>,
it can be useful to provide the same colours to this argument as to <code>colour</code>, so that LOD profiles can be linked to their respective LOD thresholds.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_return_plotdata">return_plotData</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, then the x and y coordinates of the plot data are returned when <code>layout = "l"</code>,
which can be useful for subsequent plot manipulations and overlays. For other layouts, no plot data is returned.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_show_thresh_ci">show_thresh_CI</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. Should confidence interval bounds around LOD threshold be shown if available? If <code>LOD_data</code> is a list from multiple analyses,
this option is ignored to prevent plot becoming too cluttered.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_use_lg_names">use_LG_names</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should original character LG names (the names of list <code>LOD_data</code>) be used as axis labels? If <code>FALSE</code>, numbering is used instead.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_axis_label.cex">axis_label.cex</code></td>
<td>
<p>Argument to adjust the size of the axis labels. Can be useful if there are many linkage groups to plot</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_custom_lg_names">custom_LG_names</code></td>
<td>
<p>Option to specify a vector that contains custom linkage group names. By default <code>NULL</code>. See previous argument <code>use_LG_names</code>, which is the usual manner
for controlling x-axis labels.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_lgdiv.col">LGdiv.col</code></td>
<td>
<p>Colour of dividing lines between linkage groups when <code>layout = "l"</code>, by default grey.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_ylab.at">ylab.at</code></td>
<td>
<p>Distance from the y-axis to place label (by default at 2.5 points)</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_highlight_positions">highlight_positions</code></td>
<td>
<p>Option to include a (list of) positions to highlight (e.g. peak QTL positions). Each list element should be a 2-column data.frame with columns giving
the linkage group numbers (numeric) and the corresponding cM positions (numeric) to highlight. If <code>LOD_data</code> is the result of a single genome-wide scan, it is also possible to just directly provide the
2-column data.frame (again, with column 1 containing linkage group numbers and column 2 containing corresponding cM positions).
If <code>LOD_data</code> has been provided as a list of multiple analyses, you may wish to highlight different positions from each analysis. Then <code>highlight_positions</code> should also be a list 
of the same length and in the same order as <code>LOD_data</code>. Each data.frame of positions will be coloured in the same colour as the LOD output.
If no position is to be highlighted for some analyses, add the corresponding list element as <code>NULL</code>. For example, if you wish to highlight positions for analyses 1 and 3 in a 3-analysis overlay, 
then use something like <code>highlight_positions = list(data.frame(lg = 1, cM = 50),NULL,data.frame(lg=c(2,3),cM=c(11,99)))</code>.
The default setting is <code>NULL</code>, meaning no positions are highlighted.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_maintitle">mainTitle</code></td>
<td>
<p>Option to supply vector of plot titles if <code>layout = "s"</code> or <code>layout = "g"</code>. Argument ignored if using the default layout. Single character vector also allowed and will be recycled.
For no plot titles, leave as default, i.e. <code>FALSE</code></p>
</td></tr>
<tr><td><code id="plotQTL_+3A_rescale">rescale</code></td>
<td>
<p>If results from multiple analyses are to be overlaid and different significance thresholds are detected, then by default plots will be rescaled so that threshold lines overlap.
This behaviour can be disabled by setting <code>rescale = FALSE</code>.</p>
</td></tr>
<tr><td><code id="plotQTL_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+plot">plot</a></code>, and <code><a href="graphics.html#topic+lines">lines</a></code> or <code><a href="graphics.html#topic+points">points</a></code> as appropriate (see argument <code>plot_type</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The plot data, if return_plotData = TRUE. Otherwise <code>NULL</code>. Output is returned invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data("qtl_LODs.4x")
plotQTL(LOD_data = qtl_LODs.4x,layout = "l")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotRecLS'>Plot the recombination landscape across the genome</h2><span id='topic+plotRecLS'></span>

<h3>Description</h3>

<p>Function which visualises the recombination landscape in two ways: per linkage group, and per individual. 
For the first analysis, a rudimentary spline is also fitted to estimate the recombination rate along a grid of positions defined by <code>gap</code>,
which is also returned by the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotRecLS(
  recombination_data,
  plot_per_LG = TRUE,
  plot_per_ind = TRUE,
  gap = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotRecLS_+3A_recombination_data">recombination_data</code></td>
<td>
<p>Data on predicted recombination events, as returned by the function <code><a href="#topic+count_recombinations">count_recombinations</a></code></p>
</td></tr>
<tr><td><code id="plotRecLS_+3A_plot_per_lg">plot_per_LG</code></td>
<td>
<p>Logical argument, plot recombination events per linkage group? By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotRecLS_+3A_plot_per_ind">plot_per_ind</code></td>
<td>
<p>Logical argument, plot recombination events per individual? By default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotRecLS_+3A_gap">gap</code></td>
<td>
<p>The size (in cM) of the gap used to define the grid of positions to define the window in which to estimate 
recombination rate. By default 1 cM. Interpolated positions are taken to be the centre of an interval, so a 1 cM gap would
result in predictions for positions 0.5 cM, 1.5 cM etc.</p>
</td></tr>
<tr><td><code id="plotRecLS_+3A_...">...</code></td>
<td>
<p>Option to pass extra arguments to the <code><a href="base.html#topic+plot">plot</a></code> function for the per_LG plots. This may lead
to conflicts with arguments already declared internally (such as <code>main</code> for example).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements, <code>per_LG</code> and <code>per_individual</code>. The first of these is itself a list with the same length as <code>recombination_data</code>, giving the estimated recombination rates along the linkage group.
This rate is simply estimated as the (weighted) count of recombination breakpoints divided by the population size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Rec_Data_4x")
plotRecLS(Rec_Data_4x)
</code></pre>

<hr>
<h2 id='PVE'>Function to determine the percentage variance explained (PVE) of a (maximal) QTL model, and explore sub-models.</h2><span id='topic+PVE'></span>

<h3>Description</h3>

<p>This function builds a (maximal) QTL model from previously detected QTL peaks and outputs the percentage variance explained (PVE)
of the full QTL model and all sub-models. It uses a similar approach to the fitting of genetic co-factors in the function <code><a href="#topic+QTLscan">QTLscan</a></code>.
The PVE is very similar to but not exactly equal to the adjusted R2 returned in <code>QTLscan</code> at each position (and note: in the former case, these
R2 values are per-locus, while this function can estimate the PVE combined over multiple loci). The discrepancy has to do with how PVE is calculated 
using the formula 100(1 - RSS0/RSS1), where RSS0 and RSS1 are the residual sums of squares of the NULL and QTL models, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PVE(
  IBD_list,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  block = NULL,
  QTL_df = NULL,
  prop_Pheno_rep = 0.5,
  log = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PVE_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="PVE_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="PVE_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the offspring identifiers (F1 names)</p>
</td></tr>
<tr><td><code id="PVE_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model</p>
</td></tr>
<tr><td><code id="PVE_+3A_block">block</code></td>
<td>
<p>The blocking factor to be used, if any (must be colname of <code>Phenotype.df</code>). By default <code>NULL</code>, in 
which case no blocking structure (for unreplicated experiments)</p>
</td></tr>
<tr><td><code id="PVE_+3A_qtl_df">QTL_df</code></td>
<td>
<p>A 2-column data frame of previously-detected QTL; column 1 gives linkage group identifiers, 
column 2 specifies the cM position of the QTL. If not specified, an error results. It can be convenient to generate a compatible
data.frame by first running the function <code><a href="#topic+check_cofactors">check_cofactors</a></code> to build a multi-QTL model.</p>
</td></tr>
<tr><td><code id="PVE_+3A_prop_pheno_rep">prop_Pheno_rep</code></td>
<td>
<p>The minimum proportion of phenotypes represented across blocks. If less than this, the individual is 
removed from the analysis. If there is incomplete data, the missing phenotypes are imputed using the mean values across the recorded observations.</p>
</td></tr>
<tr><td><code id="PVE_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
<tr><td><code id="PVE_+3A_verbose">verbose</code></td>
<td>
<p>Should messages be written to standard output?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with percentage variance explained of maximal QTL model and all sub-models
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x","Phenotypes_4x")
PVE(IBD_list = IBD_4x,
    Phenotype.df = Phenotypes_4x,
    genotype.ID = "geno",trait.ID = "pheno",
    block = "year",
    QTL_df = data.frame(LG=1,cM=12.3))
</code></pre>

<hr>
<h2 id='qtl_LODs.4x'>QTL output for example tetraploid</h2><span id='topic+qtl_LODs.4x'></span>

<h3>Description</h3>

<p>QTL output for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qtl_LODs.4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 6.
</p>

<hr>
<h2 id='QTLscan'>General QTL function that allows for co-factors, completely randomised block designs and the possibility to derive LOD thresholds using a permutation test</h2><span id='topic+QTLscan'></span>

<h3>Description</h3>

<p>Function to run QTL analysis using IBD probabilties given (possibly replicated) phenotypes, assuming randomised experimental design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QTLscan(
  IBD_list,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  block = NULL,
  cofactor_df = NULL,
  allelic_interaction = FALSE,
  folder = NULL,
  filename.short,
  prop_Pheno_rep = 0.5,
  perm_test = FALSE,
  N_perm.max = 1000,
  alpha = 0.05,
  gamma = 0.05,
  ncores = 1,
  log = NULL,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QTLscan_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the offspring identifiers (F1 names)</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_block">block</code></td>
<td>
<p>The blocking factor to be used, if any (must be colname of <code>Phenotype.df</code>). By default <code>NULL</code>, in which case no blocking structure (for unreplicated experiments)</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_cofactor_df">cofactor_df</code></td>
<td>
<p>A 3-column data frame of co-factor(s); column 1 gives the numeric linkage group identifier(s), 
column 2 specifies the cM position of the co-factor(s), column 3 specifies whether the QTL was fitted using &quot;a&quot; = additive effects or 
&quot;f&quot; = full allelic interactions (note that any other symbol for the full model will also be accepted, as long as it is not &quot;a&quot;). 
For backward compatibility with package versions &lt;= 0.0.9, it is possible to just supply the first two columns, 
in which case an additive-effects model is assumed for each cofactor (so, a third column will be automatically filled with &quot;a&quot;). 
By default <code>cofactor_df = NULL</code>, in which case no co-factors are included in the analysis.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_allelic_interaction">allelic_interaction</code></td>
<td>
<p>The QTL detection model can be for additive main effects only (by default <code>allelic_interaction = FALSE</code>). If <code>TRUE</code>, then the full model is used
(i.e. all possible genotype combinations are included as predictors in the model). This runs the risk of overfitting, especially if double reduction was also allowed. 
Both types of analyses can ideally be performed and compared. Note that if IBD probabilities were estimated using the &quot;heuristic&quot; method rather than the HMM method 
(see <code><a href="#topic+estimate_IBD">estimate_IBD</a></code>), then IBDs are actually haplotype probabilities rather than genotype probabilities, meaning that allelic interaction effects cannot be included in the model.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_folder">folder</code></td>
<td>
<p>If markers are to be used as co-factors, the path to the folder in which the imported IBD probabilities is contained can be provided here. 
By default this is <code>NULL</code>, if files are in working directory.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_filename.short">filename.short</code></td>
<td>
<p>If TetraOrigin was used and co-factors are being included, the shortened stem of the filename of the <code>.csv</code> files containing the output of TetraOrigin, 
i.e. without the tail &quot;_LinkageGroupX_Summary.csv&quot; which is added by default to all output of TetraOrigin.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_prop_pheno_rep">prop_Pheno_rep</code></td>
<td>
<p>The minimum proportion of phenotypes represented across blocks. If less than this, the individual is removed from the analysis. If there is incomplete
data, the missing phenotypes are imputed using the mean values across the recorded observations.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_perm_test">perm_test</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, a permutation test will be performed to determine a
genome-wide significance threshold.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_n_perm.max">N_perm.max</code></td>
<td>
<p>The maximum number of permutations to run if <code>perm_test</code> is <code>TRUE</code>; by default this is 1000.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_alpha">alpha</code></td>
<td>
<p>The P-value to be used in the selection of a threshold if <code>perm_test</code> is <code>TRUE</code>, by default 0.05 (i.e. the 0.95 quantile).</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_gamma">gamma</code></td>
<td>
<p>The width of the confidence intervals used around the permutation test threshold using the approach of Nettleton &amp; Doerge (2000), by default 0.05.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if parallel computing is required. Works both for Windows and UNIX (using <code>doParallel</code>).
Use <code>parallel::detectCores()</code> to find out how many cores you have available.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_verbose">verbose</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should messages be printed during running?</p>
</td></tr>
<tr><td><code id="QTLscan_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list; each list element (per linkage group) contains the following items:
</p>

<dl>
<dt>QTL.res</dt><dd><p>Single matrix of QTL results with columns chromosome, position, LOD, adj.r.squared and PVE (percentage variance explained).</p>
</dd>
<dt>Perm.res</dt><dd><p>If <code>perm_test</code> = <code>FALSE</code>, this will be <code>NULL</code>.
Otherwise, Perm.res contains a list of the results of the permutation test, with list items
&quot;quantile&quot;,&quot;threshold&quot; and &quot;scores&quot;. Quantile refers to which quantile of scores was used to determine the threshold.
Note that scores are each of the maximal LOD scores across the entire genome scan per permutation, thus returning a
genome-wide threshold rather than a chromosome-specific threshold. If the latter is preferred, restricting the
<code>IBD_list</code> to a single chromosome and re-running the permutation test will provide the desired threshold.</p>
</dd>
<dt>Residuals</dt><dd><p>If a blocking factor or co-factors are used, this is the (named) vector of residuals used as input for the
QTL scan. Otherwise, this is the set of (raw) phenotypes used in the QTL scan.</p>
</dd>
<dt>Map</dt><dd><p>Original map of genetic marker positions upon which the IBDs were based, most often used
for adding rug of marker positions to QTL plots.</p>
</dd>
<dt>LG_names</dt><dd><p>Names of the linkage groups</p>
</dd>
<dt>allelic_interaction</dt><dd><p>Whether argument <code>allelic_interaction</code> was <code>TRUE</code> or <code>FALSE</code> in the QTL scan</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x","Phenotypes_4x")
qtl_LODs.4x &lt;- QTLscan(IBD_list = IBD_4x,
                       Phenotype.df = Phenotypes_4x,
                       genotype.ID = "geno",
                       trait.ID = "pheno",
                       block = "year")
</code></pre>

<hr>
<h2 id='Rec_Data_4x'>Recombination data for example tetraploid</h2><span id='topic+Rec_Data_4x'></span>

<h3>Description</h3>

<p>Recombination data for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rec_Data_4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 2.
</p>

<hr>
<h2 id='segList_2x'>Expected segregation for all markers types of a diploid cross</h2><span id='topic+segList_2x'></span>

<h3>Description</h3>

<p>Expected segregation for all markers types of a diploid cross
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segList_2x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 8.
</p>

<hr>
<h2 id='segList_3x'>Expected segregation for all markers types of a triploid cross (4 x 2)</h2><span id='topic+segList_3x'></span>

<h3>Description</h3>

<p>Expected segregation for all markers types of a triploid cross (4 x 2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segList_3x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 27.
</p>

<hr>
<h2 id='segList_3x_24'>Expected segregation for all markers types of a triploid cross (2 x 4)</h2><span id='topic+segList_3x_24'></span>

<h3>Description</h3>

<p>Expected segregation for all markers types of a triploid cross (2 x 4)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segList_3x_24
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 27.
</p>

<hr>
<h2 id='segList_4x'>Expected segregation for all markers types of a tetraploid cross</h2><span id='topic+segList_4x'></span>

<h3>Description</h3>

<p>Expected segregation for all markers types of a tetraploid cross
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segList_4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 224.
</p>

<hr>
<h2 id='segList_6x'>Expected segregation for all markers types of a hexaploid cross</h2><span id='topic+segList_6x'></span>

<h3>Description</h3>

<p>Expected segregation for all markers types of a hexaploid cross
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segList_6x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3735.
</p>

<hr>
<h2 id='segMaker'>Create a list of possible QTL segregation types</h2><span id='topic+segMaker'></span>

<h3>Description</h3>

<p>Function to generate list of segregation types for the <code><a href="#topic+exploreQTL">exploreQTL</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segMaker(ploidy, segtypes, modes = c("a", "d"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="segMaker_+3A_ploidy">ploidy</code></td>
<td>
<p>The ploidy of the population. Currently assumed to be an even number for this function.</p>
</td></tr>
<tr><td><code id="segMaker_+3A_segtypes">segtypes</code></td>
<td>
<p>List of QTL segregation types to consider,
so e.g. c(1,0) would mean all possible simplex x nulliplex QTL (ie. 4 QTL, on each of homologues 1 - 4 of parent 1).
Note that symmetrical QTL types that cannot be distinguished are not automatically removed and need to be manually identified.
If this is an issue, use the inbuilt list for tetraploids provided with the package to search the full model space.
Such an inbuilt list is currently only available for tetraploids, and is available from the <code><a href="#topic+exploreQTL">exploreQTL</a></code> function.</p>
</td></tr>
<tr><td><code id="segMaker_+3A_modes">modes</code></td>
<td>
<p>Character vector of modes of QTL action to consider, with options &quot;a&quot; for &quot;additive&quot; and &quot;d&quot; for dominant QTL action.</p>
</td></tr>
</table>

<hr>
<h2 id='singleMarkerRegression'>Run a single marker regression using marker dosages</h2><span id='topic+singleMarkerRegression'></span>

<h3>Description</h3>

<p>Function to run a single marker regression using marker dosages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleMarkerRegression(
  dosage_matrix,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  maplist = NULL,
  perm_test = FALSE,
  N_perm = 1000,
  alpha = 0.05,
  ncores = 1,
  return_R2 = FALSE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="singleMarkerRegression_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.
All markers in this matrix will be tested for association with the trait.</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the population identifiers (F1 names) (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_maplist">maplist</code></td>
<td>
<p>Option to include linkage map in the format returned by <code>MDSMap_from_list</code> from <code>polymapR</code>. If maplist is
not specified (by default <code>NULL</code>) then no ordering of markers from dosage-matrix is performed. Note that all markers in dosage_matrix are tested;
markers with dosages that were not on the maplist will be assigned unordered to linkage group 0 with dummy cM positions 1,2,3 etc.</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_perm_test">perm_test</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, a permutation test will be performed to determine a
genome-wide significance threshold.</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_n_perm">N_perm</code></td>
<td>
<p>Integer. The number of permutations to run if <code>perm_test</code> is <code>TRUE</code>; by default this is 1000.</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_alpha">alpha</code></td>
<td>
<p>Numeric. The P-value to be used in the selection of a threshold if <code>perm_test</code> is <code>TRUE</code>;
by default 0.05 (i.e. the 0.95 quantile).</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use if parallel processing required. Works both for Windows and UNIX (using <code>doParallel</code>).
Use <code>parallel::detectCores()</code> to find out how many cores you have available.</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_return_r2">return_R2</code></td>
<td>
<p>Should the (adjusted) R2 of the model fit also be determined?</p>
</td></tr>
<tr><td><code id="singleMarkerRegression_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<dl>
<dt>QTL.res</dt><dd><p> The -log(p) of the model fit per marker are returned as &quot;LOD&quot; scores, although &quot;LOP&quot; would have been a better description.
If requested, R2 values are also returned in column &quot;R2adj&quot;</p>
</dd>
<dt>Perm.res</dt><dd><p> The results of the permutation test if performed, otherwise <code>NULL</code></p>
</dd>
<dt>Map</dt><dd><p> The linkage map if provided, otherwise <code>NULL</code></p>
</dd>
<dt>LG_names</dt><dd><p>Names of the linkage groups, if a map was provided, otherwise <code>NULL</code></p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("SNP_dosages.4x","BLUEs.pheno")
Trait_1.smr &lt;- singleMarkerRegression(dosage_matrix = SNP_dosages.4x,
Phenotype.df = BLUEs.pheno,genotype.ID = "Geno",trait.ID = "BLUE")
</code></pre>

<hr>
<h2 id='SNP_dosages.4x'>SNP marker dosage data for example tetraploid</h2><span id='topic+SNP_dosages.4x'></span>

<h3>Description</h3>

<p>SNP marker dosage data for example tetraploid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SNP_dosages.4x
</code></pre>


<h3>Format</h3>

<p>An object of class <code>matrix</code> (inherits from <code>array</code>) with 186 rows and 52 columns.
</p>

<hr>
<h2 id='spline_IBD'>Fit splines to IBD probabilities</h2><span id='topic+spline_IBD'></span>

<h3>Description</h3>

<p>Fits splines to IBD probabilities at a grid of positions at user-defined spacing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline_IBD(IBD_list, gap, method = "cubic", ncores = 1, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline_IBD_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="spline_IBD_+3A_gap">gap</code></td>
<td>
<p>The size (in centiMorgans) of the gap between splined positions</p>
</td></tr>
<tr><td><code id="spline_IBD_+3A_method">method</code></td>
<td>
<p>One of two options, either &quot;linear&quot; or &quot;cubic&quot;. The default method (cubic) fits cubic splines, and although more accurate,
becomes computationally expensive in higher-density data-sets, where the linear option may be preferable.</p>
</td></tr>
<tr><td><code id="spline_IBD_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores to use, by default 1 only. Works both for Windows and UNIX (using <code>doParallel</code>).
Use <code>parallel::detectCores()</code> to find out how many cores you have available. Note that with large datasets, using multiple cores
will use large amounts of memory (RAM). Single-core or e.g. 2-core evaluations, although slower, is less memory-intensive.</p>
</td></tr>
<tr><td><code id="spline_IBD_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of similar format as IBD_list, with a splined <code>IBD_array</code> in place of the original <code>IBD_array</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x")
IBD_4x.spl &lt;- spline_IBD(IBD_list = IBD_4x, gap = 1)
</code></pre>

<hr>
<h2 id='thinmap'>Thin out map data</h2><span id='topic+thinmap'></span>

<h3>Description</h3>

<p><code>thinmap</code> is a function for thinning out an integrated map, in order that IBD estimation runs more quickly. Especially
useful for maps with very high marker densities for which the <code><a href="#topic+estimate_IBD">estimate_IBD</a></code> function is to be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thinmap(
  maplist,
  dosage_matrix,
  bin_size = 1,
  bounds = NULL,
  remove_markers = NULL,
  plot_maps = TRUE,
  use_SN_phase = FALSE,
  parent1 = "P1",
  parent2 = "P2",
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thinmap_+3A_maplist">maplist</code></td>
<td>
<p>A list of maps. In the first column marker names and in the second their position.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_dosage_matrix">dosage_matrix</code></td>
<td>
<p>An integer matrix with markers in rows and individuals in columns.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_bin_size">bin_size</code></td>
<td>
<p>Numeric. Size (in cM) of the bins to include. By default, a bin size of 1 cM is used. Larger <code>bin_size</code> results in 
fewer markers being left on the resulting map.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_bounds">bounds</code></td>
<td>
<p>Numeric vector. If <code>NULL</code> (by default) then all positions are included, however if specified then output
is limited to a specific region, which may be useful if fine-mapping a region of interest.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_remove_markers">remove_markers</code></td>
<td>
<p>Optional vector of marker names to remove from the maps. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_plot_maps">plot_maps</code></td>
<td>
<p>Logical. Plot the marker positions of the selected markers using <code>polymapR::plot_map</code>.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_use_sn_phase">use_SN_phase</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, then 1x0 and 0x1 are binned per phase, to increase coverage of these
marker types across parental homologues. If not, at most one of each are retained per bin.</p>
</td></tr>
<tr><td><code id="thinmap_+3A_parent1">parent1</code></td>
<td>
<p>Identifier of parent 1, by default assumed to be <code>"P1"</code></p>
</td></tr>
<tr><td><code id="thinmap_+3A_parent2">parent2</code></td>
<td>
<p>Identifier of parent 2, by default assumed to be <code>"P2"</code></p>
</td></tr>
<tr><td><code id="thinmap_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If NULL log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A maplist of the same structure as the input maplist, but with fewer markers based on the bin_size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("phased_maplist.4x","SNP_dosages.4x")
maplist_thin&lt;-thinmap(maplist=phased_maplist.4x,dosage_matrix=SNP_dosages.4x)
</code></pre>

<hr>
<h2 id='visualiseGIC'>Visualise Genotypic Information Coefficient</h2><span id='topic+visualiseGIC'></span>

<h3>Description</h3>

<p>Function to visualise the GIC of a certain region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualiseGIC(
  GIC_list,
  add_rug = TRUE,
  add_leg = FALSE,
  ylimits = NULL,
  gic.cex = 1,
  show_markers = TRUE,
  add.mainTitle = TRUE,
  plot.cols = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualiseGIC_+3A_gic_list">GIC_list</code></td>
<td>
<p>List of GIC data, the output of <code><a href="#topic+estimate_GIC">estimate_GIC</a></code></p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_add_rug">add_rug</code></td>
<td>
<p>Should original marker positions be added to the plot?</p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_add_leg">add_leg</code></td>
<td>
<p>Should a legend be added to the plot?</p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_ylimits">ylimits</code></td>
<td>
<p>Optional argument to control the plotting area, by default <code>NULL</code></p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_gic.cex">gic.cex</code></td>
<td>
<p>Option to increase the size of the GIC</p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_show_markers">show_markers</code></td>
<td>
<p>Should markers be shown?</p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_add.maintitle">add.mainTitle</code></td>
<td>
<p>Should a main title be added to the plot?</p>
</td></tr>
<tr><td><code id="visualiseGIC_+3A_plot.cols">plot.cols</code></td>
<td>
<p>Optional argument to specify plot colours, otherwise suitable contrasting colours are chosen</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The phased map data for the specified region, recoded into 1's and 0's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GIC_4x")
visualiseGIC(GIC_list = GIC_4x)
</code></pre>

<hr>
<h2 id='visualiseHaplo'>Visualise haplotypes in certain individuals in a certain region</h2><span id='topic+visualiseHaplo'></span>

<h3>Description</h3>

<p>Function to visualise the haplotypes of a certain region in certain individuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualiseHaplo(
  IBD_list,
  display_by = c("phenotype", "name"),
  linkage_group = NULL,
  Phenotype.df = NULL,
  genotype.ID = NULL,
  trait.ID = NULL,
  pheno_range = NULL,
  cM_range = "all",
  highlight_region = NULL,
  select_offspring = NULL,
  recombinant_scan = NULL,
  allele_fish = NULL,
  presence_threshold = 0.95,
  xlabl = TRUE,
  ylabl = TRUE,
  mainTitle = NULL,
  multiplot = NULL,
  append = FALSE,
  colPal = c("white", "navyblue", "darkred"),
  hap.wd = 0.4,
  recombination_data = NULL,
  reset_par = TRUE,
  log = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualiseHaplo_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_display_by">display_by</code></td>
<td>
<p>Option to display a subset of the population's haplotypes either by <code>"phenotype"</code> or <code>"name"</code>.
If <code>"phenotype"</code> is supplied, then <code>Phenotype.df</code>,<code>genotype.ID</code>,<code>trait.ID</code> and <code>pheno_range</code> must also be specified.
if <code>"name"</code> is supplied, then <code>select_offspring</code> must be specified.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_linkage_group">linkage_group</code></td>
<td>
<p>Numeric identifier of the linkage group being examined, based on the order of <code>IBD_list</code>.
Only a single linkage group is allowed. If <code>IBD_list</code> corresponds to a single linkage group, default value
of <code>NULL</code> will suffice</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values, which can be used to select a subset of the population
to visualise (with extreme phenotypes for example). By default <code>NULL</code>, in which case a subset of the
population may be selected using the <code>select_offspring</code> argument.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the population identifiers (F1 names) (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_pheno_range">pheno_range</code></td>
<td>
<p>Vector of numeric bounds of the phenotypic scores to include (offspring selection).</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_cm_range">cM_range</code></td>
<td>
<p>Vector of numeric bounds of the genetic region to be explored. If none are specified, the default of <code>"all"</code> means all cM positions will be included.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_highlight_region">highlight_region</code></td>
<td>
<p>Option to hightlight a particular genetic region on the plot; can be a single position or a vector of 2 positions. By default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_select_offspring">select_offspring</code></td>
<td>
<p>Vector of offspring identifiers to visualise, must be supplied if <code>display_by</code> = <code>"name"</code>. Specifying <code>"all"</code> will result in
all offspring haplotypes being visualised.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_recombinant_scan">recombinant_scan</code></td>
<td>
<p>Vector of homologue numbers between which to search for recombinant offspring in the visualised region and selected individuals.
By default <code>NULL</code>, in which case no search is preformed.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_allele_fish">allele_fish</code></td>
<td>
<p>Vector of homologue numbers of interest, for which to search for offspring that carry these homologues (in the visualised
region). By default <code>NULL</code>, in which case no search (&quot;fishing&quot;) is performed.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_presence_threshold">presence_threshold</code></td>
<td>
<p>Numeric. The minimum probability used to declare presence of a homologue in an individual. This is only needed if a <code>recombinant_scan</code> is
performed. By default a value of 0.95 is used. When searching for recombinants, this value is also used to denote the proportion of loci carrying the required number
of homologues (i.e. by default 95 per cent of loci should have between 0.95 and 1.1 copies of the specified recombinant homologues).</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_xlabl">xlabl</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should an x-axis label be used?</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_ylabl">ylabl</code></td>
<td>
<p>Logical, by default <code>TRUE</code>. Should a y-axis label be used?</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_maintitle">mainTitle</code></td>
<td>
<p>Option to override default plot titles with a (vector of) captions. By default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_multiplot">multiplot</code></td>
<td>
<p>Vector of integers. By default <code>NULL</code> so haplotypes are plotted singly;
otherwise a vector specifying the number of rows and columns in the plot layout.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_append">append</code></td>
<td>
<p>Option to allow user to append new plots to spaces generated by <code>multiplot</code>, otherwise these are
filled with blank plots. By default <code>FALSE</code>. If <code>TRUE</code>, then a large enough <code>multiplot</code> grid should be
generated to make this option meaningful.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_colpal">colPal</code></td>
<td>
<p>Colour palette to use in the visualisation (best to provide 3 colours).</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_hap.wd">hap.wd</code></td>
<td>
<p>The width of the haplotype tracks to be plotted, generally recommended to be about 0.4 (default value)</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_recombination_data">recombination_data</code></td>
<td>
<p>List object as returned by the function <code>count_recombinations</code>. By default <code>NULL</code>, 
in which case no overlay of predicted recombination events is performed. However, it can be useful
to visualise predicted recombination events, particularly as this might help inform the choice of argument <code>plausible_pairing_prob</code>
of that function. See <code><a href="#topic+count_recombinations">count_recombinations</a></code> for more details.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_reset_par">reset_par</code></td>
<td>
<p>By default <code>TRUE</code>, reset par on exit.</p>
</td></tr>
<tr><td><code id="visualiseHaplo_+3A_log">log</code></td>
<td>
<p>Character string specifying the log filename to which standard output should be written. If <code>NULL</code> log is send to stdout.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>recombinant_scan</code> vector is supplied, a vector of recombinant offspring ID in the region of interest (otherwise <code>NULL</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x")
visualiseHaplo(IBD_list = IBD_4x,
               display_by = "name",
               linkage_group = 1,
               select_offspring = "all",
               multiplot = c(3,3))
</code></pre>

<hr>
<h2 id='visualisePairing'>Visualise pairing of parental homologues</h2><span id='topic+visualisePairing'></span>

<h3>Description</h3>

<p>Function to visualise the pairing of parental homologues across the population using graph, with nodes 
to denote parental homologues and edges to denote deviations from expected proportions under a polysomic model of inheritance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualisePairing(
  meiosis_report.ls,
  pos.col = "red",
  neg.col = "blue",
  parent,
  max.lwd = 20,
  datawidemax,
  add.label = TRUE,
  return.data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualisePairing_+3A_meiosis_report.ls">meiosis_report.ls</code></td>
<td>
<p>List output of function <code><a href="#topic+meiosis_report">meiosis_report</a></code></p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_pos.col">pos.col</code></td>
<td>
<p>Colour corresponding to excess of pairing associations predicted (positive deviations), by default red</p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_neg.col">neg.col</code></td>
<td>
<p>Colour corresponding to lack of pairing associations predicted (negative deviations), by default blue</p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_parent">parent</code></td>
<td>
<p>The parent, either &quot;P1&quot; (mother) or &quot;P2 (father)</p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_max.lwd">max.lwd</code></td>
<td>
<p>Maximum line width, by default 20</p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_datawidemax">datawidemax</code></td>
<td>
<p>This argument is currently a work-around to allow multiple plots to have the same scale (line thicknesses consistent).
No default is provided. To estimate this value, simply set argument <code>return.data = TRUE</code>, and record the
maximum absolute value over columns 'count', which are the deviations from random expectations. This should be done
over multiple function calls if e.g. comparing both P1 and P2 values. When a global maximum (absolute) deviation is known,
re-run the function with this value for <code>datawidemax</code>. The line width specified by <code>max.lwd</code> will then be
used for this, and all other line widths re-scaled accordingly.</p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_add.label">add.label</code></td>
<td>
<p>Should a label be applied, giving the maximum deviation in the plot? By default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_return.data">return.data</code></td>
<td>
<p>Should plot data be returned? By default <code>FALSE</code></p>
</td></tr>
<tr><td><code id="visualisePairing_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>return.data = TRUE</code>, the values for pairwise deviations from the expected numbers are 
returned, useful for determining the value <code>datawidemax</code> to provide consistent scaling across multiple plots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("mr.ls")
visualisePairing(meiosis_report.ls = mr.ls,
                 parent = "P1",
                 datawidemax = 3)
</code></pre>

<hr>
<h2 id='visualiseQTLeffects'>Visualise QTL homologue effects around a QTL position</h2><span id='topic+visualiseQTLeffects'></span>

<h3>Description</h3>

<p>Function to visualise the effect of parental homologues around a QTL peak across the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualiseQTLeffects(
  IBD_list,
  Phenotype.df,
  genotype.ID,
  trait.ID,
  linkage_group,
  LOD_data,
  cM_range = NULL,
  col.pal = c("purple4", "white", "seagreen"),
  point.density = 50,
  zero.sum = FALSE,
  allelic_interaction = FALSE,
  exploreQTL_output = NULL,
  return_plotData = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualiseQTLeffects_+3A_ibd_list">IBD_list</code></td>
<td>
<p>List of IBD probabilities</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_phenotype.df">Phenotype.df</code></td>
<td>
<p>A data.frame containing phenotypic values</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_genotype.id">genotype.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the population identifiers (F1 names) (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_trait.id">trait.ID</code></td>
<td>
<p>The colname of <code>Phenotype.df</code> that contains the response variable to use in the model (must be a colname of <code>Phenotype.df</code>)</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_linkage_group">linkage_group</code></td>
<td>
<p>Numeric identifier of the linkage group being tested, based on the order of <code>IBD_list</code>.
Only a single linkage group is allowed.</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_lod_data">LOD_data</code></td>
<td>
<p>Output of <code><a href="#topic+QTLscan">QTLscan</a></code> function</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_cm_range">cM_range</code></td>
<td>
<p>If required, the plotting region can be restricted to a specified range of centiMorgan positions
(provided as a vector of start and end positions).</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_col.pal">col.pal</code></td>
<td>
<p>Vector of colours to use in the visualisations (it is best to provide two or three colours for simplicity). By default,
effects will be coloured from purple to green through white.</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_point.density">point.density</code></td>
<td>
<p>Parameter to increase the smoothing of homologue effect tracks</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_zero.sum">zero.sum</code></td>
<td>
<p>How allele substitution effect should be defined. If <code>FALSE</code> (by default), the effect of each homologue
is computed relative to the overall phenotypic mean, otherwise contrasts (against offspring without the inherited homologue) are used.</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_allelic_interaction">allelic_interaction</code></td>
<td>
<p>By default <code>FALSE</code>, in which case the additive effects of parental alleles are visualised. If <code>TRUE</code>, a plot of
the mean effect of combinations of parental alleles is visualised instead. <code>exploreQTL_output</code> is required in this case.</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_exploreqtl_output">exploreQTL_output</code></td>
<td>
<p>If <code>allelic_interaction = TRUE</code>, the output of the function <code><a href="#topic+exploreQTL">exploreQTL</a></code> must be provided.</p>
</td></tr>
<tr><td><code id="visualiseQTLeffects_+3A_return_plotdata">return_plotData</code></td>
<td>
<p>Logical, by default <code>FALSE</code>. If <code>TRUE</code>, plot data is returned, otherwise <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated effects of the homologues, used in the visualisation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("IBD_4x","BLUEs.pheno","qtl_LODs.4x")
visualiseQTLeffects(IBD_list = IBD_4x,
                    Phenotype.df = BLUEs.pheno,
                    genotype.ID = "Geno",
                    trait.ID = "BLUE",
                    linkage_group = 2,
                    LOD_data = qtl_LODs.4x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
