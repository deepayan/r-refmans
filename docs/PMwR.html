<!DOCTYPE html><html lang="en"><head><title>Help for package PMwR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PMwR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#PMwR-package'>
<p>Tools for the Management of Financial Portfolios</p></a></li>
<li><a href='#Adjust-Series'>
<p>Adjust Time Series for Dividends and Splits</p></a></li>
<li><a href='#btest'>
<p>Backtesting Investment Strategies</p></a></li>
<li><a href='#DAX'>
<p>Deutscher Aktienindex (DAX)</p></a></li>
<li><a href='#drawdowns'>
<p>Compute Drawdowns</p></a></li>
<li><a href='#instrument'>
<p>Retrieve or Change Instrument</p></a></li>
<li><a href='#is_valid_ISIN'>
<p>Validate Security Identification Numbers</p></a></li>
<li><a href='#journal'>
<p>Journal</p></a></li>
<li><a href='#NAVseries'>
<p>Net-Asset-Value (NAV) Series</p></a></li>
<li><a href='#pl'>
<p>Profit and Loss</p></a></li>
<li><a href='#plot_trading_hours'>
<p>Plot Time Series During Trading Hours</p></a></li>
<li><a href='#PMwR-internal'><p>Internal Functions</p></a></li>
<li><a href='#position'>
<p>Aggregate Transactions to Positions</p></a></li>
<li><a href='#pricetable'>
<p>Price Table</p></a></li>
<li><a href='#quote32'>
<p>Treasury Quotes with 1/32nds of Point</p></a></li>
<li><a href='#rc'>
<p>Return Contribution</p></a></li>
<li><a href='#rebalance'>
<p>Rebalance Portfolio</p></a></li>
<li><a href='#returns'>
<p>Compute Returns</p></a></li>
<li><a href='#REXP'>
<p>REXP</p></a></li>
<li><a href='#scale1'>
<p>Scale Time Series</p></a></li>
<li><a href='#streaks'>
<p>Up and Down Streaks</p></a></li>
<li><a href='#toHTML'><p>Import from package <span class="pkg">textutils</span></p></a></li>
<li><a href='#Trade-Analysis'>
<p>Analysing Trades: Compute Profit/Loss, Resize and more</p></a></li>
<li><a href='#unit_prices'>
<p>Compute Prices for Portfolio Based on Units</p></a></li>
<li><a href='#valuation'>
<p>Valuation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Portfolio Management with R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-10-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Enrico Schumann &lt;es@enricoschumann.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for the practical management of financial
  portfolios: backtesting investment and trading strategies,
  computing profit/loss and returns, analysing trades,
  handling lists of transactions, reporting, and more.  The
  package provides a small set of reliable, efficient and
  convenient tools for processing and analysing
  trade/portfolio data.  The manual provides all the details;
  it is available from
  <a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html</a>.
  Examples and descriptions of new features are provided at
  <a href="https://enricoschumann.net/notes/PMwR/">https://enricoschumann.net/notes/PMwR/</a>.</td>
</tr>
<tr>
<td>Imports:</td>
<td>NMOF, datetimeutils, fastmatch, orgutils, parallel, textutils,
utils, zoo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>crayon, rbenchmark, tinytest</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a> ,
<a href="https://git.sr.ht/~enricoschumann/PMwR">https://git.sr.ht/~enricoschumann/PMwR</a> ,
<a href="https://gitlab.com/enricoschumann/PMwR">https://gitlab.com/enricoschumann/PMwR</a> ,
<a href="https://github.com/enricoschumann/PMwR">https://github.com/enricoschumann/PMwR</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-19 17:44:11 UTC; es19</td>
</tr>
<tr>
<td>Author:</td>
<td>Enrico Schumann <a href="https://orcid.org/0000-0001-7601-6576"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-19 23:40:20 UTC</td>
</tr>
</table>
<hr>
<h2 id='PMwR-package'>
Tools for the Management of Financial Portfolios
</h2><span id='topic+PMwR-package'></span><span id='topic+PMwR'></span>

<h3>Description</h3>

<p>Tools for the practical management of financial
portfolios: backtesting investment and trading
strategies, computing profit-and-loss and returns,
analysing trades, reporting, and more.
</p>


<h3>Details</h3>

<p><span class="pkg">PMwR</span> provides a small set of reliable, efficient
and convenient tools for processing and analysing
trade/portfolio data. The Manual provides all the
details; it is available from
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>. Examples and
descriptions of new features are provided at
<a href="https://enricoschumann.net/notes/PMwR/">https://enricoschumann.net/notes/PMwR/</a>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>The <span class="pkg">PMwR</span> Manual, which explains all functionality:<br />
Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>
</p>
<p>The closely-related <span class="pkg">NMOF</span> package is described in:<br />
Gilli, M., Maringer, D. and Schumann, E. (2019) <em>Numerical Methods
and Optimization in Finance</em>. 2nd edition. Elsevier.
<a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) Financial Optimisation with R (<span class="pkg">NMOF</span> Manual).
<a href="https://enricoschumann.net/NMOF.htm#NMOFmanual">https://enricoschumann.net/NMOF.htm#NMOFmanual</a>
</p>

<hr>
<h2 id='Adjust-Series'>
Adjust Time Series for Dividends and Splits
</h2><span id='topic+div_adjust'></span><span id='topic+split_adjust'></span>

<h3>Description</h3>

<p>Adjust a time series for dividends and splits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>div_adjust(x, t, div, backward = TRUE, additive = FALSE)

split_adjust(x, t, ratio, backward = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Adjust-Series_+3A_x">x</code></td>
<td>

<p>a numeric vector: the series to be adjusted
</p>
</td></tr>
<tr><td><code id="Adjust-Series_+3A_t">t</code></td>
<td>

<p>An integer vector, specifying the positions in
<code>x</code> at which dividends were paid
(&lsquo;ex-days&rsquo;) or at which a split occurred.
Timestamps may be duplicated, e.g. several payments
may occur on a single timestamp.
</p>
</td></tr>
<tr><td><code id="Adjust-Series_+3A_div">div</code></td>
<td>

<p>A numeric vector, specifying the dividends (or
payments, cashflows).  If necessary, recycled to
the length of <code>t</code>.
</p>
</td></tr>
<tr><td><code id="Adjust-Series_+3A_ratio">ratio</code></td>
<td>

<p>a numeric vector, specifying the split ratios. The ratio must be
&lsquo;American Style&rsquo;: a 2-for-1 stock split, for example,
corresponds to a ratio of 2. (In other countries, for instance
Germany, a 2-for-1 stock split would be called a 1-for-1 split: you
keep your shares and receive one new share per share that you own.)
</p>
</td></tr>
<tr><td><code id="Adjust-Series_+3A_backward">backward</code></td>
<td>

<p>logical; see Details
</p>
</td></tr>
<tr><td><code id="Adjust-Series_+3A_additive">additive</code></td>
<td>

<p>logical; see Details
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function transforms <code class="reqn">x</code> into returns, and
with those returns specified in <code class="reqn">t</code> calculated
as
</p>
<p style="text-align: center;"><code class="reqn">\frac{x_t + D_t}{x_{t-1}} - 1\,,</code>
</p>

<p>in which <code class="reqn">x</code> is the price, <code class="reqn">D</code> are dividends
and <code class="reqn">t</code> is time.  The adjusted <code class="reqn">x</code> is
then reconstructed from those returns.
</p>
<p>When <code>additive</code> is <code><a href="base.html#topic+TRUE">TRUE</a></code>, dividends are
simply added back to the series; see Examples.
</p>
<p>With <code>backward</code> set to <code><a href="base.html#topic+TRUE">TRUE</a></code>, which is the
default, the final prices in the unadjusted series matches
the final prices in the adjusted series.
</p>


<h3>Value</h3>

<p>a numeric vector of length equal to <code>length(x)</code>
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>
</p>
<p>Using <code>div_adjust</code> for handling generic external cashflows:
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#returns-with-external-cashflows">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#returns-with-external-cashflows</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(9.777, 10.04, 9.207, 9.406)
div &lt;- 0.7
t &lt;- 3

div_adjust(x, t, div)
div_adjust(x, t, div, FALSE)



## assume there were three splits: adjust shares outstanding
shares &lt;- c(100, 100, 200, 200, 1000, 1500)
t &lt;- c(3, 5, 6)
ratio &lt;- c(2, 5, 1.5)
### =&gt; invert ratio
split_adjust(shares, t, 1/ratio)
## [1] 1500 1500 1500 1500 1500 1500

split_adjust(shares, t, 1/ratio, backward = FALSE)
## [1] 100 100 100 100 100 100



## 'additive' ** FALSE ** (default setting)
x &lt;- c(100, 95, 100, 95, 100)
div &lt;- 5
t &lt;- c(2, 4)
div_adjust(x, t, div)
## 90.25  90.25  95.00  95.00 100.00
returns(div_adjust(x, t, div))
## 0.00000000 0.05263158 0.00000000 0.05263158
## ==&gt; reflect _actual_ returns 100/95 - 1

## 'additive' ** TRUE **
div_adjust(x, t, div, additive = TRUE)
## 90  90  95  95 100
returns(div_adjust(x, t, div, additive = TRUE))
## 0.00000000 0.05555556 0.00000000 0.05263158
## ==&gt; reflect return 95/90 - 1
</code></pre>

<hr>
<h2 id='btest'>
Backtesting Investment Strategies
</h2><span id='topic+btest'></span>

<h3>Description</h3>

<p>Testing trading and investment strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btest(prices, signal,
      do.signal = TRUE, do.rebalance = TRUE,
      print.info = NULL, b = 1, fraction = 1,
      initial.position = 0, initial.cash = 0,
      final.position = FALSE,
      cashflow = NULL, tc = 0, ...,
      add = FALSE, lag = 1, convert.weights = FALSE,
      trade.at.open = TRUE, tol = 1e-5, tol.p = NA,
      Globals = list(),
      prices0 = NULL,
      include.data = FALSE, include.timestamp = TRUE,
      timestamp, instrument,
      progressBar = FALSE,
      variations, variations.settings, replications)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="btest_+3A_prices">prices</code></td>
<td>

<p>For a single asset, a matrix of prices with four
columns: open, high, low and close. For <code>n</code>
assets, a list of length four: <code>prices[[1]]</code>
is then a matrix with <code>n</code> columns containing
the open prices for the assets; <code>prices[[2]]</code>
is a matrix with the high prices, and so on. If
only close prices are used, then for a single asset
either a matrix of one column or a numeric vector;
for multiple assets a list of length one,
containing the matrix of close prices. For example,
with 100 close prices of 5 assets, the prices
should be arranged in a matrix <code>p</code> of size 100
times 5; and <code>prices = list(p)</code>.
</p>
<p>The series in <code>prices</code> are used both as
transaction prices and for valuing open
positions. If signals are to be based on other
series, such other series should be passed via the
... argument.
</p>
<p>Prices must be ordered by time (though the
timestamps need not be provided).
</p>
</td></tr>
<tr><td><code id="btest_+3A_signal">signal</code></td>
<td>

<p>A function that evaluates to the position in units
of the instruments suggested by the trading
rule. If <code>convert.weights</code> is <code>TRUE</code>,
<code>signal</code> should return the suggested position
as weights (which need not sum to 1).  If <code>signal</code>
returns <code>NULL</code>, the current position is kept.
See Details.
</p>
</td></tr>
<tr><td><code id="btest_+3A_do.signal">do.signal</code></td>
<td>

<p>Logical or numeric vector, a function that
evaluates to <code>TRUE</code> or <code>FALSE</code>, or a
string.
</p>
<p>When a logical vector, its length must match the
number of observations in prices: <code>do.signal</code>
then corresponds to the rows in <code>prices</code> at
which a signal is computed. Alternatively, these
rows may also be specified as integers.  If a
length-one <code>TRUE</code> or <code>FALSE</code>, the value
is recycled to match the number of observations in
prices.  Default is <code>TRUE</code>: a signal is then
computed in every period.
</p>
<p><code>do.signal</code> may also be the string
&ldquo;firstofmonth&rdquo;, &ldquo;lastofmonth&rdquo;,
&ldquo;firstofquarter&rdquo; or &ldquo;lastofquarter&rdquo;;
in these cases, <code>timestamp</code> needs to specified
and must be coercable to <code><a href="base.html#topic+Date">Date</a></code>.
</p>
<p>If <code>timestamp</code> is specified, <code>do.signal</code> may
also be a vector of the same class as <code>timestamp</code>
(typically <code><a href="base.html#topic+Date">Date</a></code> or <code><a href="base.html#topic+POSIXct">POSIXct</a></code>).
If the timestamps specified in <code>do.signal</code> do not
occur in <code>timestamp</code>, a signal is computed on the
next possible time instance.
</p>
</td></tr>
<tr><td><code id="btest_+3A_do.rebalance">do.rebalance</code></td>
<td>

<p>Same as <code>do.signal</code>, but it may return a logical
vector of length equal to the number of assets, which
indicates which assets to rebalance. Can also be the
string <code>"do.signal"</code>, in which case the value of
<code>do.signal</code> is copied. <code>do.rebalance</code> is called
after signal computation, so it can access the suggested
position of the current period (via <code>SuggestedPortfolio(0)</code>.
</p>
</td></tr>
<tr><td><code id="btest_+3A_print.info">print.info</code></td>
<td>

<p>A function, called at the very end of each period,
i.e. after rebalancing.  Can also be <code>NULL</code>, in
which case nothing is printed.
</p>
</td></tr>
<tr><td><code id="btest_+3A_cashflow">cashflow</code></td>
<td>

<p>A function or <code>NULL</code> (default).
</p>
</td></tr>
<tr><td><code id="btest_+3A_b">b</code></td>
<td>

<p>burn-in (an integer). Defaults to 1. This may also
be a length-one timestamp of the same class as
<code>timestamp</code>, in which case the data up to (and
including) <code>b</code> are skipped.
</p>
</td></tr>
<tr><td><code id="btest_+3A_fraction">fraction</code></td>
<td>

<p>amount of rebalancing to be done: a scalar between
0 and 1
</p>
</td></tr>
<tr><td><code id="btest_+3A_initial.position">initial.position</code></td>
<td>

<p>a numeric vector: initial portfolio in units of
instruments.  If supplied, this will also be the
initial suggested position.
</p>
</td></tr>
<tr><td><code id="btest_+3A_initial.cash">initial.cash</code></td>
<td>

<p>a numeric vector of length 1. Defaults to 0.
</p>
</td></tr>
<tr><td><code id="btest_+3A_final.position">final.position</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="btest_+3A_tc">tc</code></td>
<td>

<p>transaction costs as a fraction of turnover (e.g.,
0.001 means 0.1%). May also be a function that
evaluates to such a fraction. More-complex
computations may be specified with
argument <code>cashflow</code>.
</p>
</td></tr>
<tr><td><code id="btest_+3A_...">...</code></td>
<td>

<p>other named arguments. All functions (signal,
do.signal, do.rebalance, print.info, cashflow) will
have access to these arguments. See Details for
reserved argument names.
</p>
</td></tr>
<tr><td><code id="btest_+3A_add">add</code></td>
<td>

<p>Default is <code>FALSE</code>. <code>TRUE</code> is <strong>not
implemented</strong> &ndash; but would mean that <code>signal</code>
should evaluate to <em>changes</em> in position,
i.e. orders.
</p>
</td></tr>
<tr><td><code id="btest_+3A_lag">lag</code></td>
<td>

<p>default is 1
</p>
</td></tr>
<tr><td><code id="btest_+3A_convert.weights">convert.weights</code></td>
<td>

<p>Default is <code>FALSE</code>.  If <code>TRUE</code>, the value
of signal will be considered a weight vector and
automatically translated into (fractional) position
sizes.
</p>
</td></tr>
<tr><td><code id="btest_+3A_trade.at.open">trade.at.open</code></td>
<td>

<p>A logical vector of length one; default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="btest_+3A_tol">tol</code></td>
<td>

<p>A numeric vector of length one: only rebalance if
the maximum absolute suggested change for at least
one position is greater than <code>tol</code>. Default is
0.00001 (which practically means always rebalance).
</p>
</td></tr>
<tr><td><code id="btest_+3A_tol.p">tol.p</code></td>
<td>

<p>A numeric vector of length one: only rebalance
those positions for which the relative suggested
change is greater than <code>tol.p</code>. Default is
<code><a href="base.html#topic+NA">NA</a></code>: always rebalance.
</p>
</td></tr>
<tr><td><code id="btest_+3A_globals">Globals</code></td>
<td>

<p>A <code>list</code> of named elements. See Details.
</p>
</td></tr>
<tr><td><code id="btest_+3A_prices0">prices0</code></td>
<td>

<p>A numeric vector (default is <code>NULL</code>). Only
used if <code>b</code> is 0 and an initial portfolio
(<code>initial.position</code>) is specified.
</p>
</td></tr>
<tr><td><code id="btest_+3A_include.data">include.data</code></td>
<td>

<p>logical. If <code>TRUE</code>, all passed data are stored
in final <code>btest</code> object. See Section
Value. See also argument <code>include.timestamp</code>.
</p>
</td></tr>
<tr><td><code id="btest_+3A_include.timestamp">include.timestamp</code></td>
<td>

<p>logical. If <code>TRUE</code>, <code>timestamp</code> is stored
in final <code>btest</code> object. If <code>timestamp</code>
is missing, integers 1, 2, ... are used. See
Section Value.  See also argument
<code>include.data</code>.
</p>
</td></tr>
<tr><td><code id="btest_+3A_timestamp">timestamp</code></td>
<td>

<p>a vector of timestamps, along prices (optional; mainly used for
print method and journal)
</p>
</td></tr>
<tr><td><code id="btest_+3A_instrument">instrument</code></td>
<td>

<p>character vector of instrument names (optional; mainly used for
print method and journal)
</p>
</td></tr>
<tr><td><code id="btest_+3A_progressbar">progressBar</code></td>
<td>

<p>logical: display <code><a href="utils.html#topic+txtProgressBar">txtProgressBar</a></code>?
</p>
</td></tr>
<tr><td><code id="btest_+3A_variations">variations</code></td>
<td>

<p>a list. See Details.
</p>
</td></tr>
<tr><td><code id="btest_+3A_variations.settings">variations.settings</code></td>
<td>

<p>a list. See Details.
</p>
</td></tr>
<tr><td><code id="btest_+3A_replications">replications</code></td>
<td>

<p>an integer. If set, the function returns a list of
<code>btest</code> objects.  Each <code>btest</code> has an
attribute <code>replication</code>, which records the
replication number.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides infrastructure for testing
trading rules. Essentially, <code>btest</code> does
accounting: keep track of transactions and positions,
value open positions, etc. The ingredients are price
time-series (single series or <abbr><span class="acronym">OHLC</span></abbr>
bars), which need not be equally spaced; and several
functions that map these series and other pieces of
information into positions.
</p>


<h4>How <code>btest</code> works</h4>


<p><code>btest</code> runs a loop from <code>b + 1</code> to
<code>NROW(prices)</code>. In iteration <code>t</code>, a
<code>signal</code> can be computed based on information
from periods prior to <code>t</code>. Trading then takes
place at the opening price of <code>t</code>.
</p>
<pre>
t    time      open  high  low   close
1    HH:MM:SS                             &lt;--\
2    HH:MM:SS                             &lt;-- - use information
3    HH:MM:SS  _________________________  &lt;--/
4    HH:MM:SS     X                       &lt;- trade here
5    HH:MM:SS
    </pre>
<p>For slow-to-compute signals this is reasonable if
there is a time lag between close and open. For
daily prices, for instance, signals could be
computed overnight. For higher frequencies, such as
every minute, the signal function should be fast to
compute. Alternatively, it may be better to use a
larger time offset (i.e. use a longer time lag) and
to trade at the close of <code>t</code> by setting
argument <code>trade.at.open</code> to <code>FALSE</code>.
</p>
<pre>
t    time      open  high  low   close
1    HH:MM:SS                             &lt;-- \
2    HH:MM:SS                             &lt;-- - use information
3    HH:MM:SS  _________________________  &lt;-- /
4    HH:MM:SS                        X    &lt;-- trade here
5    HH:MM:SS
    </pre>
<p>If no <abbr><span class="acronym">OHLC</span></abbr> bars are available, a single
series per asset (assumed to be close prices) can
be used.  <code>trade.at.open</code> will automaticall be
set to <code><a href="base.html#topic+FALSE">FALSE</a></code>.
</p>
<p>The trade logic needs to be coded in the function
<code>signal</code>. Arguments to that function must be
named and need to be passed with <code>...</code>.
Certain names are reserved and cannot be used as
arguments: <code>Open</code>, <code>High</code>, <code>Low</code>,
<code>Close</code>, <code>Wealth</code>, <code>Cash</code>,
<code>Time</code>, <code>Timestamp</code>, <code>Portfolio</code>,
<code>SuggestedPortfolio</code>, <code>Globals</code>. Further
reserved names may be added in the future:
<strong>it is suggested to not start an argument
name with a capital letter</strong>.
</p>
<p>The function <code>signal</code> must evaluate to the
target position in units of the instruments. To
work with weights, set <code>convert.weights</code> to
<code>TRUE</code>, and <code>btest</code> will translate the
weights into positions, based on the value of the
portfolio at <code>t - 1</code>.
</p>



<h4>Accessing data</h4>


<p>Within <code>signal</code> (and also other function
arguments, such as <code>do.signal</code>), you can
access data via special functions such as
<code>Close</code>. These are automatically added as
arguments to <code>signal</code>. Currently, the
following functions are available: <code>Open</code>,
<code>High</code>, <code>Low</code>, <code>Close</code>,
<code>Wealth</code>, <code>Cash</code>, <code>Time</code>,
<code>Timestamp</code>, <code>Portfolio</code>,
<code>SuggestedPortfolio</code>, <code>Globals</code>.
<code>Globals</code> is special: it is an
<code><a href="base.html#topic+environment">environment</a></code>, which can be used to
persistently store data during the run of
<code>btest</code>. Use the argument <code>Globals</code> to
add initial objects. See the Examples below and the
manual.
</p>
<p>Additional functions may be added to <code>btest</code>
in the future. The names of those functions will
always be in title case. Hence, it is recommended
to not use argument names for <code>signal</code>,
etc. that start with a capital letter.
</p>



<h4>Replications and variations</h4>


<p><code>btest</code> allows to run backtests in
parallel. See the examples at
<a href="https://enricoschumann.net/notes/parallel-backtests.html">https://enricoschumann.net/notes/parallel-backtests.html</a>.
</p>
<p>The argument <code>variations.settings</code> is a list with the
following defaults:
</p>

<dl>
<dt><code>method</code></dt><dd><p>character: supported are
<code>"loop"</code>, <code>"parallel"</code> (or <code>"snow"</code>)
and <code>"multicore"</code></p>
</dd>
<dt><code>load.balancing</code></dt><dd><p>logical</p>
</dd>
<dt><code>cores</code></dt><dd><p>numeric</p>
</dd>
</dl>




<h3>Value</h3>

<p>A list with class attribute <code>btest</code>. The list comprises:
</p>
<table role = "presentation">
<tr><td><code>position</code></td>
<td>
<p>actual portfolio holdings</p>
</td></tr>
<tr><td><code>suggested.position</code></td>
<td>
<p>suggested holdings
(aka target position)</p>
</td></tr>
<tr><td><code>cash</code></td>
<td>
<p>cash</p>
</td></tr>
<tr><td><code>wealth</code></td>
<td>
<p>time-series of total portfolio
value (aka equity curve)</p>
</td></tr>
<tr><td><code>cum.tc</code></td>
<td>
<p>transaction costs</p>
</td></tr>
<tr><td><code>journal</code></td>
<td>
<p><code><a href="#topic+journal">journal</a></code> of trades.
Only includes trades done during the backtest, not initial positions.</p>
</td></tr>
<tr><td><code>initial.wealth</code></td>
<td>
<p>initial wealth</p>
</td></tr>
<tr><td><code>b</code></td>
<td>
<p>burn-in</p>
</td></tr>
<tr><td><code>final.position</code></td>
<td>
<p>final position if <code>final.position</code> is
<code>TRUE</code>; otherwise <code><a href="base.html#topic+NA">NA</a></code></p>
</td></tr>
<tr><td><code>Globals</code></td>
<td>
<p>environment <code>Globals</code></p>
</td></tr>
</table>
<p>When <code>include.timestamp</code> is <code>TRUE</code>, the
timestamp is included. If no <code>timestamp</code> was
specified, integers <code>1, 2, ...</code> are used
instead.
</p>
<p>When <code>include.data</code> is <code>TRUE</code>, essentially
all information (prices, instrument, the
actual <code>call</code> and functions <code>signal</code> etc.)
are stored in the list as well.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann <a href="mailto:es@enricoschumann.net">es@enricoschumann.net</a>
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>;
in particular, see the chapter on backtesting:<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#backtesting">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#backtesting</a>
</p>
<p>Schumann, E. (2018) <em>Backtesting</em>.<br />
<a href="https://doi.org/10.2139/ssrn.3374195">doi:10.2139/ssrn.3374195</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For more examples, please see the Manual
## https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html

## 1 - a simple rule
timestamp &lt;- structure(c(16679L, 16680L, 16681L, 16682L,
                         16685L, 16686L, 16687L, 16688L,
                         16689L, 16692L, 16693L),
                       class = "Date")
prices &lt;- c(3182, 3205, 3272, 3185, 3201,
            3236, 3272, 3224, 3194, 3188, 3213)
data.frame(timestamp, prices)


signal &lt;- function()     ## buy when last price is
    if (Close() &lt; 3200)  ## below 3200, else sell
        1 else 0         ## (more precisely: build position of 1
                         ##  when price &lt; 3200, else reduce
                         ##  position to 0)

solution &lt;- btest(prices = prices, signal = signal)
journal(solution)


## with Date timestamps
solution &lt;- btest(prices = prices, signal = signal,
                  timestamp = timestamp)
journal(solution)



## 2 - a simple MA model
## Not run: 
library("PMwR")
library("NMOF")

dax &lt;- DAX[[1]]

n &lt;- 5
ma &lt;- MA(dax, n, pad = NA)

ma_strat &lt;-  function(ma) {
    if (Close() &gt; ma[Time()])
        1
    else
        0
}


plot(as.Date(row.names(DAX)), dax, type = "l", xlab = "", ylab = "DAX")
lines(as.Date(row.names(DAX)), ma, type = "l")

res &lt;- btest(prices = dax,
             signal = ma_strat,
             b = n, ma = ma)

par(mfrow = c(3, 1))
plot(as.Date(row.names(DAX)), dax, type = "l",
     xlab = "", ylab = "DAX")
plot(as.Date(row.names(DAX)), res$wealth, type = "l",
     xlab = "", ylab = "Equity")
plot(as.Date(row.names(DAX)), position(res), type = "s",
     xlab = "", ylab = "Position")

## End(Not run)
</code></pre>

<hr>
<h2 id='DAX'>
Deutscher Aktienindex (DAX)
</h2><span id='topic+DAX'></span>

<h3>Description</h3>

<p>Historical Prices of the DAX.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DAX")</code></pre>


<h3>Format</h3>

<p>A data frame with 505 observations on the following variable:
</p>

<dl>
<dt><code>DAX</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The <abbr><span class="acronym">DAX</span></abbr> (<em>Deutscher Aktienindex</em>) is a
stock-price index of the largest companies listed in
Germany.  The dataset comprises the close prices of
the index for the years 2014 and 2015; dates are
provided as rownames.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(DAX)
summary(DAX)
</code></pre>

<hr>
<h2 id='drawdowns'>
Compute Drawdowns
</h2><span id='topic+drawdowns'></span><span id='topic+drawdowns.zoo'></span><span id='topic+drawdowns.default'></span>

<h3>Description</h3>

<p>Compute drawdown statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawdowns(x, ...)
## Default S3 method:
drawdowns(x, ...)
## S3 method for class 'zoo'
drawdowns(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drawdowns_+3A_x">x</code></td>
<td>

<p>a <code>numeric</code> vector  of prices
</p>
</td></tr>
<tr><td><code id="drawdowns_+3A_...">...</code></td>
<td>

<p>additional arguments, to be passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>drawdowns</code> is a generic function. It computes drawdown
statistics: maximum; and time of peak, trough and recovery.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+data.frame">data.frame</a></code>:
</p>
<table role = "presentation">
<tr><td><code>peak</code></td>
<td>
<p>peak before drawdown</p>
</td></tr>
<tr><td><code>trough</code></td>
<td>
<p>lowest point</p>
</td></tr>
<tr><td><code>recover</code></td>
<td>
<p>new high or <code><a href="base.html#topic+NA">NA</a></code> if the
drawdown has not been recovered yet</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the max drawdown</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Gilli, M., Maringer, D. and Schumann, E. (2019)
<em>Numerical Methods and Optimization in Finance</em>.
2nd edition. Elsevier. <a href="https://doi.org/10.1016/C2017-0-01621-X">doi:10.1016/C2017-0-01621-X</a>
</p>
<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>;<br /> in particular,<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#drawdowns-streaks">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#drawdowns-streaks</a>
</p>


<h3>See Also</h3>

<p>The actual computation of the drawdowns is done by function
<code><a href="NMOF.html#topic+drawdown">drawdown</a></code> in package <span class="pkg">NMOF</span>.
</p>
<p>Series of uninterrupted up and down movements can be
computed with <code><a href="#topic+streaks">streaks</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(100, 98)
drawdowns(x)

x &lt;- c(100, 98, 102, 99)
dd &lt;- drawdowns(x)
dd[order(dd$max, decreasing = TRUE), ]
</code></pre>

<hr>
<h2 id='instrument'>
Retrieve or Change Instrument
</h2><span id='topic+instrument'></span><span id='topic+instrument+3C-'></span>

<h3>Description</h3>

<p>Generic function for retrieving and changing instrument information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>instrument(x, ...)
instrument(x, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="instrument_+3A_x">x</code></td>
<td>

<p>an object
</p>
</td></tr>
<tr><td><code id="instrument_+3A_...">...</code></td>
<td>

<p>arguments passed to methods
</p>
</td></tr>
<tr><td><code id="instrument_+3A_value">value</code></td>
<td>

<p>an object
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Generic function: extract or, if meaningful, replace
instrument information
</p>


<h3>Value</h3>


<p>when used to extract instrument, a character vector
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>


<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+position">position</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>jnl &lt;- journal(instrument = "A",
               amount = 100,
               price = 1)
instrument(jnl)
instrument(jnl) &lt;- "B"
</code></pre>

<hr>
<h2 id='is_valid_ISIN'>
Validate Security Identification Numbers
</h2><span id='topic+is_valid_ISIN'></span><span id='topic+is_valid_SEDOL'></span>

<h3>Description</h3>

<p>Check whether a given ISIN or SEDOL is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_valid_ISIN(isin, NA.FALSE = FALSE)
is_valid_SEDOL(SEDOL, NA.FALSE = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_valid_ISIN_+3A_isin">isin</code></td>
<td>

<p>a character vector
</p>
</td></tr>
<tr><td><code id="is_valid_ISIN_+3A_sedol">SEDOL</code></td>
<td>

<p>a character vector
</p>
</td></tr>
<tr><td><code id="is_valid_ISIN_+3A_na.false">NA.FALSE</code></td>
<td>

<p>logical: if <code><a href="base.html#topic+TRUE">TRUE</a></code>, <code><a href="base.html#topic+NA">NA</a></code> values
evaluate to <code><a href="base.html#topic+FALSE">FALSE</a></code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Checks a character vector of <abbr><span class="acronym">ISIN</span></abbr>s and
<abbr><span class="acronym">SEDOL</span></abbr>s.  The function returns <code>TRUE</code> if the
<abbr><span class="acronym">ISIN</span></abbr>/<abbr><span class="acronym">SEDOL</span></abbr> is valid, else <code>FALSE</code>.
Handling of <code><a href="base.html#topic+NA">NA</a></code> is defined by argument
<code>NA.FALSE</code>.
</p>
<p>International Securities Identification Numbers
(<abbr><span class="acronym">ISIN</span></abbr>s): The test procedure in <abbr><span class="acronym">ISO</span></abbr> 6166
does not differentiate between cases.  Thus, <abbr><span class="acronym">ISIN</span></abbr>s
are transformed to uppercase before being tested.
</p>


<h3>Value</h3>

<p>A named logical vector. For <code>is_valid_SEDOL</code>, a
character vector is attached as an attribute <code>note</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/ISO_6166">https://en.wikipedia.org/wiki/ISO_6166</a>
</p>
<p><a href="https://en.wikipedia.org/wiki/SEDOL">https://en.wikipedia.org/wiki/SEDOL</a>
</p>
<p><a href="https://anna-web.org/identifiers/">https://anna-web.org/identifiers/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isin &lt;- c("US0378331005", "AU0000XVGZA3",
          "DE000A0C3743", "not_an_isin")
is_valid_ISIN(isin)

is_valid_ISIN(c("US0378331005",
                "us0378331005")) ## case is ignored


SEDOL &lt;- c("0263494", "B1F3M59", "0263491", "A", NA)
is_valid_SEDOL(SEDOL)
## 0263494 B1F3M59 0263491       A    &lt;NA&gt;
##    TRUE    TRUE   FALSE   FALSE      NA

is_valid_SEDOL(SEDOL, NA.FALSE = TRUE)
## 0263494 B1F3M59 0263491       A    &lt;NA&gt;
##    TRUE    TRUE   FALSE   FALSE   FALSE
</code></pre>

<hr>
<h2 id='journal'>
Journal
</h2><span id='topic+journal'></span><span id='topic+aggregate.journal'></span><span id='topic+all.equal.journal'></span><span id='topic+as.journal'></span><span id='topic+as.journal.journal'></span><span id='topic+c.journal'></span><span id='topic+head.journal'></span><span id='topic+is.journal'></span><span id='topic+journal.default'></span><span id='topic+length.journal'></span><span id='topic+print.journal'></span><span id='topic+sort.journal'></span><span id='topic+split.journal'></span><span id='topic+subset.journal'></span><span id='topic+summary.journal'></span><span id='topic+tail.journal'></span><span id='topic++5B.journal'></span><span id='topic++5B+3C-.journal'></span><span id='topic+as.data.frame.journal'></span>

<h3>Description</h3>

<p>Create and manipulate a journal of financial transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>journal(amount, ...)

as.journal(x, ...)

is.journal(x)

## Default S3 method:
journal(amount, price, timestamp, instrument,
        id = NULL, account = NULL, ...)

## S3 method for class 'journal'
c(..., recursive = FALSE)

## S3 method for class 'journal'
length(x)

## S3 method for class 'journal'
aggregate(x, by, FUN, ...)

## S3 method for class 'journal'
print(x, ...,
      width = getOption("width"), max.print = getOption("max.print"),
      exclude = NULL, include.only = NULL)

## S3 method for class 'journal'
sort(x, decreasing = FALSE, by = "timestamp", ..., na.last = TRUE)

## S3 method for class 'journal'
summary(object, by = "instrument", drop.zero = TRUE,
      na.rm = FALSE, ...)

## S3 method for class 'journal'
subset(x, ...)

## S3 method for class 'journal'
x[i, match.against = NULL,
                    ignore.case = TRUE, perl = FALSE, fixed = FALSE,
                    useBytes = FALSE, ..., invert = FALSE]

## S3 replacement method for class 'journal'
x[i, match.against = NULL,
                    ignore.case = TRUE, ..., invert = FALSE] &lt;- value

## S3 method for class 'journal'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)

## S3 method for class 'journal'
head(x, n = 6L, ..., by = "instrument")

## S3 method for class 'journal'
tail(x, n = 6L, ..., by = "instrument")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="journal_+3A_timestamp">timestamp</code></td>
<td>

<p>An atomic vector of mode numeric or character. Timestamps should
typically be sortable.
</p>
</td></tr>
<tr><td><code id="journal_+3A_amount">amount</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="journal_+3A_price">price</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="journal_+3A_instrument">instrument</code></td>
<td>

<p>character or numeric (though typically character)
</p>
</td></tr>
<tr><td><code id="journal_+3A_id">id</code></td>
<td>

<p>An atomic vector. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="journal_+3A_account">account</code></td>
<td>

<p>An atomic vector. Default is <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="journal_+3A_...">...</code></td>
<td>

<p>For <code>journal</code>: further arguments, which must all be named.
</p>
<p>For <code>subset</code>: an expression that evaluates to a logical vector. The
expression may use all fields of the passed journal; see Examples.
</p>
<p>For <code>`[`</code>: arguments other than <code>ignore.case</code> to be passed
to <code><a href="base.html#topic+grep">grep</a></code>.
</p>
<p>For <code>sort</code>: arguments passed to <code><a href="base.html#topic+sort">sort</a></code>.
</p>
</td></tr>
<tr><td><code id="journal_+3A_x">x</code></td>
<td>

<p>a <code>journal</code> or an object to be coerced to class <code>journal</code> (for
<code>as.journal</code>) or to be checked if it inherits from journal (for
<code>is.journal</code>)
</p>
</td></tr>
<tr><td><code id="journal_+3A_object">object</code></td>
<td>

<p>a <code>journal</code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_width">width</code></td>
<td>

<p>integer. See <code><a href="base.html#topic+options">options</a></code>.
</p>
</td></tr>
<tr><td><code id="journal_+3A_decreasing">decreasing</code></td>
<td>

<p>passed to <code><a href="base.html#topic+sort">sort</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_by">by</code></td>
<td>

<p><code>sort</code>: sort by field. <code>head</code>/<code>tail</code>: by field
(default is instrument).
<code>summary</code>: a vector of keywords (or <code>NULL</code>); supported are
<code>"instrument"</code>, <code>"year"</code> and <code>"month"</code>.
</p>
</td></tr>
<tr><td><code id="journal_+3A_na.rm">na.rm</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="journal_+3A_drop.zero">drop.zero</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="journal_+3A_na.last">na.last</code></td>
<td>

<p>arguments passed to sort
</p>
</td></tr>
<tr><td><code id="journal_+3A_max.print">max.print</code></td>
<td>

<p>maximum number of transactions to print
</p>
</td></tr>
<tr><td><code id="journal_+3A_exclude">exclude</code></td>
<td>

<p>character: fields that should not be printed
</p>
</td></tr>
<tr><td><code id="journal_+3A_include.only">include.only</code></td>
<td>

<p>character: print only those fields. (Not supported yet.)
</p>
</td></tr>
<tr><td><code id="journal_+3A_row.names">row.names</code></td>
<td>

<p>see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_optional">optional</code></td>
<td>

<p>see <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_recursive">recursive</code></td>
<td>

<p>ignored (see <code><a href="base.html#topic+c">c</a></code>)
</p>
</td></tr>
<tr><td><code id="journal_+3A_i">i</code></td>
<td>

<p>integer, logical or character.  The latter is interpreted as a
regexp (see <code><a href="base.html#topic+grep">grep</a></code>)
</p>
</td></tr>
<tr><td><code id="journal_+3A_n">n</code></td>
<td>

<p>integer
</p>
</td></tr>
<tr><td><code id="journal_+3A_match.against">match.against</code></td>
<td>

<p>character vector of field names. Default is <code>NULL</code>, which
means to match against all character fields.
</p>
</td></tr>
<tr><td><code id="journal_+3A_ignore.case">ignore.case</code></td>
<td>

<p>logical: passed to <code><a href="base.html#topic+grepl">grepl</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_perl">perl</code></td>
<td>

<p>logical: passed to <code><a href="base.html#topic+grepl">grepl</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_fixed">fixed</code></td>
<td>

<p>logical: passed to <code><a href="base.html#topic+grepl">grepl</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_usebytes">useBytes</code></td>
<td>

<p>logical: passed to <code><a href="base.html#topic+grepl">grepl</a></code>
</p>
</td></tr>
<tr><td><code id="journal_+3A_invert">invert</code></td>
<td>

<p>logical. If <code>TRUE</code>, invert selection (when <code>i</code> is of mode
<code>character</code>, select journal entries that do not match regular
expression)
</p>
</td></tr>
<tr><td><code id="journal_+3A_fun">FUN</code></td>
<td>

<p>either a function that takes as input a journal and evaluates to a
journal, or a list of named functions
</p>
</td></tr>
<tr><td><code id="journal_+3A_value">value</code></td>
<td>

<p>a replacement value
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>journal</code> function creates a list of its arguments
and attaches a class attribute (&lsquo;<code>journal</code>&rsquo;).
It is a generic function; the default method creates a
journal from atomic vectors. The <code>btest</code> method
extracts the journal from the results of a backtest; see
<code><a href="#topic+btest">btest</a></code>.
</p>
<p><code>as.journal</code> coerces an object to a journal and is
primarily used for creating a journal from a
<code><a href="base.html#topic+data.frame">data.frame</a></code>.
Calling <code>as.journal</code> on an unnamed numeric vector
interprets the vector as amounts.  If the vector is named,
these are interpreted as instruments; see Examples.  Calling
<code>as.journal</code> on a journal returns the journal itself.
</p>
<p><code>journal</code> methods are available for several generic
functions, for instance:
</p>

<dl>
<dt><code>all.equal</code></dt><dd><p>compare contents of two journals</p>
</dd>
<dt><code>aggregate</code></dt><dd><p>Splits a journal according to
<code>by</code>, applies a function to every sub-journal and
recombines the results into a journal.</p>
</dd>
<dt><code>as.data.frame</code></dt><dd><p>Coerce journal to
<code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</dd>
<dt><code>c</code></dt><dd><p>Combine several journals into one.  Note
that the first argument to <code>c.journal</code> must inherit
from <code>journal</code>, or else the method dispatch will
fail.  For empty journals, use <code>journal()</code> (not
<code>NULL</code>).</p>
</dd>
<dt><code>length</code></dt><dd><p>number of transactions in a journal;
it uses the length of <code>amount</code></p>
</dd>
<dt><code>split</code></dt><dd><p>Splits a journal according to
<code>f</code>, yielding a list of journals.  Often used
interactively to have information per sub-journal
printed.</p>
</dd>
<dt><code>subset</code></dt><dd><p>evaluates an expression in an
environment that can access all fields of the journal.
The function is meant for interactive analysis; care is
needed when it is used within other functions: see
Examples and the Manual.</p>
</dd>
<dt><code>summary</code></dt><dd><p>provides summary statistics, such as
number of trades and average buy/sell prices</p>
</dd>
<dt><code>toOrg</code></dt><dd><p>converts a journal to an Org table;
package <span class="pkg">orgutils</span> must be available</p>
</dd>
</dl>

<p>For journals that have a length, missing arguments will be
coded as <code><a href="base.html#topic+NA">NA</a></code> except for <code>id</code> and
<code>account</code>, which become <code><a href="base.html#topic+NULL">NULL</a></code>.  In
zero-length (i.e. &lsquo;empty&rsquo;) journals, all fields have
length 0.  A zero-length journal is created, for instance,
by saying <code>journal()</code> or when an zero-row
<code>data.frame</code> is passed to <code>as.journal</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>journal</code>, which is a list of atomic
vectors.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>;
in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#journals">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#journals</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+position">position</a></code>, <code><a href="#topic+pl">pl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>j &lt;- journal(timestamp = 1:3,
             amount = c(1,2,3),
             price = 101:103,
             instrument = c("Stock A", "Stock A", "Stock B"))

## *** subset *** in functions
##   this should work as expected ...
t0 &lt;- 2.5
subset(j, timestamp &gt; t0)

##   ... but here?!
tradesAfterT &lt;- function(j, t0)
    subset(j, timestamp &gt; t0)
tradesAfterT(j, 0)

##   if really required
tradesAfterT &lt;- function(j, t0) {
    e &lt;- substitute(timestamp &gt; t0, list(t0 = t0))
    do.call(subset, list(j, e))
}
tradesAfterT(j, 0)

##   ... or much simpler
tradesAfterT &lt;- function(j, t0)
    j[j$timestamp &gt; t0]
tradesAfterT(j, 0)


## *** aggregate ***
##   several buys and sells on two days
##   aim: find average buy/sell price per day
j &lt;- journal(timestamp = structure(c(15950, 15951, 15950, 15951, 15950,
                                     15950, 15951, 15951, 15951, 15951),
                                   class = "Date"),
             amount = c(-3, -4, -3, -1, 3, -2, 1, 3, 5, 3),
             price = c(104, 102, 102, 110, 106, 104, 104, 106, 108, 107),
             instrument = c("B", "B", "A", "A", "B", "B", "A", "B", "A", "A"))

by &lt;- list(j$instrument, sign(j$amount), as.Date(j$timestamp))
fun &lt;- function(x) {
    journal(timestamp = as.Date(x$timestamp[1]),
            amount = sum(x$amount),
            price = sum(x$amount*x$price)/sum(x$amount),
            instrument = x$instrument[1L])
}
aggregate(j, by = by, FUN = fun)


## *** iterate over transactions in (previously defined) journal ***
for (j in split(j, seq_along(j)))
    print(j)



## as.journal with numeric vector
as.journal(1:3)
##    amount
## 1       1
## 2       2
## 3       3
##
## 3 transactions

## as.journal with *named* numeric vector
x &lt;- 1:3; names(x) &lt;- LETTERS[1:3]
as.journal(x)
##    instrument  amount
## 1           A       1
## 2           B       2
## 3           C       3
##
## 3 transactions

x &lt;- 1:3; names(x) &lt;- c("A", "B", "A")
as.journal(x)
##    instrument  amount
## 1           A       1
## 2           B       2
## 3           A       3
##
## 3 transactions
</code></pre>

<hr>
<h2 id='NAVseries'>
Net-Asset-Value (NAV) Series
</h2><span id='topic+NAVseries'></span><span id='topic+as.NAVseries'></span><span id='topic+plot.NAVseries'></span><span id='topic+print.NAVseries'></span><span id='topic+summary.NAVseries'></span><span id='topic+window.NAVseries'></span>

<h3>Description</h3>

<p>Create a net-asset-value (NAV) series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NAVseries(NAV, timestamp,
          instrument = NULL, title = NULL,
          description = NULL,
          drop.NA = NULL)

as.NAVseries(x, ...)

## S3 method for class 'NAVseries'
print(x, ... , na.rm = FALSE)

## S3 method for class 'NAVseries'
summary(object, ..., monthly.vol = TRUE,
        bm = NULL, monthly.te = TRUE,
        na.rm = FALSE, assume.daily = FALSE)

## S3 method for class 'NAVseries'
plot(x, y, ..., xlab = "", ylab = "", type = "l")

## S3 method for class 'NAVseries'
window(x, start = NULL, end = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NAVseries_+3A_nav">NAV</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_timestamp">timestamp</code></td>
<td>

<p>time stamp, typically <code><a href="base.html#topic+Date">Date</a></code> or <code><a href="base.html#topic+POSIXct">POSIXct</a></code>
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_instrument">instrument</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_title">title</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_description">description</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_x">x</code></td>
<td>

<p>an <code>NAVseries</code> or an object to be coerced to NAVseries
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_object">object</code></td>
<td>

<p>an <code>NAVseries</code>
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_...">...</code></td>
<td>

<p>further arguments. For <code>summary</code>, these can be
<code>NAVseries</code>.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_drop.na">drop.NA</code></td>
<td>

<p>logical. If <code>NAV</code> is the result of calling
<code>btest</code>, then this controls whether unused initial
observations (&lsquo;burnin&rsquo;) are dropped.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_bm">bm</code></td>
<td>

<p>an optional NAVseries. If <code>bm</code> does not inherit
from <code>NAVseries</code>, <code><a href="#topic+as.NAVseries">as.NAVseries</a></code> is
tried.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_monthly.vol">monthly.vol</code></td>
<td>

<p>if <code>TRUE</code> (default), volatility computations
are done on monthly returns
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_monthly.te">monthly.te</code></td>
<td>

<p>if <code>TRUE</code> (default), tracking-error computations
are done on monthly returns
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_assume.daily">assume.daily</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_na.rm">na.rm</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_y">y</code></td>
<td>

<p>a second NAVseries to be plotted. Not supported yet.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_xlab">xlab</code></td>
<td>

<p>character. See <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_ylab">ylab</code></td>
<td>

<p>character. See <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_type">type</code></td>
<td>

<p>character. See <code><a href="base.html#topic+plot">plot</a></code>.
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_start">start</code></td>
<td>

<p>same class as timestamp; <code>NULL</code> means the first timestamp
</p>
</td></tr>
<tr><td><code id="NAVseries_+3A_end">end</code></td>
<td>

<p>same class as timestamp; <code>NULL</code> means the last timestamp
</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>NAV series</h4>


<p>An NAV series is a numeric vector (the actual series) and
additional information, attached as attributes: timestamp,
instrument, title, description. Of these attributes,
timestamp is the most useful, as it is used for several
computations (e.g. when calling <code><a href="base.html#topic+summary">summary</a></code>) or
for plotting.
</p>
<p>The &lsquo;instrument&rsquo; is typically an internal label
used to identify the series, such as a ticker;
&lsquo;title&rsquo; is a label, too, but is intended to be
human-readable; &lsquo;description&rsquo; finally should be
human-readable as well, but may be longer than &lsquo;title&rsquo;.
</p>



<h4>Summaries</h4>

<p>The <code>summary</code> method returns a list of the original
NAVseries plus various statistics, such as return per year
and volatility.  The method may receive several NAV series
as input.
</p>



<h3>Value</h3>

<p>an <code>NAVseries</code>: see Details.
</p>
<p>an <code>NAVseries</code> summary: a list of lists. If a
benchmark series is present, the summary has an
attribute <code>bm</code>: an integer, specifying the
position of the benchmark.
</p>


<h3>Note</h3>

<p>The semantics of handling NAVseries are not stable
yet. Currently, objects of class <code>NAVseries</code> are
univariate: you create a single NAVseries, summarise
it, plot it, and so one. In the future, at least some
of the methods will support the multi-variate case,
i.e. be able to handle several series at once.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2024) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>; in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#NAVseries">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#NAVseries</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btest">btest</a></code>, <code><a href="#topic+journal">journal</a></code>
</p>
<p>For handling external cashflows, see <code><a href="#topic+unit_prices">unit_prices</a></code>,
<code><a href="#topic+split_adjust">split_adjust</a></code> and <code><a href="#topic+div_adjust">div_adjust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(NAVseries(DAX[[1]], as.Date(row.names(DAX)), title = "DAX"))
</code></pre>

<hr>
<h2 id='pl'>
Profit and Loss
</h2><span id='topic+pl'></span><span id='topic+.pl'></span><span id='topic+.pl_stats'></span><span id='topic+pl.data.frame'></span><span id='topic+pl.default'></span><span id='topic+pl.journal'></span><span id='topic+pl.pl'></span><span id='topic+print.pl'></span><span id='topic+as.data.frame.pl'></span>

<h3>Description</h3>

<p>Compute profit and (or) loss of financial transactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pl(amount, ... )

## Default S3 method:
pl(amount, price, timestamp = NULL,
   instrument = NULL, multiplier = 1,
   multiplier.regexp = FALSE,
   along.timestamp = FALSE, approx = FALSE,
   initial.position = NULL, initial.price = NULL,
   vprice = NULL, tol = 1e-10, do.warn = TRUE,
   do.sum = FALSE, pl.only = FALSE,
   footnotes = TRUE, ... )

## S3 method for class 'journal'
pl(amount, multiplier = 1,
   multiplier.regexp = FALSE,
   along.timestamp = FALSE, approx = FALSE,
   initial.position = NULL, initial.price = NULL,
   vprice = NULL, tol = 1e-10, do.warn = TRUE, ... )

## S3 method for class 'pl'
pl(amount, ... )

## S3 method for class 'pl'
print(x, ..., use.crayon = NULL, na.print = ".",
        footnotes = TRUE)

## S3 method for class 'pl'
as.data.frame(x, ... )

.pl(amount, price, tol = 1e-10, do.warn = TRUE)
.pl_stats(amount, price, tol = sqrt(.Machine$double.eps))

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pl_+3A_amount">amount</code></td>
<td>
<p>numeric or a <code><a href="#topic+journal">journal</a></code></p>
</td></tr>
<tr><td><code id="pl_+3A_price">price</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code id="pl_+3A_instrument">instrument</code></td>
<td>
<p>character or numeric (though
typically character)</p>
</td></tr>
<tr><td><code id="pl_+3A_timestamp">timestamp</code></td>
<td>
<p>An atomic vector of mode
<code><a href="base.html#topic+numeric">numeric</a></code> or <code><a href="base.html#topic+character">character</a></code>.
Timestamps should typically be sortable.</p>
</td></tr>
<tr><td><code id="pl_+3A_along.timestamp">along.timestamp</code></td>
<td>
<p>logical; or a a vector of
timestamps. If the latter, <code>vprice</code> must be
specified as well. See the vignette
&ldquo;Profit/Loss for Open Positions&rdquo;
(<code>pl_open_positions</code>) for details.  Timestamps
must be in ascending order and will be sorted if
they are not (and <code>vprice</code> will then be sorted
as well).</p>
</td></tr>
<tr><td><code id="pl_+3A_initial.position">initial.position</code></td>
<td>

<p>a <code><a href="#topic+position">position</a></code>
</p>
</td></tr>
<tr><td><code id="pl_+3A_initial.price">initial.price</code></td>
<td>

<p>prices to evaluate initial position
</p>
</td></tr>
<tr><td><code id="pl_+3A_vprice">vprice</code></td>
<td>

<p>valuation price; a numeric vector. With several instruments, the
prices must be named, e.g. <code>c(stock1 = 100, stock2 = 101)</code>.
See Details.
</p>
</td></tr>
<tr><td><code id="pl_+3A_multiplier">multiplier</code></td>
<td>

<p>numeric vector. When <code>instrument</code> is specified
and the vector is named, the names will be matched
against instruments.
</p>
</td></tr>
<tr><td><code id="pl_+3A_multiplier.regexp">multiplier.regexp</code></td>
<td>

<p>logical. If <code>TRUE</code>, the names of
<code>multiplier</code> are interpreted as regular
expressions. See Examples.
</p>
</td></tr>
<tr><td><code id="pl_+3A_approx">approx</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="pl_+3A_tol">tol</code></td>
<td>
<p>numeric: threshold to consider a position zero.</p>
</td></tr>
<tr><td><code id="pl_+3A_x">x</code></td>
<td>
<p>a <code>pl</code> object to be printed or to be coerced to a data.frame</p>
</td></tr>
<tr><td><code id="pl_+3A_...">...</code></td>
<td>
<p>further argument</p>
</td></tr>
<tr><td><code id="pl_+3A_use.crayon">use.crayon</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="pl_+3A_na.print">na.print</code></td>
<td>
<p>character: how to print <code>NA</code> values</p>
</td></tr>
<tr><td><code id="pl_+3A_do.warn">do.warn</code></td>
<td>
<p>logical: issue warnings?</p>
</td></tr>
<tr><td><code id="pl_+3A_do.sum">do.sum</code></td>
<td>
<p>logical: sum profit/loss across instruments?</p>
</td></tr>
<tr><td><code id="pl_+3A_pl.only">pl.only</code></td>
<td>
<p>logical: if <code>TRUE</code>, return only
numeric vector of profit/loss</p>
</td></tr>
<tr><td><code id="pl_+3A_footnotes">footnotes</code></td>
<td>

<p>logical, with default <code>TRUE</code>:
collect and print notes?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes profit and/or loss and returns a list with
several statistics (see Section Value, below). To get only
the profit/loss numbers as a numeric vector, set argument
<code>pl.only</code> to <code>TRUE</code>.
</p>
<p><code>pl</code> is a generic function: The default input is
vectors for amount, price, etc. Alternatively (and often
more conveniently), the function may also be called with a
<code><a href="#topic+journal">journal</a></code> or a <code><a href="base.html#topic+data.frame">data.frame</a></code> as its
input. For data frames, columns must be named
<code>amount</code>, <code>price</code>, and so on, as in a
<code><a href="#topic+journal">journal</a></code>.
</p>
<p><code>pl</code> may be called in two ways: either to compute
<em>total profit/loss</em> from a list of trades, possibly
broken down by <code>instrument</code> and <code>account</code>; or to
compute <em>profit/loss over time</em>. The latter case
typically requires setting arguments
<code>along.timestamp</code> and/or <code>vprice</code> (see
Examples).  Profit/loss over time is always computed with
time in ascending order: so if the timestamps in
<code>along.timestamp</code> are not sorted, the function will
sort them (and <code>vprice</code> as well).
</p>
<p>Using <code>vprice</code>: when <code>along.timestamp</code> is
logical (<code>FALSE</code> or <code>TRUE</code>),
<code>vprice</code> can be used to value an open
position. For a single asset, it should be a single
number; for several assets, it should be named
vector, with names indicating the <code>instrument</code>.
When <code>along.timestamp</code> is used to pass a
custom timestamp: for a single asset, <code>vprice</code>
must be a vector with the same length as
<code>along.timestamp</code>; for several assets, it must
be a numeric matrix with dimension
<code>length(along.timestamp)</code> times number of
assets.
</p>
<p><code>.pl</code> and <code>.pl_stats</code> are helper functions
that are called by <code>pl</code>.  <code>.pl_stats</code>
requires amount and price to be sorted in time, and
to be of length &gt; 0.
</p>
<p>To use package <span class="pkg">crayon</span> &ndash; which is only sensible
in interactive use &ndash;, either explicitly set
<code>use.crayon</code> to <code>TRUE</code> or set an option
<code>PMwR.use.crayon</code> to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>For <code>pl</code>, an object of class <code>pl</code>, which is
a list of lists: one list for each instrument. Each
such list contains numeric vectors: <code>pl</code>,
<code>realised</code>, <code>unrealised</code>, <code>buy</code>,
<code>sell</code>, <code>volume</code>. If <code>along.timestamp</code>
is not <code><a href="base.html#topic+FALSE">FALSE</a></code>, a vector <code>timestamp</code>
is also present.
</p>
<p>For <code>.pl</code>, a numeric vector with four elements:
profit/loss in units of the instrument, sum of
absolute amounts, average buy price, average sell
price. For zero-length vector, the function evaluates to
<code>c(0, 0, NaN, NaN)</code>.
</p>
<p>For <code>.pl_stats</code>, a list of two elements:
the average entry-price, and the realized profit/loss.
profit/loss in units of the instrument, sum of
absolute amounts, average buy price, average sell
price. For zero-length vector, the function evaluates to
<code>c(0, 0, NaN, NaN)</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>; in particular
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#profit-and-loss">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#profit-and-loss</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btest">btest</a></code>, <code><a href="#topic+returns">returns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>J &lt;- journal(timestamp = c(  1,   2,   3),
             amount    = c(  1,   1,  -2),
             price     = c(100, 102, 101))
pl(J)

pl(amount = c(  1,   1,  -2),
   price  = c(100, 102, 101))  ## without a 'journal'


J &lt;- journal(timestamp  = c(  1,   2,   3,   1,   2,   3),
             amount     = c(  1,   1,  -2,   1,   1,  -2),
             price      = c(100, 102, 101, 100, 102, 105),
             instrument = c(rep("Bond A", 3), rep("Bond B", 3)))

pl(J)
## Bond A
##   P/L total       0
##   average buy   101
##   average sell  101
##   cum. volume     4
##
## Bond B
##   P/L total       8
##   average buy   101
##   average sell  105
##   cum. volume     4
##
## 'P/L total' is in units of instrument;
## 'volume' is sum of /absolute/ amounts.

as.data.frame(pl(J))  ## a single data.frame
##        pl buy sell volume
## Bond A  0 101  101      4
## Bond B  8 101  105      4

lapply(pl(J), as.data.frame)  ## =&gt; a list of data.frames
## $`Bond A`
##   pl realised unrealised buy sell volume
## 1  0       NA         NA 101  101      4
##
## $`Bond B`
##   pl realised unrealised buy sell volume
## 1  8       NA         NA 101  105      4

pl(pl(J))  ## P/L as a numeric vector
## Bond A Bond B
##      0      8




## Example for 'vprice'
instrument  &lt;- c(rep("Bond A", 2), rep("Bond B", 2))
amount &lt;- c(1, -2, 2, -1)
price &lt;- c(100, 101, 100, 105)

## ... no p/l because positions not closed:
pl(amount, price, instrument = instrument, do.warn = FALSE)

## ... but with vprice specified, p/l is computed:
pl(amount, price, instrument = instrument,
   vprice = c("Bond A" = 103, "Bond B" = 100))

### ... and is, except for volume, the same as here:
instrument  &lt;- c(rep("Bond A", 3), rep("Bond B", 3))
amount &lt;- c(1, -2, 1, 2, -1, -1)
price &lt;- c(100, 101, 103, 100, 105, 100)
pl(amount, price, instrument = instrument)



## p/l over time: example for 'along.timestamp' and 'vprice'
j &lt;- journal(amount = c(1, -1),
             price = c(100, 101),
             timestamp  = as.Date(c("2017-07-05", "2017-07-06")))
pl(j)

pl(j,
   along.timestamp = TRUE)

pl(j,
   along.timestamp = seq(from = as.Date("2017-07-04"),
                         to = as.Date("2017-07-07"),
                         by = "1 day"),
   vprice = 101:104)



## Example for 'multiplier'
jnl &lt;- read.table(text =
"instrument, price, amount
 FGBL MAR 16, 165.20,  1
 FGBL MAR 16, 165.37, -1
 FGBL JUN 16, 164.12,  1
 FGBL JUN 16, 164.13, -1
 FESX JUN 16,   2910,  5
 FESX JUN 16,   2905, -5",
header = TRUE, stringsAsFactors = FALSE, sep = ",")


jnl &lt;- as.journal(jnl)
pl(jnl,  multiplier.regexp = TRUE, ## regexp matching is case sensitive
   multiplier = c("FGBL" = 1000, "FESX" = 10))



## use package 'crayon'
## Not run: 
## on Windows, you may also need 'options(crayon.enabled = TRUE)'
options(PMwR.use.crayon = FALSE)
pl(amount = c(1, -1), price = c(1, 2))
options(PMwR.use.crayon = TRUE)
pl(amount = c(1, -1), price = c(1, 2))

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_trading_hours'>
Plot Time Series During Trading Hours
</h2><span id='topic+plotTradingHours'></span><span id='topic+plot_trading_hours'></span>

<h3>Description</h3>

<p>Plot a time series after removing weekends and specific times of the day.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_trading_hours(x, t = NULL, interval = "5 min",
                   labels = "hours", label.format = NULL,
                   exclude.weekends = TRUE, holidays = NULL,
                   fromHHMMSS = "000000", toHHMMSS = "240000",
                   do.plot.axis = TRUE,
                   ...,
                   from = NULL, to = NULL,
                   do.plot = TRUE,
                   axis1.par = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_trading_hours_+3A_x">x</code></td>
<td>

<p>A numeric vector. Can also be of class <code>zoo</code>.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_t">t</code></td>
<td>

<p>A vector that inherits from class <code>POSIXt</code>. If <code>x</code>
inherits from class <code>zoo</code>, then <code>index(x)</code> is used (and
any supplied value for <code>t</code> is ignored).
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_interval">interval</code></td>
<td>

<p>A character string like &ldquo;num units&rdquo;, in which <code>num</code> is a
number, and <code>units</code> is &ldquo;sec&rdquo;, &ldquo;min&rdquo;,
&ldquo;hour&rdquo; or &ldquo;day&rdquo;. The space between num and
units is mandatory.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_labels">labels</code></td>
<td>

<p>A character vector of length one, determining the grid for
<code>plot_trading_hours</code>: can be &ldquo;hour&rdquo;, &ldquo;day&rdquo;,
&ldquo;dayhour&rdquo; or &ldquo;month&rdquo;.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_label.format">label.format</code></td>
<td>

<p>See <code><a href="base.html#topic+strftime">strftime</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_exclude.weekends">exclude.weekends</code></td>
<td>

<p>logical: default is <code>TRUE</code>
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_holidays">holidays</code></td>
<td>

<p>a vector of class <code><a href="base.html#topic+Date">Date</a></code> or a character
vector in a format that is understood by <code><a href="base.html#topic+as.Date">as.Date</a></code>.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_fromhhmmss">fromHHMMSS</code></td>
<td>

<p>a character vector of length one in format &ldquo;HHMMSS&rdquo;
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_tohhmmss">toHHMMSS</code></td>
<td>

<p>a character vector of length one in format &ldquo;HHMMSS&rdquo;
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_do.plot.axis">do.plot.axis</code></td>
<td>

<p>logical. Should <code>axis(1)</code> be plotted? Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_...">...</code></td>
<td>

<p>parameters passed to <code><a href="base.html#topic+plot">plot</a></code>
(and typically <code><a href="graphics.html#topic+par">par</a></code>)
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_from">from</code></td>
<td>

<p>POSIXct: start plot at (if not specified,
plot starts at first data point)
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_to">to</code></td>
<td>

<p>POSIXct: end plot at (if not specified,
plot ends at last data point)
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_do.plot">do.plot</code></td>
<td>

<p>logical. Should anything be plotted? Default is <code>TRUE</code>. If
<code>FALSE</code>, the function returns a list of points.
</p>
</td></tr>
<tr><td><code id="plot_trading_hours_+3A_axis1.par">axis1.par</code></td>
<td>

<p>a list of named elements
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot a timeseries during specific times of day.
</p>


<h3>Value</h3>

<p>A list (invisibly if <code>do.plot</code> is <code>TRUE</code>):
</p>
<p><code>list(t, x, axis.pos = pos, axis.labels, timegrid)</code>
</p>
<table role = "presentation">
<tr><td><code>t</code></td>
<td>
<p>positions</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>values</p>
</td></tr>
<tr><td><code>axis.pos</code></td>
<td>
<p>positions of x-tickmarks</p>
</td></tr>
<tr><td><code>axis.labels</code></td>
<td>
<p>labels at x-ticks</p>
</td></tr>
<tr><td><code>timegrid</code></td>
<td>
<p>a POSIXct vector</p>
</td></tr>
<tr><td><code>map</code></td>
<td>
<p>a function. See the manual (a link is under References).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>B.D. Ripley and K. Hornik. <em>Date-Time Classes</em>. R-News,
<strong>1</strong>(2):8&ndash;12, 2001.
</p>
<p>E. Schumann (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>; in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#plot-trading-hours">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#plot-trading-hours</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+DateTimeClasses">DateTimeClasses</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- as.POSIXct("2012-08-31 08:00:00") + 0:32400
x &lt;- runif(length(t))

par(tck = 0.001, mgp = c(3,1,0.5), bty = "n")
p &lt;- plot_trading_hours(x, t,
                        interval = "5 min", labels = "hours",
                        xlab = "time", ylab = "random points",
                        col = "blue")


## with ?lines
t &lt;- as.POSIXct("2012-08-31 10:00:00") + 0:9000
x &lt;- seq(0, 1, length.out = 9001)
lines(p$map(t)$t, x[p$map(t)$ix], pch = 19)

</code></pre>

<hr>
<h2 id='PMwR-internal'>Internal Functions</h2><span id='topic+PMwR-internal'></span><span id='topic+.timestamp'></span><span id='topic+.timestamp+3C-'></span><span id='topic+.may_be_Date'></span>

<h3>Description</h3>

<p>Internal functions, not exported from the <span class="pkg">PMwR</span> namespace.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.timestamp(x)
.timestamp(x) &lt;- value

.may_be_Date(x, ...)
</code></pre>


<h3>Details</h3>

<p><code>.timestamp</code> extracts or replaces an object's timestamp.
</p>
<p><code>.may_be_Date</code> checks whether a vector could be
coerced to class <code><a href="base.html#topic+Date">Date</a></code>, in which case it
evaluates to (a single) <code>TRUE</code>; otherwise it returns
<code>FALSE</code>. If <code>TRUE</code>, the actual <code>Date</code>s are
attached as an attribute <code>Date</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>E. Schumann (2023) <em>Portfolio Management with <span class="rlang"><b>R</b></span></em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>
</p>

<hr>
<h2 id='position'>
Aggregate Transactions to Positions
</h2><span id='topic+position'></span><span id='topic+position.default'></span><span id='topic+position.journal'></span><span id='topic+print.position'></span><span id='topic+as.matrix.position'></span>

<h3>Description</h3>

<p>Use information on single trades to compute a
position at a specific point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>position(amount, ...)

## Default S3 method:
position(amount, timestamp, instrument, when,
                 drop.zero = FALSE, account = NULL,
                 use.names = NULL, ...)

## S3 method for class 'journal'
position(amount, when, drop.zero = FALSE,
                           use.account = FALSE, ...)

## S3 method for class 'position'
print(x, ..., sep = ":")

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="position_+3A_when">when</code></td>
<td>

<p>a timestamp or a vector of timestamps;
alternatively, several keywords are supported. See Details.
</p>
</td></tr>
<tr><td><code id="position_+3A_amount">amount</code></td>
<td>

<p>numeric or an object of class <code><a href="#topic+journal">journal</a></code>
</p>
</td></tr>
<tr><td><code id="position_+3A_timestamp">timestamp</code></td>
<td>

<p>numeric or character: timestamps, must be sortable
</p>
</td></tr>
<tr><td><code id="position_+3A_instrument">instrument</code></td>
<td>

<p>character: symbols to identify different instruments
</p>
</td></tr>
<tr><td><code id="position_+3A_account">account</code></td>
<td>

<p>character: description of account. Ignored if <code><a href="base.html#topic+NULL">NULL</a></code>.
</p>
</td></tr>
<tr><td><code id="position_+3A_use.account">use.account</code></td>
<td>

<p>logical. If <a href="base.html#topic+TRUE">TRUE</a>, positions are computed by
account and instrument; otherwise by instrument only.
</p>
</td></tr>
<tr><td><code id="position_+3A_use.names">use.names</code></td>
<td>

<p>logical or <code>NULL</code>. The argument handles whether names
of <code>amount</code> are used as instruments. If <code>NULL</code>:
if <code>amount</code> is named and <code>instrument</code> is not
specified, names of <code>amount</code> are interpreted as
instruments. If <code>use.names</code> is <code>FALSE</code>, names of
<code>amount</code> are ignored. (Ignoring names was the default
behaviour prior to PMwR version 0.11.)
</p>
</td></tr>
<tr><td><code id="position_+3A_drop.zero">drop.zero</code></td>
<td>

<p>If logical, drop instruments that have a zero position;
default is <code>FALSE</code>. If numeric, it is used as a
tolerance; e.g., a value of <code>1-e12</code> will drop any
position whose absolute amount is smaller than
<code>1-e12</code>.
</p>
</td></tr>
<tr><td><code id="position_+3A_x">x</code></td>
<td>

<p>An object of type position.
</p>
</td></tr>
<tr><td><code id="position_+3A_...">...</code></td>
<td>

<p>arguments passed to <code><a href="base.html#topic+print">print</a></code>
</p>
</td></tr>
<tr><td><code id="position_+3A_sep">sep</code></td>
<td>

<p>A regular expression. Split instruments accordingly.
<strong>Not implemented yet.</strong>
</p>
</td></tr>
</table>


<h3>Details</h3>


<p><code>position</code> computes positions for lists of trades.
<code>position</code> is a generic function; most useful is the
method for <code><a href="#topic+journal">journal</a></code>s.
</p>
<p>The function checks if <code>timestamp</code> is sorted (see
<code><a href="base.html#topic+is.unsorted">is.unsorted</a></code>) and sorts the journal by
<code>timestamp</code>, if required. If there are (some) <code>NA</code>
values in <code>timestamp</code>, but <code>timestamp</code> is sorted
otherwise, the function will proceed (with a warning,
though).
</p>
<p>The argument <code>when</code> can also be specified as one of
several keywords: <code>last</code> (or <code>newest</code> or
<code>latest</code>) provides the position at the latest
timestamp; <code>first</code> (or <code>oldest</code>) provides the
position at the earliest timestamp; <code>all</code> provides the
positions at all timestamps in the journal. <code>endofday</code>,
<code>endofmonth</code> and <code>endofyear</code> provide positions at
the end of all calendar days, months and years within the
timestamp range of the journal. The latter keywords can only
work if <code>timestamp</code> can be coerced to
<code><a href="base.html#topic+Date">Date</a></code>.
</p>


<h3>Value</h3>


<p>An object of class <code>position</code>, which is a numeric
matrix with <code>instrument</code> and <code>timestamp</code>
attributes. Note that <code>position</code> will never drop the
result's <code>dim</code> attribute: it will always be a matrix of
size <code>length(when)</code> times
<code>length(unique(instrument))</code>, which may not be obvious
from the printed output.  The rows of the matrix correspond
to timestamps; the columns correspond to instruments.
</p>
<p>To extract the numeric position matrix, say
<code>as.matrix(p)</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with <span class="rlang"><b>R</b></span></em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>;
in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#computing-balances">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#computing-balances</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+journal">journal</a></code>; internal computations are handled by
<code><a href="base.html#topic+cumsum">cumsum</a></code> and <code><a href="base.html#topic+findInterval">findInterval</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>position(amount = c(1, 1, -1, 3, -4),
         timestamp = 1:5, when = 4.9)

## using a journal
J &lt;- journal(timestamp = 1:5, amount = c(1, 1, -1, 3, -4))
position(J, when = 4.9)


## 'declaring' a position, using named amounts
amount &lt;- c(1, 1, 1)
instrument &lt;- c("A", "A", "B")
position(amount = amount, instrument = instrument)
## .... or equivalently
amount &lt;- c(A = 2, B = 1)
position(amount)

## ignore names of amount
position(amount, use.names = FALSE)
</code></pre>

<hr>
<h2 id='pricetable'>
Price Table
</h2><span id='topic+pricetable'></span><span id='topic++5B.pricetable'></span>

<h3>Description</h3>

<p>Create price table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pricetable(price, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pricetable_+3A_price">price</code></td>
<td>

<p>a matrix
</p>
</td></tr>
<tr><td><code id="pricetable_+3A_...">...</code></td>
<td>

<p>further arguments, passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>pricetable</code> is a helper function for extracting
prices of particular instrument at specified dates.
For this, it first creates a table that merges series
passed via ... and appends a class attribute. A <code>[</code>
method then allows to extract prices. Importantly, if
you ask for a subset of <em>m</em> rows and <em>n</em> columns, the
result will be a matrix of size <em>m</em> times <em>n</em>, even if
times or instruments are missing.
</p>
<p><code>pricetable</code> is a generic function, currently
with methods for numeric vectors (including vectors
with a <code><a href="base.html#topic+dim">dim</a></code>, aka matrices) and for
<code><a href="zoo.html#topic+zoo">zoo</a></code> objects.
</p>


<h3>Value</h3>

<p>a numeric matrix with class attribute <code>pricetable</code>
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+match">match</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## quickly creating a pricetable
pricetable(1:3)
pricetable(1:3, instrument = c("A", "B", "C"))
### ... and the same
pricetable(c(A = 1, B = 2, C = 3))


## subsetting examples
m &lt;- 3
n &lt;- 2
price &lt;- array(c(1:m, 1:m + 100), dim = c(m,n))
colnames(price) &lt;- LETTERS[1:n]
pt &lt;- pricetable(price, timestamp = 1:m)
##   A   B
## 1 1 101
## 2 2 102
## 3 3 103

pt[ , "A"]
##   A
## 1 1
## 2 2
## 3 3

pt[ , c("X", "A", "X")]
##    X A  X
## 1 NA 1 NA
## 2 NA 2 NA
## 3 NA 3 NA

pt[ , c("X", "A", "X"), missing = 0]
##   X A X
## 1 0 1 0
## 2 0 2 0
## 3 0 3 0

pt[c(0, 1.5, 4), , missing = "locf"]
##      A   B
## 0   NA  NA
## 1.5  2 102
## 4    3 103
</code></pre>

<hr>
<h2 id='quote32'>
Treasury Quotes with 1/32nds of Point
</h2><span id='topic+quote32'></span><span id='topic+q32'></span>

<h3>Description</h3>

<p>Print treasury quotes with 1/32nds of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quote32(price, sep = "(-|'|:)", warn = TRUE)
q32(price, sep = "(-|'|:)", warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quote32_+3A_price">price</code></td>
<td>

<p>numeric or character. See Details.
</p>
</td></tr>
<tr><td><code id="quote32_+3A_sep">sep</code></td>
<td>

<p>character: a regular expression
</p>
</td></tr>
<tr><td><code id="quote32_+3A_warn">warn</code></td>
<td>

<p>logical. Warn about rounding errors?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is meant for pretty-printing of US
treasury bond quotes; it provides no other
functionality.
</p>
<p>If <code>price</code> is <code>numeric</code>, it is interpreted as a quote in
decimal notation and &lsquo;translated&rsquo; into a price quoted in
fractions of a point.
</p>
<p>If <code>price</code> is <code>character</code>, it is interpreted as a quote in
fractional notation.
</p>
<p><code>q32</code> is a short-hand for <code>quote32</code>.
</p>


<h3>Value</h3>

<p>A numeric vector of class <code>quote32</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>CME Group (2020). <em>Treasury Futures Price Rounding Conventions.</em>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>quote32(100 + 17/32 + 0.75/32)
q32("100-172")

q32("100-272") - q32("100-270")
as.numeric(q32("100-272") - q32("100-270"))
</code></pre>

<hr>
<h2 id='rc'>
Return Contribution
</h2><span id='topic+rc'></span>

<h3>Description</h3>

<p>Return contribution of portfolio segments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rc(R, weights, timestamp, segments = NULL,
   R.bm = NULL, weights.bm = NULL,
   method = "contribution",
   linking.method = NULL,
   allocation.minus.bm = TRUE,
   tol = sqrt(.Machine$double.eps))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rc_+3A_r">R</code></td>
<td>

<p>returns: a numeric matrix
</p>
</td></tr>
<tr><td><code id="rc_+3A_weights">weights</code></td>
<td>

<p>the segment weights: a numeric matrix.
<code>weights[i, j]</code> must correspond to <code>R[i, j]</code>
</p>
</td></tr>
<tr><td><code id="rc_+3A_timestamp">timestamp</code></td>
<td>

<p>character or numeric
</p>
</td></tr>
<tr><td><code id="rc_+3A_segments">segments</code></td>
<td>

<p>character. If missing, column names of <code>R</code> or of
<code>weights</code> are used (if they are not <code>NULL</code>).
</p>
</td></tr>
<tr><td><code id="rc_+3A_method">method</code></td>
<td>
<p>a string; default is <code>contribution</code></p>
</td></tr>
<tr><td><code id="rc_+3A_linking.method">linking.method</code></td>
<td>
<p><code>NULL</code> or a string. Currently
supported are <code>0-cumulative, 1-cumulative, 0.5-cumulative</code>
(<code>geometric{0,1,0.5}</code>) and <code>logarithmic</code>. See Examples.</p>
</td></tr>
<tr><td><code id="rc_+3A_allocation.minus.bm">allocation.minus.bm</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="rc_+3A_tol">tol</code></td>
<td>

<p>numeric: weights whose absolute value is below
<code>tol</code> are considered zero and not used for
computations. Ignored if <code><a href="base.html#topic+NA">NA</a></code>.
</p>
</td></tr>
</table>
<p>If portfolio returns are to be compared against benchmark
returns, benchmark returns and weights must be supplied:
</p>
<table role = "presentation">
<tr><td><code id="rc_+3A_r.bm">R.bm</code></td>
<td>

<p>benchmark returns: a numeric matrix
</p>
</td></tr>
<tr><td><code id="rc_+3A_weights.bm">weights.bm</code></td>
<td>

<p>the benchmark weights of segments: a numeric matrix.
<code>weights.bm[i, j]</code> must correspond to <code>R.bm[i, j]</code>
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The function computes segment contribution, potentially
over time.  Returns and weights must be arranged in
matrices, with rows corresponding to time periods and
columns to portfolio segments.  If <code>weights</code> and
<code>R</code> are atomic vectors, then they are interpreted as
cross-sectional weights/returns for a single period,
i.e. they are handled like row vectors.
</p>
<p>Weights can be missing, in which case <code>R</code> is assumed
to already comprise segment returns.
</p>
<p>Note that the segment contributions need not come from
asset classes; the computation works for any additive
single-period decomposition of portfolio returns.
</p>


<h3>Value</h3>


<p>A list of two components:
</p>
<table role = "presentation">
<tr><td><code>period_contributions</code></td>
<td>
<p>a data.frame of single-period
contributions, sorted in time</p>
</td></tr>
<tr><td><code>total_contributions</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>David R. Cariño (1999).
Combining Attribution Effects Over Time.
Journal of Performance Measurement.
<strong>3</strong> (4), 5&ndash;14.
</p>
<p>Jon A. Christopherson and David R. Cariño and
Wayne E. Ferson (2009),
<em>Portfolio Performance Measurement and Benchmarking</em>,
McGraw-Hill.
</p>
<p>Feibel, Bruce (2003), <em>Investment Performance Measurement</em>,
Wiley.
</p>
<p>Erik Valtonen (2002).
Incremental Attribution with and without Notional Portfolios.
Journal of Performance Measurement.
<strong>7</strong> (1), 68&ndash;83.
</p>
<p><a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#return-contribution">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#return-contribution</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+returns">returns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>weights &lt;- rbind(c( 0.25, 0.75),
                 c( 0.40, 0.60),
                 c( 0.25, 0.75))

R &lt;- rbind(c( 1  ,    0),
           c( 2.5, -1.0),
           c(-2  ,  0.5))/100

rc(R, weights, segment = c("equities", "bonds"))



## EXAMPLE of Christopherson et al., ch 19
weights &lt;- cbind(stocks = c(0.5,  0.55),
                 bonds  = c(0.5, 0.45))
##      stocks bonds
## [1,]   0.50  0.50
## [2,]   0.55  0.45

R &lt;- cbind(stocks = c(.4, 0.1),
           bonds  = c(.1, 0.2))
##      stocks bonds
## [1,]    0.4   0.1
## [2,]    0.1   0.2

## ==&gt; contributions grow at portfolio rate-of-return
rc(R, weights, linking.method =  "geometric1")

## ==&gt; contributions are made on top of current portfolio-value
rc(R, weights, linking.method =  "geometric0")

## ==&gt; mixture
rc(R, weights, linking.method =  "geometric0.5")



## EXAMPLE from
## https://quant.stackexchange.com/questions/36520/
##         how-to-calculate-the-annual-contribution-of-a-fund-to-a-portfolio-of-funds/
##         36530#36530
## (unbreak the URL)

weights &lt;- rbind(c( 0.5, 0.5),
                 c( 0.5, 0.5))

R &lt;- rbind(c( 10,   0),
           c( 0 ,  10))/100


rc(R, weights, segment = c("F1", "F2"), timestamp = 1:2,
   linking.method = "geometric1")
## ==&gt; F1 contributed first, and so gets a higher total
##     contribution

rc(R, weights, segment = c("F1", "F2"), timestamp = 1:2,
   linking.method = "geometric0")
## ==&gt; F2 contributed later, and so gets a higher total
##     contribution because it started off a higher base
##     value




## contribution for btest:
##   run a portfolio 10% equities, 90% bonds
P &lt;- as.matrix(merge(DAX, REXP, by = "row.names")[, -1])
(bt &lt;- btest(prices = list(P),
            signal = function() c(0.1, 0.9),
            convert.weights = TRUE,
            initial.cash = 100))

W &lt;- bt$position*P/bt$wealth
rc(returns(P)*W[-nrow(W), ])$total_contributions
</code></pre>

<hr>
<h2 id='rebalance'>
Rebalance Portfolio
</h2><span id='topic+rebalance'></span><span id='topic+replace_weight'></span><span id='topic+print.rebalance'></span>

<h3>Description</h3>

<p>Compute the differences between two portfolios.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rebalance(current, target, price,
          notional = NULL, multiplier = 1,
          truncate = TRUE, match.names = TRUE,
          fraction = 1, drop.zero = FALSE,
          current.weights = FALSE,
          target.weights = TRUE)

## S3 method for class 'rebalance'
print(x, ..., drop.zero = TRUE)

replace_weight(weights, ..., prefix = TRUE, sep = "::")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rebalance_+3A_current">current</code></td>
<td>

<p>the current holdings: a (typically named) vector of position sizes;
can also be a <code>position</code>
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_target">target</code></td>
<td>

<p>the target holdings: a (typically named) vector of weights;
can also be a <code>position</code>
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_price">price</code></td>
<td>

<p>a numeric vector: the current prices; may be named
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_notional">notional</code></td>
<td>

<p>a single number: the value of the portfolio; if missing,
replaced by <code>sum(current*prices)</code>
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_multiplier">multiplier</code></td>
<td>

<p>numeric vector, possibly named
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_truncate">truncate</code></td>
<td>

<p>truncate computed positions? Default is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_match.names">match.names</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_fraction">fraction</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_x">x</code></td>
<td>

<p>an object of class <code>rebalance</code>.
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_...">...</code></td>
<td>

<p><code>rebalance</code>: arguments passed to <code><a href="base.html#topic+print">print</a></code>;
<code>replace_weight</code>: numeric vectors
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_drop.zero">drop.zero</code></td>
<td>

<p>logical: should instruments with no difference
between <code>current</code> and <code>target</code> be included?
</p>
<p>Note the different defaults for computing and
printing.
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_current.weights">current.weights</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), the values in <code>current</code> are
interpreted as weights. If <code>FALSE</code>, <code>current</code> is
interpreted as a position (i.e. notional/number of contracts).
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_target.weights">target.weights</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), the values in <code>target</code> are
interpreted as weights. If <code>FALSE</code>, <code>target</code> is
interpreted as a position (i.e. notional/number of contracts).
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_weights">weights</code></td>
<td>

<p>a numeric vector with named components
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_sep">sep</code></td>
<td>

<p>character
</p>
</td></tr>
<tr><td><code id="rebalance_+3A_prefix">prefix</code></td>
<td>

<p>logical
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the necessary trades to move from the
<code>current</code> portfolio to a <code>target</code> portfolio.
</p>
<p><code>replace_weight</code> is a helper function to split
baskets into their components. All arguments passed
via <code>...</code> should be named vectors. If names are
not syntactically valid (see
<code><a href="base.html#topic+make.names">make.names</a></code>), quote them. The passed
vectors themselves should be passed as named
arguments: see examples.
</p>


<h3>Value</h3>

<p>An object of class <code>rebalance</code>, which is a
<code>data.frame</code>:
</p>
<table role = "presentation">
<tr><td><code>instrument</code></td>
<td>
<p>character, or <code>NA</code> when
<code>match.names</code> is <code>FALSE</code></p>
</td></tr>
<tr><td><code>price</code></td>
<td>
<p>prices</p>
</td></tr>
<tr><td><code>current</code></td>
<td>
<p>current portfolio, in units of instrument</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>new portfolio, in units of instrument</p>
</td></tr>
<tr><td><code>difference</code></td>
<td>
<p>the difference between <code>current</code>
and target portfolio</p>
</td></tr>
</table>
<p>Attached to the data.frame are several attributes:
</p>
<table role = "presentation">
<tr><td><code>notional</code></td>
<td>
<p>a single number</p>
</td></tr>
<tr><td><code>match.names</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code>multiplier</code></td>
<td>
<p>a numeric vector with as many elements as
the resulting data.frame has rows</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>


<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>;
in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#rebalance">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#rebalance</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+journal">journal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>r &lt;- rebalance(current = c(a = 100, b = 20),
               target  = c(a = 0.2, c = 0.3),
               price   = c(a = 1, b = 2, c = 3))
as.journal(r)

## replace_weight: the passed vectors must be named;
##                 'basket_3' is ignored because not
##                 component of weights is named
##                 'basket_3'

replace_weight(c(basket_1 = 0.3,
                 basket_2 = 0.7),
               basket_1 = c(a = 0.1, b = 0.4, c = .5),
               basket_2 = c(x = 0.1, y = 0.4, z = .5),
               basket_3 = c(X = 0.5, Z = 0.5),
               sep = "|")
</code></pre>

<hr>
<h2 id='returns'>
Compute Returns
</h2><span id='topic+returns'></span><span id='topic+.returns'></span><span id='topic+p_returns'></span><span id='topic+returns.default'></span><span id='topic+returns.zoo'></span><span id='topic+print.p_returns'></span><span id='topic+toLatex.p_returns'></span><span id='topic+toHTML.p_returns'></span>

<h3>Description</h3>

<p>Convert prices into returns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returns(x, ...)

## Default S3 method:
returns(x, t = NULL, period = NULL, complete.first = TRUE,
        pad = NULL, position = NULL,
        weights = NULL, rebalance.when = NULL,
        lag = 1, na.rm = FALSE, ..., na.warn = FALSE)

## S3 method for class 'zoo'
returns(x, period = NULL, complete.first = TRUE,
        pad = NULL, position = NULL,
        weights = NULL, rebalance.when = NULL, lag = 1, na.rm = FALSE, ...)

## S3 method for class 'p_returns'
print(x, ..., year.rows = TRUE, month.names = NULL,
      zero.print = "0", plus = FALSE, digits = 1,
      na.print = NULL)

## S3 method for class 'p_returns'
toLatex(object, ...,
        year.rows = TRUE, ytd = "YTD", month.names = NULL,
        eol = "\\\\", stand.alone = FALSE)

## S3 method for class 'p_returns'
toHTML(x, ...,
       year.rows = TRUE, ytd = "YTD", month.names = NULL,
       stand.alone = TRUE, table.style = NULL, table.class = NULL,
       th.style = NULL, th.class = NULL,
       td.style = "text-align:right; padding:0.5em;",
       td.class = NULL, tr.style = NULL, tr.class = NULL,
       browse = FALSE)

.returns(x, pad = NULL, lag)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="returns_+3A_x">x</code></td>
<td>

<p>for the default method, a <code>numeric</code>
vector (possibly with a <code>dim</code> attribute;
i.e. a matrix) of prices.  <code>returns</code> also
supports <code>x</code> of other classes, such as
<code>zoo</code> or <code><a href="#topic+NAVseries">NAVseries</a></code>. For
time-series classes, argument <code>t</code> should be
<code>NULL</code>.
</p>
<p>For <code>.returns</code>, <code>x</code> must be
<code>numeric</code> (for other classes, <code>.returns</code>
may not work properly).
</p>
</td></tr>
<tr><td><code id="returns_+3A_t">t</code></td>
<td>

<p>timestamps. See arguments <code>period</code> and
<code>rebalance.when</code>.
</p>
</td></tr>
<tr><td><code id="returns_+3A_period">period</code></td>
<td>

<p>Typically a string. Supported are <code>"hour"</code>,
<code>"day"</code>, <code>"month"</code>, <code>"quarter"</code>,
<code>"year"</code>, <code>"ann"</code> (annualised), <code>"ytd"</code>
(year-to-date), <code>"mtd"</code> (month-to-date),
<code>"itd"</code> (inception-to-date) or a single year, such
as &quot;2012&quot;. Instead of <code>"itd"</code>, <code>"total"</code> may
also be used.  The value of &lsquo;period&rsquo; is used
only when timestamp information is available: for
instance, when <code>t</code> is not <code>NULL</code> or with
<code>zoo</code>/<code>xts</code> objects. The exception is
<code>"itd"</code>, which can be computed without timestamp
information.  Holding period <code>"ytd"</code> produces a
warning if the current year (as obtained from
<code><a href="base.html#topic+Sys.Date">Sys.Date</a></code>) differs from the latest
timestamp of the series.  Specifying period as
<code>"ytd!"</code> suppresses the warning.
</p>
<p>All returns are computed as simple returns. They will
only be annualised with option <code>"ann"</code>; they will
not be annualised when the length of the time series is
less than one year. To force annualising in such a
case, use <code>"ann!"</code>. Annualisation can only work
when the timestamp <code>t</code> can be coerced to class
<code><a href="base.html#topic+Date">Date</a></code>. The result will have an attribute
<code>is.annualised</code>, which is a logical vector of
length one.  Day-count convention for annualisation is
act/365.
</p>
</td></tr>
<tr><td><code id="returns_+3A_complete.first">complete.first</code></td>
<td>

<p>logical. For holding-period returns such an monthly or
yearly, should the first period (if incomplete) be
used.
</p>
</td></tr>
<tr><td><code id="returns_+3A_pad">pad</code></td>
<td>

<p>either <code>NULL</code> (no padding of initial lost
observation) or a value used for padding (reasonable
values might be <code><a href="base.html#topic+NA">NA</a></code> or <code>0</code>)
</p>
</td></tr>
<tr><td><code id="returns_+3A_na.rm">na.rm</code></td>
<td>

<p>logical; see Details
</p>
</td></tr>
<tr><td><code id="returns_+3A_na.warn">na.warn</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="returns_+3A_position">position</code></td>
<td>

<p>either a numeric vector of the same length as the
number of assets (i.e. <code>ncol(x)</code>), or a numeric
matrix whose dimensions match those of prices
(i.e. <code>dim(x)</code> must equal <code>dim(weights)</code>), or
a matrix with as many rows as <code>rebalance.when</code> has
elements
</p>
</td></tr>
<tr><td><code id="returns_+3A_weights">weights</code></td>
<td>

<p>either a numeric vector of the same length as the
number of assets (i.e. <code>ncol(x)</code>), or a numeric
matrix whose dimensions match those of prices
(i.e. <code>dim(x)</code> must equal <code>dim(weights)</code>), or
a matrix with as many rows as <code>rebalance.when</code> has
elements
</p>
</td></tr>
<tr><td><code id="returns_+3A_rebalance.when">rebalance.when</code></td>
<td>

<p>a logical vector or a vector of integers indicating the
<code>x</code> at which to rebalance.  If <code>x</code> inherits
from a time-series class (such as <code>zoo</code>), it may
also be of the same class as the time index of
<code>x</code>.
</p>
</td></tr>
<tr><td><code id="returns_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to methods
</p>
</td></tr>
<tr><td><code id="returns_+3A_year.rows">year.rows</code></td>
<td>

<p>logical. If <code>TRUE</code> (the default), print
monthly returns with one row per year.
</p>
</td></tr>
<tr><td><code id="returns_+3A_zero.print">zero.print</code></td>
<td>

<p>character.  How to print zero values.
</p>
</td></tr>
<tr><td><code id="returns_+3A_na.print">na.print</code></td>
<td>

<p>character.  How to print <code>NA</code> values. (Not
supported yet.)
</p>
</td></tr>
<tr><td><code id="returns_+3A_plus">plus</code></td>
<td>

<p>logical. Add a &lsquo;<code>+</code>&rsquo; before positive
numbers? Default is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="returns_+3A_lag">lag</code></td>
<td>

<p>The lag for computing returns. A positive integer,
defaults to one; ignored for time-weighted returns
or if <code>t</code> is supplied.
</p>
</td></tr>
<tr><td><code id="returns_+3A_object">object</code></td>
<td>

<p>an object of class <code>p_returns</code> (&lsquo;period
returns&rsquo;)
</p>
</td></tr>
<tr><td><code id="returns_+3A_month.names">month.names</code></td>
<td>

<p>character: names of months. Default is an
abbreviated month name as provided by the
locale. That may cause trouble, notably with
<code>toLatex</code>, if such names contain
non-<abbr><span class="acronym">ASCII</span></abbr> characters: a safe choice is
either the numbers 1 to 12, or the character vector
<code><a href="base.html#topic+month.abb">month.abb</a></code>, which lives in the base
package.
</p>
</td></tr>
<tr><td><code id="returns_+3A_digits">digits</code></td>
<td>

<p>number of digits in table
</p>
</td></tr>
<tr><td><code id="returns_+3A_ytd">ytd</code></td>
<td>

<p>header for YTD
</p>
</td></tr>
<tr><td><code id="returns_+3A_eol">eol</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_stand.alone">stand.alone</code></td>
<td>
<p>logical or character</p>
</td></tr>
<tr><td><code id="returns_+3A_table.class">table.class</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_table.style">table.style</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_th.class">th.class</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_th.style">th.style</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_td.class">td.class</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_td.style">td.style</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_tr.class">tr.class</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_tr.style">tr.style</code></td>
<td>
<p>character</p>
</td></tr>
<tr><td><code id="returns_+3A_browse">browse</code></td>
<td>

<p>logical: open table in browser?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>returns</code> is a generic function.  It computes
simple returns: current values divided by prior
values minus one.  The default method works for
numeric vectors/matrices.  The function
<code>.returns</code> does the actual computations and may
be used when a &lsquo;raw&rsquo; return computation is
needed.
</p>


<h4>Holding-Period Returns</h4>

<p>When a timestamp is available, <code>returns</code> can
compute returns for specific calendar periods. See
argument <code>period</code>.
</p>



<h4>Portfolio Returns</h4>


<p><code>returns</code> may compute returns for a portfolio
specified in <code>weights</code> or <code>position</code>. The
portfolio is rebalanced at <code>rebalance.when</code>; the
default is every period.  Weights need not sum to
one. A zero-weight portfolio, or a portfolio that
never rebalances (e.g. with <code>rebalance.when</code> set
to <code>FALSE</code>), will result in a zero return.
</p>
<p><code>rebalance.when</code> may either be logical,
integers or of the same class as a <code>timestamp</code>
(e.g. <code><a href="base.html#topic+Date">Date</a></code>).
</p>



<h4>Handling missing values</h4>


<p>Removing <code><a href="base.html#topic+NA">NA</a></code>s (by setting <code>na.rm</code> to
<code><a href="base.html#topic+TRUE">TRUE</a></code>) is limited to the following types of
holding-period returns: <code>ann</code>, <code>total/itd</code>,
<code>ytd</code>, <code>mtd</code>. In each case, the first and
latest available finite values are used for computing
returns. For multivariate series <code>x</code>, this can lead
to returns being computed for differing periods.
</p>



<h3>Value</h3>

<p>If called as <code>returns(x)</code>: a numeric vector or
matrix, possibly with a class attribute (e.g. for a
<code>zoo</code> series).
</p>
<p>If called with a <code>period</code> argument: an object of
class <code>"p_returns"</code> (period returns), which is a
numeric vector of returns with attributes <code>t</code>
(timestamp) and <code>period</code>.  Main use is to have
methods that pretty-print such period returns; currently,
there are methods for <code><a href="utils.html#topic+toLatex">toLatex</a></code> and
<code><a href="tools.html#topic+toHTML">toHTML</a></code>.
</p>
<p>In some cases, additional attributes may be attached:
when portfolio returns were computed (i.e. argument
<code>weights</code> was specified), there are attributes
<code>holdings</code> and <code>contributions</code>. For
holding-period returns, there may be a logical attribute
<code>is.annualised</code>, and an attribute <code>from.to</code>,
which tells the start and end date of the holding
period.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>;
in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#computing-returns">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#computing-returns</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btest">btest</a></code>, <code><a href="#topic+pl">pl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 101:105
returns(x)
returns(x, pad = NA)
returns(x, pad = NA, lag = 2)


## monthly returns
t &lt;- seq(as.Date("2012-06-15"), as.Date("2012-12-31"), by = "1 day")
x &lt;- seq_along(t) + 1000
returns(x, t = t, period = "month")
returns(x, t = t, period = "month", complete.first = FALSE)

### formatting
print(returns(x, t = t, period = "month"), plus = TRUE, digits = 0)

## returns per year (annualised returns)
returns(x, t = t, period = "ann")  ## less than one year, not annualised
returns(x, t = t, period = "ann!") ## less than one year, *but* annualised

is.ann &lt;- function(x)
    attr(x, "is.annualised")

is.ann(returns(x, t = t, period = "ann"))   ## FALSE
is.ann(returns(x, t = t, period = "ann!"))  ## TRUE


## with weights and fixed rebalancing times
prices &lt;- cbind(p1 = 101:105,
                p2 = rep(100, 5))
R &lt;- returns(prices, weights = c(0.5, 0.5), rebalance.when = 1)
## ... =&gt; resulting weights
h &lt;- attr(R, "holdings")
h*prices / rowSums(h*prices)
##             p1        p2
## [1,] 0.5000000 0.5000000  ## &lt;== only initial weights are .5/.5
## [2,] 0.5024631 0.4975369
## [3,] 0.5049020 0.4950980
## [4,] 0.5073171 0.4926829
## [5,] 0.5097087 0.4902913
</code></pre>

<hr>
<h2 id='REXP'>
REXP
</h2><span id='topic+REXP'></span>

<h3>Description</h3>

<p>Historical Prices of the REXP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("REXP")</code></pre>


<h3>Format</h3>

<p>A data frame with 502 observations on the following variable:
</p>

<dl>
<dt><code>REXP</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Daily prices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>str(REXP)
</code></pre>

<hr>
<h2 id='scale1'>
Scale Time Series
</h2><span id='topic+scale1'></span><span id='topic+scale1.default'></span><span id='topic+scale1.zoo'></span>

<h3>Description</h3>

<p>Scale time series so that they can be better compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale1(x, ...)

## Default S3 method:
scale1(x, ..., when = "first.complete", level = 1,
       centre = FALSE, scale = FALSE, geometric = TRUE,
       total.g = NULL)

## S3 method for class 'zoo'
scale1(x, ..., when = "first.complete", level = 1,
       centre = FALSE, scale = FALSE, geometric = TRUE,
       inflate = NULL, total.g = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scale1_+3A_x">x</code></td>
<td>

<p>a time series
</p>
</td></tr>
<tr><td><code id="scale1_+3A_when">when</code></td>
<td>

<p>origin: for the default method, either a string or
numeric (integer). Allowed strings are
<code>"first.complete"</code> (the default),
<code>"first"</code>, and <code>"last"</code>.
For the <code>zoo</code> method, a
value that matches the class of the <code>index</code> of
<code>x</code>; for instance, with an index of class
<code><a href="base.html#topic+Date">Date</a></code>, <code>when</code> should inherit from
<code><a href="base.html#topic+Date">Date</a></code>.
</p>
</td></tr>
<tr><td><code id="scale1_+3A_level">level</code></td>
<td>

<p>numeric
</p>
</td></tr>
<tr><td><code id="scale1_+3A_centre">centre</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="scale1_+3A_scale">scale</code></td>
<td>

<p>logical or numeric
</p>
</td></tr>
<tr><td><code id="scale1_+3A_geometric">geometric</code></td>
<td>

<p>logical: if <code>TRUE</code> (the default), the geometric mean is
deducted with <code>centre</code> is <code>TRUE</code>; if <code>FALSE</code>,
the arithmetic mean is used
</p>
</td></tr>
<tr><td><code id="scale1_+3A_inflate">inflate</code></td>
<td>

<p>numeric: an annual rate at which the series is inflated (or deflated
if negative)
</p>
</td></tr>
<tr><td><code id="scale1_+3A_total.g">total.g</code></td>
<td>

<p>numeric: to total growth rate (or total return) of a series
</p>
</td></tr>
<tr><td><code id="scale1_+3A_...">...</code></td>
<td>

<p>other arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a generic function, with methods for numeric
vectors and matrices, and <code>zoo</code> objects.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>;
in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#scaling-series">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#scaling-series</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scale1(cumprod(1 + c(0, rnorm(20, sd = 0.02))), level = 100)
</code></pre>

<hr>
<h2 id='streaks'>
Up and Down Streaks
</h2><span id='topic+streaks'></span><span id='topic+streaks.default'></span><span id='topic+streaks.zoo'></span><span id='topic+streaks.NAVseries'></span>

<h3>Description</h3>

<p>Compute up and down streaks for time-series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>streaks(x, ...)

## Default S3 method:
streaks(x, up =  0.2, down = -up,
        initial.state = NA, y = NULL, relative = TRUE, ...)
## S3 method for class 'zoo'
streaks(x, up =  0.2, down = -up,
        initial.state = NA, y = NULL, relative = TRUE, ...)
## S3 method for class 'NAVseries'
streaks(x, up =  0.2, down = -up,
        initial.state = NA, bm = NULL, relative = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="streaks_+3A_x">x</code></td>
<td>

<p>a price series
</p>
</td></tr>
<tr><td><code id="streaks_+3A_initial.state">initial.state</code></td>
<td>

<p><code><a href="base.html#topic+NA">NA</a></code>, <code>"up"</code> or <code>"down"</code>
</p>
</td></tr>
<tr><td><code id="streaks_+3A_up">up</code></td>
<td>

<p>a number, such as 0.1 (i.e. 10%)
</p>
</td></tr>
<tr><td><code id="streaks_+3A_down">down</code></td>
<td>

<p>a negative number, such as -0.1 (i.e. -10%)
</p>
</td></tr>
<tr><td><code id="streaks_+3A_y">y</code></td>
<td>

<p>another price series
</p>
</td></tr>
<tr><td><code id="streaks_+3A_bm">bm</code></td>
<td>

<p>another price series. Mapped to &lsquo;<code>y</code>&rsquo;
in the default method.
</p>
</td></tr>
<tr><td><code id="streaks_+3A_relative">relative</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="streaks_+3A_...">...</code></td>
<td>

<p>other arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>streaks</code> is a generic function. It computes
series of uninterrupted up and down movements
(&lsquo;streaks&rsquo;) in a price series. Uninterrupted
is meant in the sense that no countermovement of
<code>down</code> (<code>up</code>) percent or more occurs in up
(down) movements.
</p>
<p>There are methods for numeric vectors, and
<code><a href="#topic+NAVseries">NAVseries</a></code> and <code>zoo</code> objects.
</p>
<p>The turning points (extreme points) are computed with
the benefit of hindsight: the starting point (the
low) of an up streak can only be determined once the
streak is triggered, i.e. the up streak has already
run its minimum amount. Vice versa for down streaks.
</p>
<p>When &lsquo;<code>up</code>&rsquo; and &lsquo;<code>down</code>&rsquo; are
not equal, results may be inconsistent: in the
current implementation, <code>streaks</code> alternates
between up and down streaks. Suppose <code>up</code> is
large compared with <code>down</code>, i.e. it takes long
to trigger up streaks, but they are easily
broken. Down streaks, on the other hand, are quickly
triggered but rarely broken. Now suppose that a down
streak is broken by an up streak: it may then well be
that the up streak would never have been counted as
such, because it was actually broken itself by
another down streak. The implementation for differing
values of &lsquo;<code>up</code>&rsquo; and &lsquo;<code>down</code>&rsquo;
may change in the future.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code>:
</p>
<table role = "presentation">
<tr><td><code>start</code></td>
<td>
<p>beginning of streak</p>
</td></tr>
<tr><td><code>end</code></td>
<td>
<p>end of streak</p>
</td></tr>
<tr><td><code>state</code></td>
<td>
<p><code>up</code>, <code>down</code> or <code><a href="base.html#topic+NA">NA</a></code></p>
</td></tr>
<tr><td><code>return</code>, <code>change</code></td>
<td>
<p>the return over the streak. If <code>y</code>
was specified, geometric excess return is
computed (see Examples). If <code>relative</code> is <code>FALSE</code>,
the column is named <code>change</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2023) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>; in particular, see<br />
<a href="https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#drawdowns-streaks">https://enricoschumann.net/R/packages/PMwR/manual/PMwR.html#drawdowns-streaks</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+drawdowns">drawdowns</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>streaks(DAX[[1]], t = as.Date(row.names(DAX)))

## results &lt;- streaks(x = &lt;...&gt;, y = &lt;...&gt;)
##
## ===&gt; *arithmetic* excess returns
##       x[results$end]/x[results$start] -
##       y[results$end]/y[results$start]
## ===&gt; *geometric* excess returns
##       x[results$end]/x[results$start] /
##      (y[results$end]/y[results$start]) - 1
</code></pre>

<hr>
<h2 id='toHTML'>Import from package <span class="pkg">textutils</span></h2><span id='topic+toHTML'></span>

<h3>Description</h3>

<p>The <code>toHTML</code> function is imported from package <span class="pkg">textutils</span>.
Help is available at <code><a href="textutils.html#topic+toHTML">textutils::toHTML</a></code>.
Say <code>library("textutils")</code> in your code to use the function.
</p>

<hr>
<h2 id='Trade-Analysis'>
Analysing Trades: Compute Profit/Loss, Resize and more
</h2><span id='topic+close_on_first'></span><span id='topic+limit'></span><span id='topic+scale_to_unity'></span><span id='topic+scale_trades'></span><span id='topic+split_trades'></span><span id='topic+tw_exposure'></span>

<h3>Description</h3>

<p>Functions to help analyse trades (as opposed to profit-and-loss series)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_trades(amount, price, timestamp, aggregate = FALSE,
            fun = NULL, ...)
split_trades(amount, price, timestamp, aggregate = FALSE,
             drop.zero = FALSE)

limit(amount, price, timestamp, lim, tol = 1e-8)
scale_to_unity(amount)
close_on_first(amount)

tw_exposure(amount, timestamp, start, end, abs.value = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Trade-Analysis_+3A_amount">amount</code></td>
<td>

<p>notionals
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_price">price</code></td>
<td>

<p>a vector of prices
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_timestamp">timestamp</code></td>
<td>

<p>a vector.
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_aggregate">aggregate</code></td>
<td>

<p><code>TRUE</code> or <code>FALSE</code>
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_fun">fun</code></td>
<td>

<p>a function
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_lim">lim</code></td>
<td>

<p>a maximum absolute position size
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_start">start</code></td>
<td>

<p>optional time
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_end">end</code></td>
<td>

<p>optional time
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_drop.zero">drop.zero</code></td>
<td>

<p>logical. If <code>TRUE</code>, trades with zero amounts are removed.
See Examples.
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_abs.value">abs.value</code></td>
<td>

<p>logical. If <code>TRUE</code>, the absolute exposure is computed.
</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_...">...</code></td>
<td>
<p>passed on to fun</p>
</td></tr>
<tr><td><code id="Trade-Analysis_+3A_tol">tol</code></td>
<td>
<p>numeric</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>scale_trades</code> takes a vector of notionals, prices and
scales all trades along the paths so that the maximum
exposure is 1.
</p>
<p>The default <code>fun</code> divides every element of a vector
<code>n</code> by <code>max(abs(cumsum(n)))</code>. If user-specified,
the function <code>fun</code> needs to take a vector of notionals
(changes in position.)
</p>
<p><code>split_trades</code> decomposes a trade list into single
trades, where a single trade comprises those trades from a
zero position to the next zero position.  Note that the
trades must be sorted chronologically.
</p>


<h3>Value</h3>

<p>Either a list or a list-of-lists.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>See Also</h3>

<p><code><a href="#topic+btest">btest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- c(1,1,-3,-1,2)
p &lt;- 100 + 1:length(n)
timestamp &lt;- 1:length(n)

scale_trades(n, p, timestamp)
scale_trades(n, p, timestamp, TRUE)  ## each _trade_ gets scaled

split_trades(n, p, timestamp)
split_trades(n, p, timestamp, TRUE)  ## almost like the original series



## effect of 'drop.zero'
P &lt;- c(100, 99, 104, 103, 102, 105, 104)  ## price series
S &lt;- c(  0,  1,   1,   0,   0,   1,   0)  ## position to be held
dS &lt;- c(0, diff(S)) ## change in position ==&gt; trades
t &lt;- seq_along(P)

#### ==&gt; 1) with all zero amounts
split_trades(amount = dS, price = P, timestamp = t)

#### ==&gt; 2) without zero-amount trades
split_trades(amount = dS, price = P, timestamp = t, drop.zero = TRUE)

#### ==&gt; 3) without all zero-amounts
zero &lt;- dS == 0
split_trades(amount = dS[!zero], price = P[!zero], timestamp = t[!zero])

</code></pre>

<hr>
<h2 id='unit_prices'>
Compute Prices for Portfolio Based on Units
</h2><span id='topic+unit_prices'></span>

<h3>Description</h3>

<p>Compute prices for a portfolio based on outstanding shares
(units).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unit_prices(NAV, cashflows,
            initial.price, initial.units = 0,
            cf.included = TRUE,
            round.price = NULL, round.units = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="unit_prices_+3A_nav">NAV</code></td>
<td>

<p>a dataframe of two columns: timestamp and net asset
value. There should be no duplicated timestamps.  Column
names are ignored; the function assumes timestamp is the
first column, <abbr><span class="acronym">NAV</span></abbr> the second.
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_cashflows">cashflows</code></td>
<td>

<p>a data.frame of two or three columns: timestamp,
cashflow and (optionally) an id or account. Column names
are ignored; the function assumes timestamp is the first
column, the external cashflows the second, and an
account/id the third.
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_initial.price">initial.price</code></td>
<td>

<p>initial price; ignored when <code>initial.units</code> is not
zero
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_initial.units">initial.units</code></td>
<td>

<p>number of outstanding units before first cashflow
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_cf.included">cf.included</code></td>
<td>

<p><code><a href="base.html#topic+logical">logical</a></code>. If <code><a href="base.html#topic+TRUE">TRUE</a></code> (the
default), it is assumed that the NAV series at the time
of the cashflow already includes the cashflow.
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_round.price">round.price</code></td>
<td>

<p>round unit prices: <code>NULL</code> (no rounding) or an
integer
</p>
</td></tr>
<tr><td><code id="unit_prices_+3A_round.units">round.units</code></td>
<td>

<p>round number of units: <code>NULL</code> (no rounding) or an
integer
</p>
</td></tr>
</table>


<h3>Details</h3>


<p><strong>This function is experimental, and its interface
is not stable yet.</strong>
</p>
<p>The function may be used to compute the returns for a
portfolio with external cashflows, i.e. what is usually
called time-weighted returns.  Note that 'cashflows' can
also comprise other positions that are added or removed
from the portfolio without affecting performance.
</p>


<h3>Value</h3>


<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with one row for each row in
<code>NAV</code>:
</p>
<table role = "presentation">
<tr><td><code>timestamp</code></td>
<td>
<p>the timestamp, as provided in argument
<code>NAV</code></p>
</td></tr>
<tr><td><code>NAV</code></td>
<td>
<p>total NAV, as provided in argument <code>NAV</code></p>
</td></tr>
<tr><td><code>price</code></td>
<td>
<p>NAV per unit</p>
</td></tr>
<tr><td><code>units</code></td>
<td>
<p>outstanding units (i.e. shares) <em>after</em>
cashflows</p>
</td></tr>
</table>
<p>Attached as an attribute is a <code><a href="base.html#topic+data.frame">data.frame</a></code>
<code>transactions</code>, with as many rows as the provided
argument <code>cashflows</code>, which provides the number of
units created/destroyed for each cashflow.
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann
</p>


<h3>References</h3>

<p>Schumann, E. (2024) <em>Portfolio Management with <span class="rlang"><b>R</b></span></em>.<br />
<a href="https://enricoschumann.net/PMwR/">https://enricoschumann.net/PMwR/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+returns">returns</a></code>, <code><a href="#topic+pl">pl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NAV &lt;- data.frame(timestamp = seq(as.Date("2017-01-01"),
                                  as.Date("2017-01-10"),
                                  by = "1 day"),
                  NAV = c(100:104, 205:209))

cf &lt;- data.frame(timestamp = c(as.Date("2017-01-01"),
                               as.Date("2017-01-06"),
                               as.Date("2017-01-06")),
                 cashflow = c(100, 50, 50),
                 account = c("A", "A", "B"))

(up &lt;- unit_prices(NAV, cf, cf.included = TRUE))
##     timestamp NAV    price    units
## 1  2017-01-01 100 100.0000 1.000000
## 2  2017-01-02 101 101.0000 1.000000
## 3  2017-01-03 102 102.0000 1.000000
## 4  2017-01-04 103 103.0000 1.000000
## 5  2017-01-05 104 104.0000 1.000000
## 6  2017-01-06 205 105.0000 1.952381
## 7  2017-01-07 206 105.5122 1.952381
## 8  2017-01-08 207 106.0244 1.952381
## 9  2017-01-09 208 106.5366 1.952381
## 10 2017-01-10 209 107.0488 1.952381

attr(up, "transactions")
##    timestamp cashflow account     units
## 1 2017-01-01      100       A 1.0000000
## 2 2017-01-06       50       A 0.4761905
## 3 2017-01-06       50       B 0.4761905
</code></pre>

<hr>
<h2 id='valuation'>
Valuation
</h2><span id='topic+valuation'></span><span id='topic+valuation.journal'></span><span id='topic+valuation.position'></span>

<h3>Description</h3>

<p>Valuation of financial objects: map an object into a
quantity that is measured in a concrete (typically
currency) unit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valuation(x, ...)

## S3 method for class 'journal'
valuation(x, multiplier = 1,
          cashflow = function(x, ...) x$amount * x$price,
          instrument = function(x, ...) "cash",
          flip.sign = TRUE, ...)

## S3 method for class 'position'
valuation(x, vprice, multiplier = 1,
          do.sum = FALSE,
          price.unit,
          use.names = FALSE,
          verbose = TRUE, do.warn = TRUE, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="valuation_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="valuation_+3A_multiplier">multiplier</code></td>
<td>
<p>a numeric vector, typically with
named elements</p>
</td></tr>
<tr><td><code id="valuation_+3A_cashflow">cashflow</code></td>
<td>
<p>either a numeric vector or a function
that takes on argument (a journal) and transforms
it into a numeric vector</p>
</td></tr>
<tr><td><code id="valuation_+3A_instrument">instrument</code></td>
<td>

<p>either a character vector or a function that takes on argument (a
journal) and transforms it into a character vector
</p>
</td></tr>
<tr><td><code id="valuation_+3A_flip.sign">flip.sign</code></td>
<td>

<p>logical.  If <code>TRUE</code> (the default), a positive amount gets
mapped into a negative cashflow.
</p>
</td></tr>
<tr><td><code id="valuation_+3A_vprice">vprice</code></td>
<td>
<p>numeric: a matrix whose elements
correspond to those in <code>x</code>.  If only a single
timestamp is used and the position is named, this may
also be a named numeric vector; see Examples.  The
argument behaves like <code>vprice</code> in
<code><a href="#topic+pl">pl</a></code>; but for valuation those prices need
not be sorted in time.</p>
</td></tr>
<tr><td><code id="valuation_+3A_do.sum">do.sum</code></td>
<td>

<p>logical: sum over positions
</p>
</td></tr>
<tr><td><code id="valuation_+3A_use.names">use.names</code></td>
<td>

<p>logical: use names of <code>vprice</code>?
</p>
</td></tr>
<tr><td><code id="valuation_+3A_price.unit">price.unit</code></td>
<td>

<p>a named character vector. Not implemented.
</p>
</td></tr>
<tr><td><code id="valuation_+3A_verbose">verbose</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="valuation_+3A_do.warn">do.warn</code></td>
<td>

<p>logical
</p>
</td></tr>
<tr><td><code id="valuation_+3A_...">...</code></td>
<td>

<p>other arguments passed to methods
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>This function is experimental, and the methods'
interfaces are not stable yet.</strong>
</p>
<p><code>valuation</code> is a generic function.  Its
semantics suggest that an object (e.g. a financial
instrument or a position) is mapped into a concrete
quantity (such as an amount of some currency).
</p>
<p>The <code><a href="#topic+journal">journal</a></code> method transforms the
transactions in a journal into amounts of currency
(e.g, a sale of 100 shares of a company is
transformed into the value of these 100 shares).
</p>
<p>The <code><a href="#topic+position">position</a></code> method takes a position
and returns the value (in currency units) of the
position.
</p>


<h3>Value</h3>

<p>depends on the object: for journals, a <code><a href="#topic+journal">journal</a></code>
</p>


<h3>Author(s)</h3>

<p>Enrico Schumann &lt;es@enricoschumann.net&gt;
</p>


<h3>References</h3>

<p>Schumann, E. (2020) <em>Portfolio Management with R</em>.
<a href="https://enricoschumann.net/R/packages/PMwR/">https://enricoschumann.net/R/packages/PMwR/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+journal">journal</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## valuing a JOURNAL

j &lt;- journal(amount = 10, price = 2)
##    amount  price
## 1      10      2
##
## 1 transaction

valuation(j, instrument = NA)
##    amount  price
## 1     -20      1
##
## 1 transaction



## valuing a POSITION
pos &lt;- position(c(AMZN = -10, MSFT = 200))

### contructing a price table:
### ==&gt; P[i, j] must correspond to pos[i, j]
P &lt;- array(c(2200, 170), dim = c(1, 2))
colnames(P) &lt;- instrument(pos)

valuation(pos, vprice = P)
##        AMZN  MSFT
## [1,] -22000 34000

### contructing a price table, alternative:
### a named vector
### ==&gt; only works when there is only a single timestamp
valuation(pos, vprice = c(MSFT = 170, AMZN = 2200))

all.equal(valuation(pos, vprice = P),
          valuation(pos, vprice = c(MSFT = 170, AMZN = 2200)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
