<!DOCTYPE html><html><head><title>Help for package KrigInv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {KrigInv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bichon_optim'>
<p>Bichon et al.'s Expected Feasibility criterion</p></a></li>
<li><a href='#computeQuickKrigcov'><p>Quick computation of kriging covariances</p></a></li>
<li><a href='#computeRealVolumeConstant'><p>A constant used to calculate the expected excursion set's volume variance</p></a></li>
<li><a href='#EGI'>
<p>Efficient Global Inversion: sequential inversion algorithm based on Kriging.</p></a></li>
<li><a href='#EGIparallel'>
<p>Efficient Global Inversion: parallel version to get batchsize locations at each iteration</p></a></li>
<li><a href='#excursion_probability'><p>Excursion probability with one or many thresholds</p></a></li>
<li><a href='#integration_design'>
<p>Construction of a sample of integration points and weights</p></a></li>
<li><a href='#jn_optim_parallel'><p> Parallel jn criterion</p></a></li>
<li><a href='#jn_optim_parallel2'><p> Parallel jn criterion</p></a></li>
<li><a href='#KrigInv-package'><p> Kriging-Based Inversion for Deterministic and Noisy Computer Experiments</p></a></li>
<li><a href='#max_futureVol_parallel'><p>Maximize parallel volume criterion</p></a></li>
<li><a href='#max_infill_criterion'><p>Optimizer for the infill criteria</p></a></li>
<li><a href='#max_sur_parallel'><p> Minimizer of the parallel <code>"sur"</code> or <code>"jn"</code> criterion</p></a></li>
<li><a href='#max_timse_parallel'><p> Minimizer of the parallel timse criterion</p></a></li>
<li><a href='#max_vorob_parallel'><p> Minimizer of the parallel vorob criterion</p></a></li>
<li><a href='#precomputeUpdateData'><p>Useful precomputations to quickly update kriging mean and variance</p></a></li>
<li><a href='#predict_nobias_km'><p> Kriging predictions</p></a></li>
<li><a href='#predict_update_km_parallel'>
<p>Quick update of kriging means and variances when one or many new points are added to the DOE.</p></a></li>
<li><a href='#print_uncertainty'>
<p>Prints a measure of uncertainty for a function of any dimension.</p></a></li>
<li><a href='#print_uncertainty_1d'>
<p>Prints a measure of uncertainty for 1d function.</p></a></li>
<li><a href='#print_uncertainty_2d'>
<p>Prints a measure of uncertainty for 2d function.</p></a></li>
<li><a href='#print_uncertainty_nd'>
<p>Print a measure of uncertainty for functions with dimension d strictly larger than 2.</p></a></li>
<li><a href='#ranjan_optim'><p> Ranjan et al.'s Expected Improvement criterion</p></a></li>
<li><a href='#sur_optim_parallel'><p> Parallel sur criterion</p></a></li>
<li><a href='#sur_optim_parallel2'><p> Parallel sur criterion</p></a></li>
<li><a href='#timse_optim_parallel'><p> Parallel targeted IMSE criterion</p></a></li>
<li><a href='#timse_optim_parallel2'><p> Parallel timse criterion</p></a></li>
<li><a href='#tmse_optim'><p> Targeted MSE criterion</p></a></li>
<li><a href='#tsee_optim'><p> Two Sided Expected Exceedance criterion</p></a></li>
<li><a href='#vorob_optim_parallel'><p> Parallel Vorob'ev criterion</p></a></li>
<li><a href='#vorob_optim_parallel2'><p> Parallel Vorob'ev criterion</p></a></li>
<li><a href='#vorob_threshold'><p> Calculation of the Vorob'ev threshold</p></a></li>
<li><a href='#vorobVol_optim_parallel'><p>Compute volume criterion</p></a></li>
<li><a href='#vorobVol_optim_parallel2'><p>Compute volume criterion</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Kriging-Based Inversion for Deterministic and Noisy Computer
Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-06</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dario Azzimonti &lt;dario.azzimonti@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>DiceKriging</td>
</tr>
<tr>
<td>Imports:</td>
<td>randtoolbox, rgenoud, pbivnorm, anMC, mvtnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Description:</td>
<td>Criteria and algorithms for sequentially estimating level sets of a multivariate numerical function, possibly observed with noise.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://doi.org/10.1016/j.csda.2013.03.008">https://doi.org/10.1016/j.csda.2013.03.008</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-09 13:37:24 UTC; dario.azzimonti</td>
</tr>
<tr>
<td>Author:</td>
<td>Clement Chevalier [aut],
  Dario Azzimonti <a href="https://orcid.org/0000-0001-5080-3061"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Ginsbourger <a href="https://orcid.org/0000-0003-2724-2678"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Victor Picheny <a href="https://orcid.org/0000-0002-4948-5542"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Yann Richet <a href="https://orcid.org/0000-0002-5677-8458"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-09 16:52:55 UTC</td>
</tr>
</table>
<hr>
<h2 id='bichon_optim'>
Bichon et al.'s Expected Feasibility criterion
</h2><span id='topic+bichon_optim'></span>

<h3>Description</h3>

<p>Evaluation of Bichon's Expected Feasibility criterion. To be used in optimization routines, like in <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bichon_optim(x, model, T, method.param = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bichon_optim_+3A_x">x</code></td>
<td>

<p>Input vector at which one wants to evaluate the criterion. 
This argument can be either a vector of size d (for an evaluation at a single point) or a p*d matrix (for p simultaneous evaluations of the criterion at p different points).
</p>
</td></tr>
<tr><td><code id="bichon_optim_+3A_model">model</code></td>
<td>

<p>An object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).
</p>
</td></tr>
<tr><td><code id="bichon_optim_+3A_t">T</code></td>
<td>

<p>Target value (scalar).
</p>
</td></tr>
<tr><td><code id="bichon_optim_+3A_method.param">method.param</code></td>
<td>

<p>Scalar tolerance around the target T. Default value is 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bichon EF criterion.
When the argument <code>x</code> is a vector, the function returns a scalar.
When the argument <code>x</code> is a p*d matrix, the function returns a vector of size p.
</p>


<h3>Author(s)</h3>

 
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Bichon B.J., Eldred M.S., Swiler L.P., Mahadevan S., McFarland J.M. (2008) <em>Efficient global reliability analysis for nonlinear implicit performance functions</em>, AIAA Journal 46(10), pp 2459-2468
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>, <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#bichon_optim

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance 
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

x &lt;- c(0.5,0.4) #one evaluation of the bichon criterion
bichon_optim(x=x,T=T,model=model)

n.grid &lt;- 20 # resolution. You may use a larger value.
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
bichon.grid &lt;- bichon_optim(x=x,T=T,model=model)
z.grid &lt;- matrix(bichon.grid, n.grid, n.grid)

#plots: contour of the criterion, DOE points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,25,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)

i.best &lt;- which.max(bichon.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of Bichon criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='computeQuickKrigcov'>Quick computation of kriging covariances</h2><span id='topic+computeQuickKrigcov'></span>

<h3>Description</h3>

<p>Computes kriging covariances between some new points and many integration points, using precomputed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeQuickKrigcov(model,integration.points,X.new,
precalc.data, F.newdata , c.newdata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeQuickKrigcov_+3A_model">model</code></td>
<td>
<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.</p>
</td></tr>
<tr><td><code id="computeQuickKrigcov_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of fixed integration points in the X space.</p>
</td></tr>
<tr><td><code id="computeQuickKrigcov_+3A_x.new">X.new</code></td>
<td>
<p>q*d matrix of new points. The calculated covariances are the covariances between these new point and the integration points.</p>
</td></tr>
<tr><td><code id="computeQuickKrigcov_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing precalculated data. This list is generated using the function <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code>.</p>
</td></tr>
<tr><td><code id="computeQuickKrigcov_+3A_f.newdata">F.newdata</code></td>
<td>
<p>The value of the kriging trend basis function at point X.new.</p>
</td></tr>
<tr><td><code id="computeQuickKrigcov_+3A_c.newdata">c.newdata</code></td>
<td>
<p>The (unconditional) covariance between X.new and the design points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires to use another function in order to generate the proper arguments. 
The argument <code>precalc.data</code> can be generated using <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code>.
The arguments <code>F.newdata</code> and <code>c.newdata</code> can be obtained using <code><a href="#topic+predict_nobias_km">predict_nobias_km</a></code>.
</p>


<h3>Value</h3>

<p>Matrix of size p*q containing kriging covariances
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code>, <code><a href="#topic+predict_nobias_km">predict_nobias_km</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#computeQuickKrigcov

set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
            response = response,covtype="matern3_2")

#the integration.points are the points where we want to 
#compute predictions/covariances if a point new.x is added 
#to the DOE
x.grid &lt;- seq(0,1,length=20)
integration.points &lt;- expand.grid(x.grid,x.grid)
integration.points &lt;- as.matrix(integration.points)

#precalculation
precalc.data &lt;- precomputeUpdateData(model=model,
                     integration.points=integration.points)

#now we can compute quickly kriging covariances 
#between these data and any other points.
#example if 5 new points are added:
X.new &lt;- matrix(runif(10),ncol=2)
pred &lt;- predict_nobias_km(object=model,
                          newdata=X.new,type="UK",se.compute=TRUE)

kn &lt;- computeQuickKrigcov(model=model,
                    integration.points=integration.points,X.new=X.new,
                    precalc.data=precalc.data,
                    F.newdata=pred$F.newdata,
                    c.newdata=pred$c)
</code></pre>

<hr>
<h2 id='computeRealVolumeConstant'>A constant used to calculate the expected excursion set's volume variance</h2><span id='topic+computeRealVolumeConstant'></span>

<h3>Description</h3>

<p>This function computes a constant used to calculate exactly the value of the <code>"jn"</code> criterion. 
Computing this constant does NOT change the optimum of the <code>"jn"</code> criterion. 
Therefore, its calculation is indicative only and is only necessary to know exactly (in expectation) the excursion set's volume variance. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeRealVolumeConstant(model,integration.points,
integration.weights=NULL,T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="computeRealVolumeConstant_+3A_model">model</code></td>
<td>
<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.</p>
</td></tr>
<tr><td><code id="computeRealVolumeConstant_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="computeRealVolumeConstant_+3A_integration.weights">integration.weights</code></td>
<td>
<p>(Optional) Vector of size p corresponding to the weights of these integration points. If not provided, all weights are set to 1.</p>
</td></tr>
<tr><td><code id="computeRealVolumeConstant_+3A_t">T</code></td>
<td>
<p>Target threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, even if the <code>"jn"</code> criterion can be used with more than one threshold, the computation of this constant is implemented only 
when the number of threshold is equal to 1.
</p>


<h3>Value</h3>

<p>a scalar
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>


<h3>See Also</h3>

<p><code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code>, <code><a href="#topic+predict_nobias_km">predict_nobias_km</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#computeRealVolumeConstant

set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin
T &lt;- 80

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
            response = response,covtype="matern3_2")

integcontrol &lt;- list(n.points=500,distrib="jn",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
	lower=c(0,0),upper=c(1,1),model=model,T=T)
	
integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights

## Not run: 
computeRealVolumeConstant(model=model,
	integration.points=integration.points,
        integration.weights=integration.weights,T=T)

## End(Not run)
</code></pre>

<hr>
<h2 id='EGI'>
Efficient Global Inversion: sequential inversion algorithm based on Kriging.
</h2><span id='topic+EGI'></span>

<h3>Description</h3>

<p>Sequential sampling based on the optimization of a kriging-based criterion, with model update after each iteration. The criterias aim at identifying an excursion set or one/many level sets. At each iteration batchsize = 1 new locations are evaluated.
Different criteria are available for selecting experiments. The pointwise criteria are <code>"bichon"</code>, <code>"ranjan"</code>, <code>"tmse"</code>, <code>"tsee"</code>  and are fast to compute. In addition, integral criteria require numerical integration and can potentially deliver more than one new location per iteration. Available integral criteria are <code>"imse"</code>, <code>"timse"</code>, <code>"sur"</code>, <code>"jn"</code>, <code>"vorob"</code>, <code>"vorobCons"</code>, <code>"vorobVol"</code>. The use of the integral criteria is implemented in the <code><a href="#topic+EGIparallel">EGIparallel</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGI(T, model, method = NULL, method.param = NULL,
fun, iter, lower, upper, new.noise.var = 0,
optimcontrol = NULL, kmcontrol = NULL, integcontrol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGI_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds. The criteria which can be used with multiple thresholds are <code>"tmse"</code>, <code>"timse"</code>, <code>"sur"</code>, <code>"jn"</code>.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_method">method</code></td>
<td>

<p>Criterion used for choosing observations.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_method.param">method.param</code></td>
<td>

<p>Optional method parameters. For methods</p>

<ul>
<li><p><code>"ranjan"</code>, <code>"bichon"</code>, <br />
<code>"tmse"</code> and <code>"timse"</code>: the tolerance value (scalar). If not provided, default value is used (1 for ranjan and bichon, 0 for tmse and timse).
</p>
</li>
<li><p><code>"vorobev"</code>: a list containing <code>penalization</code> (scalar, default=1), type I penalization, and <code>typeEx</code>,(character, default=&quot;&gt;&quot;) either &quot;&gt;&quot; or &quot;&lt;&quot; denoting the type of excursion. 
</p>
</li>
<li><p><code>"vorobCons"</code> and <code>"vorobVol"</code>: a list containing  <code>penalization</code> (scalar, default =1), <code>typeEx</code> (character, default = &quot;&gt;&quot;), <code>consLevel</code> (scalar, default=0.95), <code>n_discrete_design</code> (scalar, default=500*model@d), <code>design</code> (data.frame, default=<code>as.data.frame(sobol (n = method.param$n_discrete_design, dim = model@d))</code> ), <code>pred</code> (list resulting from <code>predict.km</code>). See also the arguments <code>alpha</code>, <code>pred</code>, <code>design</code>, <code>type</code> from the function <code><a href="anMC.html#topic+conservativeEstimate">conservativeEstimate</a></code>, package <code>anMC</code>, for more details. 
</p>
</li></ul>
 </td></tr>
<tr><td><code id="EGI_+3A_fun">fun</code></td>
<td>

<p>Objective function.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_iter">iter</code></td>
<td>

<p>Number of iterations (i.e. number of additional sampling points).
</p>
</td></tr>
<tr><td><code id="EGI_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_new.noise.var">new.noise.var</code></td>
<td>

<p>Optional scalar value of the noise variance of the new observations.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used: it can be either <code>"genoud"</code> (default) for an optimisation using the genoud algorithm, or <code>"discrete"</code> for an optimisation over a specified discrete set.
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm:
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (default : 10*d), <br />
<code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_kmcontrol">kmcontrol</code></td>
<td>

<p>Optional list representing the control variables for the re-estimation of the kriging model once new points are sampled.
The items are the same as in <code><a href="DiceKriging.html#topic+km">km</a></code>.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_integcontrol">integcontrol</code></td>
<td>

<p>Optional list specifying the procedure to build the integration points and weights, relevant only for the sampling criteria based on numerical integration: <br />
(<code>"imse"</code>, <code>"timse"</code>, <code>"sur"</code> or <code>"jn"</code>). Many options are possible.
A) If nothing is specified, 100*d points are chosen using the Sobol sequence.
B) One can directly set the field <code>integration.points</code> (a p * d matrix) for prespecified integration points. In this case these integration points and the corresponding vector <code>integration.weights</code> will be used for all the iterations of the algorithm.
C) If the field <code>integration.points</code> is not set then the integration points are renewed at each iteration.
In that case one can control the number of integration points <code>n.points</code> (default: 100*d) and a specific distribution <code>distrib</code>. Possible values for <code>distrib</code> are:
<code>"sobol"</code>, <code>"MC"</code>, <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code> and <code>"jn"</code> (default: <code>"sobol"</code>).
C.1) The choice <code>"sobol"</code> corresponds to integration points chosen with the Sobol sequence in dimension d (uniform weight).
C.2) The choice <code>"MC"</code> corresponds to points chosen randomly, uniformly on the domain.
C.3) The choices <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code> and <code>"jn"</code> correspond to importance sampling distributions (unequal weights). It is strongly recommended to use the importance sampling distribution corresponding to the chosen sampling criterion.
When important sampling procedures are chosen, <code>n.points</code> points are chosen using importance sampling among a discrete set of <code>n.candidates</code> points (default: <code>n.points*10</code>) which are distributed according to a distribution <br />
<code>init.distrib</code> (default: <code>"sobol"</code>). Possible values for <code>init.distrib</code> are the space filling distributions <code>"sobol"</code> and <code>"MC"</code> or an user defined distribution <code>"spec"</code>.
The <code>"sobol"</code> and <code>"MC"</code> choices correspond to quasi random and random points in the domain.
If the <code>"spec"</code> value is chosen the user must fill in manually the field <code>init.distrib.spec</code> to specify himself a n.candidates * d matrix of points in dimension d.
</p>
</td></tr>
<tr><td><code id="EGI_+3A_...">...</code></td>
<td>

<p>Other arguments of the target function <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function used to build the integration points and weights (based on the options specified in <code>integcontrol</code>) is the function <code><a href="#topic+integration_design">integration_design</a></code>
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The added observations (ite * d matrix)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the function <code>fun</code> at the added observations (vector of size &quot;ite&quot;)</p>
</td></tr>
<tr><td><code>nsteps</code></td>
<td>
<p>The number of added observations (=ite).</p>
</td></tr>
<tr><td><code>lastmodel</code></td>
<td>
<p>The current (last) kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.</p>
</td></tr>
<tr><td><code>lastvalue</code></td>
<td>
<p>The value of the criterion at the last added point.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points, for the last iteration.</p>
</td></tr>
</table>
<p>If <code>method="vorobCons"</code> or <code>method="vorobVol"</code> the list also has components:
</p>
<table>
<tr><td><code>current.CE</code></td>
<td>
<p>Conservative estimate computed on <code>lastmodel</code>.</p>
</td></tr>
<tr><td><code>allCE_lvs</code></td>
<td>
<p>The conservative estimate levels computed at each iteration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>
<p>Bichon B.J., Eldred M.S., Swiler L.P., Mahadevan S., McFarland J.M. (2008) <em>Efficient global reliability analysis for nonlinear implicit performance functions</em>, AIAA Journal 46(10), pp 2459-2468
</p>
<p>Ranjan P., Bingham D., Michailidis G. (2008) <em>Sequential experiment design for contour estimation from complex computer codes</em> Technometrics 50(4), pp 527-541
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>,<code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#EGI

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=50)
integcontrol &lt;- list(distrib="sur",n.points=50)
iter &lt;- 1

## Not run: 
obj1 &lt;- EGI(T=T,model=model,method="sur",fun=testfun,iter=iter,
           lower=lower,upper=upper,optimcontrol=optimcontrol,
           integcontrol=integcontrol)

obj2 &lt;- EGI(T=T,model=model,method="ranjan",fun=testfun,iter=iter,
           lower=lower,upper=upper,optimcontrol=optimcontrol)


par(mfrow=c(1,3))
print_uncertainty_2d(model=model,T=T,main="probability of excursion",
type="pn",new.points=0,cex.points=2)

print_uncertainty_2d(model=obj1$lastmodel,T=T,
main="updated probability of excursion, sur sampling",
type="pn",new.points=iter,col.points.end="red",cex.points=2)

print_uncertainty_2d(model=obj2$lastmodel,T=T,
main="updated probability of excursion, ranjan sampling",
type="pn",new.points=iter,col.points.end="red",cex.points=2)

## End(Not run)
##############
#same example with noisy initial observations and noisy new observations
branin.noise &lt;- function(x) return(branin(x)+rnorm(n=1,sd=30))

set.seed(9)
N &lt;- 20;T &lt;- 80
testfun &lt;- branin.noise
lower &lt;- c(0,0);upper &lt;- c(1,1)

design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response.noise &lt;- apply(design,1,testfun)
response.noise - response


model.noise &lt;- km(formula=~., design = design, response = response.noise,
covtype="matern3_2",noise.var=rep(30*30,times=N))

optimcontrol &lt;- list(method="genoud",pop.size=50)
integcontrol &lt;- list(distrib="sur",n.points=50)
iter &lt;- 1

## Not run: 
obj1 &lt;- EGI(T=T,model=model.noise,method="sur",fun=testfun,iter=iter,
           lower=lower,upper=upper,optimcontrol=optimcontrol,
           integcontrol=integcontrol,new.noise.var=30*30)

obj2 &lt;- EGI(T=T,model=model.noise,method="ranjan",fun=testfun,iter=iter,
           lower=lower,upper=upper,optimcontrol=optimcontrol,
            new.noise.var=30*30)

par(mfrow=c(1,3))
print_uncertainty_2d(model=model.noise,T=T,
main="probability of excursion, noisy obs.",
type="pn",new.points=0,cex.points=2)

print_uncertainty_2d(model=obj1$lastmodel,T=T,
main="probability of excursion, sur sampling, noisy obs.",
type="pn",new.points=iter,col.points.end="red",cex.points=2)

print_uncertainty_2d(model=obj2$lastmodel,T=T,
main="probability of excursion, ranjan sampling, noisy obs.",
type="pn",new.points=iter,col.points.end="red",cex.points=2)

## End(Not run)


##############
# Conservative estimates with non-noisy initial observations
## Not run: 
  testfun &lt;- branin

  ## Minimize Type II error sampling

  # The list method.param contains all parameters for the
  # conservative estimate and the conservative sequential
  # strategy. Below are parameters for a type II strategy
  # with conservative estimates at 0.95
  method.param = list(penalization=0, # Type II strategy
                      typeEx="&gt;", consLevel = 0.95,
                      n_discrete_design=500*model@d)
  # If the CE for the initial model is already computed
  # it is possible to pass the conservative Vorob'ev quantile
  # level with method.param$consVorbLevel

  obj_T2 &lt;- EGI(T=T,model=model,method="vorobCons",
                fun=testfun,iter=iter,lower=lower,upper=upper,
                optimcontrol=optimcontrol,
                integcontrol=integcontrol,method.param=method.param)

  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                       type="pn",new.points=0,cex.points=2,consQuantile = obj_T2$allCE_lvs[1])

  print_uncertainty_2d(model=obj_T2$lastmodel,T=T,
                       main="probability of excursion, parallel Type II sampling",
                       type="pn",new.points=iter,col.points.end="red",
                       cex.points=2,consQuantile = obj_T2$allCE_lvs[2])

  ## Maximize conservative estimate's volume
  # Set up method.param
  # Here we pass the conservative level computed
  # in the previous step for the initial model
  method.param = list(typeEx="&gt;", consLevel = 0.95,
                      n_discrete_design=500*model@d,
                      consVorbLevel=obj_T2$allCE_lvs[1]
  )

  obj_consVol &lt;- EGI(T=T,model=model,method="vorobVol",
                     fun=testfun,iter=iter,lower=lower,upper=upper,
                     optimcontrol=optimcontrol,
                     integcontrol=integcontrol,method.param=method.param)

  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                       type="pn",new.points=0,cex.points=2,consQuantile = obj_consVol$allCE_lvs[1])

  print_uncertainty_2d(model=obj_consVol$lastmodel,T=T,
                       main="probability of excursion, parallel consVol sampling",
                       type="pn",new.points=iter,col.points.end="red",
                       cex.points=2,consQuantile = obj_consVol$allCE_lvs[2])


## End(Not run)

</code></pre>

<hr>
<h2 id='EGIparallel'>
Efficient Global Inversion: parallel version to get batchsize locations at each iteration
</h2><span id='topic+EGIparallel'></span>

<h3>Description</h3>

<p>Sequential sampling based on the optimization of a kriging-based criterion, with model update after each iteration. The criterias aim at identifying an excursion set or one/many level sets. At each iteration batchsize new locations are evaluated.
Different criteria are available for selecting experiments. The pointwise criteria are <code>"bichon"</code>, <code>"ranjan"</code>, <code>"tmse"</code>, <code>"tsee"</code>  and are fast to compute. These criteria can be used only with batchsize = 1. In addition, integral criteria require numerical integration and can potentially deliver more than one new location per iteration. Available integral criteria are <code>"imse"</code>, <code>"timse"</code>, <code>"sur"</code>, <code>"jn"</code>, <code>"vorob"</code>, <code>"vorobCons"</code>, <code>"vorobVol"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EGIparallel(T, model, method = NULL, method.param=NULL,
fun, iter, batchsize = 1,
lower, upper, new.noise.var = 0,
optimcontrol = NULL, kmcontrol = NULL, integcontrol = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EGIparallel_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds. The criteria which can be used with multiple thresholds are <code>"tmse"</code>, <code>"timse"</code>, <code>"sur"</code>, <code>"jn"</code>.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_method">method</code></td>
<td>

<p>Criterion used for choosing observations.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_method.param">method.param</code></td>
<td>

<p>Optional method parameters. For methods</p>

<ul>
<li><p><code>"ranjan"</code>, <code>"bichon"</code>, <br />
<code>"tmse"</code> and <code>"timse"</code>: the tolerance value (scalar). If not provided, default value is used (1 for ranjan and bichon, 0 for tmse and timse).
</p>
</li>
<li><p><code>"vorob"</code>: a list containing <code>penalization</code> (scalar, default=1), type I penalization, and <code>typeEx</code>,(character, default=&quot;&gt;&quot;) either &quot;&gt;&quot; or &quot;&lt;&quot; denoting the type of excursion. 
</p>
</li>
<li><p><code>"vorobCons"</code> and <code>"vorobVol"</code>: a list containing  <code>penalization</code> (scalar, default =1), <code>typeEx</code> (character, default = &quot;&gt;&quot;), <code>consLevel</code> (scalar, default=0.95), <code>n_discrete_design</code> (scalar, default=500*model@d), <code>design</code> (data.frame, default=<code>as.data.frame(sobol (n = method.param$n_discrete_design, dim = model@d))</code> ), <code>pred</code> (result of <code>predict.km</code> on <code>model</code> at <code>design</code>) and <code>consVorbLevel</code>, the conservative estimate Vorob'ev quantile computed from <code>pred</code>. See also the arguments <code>alpha</code>, <code>pred</code>, <code>design</code>, <code>type</code> from the function <code><a href="anMC.html#topic+conservativeEstimate">conservativeEstimate</a></code>, package <code>anMC</code>, for more details. 
</p>
</li></ul>
 </td></tr>
<tr><td><code id="EGIparallel_+3A_batchsize">batchsize</code></td>
<td>

<p>Number of points to sample simultaneously. The sampling criterion will return <code>batchsize</code> points at each iteration. Some criteria can be used only with batchsize = 1 (see description).
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_new.noise.var">new.noise.var</code></td>
<td>

<p>Optional scalar value of the noise variance of the new observations.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_fun">fun</code></td>
<td>

<p>Objective function.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_iter">iter</code></td>
<td>

<p>Number of iterations.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the variables to be optimized over.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the variables to be optimized over.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used: it can be either <code>"genoud"</code> (default) for an optimisation using the genoud algorithm, or <code>"discrete"</code> for an optimisation over a specified discrete set.
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm:
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (default : 10*d), <br />
<code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly.
Finally, one can control the field optim.option in order to decide how to optimize the sampling criterion.
If <code>optim.option</code> is set to 2 (default), batchsize sequential optimizations in dimension d are performed to find the optimum.
If <code>optim.option</code> is set to 1, only one optimization in dimension batchsize*d is performed. This option is only available with <code>"genoud"</code>. This option might provide more global and accurate solutions, but is a lot more expensive.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_kmcontrol">kmcontrol</code></td>
<td>

<p>Optional list representing the control variables for the re-estimation of the kriging model once new points are sampled.
The items are the same as in <code><a href="DiceKriging.html#topic+km">km</a></code>.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_integcontrol">integcontrol</code></td>
<td>

<p>Optional list specifying the procedure to build the integration points and weights. Many options are possible.
A) If nothing is specified, 100*d points are chosen using the Sobol sequence. <br />
B) One can directly set the field <code>integration.points</code> (a p * d matrix) for prespecified integration points. In this case these integration points and the corresponding vector <code>integration.weights</code> will be used for all the iterations of the algorithm.
C) If the field <code>integration.points</code> is not set then the integration points are renewed at each iteration.
In that case one can control the number of integration points <code>n.points</code> (default: 100*d) and a specific distribution <code>distrib</code>. Possible values for <code>distrib</code> are:
<code>"sobol"</code>, <code>"MC"</code>, <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code> and <code>"jn"</code> (default: <code>"sobol"</code>).
C.1) The choice <code>"sobol"</code> corresponds to integration points chosen with the Sobol sequence in dimension d (uniform weight).
C.2) The choice <code>"MC"</code> corresponds to points chosen randomly, uniformly on the domain.
C.3) The choices <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code> and <code>"jn"</code> correspond to importance sampling distributions (unequal weights). It is strongly recommended to use the importance sampling distribution corresponding to the chosen sampling criterion.
When important sampling procedures are chosen, <code>n.points</code> points are chosen using importance sampling among a discrete set of <code>n.candidates</code> points (default: <code>n.points*10</code>) which are distributed according to a distribution <br />
<code>init.distrib</code> (default: <code>"sobol"</code>). Possible values for <code>init.distrib</code> are the space filling distributions <code>"sobol"</code> and <code>"MC"</code> or an user defined distribution <code>"spec"</code>.
The <code>"sobol"</code> and <code>"MC"</code> choices correspond to quasi random and random points in the domain.
If the <code>"spec"</code> value is chosen the user must fill in manually the field <code>init.distrib.spec</code> to specify himself a n.candidates * d matrix of points in dimension d.
</p>
</td></tr>
<tr><td><code id="EGIparallel_+3A_...">...</code></td>
<td>

<p>Other arguments of the target function <code>fun</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function used to build the integration points and weights (based on the options specified in <code>integcontrol</code>) is the function <code><a href="#topic+integration_design">integration_design</a></code>
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The added observations ((iter*batchsize) * d matrix)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of <code>fun</code> at the added observations (size: iter*batchsize)</p>
</td></tr>
<tr><td><code>nsteps</code></td>
<td>
<p>The number of added observations (=iter*batchsize).</p>
</td></tr>
<tr><td><code>lastmodel</code></td>
<td>
<p>The current (last) kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.</p>
</td></tr>
<tr><td><code>lastvalue</code></td>
<td>
<p>The value of the criterion at the last added batch of points.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points, for the last iteration, for the last point of the batch.</p>
</td></tr>
</table>
<p>If <code>method="vorobCons"</code> or <code>method="vorobVol"</code> the list also has components:
</p>
<table>
<tr><td><code>current.CE</code></td>
<td>
<p>Conservative estimate computed on <code>lastmodel</code>.</p>
</td></tr>
<tr><td><code>allCE_lvs</code></td>
<td>
<p>The conservative estimate levels computed at each iteration.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#EGIparallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(20,60) #thresholds
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
            response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=50)
integcontrol &lt;- list(distrib="sur",n.points=50)
iter &lt;- 1
batchsize &lt;- 6

## Not run: 
  obj &lt;- EGIparallel(T=T,model=model,method="sur",batchsize=batchsize,
                     fun=testfun,iter=iter,lower=lower,upper=upper,
                     optimcontrol=optimcontrol,integcontrol=integcontrol)

  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                       type="pn",new.points=0,cex.points=2)

  print_uncertainty_2d(model=obj$lastmodel,T=T,
                       main="probability of excursion, parallel sur sampling",
                       type="pn",new.points=iter*batchsize,col.points.end="red",cex.points=2)

## End(Not run)

##############
#same example with noisy initial observations and noisy new observations
branin.noise &lt;- function(x) return(branin(x)+rnorm(n=1,sd=30))

set.seed(9)
N &lt;- 20;T &lt;- c(20,60)
testfun &lt;- branin.noise
lower &lt;- c(0,0);upper &lt;- c(1,1)

design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response.noise &lt;- apply(design,1,testfun)
response.noise - response

model.noise &lt;- km(formula=~., design = design, response = response.noise,
                  covtype="matern3_2",noise.var=rep(30*30,times=N))

optimcontrol &lt;- list(method="genoud",pop.size=50)
integcontrol &lt;- list(distrib="sur",n.points=50)
iter &lt;- 1
batchsize &lt;- 6

## Not run: 
  obj &lt;- EGIparallel(T=T,model=model.noise,method="sur",batchsize=batchsize,
                     fun=testfun,iter=iter,lower=lower,upper=upper,
                     optimcontrol=optimcontrol,integcontrol=integcontrol,
                     new.noise.var=10*10)


  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model.noise,T=T,
                       main="probability of excursion, noisy obs.",
                       type="pn",new.points=0,cex.points=2)

  print_uncertainty_2d(model=obj$lastmodel,T=T,
                       main="probability of excursion, parallel sur sampling, noisy obs.",
                       type="pn",new.points=iter*batchsize,col.points.end="red",cex.points=2)

## End(Not run)


##############
# Conservative estimates with non-noisy initial observations
## Not run: 
  testfun &lt;- branin
  # The conservative sampling strategies
  # only work with 1 threshold
  T &lt;- 20
  ## Minimize Type II error sampling

  # The list method.param contains all parameters for the
  # conservative estimate and the conservative sequential
  # strategy. Below are parameters for a type II strategy
  # with conservative estimates at 0.95
  method.param = list(penalization=0, # Type II strategy
                      typeEx="&gt;", consLevel = 0.95,
                      n_discrete_design=500*model@d)
  # If the CE for the initial model is already computed
  # it is possible to pass the conservative Vorob'ev quantile
  # level with method.param$consVorbLevel

  obj_T2 &lt;- EGIparallel(T=T,model=model,method="vorobCons",batchsize=batchsize,
                        fun=testfun,iter=iter,lower=lower,upper=upper,
                        optimcontrol=optimcontrol,
                        integcontrol=integcontrol,method.param=method.param)

  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                       type="pn",new.points=0,cex.points=2,consQuantile = obj_T2$allCE_lvs[1])

  print_uncertainty_2d(model=obj_T2$lastmodel,T=T,
                       main="probability of excursion, parallel Type II sampling",
                       type="pn",new.points=iter*batchsize,col.points.end="red",
                       cex.points=2,consQuantile = obj_T2$allCE_lvs[2])

  ## Maximize conservative estimate's volume
  # Set up method.param
  # Here we pass the conservative level computed
  # in the previous step for the initial model
  method.param = list(typeEx="&gt;", consLevel = 0.95,
                      n_discrete_design=500*model@d,
                      consVorbLevel=obj_T2$allCE_lvs[1]
  )

  obj_consVol &lt;- EGIparallel(T=T,model=model,method="vorobVol",batchsize=batchsize,
                             fun=testfun,iter=iter,lower=lower,upper=upper,
                             optimcontrol=optimcontrol,
                             integcontrol=integcontrol,method.param=method.param)

  par(mfrow=c(1,2))
  print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                       type="pn",new.points=0,cex.points=2,consQuantile = obj_consVol$allCE_lvs[1])

  print_uncertainty_2d(model=obj_consVol$lastmodel,T=T,
                       main="probability of excursion, parallel consVol sampling",
                       type="pn",new.points=iter*batchsize,col.points.end="red",
                       cex.points=2,consQuantile = obj_consVol$allCE_lvs[2])


## End(Not run)

</code></pre>

<hr>
<h2 id='excursion_probability'>Excursion probability with one or many thresholds</h2><span id='topic+excursion_probability'></span>

<h3>Description</h3>

<p>Probability that Gaussian random variables with some mean and variance are over a threshold <code>T</code>, or in an union of intervals.
If <code>T</code> is a vector of size p, T1,T2,...,Tp then the considered union of interval is (T1,T2) U ... U (Tp, +infty) if p is odd, and (T1,T2) U ... U (Tp-1, Tp) if p is even.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>excursion_probability(mn,sn,T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="excursion_probability_+3A_mn">mn</code></td>
<td>
<p>Array of size k containing the expectations of the Gaussian random variables.</p>
</td></tr>
<tr><td><code id="excursion_probability_+3A_sn">sn</code></td>
<td>
<p>Array of size k containing the standard deviations of the Gaussian random variables.</p>
</td></tr>
<tr><td><code id="excursion_probability_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of size k containing the k excursion probabilities.</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict_nobias_km">predict_nobias_km</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#excursion_probability

set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
            response = response,covtype="matern3_2")

some_points &lt;- matrix(runif(20),ncol=2)
pred &lt;- predict_nobias_km(object = model,newdata = some_points,
                type = "UK",se.compute = TRUE)
                
T &lt;- c(60,80,100)
excursion_probability(mn = pred$mean,sn = pred$sd,T=T)
# probability to be in the interval [60,80] U [100, infty]
</code></pre>

<hr>
<h2 id='integration_design'>
Construction of a sample of integration points and weights
</h2><span id='topic+integration_design'></span>

<h3>Description</h3>

<p>Generic function to build integration points for some sampling criterion. 
Available important sampling schemes are <code>"sur"</code>, <code>"jn"</code>, <code>"timse"</code>, <code>"vorob"</code> and <code>"imse"</code>. 
Each of them corresponds to a sampling criterion. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>integration_design(integcontrol = NULL, d = NULL, 
lower, upper, model = NULL, T = NULL,min.prob=0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integration_design_+3A_integcontrol">integcontrol</code></td>
<td>

<p>Optional list specifying the procedure to build the integration points and weights, relevant only for the sampling criteria based on numerical integration: 
(<code>"imse"</code>, <code>"timse"</code>, <code>"sur"</code>, <code>"vorob"</code> or <code>"jn"</code>). Many options are possible.
A) If nothing is specified, 100*d points are chosen using the Sobol sequence. 
B) One can directly set the field <code>integration.points</code> (a p * d matrix) for prespecified integration points. In this case these integration points and the corresponding vector <code>integration.weights</code> will be used for all the iterations of the algorithm. 
C) If the field <code>integration.points</code> is not set then the integration points are renewed at each iteration. 
In that case one can control the number of integration points <code>n.points</code> (default: 100*d) and a specific distribution <code>distrib</code>. Possible values for <code>distrib</code> are: 
<code>"sobol"</code>, <code>"MC"</code>, <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code>, <code>"vorob"</code> and <code>"jn"</code> (default: <code>"sobol"</code>). 
C.1) The choice <code>"sobol"</code> corresponds to integration points chosen with the Sobol sequence in dimension d (equal weights). 
C.2) The choice <code>"MC"</code> corresponds to points chosen randomly, uniformly on the domain (equal weights). 
C.3) The choices <code>"timse"</code>, <code>"imse"</code>, <code>"sur"</code>, <code>"vorob"</code> and <code>"jn"</code> correspond to importance sampling distributions (unequal weights). It is  recommended to use the importance sampling distribution corresponding to the chosen sampling criterion. 
When important sampling procedures are chosen, <code>n.points</code> points are chosen using importance sampling among a discrete set of <code>n.candidates</code> points (default: <code>n.points*10</code>) which are distributed according to a distribution <code>init.distrib</code> (default: <code>"sobol"</code>). Possible values for <code>init.distrib</code> are <code>"sobol"</code> or <code>"MC"</code> (uniform random points) or an user defined distribution <code>"spec"</code>. 
If the <code>"spec"</code> value is chosen the user must fill manually the field <code>init.distrib.spec</code> with a n.candidates*d matrix of points in dimension d.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_d">d</code></td>
<td>

<p>The dimension of the input set. If not provided d is set equal to the length of <code>lower</code>.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="integration_design_+3A_min.prob">min.prob</code></td>
<td>

<p>This argument applies only when importance sampling distributions are chosen. For numerical reasons we give a minimum probability for a point to belong to the importance sample. This avoids potential importance sampling weights equal to infinity. In an importance sample of M points, the maximum weight becomes <code>1/min.prob * 1/M</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The important sampling aims at improving the accuracy of the computation of criteria which involve numerical integration, like <code>"timse"</code>, <code>"sur"</code>, etc.
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>integration.points</code></td>
<td>
<p> p * d matrix of p points used for the numerical calculation of integrals</p>
</td></tr>
<tr><td><code>integration.weights</code></td>
<td>
<p> Vector of size p corresponding to the weights of each points. If all the points are equally weighted, <code>integration.weights</code> is set to <code>NULL</code></p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p> If the <code>"vorob"</code> important sampling schemes is chosen, the function also returns a scalar, alpha, being the calculated Vorob'ev threshold</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+max_timse_parallel">max_timse_parallel</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#integration_design


#when nothing is specified: integration points 
#are chosen with the sobol sequence
integ.param &lt;- integration_design(lower=c(0,0),upper=c(1,1))
plot(integ.param$integration.points)


#an example with pure random integration points
integcontrol &lt;- list(distrib="MC",n.points=50)
integ.param &lt;- integration_design(integcontrol=integcontrol,
		lower=c(0,0),upper=c(1,1))
plot(integ.param$integration.points)

#an example with important sampling distributions
#these distributions are used to compute integral criterion like
#"sur","timse" or "imse"

#for these, we need a kriging model
set.seed(9)
N &lt;- 16;testfun &lt;- branin
lower &lt;- c(0,0);upper &lt;- c(1,1)
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")
integcontrol &lt;- list(distrib="sur",n.points=200,n.candidates=5000,
  init.distrib="MC")
  
T &lt;- c(60,100) 
#we are interested in the set of points where the response is in [60,100]

integ.param &lt;- integration_design(integcontrol=integcontrol,
		lower=c(0,0),upper=c(1,1), model=model,T=T)

print_uncertainty_2d(model=model,T=T,type="sur",
col.points.init="red",cex.points=2,
main="sur uncertainty and one sample of integration points")
points(integ.param$integration.points,pch=17,cex=1)
</code></pre>

<hr>
<h2 id='jn_optim_parallel'> Parallel jn criterion </h2><span id='topic+jn_optim_parallel'></span>

<h3>Description</h3>

<p>Evaluation of the parallel jn criterion for some candidate points. To be used in optimization routines, like in <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the posterior expected <code>"jn"</code> uncertainty, which is the posterior expected variance of the excursion set's volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jn_optim_parallel(x, integration.points, integration.weights = NULL, 
intpoints.oldmean, intpoints.oldsd, 
precalc.data, model, T, 
new.noise.var = NULL, batchsize, current.sur, ai_precalc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jn_optim_parallel_+3A_x">x</code></td>
<td>
<p>Vector of size batchsize*d at which one wants to evaluate the criterion. This argument is NOT a matrix.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_integration.points">integration.points</code></td>
<td>
<p>Matrix of points for numerical integration. Two cases are handled. If the <code>"jn"</code> importance sampling distribution has been used, this is a (2p)*d matrix containing p couples of integration points in D x D, where D is the integration domain. If instead a p*d matrix is given, then the function will perform the integration by using all <code>p^2</code> couples.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p, or 2p, corresponding to the kriging mean at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p, or 2p, corresponding to the kriging standard deviation at the integration points before adding  the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance for the new observations.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_current.sur">current.sur</code></td>
<td>
<p>Current value of the sur criterion (before adding new observations).</p>
</td></tr>
<tr><td><code id="jn_optim_parallel_+3A_ai_precalc">ai_precalc</code></td>
<td>
<p>This is a matrix with ith row equal to <code>intpoints.oldmean-T[i]</code>. The argument DOES ALWAYS need to be filled, even if there is only one threshold T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size batchsize*d (and not a matrix with batchsize rows and d columns) so that an optimizer like genoud can optimize it easily.
For example if d=2, batchsize=3 and <code>x=c(0.1,0.2,0.3,0.4,0.5,0.6)</code>, we will evaluate the parallel criterion at the three points (0.1,0.2),(0.3,0.4) and (0.5,0.6).
</p>


<h3>Value</h3>

<p>Parallel jn value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#jn_optim_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
n.points &lt;- 200
integcontrol &lt;- list(n.points=n.points,distrib="jn",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points # (2n.points)*d matrix
integration.weights &lt;- obj$integration.weights #vector of size n.points
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)
nT &lt;- 2 # number of thresholds
ai_precalc &lt;- matrix(rep(intpoints.oldmean,times=nT),
    nrow=nT,ncol=length(intpoints.oldmean),byrow=TRUE)
ai_precalc &lt;- ai_precalc - T  # substracts Ti to the ith row of ai_precalc

batchsize &lt;- 4
x &lt;- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#one evaluation of the sur_optim_parallel criterion
#we calculate the expectation of the future "sur" uncertainty 
#when 4 points are added to the doe
#the 4 points are (0.1,0.2) , (0.3,0.4), (0.5,0.6), (0.7,0.8)
jn_optim_parallel(x=x,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=0,ai_precalc=ai_precalc)

# the criterion takes a negative value, which is normal.
# See the Technometrics paper in the references

#the function max_sur_parallel will help to find the optimum: 
#ie: the batch of 4 minimizing the expectation of the future uncertainty
</code></pre>

<hr>
<h2 id='jn_optim_parallel2'> Parallel jn criterion </h2><span id='topic+jn_optim_parallel2'></span>

<h3>Description</h3>

<p>Evaluation of the parallel jn criterion for some candidate points, assuming that some other points are also going to be evaluated. 
To be used in optimization routines, like in <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the posterior expected <code>"jn"</code> uncertainty, which is the posterior expected variance of the excursion set's volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jn_optim_parallel2(x, other.points, 
integration.points, integration.weights = NULL, 
intpoints.oldmean, intpoints.oldsd, precalc.data, 
model, T, new.noise.var = NULL, 
batchsize, current.sur,ai_precalc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jn_optim_parallel2_+3A_x">x</code></td>
<td>
<p>Input vector of size d at which one wants to evaluate the criterion. This argument corresponds to only ONE point.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_other.points">other.points</code></td>
<td>
<p>Vector giving the other <code>batchsize-1</code> points at which one wants to evaluate the criterion </p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_integration.points">integration.points</code></td>
<td>
<p>Matrix of points for numerical integration. Two cases are handled. If the <code>"jn"</code> importance sampling distribution has been used, this is a (2p)*d matrix containing p couples of integration points in D x D, where D is the integration domain. If instead a p*d matrix is given, then the function will perform the integration by using all <code>p^2</code> couples.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p, or 2p, corresponding to the kriging mean at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p, or 2p, corresponding to the kriging standard deviation at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance of the new observations.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_current.sur">current.sur</code></td>
<td>
<p>Current value of the sur criterion (before adding new observations)</p>
</td></tr>
<tr><td><code id="jn_optim_parallel2_+3A_ai_precalc">ai_precalc</code></td>
<td>
<p>When multiple thresholds are used (i.e. when T is a vector), this is an nT*p matrix with ith row equal to <code>intpoints.oldmean-T[i]</code>. The argument DOES ALWAYS need to be filled, even if there is only one threshold T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size d so that an optimizer like genoud can optimize it easily.
The second argument <code>other.points</code> is a vector of size (batchsize-1)*d corresponding to the batchsize-1 other points.
</p>


<h3>Value</h3>

<p>Parallel jn value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#jn_optim_parallel2

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #threshold or thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=200,distrib="jn",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,lower=c(0,0),upper=c(1,1),
model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
                          type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)
nT &lt;- 2 # number of thresholds
ai_precalc &lt;- matrix(rep(intpoints.oldmean,times=nT),
    nrow=nT,ncol=length(intpoints.oldmean),byrow=TRUE)
ai_precalc &lt;- ai_precalc - T  # substracts Ti to the ith row of ai_precalc

batchsize &lt;- 4
other.points &lt;- c(0.7,0.5,0.5,0.9,0.9,0.8)
x &lt;- c(0.1,0.2)
#one evaluation of the jn_optim_parallel criterion2
#we calculate the expectation of the future "sur" uncertainty when 
#1+3 points are added to the doe
#the 1+3 points are (0.1,0.2) and (0.7,0.5), (0.5,0.9), (0.9,0.8)
jn_optim_parallel2(x=x,other.points,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=Inf,ai_precalc=ai_precalc)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
jn_parallel.grid &lt;- apply(X=x,FUN=jn_optim_parallel2,MARGIN=1,other.points,
          integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=Inf,ai_precalc=ai_precalc)
z.grid &lt;- matrix(jn_parallel.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(matrix(other.points,ncol=2,byrow=TRUE), col="red", pch=17, lwd=4,cex=2)

i.best &lt;- which.min(jn_parallel.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of jn_parallel criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='KrigInv-package'> Kriging-Based Inversion for Deterministic and Noisy Computer Experiments </h2><span id='topic+KrigInv'></span>

<h3>Description</h3>

<p>Kriging-based sequential algorithms, meant to identify the excursion set of a real valued function. The algorithms can also identify one or several level sets.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> KrigInv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-09-04</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL version 3</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Note</h3>

<p>Important functions are <code><a href="#topic+EGI">EGI</a></code> and <code><a href="#topic+EGIparallel">EGIparallel</a></code>. The last 1.4 version allows to handle multiple thresholds T, stored in an array and implements conservative excursion set strategies.
</p>
<p>A first prototype of this package was originally developed by D. Ginsbourger in the frame of a collaboration with IRSN (Institut de Radioprotection et de Surete Nucleaire), acting through Yann Richet. The three main authors thank IRSN for sponsoring open source research, and allowing them to spread the present package and publish it on CRAN. They also would like to warmly thank Yann Richet for numerous discussions concerning this package, and more!
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>
<p>with contributions from Yann Richet (IRSN, France)
</p>
<p>Maintainer: Clement Chevalier (clement.chevalier@unine.ch)
</p>


<h3>References</h3>

<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier C., Picheny V., Ginsbourger D. (2014), <em>Kriginv: An efficient and user-friendly implementation of batch sequential inversion strategies based on kriging</em> (2014) Computational Statistics &amp; Data Analysis, vol. 71, pp 1021-1034
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>
<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Picheny V. (2009) <em>Improving accuracy and compensating for uncertainty in surrogate modeling</em>, Ph.D. thesis, University of Florida and Ecole Nationale Superieure des Mines de Saint-Etienne
</p>
<p>Bichon B.J., Eldred M.S., Swiler L.P., Mahadevan S., McFarland J.M. (2008) <em>Efficient global reliability analysis for nonlinear implicit performance functions</em>, AIAA Journal 46(10), pp 2459-2468
</p>
<p>Ranjan P., Bingham D., Michailidis G. (2008) <em>Sequential experiment design for contour estimation from complex computer codes</em> Technometrics 50(4), pp 527-541
</p>

<hr>
<h2 id='max_futureVol_parallel'>Maximize parallel volume criterion</h2><span id='topic+max_futureVol_parallel'></span>

<h3>Description</h3>

<p>Maximizes the criterion <code>vorobVol_optim_parallel</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_futureVol_parallel(lower, upper, optimcontrol = NULL, batchsize,
  integration.param, T, model, new.noise.var = 0, typeEx = "&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_futureVol_parallel_+3A_lower">lower</code></td>
<td>
<p>lower bounds of the domain</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_upper">upper</code></td>
<td>
<p>upper bounds of the domain</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_optimcontrol">optimcontrol</code></td>
<td>
<p>optional list of control parameters for optimization aspects, see <code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code> for details</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>size of the batch of new points</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_integration.param">integration.param</code></td>
<td>
<p>Optional list of control parameter for the computation of integrals, containing the fields <code>integration.points</code>: a p*d matrix corresponding to p integrations points and <code>integration.weights</code>: a vector of size p corresponding to the weights of these integration points.
If nothing is specified, default values are used (see: function <code><a href="#topic+integration_design">integration_design</a></code> for more details). </p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_t">T</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_model">model</code></td>
<td>
<p>a km Model</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar with the noise variance at the new observation</p>
</td></tr>
<tr><td><code id="max_futureVol_parallel_+3A_typeex">typeEx</code></td>
<td>
<p>a character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing <code>par</code>, the best set of parameters found, <code>value</code> the value of the criterion and <code>alpha</code>, the Vorob'ev quantile corresponding to the conservative estimate.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). <em>Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation</em>.  Journal of Computational and Graphical Statistics, 27(2), 255-267.
</p>
<p>Azzimonti, D. (2016). <em>Contributions to Bayesian set estimation relying on random field priors</em>. PhD thesis, University of Bern.
</p>
<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier, C., Bect, J., Ginsbourger, D., Vazquez, E., Picheny, V., and Richet, Y. (2014). <em>Fast kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>. Technometrics, 56(4):455-465.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>,<code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#max_futureVol_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
            response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=200,optim.option=2)
integcontrol &lt;- list(distrib="timse",n.points=400,init.distrib="MC")
integration.param &lt;- integration_design(integcontrol=integcontrol,d=2,
                                        lower=lower,upper=upper,model=model,
                                        T=T)

batchsize &lt;- 5 #number of new points

## Not run: 
  obj &lt;- max_futureVol_parallel(lower=lower,upper=upper,optimcontrol=optimcontrol,
                            batchsize=batchsize,T=T,model=model,
                            integration.param=integration.param)
  #5 optims in dimension 2 !

  obj$par;obj$value #optimum in 5 new points
  new.model &lt;- update(object=model,newX=obj$par,newy=apply(obj$par,1,testfun),
                      cov.reestim=TRUE)

  consLevel = 0.95; n_discrete_design=500*new.model@d
  CE_design=as.matrix (randtoolbox::sobol (n = n_discrete_design,
                              dim = new.model@d))
  colnames(CE_design) &lt;- colnames(new.model@X)
  current.pred = predict.km(object = new.model,
                            newdata = CE_design,
                            type = "UK",cov.compute = TRUE)
  current.pred$cov &lt;- current.pred$cov +1e-7*diag(nrow = nrow(current.pred$cov),
                                                  ncol = ncol(current.pred$cov))

  current.CE = anMC::conservativeEstimate(alpha = consLevel, pred=current.pred,
                                    design=CE_design, threshold=T, pn = NULL,
                                    type = "&gt;", verb = 1,
                                    lightReturn = TRUE, algo = "GANMC")

  par(mfrow=c(1,2))
  print_uncertainty(model=model,T=T,type="pn",lower=lower,upper=upper,
                    cex.points=2.5,main="probability of excursion",consQuantile=obj$alpha)

  print_uncertainty(model=new.model,T=T,type="pn",lower=lower,upper=upper,
                    new.points=batchsize,col.points.end="red",cex.points=2.5,
                    main="updated probability of excursion",consQuantile=current.CE$lvs)


## End(Not run)
</code></pre>

<hr>
<h2 id='max_infill_criterion'>Optimizer for the infill criteria</h2><span id='topic+max_infill_criterion'></span>

<h3>Description</h3>

<p>Optimization, of the chosen infill criterion (maximization or minimization, depending on the case)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_infill_criterion(lower, upper, optimcontrol = NULL, 
method, T, model, method.param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_infill_criterion_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used. It can be either <code>"genoud"</code> (default) for an optimization using the genoud algorithm, or <code>"discrete"</code> for an optimization over a specified discrete set. 
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm: 
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (10*d), <code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly. 
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_method">method</code></td>
<td>

<p>Criterion used for choosing observations: <code>"ranjan"</code> (default) , <code>"bichon"</code>, <code>"tsee"</code>, or <code>"tmse"</code>.
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds. The <code>"tmse"</code> criterion can be used with multiple thresholds. The <code>"ranjan"</code>, <code>"bichon"</code>, <code>"tsee"</code> criteria can be used with only one threshold.
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="max_infill_criterion_+3A_method.param">method.param</code></td>
<td>

<p>Optional tolerance value (scalar). Default value is 1 for <code>"ranjan"</code> and <code>"bichon"</code>, and 0 for <code>"tmse"</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>The best set of parameters found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>The value of the chosen criterion at par.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2012), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing vol. 22(3), pp 773-793
</p>
<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Bichon B.J., Eldred M.S., Swiler L.P., Mahadevan S., McFarland J.M. (2008) <em>Efficient global reliability analysis for nonlinear implicit performance functions</em>, AIAA Journal 46(10), pp 2459-2468
</p>
<p>Ranjan P., Bingham D., Michailidis G. (2008) <em>Sequential experiment design for contour estimation from complex computer codes</em> Technometrics 50(4), pp 527-541
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>,<code><a href="#topic+ranjan_optim">ranjan_optim</a></code>,<code><a href="#topic+tmse_optim">tmse_optim</a></code>,<code><a href="#topic+bichon_optim">bichon_optim</a></code>,<code><a href="#topic+tsee_optim">tsee_optim</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#max_infill_criterion

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=50)

## Not run: 
obj &lt;- max_infill_criterion(lower=lower,upper=upper,optimcontrol=optimcontrol,
                             method="bichon",T=T,model=model)

obj$par;obj$value
new.model &lt;- update(object=model,newX=obj$par,newy=testfun(obj$par),cov.reestim=TRUE)

par(mfrow=c(1,2))
print_uncertainty(model=model,T=T,type="pn",lower=lower,upper=upper,
cex.points=2.5,main="probability of excursion")

print_uncertainty(model=new.model,T=T,type="pn",lower=lower,upper=upper,
new.points=1,col.points.end="red",cex.points=2.5,main="updated probability of excursion")

## End(Not run)
</code></pre>

<hr>
<h2 id='max_sur_parallel'> Minimizer of the parallel <code>"sur"</code> or <code>"jn"</code> criterion</h2><span id='topic+max_sur_parallel'></span>

<h3>Description</h3>

<p>Minimization, based on the package rgenoud (or on exhaustive search on a discrete set), of the <code>"sur"</code> or <code>"jn"</code> criterion for a batch of candidate sampling points.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_sur_parallel(lower, upper, optimcontrol = NULL, 
batchsize, integration.param, T,
model, new.noise.var = 0,real.volume.variance=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_sur_parallel_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used: it can be either <code>"genoud"</code> (default) for an optimisation using the genoud algorithm, or <code>"discrete"</code> for an optimisation over a specified discrete set. 
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm: 
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (10*d), <code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly. 
Finally, one can control the field optim.option in order to decide how to optimize the sampling criterion. 
If <code>optim.option</code> is set to 2 (default), batchsize sequential optimizations in dimension d are performed to find the optimum.
If <code>optim.option</code> is set to 1, only one optimization in dimension batchsize*d is performed. This option is only available with <code>"genoud"</code>. This option might provide more global and accurate solutions, but is a lot more expensive.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_batchsize">batchsize</code></td>
<td>

<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_integration.param">integration.param</code></td>
<td>

<p>Optional list of control parameter for the computation of integrals, containing the fields <code>integration.points</code>: a p*d matrix corresponding to p integrations points and <code>integration.weights</code>: a vector of size p corresponding to the weights of these integration points. 
If nothing is specified, default values are used (see: function <code><a href="#topic+integration_design">integration_design</a></code> for more details). 
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_t">T</code></td>
<td>

<p>Target value (scalar).
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>

<p>Optional scalar value of the noise variance of the new observations.
</p>
</td></tr>
<tr><td><code id="max_sur_parallel_+3A_real.volume.variance">real.volume.variance</code></td>
<td>
<p>Optional argument to use the <code>"jn"</code> criterion instead of <code>"sur"</code>. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>the best set of points found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the sur criterion at par.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>,<code><a href="#topic+sur_optim_parallel">sur_optim_parallel</a></code>,<code><a href="#topic+jn_optim_parallel">jn_optim_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#max_sur_parallel


set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(40,80) #thresholds
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=50,optim.option=1)
integcontrol &lt;- list(distrib="sur",n.points=50,init.distrib="MC")
integration.param &lt;- integration_design(integcontrol=integcontrol,d=2,
                                            lower=lower,upper=upper,model=model,
                                            T=T)
batchsize &lt;- 5 #number of new points

## Not run: 
obj &lt;- max_sur_parallel(lower=lower,upper=upper,optimcontrol=optimcontrol,
                        batchsize=batchsize,T=T,model=model,
                        integration.param=integration.param)
                        #one (hard) optim in dimension 5*2 !

obj$par;obj$value #optimum in 5 new points
new.model &lt;- update(object=model,newX=obj$par,newy=apply(obj$par,1,testfun),
                       cov.reestim=TRUE)


par(mfrow=c(1,2))
print_uncertainty(model=model,T=T,type="pn",lower=lower,upper=upper,
cex.points=2.5,main="probability of excursion")

print_uncertainty(model=new.model,T=T,type="pn",lower=lower,upper=upper,
new.points=batchsize,col.points.end="red",cex.points=2.5,
main="updated probability of excursion")

## End(Not run)
</code></pre>

<hr>
<h2 id='max_timse_parallel'> Minimizer of the parallel timse criterion</h2><span id='topic+max_timse_parallel'></span>

<h3>Description</h3>

<p>Minimization, based on the package rgenoud (or on exhaustive search on a discrete set), of the timse criterion for a batch of candidate sampling points.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_timse_parallel(lower, upper, optimcontrol = NULL, 
batchsize, integration.param, T,
model, new.noise.var = 0,
epsilon=0,imse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_timse_parallel_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used: it can be either <code>"genoud"</code> (default) for an optimisation using the genoud algorithm, or <code>"discrete"</code> for an optimisation over a specified discrete set. 
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm: 
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (10*d), <code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly. 
Finally, one can control the field optim.option in order to decide how to optimize the sampling criterion. 
If <code>optim.option</code> is set to 2 (default), batchsize sequential optimizations in dimension d are performed to find the optimum.
If <code>optim.option</code> is set to 1, only one optimization in dimension batchsize*d is performed. This option is only available with <code>"genoud"</code>. This option might provide more global and accurate solutions, but is a lot more expensive.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_batchsize">batchsize</code></td>
<td>

<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_integration.param">integration.param</code></td>
<td>

<p>Optional list of control parameter for the computation of integrals, containing the fields <code>integration.points</code>: a p*d matrix corresponding to p integrations points and <code>integration.weights</code>: a vector of size p corresponding to the weights of these integration points. 
If nothing is specified, default values are used (see: function <code><a href="#topic+integration_design">integration_design</a></code> for more details). 
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>

<p>Optional scalar value of the noise variance of the new observations.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_epsilon">epsilon</code></td>
<td>

<p>Optional tolerance value (a real positive number). Default value is 0.
</p>
</td></tr>
<tr><td><code id="max_timse_parallel_+3A_imse">imse</code></td>
<td>

<p>Optional boolean to decide if the <code>"imse"</code> criterion should be used instead of <code>"timse"</code>. default: <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>the best set of parameters found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the sur criterion at par.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Picheny V. (2009) <em>Improving accuracy and compensating for uncertainty in surrogate modeling</em>, Ph.D. thesis, University of Florida and Ecole Nationale Superieure des Mines de Saint-Etienne
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>,<code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#max_timse_parallel


set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(40,80) #thresholds
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=200,optim.option=2)
integcontrol &lt;- list(distrib="timse",n.points=400,init.distrib="MC")
integration.param &lt;- integration_design(integcontrol=integcontrol,d=2,
                                            lower=lower,upper=upper,model=model,
                                            T=T)
batchsize &lt;- 5 #number of new points

## Not run: 
obj &lt;- max_timse_parallel(lower=lower,upper=upper,optimcontrol=optimcontrol,
                        batchsize=batchsize,T=T,model=model,
                        integration.param=integration.param,epsilon=0,imse=FALSE)
                        #5 optims in dimension 2 !

obj$par;obj$value #optimum in 5 new points
new.model &lt;- update(object=model,newX=obj$par,newy=apply(obj$par,1,testfun),
                       cov.reestim=TRUE)

par(mfrow=c(1,2))
print_uncertainty(model=model,T=T,type="pn",lower=lower,upper=upper,
cex.points=2.5,main="probability of excursion")

print_uncertainty(model=new.model,T=T,type="pn",lower=lower,upper=upper,
new.points=batchsize,col.points.end="red",cex.points=2.5,
main="updated probability of excursion")


## End(Not run)
</code></pre>

<hr>
<h2 id='max_vorob_parallel'> Minimizer of the parallel vorob criterion</h2><span id='topic+max_vorob_parallel'></span>

<h3>Description</h3>

<p>Minimization, based on the package rgenoud (or on exhaustive search on a discrete set), of the Vorob'ev criterion for a batch of candidate sampling points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_vorob_parallel(lower, upper, optimcontrol = NULL,
batchsize, integration.param, T,
model, new.noise.var = 0,
penalisation = NULL, typeEx = "&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_vorob_parallel_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the design space.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_optimcontrol">optimcontrol</code></td>
<td>

<p>Optional list of control parameters for the optimization of the sampling criterion. The field <code>method</code> defines which optimization method is used: it can be either <code>"genoud"</code> (default) for an optimisation using the genoud algorithm, or <code>"discrete"</code> for an optimisation over a specified discrete set.
If the field <code>method</code> is set to <code>"genoud"</code>, one can set some parameters of this algorithm:
<code>pop.size</code>  (default : 50*d),  <code>max.generations</code> (10*d), <code>wait.generations</code> (2),  <code>BFGSburnin</code> (2) and the mutations <code>P1</code>, <code>P2</code>, up to <code>P9</code> (see <code><a href="rgenoud.html#topic+genoud">genoud</a></code>). Numbers into brackets are the default values.
If the field <code>method</code> is set to <code>"discrete"</code>, one can set the field <code>optim.points</code>: p * d matrix corresponding to the p points where the criterion will be evaluated. If nothing is specified, 100*d points are chosen randomly.
Finally, one can control the field optim.option in order to decide how to optimize the sampling criterion.
If <code>optim.option</code> is set to 2 (default), batchsize sequential optimizations in dimension d are performed to find the optimum.
If <code>optim.option</code> is set to 1, only one optimization in dimension batchsize*d is performed. This option is only available with <code>"genoud"</code>. This option might provide more global and accurate solutions, but is a lot more expensive.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_batchsize">batchsize</code></td>
<td>

<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_integration.param">integration.param</code></td>
<td>

<p>Optional list of control parameter for the computation of integrals, containing the fields <code>integration.points</code>: a p*d matrix corresponding to p integrations points and <code>integration.weights</code>: a vector of size p corresponding to the weights of these integration points.
If nothing is specified, default values are used (see: function <code><a href="#topic+integration_design">integration_design</a></code> for more details).
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_t">T</code></td>
<td>

<p>Target value (scalar). The criterion CANNOT be used with multiple thresholds.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>

<p>Optional scalar value of the noise variance of the new observations.
</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_penalisation">penalisation</code></td>
<td>
<p>Optional penalization constant for type I errors. If equal to zero,  computes the Type II criterion.</p>
</td></tr>
<tr><td><code id="max_vorob_parallel_+3A_typeex">typeEx</code></td>
<td>
<p>A character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>par</code></td>
<td>
<p>the best set of parameters found.</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>the value of the Vorob'ev criterion at par.</p>
</td></tr>
<tr><td><code>allvalues</code></td>
<td>
<p>If an optimization on a discrete set of points is chosen, the value of the criterion at all these points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Ginsbouger D., Bect J., Molchanov I. (2013) <em>Estimating and quantifying uncertainties on level sets using the Vorob'ev expectation and deviation with gaussian process models</em> mODa 10, Advances in Model-Oriented Design and Analysis, Contributions to Statistics, pp 35-43
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>
<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets.</em> Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>,<code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#max_vorob_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

optimcontrol &lt;- list(method="genoud",pop.size=200,optim.option=2)
integcontrol &lt;- list(distrib="timse",n.points=400,init.distrib="MC")
integration.param &lt;- integration_design(integcontrol=integcontrol,d=2,
                                            lower=lower,upper=upper,model=model,
                                            T=T)
batchsize &lt;- 5 #number of new points

## Not run: 
obj &lt;- max_vorob_parallel(lower=lower,upper=upper,optimcontrol=optimcontrol,
                        batchsize=batchsize,T=T,model=model,
                        integration.param=integration.param)
                        #5 optims in dimension 2 !

obj$par;obj$value #optimum in 5 new points
new.model &lt;- update(object=model,newX=obj$par,newy=apply(obj$par,1,testfun),
                       cov.reestim=TRUE)

par(mfrow=c(1,2))
print_uncertainty(model=model,T=T,type="pn",lower=lower,upper=upper,vorobmean=TRUE,
cex.points=2.5,main="probability of excursion")

print_uncertainty(model=new.model,T=T,type="pn",lower=lower,upper=upper,vorobmean=TRUE,
new.points=batchsize,col.points.end="red",cex.points=2.5,
main="updated probability of excursion")


## End(Not run)
</code></pre>

<hr>
<h2 id='precomputeUpdateData'>Useful precomputations to quickly update kriging mean and variance</h2><span id='topic+precomputeUpdateData'></span>

<h3>Description</h3>

<p>This function is used in combination with <code><a href="#topic+computeQuickKrigcov">computeQuickKrigcov</a></code> and computes an output list that serves as input in that function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precomputeUpdateData(model, integration.points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precomputeUpdateData_+3A_model">model</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="precomputeUpdateData_+3A_integration.points">integration.points</code></td>
<td>

<p>p*d matrix of points for numerical integration in the X space.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>Kinv.c.olddata</code></td>
<td>
<p>Matrix equal to K^(-1)*c where K is the non conditional covariance matrix at the design points and c is the non conditional covariances between the design points and the integration points.</p>
</td></tr>
<tr><td><code>Kinv.F</code></td>
<td>
<p>Matrix equal to K^(-1)*F where F is a matrix with the values of the trend functions at the design points.</p>
</td></tr>
<tr><td><code>first.member</code></td>
<td>
<p>Matrix with a complicated expression.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeQuickKrigcov">computeQuickKrigcov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#precomputeUpdateData

set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

#the points where we want to compute prediction (if a point new.x is added to the doe)
n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
integration.points &lt;- expand.grid(x.grid,y.grid)
integration.points &lt;- as.matrix(integration.points)
precalc.data &lt;- precomputeUpdateData(model=model,integration.points=integration.points)

#now we can compute quickly kriging covariances 
#between the integration.points and any other points
newdata &lt;- matrix(c(0.6,0.6),ncol=2)
pred &lt;- predict_nobias_km(object=model,newdata=newdata,type="UK",se.compute=TRUE)

kn &lt;- computeQuickKrigcov(model=model,integration.points=integration.points,X.new=newdata,
                    precalc.data=precalc.data,F.newdata=pred$F.newdata,
                    c.newdata=pred$c)

z.grid &lt;- matrix(kn, n.grid, n.grid)

#plots: contour of the covariances, DOE points and new point
#these covariances have been computed quickly with computeQuickKrigcov
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(newdata, col="red", pch=17, lwd=4,cex=3)
title("Kriging covariances with the point (0.6,0.6), in red")
</code></pre>

<hr>
<h2 id='predict_nobias_km'> Kriging predictions</h2><span id='topic+predict_nobias_km'></span>

<h3>Description</h3>

<p>This function is similar to the predict.km function from the DiceKriging package. 
The only change is the additionnal F.newdata output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_nobias_km(object, newdata, type = "UK", 
se.compute = TRUE, cov.compute = FALSE, low.memory=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_nobias_km_+3A_object">object</code></td>
<td>

<p>A Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_newdata">newdata</code></td>
<td>

<p>Vector, matrix or data frame containing the points where to perform predictions.
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_type">type</code></td>
<td>

<p>Character string corresponding to the kriging family, to be chosen between simple kriging (&quot;SK&quot;), or universal kriging (&quot;UK&quot;).
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_se.compute">se.compute</code></td>
<td>

<p>Optional boolean. If <code>FALSE</code>, only the kriging mean is computed. If <code>TRUE</code>, the kriging standard deviation and confidence intervals are computed too.
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_cov.compute">cov.compute</code></td>
<td>

<p>Optional boolean. If <code>TRUE</code> the conditional covariance matrix is computed.
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_low.memory">low.memory</code></td>
<td>

<p>Optional boolean. If set to <code>TRUE</code> the function will only return kriging means and standard deviations.
</p>
</td></tr>
<tr><td><code id="predict_nobias_km_+3A_...">...</code></td>
<td>

<p>No other arguments.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>mean</code></td>
<td>
<p> kriging mean (including the trend) computed at <code>newdata</code>. </p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p> kriging standard deviation computed at <code>newdata</code>. 
Not computed if <code>se.compute=FALSE</code>. </p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p> kriging conditional covariance matrix. Not computed if <code>cov.compute=FALSE</code> (default).</p>
</td></tr>
<tr><td><code>lower95</code></td>
<td>
 </td></tr>
<tr><td><code>upper95</code></td>
<td>
<p> bounds of the 95 % confidence interval computed at <code>newdata</code> (to be interpreted with special care when parameters are estimated, see description above). Not computed if <code>se.compute=FALSE</code>.</p>
</td></tr>
<tr><td><code>c</code></td>
<td>
<p> an auxiliary matrix, containing all the covariances between newdata and the initial design points. </p>
</td></tr>
<tr><td><code>Tinv.c</code></td>
<td>
<p> an auxiliary vector, equal to <code>T^(-1)*c</code>.</p>
</td></tr>
<tr><td><code>F.newdata</code></td>
<td>
<p>value of the trend function at <code>newdata</code>.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>Beware that the only consistency check between <code>newdata</code> and the experimental design is to test whether they have same number of columns. In that case, the columns of <code>newdata</code> are interpreted in the same order as the initial design.
</p>


<h3>Author(s)</h3>

<p>O. Roustant (Ecole des Mines de St-Etienne, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>


<h3>References</h3>

<p>N.A.C. Cressie (1993), <em>Statistics for spatial data</em>, Wiley series in probability and mathematical statistics.
</p>
<p>A.G. Journel and C.J. Huijbregts (1978), <em>Mining Geostatistics</em>, Academic Press, London.
</p>
<p>D.G. Krige (1951), A statistical approach to some basic mine valuation problems on the witwatersrand, <em>J. of the Chem., Metal. and Mining Soc. of South Africa</em>, <b>52</b> no. 6, 119-139.
</p>
<p>J.D. Martin and T.W. Simpson (2005), Use of kriging models to approximate deterministic computer models, <em>AIAA Journal</em>, <b>43</b> no. 4, 853-863.
</p>
<p>G. Matheron (1963), Principles of geostatistics, <em>Economic Geology</em>, <b>58</b>,
1246-1266.
</p>
<p>G. Matheron (1969), Le krigeage universel, <em>Les Cahiers du Centre de Morphologie Mathematique de Fontainebleau</em>, <b>1</b>.
</p>
<p>J.-S. Park and J. Baek (2001), Efficient computation of maximum likelihood estimators in a spatial linear model with power exponential covariogram, <em>Computer Geosciences</em>, <b>27</b> no. 1, 1-7.
</p>
<p>C.E. Rasmussen and C.K.I. Williams (2006), <em>Gaussian Processes for Machine Learning</em>, the MIT Press, <a href="https://gaussianprocess.org/gpml/">https://gaussianprocess.org/gpml/</a>
</p>
<p>J. Sacks, W.J. Welch, T.J. Mitchell, and H.P. Wynn (1989), Design and analysis of computer experiments, <em>Statistical Science</em>, <b>4</b>, 409-435.
</p>


<h3>See Also</h3>

  <p><code><a href="DiceKriging.html#topic+predict.km">predict.km</a></code>,  <code><a href="DiceKriging.html#topic+km">km</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#predict_nobias_km
set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

n.grid &lt;- 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)

newdata &lt;- expand.grid(x.grid,y.grid)
pred &lt;- predict_nobias_km(object=model,newdata=newdata,type="UK",se.compute=TRUE)

z.grid1 &lt;- matrix(pred$mean, n.grid, n.grid)
z.grid2 &lt;- matrix(pred$sd, n.grid, n.grid)

par(mfrow=c(1,2))

#plots: contour of the kriging mean and stdev
image(x=x.grid,y=y.grid,z=z.grid1,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid1,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
title("Kriging mean")

image(x=x.grid,y=y.grid,z=z.grid2,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid2,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
title("Kriging standard deviation")
</code></pre>

<hr>
<h2 id='predict_update_km_parallel'>
Quick update of kriging means and variances when one or many new points are added to the DOE.
</h2><span id='topic+predict_update_km_parallel'></span>

<h3>Description</h3>

<p>The functions uses the kriging update formulas to quickly compute kriging mean and variances at points newdata, when <code>r</code> new points <code>newX</code> are added. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_update_km_parallel(newXmean, newXvar, newXvalue, 
Sigma.r, newdata.oldmean, newdata.oldsd, kn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_update_km_parallel_+3A_newxmean">newXmean</code></td>
<td>

<p>Vector of size r: old kriging mean at points x_(n+1),...,x_(n+r).
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_newxvar">newXvar</code></td>
<td>

<p>Vector of size r: kriging variance at points x_(n+1),...,x_(n+r).
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_newxvalue">newXvalue</code></td>
<td>

<p>Vector of size r: value of the objective function at x_(n+1),...,x_(n+r).
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_sigma.r">Sigma.r</code></td>
<td>

<p>An r*r matrix: kriging covariances between the points x_(n+1),...,x_(n+r).
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_newdata.oldmean">newdata.oldmean</code></td>
<td>

<p>Vector: old kriging mean at the points <code>newdata</code> (before adding x_(n+1),...,x_(n+r))
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_newdata.oldsd">newdata.oldsd</code></td>
<td>

<p>Vector: old kriging standard deviations at the points <code>newdata</code> (before adding x_(n+1),...,x_(n+r))
</p>
</td></tr>
<tr><td><code id="predict_update_km_parallel_+3A_kn">kn</code></td>
<td>

<p>Kriging covariances between the points <code>newdata</code> and the r points <code>newX</code>. These covariances can be computed using the function <code><a href="#topic+computeQuickKrigcov">computeQuickKrigcov</a></code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following fields:
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>Updated kriging mean at points <code>newdata</code></p>
</td></tr>
<tr><td><code>sd</code></td>
<td>
<p>Updated kriging standard deviation at points <code>newdata</code></p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>
<p>New kriging weight of x_(n+1),...,x_(n+r) for the prediction at points <code>newdata</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+computeQuickKrigcov">computeQuickKrigcov</a></code>, <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#predict_update_km_parallel

set.seed(9)
N &lt;- 20 #number of observations
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

#points where we want to compute prediction (if a point new.x is added to the doe)
n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
newdata &lt;- expand.grid(x.grid,y.grid)
newdata &lt;- as.matrix(newdata)
precalc.data &lt;- precomputeUpdateData(model=model,integration.points=newdata)
pred2 &lt;- predict_nobias_km(object=model,newdata=newdata,type="UK",se.compute=TRUE)
newdata.oldmean &lt;- pred2$mean; newdata.oldsd &lt;- pred2$sd

#the point that we are going to add
new.x &lt;- matrix(c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8),ncol=2,byrow=TRUE)   
pred1 &lt;- predict_nobias_km(object=model,newdata=new.x,type="UK",
se.compute=TRUE,cov.compute=TRUE)
newXmean &lt;- pred1$mean; newXvar &lt;- pred1$sd^2; newXvalue &lt;- pred1$mean + 2*pred1$sd
Sigma.r &lt;- pred1$cov

kn &lt;- computeQuickKrigcov(model=model,integration.points=newdata,X.new=new.x,
                    precalc.data=precalc.data,F.newdata=pred1$F.newdata,
                    c.newdata=pred1$c)

updated.predictions &lt;- predict_update_km_parallel(newXmean=newXmean,newXvar=newXvar,
                                         newXvalue=newXvalue,Sigma.r=Sigma.r,
                                         newdata.oldmean=newdata.oldmean,
                                         newdata.oldsd=newdata.oldsd,kn=kn)

#the new kriging variance is usually lower than the old one
updated.predictions$sd - newdata.oldsd 

z.grid1 &lt;- matrix(newdata.oldsd, n.grid, n.grid)
z.grid2 &lt;- matrix(updated.predictions$sd, n.grid, n.grid)

par(mfrow=c(1,2))

image(x=x.grid,y=y.grid,z=z.grid1,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid1,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
title("Kriging standard deviation")

image(x=x.grid,y=y.grid,z=z.grid2,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid2,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(new.x, col="red", pch=17, lwd=4,cex=2)
title("updated Kriging standard deviation")
</code></pre>

<hr>
<h2 id='print_uncertainty'>
Prints a measure of uncertainty for a function of any dimension.
</h2><span id='topic+print_uncertainty'></span>

<h3>Description</h3>

<p>This function prints the value of a given measure of uncertainty. 
The function can be used to print relevant outputs after having used the function <code><a href="#topic+EGI">EGI</a></code> or <code><a href="#topic+EGIparallel">EGIparallel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_uncertainty(model, T, type = "pn", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_uncertainty_+3A_model">model</code></td>
<td>

<p>Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_+3A_type">type</code></td>
<td>

<p>Type of uncertainty that the user wants to print. 
Possible values are <code>"pn"</code> (probability of excursion), or 
<code>"sur"</code>, <code>"imse"</code>, <code>"timse"</code>, <code>"vorob"</code> if we print a measure of uncertainty corresponding to one criterion.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_+3A_...">...</code></td>
<td>

<p>Other arguments of the functions <code>print_uncertainty_1d</code>, <code>2d</code> or <code>nd</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the integrated uncertainty
</p>


<h3>Author(s)</h3>

 
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2012), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing vol. 22(3), pp 773-793
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_uncertainty_1d">print_uncertainty_1d</a></code>,<code><a href="#topic+print_uncertainty_2d">print_uncertainty_2d</a></code>,<code><a href="#topic+print_uncertainty_nd">print_uncertainty_nd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#print_uncertainty

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #threshold
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

#you could do many plots, but only one is run here
print_uncertainty(model=model,T=T,main="probability of excursion",type="pn")
#print_uncertainty(model=model,T=T,main="Vorob'ev uncertainty",type="vorob")
#print_uncertainty(model=model,T=T,main="imse uncertainty",type="imse")
#print_uncertainty(model=model,T=T,main="timse uncertainty",type="timse")
#print_uncertainty(model=model,T=T,main="sur uncertainty",type="sur")
#print_uncertainty(model=model,T=T,main="probability of excursion",type="pn",
#vorobmean=TRUE)
</code></pre>

<hr>
<h2 id='print_uncertainty_1d'>
Prints a measure of uncertainty for 1d function.
</h2><span id='topic+print_uncertainty_1d'></span>

<h3>Description</h3>

<p>This function draws the value of a given measure of uncertainty over the whole input domain (1D).
The function can be used to print relevant outputs after having used the function <code><a href="#topic+EGI">EGI</a></code> or <code><a href="#topic+EGIparallel">EGIparallel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_uncertainty_1d(model, T, type = "pn",
lower = 0, upper = 1, resolution = 500, new.points = 0,
xscale = c(0, 1), show.points = TRUE, cex.points = 1,
cex.axis = 1, pch.points.init = 17, pch.points.end = 17,
col.points.init = "black", col.points.end = "red", xaxislab = NULL,
yaxislab = NULL, xaxispoint = NULL, yaxispoint = NULL,
vorobmean=FALSE,krigmeanplot=FALSE,Tplot=FALSE,consQuantile=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_uncertainty_1d_+3A_model">model</code></td>
<td>

<p>Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_type">type</code></td>
<td>

<p>Type of uncertainty that the user wants to print.
Possible values are <code>"pn"</code> (probability of excursion), or
<code>"sur"</code>, <code>"imse"</code>, <code>"timse"</code>, <code>"vorob"</code> if we print a measure of uncertainty corresponding to one criterion.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_lower">lower</code></td>
<td>

<p>Lower bound for the input domain.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_upper">upper</code></td>
<td>

<p>Upper bound for the input domain.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_resolution">resolution</code></td>
<td>

<p>Number of points to discretize the interval (lower,upper).
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_new.points">new.points</code></td>
<td>

<p>Number of new observations.
These observations are the last new.points observations and can be printed in another color and the initial observations (see argument: <code>col.points.end</code>).
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_xscale">xscale</code></td>
<td>

<p>If one wants to rescale the input domain on another interval it is possible to set this vector of size 2. The new interval will be translated by <code>xscale[1]</code> and expanded by a factor <code>xscale[2] - xscale[1]</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_show.points">show.points</code></td>
<td>

<p>Boolean: should we show the observations on the graph ?
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_cex.points">cex.points</code></td>
<td>

<p>Multiplicative factor for the size of the points.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Multiplicative factor for the size of the axis graduations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_pch.points.init">pch.points.init</code></td>
<td>

<p>Symbol for the <code>n-new.points</code> first observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_pch.points.end">pch.points.end</code></td>
<td>

<p>Symbol for the <code>new.points</code> last observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_col.points.init">col.points.init</code></td>
<td>

<p>Color for the <code>n-new.points</code> first observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_col.points.end">col.points.end</code></td>
<td>

<p>Color for the <code>new.points</code> last observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_xaxislab">xaxislab</code></td>
<td>

<p>Optional new labels that will replace the normal levels on x axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_yaxislab">yaxislab</code></td>
<td>

<p>Optional new labels that will replace the normal levels on y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_xaxispoint">xaxispoint</code></td>
<td>

<p>Position of these new labels on x axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_yaxispoint">yaxispoint</code></td>
<td>

<p>Position of these new labels on y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_vorobmean">vorobmean</code></td>
<td>

<p>Optional boolean. When it is set to <code>TRUE</code> the Vorob'ev expectation is plotted. It corresponds to the averaged excursion set, using the definition of Vorob'ev. Here, the estimated set is the set above the Vorob'ev threshold (plotted in blue).
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_krigmeanplot">krigmeanplot</code></td>
<td>

<p>When set to <code>TRUE</code> a kriging mean is plotted on a second y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_tplot">Tplot</code></td>
<td>

<p>When set to <code>TRUE</code>, and if <code>krigmeanplot</code> is also set to <code>TRUE</code>, draws horizontal lines corresponding to the different thresholds <code>T</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_consquantile">consQuantile</code></td>
<td>

<p>Optional value for plotting conservative quantiles. In order to plot </p>

<ul>
<li><p>Conservative estimates: <code>consQuantile</code> is a list containing at least <code>consLevel</code> (scalar), with the option <code>typeEx</code> (character, default = &quot;&gt;&quot;).
</p>
</li>
<li><p>Generic Vorob'ev quantiles: <code>consQuantile</code> is a scalar corresponding to the Vorob'ev quantile level.
</p>
</li></ul>

</td></tr>
<tr><td><code id="print_uncertainty_1d_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code>plot</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integrated uncertainty. If the conservative estimate is computed, it also returns the conservative quantile level.
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2012), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing vol. 22(3), pp 773-793
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_uncertainty_2d">print_uncertainty_2d</a></code>,<code><a href="#topic+print_uncertainty_nd">print_uncertainty_nd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#print_uncertainty_1d

set.seed(9)
N &lt;- 9 #number of observations
T &lt;- c(-0.2,0.2) #thresholds
testfun &lt;- sin
lower &lt;- c(0)
upper &lt;- c(6)

#a 20 points initial design
design &lt;- data.frame( lower+(upper-lower)*matrix(runif(N),ncol=1) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

print_uncertainty_1d(model=model,T=T,lower=lower,upper=upper,
  main="probability of excursion",xlab="x",ylab="pn",
  cex.points=1.5,col.points.init="red",
  krigmeanplot=TRUE,Tplot=TRUE)

## Not run: 
uq1d &lt;- print_uncertainty_1d(model=model,T=T,lower=lower,upper=upper,
  main="probability of excursion",xlab="x",ylab="pn",
  cex.points=1.5,col.points.init="red",
  krigmeanplot=TRUE,Tplot=TRUE,consQuantile =list(consLevel=0.95))

  print_uncertainty_1d(model=model,T=T,lower=lower,upper=upper,
  main="probability of excursion",xlab="x",ylab="pn",
  cex.points=1.5,col.points.init="red",
  krigmeanplot=TRUE,Tplot=TRUE,consQuantile =uq1d[2])

## End(Not run)

</code></pre>

<hr>
<h2 id='print_uncertainty_2d'>
Prints a measure of uncertainty for 2d function.
</h2><span id='topic+print_uncertainty_2d'></span>

<h3>Description</h3>

<p>This function draws the value of a given measure of uncertainty over the whole input domain (2D).
The function can be used to print relevant outputs after having used the function <code><a href="#topic+EGI">EGI</a></code> or <code><a href="#topic+EGIparallel">EGIparallel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_uncertainty_2d(model, T, type = "pn",
lower = c(0, 0), upper = c(1, 1), resolution = 200,
new.points = 0,
xscale = c(0, 1), yscale = c(0, 1), show.points = TRUE,
cex.contourlab = 1, cex.points = 1,
cex.axis = 1, pch.points.init = 17, pch.points.end = 17,
col.points.init = "black", col.points.end = "red", nlevels = 10,
levels = NULL, xaxislab = NULL, yaxislab = NULL,
xaxispoint = NULL, yaxispoint = NULL,
krigmeanplot=FALSE,vorobmean=FALSE,consQuantile=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_uncertainty_2d_+3A_model">model</code></td>
<td>

<p>Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_type">type</code></td>
<td>

<p>Type of uncertainty that the user wants to print.
Possible values are <code>"pn"</code>  (probability of excursion), or
<code>"sur"</code>, <code>"imse"</code>, <code>"timse"</code>, <code>"vorob"</code> if we print a measure of uncertainty corresponding to one criterion.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the input domain.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the input domain.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_resolution">resolution</code></td>
<td>

<p>Number of points to discretize the domain. This discretization is used in each dimension, so that the total number of points is <code>resolution^2</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_new.points">new.points</code></td>
<td>

<p>Number of new observations.
These observations are the last new.points observations and can be printed in another color and the initial observations (see argument: <code>col.points.end</code>).
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_xscale">xscale</code></td>
<td>

<p>If one wants to rescale the input domain on another interval it is possible to set this vector of size 2. The new interval will be translated by <code>xscale[1]</code> and expanded by a factor <code>xscale[2] - xscale[1]</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_yscale">yscale</code></td>
<td>

<p>see: <code>xscale</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_show.points">show.points</code></td>
<td>

<p>Boolean: should we show the observations on the graph ?
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_cex.contourlab">cex.contourlab</code></td>
<td>

<p>Multiplicative factor for the size of labels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_cex.points">cex.points</code></td>
<td>

<p>Multiplicative factor for the size of the points.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Multiplicative factor for the size of the axis graduations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_pch.points.init">pch.points.init</code></td>
<td>

<p>Symbol for the <code>n-new.points</code> first observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_pch.points.end">pch.points.end</code></td>
<td>

<p>Symbol for the <code>new.points</code> last observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_col.points.init">col.points.init</code></td>
<td>

<p>Color for the <code>n-new.points</code> first observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_col.points.end">col.points.end</code></td>
<td>

<p>Color for the <code>new.points</code> last observations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_nlevels">nlevels</code></td>
<td>

<p>Integer corresponding to the number of levels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_levels">levels</code></td>
<td>

<p>Array: one can directly set the levels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_xaxislab">xaxislab</code></td>
<td>

<p>Optional new labels that will replace the normal levels on x axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_yaxislab">yaxislab</code></td>
<td>

<p>Optional new labels that will replace the normal levels on y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_xaxispoint">xaxispoint</code></td>
<td>

<p>Position of these new labels on x axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_yaxispoint">yaxispoint</code></td>
<td>

<p>Position of these new labels on y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_krigmeanplot">krigmeanplot</code></td>
<td>

<p>Optional boolean. When it is set to <code>FALSE</code> (default) the contour plot corresponds to the uncertainty selected. When it is set to <code>TRUE</code> the contour plot gives the kriging mean.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_vorobmean">vorobmean</code></td>
<td>

<p>Optional boolean. When it is set to <code>TRUE</code> the Vorob'ev expectation is plotted. It corresponds to the averaged excursion set, using the definition of Vorob'ev.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_consquantile">consQuantile</code></td>
<td>

<p>Optional value for plotting conservative quantiles. In order to plot </p>

<ul>
<li><p>Conservative estimates: <code>consQuantile</code> is a list containing at least <code>consLevel</code> (scalar), with the option <code>typeEx</code> (character, default = &quot;&gt;&quot;).
</p>
</li>
<li><p>Generic Vorob'ev quantiles: <code>consQuantile</code> is a scalar corresponding to the Vorob'ev quantile level.
</p>
</li></ul>

</td></tr>
<tr><td><code id="print_uncertainty_2d_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code>image</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integrated uncertainty. If the conservative estimate is computed, it also returns the conservative quantile level.
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2012), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing vol. 22(3), pp 773-793
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_uncertainty_1d">print_uncertainty_1d</a></code>,<code><a href="#topic+print_uncertainty_nd">print_uncertainty_nd</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#print_uncertainty_2d

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(20,40) #thresholds
testfun &lt;- branin
lower &lt;- c(0,0)
upper &lt;- c(1,1)

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

## Not run: 
print_uncertainty_2d(model=model,T=T,main="probability of excursion",
                     type="pn",krigmeanplot=TRUE,vorobmean=TRUE)

#print_uncertainty_2d(model=model,T=T,main="vorob uncertainty",
#type="vorob",krigmeanplot=FALSE)

#print_uncertainty_2d(model=model,T=T,main="imse uncertainty",
#type="imse",krigmeanplot=FALSE)

#print_uncertainty_2d(model=model,T=T,main="timse uncertainty",
#type="timse",krigmeanplot=FALSE)

## Print uncertainty 2d and conservative estimate at level 0.95
# uq2d&lt;- print_uncertainty_2d(model=model,T=T,main="probability of excursion",
#                     type="pn",krigmeanplot=TRUE,vorobmean=FALSE,
#                     consQuantile=list(consLevel=0.95))
# print_uncertainty_2d(model=model,T=T,main="probability of excursion",
#                     type="pn",krigmeanplot=TRUE,vorobmean=FALSE,
#                     consQuantile=uq2d[2])

## End(Not run)
</code></pre>

<hr>
<h2 id='print_uncertainty_nd'>
Print a measure of uncertainty for functions with dimension d strictly larger than 2.
</h2><span id='topic+print_uncertainty_nd'></span>

<h3>Description</h3>

<p>This function draws projections on various plans of a given measure of uncertainty. 
The function can be used to print relevant outputs after having used the function <code><a href="#topic+EGI">EGI</a></code> or <code><a href="#topic+EGIparallel">EGIparallel</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_uncertainty_nd(model,T,type="pn",lower=NULL,upper=NULL,
  		resolution=20, nintegpoints=400,
  		cex.lab=1,cex.contourlab=1,cex.axis=1,
			nlevels=10,levels=NULL,
			xdecal=3,ydecal=3, option="mean", pairs=NULL,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_uncertainty_nd_+3A_model">model</code></td>
<td>

<p>Kriging model of <code><a href="DiceKriging.html#topic+km">km</a></code> class.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_type">type</code></td>
<td>

<p>Type of uncertainty that the user wants to print. 
Possible values are <code>"pn"</code> (probability of excursion), or 
<code>"sur"</code>, <code>"imse"</code>, <code>"timse"</code> if we print a measure of uncertainty corresponding to one criterion. 
The <code>"vorob"</code> option is not available due to the difficulty of computing a Vorob'ev threshold.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_lower">lower</code></td>
<td>

<p>Vector containing the lower bounds of the input domain. If nothing is set we use a vector of 0.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_upper">upper</code></td>
<td>

<p>Vector containing the upper bounds of the input domain. If nothing is set we use a vector of 1.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_resolution">resolution</code></td>
<td>

<p>Number of points to discretize a plan included in the domain. For the moment, we cannot use values higher than 40 do to 
computation time, except when the argument <code>"pairs"</code> is not set to its default value.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_nintegpoints">nintegpoints</code></td>
<td>

<p>to do
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_cex.lab">cex.lab</code></td>
<td>

<p>Multiplicative factor for the size of titles of the axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_cex.contourlab">cex.contourlab</code></td>
<td>

<p>Multiplicative factor for the size of labels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_cex.axis">cex.axis</code></td>
<td>

<p>Multiplicative factor for the size of the axis graduations.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_nlevels">nlevels</code></td>
<td>

<p>Integer corresponding to the number of levels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_levels">levels</code></td>
<td>

<p>Array: one can directly set the levels of the contour plot.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_xdecal">xdecal</code></td>
<td>

<p>Optional position shifting of the titles of the x axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_ydecal">ydecal</code></td>
<td>

<p>Optional position shifting of the titles of the y axis.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_option">option</code></td>
<td>

<p>Optional argument (a string). The 3 possible values are <code>"mean"</code> (default), <code>"max"</code> and <code>"min"</code>.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_pairs">pairs</code></td>
<td>

<p>Optional argument. When set to codeNULL (default) the function performs the projections on plans spanned by each pair (i,j) of dimension. Otherwise, the argument is an array of size 2 corresponding to the dimensions spanning the (only) plan on which the projection is performed.
</p>
</td></tr>
<tr><td><code id="print_uncertainty_nd_+3A_...">...</code></td>
<td>

<p>Additional arguments to the <code>image</code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The integrated uncertainty
</p>


<h3>Author(s)</h3>

 
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2012), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing vol. 22(3), pp 773-793
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print_uncertainty_1d">print_uncertainty_1d</a></code>,<code><a href="#topic+print_uncertainty_2d">print_uncertainty_2d</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#print_uncertainty_nd

set.seed(9)
N &lt;- 30 #number of observations
T &lt;- -1 #threshold
testfun &lt;- hartman3
#The hartman3 function is defined over the domain [0,1]^3. 

lower &lt;- rep(0,times=3)
upper &lt;- rep(1,times=3)

#a 30 points initial design
design &lt;- data.frame( matrix(runif(3*N),ncol=3) )
response &lt;- apply(design,1,testfun)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

## Not run: 
print_uncertainty_nd(model=model,T=T,main="average probability of excursion",type="pn",
                    option="mean")

print_uncertainty_nd(model=model,T=T,main="maximum probability of excursion",type="pn",
                     option="max")


## End(Not run)
</code></pre>

<hr>
<h2 id='ranjan_optim'> Ranjan et al.'s Expected Improvement criterion </h2><span id='topic+ranjan_optim'></span>

<h3>Description</h3>

<p>Evaluation of Ranjan's Expected Feasibility criterion. To be used in optimization routines, like in <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranjan_optim(x, model, T, method.param = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ranjan_optim_+3A_x">x</code></td>
<td>

<p>Input vector at which one wants to evaluate the criterion. 
This argument can be either a vector of size d (for an evaluation at a single point) or a p*d matrix (for p simultaneous evaluations of the criterion at p different points).
</p>
</td></tr>
<tr><td><code id="ranjan_optim_+3A_model">model</code></td>
<td>

<p>An object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).
</p>
</td></tr>
<tr><td><code id="ranjan_optim_+3A_t">T</code></td>
<td>

<p>Target value (scalar).
</p>
</td></tr>
<tr><td><code id="ranjan_optim_+3A_method.param">method.param</code></td>
<td>

<p>Scalar tolerance around the target T. Default value is 1.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Ranjan EI criterion. 
When the argument <code>x</code> is a vector the function returns a scalar.
When the argument <code>x</code> is a p*d matrix the function returns a vector of size p.
</p>


<h3>Author(s)</h3>

 
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Ranjan, P., Bingham, D., Michailidis, G. (2008) <em>Sequential experiment design for contour estimation from complex computer codes</em> Technometrics 50(4), pp 527-541
</p>
<p>Bect J., Ginsbourger D., Li L., Picheny V., Vazquez E. (2010), <em>Sequential design of computer experiments for the estimation of a probability of failure</em>, Statistics and Computing, pp.1-21, 2011, <a href="https://arxiv.org/abs/1009.5177">https://arxiv.org/abs/1009.5177</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>, <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################################################
#ranjan_optim

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

x &lt;- c(0.5,0.4)#one evaluation of the ranjan criterion
ranjan_optim(x=x,T=T,model=model)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
ranjan.grid &lt;- ranjan_optim(x=x,T=T,model=model)
z.grid &lt;- matrix(ranjan.grid, n.grid, n.grid)

#plots: contour of the criterion, DOE points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,25,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)

i.best &lt;- which.max(ranjan.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of Ranjan criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='sur_optim_parallel'> Parallel sur criterion </h2><span id='topic+sur_optim_parallel'></span>

<h3>Description</h3>

<p>Evaluation of the parallel sur criterion for some candidate points. To be used in optimization routines, like in <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the expected future sur uncertainty when the candidate points are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sur_optim_parallel(x, integration.points, integration.weights = NULL, 
intpoints.oldmean, intpoints.oldsd, 
precalc.data, model, T, 
new.noise.var = NULL, batchsize, current.sur, ai_precalc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sur_optim_parallel_+3A_x">x</code></td>
<td>
<p>Vector of size batchsize*d at which one wants to evaluate the criterion. This argument is NOT a matrix.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding  the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance for the new observations.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_current.sur">current.sur</code></td>
<td>
<p>Current value of the sur criterion (before adding new observations)</p>
</td></tr>
<tr><td><code id="sur_optim_parallel_+3A_ai_precalc">ai_precalc</code></td>
<td>
<p>When multiple thresholds are used (i.e. when T is a vector), this is an nT*p matrix with ith row equal to <code>intpoints.oldmean-T[i]</code>. The argument does not need to be filled if only one threshold is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size batchsize*d (and not a matrix with batchsize rows and d columns) so that an optimizer like genoud can optimize it easily.
For example if d=2, batchsize=3 and <code>x=c(0.1,0.2,0.3,0.4,0.5,0.6)</code>, we will evaluate the parallel criterion at the three points (0.1,0.2),(0.3,0.4) and (0.5,0.6).
</p>


<h3>Value</h3>

<p>Parallel sur value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#sur_optim_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="sur",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)
nT &lt;- 2 # number of thresholds
ai_precalc &lt;- matrix(rep(intpoints.oldmean,times=nT),
    nrow=nT,ncol=length(intpoints.oldmean),byrow=TRUE)
ai_precalc &lt;- ai_precalc - T  # substracts Ti to the ith row of ai_precalc

batchsize &lt;- 4
x &lt;- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#one evaluation of the sur_optim_parallel criterion
#we calculate the expectation of the future "sur" uncertainty 
#when 4 points are added to the doe
#the 4 points are (0.1,0.2) , (0.3,0.4), (0.5,0.6), (0.7,0.8)
sur_optim_parallel(x=x,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=Inf,ai_precalc=ai_precalc)


#the function max_sur_parallel will help to find the optimum: 
#ie: the batch of 4 minimizing the expectation of the future uncertainty
</code></pre>

<hr>
<h2 id='sur_optim_parallel2'> Parallel sur criterion </h2><span id='topic+sur_optim_parallel2'></span>

<h3>Description</h3>

<p>Evaluation of the parallel sur criterion for some candidate points, assuming that some other points are also going to be evaluated. 
To be used in optimization routines, like in <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the expected future sur uncertainty when the candidate points are added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sur_optim_parallel2(x, other.points, 
integration.points, integration.weights = NULL, 
intpoints.oldmean, intpoints.oldsd, precalc.data, 
model, T, new.noise.var = NULL, 
batchsize, current.sur,ai_precalc = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sur_optim_parallel2_+3A_x">x</code></td>
<td>
<p>Input vector of size d at which one wants to evaluate the criterion. This argument corresponds to only ONE point.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_other.points">other.points</code></td>
<td>
<p>Vector giving the other <code>batchsize-1</code> points at which one wants to evaluate the criterion </p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance of the new observations.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_current.sur">current.sur</code></td>
<td>
<p>Current value of the sur criterion (before adding new observations)</p>
</td></tr>
<tr><td><code id="sur_optim_parallel2_+3A_ai_precalc">ai_precalc</code></td>
<td>
<p>When multiple thresholds are used (i.e. when T is a vector), this is an nT*p matrix with ith row equal to <code>intpoints.oldmean-T[i]</code>. The argument does not need to be filled if only one threshold is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size d so that an optimizer like genoud can optimize it easily.
The second argument <code>other.points</code> is a vector of size (batchsize-1)*d corresponding to the batchsize-1 other points.
</p>


<h3>Value</h3>

<p>Parallel sur value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>
<p>Chevalier C., Ginsbourger D. (2014), <em>Corrected Kriging update formulae for batch-sequential data assimilation</em>, in Pardo-Iguzquiza, E., et al. (Eds.) Mathematics of Planet Earth, pp 119-122
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_sur_parallel">max_sur_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#sur_optim_parallel2

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="sur",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,lower=c(0,0),upper=c(1,1),
model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
                          type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)
nT &lt;- 2 # number of thresholds
ai_precalc &lt;- matrix(rep(intpoints.oldmean,times=nT),
    nrow=nT,ncol=length(intpoints.oldmean),byrow=TRUE)
ai_precalc &lt;- ai_precalc - T  # substracts Ti to the ith row of ai_precalc

batchsize &lt;- 4
other.points &lt;- c(0.7,0.5,0.5,0.9,0.9,0.8)
x &lt;- c(0.1,0.2)
#one evaluation of the sur_optim_parallel criterion2
#we calculate the expectation of the future "sur" uncertainty when 
#1+3 points are added to the doe
#the 1+3 points are (0.1,0.2) and (0.7,0.5), (0.5,0.9), (0.9,0.8)
sur_optim_parallel2(x=x,other.points,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=Inf,ai_precalc=ai_precalc)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
sur_parallel.grid &lt;- apply(X=x,FUN=sur_optim_parallel2,MARGIN=1,other.points,
          integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,current.sur=Inf,ai_precalc=ai_precalc)
z.grid &lt;- matrix(sur_parallel.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(matrix(other.points,ncol=2,byrow=TRUE), col="red", pch=17, lwd=4,cex=2)

i.best &lt;- which.min(sur_parallel.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of sur_parallel criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='timse_optim_parallel'> Parallel targeted IMSE criterion </h2><span id='topic+timse_optim_parallel'></span>

<h3>Description</h3>

<p>Evaluation of the <code>"timse"</code> criterion for some candidate points. To be used in optimization routines, like in <code><a href="#topic+max_timse_parallel">max_timse_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the posterior timse uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timse_optim_parallel(x, integration.points, integration.weights = NULL, 
intpoints.oldmean = NULL, intpoints.oldsd = NULL, 
precalc.data, model, T, new.noise.var = 0, weight = NULL,
batchsize, current.timse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timse_optim_parallel_+3A_x">x</code></td>
<td>
<p>Input vector of size d at which one wants to evaluate the criterion.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance of the new observations.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_weight">weight</code></td>
<td>

<p>Vector of weight function (length must be equal to the number of lines of the matrix integration.points). 
If nothing is set, the imse criterion is used instead of timse. It corresponds to equal weights.
</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel_+3A_current.timse">current.timse</code></td>
<td>
<p>Current value of the timse criterion (before adding new observations)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Targeted imse value</p>


<h3>Author(s)</h3>

<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Picheny V. (2009) <em>Improving accuracy and compensating for uncertainty in surrogate modeling</em>, Ph.D. thesis, University of Florida and Ecole Nationale Superieure des Mines de Saint-Etienne
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_timse_parallel">max_timse_parallel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#timse_optim_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=1000,distrib="timse",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,lower=c(0,0),
upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

#we also need to compute weights. Otherwise the (more simple) 
#imse criterion will be evaluated
weight0 &lt;- 1/sqrt( 2*pi*(intpoints.oldsd^2) )
weight &lt;- 0
for(i in 1:length(T)){
  Ti &lt;- T[i]
  weight &lt;- weight + weight0 * exp(-0.5*((intpoints.oldmean-Ti)/sqrt(intpoints.oldsd^2))^2)
}

batchsize &lt;- 4
x &lt;- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#one evaluation of the timse_optim_parallel criterion
#we calculate the expectation of the future "timse" 
#uncertainty when 4 points are added to the doe
#the 4 points are (0.1,0.2) , (0.3,0.4), (0.5,0.6), (0.7,0.8)
timse_optim_parallel(x=x,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,weight=weight,
          batchsize=batchsize,current.timse=Inf)

#the function max_timse_parallel will help to find the optimum: 
#ie: the batch of 4 minimizing the expectation of the future uncertainty
</code></pre>

<hr>
<h2 id='timse_optim_parallel2'> Parallel timse criterion </h2><span id='topic+timse_optim_parallel2'></span>

<h3>Description</h3>

<p>Evaluation of the parallel timse criterion for some candidate points, assuming that some other points are also going to be evaluated. 
To be used in optimization routines, like in <code><a href="#topic+max_timse_parallel">max_timse_parallel</a></code>. 
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise. 
The criterion is the integral of the posterior timse uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timse_optim_parallel2(x, other.points, 
integration.points, integration.weights = NULL, 
intpoints.oldmean, intpoints.oldsd, precalc.data, 
model, T, new.noise.var = NULL,weight = NULL, 
batchsize, current.timse)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timse_optim_parallel2_+3A_x">x</code></td>
<td>
<p>Input vector of size d at which one wants to evaluate the criterion. This argument corresponds to only ONE point.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_other.points">other.points</code></td>
<td>
<p>Vector giving the other <code>batchsize-1</code> points at which one wants to evaluate the criterion </p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_t">T</code></td>
<td>
<p>Array containing one or several thresholds.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance for the new observations.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_weight">weight</code></td>
<td>

<p>Vector of weight function (length must be equal to the number of lines of the matrix integration.points). 
If nothing is set, the imse criterion is used instead of timse. It corresponds to equal weights.
</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="timse_optim_parallel2_+3A_current.timse">current.timse</code></td>
<td>
<p>Current value of the timse criterion (before adding new observations)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size d so that an optimizer like genoud can optimize it easily.
The second argument <code>other.points</code> is a vector of size (batchsize-1)*d corresponding to the batchsize-1 other points.
</p>


<h3>Value</h3>

<p>Parallel timse value</p>


<h3>Author(s)</h3>

<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Picheny V. (2009) <em>Improving accuracy and compensating for uncertainty in surrogate modeling</em>, Ph.D. thesis, University of Florida and Ecole Nationale Superieure des Mines de Saint-Etienne
</p>
<p>Chevalier C., Bect J., Ginsbourger D., Vazquez E., Picheny V., Richet Y. (2014), <em>Fast parallel kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>, Technometrics, vol. 56(4), pp 455-465
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_timse_parallel">max_timse_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#timse_optim_parallel2

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(80,100) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=1000,distrib="timse",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,lower=c(0,0),upper=c(1,1),
model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

#we also need to compute weights. Otherwise the (more simple) 
#imse criterion will be evaluated
weight0 &lt;- 1/sqrt( 2*pi*(intpoints.oldsd^2) )
weight &lt;- 0
for(i in 1:length(T)){
  Ti &lt;- T[i]
  weight &lt;- weight + weight0 * exp(-0.5*((intpoints.oldmean-Ti)/sqrt(intpoints.oldsd^2))^2)
}

batchsize &lt;- 4
other.points &lt;- c(0.7,0.5,0.5,0.9,0.9,0.8)
x &lt;- c(0.1,0.2)
#one evaluation of the timse_optim_parallel criterion2
#we calculate the expectation of the future "timse" uncertainty 
#when 1+3 points are added to the doe
#the 1+3 points are (0.1,0.2) and (0.7,0.5), (0.5,0.9), (0.9,0.8)
timse_optim_parallel2(x=x,other.points,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,weight=weight,
          batchsize=batchsize,current.timse=Inf)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
timse_parallel.grid &lt;- apply(X=x,FUN=timse_optim_parallel2,MARGIN=1,other.points,
          integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,weight=weight,
          batchsize=batchsize,current.timse=Inf)
z.grid &lt;- matrix(timse_parallel.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(matrix(other.points,ncol=2,byrow=TRUE), col="red", pch=17, lwd=4,cex=2)

i.best &lt;- which.min(timse_parallel.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of timse_parallel criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='tmse_optim'> Targeted MSE criterion </h2><span id='topic+tmse_optim'></span>

<h3>Description</h3>

<p>Evaluation of the Targeted MSE criterion. To be used in optimization routines, 
like in <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmse_optim(x, model, T, method.param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmse_optim_+3A_x">x</code></td>
<td>

<p>Input vector at which one wants to evaluate the criterion. 
This argument can be either a vector of size d (for an evaluation at a single point) or a p*d matrix (for p simultaneous evaluations of the criterion at p different points).
</p>
</td></tr>
<tr><td><code id="tmse_optim_+3A_model">model</code></td>
<td>

<p>An object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).
</p>
</td></tr>
<tr><td><code id="tmse_optim_+3A_t">T</code></td>
<td>

<p>Array containing one or several thresholds.
</p>
</td></tr>
<tr><td><code id="tmse_optim_+3A_method.param">method.param</code></td>
<td>

<p>Scalar tolerance around the targets T.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>targeted MSE value.
When the argument <code>x</code> is a vector the function returns a scalar.
When the argument <code>x</code> is a p*d matrix the function returns a vector of size p.
</p>


<h3>Author(s)</h3>

 
<p>Victor Picheny (INRA, Toulouse, France)
</p>
<p>David Ginsbourger (IDIAP Martigny and University of Bern, Switzerland)
</p>
<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Picheny V., Ginsbourger D., Roustant O., Haftka R.T., (2010) <em>Adaptive designs of experiments for accurate approximation of a target region</em>, J. Mech. Des. vol. 132(7)
</p>
<p>Picheny V. (2009) <em>Improving accuracy and compensating for uncertainty in surrogate modeling</em>, Ph.D. thesis, University of Florida and Ecole Nationale Superieure des Mines de Saint-Etienne
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>, <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#tmse_optim

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- c(40,80) #thresholds
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

x &lt;- c(0.5,0.4)#one evaluation of the tmse criterion
tmse_optim(x=x,T=T,model=model)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
tmse.grid &lt;- tmse_optim(x=x,T=T,model=model)
z.grid &lt;- matrix(tmse.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,25,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)

i.best &lt;- which.max(tmse.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of tmse criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='tsee_optim'> Two Sided Expected Exceedance criterion </h2><span id='topic+tsee_optim'></span>

<h3>Description</h3>

<p>Evaluation of the Two-Sided Expected Exceedance criterion. To be used in optimization routines, like in <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsee_optim(x, model, T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsee_optim_+3A_x">x</code></td>
<td>

<p>Input vector at which one wants to evaluate the criterion. 
This argument can be either a vector of size d (for an evaluation at a single point) or a p*d matrix (for p simultaneous evaluations of the criterion at p different points).
</p>
</td></tr>
<tr><td><code id="tsee_optim_+3A_model">model</code></td>
<td>

<p>An object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).
</p>
</td></tr>
<tr><td><code id="tsee_optim_+3A_t">T</code></td>
<td>

<p>Target value (scalar).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tsee criterion. 
When the argument <code>x</code> is a vector the function returns a scalar.
When the argument <code>x</code> is a p*d matrix the function returns a vector of size p.
</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Yann Richet (IRSN, France)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGI">EGI</a></code>, <code><a href="#topic+max_infill_criterion">max_infill_criterion</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>#tsee_optim

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

x &lt;- c(0.5,0.4)#one evaluation of the tsee criterion
tsee_optim(x=x,T=T,model=model)

n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
tsee.grid &lt;- tsee_optim(x=x,T=T,model=model)
z.grid &lt;- matrix(tsee.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,25,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)

i.best &lt;- which.max(tsee.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of tsee criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='vorob_optim_parallel'> Parallel Vorob'ev criterion </h2><span id='topic+vorob_optim_parallel'></span>

<h3>Description</h3>

<p>Evaluation of the parallel Vorob'ev criterion for some candidate points. To be used in optimization routines, like in <code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code>.
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise.
The criterion is the integral of the posterior Vorob'ev uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorob_optim_parallel(x, integration.points, integration.weights = NULL,
intpoints.oldmean, intpoints.oldsd,
precalc.data, model, T,
new.noise.var = NULL, batchsize, alpha, current.vorob,
penalisation=NULL,typeEx="&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorob_optim_parallel_+3A_x">x</code></td>
<td>
<p>Input vector of size batchsize*d at which one wants to evaluate the criterion. This argument is NOT a matrix.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding  the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_t">T</code></td>
<td>
<p>Target value (scalar). The criterion CANNOT be used with multiple thresholds.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance for the new observations.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_alpha">alpha</code></td>
<td>
<p>The Vorob'ev threshold.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_current.vorob">current.vorob</code></td>
<td>
<p>Current value of the vorob criterion (before adding new observations)</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_penalisation">penalisation</code></td>
<td>
<p>Optional penalization constant for type I errors. If equal to zero,  computes the Type II criterion.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel_+3A_typeex">typeEx</code></td>
<td>
<p>A character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size batchsize*d (and not a matrix with batchsize rows and d columns) so that an optimizer like genoud can optimize it easily.
For example if d=2, batchsize=3 and <code>x=c(0.1,0.2,0.3,0.4,0.5,0.6)</code>, we will evaluate the parallel criterion at the three points (0.1,0.2),(0.3,0.4) and (0.5,0.6).
</p>


<h3>Value</h3>

<p>Parallel vorob value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Ginsbouger D., Bect J., Molchanov I. (2013) <em>Estimating and quantifying uncertainties on level sets using the Vorob'ev expectation and deviation with gaussian process models</em> mODa 10, Advances in Model-Oriented Design and Analysis, Contributions to Statistics, pp 35-43
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>
<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#vorob_optim_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="vorob",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
alpha &lt;- obj$alpha
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

batchsize &lt;- 4
x &lt;- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#one evaluation of the vorob_optim_parallel criterion
#we calculate the expectation of the future "vorob" uncertainty
#when 4 points are added to the doe
#the 4 points are (0.1,0.2) , (0.3,0.4), (0.5,0.6), (0.7,0.8)
vorob_optim_parallel(x=x,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,alpha=alpha,current.vorob=Inf)


#the function max_vorob_parallel will help to find the optimum:
#ie: the batch of 4 minimizing the expectation of the future uncertainty

</code></pre>

<hr>
<h2 id='vorob_optim_parallel2'> Parallel Vorob'ev criterion </h2><span id='topic+vorob_optim_parallel2'></span>

<h3>Description</h3>

<p>Evaluation of the Vorob'ev criterion for some candidate points, assuming that some other points are also going to be evaluated. To be used in optimization routines, like in <code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code>.
To avoid numerical instabilities, the new points are evaluated only if they are not too close to an existing observation, or if there is some observation noise.
The criterion is the integral of the posterior Vorob'ev uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorob_optim_parallel2(x, other.points,
integration.points, integration.weights = NULL,
intpoints.oldmean, intpoints.oldsd, precalc.data,
model, T, new.noise.var = NULL,
batchsize, alpha, current.vorob,
penalisation = NULL, typeEx = "&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorob_optim_parallel2_+3A_x">x</code></td>
<td>
<p>Input vector of size d at which one wants to evaluate the criterion. This argument corresponds to only ONE point.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_other.points">other.points</code></td>
<td>
<p>Vector giving the other <code>batchsize-1</code> points at which one wants to evaluate the criterion </p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_integration.points">integration.points</code></td>
<td>
<p>p*d matrix of points for numerical integration in the X space.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>Vector of size p corresponding to the weights of these integration points.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size p corresponding to the kriging mean at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size p corresponding to the kriging standard deviation at the integration points before adding <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_model">model</code></td>
<td>
<p>Object of class <code><a href="DiceKriging.html#topic+km">km</a></code> (Kriging model).</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_t">T</code></td>
<td>
<p>Target value (scalar). The criterion CANNOT be used with multiple thresholds.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar value of the noise variance of the new observations.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_batchsize">batchsize</code></td>
<td>
<p>Number of points to sample simultaneously. The sampling criterion will return batchsize points at a time for sampling.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_alpha">alpha</code></td>
<td>
<p>The Vorob'ev threshold.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_current.vorob">current.vorob</code></td>
<td>
<p>Current value of the vorob criterion (before adding new observations)</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_penalisation">penalisation</code></td>
<td>
<p>Optional penalization constant for type I errors. If equal to zero,  computes the Type II criterion.</p>
</td></tr>
<tr><td><code id="vorob_optim_parallel2_+3A_typeex">typeEx</code></td>
<td>
<p>A character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first argument <code>x</code> has been chosen to be a vector of size d so that an optimizer like genoud can optimize it easily.
The second argument <code>other.points</code> is a vector of size (batchsize-1)*d corresponding to the batchsize-1 other points.
</p>


<h3>Value</h3>

<p>Parallel Vorob'ev value</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>
<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Ginsbouger D., Bect J., Molchanov I. (2013) <em>Estimating and quantifying uncertainties on level sets using the Vorob'ev expectation and deviation with gaussian process models</em> mODa 10, Advances in Model-Oriented Design and Analysis, Contributions to Statistics, pp 35-43
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#vorob_optim_parallel2

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
	response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="vorob",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights
alpha &lt;- obj$alpha
pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
                          type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

batchsize &lt;- 4
other.points &lt;- c(0.7,0.5,0.5,0.9,0.9,0.8)
x &lt;- c(0.1,0.2)
#one evaluation of the vorob_optim_parallel criterion2
#we calculate the expectation of the future "vorob" uncertainty when
#1+3 points are added to the doe
#the 1+3 points are (0.1,0.2) and (0.7,0.5), (0.5,0.9), (0.9,0.8)
vorob_optim_parallel2(x=x,other.points,integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,alpha=alpha,current.vorob=Inf)


n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
vorob_parallel.grid &lt;- apply(X=x,FUN=vorob_optim_parallel2,MARGIN=1,other.points,
          integration.points=integration.points,
          integration.weights=integration.weights,
          intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
          precalc.data=precalc.data,T=T,model=model,
          batchsize=batchsize,alpha=alpha,current.vorob=Inf)
z.grid &lt;- matrix(vorob_parallel.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(matrix(other.points,ncol=2,byrow=TRUE), col="red", pch=17, lwd=4,cex=2)

i.best &lt;- which.min(vorob_parallel.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of vorob_parallel criterion (black) and of f(x)=T (blue)")
</code></pre>

<hr>
<h2 id='vorob_threshold'> Calculation of the Vorob'ev threshold </h2><span id='topic+vorob_threshold'></span>

<h3>Description</h3>

<p>Evaluation of the Vorob'ev threshold given an excursion probability vector. This threshold is such that the volume of the set (x : pn(x) &gt; threshold) is equal to the integral of pn. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorob_threshold(pn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorob_threshold_+3A_pn">pn</code></td>
<td>
<p>Input vector of arbitrary size containing the excursion probabilities pn(x).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this function, all the points x are supposed to be equaly weighted.
</p>


<h3>Value</h3>

<p>a scalar: the Vorob'ev thresold</p>


<h3>Author(s)</h3>

<p>Clement Chevalier (University of Neuchatel, Switzerland)
</p>


<h3>References</h3>

<p>Chevalier C., Ginsbouger D., Bect J., Molchanov I. (2013) <em>Estimating and quantifying uncertainties on level sets using the Vorob'ev expectation and deviation with gaussian process models</em> mODa 10, Advances in Model-Oriented Design and Analysis, Contributions to Statistics, pp 35-43
</p>
<p>Chevalier C. (2013) <em>Fast uncertainty reduction strategies relying on Gaussian process models</em> Ph.D Thesis, University of Bern
</p>


<h3>See Also</h3>

<p><code><a href="#topic+max_vorob_parallel">max_vorob_parallel</a></code>, <code><a href="#topic+vorob_optim_parallel">vorob_optim_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#vorob_threshold

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design, 
	response = response,covtype="matern3_2")

## Not run: 
###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="sobol")
obj &lt;- integration_design(integcontrol=integcontrol,
lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points

pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
type="UK",se.compute=TRUE)
pn &lt;- pnorm((pred$mean-T)/pred$sd)

vorob_threshold(pn)

## End(Not run)
</code></pre>

<hr>
<h2 id='vorobVol_optim_parallel'>Compute volume criterion</h2><span id='topic+vorobVol_optim_parallel'></span>

<h3>Description</h3>

<p>Compute the volume criterion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorobVol_optim_parallel(x, integration.points, integration.weights = NULL,
  intpoints.oldmean, intpoints.oldsd, precalc.data, model, T,
  new.noise.var = NULL, batchsize, alpha, current.crit, typeEx = "&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorobVol_optim_parallel_+3A_x">x</code></td>
<td>
<p>vector of size <code>batchsize*d</code> describing the  point(s) where to evaluate the criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_integration.points">integration.points</code></td>
<td>
<p><code class="reqn">p*d</code> matrix with the integration points for evaluating numerically the integral of the criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_integration.weights">integration.weights</code></td>
<td>
<p>vector of size <code class="reqn">p</code> containting the integration weights for the integral numerical evaluation</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size <code class="reqn">p</code> corresponding to the kriging mean at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size <code class="reqn">p</code> corresponding to the kriging standard deviation at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_model">model</code></td>
<td>
<p>a km Model</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_t">T</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar with the noise variance at the new observation</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_batchsize">batchsize</code></td>
<td>
<p>size of the batch of new points</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_alpha">alpha</code></td>
<td>
<p>threshold on pn obtained with conservative estimates</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_current.crit">current.crit</code></td>
<td>
<p>starting value for criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel_+3A_typeex">typeEx</code></td>
<td>
<p>a character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the criterion at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). <em>Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation</em>.  Journal of Computational and Graphical Statistics, 27(2), 255-267.
</p>
<p>Azzimonti, D. (2016). <em>Contributions to Bayesian set estimation relying on random field priors</em>. PhD thesis, University of Bern.
</p>
<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier, C., Bect, J., Ginsbourger, D., Vazquez, E., Picheny, V., and Richet, Y. (2014). <em>Fast kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>. Technometrics, 56(4):455-465.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_futureVol_parallel">max_futureVol_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#vorobVol_optim_parallel

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
            response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="vorob",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
                          lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights


# alpha, the pn threshold should be computed with conservativeEstimate
# Here it is fixed at 0.992364
alpha &lt;- 0.992364

## Not run: 
  # You can compute it with the following code
  CE_design=as.matrix (randtoolbox::sobol (n = 500*model@d,
                                           dim = model@d))
  colnames(CE_design) &lt;- colnames(model@X)

  CE_pred = predict.km(object = model, newdata = CE_design,
                       type = "UK",cov.compute = TRUE)
  CE_pred$cov &lt;- CE_pred$cov +1e-7*diag(nrow = nrow(CE_pred$cov),ncol = ncol(CE_pred$cov))

  Cestimate &lt;- anMC::conservativeEstimate(alpha = 0.95, pred=CE_pred,
                                          design=CE_design, threshold=T, pn = NULL,
                                          type = "&gt;", verb = 1,
                                          lightReturn = TRUE, algo = "GANMC")
  alpha &lt;- Cestimate$lvs

## End(Not run)

pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
                          type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

batchsize &lt;- 4
x &lt;- c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8)
#one evaluation of the vorob_optim_parallel criterion
#we calculate the expectation of the future "vorob" uncertainty
#when 4 points are added to the doe
#the 4 points are (0.1,0.2) , (0.3,0.4), (0.5,0.6), (0.7,0.8)
vorobVol_optim_parallel(x=x,integration.points=integration.points,
                     integration.weights=integration.weights,
                     intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
                     precalc.data=precalc.data,T=T,model=model,
                     batchsize=batchsize,alpha=alpha)


#the function max_futureVol_parallel will help to find the optimum:
#ie: the batch of 4 maximizing the expectation of the future
# uncertainty (future volume of the Vorob'ev quantile)

</code></pre>

<hr>
<h2 id='vorobVol_optim_parallel2'>Compute volume criterion</h2><span id='topic+vorobVol_optim_parallel2'></span>

<h3>Description</h3>

<p>Compute the volume criterion. Useful for optimization routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vorobVol_optim_parallel2(x, other.points, integration.points,
  integration.weights = NULL, intpoints.oldmean, intpoints.oldsd,
  precalc.data, model, T, new.noise.var = NULL, batchsize, alpha,
  current.crit, typeEx = "&gt;")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vorobVol_optim_parallel2_+3A_x">x</code></td>
<td>
<p>One point where to evaluate the criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_other.points">other.points</code></td>
<td>
<p>remaining points of the batch</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_integration.points">integration.points</code></td>
<td>
<p><code class="reqn">p*d</code> matrix with the integration points for evaluating numerically the integral of the criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_integration.weights">integration.weights</code></td>
<td>
<p>vector of size <code class="reqn">p</code> containting the integration weights for the integral numerical evaluation</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_intpoints.oldmean">intpoints.oldmean</code></td>
<td>
<p>Vector of size <code class="reqn">p</code> corresponding to the kriging mean at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_intpoints.oldsd">intpoints.oldsd</code></td>
<td>
<p>Vector of size <code class="reqn">p</code> corresponding to the kriging standard deviation at the integration points before adding the batchsize points <code>x</code> to the design of experiments.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_precalc.data">precalc.data</code></td>
<td>
<p>List containing useful data to compute quickly the updated kriging variance. This list can be generated using the <code><a href="#topic+precomputeUpdateData">precomputeUpdateData</a></code> function.</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_model">model</code></td>
<td>
<p>a km Model</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_t">T</code></td>
<td>
<p>threshold</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_new.noise.var">new.noise.var</code></td>
<td>
<p>Optional scalar with the noise variance at the new observation</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_batchsize">batchsize</code></td>
<td>
<p>size of the batch of new points</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_alpha">alpha</code></td>
<td>
<p>threshold on pn obtained with conservative estimates</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_current.crit">current.crit</code></td>
<td>
<p>starting value for criterion</p>
</td></tr>
<tr><td><code id="vorobVol_optim_parallel2_+3A_typeex">typeEx</code></td>
<td>
<p>a character (&quot;&gt;&quot; or &quot;&lt;&quot;) identifying the type of excursion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the criterion at <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Dario Azzimonti (IDSIA, Switzerland)
</p>


<h3>References</h3>

<p>Azzimonti, D. and Ginsbourger, D. (2018). <em>Estimating orthant probabilities of high dimensional Gaussian vectors with an application to set estimation</em>.  Journal of Computational and Graphical Statistics, 27(2), 255-267.
</p>
<p>Azzimonti, D. (2016). <em>Contributions to Bayesian set estimation relying on random field priors</em>. PhD thesis, University of Bern.
</p>
<p>Azzimonti, D., Ginsbourger, D., Chevalier, C., Bect, J., and Richet, Y. (2018). <em>Adaptive design of experiments for conservative estimation of excursion sets</em>. Under revision. Preprint at <a href="https://hal.archives-ouvertes.fr/hal-01379642">hal-01379642</a>
</p>
<p>Chevalier, C., Bect, J., Ginsbourger, D., Vazquez, E., Picheny, V., and Richet, Y. (2014). <em>Fast kriging-based stepwise uncertainty reduction with application to the identification of an excursion set</em>. Technometrics, 56(4):455-465.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+EGIparallel">EGIparallel</a></code>, <code><a href="#topic+max_futureVol_parallel">max_futureVol_parallel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>#vorobVol_optim_parallel2

set.seed(9)
N &lt;- 20 #number of observations
T &lt;- 80 #threshold
testfun &lt;- branin

#a 20 points initial design
design &lt;- data.frame( matrix(runif(2*N),ncol=2) )
response &lt;- testfun(design)

#km object with matern3_2 covariance
#params estimated by ML from the observations
model &lt;- km(formula=~., design = design,
            response = response,covtype="matern3_2")

###we need to compute some additional arguments:
#integration points, and current kriging means and variances at these points
integcontrol &lt;- list(n.points=50,distrib="vorob",init.distrib="MC")
obj &lt;- integration_design(integcontrol=integcontrol,
                          lower=c(0,0),upper=c(1,1),model=model,T=T)

integration.points &lt;- obj$integration.points
integration.weights &lt;- obj$integration.weights

# alpha, the pn threshold should be computed with conservativeEstimate
# Here it is fixed at 0.992364
alpha &lt;- 0.992364

## Not run: 
# You can compute it with the following code
CE_design=as.matrix (randtoolbox::sobol (n = 500*model@d,
                                      dim = model@d))
colnames(CE_design) &lt;- colnames(model@X)

CE_pred = predict.km(object = model, newdata = CE_design,
                          type = "UK",cov.compute = TRUE)
CE_pred$cov &lt;- CE_pred$cov +1e-7*diag(nrow = nrow(CE_pred$cov),ncol = ncol(CE_pred$cov))

Cestimate &lt;- anMC::conservativeEstimate(alpha = 0.95, pred=CE_pred,
                           design=CE_design, threshold=T, pn = NULL,
                           type = "&gt;", verb = 1,
                           lightReturn = TRUE, algo = "GANMC")
alpha &lt;- Cestimate$lvs

## End(Not run)


pred &lt;- predict_nobias_km(object=model,newdata=integration.points,
                          type="UK",se.compute=TRUE)
intpoints.oldmean &lt;- pred$mean ; intpoints.oldsd&lt;-pred$sd

#another precomputation
precalc.data &lt;- precomputeUpdateData(model,integration.points)

batchsize &lt;- 4
other.points &lt;- c(0.7,0.5,0.5,0.9,0.9,0.8)
x &lt;- c(0.1,0.2)
#one evaluation of the vorobVol_optim_parallel criterion2
#we calculate the expectation of the future volume vorobev uncertainty when
#1+3 points are added to the doe
#the 1+3 points are (0.1,0.2) and (0.7,0.5), (0.5,0.9), (0.9,0.8)
vorobVol_optim_parallel2(x=x,other.points=other.points,integration.points=integration.points,
                      integration.weights=integration.weights,
                      intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
                      precalc.data=precalc.data,T=T,model=model,
                      batchsize=batchsize,alpha=alpha)


n.grid &lt;- 20 #you can run it with 100
x.grid &lt;- y.grid &lt;- seq(0,1,length=n.grid)
x &lt;- expand.grid(x.grid, y.grid)
vorobVol_parallel.grid &lt;- apply(X=x,FUN=vorobVol_optim_parallel2,MARGIN=1,other.points=other.points,
                             integration.points=integration.points,
                             integration.weights=integration.weights,
                             intpoints.oldmean=intpoints.oldmean,intpoints.oldsd=intpoints.oldsd,
                             precalc.data=precalc.data,T=T,model=model,
                             batchsize=batchsize,alpha=alpha)
z.grid &lt;- matrix(vorobVol_parallel.grid, n.grid, n.grid)

#plots: contour of the criterion, doe points and new point
image(x=x.grid,y=y.grid,z=z.grid,col=grey.colors(10))
contour(x=x.grid,y=y.grid,z=z.grid,15,add=TRUE)
points(design, col="black", pch=17, lwd=4,cex=2)
points(matrix(other.points,ncol=2,byrow=TRUE), col="red", pch=17, lwd=4,cex=2)

# Note that we want to maximize this criterion.
i.best &lt;- which.max(vorobVol_parallel.grid)
points(x[i.best,], col="blue", pch=17, lwd=4,cex=3)

#plots the real (unknown in practice) curve f(x)=T
testfun.grid &lt;- apply(x,1,testfun)
z.grid.2 &lt;- matrix(testfun.grid, n.grid, n.grid)
contour(x.grid,y.grid,z.grid.2,levels=T,col="blue",add=TRUE,lwd=5)
title("Contour lines of vorobVol_parallel criterion (black) and of f(x)=T (blue)")



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
