<!DOCTYPE html><html><head><title>Help for package extBatchMarking</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {extBatchMarking}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#extBatchMarking-package'><p>extBatchMarking: Extended Batch Marking Models</p></a></li>
<li><a href='#batchLL'><p>batchLL function provides the batch marking log-likelihood</p></a></li>
<li><a href='#batchLogit'><p>batchLogit function</p></a></li>
<li><a href='#batchMarkHmmLL'><p>Log-likelihood function for marked model.</p></a></li>
<li><a href='#batchMarkOptim'><p>Marked model only.</p></a></li>
<li><a href='#batchMarkUnmarkHmmLL'><p>Log-likelihood function for combined model.</p></a></li>
<li><a href='#batchMarkUnmarkOptim'><p>Combined Marked and Unmarked models.</p></a></li>
<li><a href='#batchUnmark2Viterbi'><p>batchUnmark2Viterbi function provides a wrapper for the batchUnmarkViterbi to compute the popuation abundance</p></a></li>
<li><a href='#batchUnmarkHmmLL'><p>batchUnmarkHmmLL function provides the unmarked function to be optimized</p></a></li>
<li><a href='#batchUnmarkViterbi'><p>batchUnmarkViterbi function provides the implementation of the Viterbi alogrithm for the unmarked model</p></a></li>
<li><a href='#dbinpois'><p>Convolution of Poisson and Binomial for Batch</p></a></li>
<li><a href='#delta_g'><p>initial probability function</p></a></li>
<li><a href='#gamma_gt'><p>Transition State Probability</p>
'gamma_gt' computes the transition probability matrix</a></li>
<li><a href='#probs'><p>State-dependent probability function</p></a></li>
<li><a href='#WeatherLoach'><p>Weather Loach data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Extended Batch Marking Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-05</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kehinde Olobatuyi &lt;olobatuyikenny@uvic.ca&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A system for batch-marking data analysis to estimate survival probabilities, capture probabilities, and enumerate the population abundance for both marked and unmarked individuals. The estimation of only marked individuals can be achieved through the batchMarkOptim() function. Similarly, the combined marked and unmarked can be achieved through the batchMarkUnmarkOptim() function. The algorithm was also implemented for the hidden Markov model encapsulated in batchMarkUnmarkOptim() to estimate the abundance of both marked and unmarked individuals in the population. The package is based on the paper: "Hidden Markov Models for Extended Batch Data" of Cowen et al. (2017) &lt;<a href="https://doi.org/10.1111%2Fbiom.12701">doi:10.1111/biom.12701</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, foreach, optimbase, Rcpp, parallel</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Olobatuyi/extBatchMarking">https://github.com/Olobatuyi/extBatchMarking</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Olobatuyi/extBatchMarking/issues">https://github.com/Olobatuyi/extBatchMarking/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-09 18:46:31 UTC; Windows</td>
</tr>
<tr>
<td>Author:</td>
<td>Kehinde Olobatuyi <a href="https://orcid.org/0000-0002-4635-7895"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Simon Johns [aut],
  Matthew RP Parker <a href="https://orcid.org/0000-0003-3021-7959"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Steve Hof [aut],
  Laura LE Cowen <a href="https://orcid.org/0000-0002-0853-1450"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-10 10:23:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='extBatchMarking-package'>extBatchMarking: Extended Batch Marking Models</h2><span id='topic+extBatchMarking'></span><span id='topic+extBatchMarking-package'></span>

<h3>Description</h3>

<p>A system for batch-marking data analysis to estimate survival probabilities, capture probabilities, and enumerate the population abundance for both marked and unmarked individuals. The estimation of only marked individuals can be achieved through the batchMarkOptim() function. Similarly, the combined marked and unmarked can be achieved through the batchMarkUnmarkOptim() function. The algorithm was also implemented for the hidden Markov model encapsulated in batchMarkUnmarkOptim() to estimate the abundance of both marked and unmarked individuals in the population. The package is based on the paper: &quot;Hidden Markov Models for Extended Batch Data&quot; of Cowen et al. (2017) <a href="https://doi.org/10.1111/biom.12701">doi:10.1111/biom.12701</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kehinde Olobatuyi <a href="mailto:olobatuyikenny@uvic.ca">olobatuyikenny@uvic.ca</a> (<a href="https://orcid.org/0000-0002-4635-7895">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Simon Johns <a href="mailto:simon737@outlook.com">simon737@outlook.com</a>
</p>
</li>
<li><p> Matthew RP Parker <a href="mailto:mrparker909@gmail.com">mrparker909@gmail.com</a> (<a href="https://orcid.org/0000-0003-3021-7959">ORCID</a>)
</p>
</li>
<li><p> Steve Hof <a href="mailto:steven.Hof@icloud.com">steven.Hof@icloud.com</a>
</p>
</li>
<li><p> Laura LE Cowen <a href="mailto:lcowen@uvic.ca">lcowen@uvic.ca</a> (<a href="https://orcid.org/0000-0002-0853-1450">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/Olobatuyi/extBatchMarking">https://github.com/Olobatuyi/extBatchMarking</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/Olobatuyi/extBatchMarking/issues">https://github.com/Olobatuyi/extBatchMarking/issues</a>
</p>
</li></ul>


<hr>
<h2 id='batchLL'>batchLL function provides the batch marking log-likelihood</h2><span id='topic+batchLL'></span>

<h3>Description</h3>

<p>batchLL function provides the batch marking log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchLL(phi, p, R, begin_g, end_g, cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchLL_+3A_phi">phi</code></td>
<td>
<p>The probability of surviving and remaining in the population between occasions t and t +1, given an individual was alive and in the population at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchLL_+3A_p">p</code></td>
<td>
<p>The probability of capture at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchLL_+3A_r">R</code></td>
<td>
<p>The number of individuals marked and released at sampling occasion g from batch group g; g = 1,2,...,G. This must be an integer.</p>
</td></tr>
<tr><td><code id="batchLL_+3A_begin_g">begin_g</code></td>
<td>
<p>The beginning of the occasion.</p>
</td></tr>
<tr><td><code id="batchLL_+3A_end_g">end_g</code></td>
<td>
<p>The end of the occasion.</p>
</td></tr>
<tr><td><code id="batchLL_+3A_cores">cores</code></td>
<td>
<p>Number of cores for parallel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fr returns the log sum of the Hidden Markov Model.
</p>

<hr>
<h2 id='batchLogit'>batchLogit function</h2><span id='topic+batchLogit'></span>

<h3>Description</h3>

<p>'batchLogit' provides the number between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchLogit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchLogit_+3A_x">x</code></td>
<td>
<p>This is an input numerical value i.e double.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a number between 0 and 1.
</p>

<hr>
<h2 id='batchMarkHmmLL'>Log-likelihood function for marked model.</h2><span id='topic+batchMarkHmmLL'></span>

<h3>Description</h3>

<p>This helps users check whether the function can be optimized at the given initial values before optimizing using <code><a href="#topic+batchMarkOptim">batchMarkOptim</a></code>. After a quick check, if <code>NAN</code> or <code>Inf</code> is returned, the initial values should be revisited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMarkHmmLL(
  par,
  data,
  choiceModel = c("model1", "model2", "model3", "model4"),
  cores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMarkHmmLL_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="batchMarkHmmLL_+3A_data">data</code></td>
<td>
<p>A capture-recapture data matrix or data frame.</p>
</td></tr>
<tr><td><code id="batchMarkHmmLL_+3A_choicemodel">choiceModel</code></td>
<td>
<p>This chooses among different models and allows for model selection</p>
</td></tr>
<tr><td><code id="batchMarkHmmLL_+3A_cores">cores</code></td>
<td>
<p>The number of cores for parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Log-likelihood value of the likelihood function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(extBatchMarking)
# Initial parameter
theta &lt;- c(0, -1)
res1  &lt;- batchMarkHmmLL(par        = theta,
                       data        = WeatherLoach,
                       choiceModel = "model4",
                       cores       = 1)
res1

</code></pre>

<hr>
<h2 id='batchMarkOptim'>Marked model only.</h2><span id='topic+batchMarkOptim'></span>

<h3>Description</h3>

<p>batchMarkOptim function provides the batch marking function to be optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMarkOptim(
  par = NULL,
  data,
  choiceModel = c("model1", "model2", "model3", "model4"),
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B"),
  parallel = FALSE,
  lowerBound = -Inf,
  cores = 1,
  hessian = FALSE,
  control,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMarkOptim_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_data">data</code></td>
<td>
<p>A capture-recapture data matrix or data frame</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_choicemodel">choiceModel</code></td>
<td>
<p>This chooses among different models and allow for model selection</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_method">method</code></td>
<td>
<p>The method to be used. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Should the algorithm be run in parallel? This will be implemented in a future version.</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Lower bounds on the variables for the &quot;L-BFGS-B&quot; <code>method</code>.</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_cores">cores</code></td>
<td>
<p>The number of cores for parallelization</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_control">control</code></td>
<td>
<p>A list of control parameters. See optim for details.</p>
</td></tr>
<tr><td><code id="batchMarkOptim_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed by user which goes into the <code><a href="stats.html#topic+optim">optim</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after ... must be matched exactly.
<code><a href="#topic+batchMarkOptim">batchMarkOptim</a></code> depends on <code><a href="stats.html#topic+optim">optim</a></code> function to optimize the parameters of the marked model only. By default optim performs minimization.
</p>


<h3>Value</h3>

<p>For <code>batchMarkOptim</code>, a list with components:
</p>

<dl>
<dt>phi</dt><dd><p>The survival probability and remaining in the population between occasion t and t+1.</p>
</dd>
<dt>p</dt><dd><p>The capture probability at occasion time t.</p>
</dd>
<dt>ll</dt><dd><p>The optimized log-likelihood value of marked model.</p>
</dd>
<dt>hessian</dt><dd><p>The hessian matrix.</p>
</dd>
<dt>AIC</dt><dd><p>The Akaike Information Criteria for model selection.</p>
</dd>
</dl>



<h3>References</h3>

<p>Laura L. E. Cowen, Panagiotis Besbeas, Byron J. T. Morgan, 2017.: Hidden Markov Models for Extended Batch Data,
Biometrics, 73, 1321-1331. DOI: 10.1111/biom.12701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the package
library(extBatchMarking)

# Load the WeatherLoach data from Cowen et al., 2017.
data(WeatherLoach)

# Initial parameter values
theta &lt;- c(0, -1)


mod1 &lt;- batchMarkOptim(
           par         = theta,
           data        = WeatherLoach,
           choiceModel = "model4",
           method      = "BFGS",
           parallel    = FALSE,
           hessian     = TRUE,
           control     = list(trace = 1)
     )

 # Survival probability
 mod1$phi
 # Capture probability
 mod1$p
 # Optimized log-likelihood
 mod1$ll
 # The Hessian matrix
 mod1$hessian
 # The Aikaike Information Criteria
 mod1$AIC
 

 
 mod2 &lt;- batchMarkOptim(
           par         = theta,
           data        = WeatherLoach,
           choiceModel = "model4",
           method      = "L-BFGS-B",
           parallel    = FALSE,
           hessian     = TRUE,
           control     = list(trace = 1))

 # Survival probability
 mod2$phi
 # Capture probability
 mod2$p
 # Optimized log-likelihood
 mod2$ll
 # The Hessian matrix
 mod2$hessian
 # The Akaike Information Criteria
 mod2$AIC
 
</code></pre>

<hr>
<h2 id='batchMarkUnmarkHmmLL'>Log-likelihood function for combined model.</h2><span id='topic+batchMarkUnmarkHmmLL'></span>

<h3>Description</h3>

<p>This helps users check whether the function can be optimized at the given initial values before optimizing using <code><a href="#topic+batchMarkUnmarkOptim">batchMarkUnmarkOptim</a></code>. After a quick check, if <code>NAN</code> or <code>Inf</code> is returned, the initial values should be revisited.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMarkUnmarkHmmLL(
  par,
  data,
  Umax,
  nBins,
  choiceModel = c("model1", "model2", "model3", "model4"),
  cores
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_data">data</code></td>
<td>
<p>A capture-recapture data matrix or data frame.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_umax">Umax</code></td>
<td>
<p>The maximum number of the unmarked individuals in the population for capture on any occasion.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_nbins">nBins</code></td>
<td>
<p>The number of bin size into which the matrix will be divided.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_choicemodel">choiceModel</code></td>
<td>
<p>This chooses among different models and allow for model selection.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkHmmLL_+3A_cores">cores</code></td>
<td>
<p>The number of cores for parallelization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Log-likelihood value of the likelihood function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(extBatchMarking)
theta &lt;- c(0.1, 0.1, 7, -1.5)
res3  &lt;- batchMarkUnmarkHmmLL(par        = theta,
                             data        = WeatherLoach,
                             choiceModel = "model4",
                             Umax        = 1800,
                             nBins       = 20,
                             cores       = 1)
res3
</code></pre>

<hr>
<h2 id='batchMarkUnmarkOptim'>Combined Marked and Unmarked models.</h2><span id='topic+batchMarkUnmarkOptim'></span>

<h3>Description</h3>

<p>batchMarkUnmarkOptim function provides the batch marking and unmarked function to be optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchMarkUnmarkOptim(
  par = NULL,
  data,
  choiceModel = c("model1", "model2", "model3", "model4"),
  method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B"),
  Umax = 1800,
  nBins = 20,
  popSize = c("Horvitz_Thompson", "Model-Based"),
  parallel = FALSE,
  lowerBound = -Inf,
  cores = 1,
  hessian = FALSE,
  control,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchMarkUnmarkOptim_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_data">data</code></td>
<td>
<p>A capture-recapture data matrix or data frame</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_choicemodel">choiceModel</code></td>
<td>
<p>This chooses among different models and allow for model selection</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_method">method</code></td>
<td>
<p>The method to be used. See optim for details.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_umax">Umax</code></td>
<td>
<p>The maximum number of the unmarked individuals in the population for capture on any occasion.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_nbins">nBins</code></td>
<td>
<p>The number of bin size into which the matrix will be divided.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_popsize">popSize</code></td>
<td>
<p>The Horvitz_Thompson method or Model-Based to compute population size.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_parallel">parallel</code></td>
<td>
<p>Logical. Should the algorithm be run in parallel? This will be implemented in a future version.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_lowerbound">lowerBound</code></td>
<td>
<p>Lower bounds on the variables for the &quot;L-BFGS-B&quot; method.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_cores">cores</code></td>
<td>
<p>The number of cores for parallelization</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_hessian">hessian</code></td>
<td>
<p>Logical. Should a numerically differentiated Hessian matrix be returned?</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_control">control</code></td>
<td>
<p>a list of control parameters. See <code><a href="stats.html#topic+optim">optim</a></code> for details.</p>
</td></tr>
<tr><td><code id="batchMarkUnmarkOptim_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed by user which goes into the optim function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arguments after ... must be matched exactly.
</p>
<p>batchMarkUnmarkOptim depends on optim function to optimize the parameters of the combined model. By default optim performs minimization.
</p>
<p>Example on Umax and nBins: Umax = 1800 has a matrix of 1801 x 1801 and nBins = 20, reduces the matrix to 90 x 90. This is done in Cowen et al., 2017 to reduce the computing time when dealing with large matrix.
</p>


<h3>Value</h3>

<p>A list of the following optimized parameters will be returned.
</p>

<dl>
<dt>phi</dt><dd><p>The survival probability and remaining in the population between occasion t and t+1.</p>
</dd>
<dt>p</dt><dd><p>The capture probability at occasion time t.</p>
</dd>
<dt>ll</dt><dd><p>The optimized log-likelihood value of marked model.</p>
</dd>
<dt>hessian</dt><dd><p>The hessian matrix.</p>
</dd>
<dt>AIC</dt><dd><p>The Akaike Information Criteria for model selection.</p>
</dd>
<dt>lambda</dt><dd><p>Initial mean abundance at occasion t = 1.</p>
</dd>
<dt>gam</dt><dd><p>Recruitment rate of individual into the unmarked population.</p>
</dd>
<dt>M</dt><dd><p>Total number of marked individual in the population.</p>
</dd>
<dt>U</dt><dd><p>Total number of unmarked individuals in the population available for capture at occasion t = 1,..., T.</p>
</dd>
<dt>N</dt><dd><p>Total population size at time t = 1, ..., T.</p>
</dd>
</dl>



<h3>References</h3>

<p>Laura L. E. Cowen, Panagiotis Besbeas, Byron J. T. Morgan, 2017.: Hidden Markov Models for Extended Batch Data,
Biometrics, 73, 1321-1331. DOI: 10.1111/biom.12701.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load the package
library(extBatchMarking)

# Load the WeatherLoach data from Cowen et al., 2017.
data(WeatherLoach)

# Initial parameter values
theta &lt;- c(0.1, 0.1, 7, -1.5)


mod1 &lt;- batchMarkUnmarkOptim(
           par         = theta,
           data        = WeatherLoach,
           Umax        = 1800,
           nBins       = 20,
           choiceModel = "model4",
           popSize    = "Horvitz_Thompson",
           method      = "CG",
           parallel    = FALSE,
           control     = list(trace = 1))

 # Survival probability
 mod1$phi
 # Capture probability
 mod1$p
 # Optimized log-likelihood
 mod1$ll
 # The Hessian matrix
 mod1$hessian
 # The Aikaike Information Criteria
 mod1$AIC
 # The initial mean abundance
 mod1$lambda
 # Recruitment rate into the population
 mod1$gam
 # The estimated abundance of unmarked animals
 mod1$U
 # The estimated abundance of marked animals
 mod1$M
 # The estimated total abundance of marked and unmarked animals
 mod1$N
 

 
mod2 &lt;- batchMarkUnmarkOptim(
           par         = theta,
           data        = WeatherLoach,
           Umax        = 1800,
           nBins       = 20,
           choiceModel = "model4",
           popSize    = "Model-Based",
           method      = "L-BFGS-B",
           parallel    = FALSE,
           control     = list(trace = 1))

 # Survival probability
 mod2$phi
 # Capture probability
 mod2$p
 # Optimized log-likelihood
 mod2$ll
 # The Hessian matrix
 mod2$hessian
 # The Akaike Information Criteria
 mod2$AIC
 # The initial mean abundance
 mod2$lambda
 # Recruitment rate into the population
 mod2$gam
 # The estimated abundance of unmarked animals
 mod2$U
 # The estimated abundance of marked animals
 mod2$M
 # The estimated total abundance of marked and unmarked animals
 mod2$N
 
</code></pre>

<hr>
<h2 id='batchUnmark2Viterbi'>batchUnmark2Viterbi function provides a wrapper for the batchUnmarkViterbi to compute the popuation abundance</h2><span id='topic+batchUnmark2Viterbi'></span>

<h3>Description</h3>

<p>batchUnmark2Viterbi function provides a wrapper for the batchUnmarkViterbi to compute the popuation abundance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchUnmark2Viterbi(
  par,
  data,
  Umax,
  nBins,
  choiceModel = c("model1", "model2", "model3", "model4")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchUnmark2Viterbi_+3A_par">par</code></td>
<td>
<p>Initial values for the parameters to be optimized over.</p>
</td></tr>
<tr><td><code id="batchUnmark2Viterbi_+3A_data">data</code></td>
<td>
<p>A capture-recapture data matrix or data frame.</p>
</td></tr>
<tr><td><code id="batchUnmark2Viterbi_+3A_umax">Umax</code></td>
<td>
<p>The maximum number of the unmarked individuals in the population for capture on any occasion.</p>
</td></tr>
<tr><td><code id="batchUnmark2Viterbi_+3A_nbins">nBins</code></td>
<td>
<p>The number of bin size into which the matrix will be divided.</p>
</td></tr>
<tr><td><code id="batchUnmark2Viterbi_+3A_choicemodel">choiceModel</code></td>
<td>
<p>This chooses among different models and allows for model selection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Log-likelihood value of the likelihood function
</p>

<hr>
<h2 id='batchUnmarkHmmLL'>batchUnmarkHmmLL function provides the unmarked function to be optimized</h2><span id='topic+batchUnmarkHmmLL'></span>

<h3>Description</h3>

<p>batchUnmarkHmmLL function provides the unmarked function to be optimized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchUnmarkHmmLL(phi, p, lambda, gam, Umax, nBins, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchUnmarkHmmLL_+3A_phi">phi</code></td>
<td>
<p>The probability of surviving and remaining in the population between occasions t and t +1, given an individual was alive and in the population at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_p">p</code></td>
<td>
<p>The probability of capture at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_lambda">lambda</code></td>
<td>
<p>The initial mean abundance (at occasion 1) for the unmarked population.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_gam">gam</code></td>
<td>
<p>The recruitment rate into the unmarked population.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_umax">Umax</code></td>
<td>
<p>The maximum number of the unmarked individuals in the population for capture on any occasion.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_nbins">nBins</code></td>
<td>
<p>The number of bin size into which the matrix will be divided.</p>
</td></tr>
<tr><td><code id="batchUnmarkHmmLL_+3A_u">u</code></td>
<td>
<p>The number of individuals captured at sampling occasion t that were not marked; t = 1,...,T.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Log-likelihood value of the likelihood function
</p>

<hr>
<h2 id='batchUnmarkViterbi'>batchUnmarkViterbi function provides the implementation of the Viterbi alogrithm for the unmarked model</h2><span id='topic+batchUnmarkViterbi'></span>

<h3>Description</h3>

<p>batchUnmarkViterbi function provides the implementation of the Viterbi alogrithm for the unmarked model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>batchUnmarkViterbi(phi, p, lambda, gam, Umax, nBins, u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="batchUnmarkViterbi_+3A_phi">phi</code></td>
<td>
<p>The probability of surviving and remaining in the population between occasions t and t +1, given an individual was alive and in the population at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_p">p</code></td>
<td>
<p>The probability of capture at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_lambda">lambda</code></td>
<td>
<p>the initial mean abundance (at occasion 1) for the unmarked population.</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_gam">gam</code></td>
<td>
<p>The recruitment rate into the unmarked population</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_umax">Umax</code></td>
<td>
<p>The maximum number of the unmarked individuals in the population for capture on any occasion.</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_nbins">nBins</code></td>
<td>
<p>The number of bin size into which the matrix will be divided.</p>
</td></tr>
<tr><td><code id="batchUnmarkViterbi_+3A_u">u</code></td>
<td>
<p>The number of individuals captured at sampling occasion t that were not marked; t = 1,...,T.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Negative Log-likelihood value of the likelihood function
</p>

<hr>
<h2 id='dbinpois'>Convolution of Poisson and Binomial for Batch</h2><span id='topic+dbinpois'></span>

<h3>Description</h3>

<p>This is the convolution of Poisson and Binomial distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbinpois(z, n, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbinpois_+3A_z">z</code></td>
<td>
<p>This is the vector of numerical values</p>
</td></tr>
<tr><td><code id="dbinpois_+3A_n">n</code></td>
<td>
<p>The <code>nrow</code> of capture-recapture data matrix or data frame</p>
</td></tr>
<tr><td><code id="dbinpois_+3A_par">par</code></td>
<td>
<p>This is the vector of parameter values: average from Poisson distribution and probability of success from Binomial distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The convolution of Poisson and Binomial distribution helps us to compute the number of individuals that have survived from t-1 to t in the combined model while simultaneously computing the number of individuals recruited into the population at occasion t.
</p>
<p>The survival is modeled as Binomial distribution and the recruitment as the Poisson distirubiton
</p>


<h3>Value</h3>

<p>f This is the output of the convolution from the Binomial and Poisson distributions
</p>

<hr>
<h2 id='delta_g'>initial probability function</h2><span id='topic+delta_g'></span>

<h3>Description</h3>

<p>initial probability function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_g(R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_g_+3A_r">R</code></td>
<td>
<p>The number of individuals marked and released at sampling occasion g from batch group g; g = 1,2,...,G. This must be an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of initial value with 1 at the observed position
</p>

<hr>
<h2 id='gamma_gt'>Transition State Probability
'gamma_gt' computes the transition probability matrix</h2><span id='topic+gamma_gt'></span>

<h3>Description</h3>

<p>Transition State Probability
'gamma_gt' computes the transition probability matrix
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_gt_+3A_r">R</code></td>
<td>
<p>integer number of marked individuals released per occasion</p>
</td></tr>
<tr><td><code id="gamma_gt_+3A_phi">phi</code></td>
<td>
<p>double number. Survival probability of individuals</p>
</td></tr>
<tr><td><code id="gamma_gt_+3A_cores">cores</code></td>
<td>
<p>The number of cores on your machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pR Returns the transition matrix
</p>

<hr>
<h2 id='probs'>State-dependent probability function</h2><span id='topic+probs'></span>

<h3>Description</h3>

<p>'probs' computes the state-dependent transition matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probs(r, p, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probs_+3A_r">r</code></td>
<td>
<p>The number of individuals from batch group &quot;g&quot; recaptured at recapture occasion t; g = 1,2,...,G, t = g+1,...,T. This must be an integer.</p>
</td></tr>
<tr><td><code id="probs_+3A_p">p</code></td>
<td>
<p>The probability of capture at occasion t. This must be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="probs_+3A_r">R</code></td>
<td>
<p>The number of individuals marked and released at sampling occasion g from batch group g; g = 1,2,...,G. This must be an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>PR diagonal matrix of the state-dependent probability.
</p>

<hr>
<h2 id='WeatherLoach'>Weather Loach data</h2><span id='topic+WeatherLoach'></span>

<h3>Description</h3>

<p>Data from marked individuals captured on multiple occasions
The weather-loach study was described in detail by Huggin ()
Different colored batch tags were given to a random sample of unmarked individuals at each occasion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WeatherLoach
</code></pre>


<h3>Format</h3>



<h4>'Weather_loach'</h4>

<p>A data frame with 10 rows indicating number of captures and 11 columns indicating recaptures
</p>

<dl>
<dt>Weather Loach Data</dt><dd></dd>
</dl>



</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
