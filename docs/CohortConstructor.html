<!DOCTYPE html><html><head><title>Help for package CohortConstructor</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CohortConstructor}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CohortConstructor-package'><p>CohortConstructor: Build and Manipulate Study Cohorts Using a Common Data Model</p></a></li>
<li><a href='#collapseCohorts'><p>Collapse cohort entries using a certain gap to concatenate records.</p></a></li>
<li><a href='#conceptCohort'><p>Create cohorts based on a concept set</p></a></li>
<li><a href='#demographicsCohort'><p>Create cohorts based on patient demographics</p></a></li>
<li><a href='#entryAtFirstDate'><p>Update cohort start date to be the first date from of a set of column dates</p></a></li>
<li><a href='#entryAtLastDate'><p>Set cohort start date to the last of a set of column dates</p></a></li>
<li><a href='#exitAtDeath'><p>Set cohort end date to death date</p></a></li>
<li><a href='#exitAtFirstDate'><p>Set cohort end date to the first of a set of column dates</p></a></li>
<li><a href='#exitAtLastDate'><p>Set cohort end date to the last of a set of column dates</p></a></li>
<li><a href='#exitAtObservationEnd'><p>Set cohort end date to end of observation</p></a></li>
<li><a href='#intersectCohorts'><p>Generate a combination cohort set between the intersection of different</p>
cohorts.</a></li>
<li><a href='#matchCohorts'><p>Generate a new cohort matched cohort</p></a></li>
<li><a href='#measurementCohort'><p>Create cohorts measurement based cohorts</p></a></li>
<li><a href='#mockCohortConstructor'><p>Function to create a mock cdm reference for CohortConstructor</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#requireAge'><p>Restrict cohort on age</p></a></li>
<li><a href='#requireCohortIntersect'><p>Require cohort subjects are present (or absence) in another cohort</p></a></li>
<li><a href='#requireConceptIntersect'><p>Require cohort subjects to have (or not have) events of a concept list</p></a></li>
<li><a href='#requireDeathFlag'><p>Require cohort subjects have (or do not have) a death record</p></a></li>
<li><a href='#requireDemographics'><p>Restrict cohort on patient demographics</p></a></li>
<li><a href='#requireFutureObservation'><p>Restrict cohort on future observation</p></a></li>
<li><a href='#requireInDateRange'><p>Require that an index date is within a date range</p></a></li>
<li><a href='#requireIsFirstEntry'><p>Restrict cohort to first entry</p></a></li>
<li><a href='#requireIsLastEntry'><p>Restrict cohort to last entry per person</p></a></li>
<li><a href='#requirePriorObservation'><p>Restrict cohort on prior observation</p></a></li>
<li><a href='#requireSex'><p>Restrict cohort on sex</p></a></li>
<li><a href='#requireTableIntersect'><p>Require cohort subjects are present in another clinical table</p></a></li>
<li><a href='#sampleCohorts'><p>Sample a cohort table for a given number of individuals.</p></a></li>
<li><a href='#stratifyCohorts'><p>Create a new cohort table from stratifying an existing one</p></a></li>
<li><a href='#subsetCohorts'><p>Generate a cohort table using a subset of cohorts from another table.</p></a></li>
<li><a href='#trimDemographics'><p>Restrict cohort on patient demographics</p></a></li>
<li><a href='#trimToDateRange'><p>Trim cohort dates to be within a date range</p></a></li>
<li><a href='#unionCohorts'><p>Generate cohort from the union of different cohorts</p></a></li>
<li><a href='#yearCohorts'><p>Generate a new cohort table restricting cohort entries to certain years</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Build and Manipulate Study Cohorts Using a Common Data Model</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Create and manipulate study cohorts in data mapped to the 
    Observational Medical Outcomes Partnership Common Data Model.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>CDMConnector (&ge; 1.3.1), checkmate, cli, dbplyr (&ge; 2.5.0),
dplyr, glue, magrittr, omopgenerics (&ge; 0.2.1), PatientProfiles
(&ge; 1.1.0), purrr, rlang, tidyr, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>DBI, CodelistGenerator, DrugUtilisation, duckdb, knitr,
rmarkdown, testthat (&ge; 3.0.0), tibble, stringr,
IncidencePrevalence, omock (&ge; 0.2.0), covr, RPostgres, odbc</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ohdsi.github.io/CohortConstructor/">https://ohdsi.github.io/CohortConstructor/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-13 19:25:57 UTC; eburn</td>
</tr>
<tr>
<td>Author:</td>
<td>Edward Burn <a href="https://orcid.org/0000-0002-9286-1128"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Marti Catala <a href="https://orcid.org/0000-0003-3308-9905"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nuria Mercade-Besora
    <a href="https://orcid.org/0009-0006-7948-3747"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Marta Alcalde-Herraiz
    <a href="https://orcid.org/0009-0002-4405-1814"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mike Du <a href="https://orcid.org/0000-0002-9517-8834"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Yuchen Guo <a href="https://orcid.org/0000-0002-0847-4855"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Xihang Chen <a href="https://orcid.org/0009-0001-8112-8959"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kim Lopez <a href="https://orcid.org/0000-0002-8462-8668"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edward Burn &lt;edward.burn@ndorms.ox.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-14 07:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='CohortConstructor-package'>CohortConstructor: Build and Manipulate Study Cohorts Using a Common Data Model</h2><span id='topic+CohortConstructor'></span><span id='topic+CohortConstructor-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Create and manipulate study cohorts in data mapped to the Observational Medical Outcomes Partnership Common Data Model.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Edward Burn <a href="mailto:edward.burn@ndorms.ox.ac.uk">edward.burn@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0000-0002-9286-1128">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Marti Catala <a href="mailto:marti.catalasabate@ndorms.ox.ac.uk">marti.catalasabate@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0000-0003-3308-9905">ORCID</a>)
</p>
</li>
<li><p> Nuria Mercade-Besora <a href="mailto:nuria.mercadebesora@ndorms.ox.ac.uk">nuria.mercadebesora@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0009-0006-7948-3747">ORCID</a>)
</p>
</li>
<li><p> Marta Alcalde-Herraiz <a href="mailto:marta.alcaldeherraiz@ndorms.ox.ac.uk">marta.alcaldeherraiz@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0009-0002-4405-1814">ORCID</a>)
</p>
</li>
<li><p> Mike Du <a href="mailto:mike.du@ndorms.ox.ac.uk">mike.du@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0000-0002-9517-8834">ORCID</a>)
</p>
</li>
<li><p> Yuchen Guo <a href="mailto:yuchen.guo@ndorms.ox.ac.uk">yuchen.guo@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0000-0002-0847-4855">ORCID</a>)
</p>
</li>
<li><p> Xihang Chen <a href="mailto:xihang.chen@ndorms.ox.ac.uk">xihang.chen@ndorms.ox.ac.uk</a> (<a href="https://orcid.org/0009-0001-8112-8959">ORCID</a>)
</p>
</li>
<li><p> Kim Lopez <a href="mailto:kim.lopez@spc.ox.ac.uk">kim.lopez@spc.ox.ac.uk</a> (<a href="https://orcid.org/0000-0002-8462-8668">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ohdsi.github.io/CohortConstructor/">https://ohdsi.github.io/CohortConstructor/</a>
</p>
</li></ul>


<hr>
<h2 id='collapseCohorts'>Collapse cohort entries using a certain gap to concatenate records.</h2><span id='topic+collapseCohorts'></span>

<h3>Description</h3>

<p><code>collapseCohorts()</code> concatenates cohort records, allowing for some number
of days between one finishing and the next starting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapseCohorts(cohort, cohortId = NULL, gap = 0, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapseCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table</p>
</td></tr>
<tr><td><code id="collapseCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="collapseCohorts_+3A_gap">gap</code></td>
<td>
<p>Number of days to use when merging cohort entries.</p>
</td></tr>
<tr><td><code id="collapseCohorts_+3A_name">name</code></td>
<td>
<p>Name of the cohort table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table
</p>

<hr>
<h2 id='conceptCohort'>Create cohorts based on a concept set</h2><span id='topic+conceptCohort'></span>

<h3>Description</h3>

<p><code>conceptCohort()</code> creates a cohort table from patient records
from the clinical tables in the OMOP CDM.
</p>
<p>The following tables are currently supported for creating concept
cohorts:
</p>

<ul>
<li><p> condition_occurrence
</p>
</li>
<li><p> device_exposure
</p>
</li>
<li><p> drug_exposure
</p>
</li>
<li><p> measurement
</p>
</li>
<li><p> observation
</p>
</li>
<li><p> procedure_occurrence
</p>
</li>
<li><p> visit_occurrence
</p>
</li></ul>

<p>Cohort duration is based on record start and end (e.g.
condition_start_date and condition_end_date for records coming
from the condition_occurrence tables). So that the resulting table
satisfies the requirements of an OMOP CDM cohort table:
</p>

<ul>
<li><p> Overlapping records are collapsed into a single cohort entry.
</p>
</li>
<li><p> If a record starts outside of an observation period it will be
silently ignored.
</p>
</li>
<li><p> If a record ends outside of an observation period it will be
trimmed so as to end at the preceding observation period end date.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>conceptCohort(cdm, conceptSet, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conceptCohort_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference.</p>
</td></tr>
<tr><td><code id="conceptCohort_+3A_conceptset">conceptSet</code></td>
<td>
<p>A conceptSet, which can either be a codelist
or a conceptSetExpression.</p>
</td></tr>
<tr><td><code id="conceptCohort_+3A_name">name</code></td>
<td>
<p>Name of the cohort in the cdm object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(conditionOccurrence = TRUE)

cohort &lt;- conceptCohort(cdm = cdm, conceptSet = list(a = 1), name = "cohort")

cohort |&gt; attrition()

</code></pre>

<hr>
<h2 id='demographicsCohort'>Create cohorts based on patient demographics</h2><span id='topic+demographicsCohort'></span>

<h3>Description</h3>

<p><code>demographicsCohort()</code> creates a cohort table based on patient
characteristics. If and when an individual satisfies all the criteria they
enter the cohort. When they stop satisfying any of the criteria their
cohort entry ends.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demographicsCohort(
  cdm,
  name,
  ageRange = NULL,
  sex = NULL,
  minPriorObservation = NULL,
  minFutureObservation = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demographicsCohort_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference.</p>
</td></tr>
<tr><td><code id="demographicsCohort_+3A_name">name</code></td>
<td>
<p>Name of the new cohort table</p>
</td></tr>
<tr><td><code id="demographicsCohort_+3A_agerange">ageRange</code></td>
<td>
<p>A list of vectors specifying minimum and maximum age.</p>
</td></tr>
<tr><td><code id="demographicsCohort_+3A_sex">sex</code></td>
<td>
<p>Can be &quot;Both&quot;, &quot;Male&quot; or &quot;Female&quot;.</p>
</td></tr>
<tr><td><code id="demographicsCohort_+3A_minpriorobservation">minPriorObservation</code></td>
<td>
<p>A minimum number of prior observation days in
the database.</p>
</td></tr>
<tr><td><code id="demographicsCohort_+3A_minfutureobservation">minFutureObservation</code></td>
<td>
<p>A minimum number of future observation days in
the database.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor()

cohort &lt;-  cdm |&gt; demographicsCohort(name = "cohort3", ageRange = c(18,40), sex = "Male")

attrition(cohort)

</code></pre>

<hr>
<h2 id='entryAtFirstDate'>Update cohort start date to be the first date from of a set of column dates</h2><span id='topic+entryAtFirstDate'></span>

<h3>Description</h3>

<p><code>entryAtFirstDate()</code> resets cohort start date based on a set of specified
column dates. The first date that occurs is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entryAtFirstDate(
  cohort,
  dateColumns,
  cohortId = NULL,
  returnReason = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entryAtFirstDate_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="entryAtFirstDate_+3A_datecolumns">dateColumns</code></td>
<td>
<p>Date columns in the cohort table to consider.</p>
</td></tr>
<tr><td><code id="entryAtFirstDate_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="entryAtFirstDate_+3A_returnreason">returnReason</code></td>
<td>
<p>If TRUE it will return a column stating which column in
<code>dateColumns</code> is used as a new cohort end date.</p>
</td></tr>
<tr><td><code id="entryAtFirstDate_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(tables = list(
"cohort" = dplyr::tibble(
  cohort_definition_id = 1,
  subject_id = c(1, 2, 3, 4),
  cohort_start_date = as.Date(c("2000-06-03", "2000-01-01", "2015-01-15", "2000-12-09")),
  cohort_end_date = as.Date(c("2001-09-01", "2001-01-12", "2015-02-15", "2002-12-09")),
  date_1 = as.Date(c("2001-08-01", "2001-01-01", "2015-01-15", "2002-12-09")),
  date_2 = as.Date(c("2001-08-01", NA, "2015-02-14", "2002-12-09"))
)
))
cdm$cohort |&gt; entryAtLastDate(dateColumns = c("date_1", "date_2"))

</code></pre>

<hr>
<h2 id='entryAtLastDate'>Set cohort start date to the last of a set of column dates</h2><span id='topic+entryAtLastDate'></span>

<h3>Description</h3>

<p>Set cohort start date to the last of a set of column dates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entryAtLastDate(
  cohort,
  dateColumns,
  cohortId = NULL,
  returnReason = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entryAtLastDate_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="entryAtLastDate_+3A_datecolumns">dateColumns</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="entryAtLastDate_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="entryAtLastDate_+3A_returnreason">returnReason</code></td>
<td>
<p>If TRUE it will return a column stating which column in
<code>dateColumns</code> is used as a new cohort end date. description</p>
</td></tr>
<tr><td><code id="entryAtLastDate_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(tables = list(
"cohort" = dplyr::tibble(
  cohort_definition_id = 1,
  subject_id = c(1, 2, 3, 4),
  cohort_start_date = as.Date(c("2000-06-03", "2000-01-01", "2015-01-15", "2000-12-09")),
  cohort_end_date = as.Date(c("2001-09-01", "2001-01-12", "2015-02-15", "2002-12-09")),
  date_1 = as.Date(c("2001-08-01", "2001-01-01", "2015-01-15", "2002-12-09")),
  date_2 = as.Date(c("2001-08-01", NA, "2015-02-14", "2002-12-09"))
)
))
cdm$cohort |&gt; entryAtLastDate(dateColumns = c("date_1", "date_2"))

</code></pre>

<hr>
<h2 id='exitAtDeath'>Set cohort end date to death date</h2><span id='topic+exitAtDeath'></span>

<h3>Description</h3>

<p>This functions changes cohort end date to subject's death date. In the case
were this generates overlapping records in the cohort, those overlapping
entries will be merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exitAtDeath(
  cohort,
  cohortId = NULL,
  requireDeath = FALSE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exitAtDeath_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="exitAtDeath_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="exitAtDeath_+3A_requiredeath">requireDeath</code></td>
<td>
<p>If TRUE, subjects without a death record will be dropped,
while if FALSE their end date will be left as is.</p>
</td></tr>
<tr><td><code id="exitAtDeath_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(PatientProfiles)
library(CohortConstructor)
cdm &lt;- mockPatientProfiles()
cdm$cohort1 |&gt; exitAtDeath()

</code></pre>

<hr>
<h2 id='exitAtFirstDate'>Set cohort end date to the first of a set of column dates</h2><span id='topic+exitAtFirstDate'></span>

<h3>Description</h3>

<p><code>exitAtFirstDate()</code> resets cohort end date based on a set of specified
column dates. The first date that occurs is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exitAtFirstDate(
  cohort,
  dateColumns,
  cohortId = NULL,
  returnReason = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exitAtFirstDate_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="exitAtFirstDate_+3A_datecolumns">dateColumns</code></td>
<td>
<p>Date columns in the cohort table to consider.</p>
</td></tr>
<tr><td><code id="exitAtFirstDate_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="exitAtFirstDate_+3A_returnreason">returnReason</code></td>
<td>
<p>If TRUE it will return a column stating which column in
<code>dateColumns</code> is used as a new cohort end date.</p>
</td></tr>
<tr><td><code id="exitAtFirstDate_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(tables = list(
"cohort" = dplyr::tibble(
  cohort_definition_id = 1,
  subject_id = c(1, 2, 3, 4),
  cohort_start_date = as.Date(c("2000-06-03", "2000-01-01", "2015-01-15", "2000-12-09")),
  cohort_end_date = as.Date(c("2001-09-01", "2001-01-12", "2015-02-15", "2002-12-09")),
  date_1 = as.Date(c("2001-08-01", "2001-01-01", "2015-01-15", "2002-12-09")),
  date_2 = as.Date(c("2001-08-01", NA, "2015-04-15", "2002-12-09"))
)
))
cdm$cohort |&gt; exitAtFirstDate(dateColumns = c("date_1", "date_2"))

</code></pre>

<hr>
<h2 id='exitAtLastDate'>Set cohort end date to the last of a set of column dates</h2><span id='topic+exitAtLastDate'></span>

<h3>Description</h3>

<p><code>exitAtLastDate()</code> resets cohort end date based on a set of specified
column dates. The last date that occurs is chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exitAtLastDate(
  cohort,
  dateColumns,
  cohortId = NULL,
  returnReason = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exitAtLastDate_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="exitAtLastDate_+3A_datecolumns">dateColumns</code></td>
<td>
<p>description</p>
</td></tr>
<tr><td><code id="exitAtLastDate_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="exitAtLastDate_+3A_returnreason">returnReason</code></td>
<td>
<p>If TRUE it will return a column stating which column in
<code>dateColumns</code> is used as a new cohort end date. description</p>
</td></tr>
<tr><td><code id="exitAtLastDate_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(tables = list(
"cohort" = dplyr::tibble(
  cohort_definition_id = 1,
  subject_id = c(1, 2, 3, 4),
  cohort_start_date = as.Date(c("2000-06-03", "2000-01-01", "2015-01-15", "2000-12-09")),
  cohort_end_date = as.Date(c("2001-09-01", "2001-01-12", "2015-02-15", "2002-12-09")),
  date_1 = as.Date(c("2001-08-01", "2001-01-01", "2015-01-15", "2002-12-09")),
  date_2 = as.Date(c("2001-08-01", NA, "2015-04-15", "2002-12-09"))
)
))
cdm$cohort |&gt; exitAtLastDate(dateColumns = c("date_1", "date_2"))

</code></pre>

<hr>
<h2 id='exitAtObservationEnd'>Set cohort end date to end of observation</h2><span id='topic+exitAtObservationEnd'></span>

<h3>Description</h3>

<p><code>exitAtObservationEnd()</code> resets cohort end date based on a set of specified
column dates. The last date that occurs is chosen.
</p>
<p>This functions changes cohort end date to the end date of the observation
period corresponding to the cohort entry. In the case were this generates
overlapping records in the cohort, overlapping entries will be merged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exitAtObservationEnd(cohort, cohortId = NULL, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exitAtObservationEnd_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="exitAtObservationEnd_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="exitAtObservationEnd_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt; exitAtObservationEnd()

</code></pre>

<hr>
<h2 id='intersectCohorts'>Generate a combination cohort set between the intersection of different
cohorts.</h2><span id='topic+intersectCohorts'></span>

<h3>Description</h3>

<p><code>intersectCohorts()</code> combines different cohort entries, with those records
that overlap combined and kept. Cohort entries are when an individual was in
<em>both</em> of the cohorts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersectCohorts(
  cohort,
  cohortId = NULL,
  gap = 0,
  mutuallyExclusive = FALSE,
  returnOnlyComb = FALSE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersectCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_gap">gap</code></td>
<td>
<p>Number of days between two subsequent cohort entries to be merged
in a single cohort record.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_mutuallyexclusive">mutuallyExclusive</code></td>
<td>
<p>Whether the generated cohorts are mutually
exclusive or not.</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_returnonlycomb">returnOnlyComb</code></td>
<td>
<p>Whether to only get the combination cohort back</p>
</td></tr>
<tr><td><code id="intersectCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the demographic requirements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort3 &lt;- intersectCohorts(
  cohort = cdm$cohort2,
  name = "cohort3",
)

settings(cdm$cohort3)


</code></pre>

<hr>
<h2 id='matchCohorts'>Generate a new cohort matched cohort</h2><span id='topic+matchCohorts'></span>

<h3>Description</h3>

<p><code>matchCohorts()</code> generate a new cohort matched to individuals in an
existing cohort. Individuals can be matched based on year of birth and sex.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matchCohorts(
  cohort,
  cohortId = NULL,
  matchSex = TRUE,
  matchYearOfBirth = TRUE,
  ratio = 1,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="matchCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="matchCohorts_+3A_matchsex">matchSex</code></td>
<td>
<p>Whether to match in sex.</p>
</td></tr>
<tr><td><code id="matchCohorts_+3A_matchyearofbirth">matchYearOfBirth</code></td>
<td>
<p>Whether to match in year of birth.</p>
</td></tr>
<tr><td><code id="matchCohorts_+3A_ratio">ratio</code></td>
<td>
<p>Number of allowed matches per individual in the target cohort.</p>
</td></tr>
<tr><td><code id="matchCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new generated cohort set.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
library(dplyr)
cdm &lt;- mockCohortConstructor(nPerson = 200)
cdm$new_matched_cohort &lt;- cdm$cohort2 |&gt;
  matchCohorts(
    name = "new_matched_cohort",
    cohortId = 2,
    matchSex = TRUE,
    matchYearOfBirth = TRUE,
    ratio = 1)
cdm$new_matched_cohort

</code></pre>

<hr>
<h2 id='measurementCohort'>Create cohorts measurement based cohorts</h2><span id='topic+measurementCohort'></span>

<h3>Description</h3>

<p><code>measurementCohort()</code> creates cohorts based on patient records contained
in the measurement table. This function extends the <code>conceptCohort()</code> as it
allows for measurement values associated with the records to be specified.
</p>

<ul>
<li><p> If <code>valueAsConcept</code> and <code>valueAsNumber</code> are NULL then no requirements on
of the values associated with measurement records and using
<code>measurementCohort()</code> will lead to the same result as using <code>conceptCohort()</code>
(so long as all concepts are from the measurement domain).
</p>
</li>
<li><p> If one of <code>valueAsConcept</code> and <code>valueAsNumber</code> is not NULL then records
will be required to have values that satisfy the requirement specified.
</p>
</li>
<li><p> If both <code>valueAsConcept</code> and <code>valueAsNumber</code> are not NULL, records will
be required to have values that fulfill <em>either</em> of the requirements
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>measurementCohort(
  cdm,
  conceptSet,
  name,
  valueAsConcept = NULL,
  valueAsNumber = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measurementCohort_+3A_cdm">cdm</code></td>
<td>
<p>A cdm reference.</p>
</td></tr>
<tr><td><code id="measurementCohort_+3A_conceptset">conceptSet</code></td>
<td>
<p>A conceptSet, which can either be a codelist
or a conceptSetExpression.</p>
</td></tr>
<tr><td><code id="measurementCohort_+3A_name">name</code></td>
<td>
<p>Name of the cohort in the cdm object.</p>
</td></tr>
<tr><td><code id="measurementCohort_+3A_valueasconcept">valueAsConcept</code></td>
<td>
<p>A vector of cohort IDs used to filter measurements.
Only measurements with these values in the <code>value_as_concept_id</code> column of
the measurement table will be included. If NULL all entries independently of
their value as concept will be considered.</p>
</td></tr>
<tr><td><code id="measurementCohort_+3A_valueasnumber">valueAsNumber</code></td>
<td>
<p>A named list indicating the range of values and the unit
they correspond to, as follows:
list(&quot;unit_concept_id&quot; = c(rangeValue1, rangeValue2)). If NULL, all entries
independently of their value as number will be included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(con = NULL)
cdm$concept &lt;- cdm$concept |&gt;
  dplyr::union_all(
    dplyr::tibble(
      concept_id = c(4326744, 4298393, 45770407, 8876, 4124457),
      concept_name = c("Blood pressure", "Systemic blood pressure",
                       "Baseline blood pressure", "millimeter mercury column",
                       "Normal range"),
      domain_id = "Measurement",
      vocabulary_id = c("SNOMED", "SNOMED", "SNOMED", "UCUM", "SNOMED"),
      standard_concept = "S",
      concept_class_id = c("Observable Entity", "Observable Entity",
                           "Observable Entity", "Unit", "Qualifier Value"),
      concept_code = NA,
      valid_start_date = NA,
      valid_end_date = NA,
      invalid_reason = NA
    )
  )
cdm$measurement &lt;- dplyr::tibble(
  measurement_id = 1:4,
  person_id = c(1, 1, 2, 3),
  measurement_concept_id = c(4326744, 4298393, 4298393, 45770407),
  measurement_date = as.Date(c("2000-07-01", "2000-12-11", "2002-09-08",
                                "2015-02-19")),
  measurement_type_concept_id = NA,
  value_as_number = c(100, 125, NA, NA),
  value_as_concept_id = c(0, 0, 0, 4124457),
  unit_concept_id = c(8876, 8876, 0, 0)
)
cdm &lt;- CDMConnector::copyCdmTo(
  con = DBI::dbConnect(duckdb::duckdb()),
  cdm = cdm, schema = "main")

cdm$cohort &lt;- measurementCohort(
  cdm = cdm,
  name = "cohort",
  conceptSet = list("normal_blood_pressure" = c(4326744, 4298393, 45770407)),
  valueAsConcept = c(4124457),
  valueAsNumber = list("8876" = c(70, 120))
)

cdm$cohort

</code></pre>

<hr>
<h2 id='mockCohortConstructor'>Function to create a mock cdm reference for CohortConstructor</h2><span id='topic+mockCohortConstructor'></span>

<h3>Description</h3>

<p><code>mockCohortConstructor()</code> creates an example dataset that can be used for
demonstrating and testing the package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mockCohortConstructor(
  nPerson = 10,
  conceptTable = NULL,
  tables = NULL,
  conceptId = NULL,
  conceptIdClass = NULL,
  drugExposure = FALSE,
  conditionOccurrence = FALSE,
  measurement = FALSE,
  death = FALSE,
  otherTables = NULL,
  con = DBI::dbConnect(duckdb::duckdb()),
  writeSchema = "main",
  seed = 123
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mockCohortConstructor_+3A_nperson">nPerson</code></td>
<td>
<p>number of person in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_concepttable">conceptTable</code></td>
<td>
<p>user defined concept table</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_tables">tables</code></td>
<td>
<p>list of tables to include in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_conceptid">conceptId</code></td>
<td>
<p>list of concept id</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_conceptidclass">conceptIdClass</code></td>
<td>
<p>the domain class of the conceptId</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_drugexposure">drugExposure</code></td>
<td>
<p>T/F include drug exposure table in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_conditionoccurrence">conditionOccurrence</code></td>
<td>
<p>T/F include condition occurrence in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_measurement">measurement</code></td>
<td>
<p>T/F include measurement in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_death">death</code></td>
<td>
<p>T/F include death table in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_othertables">otherTables</code></td>
<td>
<p>it takes a list of single tibble with names to include other tables in the cdm</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_con">con</code></td>
<td>
<p>A DBI connection to create the cdm mock object.</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_writeschema">writeSchema</code></td>
<td>
<p>Name of an schema on the same connection with writing
permissions.</p>
</td></tr>
<tr><td><code id="mockCohortConstructor_+3A_seed">seed</code></td>
<td>
<p>Seed passed to omock::mockCdmFromTable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cdm object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor()

cdm

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+cohortCount'></span><span id='topic+settings'></span><span id='topic+attrition'></span><span id='topic+cohortCodelist'></span><span id='topic+tableName'></span><span id='topic+bind'></span><span id='topic+startDateColumn'></span><span id='topic+endDateColumn'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>omopgenerics</dt><dd><p><code><a href="omopgenerics.html#topic+attrition">attrition</a></code>, <code><a href="omopgenerics.html#topic+bind">bind</a></code>, <code><a href="omopgenerics.html#topic+cohortCodelist">cohortCodelist</a></code>, <code><a href="omopgenerics.html#topic+cohortCount">cohortCount</a></code>, <code><a href="omopgenerics.html#topic+settings">settings</a></code>, <code><a href="omopgenerics.html#topic+tableName">tableName</a></code></p>
</dd>
<dt>PatientProfiles</dt><dd><p><code><a href="PatientProfiles.html#topic+endDateColumn">endDateColumn</a></code>, <code><a href="PatientProfiles.html#topic+startDateColumn">startDateColumn</a></code></p>
</dd>
</dl>

<hr>
<h2 id='requireAge'>Restrict cohort on age</h2><span id='topic+requireAge'></span>

<h3>Description</h3>

<p><code>requireAge()</code> filters cohort records, keeping only records where individuals
satisfy the specified age criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireAge(
  cohort,
  ageRange,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireAge_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireAge_+3A_agerange">ageRange</code></td>
<td>
<p>A list of minimum and maximum age.</p>
</td></tr>
<tr><td><code id="requireAge_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireAge_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in cohort that contains the date to compute the
demographics characteristics on which to restrict on.</p>
</td></tr>
<tr><td><code id="requireAge_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the age requirement.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
age requirement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  requireAge(indexDate = "cohort_start_date",
             ageRange = list(c(18, 65)))

</code></pre>

<hr>
<h2 id='requireCohortIntersect'>Require cohort subjects are present (or absence) in another cohort</h2><span id='topic+requireCohortIntersect'></span>

<h3>Description</h3>

<p><code>requireCohortIntersect()</code> filters a cohort table based on a requirement
that an individual is seen (or not seen) in another cohort in some time
window around an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireCohortIntersect(
  cohort,
  targetCohortTable,
  window,
  intersections = c(1, Inf),
  cohortId = NULL,
  targetCohortId = NULL,
  indexDate = "cohort_start_date",
  targetStartDate = "cohort_start_date",
  targetEndDate = "cohort_end_date",
  censorDate = NULL,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireCohortIntersect_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_targetcohorttable">targetCohortTable</code></td>
<td>
<p>Name of the cohort that we want to check for
intersect.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_window">window</code></td>
<td>
<p>Window to consider events over.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_intersections">intersections</code></td>
<td>
<p>A range indicating number of intersections for
criteria to be fulfilled. If a single number is passed, the number of
intersections must match this.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_targetcohortid">targetCohortId</code></td>
<td>
<p>Vector of cohort definition ids to include.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in x that contains the date to compute the
intersection.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_targetstartdate">targetStartDate</code></td>
<td>
<p>Date of reference in cohort table, either for start
(in overlap) or on its own (for incidence).</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_targetenddate">targetEndDate</code></td>
<td>
<p>Date of reference in cohort table, either for end
(overlap) or NULL (if incidence).</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_censordate">censorDate</code></td>
<td>
<p>Whether to censor overlap events at a specific date or a
column date of x.</p>
</td></tr>
<tr><td><code id="requireCohortIntersect_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the future observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with only those isatisfying the criteria kept
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  requireCohortIntersect(targetCohortTable = "cohort2",
                             targetCohortId = 1,
                             indexDate = "cohort_start_date",
                             window = c(-Inf, 0))

</code></pre>

<hr>
<h2 id='requireConceptIntersect'>Require cohort subjects to have (or not have) events of a concept list</h2><span id='topic+requireConceptIntersect'></span>

<h3>Description</h3>

<p><code>requireConceptIntersect()</code> filters a cohort table based on a requirement
that an individual is seen (or not seen) to have events related to a concept
list in some time window around an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireConceptIntersect(
  cohort,
  conceptSet,
  window,
  intersections = c(1, Inf),
  cohortId = NULL,
  indexDate = "cohort_start_date",
  targetStartDate = "event_start_date",
  targetEndDate = "event_end_date",
  censorDate = NULL,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireConceptIntersect_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_conceptset">conceptSet</code></td>
<td>
<p>Concept set list.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_window">window</code></td>
<td>
<p>Window to consider events over.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_intersections">intersections</code></td>
<td>
<p>A range indicating number of intersections for
criteria to be fulfilled. If a single number is passed, the number of
intersections must match this.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged..</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in x that contains the date to compute the
intersection.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_targetstartdate">targetStartDate</code></td>
<td>
<p>Date of reference in cohort table, either for start
(in overlap) or on its own (for incidence).</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_targetenddate">targetEndDate</code></td>
<td>
<p>Date of reference in cohort table, either for end
(overlap) or NULL (if incidence).</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_censordate">censorDate</code></td>
<td>
<p>Whether to censor overlap events at a specific date or a
column date of x.</p>
</td></tr>
<tr><td><code id="requireConceptIntersect_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the future observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with only those  with the events in the concept list
kept (or those without the event if negate = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(conditionOccurrence = TRUE)
cdm$cohort2 &lt;-  requireConceptIntersect(
  cohort = cdm$cohort1,
  conceptSet = list(a = 1),
  window = c(-Inf, 0),
  name = "cohort2")
  
</code></pre>

<hr>
<h2 id='requireDeathFlag'>Require cohort subjects have (or do not have) a death record</h2><span id='topic+requireDeathFlag'></span>

<h3>Description</h3>

<p><code>requireDeathFlag()</code> filters a cohort table based on a requirement
that an individual is seen (or not seen) to have a death in some time
window around an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireDeathFlag(
  cohort,
  window,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  censorDate = NULL,
  negate = FALSE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireDeathFlag_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_window">window</code></td>
<td>
<p>Window to consider events over.</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in x that contains the date to compute the
intersection.</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_censordate">censorDate</code></td>
<td>
<p>Whether to censor overlap events at a specific date or a
column date of x.</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_negate">negate</code></td>
<td>
<p>If set as TRUE, criteria will be applied as exclusion
rather than inclusion (i.e. require absence in another cohort).</p>
</td></tr>
<tr><td><code id="requireDeathFlag_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the future observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with only those with a death event kept (or without
if negate = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CDMConnector)
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(death = TRUE)
cdm$cohort1 &lt;- cdm$cohort1 |&gt; requireDeathFlag(window = list(c(0, Inf)))
attrition(cdm$cohort1)

</code></pre>

<hr>
<h2 id='requireDemographics'>Restrict cohort on patient demographics</h2><span id='topic+requireDemographics'></span>

<h3>Description</h3>

<p><code>requireDemographics()</code> filters cohort records, keeping only records where
individuals satisfy the specified demographic criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireDemographics(
  cohort,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  ageRange = list(c(0, 150)),
  sex = c("Both"),
  minPriorObservation = 0,
  minFutureObservation = 0,
  requirementInteractions = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireDemographics_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in cohort that contains the date to compute the
demographics characteristics on which to restrict on.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_agerange">ageRange</code></td>
<td>
<p>A list of minimum and maximum age.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_sex">sex</code></td>
<td>
<p>Can be &quot;Both&quot;, &quot;Male&quot; or &quot;Female&quot;. If one of the latter, only
those with that sex will be included.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_minpriorobservation">minPriorObservation</code></td>
<td>
<p>A minimum number of prior observation days in
the database.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_minfutureobservation">minFutureObservation</code></td>
<td>
<p>A minimum number of future observation days in
the database.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_requirementinteractions">requirementInteractions</code></td>
<td>
<p>If TRUE, cohorts will be created for
all combinations of ageGroup, sex, and daysPriorObservation. If FALSE, only the
first value specified for the other factors will be used. Consequently,
order of values matters when requirementInteractions is FALSE.</p>
</td></tr>
<tr><td><code id="requireDemographics_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the demographic requirements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
demographic requirements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(nPerson = 100)
cdm$cohort1 |&gt;
  requireDemographics(indexDate = "cohort_start_date",
                      ageRange = list(c(18, 65)),
                      sex = "Female",
                      minPriorObservation = 365)

</code></pre>

<hr>
<h2 id='requireFutureObservation'>Restrict cohort on future observation</h2><span id='topic+requireFutureObservation'></span>

<h3>Description</h3>

<p><code>requireFutureObservation()</code> filters cohort records, keeping only records
where individuals satisfy the specified future observation criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireFutureObservation(
  cohort,
  minFutureObservation,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireFutureObservation_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireFutureObservation_+3A_minfutureobservation">minFutureObservation</code></td>
<td>
<p>A minimum number of future observation days in
the database.</p>
</td></tr>
<tr><td><code id="requireFutureObservation_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireFutureObservation_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in cohort that contains the date to compute the
demographics characteristics on which to restrict on.</p>
</td></tr>
<tr><td><code id="requireFutureObservation_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the future observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
future observation requirement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  requireFutureObservation(indexDate = "cohort_start_date",
                           minFutureObservation = 30)

</code></pre>

<hr>
<h2 id='requireInDateRange'>Require that an index date is within a date range</h2><span id='topic+requireInDateRange'></span>

<h3>Description</h3>

<p><code>requireInDateRange()</code> filters cohort records, keeping only those for
which the index date is within the specified date range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireInDateRange(
  cohort,
  dateRange,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireInDateRange_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireInDateRange_+3A_daterange">dateRange</code></td>
<td>
<p>A window of time during which the index date must have
been observed.</p>
</td></tr>
<tr><td><code id="requireInDateRange_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireInDateRange_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in cohort that contains the index date of interest</p>
</td></tr>
<tr><td><code id="requireInDateRange_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with any cohort entries outside of the date range
dropped
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)
cdm$cohort1 |&gt;
  requireInDateRange(indexDate = "cohort_start_date",
                     dateRange = as.Date(c("2010-01-01", "2019-01-01")))

</code></pre>

<hr>
<h2 id='requireIsFirstEntry'>Restrict cohort to first entry</h2><span id='topic+requireIsFirstEntry'></span>

<h3>Description</h3>

<p><code>requireIsFirstEntry()</code> filters cohort records, keeping only the first
cohort entry per person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireIsFirstEntry(
  cohort,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireIsFirstEntry_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireIsFirstEntry_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireIsFirstEntry_+3A_indexdate">indexDate</code></td>
<td>
<p>Column name in cohort that contains the date to restrict on.</p>
</td></tr>
<tr><td><code id="requireIsFirstEntry_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table in a cdm reference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 &lt;- requireIsFirstEntry(cdm$cohort1)


</code></pre>

<hr>
<h2 id='requireIsLastEntry'>Restrict cohort to last entry per person</h2><span id='topic+requireIsLastEntry'></span>

<h3>Description</h3>

<p><code>requireIsLastEntry()</code> filters cohort records, keeping only the last
cohort entry per person.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireIsLastEntry(
  cohort,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireIsLastEntry_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireIsLastEntry_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireIsLastEntry_+3A_indexdate">indexDate</code></td>
<td>
<p>Column name in cohort that contains the date to restrict on.</p>
</td></tr>
<tr><td><code id="requireIsLastEntry_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table in a cdm reference.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 &lt;- requireIsLastEntry(cdm$cohort1)


</code></pre>

<hr>
<h2 id='requirePriorObservation'>Restrict cohort on prior observation</h2><span id='topic+requirePriorObservation'></span>

<h3>Description</h3>

<p><code>requirePriorObservation()</code> filters cohort records, keeping only records
where individuals satisfy the specified prior observation criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requirePriorObservation(
  cohort,
  minPriorObservation,
  cohortId = NULL,
  indexDate = "cohort_start_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requirePriorObservation_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requirePriorObservation_+3A_minpriorobservation">minPriorObservation</code></td>
<td>
<p>A minimum number of prior observation days in
the database.</p>
</td></tr>
<tr><td><code id="requirePriorObservation_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requirePriorObservation_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in cohort that contains the date to compute the
demographics characteristics on which to restrict on.</p>
</td></tr>
<tr><td><code id="requirePriorObservation_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the prior observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
prior observation requirement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  requirePriorObservation(indexDate = "cohort_start_date",
                          minPriorObservation = 365)

</code></pre>

<hr>
<h2 id='requireSex'>Restrict cohort on sex</h2><span id='topic+requireSex'></span>

<h3>Description</h3>

<p><code>requireSex()</code> filters cohort records, keeping only records where individuals
satisfy the specified sex criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireSex(cohort, sex, cohortId = NULL, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireSex_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireSex_+3A_sex">sex</code></td>
<td>
<p>Can be &quot;Both&quot;, &quot;Male&quot; or &quot;Female&quot;. If one of the latter, only
those with that sex will be included.</p>
</td></tr>
<tr><td><code id="requireSex_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireSex_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the sex requirements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
sex requirement
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  requireSex(sex = "Female")

</code></pre>

<hr>
<h2 id='requireTableIntersect'>Require cohort subjects are present in another clinical table</h2><span id='topic+requireTableIntersect'></span>

<h3>Description</h3>

<p><code>requireTableIntersect()</code> filters a cohort table based on a requirement
that an individual is seen (or not seen) to have a record (or no records) in
a clinical table in some time window around an index date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>requireTableIntersect(
  cohort,
  tableName,
  window,
  intersections = c(1, Inf),
  cohortId = NULL,
  indexDate = "cohort_start_date",
  targetStartDate = startDateColumn(tableName),
  targetEndDate = endDateColumn(tableName),
  censorDate = NULL,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="requireTableIntersect_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_tablename">tableName</code></td>
<td>
<p>Name of the table to check for intersect.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_window">window</code></td>
<td>
<p>Window to consider events over.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_intersections">intersections</code></td>
<td>
<p>A range indicating number of intersections for
criteria to be fulfilled. If a single number is passed, the number of
intersections must match this.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_indexdate">indexDate</code></td>
<td>
<p>Variable in x that contains the date to compute the
intersection.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_targetstartdate">targetStartDate</code></td>
<td>
<p>Date of reference in cohort table, either for start
(in overlap) or on its own (for incidence).</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_targetenddate">targetEndDate</code></td>
<td>
<p>Date of reference in cohort table, either for end
(overlap) or NULL (if incidence).</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_censordate">censorDate</code></td>
<td>
<p>Whether to censor overlap events at a specific date or a
column date of x.</p>
</td></tr>
<tr><td><code id="requireTableIntersect_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the future observation restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with only those in the other table kept (or those that
are not in the table if negate = TRUE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor(drugExposure = TRUE)
cdm$cohort1 |&gt;
  requireTableIntersect(tableName = "drug_exposure",
                            indexDate = "cohort_start_date",
                            window = c(-Inf, 0))

</code></pre>

<hr>
<h2 id='sampleCohorts'>Sample a cohort table for a given number of individuals.</h2><span id='topic+sampleCohorts'></span>

<h3>Description</h3>

<p><code>sampleCohorts()</code> samples an existing cohort table for a given number of
people. All records of these individuals are preserved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleCohorts(cohort, cohortId = NULL, n, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sampleCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="sampleCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will not be sampled.</p>
</td></tr>
<tr><td><code id="sampleCohorts_+3A_n">n</code></td>
<td>
<p>Number of people to be sampled for each included cohort.</p>
</td></tr>
<tr><td><code id="sampleCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new sampled cohort.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with the specified cohorts sampled.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort2 |&gt; sampleCohorts(cohortId = 1, n = 10)

</code></pre>

<hr>
<h2 id='stratifyCohorts'>Create a new cohort table from stratifying an existing one</h2><span id='topic+stratifyCohorts'></span>

<h3>Description</h3>

<p><code>stratifyCohorts()</code> creates new cohorts, splitting an existing cohort based
on specified columns on which to stratify on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stratifyCohorts(
  cohort,
  strata,
  cohortId = NULL,
  removeStrata = TRUE,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stratifyCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="stratifyCohorts_+3A_strata">strata</code></td>
<td>
<p>A strata list that point to columns in cohort table.</p>
</td></tr>
<tr><td><code id="stratifyCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="stratifyCohorts_+3A_removestrata">removeStrata</code></td>
<td>
<p>Whether to remove strata columns from final cohort table.</p>
</td></tr>
<tr><td><code id="stratifyCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new cohort.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table stratified.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
library(PatientProfiles)

cdm &lt;- mockCohortConstructor()

cdm$my_cohort &lt;- cdm$cohort1 |&gt;
  addAge(ageGroup = list("child" = c(0, 17), "adult" = c(18, Inf))) |&gt;
  addSex() |&gt;
  stratifyCohorts(
    strata = list("sex", c("sex", "age_group")), name = "my_cohort"
  )

cdm$my_cohort

settings(cdm$my_cohort)

attrition(cdm$my_cohort)

</code></pre>

<hr>
<h2 id='subsetCohorts'>Generate a cohort table using a subset of cohorts from another table.</h2><span id='topic+subsetCohorts'></span>

<h3>Description</h3>

<p><code>subsetCohorts()</code> filters an existing cohort table, keeping only the records
from cohorts that are specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetCohorts(cohort, cohortId, minCohortCount = 0, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="subsetCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="subsetCohorts_+3A_mincohortcount">minCohortCount</code></td>
<td>
<p>the minimum count of a cohort to be included. Default
is 0, meaning all non-empty cohorts will be included. Cohorts not included
will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="subsetCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the demographic requirements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cohort table with only cohorts in cohortId.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort1 |&gt; subsetCohorts(cohortId = 1)

</code></pre>

<hr>
<h2 id='trimDemographics'>Restrict cohort on patient demographics</h2><span id='topic+trimDemographics'></span>

<h3>Description</h3>

<p><code>trimDemographics()</code> resets the cohort start and end date based on the
specified demographic criteria is satisfied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimDemographics(
  cohort,
  cohortId = NULL,
  ageRange = NULL,
  sex = NULL,
  minPriorObservation = NULL,
  minFutureObservation = NULL,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimDemographics_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_agerange">ageRange</code></td>
<td>
<p>A list of minimum and maximum age.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_sex">sex</code></td>
<td>
<p>Can be &quot;Both&quot;, &quot;Male&quot; or &quot;Female&quot;. If one of the latter, only
those with that sex will be included.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_minpriorobservation">minPriorObservation</code></td>
<td>
<p>A minimum number of prior observation days in
the database.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_minfutureobservation">minFutureObservation</code></td>
<td>
<p>A minimum number of future observation days in
the database.</p>
</td></tr>
<tr><td><code id="trimDemographics_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the demographic requirements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with only records for individuals satisfying the
demographic requirements
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort1 |&gt; trimDemographics(ageRange = list(c(10, 30)))

</code></pre>

<hr>
<h2 id='trimToDateRange'>Trim cohort dates to be within a date range</h2><span id='topic+trimToDateRange'></span>

<h3>Description</h3>

<p><code>trimToDateRange()</code> resets the cohort start and end date based on the
specified date range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trimToDateRange(
  cohort,
  dateRange,
  cohortId = NULL,
  startDate = "cohort_start_date",
  endDate = "cohort_end_date",
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trimToDateRange_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="trimToDateRange_+3A_daterange">dateRange</code></td>
<td>
<p>A window of time during which the index date must have
been observed.</p>
</td></tr>
<tr><td><code id="trimToDateRange_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to modify. If NULL, all cohorts will be
used; otherwise, only the specified cohorts will be modified, and the
rest will remain unchanged.</p>
</td></tr>
<tr><td><code id="trimToDateRange_+3A_startdate">startDate</code></td>
<td>
<p>Variable with earliest date.</p>
</td></tr>
<tr><td><code id="trimToDateRange_+3A_enddate">endDate</code></td>
<td>
<p>Variable with latest date.</p>
</td></tr>
<tr><td><code id="trimToDateRange_+3A_name">name</code></td>
<td>
<p>Name of the new cohort with the restriction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohort table with record timings updated to only be within the
date range. Any records with all time outside of the range will have
been dropped.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)
cdm &lt;- mockCohortConstructor()
cdm$cohort1 |&gt;
  trimToDateRange(startDate = "cohort_start_date",
                  endDate = "cohort_end_date",
                  dateRange = as.Date(c("2015-01-01",
                                        "2015-12-31")))

</code></pre>

<hr>
<h2 id='unionCohorts'>Generate cohort from the union of different cohorts</h2><span id='topic+unionCohorts'></span>

<h3>Description</h3>

<p><code>unionCohorts()</code> combines different cohort entries, with those records
that overlap combined and kept. Cohort entries are when an individual was in
<em>either</em> of the cohorts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unionCohorts(
  cohort,
  cohortId = NULL,
  gap = 0,
  cohortName = NULL,
  name = tableName(cohort)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unionCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_gap">gap</code></td>
<td>
<p>Number of days between two subsequent cohort entries of a subject
that will be merged in a single cohort entry</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_cohortname">cohortName</code></td>
<td>
<p>Name of the returned cohort. If NULL, the cohort name will
be created by collapsing the individual cohort names, separated by &quot;_&quot;.</p>
</td></tr>
<tr><td><code id="unionCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new cohort table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort2 &lt;- cdm$cohort2 |&gt; unionCohorts()
settings(cdm$cohort2)


</code></pre>

<hr>
<h2 id='yearCohorts'>Generate a new cohort table restricting cohort entries to certain years</h2><span id='topic+yearCohorts'></span>

<h3>Description</h3>

<p><code>yearCohorts()</code> splits a cohort into multiple cohorts, one for each year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yearCohorts(cohort, years, cohortId = NULL, name = tableName(cohort))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yearCohorts_+3A_cohort">cohort</code></td>
<td>
<p>A cohort table in a cdm reference.</p>
</td></tr>
<tr><td><code id="yearCohorts_+3A_years">years</code></td>
<td>
<p>Numeric vector of years to use to restrict observation to.</p>
</td></tr>
<tr><td><code id="yearCohorts_+3A_cohortid">cohortId</code></td>
<td>
<p>IDs of the cohorts to include. If NULL all cohorts will be
considered. Cohorts not included will be removed from the cohort set.</p>
</td></tr>
<tr><td><code id="yearCohorts_+3A_name">name</code></td>
<td>
<p>Name of the new cohort table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cohort table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(CohortConstructor)

cdm &lt;- mockCohortConstructor(nPerson = 100)

cdm$cohort1 &lt;- cdm$cohort1 |&gt; yearCohorts(years = 2000:2002)
settings(cdm$cohort1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
