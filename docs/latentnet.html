<!DOCTYPE html><html><head><title>Help for package latentnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {latentnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#latentnet-package'><p>latentnet: Latent Position and Cluster Models for Statistical Networks</p></a></li>
<li><a href='#as.mcmc.list.ergmm'><p>Convert an ERGMM Object to an MCMC list object for Diagnostics.</p></a></li>
<li><a href='#bilinear-ergmTerm'><p>Bilinear (inner-product) latent space, with optional clustering</p></a></li>
<li><a href='#control.ergmm'><p>Auxiliary for Controlling ERGMM Fitting</p></a></li>
<li><a href='#davis'><p>Southern Women Data Set (Davis) as a bipartite &ldquo;network&rdquo; object</p></a></li>
<li><a href='#ergmm'><p>Fit a Latent Space Random Graph Model</p></a></li>
<li><a href='#ergmm-class'><p>Class of Fitted Exponential Random Graph Mixed Models</p></a></li>
<li><a href='#ergmm-families'><p>Edge Weight Distribution Families</p></a></li>
<li><a href='#ergmm.drawpie'><p>Draw a pie chart at a specified location.</p></a></li>
<li><a href='#ergmm.par.list'><p>A List of ERGMM Parameter Configuration</p></a></li>
<li><a href='#ergmm.prior'><p>Auxiliary for Setting the ERGMM Prior</p></a></li>
<li><a href='#euclidean-ergmTerm'><p>Euclidean distance latent space, with optional clustering</p></a></li>
<li><a href='#euclidean2-ergmTerm'><p>Squared euclidean distance latent space, with optional clustering</p></a></li>
<li><a href='#gof.ergmm'><p>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph</p>
Mixed Model Fit</a></li>
<li><a href='#Intercept-ergmTerm'><p>Intercept</p></a></li>
<li><a href='#latentcov-ergmTerm'><p>Edge covariates for the latent model</p></a></li>
<li><a href='#loopcov-ergmTerm'><p>Covariate effect on self-loops</p></a></li>
<li><a href='#loopfactor-ergmTerm'><p>Factor attribute effect on self-loops</p></a></li>
<li><a href='#loops-ergmTerm'><p>Self-loops</p></a></li>
<li><a href='#mcmc.diagnostics.ergmm'><p>Conduct MCMC diagnostics on an ERGMM fit</p></a></li>
<li><a href='#merge.ergmm'><p>Merge two or more replications of ERGMM fits</p></a></li>
<li><a href='#plot.ergmm'><p>Plotting Method for class ERGMM</p></a></li>
<li><a href='#predict.ergmm'><p>Predicted Dyad Values for an ERGMM.</p></a></li>
<li><a href='#receivercov-ergmTerm'><p>Receiver covariate effect</p></a></li>
<li><a href='#rreceiver-ergmTerm'><p>Random receiver effect</p></a></li>
<li><a href='#rsender-ergmTerm'><p>Random sender effect</p></a></li>
<li><a href='#rsociality-ergmTerm'><p>Random sociality effect</p></a></li>
<li><a href='#sendercov-ergmTerm'><p>Sender covariate effect</p></a></li>
<li><a href='#simulate.ergmm'><p>Draw from the distribution of an Exponential Random Graph Mixed Model</p></a></li>
<li><a href='#socialitycov-ergmTerm'><p>Sociality covariate effect</p></a></li>
<li><a href='#summary.ergmm'><p>ERGMM Fit Summaries</p></a></li>
<li><a href='#tribes'><p>Read Highland Tribes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.11.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Latent Position and Cluster Models for Statistical Networks</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit and simulate latent position and cluster models for statistical networks. See Krivitsky and Handcock (2008) &lt;<a href="https://doi.org/10.18637%2Fjss.v024.i05">doi:10.18637/jss.v024.i05</a>&gt; and Krivitsky, Handcock, Raftery, and Hoff (2009) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2009.04.001">doi:10.1016/j.socnet.2009.04.001</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), network, ergm (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>sna, mvtnorm, abind, coda (&ge; 0.17.1), tools, MASS,
statnet.common (&ge; 4.1.0)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Suggests:</td>
<td>KernSmooth, snowFT, rgl, heplots, rlecuyer, covr</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statnet/latentnet/issues">https://github.com/statnet/latentnet/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://statnet.org">https://statnet.org</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-19 06:38:01 UTC; pavel</td>
</tr>
<tr>
<td>Author:</td>
<td>Pavel N. Krivitsky
    <a href="https://orcid.org/0000-0002-9101-3362"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Mark S. Handcock [aut],
  Susan M. Shortreed [ctb],
  Jeremy Tantrum [ctb],
  Peter D. Hoff [ctb],
  Li Wang [ctb],
  Kirk Li [ctb],
  Jake Fisher [ctb],
  Jordan T. Bates [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pavel N. Krivitsky &lt;pavel@statnet.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-19 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='latentnet-package'>latentnet: Latent Position and Cluster Models for Statistical Networks</h2><span id='topic+latentnet'></span><span id='topic+latentnet-package'></span>

<h3>Description</h3>

<p>Fit and simulate latent position and cluster models for statistical networks. See Krivitsky and Handcock (2008) <a href="https://doi.org/10.18637/jss.v024.i05">doi:10.18637/jss.v024.i05</a> and Krivitsky, Handcock, Raftery, and Hoff (2009) <a href="https://doi.org/10.1016/j.socnet.2009.04.001">doi:10.1016/j.socnet.2009.04.001</a>.
</p>


<h3>Details</h3>

<p>The package <code>latentnet</code> is used to fit latent cluster random effect
models, where the probability of a network <code class="reqn">g</code>, on a set of nodes is a
product of dyad probabilities, each of which is a GLM with linear component
<code class="reqn">\eta_{i,j}=\sum_{k=1}^p \beta_k
X_{i,j,k}+d(Z_i,Z_j)+\delta_i+\gamma_j</code>, where <code class="reqn">X</code> is an array of dyad
covariates, <code class="reqn">\beta</code> is a vector of covariate coefficients, <code class="reqn">Z_i</code> is
the latent space position of node <code class="reqn">i</code>, <code class="reqn">d(\cdot,\cdot)</code> is a
function of the two positions: either negative Euclidean
(<code class="reqn">-||Z_i-Z_j||</code>) or bilinear (<code class="reqn">Z_i\cdot Z_j</code>), and <code class="reqn">\delta</code> and
<code class="reqn">\gamma</code> are vectors of sender and receiver effects. (Note that these
are different from the eigenmodel of Hoff (2007) &ldquo;Modeling homophily and
stochastic equivalence in symmetric relational data&rdquo;, fit by package
<code>eigenmodel</code>.)
</p>
<p>The <code><a href="#topic+ergmm">ergmm</a></code> specifies models via: <code>g ~ &lt;model terms&gt;</code> where
<code>g</code> is a <code>network</code> object For the list of possible <code>&lt;model
terms&gt;</code>, see <code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code>. For the list of the possible dyad
distribution families, see <code><a href="#topic+families.ergmm">families.ergmm</a></code>.
</p>
<p>The arguments in the <code><a href="#topic+ergmm">ergmm</a></code> function specific to latent
variable models are <code><a href="#topic+ergmm.control">ergmm.control</a></code>. See the help page for
<code><a href="#topic+ergmm">ergmm</a></code> for the details.
</p>
<p>The result of a latent variable model fit is an <code><a href="#topic+ergmm">ergmm</a></code> object.
Hence the <code><a href="base.html#topic+summary">summary</a></code>, <code>print</code>, and <code>plot</code> functions
apply to the fits.  The <code><a href="#topic+plot.ergmm">plot.ergmm</a></code> function has many options
specific to latent variable models.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pavel N. Krivitsky <a href="mailto:pavel@statnet.org">pavel@statnet.org</a> (<a href="https://orcid.org/0000-0002-9101-3362">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mark S. Handcock <a href="mailto:handcock@stat.ucla.edu">handcock@stat.ucla.edu</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Susan M. Shortreed [contributor]
</p>
</li>
<li><p> Jeremy Tantrum [contributor]
</p>
</li>
<li><p> Peter D. Hoff [contributor]
</p>
</li>
<li><p> Li Wang <a href="mailto:lxwang@gmail.com">lxwang@gmail.com</a> [contributor]
</p>
</li>
<li><p> Kirk Li <a href="mailto:kirkli@uw.edu">kirkli@uw.edu</a> [contributor]
</p>
</li>
<li><p> Jake Fisher <a href="mailto:jcf26@duke.edu">jcf26@duke.edu</a> [contributor]
</p>
</li>
<li><p> Jordan T. Bates <a href="mailto:jtbates@gmail.com">jtbates@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Mark S. Handcock, Adrian E. Raftery and Jeremy Tantrum (2007).
<em>Model-Based Clustering for Social Networks</em>.  Journal of the Royal
Statistical Society: Series A (Statistics in Society), 170(2), 301-354.
</p>
<p>Peter D. Hoff (2005). <em>Bilinear Mixed Effects Models for Dyadic Data</em>.
Journal of the American Statistical Association, 100(469), 286-295.
</p>
<p>Peter D. Hoff, Adrian E. Raftery and Mark S. Handcock (2002).  <em>Latent
space approaches to social network analysis</em>.  Journal of the American
Statistical Association, 97(460), 1090-1098.
</p>
<p>Pavel N. Krivitsky, Mark S. Handcock, Adrian E. Raftery, and Peter D. Hoff
(2009).  <em>Representing degree distributions, clustering, and homophily
in social networks with latent cluster random effects models</em>.  Social
Networks, 31(3), 204-213.
</p>
<p>Pavel N. Krivitsky and Mark S. Handcock (2008).  <em>Fitting Position
Latent Cluster Models for Social Networks with <code>latentnet</code></em>. Journal of
Statistical Software, 24(5). <a href="https://doi.org/10.18637/jss.v024.i05">doi:10.18637/jss.v024.i05</a>
</p>
<p>Susan M. Shortreed, Mark S. Handcock, and Peter D. Hoff (2006).
<em>Positional Estimation within the Latent Space Model for Networks</em>.
Methodology, 2(1), 24-33.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://statnet.org">https://statnet.org</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/statnet/latentnet/issues">https://github.com/statnet/latentnet/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.mcmc.list.ergmm'>Convert an ERGMM Object to an MCMC list object for Diagnostics.</h2><span id='topic+as.mcmc.list.ergmm'></span><span id='topic+as.mcmc.ergmm'></span>

<h3>Description</h3>

<p>Functions to extract a subset of MCMC-sampled variables from an object of
class <code><a href="#topic+ergmm.object">ergmm</a></code> and construct an
<code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list.ergmm'
as.mcmc(x, burnin = FALSE, which.vars = NULL, vertex.i = c(1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.mcmc.list.ergmm_+3A_x">x</code></td>
<td>
<p>An object of class <code><a href="#topic+ergmm.object">ergmm</a></code>.</p>
</td></tr>
<tr><td><code id="as.mcmc.list.ergmm_+3A_burnin">burnin</code></td>
<td>
<p>If <code>TRUE</code>, generates an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
object for the burnin (if stored) instead of the main sampling run.</p>
</td></tr>
<tr><td><code id="as.mcmc.list.ergmm_+3A_which.vars">which.vars</code></td>
<td>
<p>A named list mapping variable names to the indices to
include. If given, overrides the defaults and all arguments that follow.</p>
</td></tr>
<tr><td><code id="as.mcmc.list.ergmm_+3A_vertex.i">vertex.i</code></td>
<td>
<p>A numeric vector of vertices whose latent space coordinates
and random effects to include.</p>
</td></tr>
<tr><td><code id="as.mcmc.list.ergmm_+3A_...">...</code></td>
<td>
<p>Not used at this time.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless <code>which.vars</code> is specified, the <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
returned also includes all of the covariate coefficients.
</p>
<p>Regardless of whether the MCMC run was single- or multi-threaded, this
function returns an <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, with a single thread, if
necessary.
</p>


<h3>Value</h3>

<p>A <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code> object with the sample of the
selected subset of the variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>, <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>,
<code><a href="#topic+mcmc.diagnostics.ergmm">mcmc.diagnostics.ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(coda)
data(sampson)
monks.fit&lt;-ergmm(samplike~euclidean(d=2,G=3))
monks.fit.mcmc&lt;-as.mcmc.list(monks.fit)
plot(monks.fit.mcmc)
raftery.diag(monks.fit.mcmc)

</code></pre>

<hr>
<h2 id='bilinear-ergmTerm'>Bilinear (inner-product) latent space, with optional clustering</h2><span id='topic+bilinear-ergmTerm'></span><span id='topic+InitErgmTerm.bilinear'></span>

<h3>Description</h3>

<p>Adds a term to the model equal to the inner product of
the latent positions: <code class="reqn">Z_i \cdot Z_j</code>, where
<code class="reqn">Z_i</code> and <code class="reqn">Z_j</code> are the positions of their
respective actors in an unobserved social space. These positions
may optionally have a finite spherical Gaussian mixture
clustering structure. <em>Note: For a bilinear latent space
effect, two actors being closer in the clustering sense does not
necessarily mean that the expected value of a tie between them is
higher. Thus, a warning is printed when this model is combined
with clustering.</em>
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: bilinear(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)

# valued: bilinear(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bilinear-ergmTerm_+3A_d">d</code></td>
<td>
<p>The dimension of the latent space.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_g">G</code></td>
<td>
<p>The number of groups (0 for no clustering).</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_var.mul">var.mul</code></td>
<td>
<p>In the absence of <code>var</code>, this argument will be
used as a scaling factor for a function of average cluster size
and latent space dimension to set <code>var</code>. To set it in the
<code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>Z.var.mul</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_var">var</code></td>
<td>
<p>If given, the scale parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_var.df.mul">var.df.mul</code></td>
<td>
<p>In the absence of <code>var.df</code>, this argument is
the multiplier for the square root of average cluster size, which
serves in place of <code>var.df</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df.mul</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_mean.var.mul">mean.var.mul</code></td>
<td>
<p>In the absence of <code>mean.var</code>, the
multiplier for a function of number of vertices and latent space
dimension to set <code>mean.var</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var.mul</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_mean.var">mean.var</code></td>
<td>
<p>The variance of the spherical Gaussian prior
distribution of the cluster means. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_pk.mul">pK.mul</code></td>
<td>
<p>In the absence of <code>pK</code>, this argument is the
multiplier for the square root of the average cluster size, which
is used as <code>pK</code>. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
<tr><td><code id="bilinear-ergmTerm_+3A_pk">pK</code></td>
<td>
<p>The parameter of the Dirichilet prior distribution of
cluster assignment probabilities. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>Z</code></dt><dd><p> Numeric matrix with rows being latent space
positions.</p>
</dd>
<dt><code>Z.K</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Integer vector of
cluster assignments. </p>
</dd>
<dt><code>Z.mean</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric matrix
with rows being cluster means. </p>
</dd>
<dt><code>Z.var</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Depending on the
model, either a numeric vector with within-cluster variances
or a numeric scalar with the overal latent space variance. </p>
</dd>
<dt><code>Z.pK</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric vector of
probabilities of a vertex being in a particular cluster.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='control.ergmm'>Auxiliary for Controlling ERGMM Fitting</h2><span id='topic+control.ergmm'></span><span id='topic+ergmm.control'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code>ergmm</code> fitting. Typically
only used when calling <code>ergmm</code>. It is used to set parameters that
affect the sampling but do not affect the posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control.ergmm(
  sample.size = 4000,
  burnin = 10000,
  interval = 10,
  threads = 1,
  kl.threads = 1,
  mle.maxit = 100,
  Z.delta = 0.6,
  RE.delta = 0.6,
  group.deltas = 0.4,
  pilot.runs = 4,
  pilot.factor = 0.8,
  pilot.discard.first = 0.5,
  target.acc.rate = 0.234,
  backoff.threshold = 0.05,
  backoff.factor = 0.2,
  accept.all = FALSE,
  store.burnin = FALSE,
  refine.user.start = TRUE
)

ergmm.control(
  sample.size = 4000,
  burnin = 10000,
  interval = 10,
  threads = 1,
  kl.threads = 1,
  mle.maxit = 100,
  Z.delta = 0.6,
  RE.delta = 0.6,
  group.deltas = 0.4,
  pilot.runs = 4,
  pilot.factor = 0.8,
  pilot.discard.first = 0.5,
  target.acc.rate = 0.234,
  backoff.threshold = 0.05,
  backoff.factor = 0.2,
  accept.all = FALSE,
  store.burnin = FALSE,
  refine.user.start = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control.ergmm_+3A_sample.size">sample.size</code></td>
<td>
<p>The number of draws to be taken from the posterior
distribution.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_burnin">burnin</code></td>
<td>
<p>The number of initial MCMC iterations to be discarded.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_interval">interval</code></td>
<td>
<p>The number of iterations between consecutive draws.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_threads">threads</code></td>
<td>
<p>The number of chains to run. If greater than 1, package
<code><a href="snowFT.html#topic+snowFT-package">snowFT</a></code> is used to take advantage of any
multiprocessing or distributed computing capabilities that may be available.
Currently, only PVM (via <code>rpvm</code>) has been tested. Note, also, that PVM
daemon needs to be started before the package is loaded.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_kl.threads">kl.threads</code></td>
<td>
<p>If greather than 1, uses an experimental parallelized
label-switching algorithm. This is not guaranteed to work.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_mle.maxit">mle.maxit</code></td>
<td>
<p>Maximum number of iterations for computing the starting
values, posterior modes, MLEs, MKL estimates, etc..</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_z.delta">Z.delta</code></td>
<td>
<p>Standard deviation of the proposal for the jump in the
individual latent space position, or its starting value for the tuner.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_re.delta">RE.delta</code></td>
<td>
<p>Standard deviation of the proposal for the jump in the
individual random effects values, or its starting value for the tuner.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_group.deltas">group.deltas</code></td>
<td>
<p>A scalar, a vector, or a matrix of an appropriate size,
giving the initial proposal structure for the &ldquo;group proposal&rdquo; of a jump
in covariate coefficients, scaling of latent space positions, and a shift in
random ffects. If a matrix of an appropriate size is given, it is used as a
matrix of coefficients for a correlated proposal. If a vector is given, an
independent proposal is used with the corresponding elements being proposal
standard deviations. If a scalar is given, it is used as a multiplier for an
initial heuristic for the proposal structure. It is usually best to leave
this argument alone and let the adaptive sampling be used.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_pilot.runs">pilot.runs</code></td>
<td>
<p>Number of pilot runs into which to split the burn-in
period. After each pilot run, the proposal standard deviations and
coefficients <code>Z.delta</code>, <code>RE.delta</code>, and <code>group.deltas</code> are
reevaluated. If set to <code>0</code>, disables adaptive sampling, and only makes
a single burn-in run.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_pilot.factor">pilot.factor</code></td>
<td>
<p>Initial value for the factor by which the coefficients
gotten by a Choletsky decomposition of the pilot sample covariance matrix
are multiplied.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_pilot.discard.first">pilot.discard.first</code></td>
<td>
<p>Proportion of draws from the pilot run to discard
for estimating acceptance rate and group proposal covariance.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_target.acc.rate">target.acc.rate</code></td>
<td>
<p>Taget acceptance rate for the proposals used. After a
pilot run, the proposal variances are adjusted upward if the acceptance rate
is above this, and downward if below.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_backoff.threshold">backoff.threshold</code></td>
<td>
<p>If a pilot run's acceptance rate is below this,
redo it with drastically reduced proposal standard deviation.  Set to
<code>0</code> to disable this behavior.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_backoff.factor">backoff.factor</code></td>
<td>
<p>Factor by which to multiply the relevant proposal
standard deviation if its acceptance rate fell below the backoff threshold.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_accept.all">accept.all</code></td>
<td>
<p>Forces all proposals to be accepted unconditionally. Use
only in debugging proposal distributions!</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_store.burnin">store.burnin</code></td>
<td>
<p>If <code>TRUE</code>, the samples from the burnin are also
stored and returned, to be used in MCMC diagnostics.</p>
</td></tr>
<tr><td><code id="control.ergmm_+3A_refine.user.start">refine.user.start</code></td>
<td>
<p>If <code>TRUE</code>, the values passed to
<code><a href="#topic+ergmm">ergmm</a></code> in the <code>user.start</code> argument can be updated by the
mode-finding algorithm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the arguments as components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(sampson)
## Shorter run than default.
samp.fit&lt;-ergmm(samplike~euclidean(d=2,G=3)+rreceiver,
control=ergmm.control(burnin=1000,sample.size= 2000,interval=5))


</code></pre>

<hr>
<h2 id='davis'>Southern Women Data Set (Davis) as a bipartite &ldquo;network&rdquo; object</h2><span id='topic+davis'></span>

<h3>Description</h3>

<p>This is a data set of 18 women observed over a nine-month period. During
that period, various subsets of these women had met in a series of 14
informal social events. The data recored which women met for which events.
The data is originally from Davis, Gardner and Gardner (1941) via
<code>UCINET</code> and stored as a <code>network</code> object.
</p>


<h3>Details</h3>

<p>This documentation is taken from Freeman (2003) in his usual lucid
description. See the reference to the paper below:
</p>
<p>In the 1930s, five ethnographers, Allison Davis, Elizabeth Stubbs Davis,
Burleigh B. Gardner, Mary R. Gardner and J. G. St. Clair Drake, collected
data on stratification in Natchez, Mississippi (Warner, 1988, p. 93). They
produced the book cited below (DGG) that reported a comparative study of
social class in black and in white society. One element of this work
involved examining the correspondence between people's social class levels
and their patterns of informal interaction. DGG was concerned with the issue
of how much the informal contacts made by individuals were established
solely (or primarily) with others at approximately their own class levels.
To address this question the authors collected data on social events and
examined people's patterns of informal contacts.
</p>
<p>In particular, they collected systematic data on the social activities of 18
women whom they observed over a nine-month period. During that period,
various subsets of these women had met in a series of 14 informal social
events. The participation of women in events was uncovered using
<code style="white-space: pre;">&#8288;interviews, the records of participant observers, guest lists, and the newspapers'' (DGG, p. 149). Homans (1950, p. 82), who presumably had been in touch with the research team, reported that the data reflect joint activities like, &#8288;</code>a day's work behind the counter of a store, a meeting of
a women's club, a church supper, a card party, a supper party, a meeting of
the Parent-Teacher Association, etc.&rdquo;
</p>
<p>This data set has several interesting properties. It is small and
manageable. It embodies a relatively simple structural pattern, one in
which, according to DGG, the women seemed to organize themselves into two
more or less distinct groups. Moreover, they reported that the positions -
core and peripheral - of the members of these groups could also be
determined in terms of the ways in which different women had been involved
in group activities. At the same time, the DGG data set is complicated
enough that some of the details of its patterning are less than obvious. As
Homans (1950, p. 84) put it, <code style="white-space: pre;">&#8288;The pattern is frayed at the edges.'' And, finally, this data set comes to us in a two-mode &#8288;</code>woman by event&rdquo; form.
Thus, it provides an opportunity to explore methods designed for direct
application to two-mode data. But at the same time, it can easily be
transformed into two one-mode matrices (woman by woman or event by event)
that can be examined using tools for one-mode analysis.
</p>
<p>Because of these properties, this DGG data set has become something of a
touchstone for comparing analytic methods in social network analysis. Davis,
Gardner and Gardner presented an intuitive interpretation of the data, based
in part on their ethnographic experience in the community. Then the DGG data
set was picked up by Homans (1950) who provided an alternative intuitive
interpretation. In 1972, Phillips and Conviser used an analytic tool, based
on information theory, that provided a systematic way to reexamine the DGG
data. Since then, this data set has been analyzed again and again. It
reappears whenever any network analyst wants to explore the utility of some
new tool for analyzing data.
</p>
<p>If the source of the data set does not specified otherwise, this data set is
protected by the Creative Commons License
<a href="https://creativecommons.org/licenses/by-nc-nd/2.5/">https://creativecommons.org/licenses/by-nc-nd/2.5/</a>.
</p>
<p>When publishing results obtained using this data set the original authors
should be cited.  In addition this package should be cited.
</p>


<h3>Source</h3>

<p>Linton C. Freeman (2003).  <em>Finding Social Groups: A
Meta-Analysis of the Southern Women Data</em>, In Ronald Breiger, Kathleen
Carley and Philippa Pattison, eds. Dynamic Social Network Modeling and
Analysis. Washington: The National Academies Press.
</p>


<h3>References</h3>

<p>Davis, A., Gardner, B. B. and M. R. Gardner (1941) <em>Deep
South,</em> Chicago: The University of Chicago Press.
</p>
<p>Linton C. Freeman (2003). <em>Finding Social Groups: A Meta-Analysis of
the Southern Women Data</em>, In Ronald Breiger, Kathleen Carley and Philippa
Pattison, eds. Dynamic Social Network Modeling and Analysis. Washington: The
National Academies Press.
</p>


<h3>See Also</h3>

<p>statnet, network, ergm, ergm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(davis)
# Fit a 2D 2-cluster fit and plot.
davis.fit&lt;-ergmm(davis~euclidean(d=2,G=2)+rsociality)
plot(davis.fit,pie=TRUE,rand.eff="sociality")


</code></pre>

<hr>
<h2 id='ergmm'>Fit a Latent Space Random Graph Model</h2><span id='topic+ergmm'></span><span id='topic+latent'></span><span id='topic+latentcluster'></span>

<h3>Description</h3>

<p><code><a href="#topic+ergmm">ergmm()</a></code> is used to fit latent space and latent space cluster
random network models, as described by Hoff, Raftery and Handcock (2002),
Handcock, Raftery and Tantrum (2005), and Krivitsky, Handcock, Raftery, and
Hoff (2009).  <code><a href="#topic+ergmm">ergmm()</a></code> can return either a Bayesian model fit or
the two-stage MLE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmm(
  formula,
  response = NULL,
  family = "Bernoulli",
  fam.par = NULL,
  control = control.ergmm(),
  user.start = list(),
  prior = ergmm.prior(),
  tofit = c("mcmc", "mkl", "mkl.mbc", "procrustes", "klswitch"),
  Z.ref = NULL,
  Z.K.ref = NULL,
  seed = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmm_+3A_formula">formula</code></td>
<td>
<p>An formula object, of the form <code>g ~ &lt;term 1&gt; +
  &lt;term 2&gt; ...</code>, where <code>g</code> is a network object or a matrix
that can be coerced to a network object, and <code>&lt;term 1&gt;</code>,
<code>&lt;term 2&gt;</code>, etc., are each terms for the model. See
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for the terms that can be fitted, though note the
section on fixed effects below.  To create a network object in ,
use the <code>network</code> function, then add nodal attributes to it
using <code>set.vertex.attribute</code> if necessary.
</p>
<p>Note that, as in <code><a href="stats.html#topic+lm">lm()</a></code>, the model will include an
<code><a href="#topic+Intercept-ergmTerm">intercept</a></code> term. This behavior can be overridden by
including a <code>-1</code> or <code>+0</code> term in the formula, and a
<code><a href="#topic+Intercept-ergmTerm">1(mean=...,var=...)</a></code> term can be used
to set a prior different from default.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_response">response</code></td>
<td>
<p>An optional edge attribute that serves as the response
variable. By default, presence (1) or absence (0) of an edge in <code>g</code> is
used.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_family">family</code></td>
<td>
<p>A character vector specifying the conditional distribution of
each edge value. See <a href="#topic+families.ergmm">families.ergmm</a> for the currently implemented
families.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_fam.par">fam.par</code></td>
<td>
<p>For those families that require additional parameters, a
list.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_control">control</code></td>
<td>
<p>The MCMC parameters that do not affect the posterior
distribution such as the sample size, the proposal variances, and tuning
parameters, in the form of a named list. See <code><a href="#topic+control.ergmm">control.ergmm</a></code> for
more information and defaults.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_user.start">user.start</code></td>
<td>
<p>An optional initial configuration parameters for MCMC in
the form of a list. By default, posterior mode conditioned on cluster
assignments is used. It is permitted to only supply some of the parameters
of a configuration. If this is done, the remaining paramters are fitted
conditional on those supplied.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_prior">prior</code></td>
<td>
<p>The prior parameters for the model being fitted in the form of
a named list. See term help for the terms to use.  If given, will
override those given in the formula terms, making it useful as a convenient
way to store and reproduce a prior distribution. The list or prior
parameters can also be extracted from an <a href="#topic+ergmm.object">ERGMM fit
object</a>. See <code><a href="#topic+ergmm.prior">ergmm.prior</a></code> for more information.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_tofit">tofit</code></td>
<td>
<p>A character vector listing some subset of &quot;pmode&quot;, &quot;mcmc&quot;,
&quot;mkl&quot;, &quot;mkl.mbc&quot;, &quot;mle&quot;,&quot;procrustes&quot;, and &quot;klswitch&quot;, defaulting to all of
the above, instructing <code><a href="#topic+ergmm">ergmm</a></code> what should be returned as a part
of the <a href="#topic+ergmm.object">ERGMM fit object</a>. Omiting can be used to skip
particular steps in the fitting process. If the requested procedure or
output depends on some other procedure or output not explictly listed, the
dependency will be resolved automatically.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_z.ref">Z.ref</code></td>
<td>
<p>If given, used as a reference for Procrustes analysis.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_z.k.ref">Z.K.ref</code></td>
<td>
<p>If given, used as a reference for label-switching.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_seed">seed</code></td>
<td>
<p>If supplied, random number seed.</p>
</td></tr>
<tr><td><code id="ergmm_+3A_verbose">verbose</code></td>
<td>
<p>If this is <code>TRUE</code> (or <code>1</code>), causes information to
be printed out about the progress of the fitting, particularly initial value
generation. Higher values lead to greater verbosity.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code> returns an object of class
<code><a href="#topic+ergmm.object">ergmm</a></code> containing the information about the
posterior.
</p>


<h3>Specifying fixed effects</h3>

<p>Each coefficient for a fixed effect covariate has a normal prior whose
mean and variance are set by the <code>mean</code> and <code>var</code> parameters
of the term. For those formula terms that add more than one covariate,
a vector can be given for mean and variance. If not, the vectors given
will be repeated until the needed length is reached.
</p>
<p><code><a href="#topic+ergmm">ergmm</a></code> can use model terms implemented for the
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> package and via the
<a href="https://github.com/statnet/ergm.userterms"><code>ergm.userterms</code>
API (in GitHub repository <code>statnet/ergm.userterms</code>)</a>. See
<code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for a list of available terms. If you
wish to specify the prior mean and variance, you can add them to
the call. E.g.,<br /> <code>TERMNAME(..., mean=0, var=9)</code>,<br /> where
<code>...</code> are the arguments for the <code>ergm</code> term, will
initialize <code>TERMNAME</code> with prior mean of 0 and prior variance
of 9.
</p>
<p>Some caveats:
</p>

<ul>
<li> <p><code><a href="ergm.html#topic+ergm-package">ergm</a></code> has a binary and a valued
mode. Regardless of the <code><a href="#topic+families.ergmm">family</a></code>
used, the <em>binary</em> variant of the
<code><a href="ergm.html#topic+ergm-package">ergm</a></code> term will be used in the
linear predictor of the model.
</p>
</li>
<li> <p><code><a href="ergm.html#topic+ergm-package">ergm</a></code> does not support modeling
self-loops, so terms imported in this way will always have
predictor <code>x[i,i]==0</code>. This should not affect most
situations, but if you absolutely must model self-loops and
non-self-edges in one term, use the deprecated terms below.
</p>
</li>
<li> <p><code>latentnet</code> only fits models with dyadic
independence. Terms that induce dyadic dependence (e.g.,
<code>triangles</code>) can be used, but then the likelihood of the
model will, effectively, be replaced with
pseudolikelihood. (Note that under dyadic independence, the two
are equal.)
</p>
</li></ul>



<h3>References</h3>

<p>Mark S. Handcock, Adrian E. Raftery and Jeremy Tantrum (2002).
<em>Model-Based Clustering for Social Networks.</em> Journal of the Royal
Statistical Society: Series A, 170(2), 301-354.
</p>
<p>Peter D. Hoff, Adrian E. Raftery and Mark S. Handcock (2002).  <em>Latent
space approaches to social network analysis.</em> Journal of the American
Statistical Association, 97(460), 1090-1098.
</p>
<p>Pavel N. Krivitsky, Mark S. Handcock, Adrian E. Raftery, and Peter D. Hoff
(2009). <em>Representing degree distributions, clustering, and homophily
in social networks with latent cluster random effects models</em>.  Social
Networks, 31(3), 204-213.
</p>
<p>Pavel N. Krivitsky and Mark S. Handcock (2008).  <em>Fitting Position
Latent Cluster Models for Social Networks with <code>latentnet</code></em>. Journal of
Statistical Software, 24(5). <a href="https://doi.org/10.18637/jss.v024.i05">doi:10.18637/jss.v024.i05</a>
</p>


<h3>See Also</h3>

<p><code><a href="network.html#topic+network">network</a></code>, <a href="#topic+summary.ergmm">summary.ergmm</a>, <code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code>, <code><a href="#topic+families.ergmm">families.ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#
# Use 'data(package = "latentnet")' to list the data sets in a
#
data(package="latentnet")
#
# Using Sampson's Monk data, lets fit a 
# simple latent position model
#
data(sampson)
samp.fit &lt;- ergmm(samplike ~ euclidean(d=2))
#
# See if we have convergence in the MCMC
mcmc.diagnostics(samp.fit)
#
# Plot the fit
#
plot(samp.fit)
#
# Using Sampson's Monk data, lets fit a latent clustering random effects model
#
samp.fit2 &lt;- ergmm(samplike ~ euclidean(d=2, G=3)+rreceiver)
#
# See if we have convergence in the MCMC
mcmc.diagnostics(samp.fit2)
#
# Plot the fit.
#
plot(samp.fit2, pie=TRUE)

</code></pre>

<hr>
<h2 id='ergmm-class'>Class of Fitted Exponential Random Graph Mixed Models</h2><span id='topic+ergmm-class'></span><span id='topic+ergmm.object'></span><span id='topic+print.ergmm'></span><span id='topic+show.ergmm'></span>

<h3>Description</h3>

<p>A class <code><a href="#topic+ergmm.object">ergmm</a></code> to represent a fitted exponential
random graph mixed model. The output of <code><a href="#topic+ergmm">ergmm</a></code>.
</p>


<h3>Details</h3>

<p>There are methods <code><a href="#topic+summary.ergmm">summary.ergmm</a></code>, <code>print.ergmm</code>,
<code><a href="#topic+plot.ergmm">plot.ergmm</a></code>, <code><a href="#topic+predict.ergmm">predict.ergmm</a></code>, and
<code><a href="#topic+as.mcmc.list.ergmm">as.mcmc.list.ergmm</a></code>.
</p>
<p>The structure of <code>ergmm</code> is as follows:
</p>

<dl>
<dt><code>sample</code></dt><dd><p> An object of class <code><a href="#topic+ergmm.par.list.object">ergmm.par.list</a></code> containing the
MCMC sample from the posterior. If the run had multiple threads, their output is concatenated.</p>
</dd>
<dt><code>mcmc.mle</code></dt><dd><p> A list containing the parameter
configuration of the highest-likelihood MCMC iteration. </p>
</dd>
<dt><code>mcmc.pmode</code></dt><dd><p> A list containing the parameter
configuration of the highest-joint-density (conditional on cluster
assignments) MCMC iteration. </p>
</dd>
<dt><code>mkl</code></dt><dd><p> A list containing the MKL estimate. </p>
</dd>
<dt><code>model</code></dt><dd><p> A list containing the model
that was fitted.</p>
</dd>
<dt><code>prior</code></dt><dd><p> A list containing the
information about the prior distribution used. It can be passed as
parameter <code>prior</code> to <code><a href="#topic+ergmm">ergmm</a></code> to reproduce the prior
in a new fit.</p>
</dd>
<dt><code>control</code></dt><dd><p> A list containing the
information about the model fit settings that do not affect the
posterior distribution. It can be passed as
parameter <code>control</code> to <code><a href="#topic+ergmm">ergmm</a></code> to reproduce control
parameters in a new fit.</p>
</dd>
<dt><code>mle</code></dt><dd><p> A list containing the MLE,
conditioned on cluster assignments.</p>
</dd>
<dt><code>pmode</code></dt><dd><p> A list containing the posterior mode,
conditioned on cluster assignments.</p>
</dd>
<dt><code>burnin.start</code></dt><dd><p> A list containing the starting
value for the burnin.</p>
</dd>
<dt><code>main.start</code></dt><dd><p>  A list (or a list of lists, for a
multithreaded run) containing the starting
value for the sampling. </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>, <code><a href="#topic+summary.ergmm">summary.ergmm</a></code>,
<code><a href="#topic+plot.ergmm">plot.ergmm</a></code>, <code><a href="#topic+predict.ergmm">predict.ergmm</a></code>,
<code><a href="#topic+as.mcmc.list.ergmm">as.mcmc.list.ergmm</a></code>
</p>

<hr>
<h2 id='ergmm-families'>Edge Weight Distribution Families</h2><span id='topic+ergmm-families'></span><span id='topic+families.ergmm'></span><span id='topic+family'></span><span id='topic+ergmm.families'></span><span id='topic+dlpY.deta.Bernoulli.logit'></span><span id='topic+dlpY.deta.binomial.logit'></span><span id='topic+dlpY.deta.fs'></span><span id='topic+dlpY.deta.Poisson.log'></span><span id='topic+dlpY.deta.normal.identity'></span><span id='topic+dlpY.ddispersion.fs'></span><span id='topic+dlpY.ddispersion.normal.identity'></span><span id='topic+lpYc.Bernoulli.logit'></span><span id='topic+lpYc.binomial.logit'></span><span id='topic+lpYc.normal.identity'></span><span id='topic+lpYc.fs'></span><span id='topic+lpYc.Poisson.log'></span><span id='topic+lpY.Bernoulli.logit'></span><span id='topic+lpY.binomial.logit'></span><span id='topic+lpY.Poisson.log'></span><span id='topic+lpY.normal.identity'></span><span id='topic+lpY.fs'></span><span id='topic+EY.Bernoulli.logit'></span><span id='topic+EY.binomial.logit'></span><span id='topic+EY.fs'></span><span id='topic+EY.Poisson.log'></span><span id='topic+EY.normal.identity'></span><span id='topic+pY.fs'></span><span id='topic+pY.Poisson.log'></span><span id='topic+pY.Bernoulli.logit'></span><span id='topic+pY.binomial.logit'></span><span id='topic+pY.normal.identity'></span><span id='topic+rsm.fs'></span><span id='topic+rsm.Poisson.log'></span><span id='topic+rsm.binomial.logit'></span><span id='topic+rsm.Bernoulli.logit'></span><span id='topic+rsm.normal.identity'></span><span id='topic+family.IDs'></span><span id='topic+family.names'></span><span id='topic+fam.par.check'></span>

<h3>Description</h3>

<p>Family-link combinations supported by <code><a href="#topic+ergmm">ergmm</a></code>.
</p>


<h3>Details</h3>

<p>Each supported family has a family of functions, of the form <code>pY.</code>-,
<code>lpY.</code>-, <code>EY.</code>-, <code>dlpY.deta.</code>-, <code>dlpY.ddispersion.</code>-,
<code>lpYc.</code>-, <code>rsm.</code>-, followed by the family's name, for the
respective family's name, representing the family's likelihood,
log-likelihood, expectation, derivative of log-likelihood with repect to the
linear predictor, derivative of log-likelihood with respect to the
dispersion parameter, log-normalizing-constant, and random sociomatrix
generation functions.
</p>
<p>On the <code>C</code> side, similar functions exist, but becuase of static typing,
are also provided for &ldquo;continuous&rdquo; versions of those families. These
should not be used on their own, but are used in estimating MKL positions
from the posterior distribution.
</p>


<h3>Family-link combinations</h3>


<table>
<tr>
 <td style="text-align: right;">
ID </td><td style="text-align: left;"> <code>C</code> name          </td><td style="text-align: left;"> <span class="rlang"><b>R</b></span> name   </td><td style="text-align: left;"> Type       </td><td style="text-align: left;"> Family    </td><td style="text-align: left;"> Link  </td>
</tr>
<tr>
 <td style="text-align: right;">
1 </td><td style="text-align: left;"> <code>Bernoulli_logit</code>       </td><td style="text-align: left;"> <code>Bernoulli.logit</code> </td><td style="text-align: left;"> Discrete   </td><td style="text-align: left;"> Bernoulli </td><td style="text-align: left;"> logit </td>
</tr>
<tr>
 <td style="text-align: right;">
2 </td><td style="text-align: left;"> <code>binomial_logit</code>        </td><td style="text-align: left;"> <code>binomial.logit</code>  </td><td style="text-align: left;"> Discrete   </td><td style="text-align: left;"> binomial  </td><td style="text-align: left;"> logit </td>
</tr>
<tr>
 <td style="text-align: right;">
3 </td><td style="text-align: left;"> <code>Poisson_log</code>           </td><td style="text-align: left;"> <code>Poisson.log</code>     </td><td style="text-align: left;"> Discrete   </td><td style="text-align: left;"> Possion   </td><td style="text-align: left;"> log   </td>
</tr>
<tr>
 <td style="text-align: right;">
4 </td><td style="text-align: left;"> <code>Bernoulli_cont_logit</code> </td><td style="text-align: left;"> NA              </td><td style="text-align: left;"> Continuous </td><td style="text-align: left;"> Bernoulli </td><td style="text-align: left;"> logit </td>
</tr>
<tr>
 <td style="text-align: right;">
5 </td><td style="text-align: left;"> <code>binomial_cont_logit</code>  </td><td style="text-align: left;"> NA              </td><td style="text-align: left;"> Continuous </td><td style="text-align: left;"> binomial  </td><td style="text-align: left;"> logit </td>
</tr>
<tr>
 <td style="text-align: right;">
6 </td><td style="text-align: left;"> <code>Poisson_cont_log</code>     </td><td style="text-align: left;"> NA              </td><td style="text-align: left;"> Continuous </td><td style="text-align: left;"> Possion   </td><td style="text-align: left;"> log </td>
</tr>
<tr>
 <td style="text-align: right;">
7 </td><td style="text-align: left;"> <code>normal_identity</code>      </td><td style="text-align: left;"> <code>normal.identity</code> </td><td style="text-align: left;"> Continuous </td><td style="text-align: left;"> normal   </td><td style="text-align: left;"> identity
</td>
</tr>

</table>

<p><code>.link</code> can be omited when not ambiguous. Some families
require an appropriate <code>fam.par</code> argument to be supplied to
<code><a href="#topic+ergmm">ergmm</a></code>:
</p>

<dl>
<dt>binomial families</dt><dd><p>a mandatory <code>trials</code> parameter for the
number of trials (same for every dyad) whose success the response
counts represent</p>
</dd>
<dt>normal</dt><dd><p>a mandatory <code>prior.var</code> and <code>prior.var.df</code> parameter for the prior scale and degrees of freedom of the variance of
the dyad values</p>
</dd>
</dl>


<hr>
<h2 id='ergmm.drawpie'>Draw a pie chart at a specified location.</h2><span id='topic+ergmm.drawpie'></span>

<h3>Description</h3>

<p>Used by <code><a href="#topic+plot.ergmm">plot.ergmm</a></code> to draw pie charts to visualize soft
clusterings when <code>pie=TRUE</code>. Exported as a courtesy to dependent
packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmm.drawpie(center, radius, probs, n = 50, cols = seq_along(probs), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmm.drawpie_+3A_center">center</code></td>
<td>
<p>A numeric vector of length 2, specifying the horizontal and
the vertical coordinates of its center.</p>
</td></tr>
<tr><td><code id="ergmm.drawpie_+3A_radius">radius</code></td>
<td>
<p>Radius of the pie chart.</p>
</td></tr>
<tr><td><code id="ergmm.drawpie_+3A_probs">probs</code></td>
<td>
<p>A vector of probabilities/weights of each sector; they do not
have to sum to 1.</p>
</td></tr>
<tr><td><code id="ergmm.drawpie_+3A_n">n</code></td>
<td>
<p>Number of points to use to approximate the &quot;circle&quot;.</p>
</td></tr>
<tr><td><code id="ergmm.drawpie_+3A_cols">cols</code></td>
<td>
<p>A vector of colors to use for the sectors.</p>
</td></tr>
<tr><td><code id="ergmm.drawpie_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently unused.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>See COPYRIGHT.
</p>


<h3>See Also</h3>

<p>plot.ergmm
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(0,sum(1:11))*2,c(-10,10),type="n",asp=1)
for(i in 1:10) ergmm.drawpie(c(sum(1:i)*2,0), radius=i, probs=1:(i+1))

</code></pre>

<hr>
<h2 id='ergmm.par.list'>A List of ERGMM Parameter Configuration</h2><span id='topic+ergmm.par.list'></span><span id='topic+ergmm.par.list.object'></span><span id='topic+as.ergmm.par.list'></span><span id='topic+as.mcmc.list.ergmm.par.list'></span><span id='topic++5B.ergmm.par.list'></span><span id='topic++5B+5B.ergmm.par.list'></span><span id='topic++24.ergmm.par.list'></span><span id='topic+length.ergmm.par.list'></span><span id='topic+unstack.ergmm.par.list'></span><span id='topic+del.iteration'></span>

<h3>Description</h3>

<p>A class <code><a href="#topic+ergmm.par.list.object">ergmm.par.list</a></code> to represent a
series of parameter configurations for the same exponential random graph
mixed model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ergmm.par.list(x, ...)

## S3 method for class 'ergmm.par.list'
x[i]

## S3 method for class 'ergmm.par.list'
length(x)

## S3 method for class 'ergmm.par.list'
x[[i]]

## S3 method for class 'ergmm.par.list'
unstack(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmm.par.list_+3A_x">x</code></td>
<td>
<p>an <code>ergm.par.list</code> object.</p>
</td></tr>
<tr><td><code id="ergmm.par.list_+3A_...">...</code></td>
<td>
<p>extra arguments, currently unused.</p>
</td></tr>
<tr><td><code id="ergmm.par.list_+3A_i">i</code></td>
<td>
<p>index of the iteration to extract.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>[[</code> operator with a
numeric or integer index returns a
list with the the
configuration with that index. <code>[</code> operator given a numeric
vector returns a <code>ergmm.par.list</code> object with the subset of
configurations with the indices given.
</p>
<p>The structure of <code>ergmm.par.list</code> is derived from named lists, with each entry having an
additional dimension (always the first one), indexed by
configuration. That is, scalars become vectors, vectors become
matrixes with the original vectors in rows, and matrices become
3-dimensional arrays, with the original matrices indexed by their
first dimension. See term documentation for comon elements of
these configurations.
In some cases, such as when representing MCMC or optimization output,
the object may also have some of the following elements:
</p>

<dl>
<dt><code>mlp</code></dt><dd><p><code class="reqn">\log p(Y,Z,\beta,\mu,\sigma,\delta,\gamma,\sigma_\delta,\sigma_\gamma,|K)</code>,
the joint
probability/density of network, the covariate coefficients, the
latent space positions and parameters, and the random effects and
their variances, conditional on cluster assignments.</p>
</dd>
<dt><code>lpY</code></dt><dd><p><code class="reqn">\log p(Y|\dots)</code>, depending on the model, the log-probability or
log-density of the network conditional on all the parameters.</p>
</dd>
<dt><code>lpZ</code></dt><dd><p><code class="reqn">\log p(Z|\mu,\sigma,K)</code>, the log-density of latent space positions conditional on
latent space or cluster parameters and cluster assignments.</p>
</dd>
<dt><code>lpbeta</code></dt><dd><p><code class="reqn">\log p(\beta)</code>, the prior log-density of
the covariate coefficients.</p>
</dd>
<dt><code>lpRE</code></dt><dd><p><code class="reqn">\log p(\delta,\gamma|\sigma_\delta,\sigma_\gamma)</code>, the log-density of all random effects, conditional on
their respective variances.</p>
</dd>
<dt><code>lpLV</code></dt><dd><p><code class="reqn">\log p(\mu,\sigma)</code>, the prior log-density
of latent space or cluster parameters (but not that of the cluster
assignments).</p>
</dd>
<dt><code>lpREV</code></dt><dd><p><code class="reqn">\log p(\sigma_\delta,\sigma_\gamma)</code>, the prior log-density of all random effect variances.</p>
</dd>
<dt><code>Z.rate</code></dt><dd><p>Proportion of single-vertex proposals accepted over the preceding
interval.</p>
</dd>
<dt><code>beta.rate</code></dt><dd>
<p>Proportion of group proposals accepted over the preceding interval.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>
</p>

<hr>
<h2 id='ergmm.prior'>Auxiliary for Setting the ERGMM Prior</h2><span id='topic+ergmm.prior'></span>

<h3>Description</h3>

<p>Auxiliary function as user interface for <code><a href="#topic+ergmm">ergmm</a></code> prior
specification. Typically only used when calling <code><a href="#topic+ergmm">ergmm</a></code>. It is
used to supply the parameters of the prior distribution of the model, to
overwrite those specified in the model formula, and to supply miscellaneous
prior parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ergmm.prior(..., adjust.beta.var = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ergmm.prior_+3A_...">...</code></td>
<td>
<p>Prior distribution parameters. See term documentation and <code><a href="#topic+ergmm">ergmm()</a></code> for more
information.</p>
</td></tr>
<tr><td><code id="ergmm.prior_+3A_adjust.beta.var">adjust.beta.var</code></td>
<td>
<p>A shortcut: whether the prior variance for each
covariate coefficient should be divided by the mean square of that
covariate. This adjustment affects those variances specified in the formula
or by default, but not those specified through the <code>prior=</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the arguments as elements.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm()</a></code>, <code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code>
</p>

<hr>
<h2 id='euclidean-ergmTerm'>Euclidean distance latent space, with optional clustering</h2><span id='topic+euclidean-ergmTerm'></span><span id='topic+InitErgmTerm.euclidean'></span>

<h3>Description</h3>

<p>Adds a term to the model equal to the negative
Eucledean distance <code class="reqn">-||Z_i-Z_j||</code>, where
<code class="reqn">Z_i</code> and <code class="reqn">Z_j</code> are the positions of their
respective actors in an unobserved social space. These positions
may optionally have a finite spherical Gaussian mixture
clustering structure. This term was previously called
<code>latent</code>.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: euclidean(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)

# valued: euclidean(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean-ergmTerm_+3A_d">d</code></td>
<td>
<p>The dimension of the latent space.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_g">G</code></td>
<td>
<p>The number of groups (0 for no clustering).</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_var.mul">var.mul</code></td>
<td>
<p>In the absence of <code>var</code>, this argument will be
used as a scaling factor for a function of average cluster size
and latent space dimension to set <code>var</code>. To set it in the
<code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>Z.var.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_var">var</code></td>
<td>
<p>If given, the scale parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_var.df.mul">var.df.mul</code></td>
<td>
<p>In the absence of <code>var.df</code>, this argument is
the multiplier for the square root of average cluster size, which
serves in place of <code>var.df</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_mean.var.mul">mean.var.mul</code></td>
<td>
<p>In the absence of <code>mean.var</code>, the
multiplier for a function of number of vertices and latent space
dimension to set <code>mean.var</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_mean.var">mean.var</code></td>
<td>
<p>The variance of the spherical Gaussian prior
distribution of the cluster means. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_pk.mul">pK.mul</code></td>
<td>
<p>In the absence of <code>pK</code>, this argument is the
multiplier for the square root of the average cluster size, which
is used as <code>pK</code>. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
<tr><td><code id="euclidean-ergmTerm_+3A_pk">pK</code></td>
<td>
<p>The parameter of the Dirichilet prior distribution of
cluster assignment probabilities. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>Z</code></dt><dd><p> Numeric matrix with rows being latent space
positions.</p>
</dd>
<dt><code>Z.K</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Integer vector of
cluster assignments. </p>
</dd>
<dt><code>Z.mean</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric matrix
with rows being cluster means. </p>
</dd>
<dt><code>Z.var</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Depending on the
model, either a numeric vector with within-cluster variances
or a numeric scalar with the overal latent space variance. </p>
</dd>
<dt><code>Z.pK</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric vector of
probabilities of a vertex being in a particular cluster.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='euclidean2-ergmTerm'>Squared euclidean distance latent space, with optional clustering</h2><span id='topic+euclidean2-ergmTerm'></span><span id='topic+InitErgmTerm.euclidean2'></span>

<h3>Description</h3>

<p>Adds a term to the model equal to the negative
Eucledean distance <code class="reqn">-||Z_i-Z_j||^2</code>, where
<code class="reqn">Z_i</code> and <code class="reqn">Z_j</code> are the positions of their
respective actors in an unobserved social space. These positions
may optionally have a finite spherical Gaussian mixture
clustering structure. This term was previously called
<code>latent</code>.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: euclidean(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)

# valued: euclidean(d, G=0, var.mul=1/8, var=NULL, var.df.mul=1, var.df=NULL,
#             mean.var.mul=1, mean.var=NULL, pK.mul=1, pK=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euclidean2-ergmTerm_+3A_d">d</code></td>
<td>
<p>The dimension of the latent space.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_g">G</code></td>
<td>
<p>The number of groups (0 for no clustering).</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_var.mul">var.mul</code></td>
<td>
<p>In the absence of <code>var</code>, this argument will be
used as a scaling factor for a function of average cluster size
and latent space dimension to set <code>var</code>. To set it in the
<code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>Z.var.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_var">var</code></td>
<td>
<p>If given, the scale parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_var.df.mul">var.df.mul</code></td>
<td>
<p>In the absence of <code>var.df</code>, this argument is
the multiplier for the square root of average cluster size, which
serves in place of <code>var.df</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the
within-cluster variance. To set it in the <code>prior</code> argument
to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.var.df</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_mean.var.mul">mean.var.mul</code></td>
<td>
<p>In the absence of <code>mean.var</code>, the
multiplier for a function of number of vertices and latent space
dimension to set <code>mean.var</code>. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var.mul</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_mean.var">mean.var</code></td>
<td>
<p>The variance of the spherical Gaussian prior
distribution of the cluster means. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.mean.var</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_pk.mul">pK.mul</code></td>
<td>
<p>In the absence of <code>pK</code>, this argument is the
multiplier for the square root of the average cluster size, which
is used as <code>pK</code>. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
<tr><td><code id="euclidean2-ergmTerm_+3A_pk">pK</code></td>
<td>
<p>The parameter of the Dirichilet prior distribution of
cluster assignment probabilities. To set it in the <code>prior</code>
argument to <code><a href="#topic+ergmm">ergmm</a></code>, use <code>Z.pK</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>Z</code></dt><dd><p> Numeric matrix with rows being latent space
positions.</p>
</dd>
<dt><code>Z.K</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Integer vector of
cluster assignments. </p>
</dd>
<dt><code>Z.mean</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric matrix
with rows being cluster means. </p>
</dd>
<dt><code>Z.var</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Depending on the
model, either a numeric vector with within-cluster variances
or a numeric scalar with the overal latent space variance. </p>
</dd>
<dt><code>Z.pK</code> (when <code class="reqn">\code{G}&gt;0</code>)</dt><dd><p> Numeric vector of
probabilities of a vertex being in a particular cluster.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='gof.ergmm'>Conduct Goodness-of-Fit Diagnostics on a Exponential Family Random Graph
Mixed Model Fit</h2><span id='topic+gof.ergmm'></span><span id='topic+gof'></span>

<h3>Description</h3>

<p><code><a href="#topic+gof">gof</a></code> calculates <code class="reqn">p</code>-values for geodesic distance, degree,
and reachability summaries to diagnose the goodness-of-fit of exponential
family random graph mixed models.  See <code><a href="#topic+ergmm">ergmm</a></code> for more
information on these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
gof(
  object,
  ...,
  nsim = 100,
  GOF = ~idegree + odegree + distance,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof.ergmm_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+ergmm.object">ergmm</a></code> object (returned by
<code><a href="#topic+ergmm">ergmm</a></code>).</p>
</td></tr>
<tr><td><code id="gof.ergmm_+3A_...">...</code></td>
<td>
<p>Additional arguments, to be passed to lower-level functions in
the future.</p>
</td></tr>
<tr><td><code id="gof.ergmm_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations to use for the MCMC <code class="reqn">p</code>-values.
This is the size of the sample of graphs to be randomly drawn from the
distribution specified by the object on the set of all graphs.</p>
</td></tr>
<tr><td><code id="gof.ergmm_+3A_gof">GOF</code></td>
<td>
<p>formula; an formula object, of the form <code>~ &lt;model terms&gt;</code>
specifying the statistics to use to diagnosis the goodness-of-fit of the
model.  They do not need to be in the model formula specified in
<code>formula</code>, and typically are not.  Examples are the degree distribution
(&quot;degree&quot;), minimum geodesic distances (&quot;dist&quot;), and shared partner
distributions (&quot;espartners&quot; and &quot;dspartners&quot;).  For the details on the
possible <code>&lt;model terms&gt;</code>, see <code><a href="ergm.html#topic+ergm-terms">ergm-terms</a></code>.</p>
</td></tr>
<tr><td><code id="gof.ergmm_+3A_verbose">verbose</code></td>
<td>
<p>Provide verbose information on the progress of the
simulation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sample of graphs is randomly drawn from the posterior of the
<code><a href="#topic+ergmm">ergmm</a></code>.
</p>
<p>A plot of the summary measures is plotted.  More information can be found by
looking at the documentation of <code><a href="ergm.html#topic+ergm">ergm</a></code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+gof">gof</a></code> and <code><a href="#topic+gof.ergmm">gof.ergmm</a></code> return an object of
class <code>gof</code>.  This is a list of the tables of statistics and
<code class="reqn">p</code>-values.  This is typically plotted using
<code><a href="ergm.html#topic+plot.gof">plot.gof</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>, <code><a href="#topic+ergmm.object">ergmm (object)</a></code>,
<code><a href="ergm.html#topic+ergm">ergm</a></code>, <code>network</code>, <code><a href="#topic+simulate.ergmm">simulate.ergmm</a></code>,
<code><a href="ergm.html#topic+plot.gof">plot.gof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#
data(sampson)
#
# test the gof.ergm function
#
samplike.fit &lt;- ergmm(samplike ~ euclidean(d=2,G=3),
                      control=ergmm.control(burnin=1000,interval=5))
samplike.fit
summary(samplike.fit)

#
# Plot the probabilities first
#
monks.gof &lt;- gof(samplike.fit)
monks.gof
#
# Place all three on the same page
# with nice margins
#
par(mfrow=c(1,3))
par(oma=c(0.5,2,1,0.5))
#
plot(monks.gof)
#
# And now the odds 
#
plot(monks.gof, plotlogodds=TRUE)

</code></pre>

<hr>
<h2 id='Intercept-ergmTerm'>Intercept</h2><span id='topic+Intercept-ergmTerm'></span><span id='topic+InitErgmTerm.Intercept'></span><span id='topic+1-ergmTerm'></span><span id='topic+intercept-ergmTerm'></span>

<h3>Description</h3>

<p>This term serves as an intercept term, is included by
default (though, as in <code><a href="stats.html#topic+lm">lm</a></code>, it can be excluded by
adding <code>+0</code> or <code>-1</code> into the model formula). It adds
one covariate to the model, for which <code>x[i,j]=1</code> for all
<code>i</code> and <code>j</code>.
</p>
<p>It can be used explicitly to set prior mean and variance for the
intercept term.
</p>
<p>This term differs from the <code>ergm</code>'s
<code><a href="ergm.html#topic+edges-ergmTerm">edges-ergmTerm</a></code> term if the network has self-loops.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: 1(mean=0, var=9)

# binary: Intercept(mean=0, var=9)

# binary: intercept(mean=0, var=9)

# valued: 1(mean=0, var=9)

# valued: Intercept(mean=0, var=9)

# valued: intercept(mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Intercept-ergmTerm_+3A_mean">mean</code>, <code id="Intercept-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='latentcov-ergmTerm'>Edge covariates for the latent model</h2><span id='topic+latentcov-ergmTerm'></span><span id='topic+InitErgmTerm.latentcov'></span>

<h3>Description</h3>

<p>This term adds multiple covariates to the model, one
for each of (a subset of) the unique values of the
<code>attrname</code> attribute (or each combination of the attributes
given). Each of these covariates has <code>x[i,i]=1</code> if
<code>attrname(i)==l</code>, where <code>l</code> is that covariate's level,
and <code>x[i,j]=0</code> otherwise. To include all attribute values se
<code>base=0</code> &ndash; because the sum of all such statistics equals
twice the number of self-loops and hence a linear dependency
would arise in any model also including <code>loops</code>. Thus, the
<code>base</code> argument tells which value(s) (numbered in order
according to the <code>sort</code> function) should be omitted. The
default value, <code>base=1</code>, means that the smallest (i.e.,
first in sorted order) attribute value is omitted. For example,
if the &ldquo;fruit&rdquo; factor has levels &ldquo;orange&rdquo;,
&ldquo;apple&rdquo;, &ldquo;banana&rdquo;, and &ldquo;pear&rdquo;, then to add
just two terms, one for &ldquo;apple&rdquo; and one for &ldquo;pear&rdquo;,
then set &ldquo;banana&rdquo; and &ldquo;orange&rdquo; to the base
(remember to sort the values first) by using
<code>nodefactor("fruit", base=2:3)</code>. For an analogous term for
quantitative vertex attributes, see
<code>nodecov</code>.<code>attrname</code> is a character string giving the
name of a numeric (not categorical) attribute in the network's
vertex attribute list.  This term adds one covariate to the
model, for which <code>x[i,i]=attrname(i)</code> and <code>x[i,j]=0</code>
for <code>i!=j</code>.  This term only makes sense if the network has
self-loops.
</p>
<p><code>latentcov</code> can be called more than once, to model the
effects of multiple covariates. Note that some covariates can be
more conveniently specified using the following terms.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: latentcov(x, attrname=NULL, mean=0, var=9)

# valued: latentcov(x, attrname=NULL, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latentcov-ergmTerm_+3A_x">x</code></td>
<td>
<p>either a matrix of covariates on each pair of vertices, a
network, or an edge attribute.</p>
</td></tr>
<tr><td><code id="latentcov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>optional argument to provide the name of the edge attribute.</p>
</td></tr>
<tr><td><code id="latentcov-ergmTerm_+3A_mean">mean</code>, <code id="latentcov-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='loopcov-ergmTerm'>Covariate effect on self-loops</h2><span id='topic+loopcov-ergmTerm'></span><span id='topic+InitErgmTerm.loopcov'></span>

<h3>Description</h3>

<p>This term adds one covariate to the model, for which
<code>x[i,i]=attrname(i)</code> and <code>x[i,j]=0</code> for <code>i!=j</code>.
This term only makes sense if the network has self-loops.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: loopcov(attrname, mean=0, var=9)

# valued: loopcov(attrname, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopcov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character string giving the name of a numeric
(not categorical) attribute in the network's vertex attribute
list.</p>
</td></tr>
<tr><td><code id="loopcov-ergmTerm_+3A_mean">mean</code>, <code id="loopcov-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='loopfactor-ergmTerm'>Factor attribute effect on self-loops</h2><span id='topic+loopfactor-ergmTerm'></span><span id='topic+InitErgmTerm.loopfactor'></span>

<h3>Description</h3>

<p>This term adds multiple covariates to the model, one
for each of (a subset of) the unique values of the
<code>attrname</code> attribute (or each combination of the attributes
given). Each of these covariates has <code>x[i,i]=1</code> if
<code>attrname(i)==l</code>, where <code>l</code> is that covariate's level,
and <code>x[i,j]=0</code> otherwise. To include all attribute values se
<code>base=0</code> &ndash; because the sum of all such statistics equals
twice the number of self-loops and hence a linear dependency
would arise in any model also including <code>loops</code>. Thus, the
<code>base</code> argument tells which value(s) (numbered in order
according to the <code>sort</code> function) should be omitted. The
default value, <code>base=1</code>, means that the smallest (i.e.,
first in sorted order) attribute value is omitted. For example,
if the &ldquo;fruit&rdquo; factor has levels &ldquo;orange&rdquo;,
&ldquo;apple&rdquo;, &ldquo;banana&rdquo;, and &ldquo;pear&rdquo;, then to add
just two terms, one for &ldquo;apple&rdquo; and one for &ldquo;pear&rdquo;,
then set &ldquo;banana&rdquo; and &ldquo;orange&rdquo; to the base
(remember to sort the values first) by using
<code>nodefactor("fruit", base=2:3)</code>. For an analogous term for
quantitative vertex attributes, see
<code>nodecov</code>.<code>attrname</code> is a character string giving the
name of a numeric (not categorical) attribute in the network's
vertex attribute list.  This term adds one covariate to the
model, for which <code>x[i,i]=attrname(i)</code> and <code>x[i,j]=0</code>
for <code>i!=j</code>.  This term only makes sense if the network has
self-loops.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: loopfactor(attrname, mean=0, var=9)

# valued: loopfactor(attrname, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loopfactor-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character vector giving one or more names of
categorical attributes in the network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="loopfactor-ergmTerm_+3A_mean">mean</code>, <code id="loopfactor-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='loops-ergmTerm'>Self-loops</h2><span id='topic+loops-ergmTerm'></span><span id='topic+InitErgmTerm.loops'></span>

<h3>Description</h3>

<p>Effect of the dyad being a self-loop (i.e., <code class="reqn">(i,i)</code>).
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: loops(mean=0, var=9)

# valued: loops(mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loops-ergmTerm_+3A_mean">mean</code>, <code id="loops-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='mcmc.diagnostics.ergmm'>Conduct MCMC diagnostics on an ERGMM fit</h2><span id='topic+mcmc.diagnostics.ergmm'></span><span id='topic+mcmc.diagnostics'></span>

<h3>Description</h3>

<p>This function creates simple diagnostic plots for the MCMC sampled
statistics produced from a fit. It also prints the Raftery-Lewis
diagnostics, indicates if they are sufficient, and suggests the run length
required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
mcmc.diagnostics(
  object,
  which.diags = c("cor", "acf", "trace", "raftery"),
  burnin = FALSE,
  which.vars = NULL,
  vertex.i = c(1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+ergmm.object">ergmm</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_which.diags">which.diags</code></td>
<td>
<p>A list of diagnostics to produce. &quot;cor&quot; is the
correlation matrix of the statistics, &quot;acf&quot; plots the autocorrelation
functions, &quot;trace&quot; produces trace plots and density estimates, and &quot;raftery&quot;
produces the Raftery-Lewis statistics.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_burnin">burnin</code></td>
<td>
<p>If not <code>FALSE</code>, rather than perform diagnostics on the
sampling run, performs them on the pilot run whose index is given.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_which.vars">which.vars</code></td>
<td>
<p>A named list mapping variable names to the indices to
include. If given, overrides the defaults and all arguments that follow.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_vertex.i">vertex.i</code></td>
<td>
<p>A numeric vector of vertices whose latent space coordinates
and random effects to include.</p>
</td></tr>
<tr><td><code id="mcmc.diagnostics.ergmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. None are supported at the moment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Produces the plots per <code>which.diags</code>.  Autocorrelation function that is
printed if &quot;acf&quot; is requested is for lags <code>0</code> and <code>interval</code>.
</p>


<h3>Value</h3>

<p><code>mcmc.diagnostics.ergmm</code> returns a table of Raftery-Lewis
diagnostics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>, <code><a href="#topic+ergmm.object">ergmm.object</a></code>,
<code><a href="coda.html#topic+raftery.diag">raftery.diag</a></code>, <code><a href="coda.html#topic+autocorr">autocorr</a></code>,
<code><a href="coda.html#topic+plot.mcmc.list">plot.mcmc.list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#
data(sampson)
#
# test the mcmc.diagnostics function
#
gest &lt;- ergmm(samplike ~ euclidean(d=2),
              control=ergmm.control(burnin=1000,interval=5))
summary(gest)
#
# Plot the traces and densities
#
mcmc.diagnostics(gest)


</code></pre>

<hr>
<h2 id='merge.ergmm'>Merge two or more replications of ERGMM fits</h2><span id='topic+merge.ergmm'></span>

<h3>Description</h3>

<p>A <code><a href="base.html#topic+merge">merge</a></code> method for
<code><a href="#topic+ergmm.object">ergmm</a></code> objects, constructing an
<code><a href="#topic+ergmm.object">ergmm</a></code> object containing the combined MCMC
output (and derived estimates) of several
<code><a href="#topic+ergmm.object">ergmm</a></code> objects produced with the same
input parameters but different starting values, random seeds, etc..
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
merge(x, y, ..., verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.ergmm_+3A_x">x</code></td>
<td>
<p>The first <code><a href="#topic+ergmm.object">ergmm</a></code> object to be merged.</p>
</td></tr>
<tr><td><code id="merge.ergmm_+3A_y">y</code></td>
<td>
<p>The second <code><a href="#topic+ergmm.object">ergmm</a></code> object to be merged.</p>
</td></tr>
<tr><td><code id="merge.ergmm_+3A_...">...</code></td>
<td>
<p>Additional <code><a href="#topic+ergmm.object">ergmm</a></code> objects to be
merged.</p>
</td></tr>
<tr><td><code id="merge.ergmm_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, marks the progress of merging.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+ergmm.object">ergmm</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm.object">ergmm.object</a></code>, <code><a href="#topic+ergmm">ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(sampson)
# Run two short MCMC-based fits.
samp.fit1 &lt;- ergmm(samplike ~ euclidean(d=2, G=3),
  control=ergmm.control(burnin=1000,interval=10,sample.size=2000))
samp.fit2 &lt;- ergmm(samplike ~ euclidean(d=2, G=3),
  control=ergmm.control(burnin=1000,interval=10,sample.size=2000))

# Combine them, and summarize the result.
samp.fit &lt;-  merge(samp.fit1,samp.fit2)
summary(samp.fit)


</code></pre>

<hr>
<h2 id='plot.ergmm'>Plotting Method for class ERGMM</h2><span id='topic+plot.ergmm'></span><span id='topic+plot3d.ergmm'></span>

<h3>Description</h3>

<p><code><a href="#topic+plot.ergmm">plot.ergmm</a></code> is the plotting method for
<code><a href="#topic+ergmm.object">ergmm</a></code> objects.  For latent models, this plots
the minimum Kullback-Leibler positions by default.  The maximum likelihood,
posterior mean, posterior mode, or a particular iteration's or
configuration's positions can be used instead, or pie charts of the
posterior probabilities of cluster membership can be shown. See
<code><a href="#topic+ergmm">ergmm</a></code> for more information on how to fit these models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
plot(
  x,
  ...,
  vertex.cex = 1,
  vertex.sides = 16 * ceiling(sqrt(vertex.cex)),
  what = "mkl",
  main = NULL,
  xlab = NULL,
  ylab = NULL,
  zlab = NULL,
  xlim = NULL,
  ylim = NULL,
  zlim = NULL,
  object.scale = formals(plot.network.default)[["object.scale"]],
  pad = formals(plot.network.default)[["pad"]],
  cluster.col = c("red", "green", "blue", "cyan", "magenta", "orange", "yellow",
    "purple"),
  vertex.col = NULL,
  print.formula = TRUE,
  edge.col = 8,
  Z.ref = NULL,
  Z.K.ref = NULL,
  zoom.on = NULL,
  pie = FALSE,
  labels = FALSE,
  rand.eff = NULL,
  rand.eff.cap = NULL,
  plot.means = TRUE,
  plot.vars = TRUE,
  suppress.axes = FALSE,
  jitter1D = 1,
  curve1D = TRUE,
  use.rgl = FALSE,
  vertex.3d.cex = 1/20,
  edge.plot3d = TRUE,
  suppress.center = FALSE,
  density.par = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ergmm_+3A_x">x</code></td>
<td>
<p>an R object of class <code><a href="#topic+ergmm.object">ergmm</a></code>.  See
documentation for <code><a href="#topic+ergmm">ergmm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_...">...</code></td>
<td>
<p>Other optional arguments passed to the
<code><a href="network.html#topic+plot.network">plot.network</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_what">what</code></td>
<td>
<p>Character vector, integer, or a list that specifies the point
estimates to be used. Can be one of the follwoing:
</p>

<dl>
<dt><code>"mkl"</code></dt><dd><p>This is the defult. Plots the Minimum Kulblack-Leibler divergence values.</p>
</dd>
<dt><code>"start"</code>,<code>"burnin.start"</code></dt><dd><p>Plots the starting configuration.</p>
</dd>
<dt><code>"sampling.start"</code></dt><dd><p>Plots the starting configuration of the sampling phase (the last burnin configuration).</p>
</dd>
<dt><code>"mle"</code></dt><dd><p>Plots the maximum likelihood estimates. Random effects are treated as fixed.</p>
</dd>
<dt><code>"pmean"</code></dt><dd><p>Plots the posterior means.</p>
</dd>
<dt><code>"pmode"</code></dt><dd><p>Plots the conditional posterior mode.</p>
</dd>
<dt><code>"cloud"</code></dt><dd><p>Plots the &ldquo;cloud&rdquo; of latent space position draws,
with their cluster colors.</p>
</dd>
<dt><code>"density"</code></dt><dd><p>Plots density and contours of the posterior latent positions, and, in cluster models, each cluster.</p>
</dd>
<dt><code>list</code></dt><dd><p>Plots the
configuration contained in the list.</p>
</dd>
<dt>integer</dt><dd><p>Plots the configuration of <code>what</code>th MCMC draw stored in <code>x</code>.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_main">main</code>, <code id="plot.ergmm_+3A_vertex.cex">vertex.cex</code>, <code id="plot.ergmm_+3A_vertex.col">vertex.col</code>, <code id="plot.ergmm_+3A_xlim">xlim</code>, <code id="plot.ergmm_+3A_ylim">ylim</code>, <code id="plot.ergmm_+3A_vertex.sides">vertex.sides</code></td>
<td>
<p>Arguments passed
to <code><a href="network.html#topic+plot.network">plot.network</a></code>, whose defaults differ from those of
<code><a href="network.html#topic+plot.network">plot.network</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_zlim">zlim</code>, <code id="plot.ergmm_+3A_zlab">zlab</code></td>
<td>
<p>Limits and labels for the third latent space dimension or
principal component, if <code>use.rgl=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_object.scale">object.scale</code>, <code id="plot.ergmm_+3A_pad">pad</code>, <code id="plot.ergmm_+3A_edge.col">edge.col</code>, <code id="plot.ergmm_+3A_xlab">xlab</code>, <code id="plot.ergmm_+3A_ylab">ylab</code></td>
<td>
<p>Arguments passed to
<code><a href="network.html#topic+plot.network">plot.network</a></code>, whose defaults differ from those of
<code><a href="network.html#topic+plot.network">plot.network</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_cluster.col">cluster.col</code></td>
<td>
<p>A vector of colors used to distinguish clusters in a
latent cluster model.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_print.formula">print.formula</code></td>
<td>
<p>Whether the formula based on which the <code>x</code> was
fitted should be printed under the main title. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_z.ref">Z.ref</code></td>
<td>
<p>If given, rotates the the latent positions to the nearest
configuration to this one before plotting.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_z.k.ref">Z.K.ref</code></td>
<td>
<p>If given, relabels the clusters to the nearest configuration
to this one before plotting.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_zoom.on">zoom.on</code></td>
<td>
<p>If given a list of vertex indices, sets the plotting region
to the smallest that can fit those vertices.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_pie">pie</code></td>
<td>
<p>For latent clustering models, each node is drawn as a pie chart
representing the probabilities of cluster membership.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_labels">labels</code></td>
<td>
<p>Whether vertex labels should be displayed. Defaults to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_rand.eff">rand.eff</code></td>
<td>
<p>A character vector selecting &quot;sender&quot;, &quot;receiver&quot;,
&quot;sociality&quot;, or &quot;total&quot; random effects. Each vertex is scaled such that its
area is proportional to the odds ratio due to its selected random effect.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_rand.eff.cap">rand.eff.cap</code></td>
<td>
<p>If not <code>NULL</code> and <code>rand.eff</code> is given, limits
the scaling of the plotting symbol due to random effect to the given value.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_plot.means">plot.means</code></td>
<td>
<p>Whether cluster means are plotted for latent cluster
models. The &quot;+&quot; character is used. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_plot.vars">plot.vars</code></td>
<td>
<p>Whether circles with radius equal to the square root of
posterior latent or intracluster variance estimates are plotted. Defaults to
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_suppress.axes">suppress.axes</code></td>
<td>
<p>Whether axes should <em>not</em> be drawn. Defaults to
<code>FALSE</code>. (Axes are drawn.)</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_jitter1d">jitter1D</code></td>
<td>
<p>For 1D latent space fits, it often helps to jitter the
positions for visualization. This option controls the amount of jitter.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_curve1d">curve1D</code></td>
<td>
<p>Controls whether the edges in 1D latent space fits are
plotted as curves. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_use.rgl">use.rgl</code></td>
<td>
<p>Whether the package rgl should be used to plot fits for
latent space dimension 3 or higher in 3D. Defaults to <code>FALSE</code>. If set
to <code>TRUE</code>, argument <code>pie</code> has no effect.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_vertex.3d.cex">vertex.3d.cex</code></td>
<td>
<p>Controls the size of the plotting symbol when
<code>use.rgl=TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_edge.plot3d">edge.plot3d</code></td>
<td>
<p>If <code>TRUE</code> (the default) edges or arcs in a 3D plot
will be drawn. Otherwise, only vertices and clusters.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_suppress.center">suppress.center</code></td>
<td>
<p>Suppresses the plotting of &quot;+&quot; at the origin.
Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.ergmm_+3A_density.par">density.par</code></td>
<td>
<p>A list of optional parameters for density plots:
</p>

<dl>
<dt><code>totaldens</code></dt><dd><p>Whether the overal density of latent space positions should be plotted. Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>subdens</code></dt><dd><p>Whether the densities of latent space positions broken down by cluster should be plotted. Defaults to <code>TRUE</code>.</p>
</dd>
<dt><code>mfrow</code></dt><dd><p>When plotting multiple clusters' densities, passed to <code><a href="graphics.html#topic+par">par</a></code></p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>At this time, no plotting non-latent-space model fits is not supported.
</p>
<p>Plots the results of an ergmm fit.
</p>
<p>More information can be found by looking at the documentation of
<code><a href="#topic+ergmm">ergmm</a></code>.
</p>
<p>For bipartite networks, the events are marked with a bullet (small black
circle) inside the plotting symbol.
</p>


<h3>Value</h3>

<p>If applicable, invisibly returns the vertex positions plotted.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>,<code><a href="#topic+ergmm.object">ergmm.object</a></code>, <code>network</code>,
<code><a href="network.html#topic+plot.network">plot.network</a></code>, <code><a href="base.html#topic+plot">plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#
# Using Sampson's Monk data, let's fit a 
# simple latent position model
#
data(sampson)
#
# Using Sampson's Monk data, let's fit a
# latent clustering random effects model
# Store the burn-in.
samp.fit &lt;- ergmm(samplike ~ euclidean(d=2, G=3)+rreceiver,
                  control=ergmm.control(store.burnin=TRUE))
#
# See if we have convergence in the MCMC
mcmc.diagnostics(samp.fit)
# We can also plot the burn-in:
for(i in samp.fit$control$pilot.runs) mcmc.diagnostics(samp.fit,burnin=i)
#
# Plot the resulting fit.
#
plot(samp.fit,labels=TRUE,rand.eff="receiver")
plot(samp.fit,pie=TRUE,rand.eff="receiver")
plot(samp.fit,what="pmean",rand.eff="receiver")
plot(samp.fit,what="cloud",rand.eff="receiver")
plot(samp.fit,what="density",rand.eff="receiver")
plot(samp.fit,what=5,rand.eff="receiver")

## Not run: 
# Fit a 3D latent space model to Sampson's Monks
samp.fit3 &lt;- ergmm(samplike ~ euclidean(d=3))

# Plot the first two principal components of the
# latent space positions
plot(samp.fit,use.rgl=FALSE)
# Plot the resulting fit in 3D
plot(samp.fit,use.rgl=TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='predict.ergmm'>Predicted Dyad Values for an ERGMM.</h2><span id='topic+predict.ergmm'></span>

<h3>Description</h3>

<p>Returns a matrix of expected dyad values based on an ERGMM fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
predict(object, ..., type = "post")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.ergmm_+3A_object">object</code></td>
<td>
<p>An obejct of class <code><a href="#topic+ergmm.object">ergmm</a></code>.</p>
</td></tr>
<tr><td><code id="predict.ergmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently unused.</p>
</td></tr>
<tr><td><code id="predict.ergmm_+3A_type">type</code></td>
<td>
<p>One of &quot;mkl&quot;, &quot;start&quot;, &quot;mle&quot;, &quot;pmean&quot;, &quot;mkl&quot;, &quot;pmode&quot;, &quot;post&quot;,
an index of the iteration to use, or a list, for the configuration of
parameters based on which the prediction is made. An exception is &quot;post&quot;,
which computes the expected dyad values integrated over the posterior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A sociomatrix of predicted values. Note that predictions are made
for unobserved values (whether structural zeros or unobserved dyads).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm.object">ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(sampson)
monks.fit&lt;-ergmm(samplike~euclidean(d=2,G=3),tofit="mcmc")
heatmap(predict(monks.fit),Rowv=NA,Colv=NA)


</code></pre>

<hr>
<h2 id='receivercov-ergmTerm'>Receiver covariate effect</h2><span id='topic+receivercov-ergmTerm'></span><span id='topic+InitErgmTerm.receivercov'></span>

<h3>Description</h3>

<p><em>Deprecated for networks without self-loops. Use
<code><a href="ergm.html#topic+nodeicov-ergmTerm">nodeicov-ergmTerm</a></code>,
<code><a href="ergm.html#topic+nodeifactor-ergmTerm">nodeifactor-ergmTerm</a></code>,
<code><a href="ergm.html#topic+nodecov-ergmTerm">nodecov-ergmTerm</a></code> or
<code><a href="ergm.html#topic+nodefactor-ergmTerm">nodefactor-ergmTerm</a></code> instead.</em>
</p>
<p>If the attribute is numeric, this term adds one covariate to the
model equaling <code>attrname(i)</code>. If the attribute is not
numeric or <code>force.factor==TRUE</code>, this term adds <code class="reqn">p-1</code>
covariates to the model, where <code class="reqn">p</code> is the number of unique
values of <code>attrname</code>.  The <code class="reqn">k</code>th such covariate has the
value <code>attrname(i) == value(k+1)</code>, where <code>value(k)</code> is
the <code class="reqn">k</code>th smallest unique value of the <code>attrname</code>
attribute. This term only makes sense if the network is directed.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: receivercov(attrname, force.factor=FALSE, mean=0, var=9)

# valued: receivercov(attrname, force.factor=FALSE, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="receivercov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character string giving the name of an attribute
in the network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="receivercov-ergmTerm_+3A_force.factor">force.factor</code></td>
<td>
<p>logical, indicating if <code>attrname</code>'s value
should be interpreted as categorical even if numeric.</p>
</td></tr>
<tr><td><code id="receivercov-ergmTerm_+3A_mean">mean</code>, <code id="receivercov-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='rreceiver-ergmTerm'>Random receiver effect</h2><span id='topic+rreceiver-ergmTerm'></span><span id='topic+InitErgmTerm.rreceiver'></span>

<h3>Description</h3>

<p>Adds a random receiver effect to the model, with normal
prior centered around <code class="reqn">0</code> and a variance that is
estimated. Can only be used on directed networks.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: rreceiver(var=1, var.df=3)

# valued: rreceiver(var=1, var.df=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rreceiver-ergmTerm_+3A_var">var</code></td>
<td>
<p>The scale parameter for the scale-inverse-chi-squared
prior distribution of the receiver effect variance. To set
it in the <code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>receiver.var</code>.</p>
</td></tr>
<tr><td><code id="rreceiver-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the receiver effect
variance. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>receiver.var.df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>receiver</code></dt><dd><p> Numeric vector of values of each
vertex's random receiver effect.</p>
</dd>
<dt><code>receiver.var</code></dt><dd><p> Random receiver effect's variance.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='rsender-ergmTerm'>Random sender effect</h2><span id='topic+rsender-ergmTerm'></span><span id='topic+InitErgmTerm.rsender'></span>

<h3>Description</h3>

<p>Adds a random sender effect to the model, with normal
prior centered around <code class="reqn">0</code> and a variance that is
estimated. Can only be used on directed networks.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: rsender(var=1, var.df=3)

# valued: rsender(var=1, var.df=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsender-ergmTerm_+3A_var">var</code></td>
<td>
<p>The scale parameter for the scale-inverse-chi-squared
prior distribution of the sender effect variance. To set
it in the <code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>sender.var</code>.</p>
</td></tr>
<tr><td><code id="rsender-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the sender effect
variance. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>sender.var.df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>sender</code></dt><dd><p> Numeric vector of values of each
vertex's random sender effect.</p>
</dd>
<dt><code>sender.var</code></dt><dd><p> Random sender effect's variance.</p>
</dd>
</dl>



<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='rsociality-ergmTerm'>Random sociality effect</h2><span id='topic+rsociality-ergmTerm'></span><span id='topic+InitErgmTerm.rsociality'></span>

<h3>Description</h3>

<p>Adds a random sociality effect to the model, with normal
prior centered around <code class="reqn">0</code> and a variance that is
estimated. Can only be used on directed networks.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: rsociality(var=1, var.df=3)

# valued: rsociality(var=1, var.df=3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsociality-ergmTerm_+3A_var">var</code></td>
<td>
<p>The scale parameter for the scale-inverse-chi-squared
prior distribution of the sociality effect variance. To set
it in the <code>prior</code> argument to <code><a href="#topic+ergmm">ergmm</a></code>, use
<code>sociality.var</code>.</p>
</td></tr>
<tr><td><code id="rsociality-ergmTerm_+3A_var.df">var.df</code></td>
<td>
<p>The degrees of freedom parameter for the
scale-inverse-chi-squared prior distribution of the sociality effect
variance. To set it in the <code>prior</code> argument to
<code><a href="#topic+ergmm">ergmm</a></code>, use <code>sociality.var.df</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following parameters are associated with this term:
</p>

<dl>
<dt><code>sociality</code></dt><dd><p> Numeric vector of values of each
vertex's random sociality effect.</p>
</dd>
<dt><code>sociality.var</code></dt><dd><p> Random sociality effect's variance.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='sendercov-ergmTerm'>Sender covariate effect</h2><span id='topic+sendercov-ergmTerm'></span><span id='topic+InitErgmTerm.sendercov'></span>

<h3>Description</h3>

<p><em>Deprecated for networks without self-loops. Use
<code><a href="ergm.html#topic+nodeocov-ergmTerm">nodeocov-ergmTerm</a></code>,
<code><a href="ergm.html#topic+nodeofactor-ergmTerm">nodeofactor-ergmTerm</a></code>,
<code><a href="ergm.html#topic+nodecov-ergmTerm">nodecov-ergmTerm</a></code> or
<code><a href="ergm.html#topic+nodefactor-ergmTerm">nodefactor-ergmTerm</a></code> instead.</em>
</p>
<p>If the attribute is numeric, this term adds one covariate to the
model equaling <code>attrname(i)</code>. If the attribute is not
numeric or <code>force.factor==TRUE</code>, this term adds <code class="reqn">p-1</code>
covariates to the model, where <code class="reqn">p</code> is the number of unique
values of <code>attrname</code>.  The <code class="reqn">k</code>th such covariate has the
value <code>attrname(i) == value(k+1)</code>, where <code>value(k)</code> is
the <code class="reqn">k</code>th smallest unique value of the <code>attrname</code>
attribute. This term only makes sense if the network is directed.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: sendercov(attrname, force.factor=FALSE, mean=0, var=9)

# valued: sendercov(attrname, force.factor=FALSE, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sendercov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character string giving the name of an attribute
in the network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="sendercov-ergmTerm_+3A_force.factor">force.factor</code></td>
<td>
<p>logical, indicating if <code>attrname</code>'s value
should be interpreted as categorical even if numeric.</p>
</td></tr>
<tr><td><code id="sendercov-ergmTerm_+3A_mean">mean</code>, <code id="sendercov-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This term can only be used with directed networks.
</p>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='simulate.ergmm'>Draw from the distribution of an Exponential Random Graph Mixed Model</h2><span id='topic+simulate.ergmm'></span><span id='topic+simulate'></span><span id='topic+simulate.ergmm.model'></span>

<h3>Description</h3>

<p>If passed a <code><a href="#topic+ergmm.object">ergmm</a></code> fit object, <code>simulate</code>
is used to simulate networks from the posterior of an exponetial random
graph mixed model fit. Alternatively, a
<code>ergmm.model</code> can be passed to
simulate based on a particular parametr configuration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
simulate(object, nsim = 1, seed = NULL, ...)

## S3 method for class 'ergmm.model'
simulate(object, nsim = 1, seed = NULL, par, prior = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate.ergmm_+3A_object">object</code></td>
<td>
<p>either an object of class <code><a href="#topic+ergmm.object">ergmm</a></code>
for posterior simulation, or an object of class
<code>ergmm.model</code> for a specific model.</p>
</td></tr>
<tr><td><code id="simulate.ergmm_+3A_nsim">nsim</code></td>
<td>
<p>number of networks to draw (independently)</p>
</td></tr>
<tr><td><code id="simulate.ergmm_+3A_seed">seed</code></td>
<td>
<p>random seed to use; defaults to using the current state of the
random number generator</p>
</td></tr>
<tr><td><code id="simulate.ergmm_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently unused.</p>
</td></tr>
<tr><td><code id="simulate.ergmm_+3A_par">par</code></td>
<td>
<p>a list with the parameter configuration based on which to
simulate</p>
</td></tr>
<tr><td><code id="simulate.ergmm_+3A_prior">prior</code></td>
<td>
<p>a list with the prior distribution parameters that deviate from
their defaults</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A sample of networks is randomly drawn from the specified model. If a needed
value of <code>par</code> is missing, it is generated from its prior distribution.
</p>


<h3>Value</h3>

<p>If <code>nsim = 1</code>, <code>simulate</code> returns an object of class
<code><a href="network.html#topic+network">network</a></code>. Otherwise, an object of class
<code>network.series</code> that is a list consisting of the following elements:
</p>
<table>
<tr><td><code>$formula</code></td>
<td>
<p>The formula used to generate the sample.</p>
</td></tr>
<tr><td><code>$networks</code></td>
<td>
<p>A list of the generated networks.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm">ergmm</a></code>, <code> network</code>,
<code><a href="network.html#topic+print.network">print.network</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#
# Fit a short MCMC run: just the MCMC.
#
data(sampson)
gest &lt;- ergmm(samplike ~ euclidean(d=2,G=3),
              control=ergmm.control(burnin=100,interval=5,sample.size=100),tofit="mcmc")
#
# Draw from the posterior
#
g.sim &lt;- simulate(gest)
plot(g.sim)
#
# Draw from the first draw from the posterior
#
g.sim &lt;- with(gest,simulate(model,par=sample[[1]],prior=prior))
plot(g.sim)
</code></pre>

<hr>
<h2 id='socialitycov-ergmTerm'>Sociality covariate effect</h2><span id='topic+socialitycov-ergmTerm'></span><span id='topic+InitErgmTerm.socialitycov'></span>

<h3>Description</h3>

<p><em>Deprecated for networks without self-loops. Use
<code><a href="ergm.html#topic+nodecov-ergmTerm">nodecov-ergmTerm</a></code> or
<code><a href="ergm.html#topic+nodefactor-ergmTerm">nodefactor-ergmTerm</a></code> instead.</em>
</p>
<p>If the attribute is numeric, this term adds one covariate to the
model equaling <code>attrname(i)</code>. If the attribute is not
numeric or <code>force.factor==TRUE</code>, this term adds <code class="reqn">p-1</code>
covariates to the model, where <code class="reqn">p</code> is the number of unique
values of <code>attrname</code>.  The <code class="reqn">k</code>th such covariate has the
value <code>attrname(i) == value(k+1)</code>, where <code>value(k)</code> is
the <code class="reqn">k</code>th smallest unique value of the <code>attrname</code>
attribute. This term only makes sense if the network is directed.
</p>
<p><strong>Important:</strong> This term works in <a href="https://CRAN.R-project.org/package=latentnet"><span class="pkg">latentnet</span></a>'s <code><a href="#topic+ergmm">ergmm()</a></code> only. Using it in <code><a href="ergm.html#topic+ergm">ergm()</a></code> will result in an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># binary: socialitycov(attrname, force.factor=FALSE, mean=0, var=9)

# valued: socialitycov(attrname, force.factor=FALSE, mean=0, var=9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="socialitycov-ergmTerm_+3A_attrname">attrname</code></td>
<td>
<p>a character string giving the name of an attribute
in the network's vertex attribute list.</p>
</td></tr>
<tr><td><code id="socialitycov-ergmTerm_+3A_force.factor">force.factor</code></td>
<td>
<p>logical, indicating if <code>attrname</code>'s value
should be interpreted as categorical even if numeric.</p>
</td></tr>
<tr><td><code id="socialitycov-ergmTerm_+3A_mean">mean</code>, <code id="socialitycov-ergmTerm_+3A_var">var</code></td>
<td>
<p>prior mean and variance.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ergm.html#topic+ergmTerm">ergmTerm</a></code> for index of model terms currently visible to the package.
</p>


<h4>Keywords</h4>

<p>None</p>


<hr>
<h2 id='summary.ergmm'>ERGMM Fit Summaries</h2><span id='topic+summary.ergmm'></span><span id='topic+print.summary.ergmm'></span><span id='topic+summary.ergmm.object'></span><span id='topic+bic.ergmm'></span>

<h3>Description</h3>

<p><code>summary.ergmm</code> prodcues a summary of an
<code><a href="#topic+ergmm.object">ergmm</a></code> object, including point estimates,
standard errors, and BIC calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ergmm'
summary(
  object,
  point.est = c(if (!is.null(object[["mle"]])) "mle", if (!is.null(object[["sample"]]))
    c("pmean", "mkl")),
  quantiles = c(0.025, 0.975),
  se = "mle" %in% point.est,
  bic.eff.obs = c("ties", "dyads", "actors"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ergmm_+3A_object">object</code></td>
<td>
<p>An <code><a href="#topic+ergmm.object">ergmm</a></code> object to be summarized.</p>
</td></tr>
<tr><td><code id="summary.ergmm_+3A_point.est">point.est</code></td>
<td>
<p>Point estimates to compute: a character vector with some
subset of <code>"mle"</code>, <code>"pmean"</code>, <code>"mkl"</code>, and <code>"pmode"</code>.
Defaults to a concatenation of <code>"mle"</code> (if fit), <code>"pmean"</code>, and
<code>"mkl"</code> (if MCMC was run).</p>
</td></tr>
<tr><td><code id="summary.ergmm_+3A_quantiles">quantiles</code></td>
<td>
<p>Posterior quantiles (credible intervals) to compute.</p>
</td></tr>
<tr><td><code id="summary.ergmm_+3A_se">se</code></td>
<td>
<p>Whether to compute standard errors. Defaults to <code>TRUE</code> if MLE
was fit.</p>
</td></tr>
<tr><td><code id="summary.ergmm_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="summary.ergmm_+3A_eff.obs">eff.obs</code>, <code id="summary.ergmm_+3A_bic.eff.obs">bic.eff.obs</code></td>
<td>
<p>What effective sample size to use for BIC
calculation?
</p>

<dl>
<dt><code>"ties"</code></dt><dd><p>the number of non-missing ties in the network. This is the approach recommended by Handcock et al. (2007) and the default. Not well-defined for valued networks.</p>
</dd>
<dt><code>"dyads"</code></dt><dd><p>the number of non-missing dyads (potential ties) in the network.</p>
</dd>
<dt><code>"actors"</code></dt><dd><p>the number of actors in the network. The default prior to 2.7.0.</p>
</dd>
<dt>a number</dt><dd><p>to specify a specific sample size.</p>
</dd>
<dt><code>NULL</code></dt><dd><p>Don't compute the BIC at all. Mostly for internal use.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that BIC computed for the random effects models uses the same
formualtion as Handcock et al., so it is likely correct, but has not been
peer-reviewed.
</p>
<p>This BIC can be (reasonably) safely used to select the number of clusters or
which fixed effects to include in the model. It is not clear whether it is
appropriate to use this BIC to select the dimension of latent space and
whether or not to include random actor effects. These considerations are
independent of the bug described below.
</p>
<p>Prior to version 2.7.0, there was a bug in BIC calculation that used <code class="reqn">p
+ n(d+r+s)</code> as the number of parameters in the likelihood (where <code class="reqn">p</code> is
the number of fixed effects, <code class="reqn">n</code> the number of actors, <code class="reqn">d</code>, the
latent space dimension, and <code class="reqn">r</code> and <code class="reqn">s</code> indicators of presence of
sender and receiver (or sociality) effects). This value should have been
just <code class="reqn">p</code>.
</p>
<p>The following applications could have produced different results:
</p>

<ul>
<li><p>Using the BIC to select latent space dimension.
</p>
</li>
<li><p>Using the BIC to decide whether or not to include random effects.
</p>
</li></ul>

<p>The following applications could not (i.e., would be off by a constant):
</p>

<ul>
<li><p>Using the BIC to select the number of clusters.
</p>
</li>
<li><p>Using the BIC to select the fixed effects to be used.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>summary</code>, an object of class
<code><a href="#topic+summary.ergmm.object">summary.ergmm</a></code>. A print method is
available.
</p>
<p>The BICs are available as the element &quot;bic&quot; of the object returned.
</p>
<p><code>bic.ergmm</code> returns the BIC for the model directly.
</p>


<h3>References</h3>

<p>Chris Fraley and Adrian E. Raftery (2002). <em>Model-based
clustering, discriminant analysis, and density estimation</em>. Journal of the
American Statistical Association, 97(458), 611-631.
</p>
<p>Mark S. Handcock, Adrian E. Raftery and Jeremy Tantrum (2007).
<em>Model-Based Clustering for Social Networks</em>.  Journal of the Royal
Statistical Society: Series A (Statistics in Society), 170(2), 301-354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ergmm.object">ergmm.object</a></code>, <code><a href="#topic+ergmm">ergmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(sampson)
# Fit the model for cluster sizes 1 through 4:
fits&lt;-list(
           ergmm(samplike~euclidean(d=2,G=1)),
           ergmm(samplike~euclidean(d=2,G=2)),
           ergmm(samplike~euclidean(d=2,G=3)),
           ergmm(samplike~euclidean(d=2,G=4))
           )

## Not run: 
# Optionally, plot all fits.
lapply(fits,plot)

## End(Not run)

# Compute the BICs for the fits and plot them:
(bics&lt;-reshape(
    as.data.frame(t(sapply(fits,
                           function(x)c(G=x$model$G,unlist(bic.ergmm(x))[c("Y","Z","overall")])))),
    list(c("Y","Z","overall")),idvar="G",v.names="BIC",timevar="Component",
    times=c("likelihood","clustering","overall"),direction="long"
    ))

with(bics,interaction.plot(G,Component,BIC,type="b",xlab="Clusters", ylab="BIC"))

# Summarize and plot whichever fit has the lowest overall BIC:
bestG&lt;-with(bics[bics$Component=="overall",],G[which.min(BIC)])
summary(fits[[bestG]])
plot(fits[[bestG]])


</code></pre>

<hr>
<h2 id='tribes'>Read Highland Tribes</h2><span id='topic+tribes'></span>

<h3>Description</h3>

<p>A network of political alliances and enmities among the 16 Gahuku-Gama
sub-tribes of Eastern Central Highlands of New Guinea, documented by Read
(1954).
</p>


<h3>Format</h3>

<p>An undirected <code><a href="network.html#topic+network">network</a></code> object with no loops, having the following attributes:
</p>

<dl>
<dt><code>%v% "vertex.names"</code></dt><dd><p>Character attribute with names of tribes.</p>
</dd>
<dt><code>%e% "pos"</code></dt><dd><p>Logical attribute indicating an
alliance relationship.</p>
</dd>
<dt><code>%e% "neg"</code></dt><dd><p>Logical attribute indicating a hostile
relationship (&quot;rova&quot;).</p>
</dd>
<dt><code>%e% "sign"</code></dt><dd><p>Numeric attribute coding -1 for enmity, 0
for no relationship, and 1 for alliance.</p>
</dd>
<dt><code>%e% "sign.012"</code></dt><dd><p>Numeric attribute coding 0 for enmity, 1
for no relationship, and 2 for alliance.</p>
</dd>
</dl>

<p>Because of limitations of <code><a href="network.html#topic+network">network</a></code> objects, the object
itself is a complete graph, and is thus meaningless if used directly
or plotted.
</p>


<h3>Details</h3>

<p>This network shows 3 clusters.
</p>


<h3>Source</h3>

<p><a href="http://vlado.fmf.uni-lj.si/pub/networks/data/UciNet/UciData.htm#gama">http://vlado.fmf.uni-lj.si/pub/networks/data/UciNet/UciData.htm#gama</a>,
with corrections from Read (1954).
</p>


<h3>References</h3>

<p>Taken from UCINET IV, which cites the following: Hage P. and
Harary F. (1983). Structural models in anthropology. Cambridge: Cambridge
University Press. (See p 56-60).  Read K. (1954). Cultures of the central
highlands, New Guinea. Southwestern Journal of Anthropology, 10, 1-43.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(tribes)
# Only model positive ties:
tribes.fit&lt;-ergmm(tribes~euclidean(d=2,G=3),response="pos")
# Edge color must be set manually, for green ties to represent alliance
# and for red ties to represent enmity.
plot(tribes.fit,edge.col=as.matrix(tribes,"pos",m="a")*3+as.matrix(tribes,"neg",m="a")*2,pie=TRUE)
# Model both positive and negative ties:
tribes.fit3&lt;-ergmm(tribes~euclidean(d=2,G=3),response="sign.012",
                   family="binomial.logit",fam.par=list(trials=2))
# Edge color must be set manually, for green ties to represent alliance
# and for red ties to represent enmity.
plot(tribes.fit3,edge.col=as.matrix(tribes,"pos",m="a")*3+as.matrix(tribes,"neg",m="a")*2,pie=TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
