<!DOCTYPE html><html><head><title>Help for package TCIU</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TCIU}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#fmri_2dvisual'><p>visualization of the 2D brain (axial, sagittal and coronal) with the activated areas</p></a></li>
<li><a href='#fmri_3dvisual'><p>visualization of the 3D brain with the activated areas</p></a></li>
<li><a href='#fmri_3dvisual_region'><p>visualization of the 3D brain with the activated areas by regions</p></a></li>
<li><a href='#fmri_image'><p>interactive graph object of the fMRI image</p></a></li>
<li><a href='#fmri_kimesurface'><p>interactive graph object of 3D kime-series</p></a></li>
<li><a href='#fmri_post_hoc'><p>post-hoc process for p values</p></a></li>
<li><a href='#fmri_pval_comparison_2d'><p>2D comparison visualization between the p-values</p></a></li>
<li><a href='#fmri_pval_comparison_3d'><p>comparison between 3d visualization for p-values</p></a></li>
<li><a href='#fmri_ROI_phase1'><p>p-values on region of interest(ROI) of the brain</p></a></li>
<li><a href='#fmri_ROI_phase2'><p>tensor-on-tensor regression on region of interest(ROI) of the brain</p></a></li>
<li><a href='#fmri_simulate_func'><p>real-valued fMRI data simulation</p></a></li>
<li><a href='#fmri_stimulus_detect'><p>fMRI data stimulus detection</p></a></li>
<li><a href='#fmri_time_series'><p>visualization of the fMRI data (real, imaginary, magnitude, and phase parts) in time series</p></a></li>
<li><a href='#fmri_ts_forecast'><p>forecast the fMRI data based on the time series</p></a></li>
<li><a href='#GaussSmoothArray'><p>GaussSmoothArray</p></a></li>
<li><a href='#GaussSmoothKernel'><p>GaussSmoothKernel</p></a></li>
<li><a href='#ILT'><p>numerical method to compute inverse of Laplace Transform</p></a></li>
<li><a href='#inv_kimesurface_transform'><p>inverse kimesurface transform on a function in different periodic ranges</p></a></li>
<li><a href='#kimesurface_transform'><p>kimesurface transform on a function with a specified set of complex values</p></a></li>
<li><a href='#LT'><p>numerical method to compute Laplace Transform</p></a></li>
<li><a href='#mask'><p>mask</p></a></li>
<li><a href='#mask_dict'><p>mask_dict</p></a></li>
<li><a href='#mask_label'><p>mask_label</p></a></li>
<li><a href='#phase1_pval'><p>phase1_pval</p></a></li>
<li><a href='#phase2_pval'><p>phase2_pval</p></a></li>
<li><a href='#phase3_pval'><p>phase3_pval</p></a></li>
<li><a href='#sample_save'><p>sample_save</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Spacekime Analytics, Time Complexity and Inferential Uncertainty</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.6</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/SOCR/TCIU">https://github.com/SOCR/TCIU</a>,
<a href="https://www.socr.umich.edu/spacekime/">https://www.socr.umich.edu/spacekime/</a>,
<a href="https://www.socr.umich.edu/TCIU/">https://www.socr.umich.edu/TCIU/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SOCR/TCIU/issues">https://github.com/SOCR/TCIU/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Provide the core functionality to transform longitudinal data to
    complex-time (kime) data using analytic and numerical techniques, visualize the original 
    time-series and reconstructed kime-surfaces, perform model based (e.g., tensor-linear regression)
    and model-free classification and clustering methods in the book Dinov, ID and Velev, MV. (2021)
    "Data Science: Time Complexity, Inferential Uncertainty, and Spacekime Analytics", De Gruyter STEM Series,
    ISBN 978-3-11-069780-3. <a href="https://www.degruyter.com/view/title/576646">https://www.degruyter.com/view/title/576646</a>.
    The package includes 18 core functions which can be separated into three groups.
    1) draw longitudinal data, such as Functional magnetic resonance imaging(fMRI) time-series, and forecast or transform the time-series data.
    2) simulate real-valued time-series data, e.g., fMRI time-courses, detect the activated areas,
    report the corresponding p-values, and visualize the p-values in the 3D brain space.
    3) Laplace transform and kimesurface reconstructions of the fMRI data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, ggplot2, dplyr, tidyr, RColorBrewer, fancycut, scales,
plotly, gridExtra, ggpubr, ICSNP, rrcov, geometry, DT,
forecast, fmri, pracma, zoo, extraDistr, parallel, foreach,
spatstat.explore, spatstat.geom, cubature, doParallel,
reshape2, MultiwayRegression, interp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>oro.nifti, magrittr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-17 19:24:36 UTC; petersyy</td>
</tr>
<tr>
<td>Author:</td>
<td>Yongkai Qiu [aut],
  Zhe Yin [aut],
  Jinwen Cao [aut],
  Yupeng Zhang [aut],
  Yuyao Liu [aut],
  Rongqian Zhang [aut],
  Yueyang Shen [aut, cre],
  Rouben Rostamian [ctb],
  Ranjan Maitra [ctb],
  Daniel Rowe [ctb],
  Daniel Adrian [ctb] (gLRT method for complex-valued fMRI statistics),
  Yunjie Guo [aut],
  Ivo Dinov [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yueyang Shen &lt;petersyy@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-17 23:40:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='fmri_2dvisual'>visualization of the 2D brain (axial, sagittal and coronal) with the activated areas</h2><span id='topic+fmri_2dvisual'></span>

<h3>Description</h3>

<p>a visualization method, using <code>ggplot2</code> to draw the brain 
from axial, sagittal and coronal view with activated area identified by p-values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_2dvisual(
  pval,
  axis_ls,
  hemody_data = NULL,
  mask,
  p_threshold = 0.05,
  legend_show = TRUE,
  method = "scale_p",
  color_pal = "YlOrRd",
  multi_pranges = TRUE,
  mask_width = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_2dvisual_+3A_pval">pval</code></td>
<td>
<p>a 3D array of p-values used to plot activated area of the brain</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_axis_ls">axis_ls</code></td>
<td>
<p>a list with two elements. The first element is the character of 'x', 'y', 'z'.
The second element is an integer showing a specific slice on the fixed axis identified in the first element.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_hemody_data">hemody_data</code></td>
<td>
<p>a parameter to have the plot with/without hemodynamic contour. The default is NULL to make the plot 
without hemodynamic contour, otherwise assign a 3D array of the hemodynamic data.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_mask">mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to show the shell of the brain</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that can be selected randomly below 0.05 to 
drop all p-values above the threshold. If 'low5_percent' method is used, 
make 'p_threshold' as NULL. The default is 0.05.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_legend_show">legend_show</code></td>
<td>
<p>a logical parameter to specify whether the final plot has legend</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_method">method</code></td>
<td>
<p>a string that represents method for the plot. 
There are 3 options: 'min_max', 'scale_p' and 'low5_percent'. The default is 'scale_p'.
'min_max' is to draw plot based on the color scale of the minimum and maximum of the p value; 
'scale_p' is to draw the plot with fixed color scale for fixed range of p value; 
'low5_percent' is to draw the plot for the smallest 5 percent of p value when all the p values are not significant.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_color_pal">color_pal</code></td>
<td>
<p>the name of the color palettes provided by <code>RColorBrewer</code>. The default is &quot;YlOrRd&quot;.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_multi_pranges">multi_pranges</code></td>
<td>
<p>an option under 'scale_p' method to decide whether there are at most 9 colors 
in the legend for the ranges of p value, or at most 4 colors. 
The default is TRUE, choosing the larger number of colors for the plot.</p>
</td></tr>
<tr><td><code id="fmri_2dvisual_+3A_mask_width">mask_width</code></td>
<td>
<p>a numeric value to specify the width of mask contour. The default is 1.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_2dvisual</code> is used to find activated part of the brain 
based on given p values from sagittal, axial and coronal view. When providing input of 
the p-values, the specific plane and index to slice on, the mask data and 
the hemodynamic data of the brain, a plot will be generated with the heat map 
for the activated parts, the black contour showing the position of the brain, 
and the blue contour representing the hemodynamic contour.
</p>


<h3>Value</h3>

<p>a plot drawn by <code>ggplot2</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D data of mask provided by the package
dim(mask)
# sample 3D p value provided by the package
dim(phase2_pval)

# plot the sagittal, coronal and axial view of this p value generated from the brain fMRI data

fmri_2dvisual(phase2_pval, list('x',40), hemody_data=NULL, mask=mask, p_threshold=0.05)


</code></pre>

<hr>
<h2 id='fmri_3dvisual'>visualization of the 3D brain with the activated areas</h2><span id='topic+fmri_3dvisual'></span>

<h3>Description</h3>

<p>a visualization method, using <code>plotly</code> to draw the 3D plot of the brain 
with the activated areas determined by p-values, which is generated from fMRI data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_3dvisual(
  pval,
  mask,
  p_threshold = 0.05,
  method = "scale_p",
  color_pal = "YlOrRd",
  multi_pranges = TRUE,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_3dvisual_+3A_pval">pval</code></td>
<td>
<p>a 3D array of p-values used to plot activated area of the brain</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_mask">mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to show the shell of the brain</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that can be selected randomly below 0.05 to 
drop all p-values above the threshold. If 'low5_percent' method is used, 
make 'p_threshold' as NULL. The default is 0.05.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_method">method</code></td>
<td>
<p>a string that represents method for the plot.
There are 2 options: 'scale_p' and 'low5_percent'. The default is 'scale_p'. 
'scale_p' is to draw the plot with fixed color scale for fixed range of p value.
'low5_percent' is to draw the plot for the smallest 5 percent of p value when all the p values are not significant.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_color_pal">color_pal</code></td>
<td>
<p>the name of the color palettes provided by <code>RColorBrewer</code>. The default is &quot;YlOrRd&quot;.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_multi_pranges">multi_pranges</code></td>
<td>
<p>an option under 'scale_p' method to decide whether there are at most 9 colors 
in the legend for the ranges of p value, or at most 4 colors. 
The default is TRUE, choosing the larger number of colors for the plot.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_+3A_title">title</code></td>
<td>
<p>the title of the plot. The default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_3dvisual</code> is used to visualize the 3D plot of the brain 
with its activated parts based on provided p values. The p values are generated by
applying statistical test on fMRI data. When providing input of a 3D p-values data, 
a 3D interactive plot will be generated with surface for the brain shell 
and scatter points in different colors and size representing different stimulated levels.
</p>


<h3>Value</h3>

<p>a list of two elements
</p>

<ul>
<li><p> plot - the 3d plot of the fMRI data drawn by <code>plotly</code>
</p>
</li>
<li><p> pval_df - data.frame with the p value for each voxel and the specified color for it
</p>
</li></ul>



<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D data of mask provided by the package
dim(mask)
# sample 3D p value provided by the package
dim(phase2_pval)

# make the 3D plot
fmri_3dvisual(phase2_pval, mask, p_threshold = 0.05, method="scale_p")$plot

</code></pre>

<hr>
<h2 id='fmri_3dvisual_region'>visualization of the 3D brain with the activated areas by regions</h2><span id='topic+fmri_3dvisual_region'></span>

<h3>Description</h3>

<p>an improved visualization method of <code>fmri_3dvisual</code>, using <code>plotly</code> to 
draw the 3D plot of the brain with the activated areas region by region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_3dvisual_region(
  pval,
  mask,
  label_index,
  label_name,
  top_num = NULL,
  p_threshold = 0.05,
  method = "scale_p",
  multi_pranges = TRUE,
  color_pal = "YlOrRd",
  rank = NULL,
  title = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_3dvisual_region_+3A_pval">pval</code></td>
<td>
<p>a 3D or 1D or a list of two 3D array of p-values used to plot activated area of the brain</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_mask">mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to show the regions of the brain</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_label_index">label_index</code></td>
<td>
<p>a 1D array listing  the label number in the mask</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_label_name">label_name</code></td>
<td>
<p>a 1D array corresponding to the name of the label number in the mask</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_top_num">top_num</code></td>
<td>
<p>NULL or a numeric value that used for 1D p-values. If specified, the output will 
show the top num significant regions. The default is NULL.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that used for 3D p-values can be selected randomly below 0.05 to 
drop all p-values above the threshold. If 'low5_percent' method is used, 
make 'p_threshold' as NULL. The default is 0.05.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_method">method</code></td>
<td>
<p>a string that represents method for the 3D p-values plot.
There are 2 options: 'scale_p' and 'low5_percent'. The default is 'scale_p'. 
'scale_p' is to draw the plot with fixed color scale for fixed range of p value.
'low5_percent' is to draw the plot for the smallest 5 percent of p value when all the p values are not significant.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_multi_pranges">multi_pranges</code></td>
<td>
<p>an option under 'scale_p' method to decide whether there are at most 9 colors 
in the legend for the ranges of 3D p-values, or at most 4 colors. 
The default is TRUE, choosing the larger number of colors for the plot.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_color_pal">color_pal</code></td>
<td>
<p>the name of the color palettes provided by <code>RColorBrewer</code>. The default is &quot;YlOrRd&quot;.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_rank">rank</code></td>
<td>
<p>the method that how the trace is ranked. The default is NULL.
There are 2 options: 'value' and a vector.
'value' is to draw the 1D p-values by the values from smallest to largest.
a vector is to specific the rank of the regions in 3D p-values plot.</p>
</td></tr>
<tr><td><code id="fmri_3dvisual_region_+3A_title">title</code></td>
<td>
<p>the title of the plot. The default is NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_3dvisual_region</code> is used to visualize the 3D plot of the brain 
with activated parts region by region. When providing a 1D/3D p-values data, a 3D interactive
plot with surface of the brain shell will be generated with either scatter points representing 
different stimulated levels or large color pieces representing different regions of the brain. 
When providing a list of two 3D array of p-values, two 3D interactive brains with different scatter
points corresponding to the two input 3D p-values will be given.
</p>


<h3>Value</h3>

<p>the 3d plot of the fMRI data drawn by <code>plotly</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample label vector provided in the package
label_index = mask_dict$index
label_name = as.character(mask_dict$name)
label_mask = mask_label

fmri_3dvisual_region(phase1_pval, label_mask, label_index,
                     label_name, title = "phase1 p-values")
fmri_3dvisual_region(phase1_pval, label_mask, label_index,
                     label_name, 5, title = "phase1 top five p-values", rank = "value")

# for 3D visualization, user needs to include empty region in the label
label_index = c(0, label_index)
label_name = c("empty", label_name)
fmri_3dvisual_region(phase2_pval, label_mask, label_index,
                     label_name, title = "phase2 p-values", rank = c(1:length(label_name)))
fmri_3dvisual_region(list(phase2_pval,phase3_pval), label_mask, label_index,
                     label_name, title = "phase2&amp;3 p-values")

</code></pre>

<hr>
<h2 id='fmri_image'>interactive graph object of the fMRI image</h2><span id='topic+fmri_image'></span>

<h3>Description</h3>

<p>fMRI image visualization method, based on package <code>plotly</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_image(fmridata, option = "manually", voxel_location = NULL, time = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_image_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4D array contains information for the fMRI spacetime image. The data should only contain the magnitude for the fMRI image.</p>
</td></tr>
<tr><td><code id="fmri_image_+3A_option">option</code></td>
<td>
<p>The default is 'manually'. If choose 'auto', then this function will lead you to key in the space (x,y,z) parameters and time (time) parameter for this function to generate graphs.</p>
</td></tr>
<tr><td><code id="fmri_image_+3A_voxel_location">voxel_location</code></td>
<td>
<p>a 3D array indicating the spatial location of the brain. If option is auto, set the voxel_location as NULL.</p>
</td></tr>
<tr><td><code id="fmri_image_+3A_time">time</code></td>
<td>
<p>time location for the voxel</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_image</code> is used to create images for front view, side view, and top view of the fMRI image.
When providing the 4D array of the fMRI spacetime image and input the x,y,z position of the voxel, 
three views of the fMRI image and the time series image of the voxel will be shown.
</p>


<h3>Value</h3>

<p>an interactive graph object of the fMRI image created by <code>plotly</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask)
fmri_image(fmri_generate$fmri_data, option='manually', voxel_location = c(40,22,33), time = 4)

</code></pre>

<hr>
<h2 id='fmri_kimesurface'>interactive graph object of 3D kime-series</h2><span id='topic+fmri_kimesurface'></span>

<h3>Description</h3>

<p>Use <code>plotly</code> to display in 3D the kime-series as 2D manifolds (kimesurface) over the cartesian domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_kimesurface(fmridata, voxel_location = NULL, is.4d = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_kimesurface_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4d array which contains the spatial and temporal record of fMRI result or a single real valued vector.</p>
</td></tr>
<tr><td><code id="fmri_kimesurface_+3A_voxel_location">voxel_location</code></td>
<td>
<p>a 3d array indicating the spatial location of the brain.</p>
</td></tr>
<tr><td><code id="fmri_kimesurface_+3A_is.4d">is.4d</code></td>
<td>
<p>The default is true. If change to false, need to input a vector instead of array.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_kimesurface</code> is display in 3D the kime-series as 2D manifolds (kimesurface) over the Cartesian domain. It helps transform the fMRI time-series data at a fixed voxel location into a kimesurface (kime-series). User can choose to provide the 4D array of the fMRI spacetime image and the voxel_location or a single time-series vector, then a 3D visualization will be shown.
</p>


<h3>Value</h3>

<p>an interactive plot in 3D kimesurface
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample fMRI time-series vector of a single voxel
sample_voxel = sample_save[[9]]
## Not run: 
fmri_kimesurface(sample_voxel, is.4d = FALSE)[[1]]
fmri_kimesurface(sample_voxel, is.4d = FALSE)[[2]]
fmri_kimesurface(sample_voxel, is.4d = FALSE)[[3]]
fmri_kimesurface(sample_voxel, is.4d = FALSE)[[4]]

## End(Not run)
</code></pre>

<hr>
<h2 id='fmri_post_hoc'>post-hoc process for p values</h2><span id='topic+fmri_post_hoc'></span>

<h3>Description</h3>

<p>This function is used to conduct the post-hoc process (i.e. FDR correction and spatial clustering) for a 3-dimensional p-value array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_post_hoc(
  p_val_3d,
  fdr_corr = NULL,
  spatial_cluster.thr = NULL,
  spatial_cluster.size = NULL,
  show_comparison = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_post_hoc_+3A_p_val_3d">p_val_3d</code></td>
<td>
<p>an array which contains the p-values as the result of fMRI statistical tests.</p>
</td></tr>
<tr><td><code id="fmri_post_hoc_+3A_fdr_corr">fdr_corr</code></td>
<td>
<p>The default is NULL. Input 'fdr' to conduct FDR correction.</p>
</td></tr>
<tr><td><code id="fmri_post_hoc_+3A_spatial_cluster.thr">spatial_cluster.thr</code></td>
<td>
<p>The default is NULL. Together with spatial_cluster.size are used to filter contiguous clusters of locations in a 3D array that are below some threshold and with some minimum size.</p>
</td></tr>
<tr><td><code id="fmri_post_hoc_+3A_spatial_cluster.size">spatial_cluster.size</code></td>
<td>
<p>The default is NULL. The size of spatial cluster.</p>
</td></tr>
<tr><td><code id="fmri_post_hoc_+3A_show_comparison">show_comparison</code></td>
<td>
<p>The default is FALSE. If TRUE, the output would display the comparison between raw and processed p-values.</p>
</td></tr>
<tr><td><code id="fmri_post_hoc_+3A_...">...</code></td>
<td>
<p>One can specify breaks etc. to modify the comparison histogram in ggplot2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_post_hoc</code> would help do the FDR correction and spatial clustering for a 3d p-value array. The FDR correction controls for a low proportion of false positives, while the spatial clustering part help filter out all sparse p-values that are not in specified clusters.
</p>


<h3>Value</h3>

<p>3D p-values after FDR correction or spatial clustering
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D p value provided by the package
dim(phase2_pval)

# do the FDR correction
pval_fdr = fmri_post_hoc(phase2_pval, 
                         fdr_corr = 'fdr',
                         spatial_cluster.thr = NULL,
                         spatial_cluster.size = NULL, 
                         show_comparison = FALSE)

# do the spatial clustering
pval_posthoc = fmri_post_hoc(pval_fdr,
                             fdr_corr = NULL,
                             spatial_cluster.thr = 0.05,
                             spatial_cluster.size = 5, 
                             show_comparison = FALSE)

</code></pre>

<hr>
<h2 id='fmri_pval_comparison_2d'>2D comparison visualization between the p-values</h2><span id='topic+fmri_pval_comparison_2d'></span>

<h3>Description</h3>

<p>a plot arrangement method, which uses <code>gridExtra</code> to combine multiple 
2D plots of the fMRI data together. This can bring convenience for users to compare 
the result of different statistical tests based on the p values they provide
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_pval_comparison_2d(
  pval_ls,
  pval_name_ls,
  axis_i_lses,
  hemody_data = NULL,
  mask,
  p_threshold = 0.05,
  legend_show = TRUE,
  method = "scale_p",
  color_pal = "YlOrRd",
  multi_pranges = TRUE,
  mask_width = 1.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_pval_comparison_2d_+3A_pval_ls">pval_ls</code></td>
<td>
<p>a list. Each element is a 3D array of p-values data</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_pval_name_ls">pval_name_ls</code></td>
<td>
<p>a list with the element as name for the p-values data provided in 'pval_ls'</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_axis_i_lses">axis_i_lses</code></td>
<td>
<p>a list with 3 numeric elements or a list of lists. If the elements are numeric, 
they would specify indices of slice for the three direction. 
If any direction of the slice need not to be shown, make it as NULL for that element. 
If elements are lists, each list provides specified cuts for corresponding 3D p-values data.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_hemody_data">hemody_data</code></td>
<td>
<p>a parameter to have the plot with/without hemodynamic contour. The default is NULL to make the plot 
without hemodynamic contour, otherwise assign a 3D array of the hemodynamic data.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_mask">mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to show the shell of the brain</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that can be selected randomly below 0.05 to 
drop all p-values above the threshold. If 'low5_percent' method is used, 
make 'p_threshold' as NULL. The default is 0.05.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_legend_show">legend_show</code></td>
<td>
<p>a logical parameter to specify whether the final plot has legend
for all the subplots or the shared legend for all the subplots. The default is TRUE.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_method">method</code></td>
<td>
<p>a string that represents method for the plot. 
There are 3 options: 'min_max', 'scale_p' and 'low5_percent'. The default is 'scale_p'. 
'min_max' is to draw plot based on the color scale of the minimum and maximum of the p-values; 
'scale_p' is to draw the plot with fixed color scale for fixed range of p-values; 
'low5_percent' is to draw the plot for the smallest 5 percent of p-values
when all the p-values are not significant</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_color_pal">color_pal</code></td>
<td>
<p>the name of the color palettes provided by <code>RColorBrewer</code> The default is &quot;YlOrRd&quot;.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_multi_pranges">multi_pranges</code></td>
<td>
<p>an option under 'scale_p' method to decide whether there are at most 9 colors 
in the legend for the ranges of p-values, or at most 4 colors. 
The default is TRUE, choosing the larger number of colors for the plot.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_2d_+3A_mask_width">mask_width</code></td>
<td>
<p>a numeric value to specify the width of mask contour. The default is 1.5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_pval_comparison_2d</code> is used to combine and compare the 2D plots for different 3D arrays of p-values.
The plots in each row are generated by one specific 3D p value data. 
The first column of the integrated plot specifies the name of the 3D p value data (for generation of 
the plots in that row). The rest of the three columns are the plots from sagittal, coronal and 
axial view for each 3D p value data.
</p>


<h3>Value</h3>

<p>a combination plot arranged by <code>gridExtra</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D data of mask provided by the package
dim(mask)
# sample 3D p value provided by the package
dim(phase2_pval)
dim(phase3_pval)


fmri_pval_comparison_2d(list(phase2_pval, phase3_pval), 
                        list('phase2_pval', 'phase3_pval'),
                        list(list(40, 26, 33), list(40, 26, 33)), 
                        hemody_data = NULL, 
                        mask = mask, p_threshold = 0.05, 
                        legend_show = FALSE, method = 'scale_p',
                        color_pal = "YlOrRd", multi_pranges=TRUE)
                  
</code></pre>

<hr>
<h2 id='fmri_pval_comparison_3d'>comparison between 3d visualization for p-values</h2><span id='topic+fmri_pval_comparison_3d'></span>

<h3>Description</h3>

<p>a visualization method, use <code>plotly</code> to compare 
the activated parts inside the brain, using two sets of color palettes. 
The activated parts are localized with different p values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_pval_comparison_3d(
  pval_3d_ls,
  mask,
  p_threshold,
  method_ls,
  color_pal_ls = list("YlOrRd", "YlGnBu"),
  multi_pranges = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_pval_comparison_3d_+3A_pval_3d_ls">pval_3d_ls</code></td>
<td>
<p>a list of two element, each element is a 3D array of p-values used to plot activated area of the brain</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_3d_+3A_mask">mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to show the shell of the brain</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_3d_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that can be selected randomly below 0.05 to 
drop insignificant p-values of no need or drop no p-values. If 'low5_percent' method is used, 
make 'p_threshold' as NULL. The default is 0.05.</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_3d_+3A_method_ls">method_ls</code></td>
<td>
<p>a string that represents method for the plot. 
There are 2 options: 'scale_p' and 'low5_percent'. The default is 'scale_p'. 
'scale_p' is to draw the plot with fixed color scale for fixed range of p value; 
'low5_percent' is to draw the plot for the smallest 5 percent of p value 
when all the p values are not significant</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_3d_+3A_color_pal_ls">color_pal_ls</code></td>
<td>
<p>a list of two element. Each element is the name of 
the color palettes provided by <code>RColorBrewer</code>. The default is list('YlOrRd', 'YlGnBu').</p>
</td></tr>
<tr><td><code id="fmri_pval_comparison_3d_+3A_multi_pranges">multi_pranges</code></td>
<td>
<p>an option under 'scale_p' method to decide whether there are at most 9 colors 
in the legend for the ranges of p value, or at most 4 colors. 
The default is TRUE, choosing the larger number of colors for the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_pval_comparison_3d</code> is used to visualize and compare the 3D plots of 
the activated parts in one brain shell. The activated parts are plotted 
based on p-values provided. Note that this comparison can only be made when the masks 
of the two p values are the same. When providing input of two set of the 3D array of p-values, 
corresponding p threshold for each p value data, and the method to draw the plot, 
the plot will be generated with one brain shell and two groups of activated parts 
in two sets of color palettes. The size and color of the scatter points represent 
different stimulated levels of the activated parts.
</p>


<h3>Value</h3>

<p>a plot drawn by <code>plotly</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D data of mask provided by the package
dim(mask)
# sample 3D p value provided by the package
dim(phase2_pval)
dim(phase3_pval)

fmri_pval_comparison_3d(list(phase2_pval, phase3_pval), mask, 
                        list(0.05, 0.05), list('scale_p', 'scale_p'), multi_pranges=FALSE)
</code></pre>

<hr>
<h2 id='fmri_ROI_phase1'>p-values on region of interest(ROI) of the brain</h2><span id='topic+fmri_ROI_phase1'></span>

<h3>Description</h3>

<p>This function takes a 4 dimensional real-valued fMRI data and calculates p-values for the ROIs individually to test whether the ROI is potentially activated.
It is the first phase of a ROI 3-phase analysis and usually followed by second phase analysis <code>fmri_ROI_phase2</code> .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_ROI_phase1(
  fmridata,
  label_mask = NULL,
  label_dict = NULL,
  stimulus_idx = NULL,
  rest_idx = NULL,
  p_threshold = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_ROI_phase1_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4d array which contains the spatial and temporal record of fmri data</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase1_+3A_label_mask">label_mask</code></td>
<td>
<p>a 3D nifti or 3D array of data to indicates the corresponding indices of the ROIs</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase1_+3A_label_dict">label_dict</code></td>
<td>
<p>a dataframe which contains the name of ROIs and their corresponding index</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase1_+3A_stimulus_idx">stimulus_idx</code></td>
<td>
<p>a vector that specifies when motion happens</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase1_+3A_rest_idx">rest_idx</code></td>
<td>
<p>a vector that specifies when study participant does not move</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase1_+3A_p_threshold">p_threshold</code></td>
<td>
<p>NULL or a numeric value that can be selected randomly below 0.05 to drop all p-values above the threshold.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_ROI_phase1</code> is used to calculate p-values of ROIs for a given real-valued fmridata. It first takes in the fmridata and corresponding mask. 
For a fixed region, the function will first compute Temporal Contrast-to-noise Ratio (tCNR) for each voxel in that region, which is the mean of 80 paired differences in intensity for &quot;on&quot; and &quot;off&quot; states divided by its standard deviation. Second, it will conduct t-test on all tCNRs of a fixed region to see there are significant changes for the ROI during the on and off period. Finally, it will use bonferroni correction to control significant level and select the ROIs with p-values under the significant level to enter next phase analysis.
</p>


<h3>Value</h3>

<p>a list of two elements
</p>

<ul>
<li><p> all_ROI - the test result for all ROIs
</p>
</li>
<li><p> sign_ROI - the test result for significant ROIs
</p>
</li></ul>



<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask)
# p-values for phase 1

result = fmri_ROI_phase1(fmri_generate$fmri_data, mask_label,
                          mask_dict, stimulus_idx = fmri_generate$on_time)

</code></pre>

<hr>
<h2 id='fmri_ROI_phase2'>tensor-on-tensor regression on region of interest(ROI) of the brain</h2><span id='topic+fmri_ROI_phase2'></span>

<h3>Description</h3>

<p>This function takes a 4d fMRI data and detects locations where stimulus occurs
on each region of interest(ROI) of the brain using <code>MultiwayRegression</code>. This function could be used as
an intermediate step of a three-phase analytics protocol to detect motor areas. The functions to implement this 
three-phase protocol in a consecutive order is <code>fmri_ROI_phase2</code>, <code>fmri_ROI_phase3</code> and <code>fmri_post_hoc</code> respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_ROI_phase2(
  fmridata,
  label_mask,
  label_dict,
  stimulus_idx,
  stimulus_dur,
  fmri.design_order = 2,
  fmri.stimulus_TR = 3,
  rrr_rank = 3,
  method = "t_test",
  parallel_computing = FALSE,
  ncor = max(detectCores() - 2, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_ROI_phase2_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4d array which contains the spatial and temporal record of fmri result.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_label_mask">label_mask</code></td>
<td>
<p>a 3d nifti or 3d array of data that shows the labeled brain atlas.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_label_dict">label_dict</code></td>
<td>
<p>a dataframe or array or matrix to specify the indices and corresponding
names of the ROI. The input of this parameter could take one of the list outputs of the <code>fmri_ROI_phase2</code> function as a following step.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_stimulus_idx">stimulus_idx</code></td>
<td>
<p>a vector of the start time points of the time period when the fMRI data receives stimulation.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_stimulus_dur">stimulus_dur</code></td>
<td>
<p>a vector of the time period when the fMRI data receives stimulation.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_fmri.design_order">fmri.design_order</code></td>
<td>
<p>a parameter to specify the order of the polynomial drift terms in <code>fmri.design</code> function.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_fmri.stimulus_tr">fmri.stimulus_TR</code></td>
<td>
<p>a parameter to specify the time between scans in seconds in <code>fmri.stimulus</code> function.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_rrr_rank">rrr_rank</code></td>
<td>
<p>a parameter to specify the assumed rank of the coefficient array in <code>rrr</code> function.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_method">method</code></td>
<td>
<p>a string that represents method for calculating p-values from tensor-on-tensor regression coefficients. 
There are 2 options: 't_test' and 'corrected_t_test'. The default is 't_test'.
't_test' is to calculate the test statistics 't-value' across all voxels in the bounding box of ROI; 
'corrected_t_test' is to calculate the test statistics 't-value' by first across each voxel on a temporal basis,
and then across all voxels in the bounding box of ROI.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_parallel_computing">parallel_computing</code></td>
<td>
<p>a logical parameter to determine whether to use parallel computing to speed up the function or not.
The default is FALSE.</p>
</td></tr>
<tr><td><code id="fmri_ROI_phase2_+3A_ncor">ncor</code></td>
<td>
<p>number of cores for parallel computing. The default is the number of cores of the computer minus 2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_ROI_phase2</code> is used to detect locations where stimulus occurs by calculating the p-values
of the ROI-based tensor-on-tensor regression. Two methods can be chosen to calculate the p-values from the regression coefficients.
</p>


<h3>Value</h3>

<p>a 3d array storing ROI-based tensor regression p-values for the 4d fMRI data
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# sample 3D data of labeled brain atlas provided by the package
# this example will use parallel computing and take about ten minutes to finish
dim(mask_label)
# sample dataframe of ROI-based indices and names provided by the package
dim(mask_dict)
# sample 3D data of mask provided by the package
dim(mask)

# calculated p-values 
set.seed(1)
fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask)
fmridata = fmri_generate$fmri_data
stimulus_idx = fmri_generate$ons
stimulus_dur = fmri_generate$dur
# the function will may take a long time, see examples in demo function or vignettes       


</code></pre>

<hr>
<h2 id='fmri_simulate_func'>real-valued fMRI data simulation</h2><span id='topic+fmri_simulate_func'></span>

<h3>Description</h3>

<p>a real-valued fMRI data simulation function, used to simply generate a 3D fMRI data associated with brain area with activated parts inside.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_simulate_func(
  dim_data,
  mask = NULL,
  ons = c(1, 21, 41, 61, 81, 101, 121, 141),
  dur = c(10, 10, 10, 10, 10, 10, 10, 10)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_simulate_func_+3A_dim_data">dim_data</code></td>
<td>
<p>a vector of length 3 to identify the dimension of fMRI data user wants to simulate</p>
</td></tr>
<tr><td><code id="fmri_simulate_func_+3A_mask">mask</code></td>
<td>
<p>a 3D array of 1’s and 0’s or NULL. To specify the area inside the brain shell.
One may use the mask data provided by this package, or generate a 3D array of 1’s and 0’s of the same dimension with the fMRI data to be generated.
If NULL, then the function would generate a 3D sphere mask.</p>
</td></tr>
<tr><td><code id="fmri_simulate_func_+3A_ons">ons</code></td>
<td>
<p>a vector of the start time points of the time period when the fMRI data receives stimulation</p>
</td></tr>
<tr><td><code id="fmri_simulate_func_+3A_dur">dur</code></td>
<td>
<p>a vector of the time period when the fMRI data receives stimulation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_simulate_func</code> is used to simulate fMRI data with specified dimension and total time points. 
The fMRI data can be brain-shaped by using the mask data provided in our package, if the dimension fits the same as our data (c(64, 64. 40)).
Otherwise, the function will generate a 3D sphere data with multiple activated part inside. The activated parts can be detected based on the p values.
</p>


<h3>Value</h3>

<p>an array with the specified dimension
</p>
<p>a list of four elements
</p>

<ul>
<li><p> fmri_data - the fMRI data generated by the function as specialized values.
</p>
</li>
<li><p> mask - mask of the fMRI data.
</p>
</li>
<li><p> ons - a vector of the start time points of the time period when the fMRI data receives stimulation.
</p>
</li>
<li><p> dur - a vector of the time period when the fMRI data receives stimulation. Notice that the length of ons 
is equal to the length of dur, and all the time period when the data does not receive the simulations have the same 
duration as its former 'on' time period.
</p>
</li>
<li><p> on_time - a vector that specifies when motion happens.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># sample 3D data of mask provided by the package
dim(mask)

# the input dimension is the dimension we want for our simulated fMRI data
fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask, 
                                   ons = c(1, 21, 41, 61, 81, 101, 121, 141), 
                                   dur = c(10, 10, 10, 10, 10, 10, 10, 10))

</code></pre>

<hr>
<h2 id='fmri_stimulus_detect'>fMRI data stimulus detection</h2><span id='topic+fmri_stimulus_detect'></span>

<h3>Description</h3>

<p>This function takes a real/complex valued fMRI data and detects locations where stimulus occurs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_stimulus_detect(
  fmridata,
  mask = NULL,
  stimulus_idx = NULL,
  rest_idex = NULL,
  method,
  fdr_corr = NULL,
  spatial_cluster.thr = NULL,
  spatial_cluster.size = NULL,
  ons = NULL,
  dur = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_stimulus_detect_+3A_fmridata">fmridata</code></td>
<td>
<p>an array or a vector which contains the spatial and/or temporal record of fMRI result</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_mask">mask</code></td>
<td>
<p>a 3d array indicating the spatial location of the brain</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_stimulus_idx">stimulus_idx</code></td>
<td>
<p>a vector that specifies when motion happens</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_rest_idex">rest_idex</code></td>
<td>
<p>a vector that specifies when study participant does not move</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_method">method</code></td>
<td>
<p>a string that indicates which testing method is to be used. There are 5 options: 'HotellingT2', 'Wilks-Lambda' and 'gLRT'(likelihood ratio test) for complex fMRI data and 't-test', 'wilcoxon-test' for real fMRI data. For 4D real-valued fMRI data, two more options: 'on_off_diff' and 'HRF' method can be applied.</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_fdr_corr">fdr_corr</code></td>
<td>
<p>a logical variable. True if FDR correction is to be applied</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_spatial_cluster.thr">spatial_cluster.thr</code></td>
<td>
<p>threshold p-value to be used for spatial clustering</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_spatial_cluster.size">spatial_cluster.size</code></td>
<td>
<p>number of spatially connected voxels to be tested for spatial clustering</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_ons">ons</code></td>
<td>
<p>a vector with the first time points of the time periods when the fMRI data receives stimulation. The default is NULL. Need to specify when choose the method 'gLRT' or 'HRF'.</p>
</td></tr>
<tr><td><code id="fmri_stimulus_detect_+3A_dur">dur</code></td>
<td>
<p>a vector of the time length of each stimulated period. The default is NULL. Need to specify when choose the method 'gLRT' or 'HRF'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_stimulus_detect</code> is used to conduct motor area detection. It first takes in a real or complex valued fMRI data, and then users can choose to use various methods to find the spatial regions where motor area is located inside the brain. User can either input the 4d fMRI data and get a 3d array storing p-values or input the fMRI data with smaller dimension (e.g. fix the x,y axis) and get a vector storing p-values. Besides, one can use this function to just calculate raw p-values, and we also provide options so that users can do FDR correction and spatial clustering to get a more accurate result.
</p>


<h3>Value</h3>

<p>If input fMRI data is 4d, return a 3d array storing p-values for the 4d fMRI data. If input fMRI data is less than 4d, return a vector storing p-values for the fMRI data.
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask)
fmridata = fmri_generate$fmri_data
stimulus_idx = fmri_generate$on_time
ons = fmri_generate$ons
dur = fmri_generate$dur


# p-values using t-test for 4d fMRI data
p_value1 = fmri_stimulus_detect(fmridata = fmridata, mask = mask,
                                stimulus_idx = stimulus_idx,
                                method = 't-test')
dim(fmridata)
dim(p_value1)

# p-values using t-test for 2d fMRI data
p_value2 = fmri_stimulus_detect(fmridata = fmridata[40,41,,], mask = mask,
                                stimulus_idx = stimulus_idx,
                                method = 't-test')
dim(fmridata[40,41,,])
dim(p_value2)


</code></pre>

<hr>
<h2 id='fmri_time_series'>visualization of the fMRI data (real, imaginary, magnitude, and phase parts) in time series</h2><span id='topic+fmri_time_series'></span>

<h3>Description</h3>

<p>a visualization method, use <code>plotly</code> to draw the fMRI data in time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_time_series(fmridata, voxel_location, is.4d = TRUE, ref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_time_series_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4d array which contains the spatial and temporal record of fMRI result or a single complex valued vector</p>
</td></tr>
<tr><td><code id="fmri_time_series_+3A_voxel_location">voxel_location</code></td>
<td>
<p>a 3d array indicating the spatial location of the brain. If is.4d is false, set the voxel_location as NULL.</p>
</td></tr>
<tr><td><code id="fmri_time_series_+3A_is.4d">is.4d</code></td>
<td>
<p>The default is TRUE. If change to false, input a vector instead of a 4d array.</p>
</td></tr>
<tr><td><code id="fmri_time_series_+3A_ref">ref</code></td>
<td>
<p>The default is NULL. User can input an outside extra reference <code>plotly</code> object to include in the final result.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_time_series</code> is used to create four interactive time series graphs for the real, imaginary, magnitude, and phase parts for the fMRI spacetime data.
User can choose to provide the 4d array of the fMRI spacetime image and the voxel_location or a single complex valued vector, then four interactive time series graphs will be shown. 
Besides, the reference <code>plotly</code> object can be added to the final result.
</p>


<h3>Value</h3>

<p>an interactive time series graph object created by <code>plotly</code>
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load sample time-series data of one voxel in the brain provided by the package
sample_voxel = sample_save[[9]]
reference_plot = sample_save[[8]]
fmri_time_series(sample_voxel, voxel_location = NULL, is.4d = FALSE, ref = reference_plot)

</code></pre>

<hr>
<h2 id='fmri_ts_forecast'>forecast the fMRI data based on the time series</h2><span id='topic+fmri_ts_forecast'></span>

<h3>Description</h3>

<p>a function to forecast the fMRI data based on the time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fmri_ts_forecast(fmridata, voxel_location, cut = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fmri_ts_forecast_+3A_fmridata">fmridata</code></td>
<td>
<p>a 4D array contains information for the fMRI spacetime image. The data should only contain the magnitude for the fMRI image.</p>
</td></tr>
<tr><td><code id="fmri_ts_forecast_+3A_voxel_location">voxel_location</code></td>
<td>
<p>a 3d array indicating the voxel location of the brain</p>
</td></tr>
<tr><td><code id="fmri_ts_forecast_+3A_cut">cut</code></td>
<td>
<p>breaking point of the time-series data. The default is 10.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>fmri_ts_forecast</code> is used to forecast with time series. It will fit the best ARIMA model to univariate time series from the input fMRI data.
</p>


<h3>Value</h3>

<p>a figure forecasting the fMRI voxel with time series
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fmri_generate = fmri_simulate_func(dim_data = c(64, 64, 40), mask = mask)

smoothmod &lt;- GaussSmoothArray(fmri_generate$fmri_data, sigma = diag(3,3))
fmri_ts_forecast(smoothmod,c(41,44,33))

</code></pre>

<hr>
<h2 id='GaussSmoothArray'>GaussSmoothArray</h2><span id='topic+GaussSmoothArray'></span>

<h3>Description</h3>

<p>An internal function named GaussSmoothArray. Original from AnalyzeFMRI package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSmoothArray(
  x,
  voxdim = c(1, 1, 1),
  ksize = 5,
  sigma = diag(3, 3),
  mask = NULL,
  var.norm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSmoothArray_+3A_x">x</code></td>
<td>
<p>The array to be smoothed.</p>
</td></tr>
<tr><td><code id="GaussSmoothArray_+3A_voxdim">voxdim</code></td>
<td>
<p>The dimensions of the volume elements (voxel) that make up the array.</p>
</td></tr>
<tr><td><code id="GaussSmoothArray_+3A_ksize">ksize</code></td>
<td>
<p>The dimensions (in number of voxels) of the 3D discrete smoothing kernel used to smooth the array.</p>
</td></tr>
<tr><td><code id="GaussSmoothArray_+3A_sigma">sigma</code></td>
<td>
<p>The covariance matrix of the 3D Gaussian smoothing kernel. This matrix doesn't have to be non-singular; zero on the diagonal of sigma indicate no smoothing in that direction.</p>
</td></tr>
<tr><td><code id="GaussSmoothArray_+3A_mask">mask</code></td>
<td>
<p>A 3D 0-1 mask that delimits where the smoothing occurs.</p>
</td></tr>
<tr><td><code id="GaussSmoothArray_+3A_var.norm">var.norm</code></td>
<td>
<p>Logical flag indicating whether to normalize the variance of the smoothed array.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array with the size of parameter x
</p>

<hr>
<h2 id='GaussSmoothKernel'>GaussSmoothKernel</h2><span id='topic+GaussSmoothKernel'></span>

<h3>Description</h3>

<p>An internal function named GaussSmoothKernel. Original from AnalyzeFMRI package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSmoothKernel(voxdim = c(1, 1, 1), ksize = 5, sigma = diag(3, 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSmoothKernel_+3A_voxdim">voxdim</code></td>
<td>
<p>Dimensions of each voxel.</p>
</td></tr>
<tr><td><code id="GaussSmoothKernel_+3A_ksize">ksize</code></td>
<td>
<p>Dimensions of the discrete kernel size.</p>
</td></tr>
<tr><td><code id="GaussSmoothKernel_+3A_sigma">sigma</code></td>
<td>
<p>The covariance matrix of the Gaussian kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a 3 dimensional array with size = (ksize, ksize, ksize)
</p>

<hr>
<h2 id='ILT'>numerical method to compute inverse of Laplace Transform</h2><span id='topic+ILT'></span>

<h3>Description</h3>

<p>a function that numerically computes the inverse of Laplace Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ILT(
  FUNCT,
  t,
  nterms = 31L,
  m = 1,
  gamma = 0.5,
  fail_val = complex(0),
  msg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ILT_+3A_funct">FUNCT</code></td>
<td>
<p>function object F(z), typically a Laplace Transform of a function f(t)</p>
</td></tr>
<tr><td><code id="ILT_+3A_t">t</code></td>
<td>
<p>time domain value to evaluate the ILT(F)(t)</p>
</td></tr>
<tr><td><code id="ILT_+3A_nterms">nterms</code></td>
<td>
<p>number of terms to use in the numerical inversion (odd number). The default is 31L.</p>
</td></tr>
<tr><td><code id="ILT_+3A_m">m</code></td>
<td>
<p>width of the contour path in C; too small values may lead to singularities on the negative x-axis; 
too large valued may lead to numerical instability for large positive x-axis. The default is 1.</p>
</td></tr>
<tr><td><code id="ILT_+3A_gamma">gamma</code></td>
<td>
<p>value on the positive x-axis for the vertical line representing the contour. The default is 0.5</p>
</td></tr>
<tr><td><code id="ILT_+3A_fail_val">fail_val</code></td>
<td>
<p>value to return in event of failure to converge</p>
</td></tr>
<tr><td><code id="ILT_+3A_msg">msg</code></td>
<td>
<p>Boolean to show/hide warnings. The default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first uses full optimum contour path to do inverse Laplace Transform.
However, if this method fails, the function will automatically change to the method 
of using Bromwich contour path to do inverse Laplace Transform
</p>


<h3>Value</h3>

<p>a real value computed from inverse Laplace Transform
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># analytic form of Laplace transform of f(t) = t
F = function(z) { 1/(z^2) }
# do inverse Laplace transform on t = 0.2
ILT(F, t = 0.2)
# the result is equal to t = 0.2
</code></pre>

<hr>
<h2 id='inv_kimesurface_transform'>inverse kimesurface transform on a function in different periodic ranges</h2><span id='topic+inv_kimesurface_transform'></span>

<h3>Description</h3>

<p>This function applies the inverse kimesurface transform to convert a kimesurface-transformed function back
to get the original 1D function in [0, 2*pi] or other similar periodic time range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_kimesurface_transform(
  time_points,
  array_2d,
  num_length = 20,
  m = 1,
  msg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_kimesurface_transform_+3A_time_points">time_points</code></td>
<td>
<p>a sequence of points in [0, 2*pi] or other periodic range</p>
</td></tr>
<tr><td><code id="inv_kimesurface_transform_+3A_array_2d">array_2d</code></td>
<td>
<p>2D array, got from the kimesurface_transform</p>
</td></tr>
<tr><td><code id="inv_kimesurface_transform_+3A_num_length">num_length</code></td>
<td>
<p>integer, interpolate f(t) to num_length samples in [0 : 2*pi] to extend the plot</p>
</td></tr>
<tr><td><code id="inv_kimesurface_transform_+3A_m">m</code></td>
<td>
<p>width of the contour path in C; too small values may lead to singularities on the negative x-axis; 
too large valued may lead to numerical instability for large positive x-axis. The default is 1.</p>
</td></tr>
<tr><td><code id="inv_kimesurface_transform_+3A_msg">msg</code></td>
<td>
<p>Boolean to show/hide warnings. The default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two elements
</p>

<ul>
<li><p> Smooth_Reconstruction - the smoothed data computed from inverse kimesurface transform, 
with the same length of time_points
</p>
</li>
<li><p> Raw_Reconstruction - the original unsmoothed data computed from inverse kimesurface transform, 
with the same length of time_points
</p>
</li></ul>



<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(reshape2)
require(ggplot2)

# drop the first row and first column because of divergence on Laplace Transform
x = seq(0, 2, length.out=50)[2:50]; y = seq(0, 2, length.out=50)[2:50];
# do kimesurface transform on sine function
z2_grid = kimesurface_transform(FUNCT = function(t) { sin(t) },
                                real_x = x, img_y = y)
                                
time_points = seq(0+0.001, 2*pi, length.out = 160)
inv_data = inv_kimesurface_transform(time_points, z2_grid)
time_Intensities_ILT_df2 &lt;- as.data.frame(cbind(Re=scale(Re(inv_data$Smooth_Reconstruction)), 
                                                Im=scale(Re(inv_data$Raw_Reconstruction)),
                                                fMRI=scale(Re(sin(time_points))),
                                                time_points=time_points))
colnames(time_Intensities_ILT_df2) = c("Smooth Reconstruction", 
                                       "Raw Reconstruction", 
                                       "Original sin()",
                                       "time_points")
df = reshape2::melt(time_Intensities_ILT_df2, id.var = "time_points")
ggplot(df, aes(x = time_points, y = value, colour = variable)) + 
       geom_line(linetype=1, lwd=3) +
       ylab("Function Intensity") + xlab("Time") +
       theme(legend.position="top")+
       labs(title= bquote("Comparison between" ~ "f(t)=sin(t)" ~ "
       and Smooth(ILT(LT(fMRI)))(t); Range [" ~ 0 ~":"~ 2*pi~"]"))

</code></pre>

<hr>
<h2 id='kimesurface_transform'>kimesurface transform on a function with a specified set of complex values</h2><span id='topic+kimesurface_transform'></span>

<h3>Description</h3>

<p>a function applies the kimesurface transform on a function with a specified set of complex values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kimesurface_transform(
  FUNCT,
  glb_para,
  real_x,
  img_y,
  parallel_computing = FALSE,
  ncor = 6
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kimesurface_transform_+3A_funct">FUNCT</code></td>
<td>
<p>function object f(t) to conduct kimesurface transform on</p>
</td></tr>
<tr><td><code id="kimesurface_transform_+3A_glb_para">glb_para</code></td>
<td>
<p>a vector of global objections that needed to be imported when using parallel computing</p>
</td></tr>
<tr><td><code id="kimesurface_transform_+3A_real_x">real_x</code></td>
<td>
<p>a list of numeric values, which is the real part of a set of complex values</p>
</td></tr>
<tr><td><code id="kimesurface_transform_+3A_img_y">img_y</code></td>
<td>
<p>a list of numeric values, which is the imaginary part of the set of complex values stated above</p>
</td></tr>
<tr><td><code id="kimesurface_transform_+3A_parallel_computing">parallel_computing</code></td>
<td>
<p>logical object to determine whether to use parallel computing to speed up the function or not.
The default is FALSE.</p>
</td></tr>
<tr><td><code id="kimesurface_transform_+3A_ncor">ncor</code></td>
<td>
<p>number of cores for parallel computing. The default is 6.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function applies the kimesurface transform on a 1D function f(t), to have it converted to a 2D function. The input
is a set of complex values with the same number of real and imaginary parts. These two parts can specify a 2D plane 
of the same length and width. The new 2D function is defined on this 2D plane. It mainly does a 
Laplace Transform and modifies all the function values in a specific way to have them looks better in the plot.
</p>


<h3>Value</h3>

<p>a 2d array that did kimesurface transform for the set of complex value (the real and imaginary parts can
construct a 2d plane)
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'># drop the first row and first column because of divergence on Laplace Transform
# do kimesurface transform on sine function
x = seq(0, 2, length.out=50)[2:50]; y = seq(0, 2, length.out=50)[2:50];


kimesurface_transform(FUNCT = function(t) {sin(t)}, real_x = x, img_y = y);

                      
</code></pre>

<hr>
<h2 id='LT'>numerical method to compute Laplace Transform</h2><span id='topic+LT'></span>

<h3>Description</h3>

<p>a function that numerically computes the Laplace Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LT(FUNCT, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LT_+3A_funct">FUNCT</code></td>
<td>
<p>a function object f(t) conducting Laplace Transform</p>
</td></tr>
<tr><td><code id="LT_+3A_z">z</code></td>
<td>
<p>a complex domain value used to evaluate the F(z)=LT(f)(z)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a complex value computed from Laplace Transform
</p>


<h3>Author(s)</h3>

<p>SOCR team &lt;<a href="http://socr.umich.edu/people/">http://socr.umich.edu/people/</a>&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f = function(t) { t }; z= 1+1i; 
LT(f, z); 
# compare with the result from analytic form of Laplace Transform of f(t) = t
# analytic form is below
F = function (z) { 1/z^2 }; F(z)
# the two results are the same
</code></pre>

<hr>
<h2 id='mask'>mask</h2><span id='topic+mask'></span>

<h3>Description</h3>

<p>a 64*64*40 3D array representing brain mask
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask
</code></pre>


<h3>Format</h3>

<p>a 3D array containing brain mask data
</p>

<hr>
<h2 id='mask_dict'>mask_dict</h2><span id='topic+mask_dict'></span>

<h3>Description</h3>

<p>a data.frame containing the label index corresponding to its label name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_dict
</code></pre>


<h3>Format</h3>

<p>a data.frame containing the label index corresponding to its label name
</p>

<hr>
<h2 id='mask_label'>mask_label</h2><span id='topic+mask_label'></span>

<h3>Description</h3>

<p>a 64*64*40 3D array representing brain mask with labels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_label
</code></pre>


<h3>Format</h3>

<p>a 3D array containing brain mask data
</p>

<hr>
<h2 id='phase1_pval'>phase1_pval</h2><span id='topic+phase1_pval'></span>

<h3>Description</h3>

<p>a 64*64*40 3D array containing a sample p values for the first phase of three-phase ROI analysis by function fmri_ROI_phase1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase1_pval
</code></pre>


<h3>Format</h3>

<p>a 3D array containing p values
</p>

<hr>
<h2 id='phase2_pval'>phase2_pval</h2><span id='topic+phase2_pval'></span>

<h3>Description</h3>

<p>a 64*64*40 3D array containing a sample p values for the second phase of three-phase ROI analysis by function fmri_ROI_phase2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase2_pval
</code></pre>


<h3>Format</h3>

<p>a 3D array containing p values
</p>

<hr>
<h2 id='phase3_pval'>phase3_pval</h2><span id='topic+phase3_pval'></span>

<h3>Description</h3>

<p>a 64*64*40 3D array containing a sample p values for the third phase of three-phase ROI analysis, generated by the post-hoc process for phase2_pval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase3_pval
</code></pre>


<h3>Format</h3>

<p>a 3D array containing p values
</p>

<hr>
<h2 id='sample_save'>sample_save</h2><span id='topic+sample_save'></span>

<h3>Description</h3>

<p>a list containing some pre-calculated data for generating vignettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_save
</code></pre>


<h3>Format</h3>

<p>a list containing some pre-calculated data for generating vignettes
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
