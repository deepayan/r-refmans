<!DOCTYPE html><html><head><title>Help for package sgt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sgt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#sgt'><p>The Skewed Generalized T Distribution</p></a></li>
<li><a href='#sgtmle'><p>Maximum Likelihood Estimation with the Skewed Generalized T Distribution</p></a></li>
<li><a href='#summary.sgtest'><p>Summary the Maximum-Likelihood Estimation with the Skewed Generalized T Distribution</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Skewed Generalized T Distribution Tree</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-08-30</td>
</tr>
<tr>
<td>Author:</td>
<td>Carter Davis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carter Davis &lt;cdavis40@chicagobooth.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), optimx (&ge; 2013.8.7), numDeriv (&ge; 2014.2-1)</td>
</tr>
<tr>
<td>Description:</td>
<td>Density, distribution function, quantile function and random generation for the skewed generalized t distribution. This package also provides a function that can fit data to the skewed generalized t distribution using maximum likelihood estimation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-09-03 01:47:41 UTC; carter</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-09-04 01:00:18</td>
</tr>
</table>
<hr>
<h2 id='sgt'>The Skewed Generalized T Distribution</h2><span id='topic+SGT'></span><span id='topic+sgt'></span><span id='topic+dsgt'></span><span id='topic+psgt'></span><span id='topic+qsgt'></span><span id='topic+rsgt'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random
generation for the skewed generalized t distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsgt(x, mu = 0, sigma = 1, lambda = 0, p = 2, q = Inf, 
mean.cent = TRUE, var.adj = TRUE, log = FALSE)
psgt(quant, mu = 0, sigma = 1, lambda = 0, p = 2, q = Inf, 
mean.cent = TRUE, var.adj = TRUE, lower.tail = TRUE, 
log.p = FALSE)
qsgt(prob, mu = 0, sigma = 1, lambda = 0, p = 2, q = Inf, 
mean.cent = TRUE, var.adj = TRUE, lower.tail = TRUE, 
log.p = FALSE)
rsgt(n, mu = 0, sigma = 1, lambda = 0, p = 2, q = Inf, 
mean.cent = TRUE, var.adj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgt_+3A_x">x</code>, <code id="sgt_+3A_quant">quant</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="sgt_+3A_prob">prob</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="sgt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="sgt_+3A_mu">mu</code></td>
<td>
<p>vector of parameters. Note that if <code>mean.cent == TRUE</code>, <code>mu</code> is the mean of the distribution. Otherwise, <code>mu</code> is the mode of the distribution.</p>
</td></tr>
<tr><td><code id="sgt_+3A_sigma">sigma</code></td>
<td>
<p>vector of variance parameters. The default is 1. The variance of the distribution increases as <code>sigma</code> increases. Must be strictly positive.</p>
</td></tr>
<tr><td><code id="sgt_+3A_lambda">lambda</code></td>
<td>
<p>vector of skewness parameters. Note that <code>-1 &lt; lambda &lt; 1</code>. If <code>lambda &lt; 0</code>, the distribution is skewed to the left. If <code>lambda &gt; 0</code>, the distribution is skewed to the right. If <code>lambda = 0</code>, then the distribution is symmetric.</p>
</td></tr>
<tr><td><code id="sgt_+3A_p">p</code>, <code id="sgt_+3A_q">q</code></td>
<td>
<p>vector of parameters. Smaller values of <code>p</code> and <code>q</code> result in larger values for the kurtosis of the distribution. Allowed to be infinite. Note that <code>p &gt; 0</code>, <code>q &gt; 0</code>, otherwise <code>NaNs</code> will be produced.</p>
</td></tr>
<tr><td><code id="sgt_+3A_mean.cent">mean.cent</code></td>
<td>
<p>logical; if TRUE, <code>mu</code> is the mean of the distribution, otherwise <code>mu</code> is the mode of the distribution. May only be used if <code>p*q &gt; 1</code>, otherwise <code>NaNs</code> will be produced.</p>
</td></tr>
<tr><td><code id="sgt_+3A_var.adj">var.adj</code></td>
<td>
<p>logical or a positive scalar. If <code>TRUE</code>, then <code>sigma</code> is rescaled so that <code>sigma</code> is the variance. If <code>FALSE</code>, then <code>sigma</code> is not rescaled. If <code>var.adj</code> is a positive scalar, then <code>sigma</code> is rescaled by <code>var.adj</code>. May only be used if <code>p*q &gt; 2</code>, otherwise <code>NaNs</code> will be produced.</p>
</td></tr>
<tr><td><code id="sgt_+3A_log">log</code>, <code id="sgt_+3A_log.p">log.p</code></td>
<td>
<p>logical; if TRUE, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="sgt_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code> otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>mu</code>, <code>sigma</code>, <code>lambda</code>, <code>p</code>, or <code>q</code> are not specified they assume the default values of <code>mu = 0</code>, <code>sigma = 1</code>, <code>lambda = 0</code>, <code>p = 2</code>, and <code>q = Inf</code>. These default values yield a standard normal distribution. 
</p>
<p>See <code>vignette('sgt')</code> for the probability density function, moments, and various special cases of the skewed generalized t distribution.
</p>


<h3>Value</h3>

<p><code>dsgt</code> gives the density,
<code>psgt</code> gives the distribution function,
<code>qsgt</code> gives the quantile function, and
<code>rsgt</code> generates random deviates.
</p>
<p>The length of the result is determined by <code>n</code> for
<code>rsgt</code>, and is the maximum of the lengths of the
numerical arguments for the other functions.  
</p>
<p>The numerical arguments other than <code>n</code> are recycled to the
length of the result.  Only the first elements of the logical
arguments are used.
</p>
<p><code>sigma &lt;= 0</code>, <code>lambda &lt;= -1</code>, <code>lambda &gt;= 1</code>, <code>p &lt;= 0</code>, and <code>q &lt;= 0</code> are errors and return <code>NaN</code>. Also, if <code>mean.cent</code> is <code>TRUE</code> but codep*q &lt;= 1, the result is an error and <code>NaNs</code> are produced. Similarly, if <code>var.adj</code> is <code>TRUE</code> but codep*q &lt;= 2, the result is an error and <code>NaNs</code> are produced.
</p>


<h3>Author(s)</h3>

<p>Carter Davis, <a href="mailto:carterdavis@byu.edu">carterdavis@byu.edu</a></p>


<h3>Source</h3>

<p>For <code>psgt</code>, based on
</p>
<p>a transformation of the cumulative probability density function that uses the incomplete beta function or incomplete gamma function.
</p>
<p>For <code>qsgt</code>, based on
</p>
<p>solving for the inverse of the <code>psgt</code> function that uses the inverse of the incomplete beta function or incomplete gamma function.
</p>
<p>For <code>rsgt</code>, the algorithm simply uses the <code>qsgt</code> function with probabilities that are uniformly distributed.
</p>


<h3>References</h3>

<p>Hansen, C., McDonald, J. B., and Newey, W. K. (2010)
&quot;Instrumental Variables Regression with Flexible Distributions&quot;
<em>Journal of Business and Economic Statistics</em>, volume 28, 13-25.
</p>
<p>Kerman, S. C., and McDonald, J. B. (2012)
&quot;Skewness-Kurtosis Bounds for the Skewed Generalized T and Related Distributions&quot;
<em>Statistics and Probability Letters</em>, volume 83, 2129-2134.
</p>
<p>Theodossiou, Panayiotis (1998)
&quot;Financial Data and the Skewed Generalized T Distribution&quot;
<em>Management Science</em>, volume 44, 1650-1661.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+Distributions">Distributions</a> for other standard distributions which are special cases of the skewed generalized t distribution, including <code><a href="stats.html#topic+dt">dt</a></code> for the t distribution, <code><a href="stats.html#topic+dnorm">dnorm</a></code> for the normal distribution, and <code><a href="stats.html#topic+dunif">dunif</a></code> for the uniform distribution. Other special cases of the skewed generalized t distribution include the generalized t distribution in the <code>gamlss.dist</code> package, the skewed t distribution in the <code>skewt</code> package, the exponential power distribution (also known as the generalized error distribution) in the <code>normalp</code> package, and the Laplace distribution in the <code>rmutil</code> package. Also see <code><a href="base.html#topic+beta">beta</a></code> for the beta function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(graphics)

### This shows how to get a normal distribution
x = seq(-4,6,by=0.05)
plot(x, dnorm(x, mean=1, sd=1.5), type='l')
lines(x, dsgt(x, mu=1, sigma=1.5), col='blue')

### This shows how to get a cauchy distribution
plot(x, dcauchy(x, location=1, scale=1.3), type='l')
lines(x, dsgt(x, mu=1, sigma=1.3, q=1/2, mean.cent=FALSE, var.adj = sqrt(2)), col='blue')

### This shows how to get a Laplace distribution
plot(x, dsgt(x, mu=1.2, sigma=1.8, p=1, var.adj=FALSE), type='l', col='blue')

### This shows how to get a uniform distribution
plot(x, dunif(x, min=1.2, max=2.6), type='l')
lines(x, dsgt(x, mu=1.9, sigma=0.7, p=Inf, var.adj=FALSE), col='blue')

</code></pre>

<hr>
<h2 id='sgtmle'>Maximum Likelihood Estimation with the Skewed Generalized T Distribution</h2><span id='topic+sgt.mle'></span><span id='topic+SGT.MLE'></span><span id='topic+print.MLE'></span><span id='topic+print.mult.MLE'></span>

<h3>Description</h3>

<p>This function allows data to be fit to the skewed generalized t distribution using maximum likelihood estimation. This function uses the <code>maxLik</code> package to perform its estimations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sgt.mle(X.f, mu.f = mu ~ mu, sigma.f = sigma ~ sigma, 
lambda.f = lambda ~ lambda, p.f = p ~ p, q.f = q ~ q, 
data = parent.frame(), start, subset, 
method = c("Nelder-Mead", "BFGS"), itnmax = NULL,
hessian.method="Richardson", 
gradient.method="Richardson",
mean.cent = TRUE, var.adj = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sgtmle_+3A_x.f">X.f</code></td>
<td>
<p>A formula specifying the data, or the function of the data with parameters, that should be used in the maximisation procedure. <code>X</code> should be on the left-hand side and the right-hand side should be the data or function of the data that should be used.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_mu.f">mu.f</code>, <code id="sgtmle_+3A_sigma.f">sigma.f</code>, <code id="sgtmle_+3A_lambda.f">lambda.f</code>, <code id="sgtmle_+3A_p.f">p.f</code>, <code id="sgtmle_+3A_q.f">q.f</code></td>
<td>
<p>formulas including variables and
parameters that specify the functional form of the parameters in the skewed generalized t log-likelihood function. <code>mu</code>, <code>sigma</code>, <code>lambda</code>, <code>p</code>, and <code>q</code> should be on the left-hand side of these formulas respectively.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_data">data</code></td>
<td>
<p>an optional data frame in which to evaluate the variables in <code>formula</code> and <code>weights</code>.  Can also be a list or an environment.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_start">start</code></td>
<td>
<p>a named list or named numeric vector of starting estimates for every parameter.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_method">method</code></td>
<td>
<p>A list of the optimization methods to be used, which is passed directly to the <code>optimx</code> function in the <code>optimx</code> package. See <code>?optimx</code> for a list of methods that can be used.
Note that the method that achieves the highest log-likelihood value is the method that is printed and reported.
The default method is to use both &quot;Nelder-Mead&quot; and the &quot;BFGS&quot; methods.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_itnmax">itnmax</code></td>
<td>
<p>If provided as a vector of the same length as <code>method</code>, gives the maximum number of iterations or function values for the corresponding method. If a single number is provided, this will be used for all methods.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_hessian.method">hessian.method</code></td>
<td>
<p>method used to calculate the hessian of the final estimates, either &quot;Richardson&quot; or &quot;complex&quot;. This method is passed to the <code>hessian</code> function in the <code>numDeriv</code> package. See <code>?hessian</code> for details.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_gradient.method">gradient.method</code></td>
<td>
<p>method used to calculate the gradient of the final estimates, either &quot;Richardson&quot;, &quot;simple&quot;, or &quot;complex&quot;. This method is passed to the <code>grad</code> function in the <code>numDeriv</code> package. See <code>?grad</code> for details.</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_mean.cent">mean.cent</code>, <code id="sgtmle_+3A_var.adj">var.adj</code></td>
<td>
<p>arguments passed to the skewed generalized t distribution function (see <code>?dsgt</code>).</p>
</td></tr>
<tr><td><code id="sgtmle_+3A_...">...</code></td>
<td>
<p>further arguments that are passed to the <code>control</code> argument in the <code>optimx</code> function in the <code>optimx</code> package. See <code>?optimx</code> for a list of arguments that can be used in the <code>control</code> argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter names are taken from <code>start</code>. If there is a name of a parameter or some data found on the right-hand side of one of the formulas but not found in <code>data</code> and not found in <code>start</code>, then an error is given.
</p>
<p>This function simply uses the <code>optimx</code> function in the <code>optimx</code> package to maximize the skewed generalized t distribution log-likelihood function. It takes the method that returned the highest log-likelihood, and saves these results as the final estimates.
</p>


<h3>Value</h3>

<p><code>sgt.mle</code> returns a list of class <code>"sgtest"</code>.
A list of class <code>"sgtest"</code> has the following components:
</p>
<table>
<tr><td><code>maximum</code></td>
<td>
<p>log-likelihood value of estimates (the last calculated value
if not converged) of the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated parameter value with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p><code>convcode</code> returned from the <code>optimx</code> function in the <code>optimx</code> package of the method that achieved the greatest log-likelihood value. See <code>?optimx</code> for the different <code>convcode</code> values.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>The amount of iterations that the method which achieved the the greatest log-likelihood value used to reach its estimate.</p>
</td></tr>
<tr><td><code>best.method.used</code></td>
<td>
<p>name of the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>optimx</code></td>
<td>
<p>A <code>data.frame</code> of class <code>"optimx"</code> that contains the results of the <code>optimx</code> maximization for every method (<em>not</em> just the method that achieved the highest log-likelihood value). See <code>?optimx</code> for details.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>vector, gradient value of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>matrix, hessian of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>variance/covariance matrix of the maximimum likelihood estimates</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard errors of the estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carter Davis, <a href="mailto:carterdavis@byu.edu">carterdavis@byu.edu</a></p>


<h3>References</h3>

<p>Davis, Carter, James McDonald, and Daniel Walton (2015). 
&quot;A Generalized Regression Specification using the Skewed Generalized T Distribution&quot; 
working paper.
</p>


<h3>See Also</h3>

<p>The <code>optimx</code> package and its documentation. The <code>sgt.mle</code> simply uses its functions to maximize the skewed generalized t log-likelihood. Also, the <code>sgt.mle</code> function uses the <code>numDeriv</code> package to compute the final hessian and gradients of the estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># SINGLE VARIABLE ESTIMATION:
### generate random variable
set.seed(7900)
n = 1000
x = rsgt(n, mu = 2, sigma = 2, lambda = -0.25, p = 1.7, q = 7)

### Get starting values and estimate the parameter values
start = list(mu = 0, sigma = 1, lambda = 0, p = 2, q = 10)
result = sgt.mle(X.f = ~ x, start = start, method = "nlminb")
print(result)
print(summary(result))

# REGRESSION MODEL ESTIMATION:
### Generate Random Data 
set.seed(1253)
n = 1000
x1 = rnorm(n)
x2 = runif(n)
y = 1 + 2*x1 + 3*x2 + rnorm(n)
data = as.data.frame(cbind(y, x1, x2))

### Estimate Linear Regression Model
reg = lm(y ~ x1 + x2, data = data)
coef = as.numeric(reg$coefficients)
rmse = summary(reg)$sigma
start = c(b0 = coef[1], b1 = coef[2], b2 = coef[3], 
g0 = log(rmse)+log(2)/2, g1 = 0, g2 = 0, d0 = 0, 
d1 = 0, d2 = 0, p = 2, q = 10)

### Set up Model
X.f = X ~ y - (b0 + b1*x1 + b2*x2)
mu.f = mu ~ 0
sigma.f = sigma ~ exp(g0 + g1*x1 + g2*x2)
lambda.f = lambda ~ (exp(d0 + d1*x1 + d2*x2)-1)/(exp(d0 + d1*x1 + d2*x2)+1)

### Estimate Regression with a skewed generalized t error term
### This estimates the regression model from the Davis, 
### McDonald, and Walton (2015) paper cited in the references section
### q is in reality infinite since the error term is normal
result = sgt.mle(X.f = X.f, mu.f = mu.f, sigma.f = sigma.f, 
lambda.f = lambda.f, data = data, start = start, 
var.adj = FALSE, method = "nlm")
print(result)
print(summary(result))
</code></pre>

<hr>
<h2 id='summary.sgtest'>Summary the Maximum-Likelihood Estimation with the Skewed Generalized T Distribution</h2><span id='topic+summary.sgtest'></span><span id='topic+coef.summary.sgtest'></span>

<h3>Description</h3>

<p>Summary the maximum-likelihood estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sgtest'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.sgtest_+3A_object">object</code></td>
<td>

<p>object of class <code>'sgtest'</code>, usually a result from
maximum-likelihood estimation.
</p>
</td></tr>
<tr><td><code id="summary.sgtest_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary.sgtest</code> returns an
object of class <code>'summary.sgtest'</code> with the following components:
</p>
<table>
<tr><td><code>maximum</code></td>
<td>
<p>log-likelihood value of estimates (the last calculated value
if not converged) of the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>estimate</code></td>
<td>
<p>estimated parameter value with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>convcode</code></td>
<td>
<p><code>convcode</code> returned from the <code>optimx</code> function in the <code>optimx</code> package of the method that achieved the greatest log-likelihood value. See <code>?optimx</code> for the different <code>convcode</code> values.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>The amount of iterations that the method which achieved the the greatest log-likelihood value used to reach its estimate.</p>
</td></tr>
<tr><td><code>best.method.used</code></td>
<td>
<p>name of the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>optimx</code></td>
<td>
<p>A <code>data.frame</code> of class <code>"optimx"</code> that contains the results of the <code>optimx</code> maximization for every method (<em>not</em> just the method that achieved the highest log-likelihood value). See <code>?optimx</code> for details.</p>
</td></tr>
<tr><td><code>gradient</code></td>
<td>
<p>vector, gradient value of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>matrix, hessian of the estimates with the method that achieved the greatest log-likelihood value.</p>
</td></tr>
<tr><td><code>varcov</code></td>
<td>
<p>variance/covariance matrix of the maximimum likelihood estimates</p>
</td></tr>
<tr><td><code>std.error</code></td>
<td>
<p>standard errors of the estimates</p>
</td></tr>
<tr><td><code>z.score</code></td>
<td>
<p>the z score of the estimates</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-values of the estimates</p>
</td></tr>
<tr><td><code>summary.table</code></td>
<td>
<p>a <code>data.frame</code> containing the estimates, standard errors, z scores, and p-values of the estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carter Davis, <a href="mailto:cdavis40@chicagobooth.edu">cdavis40@chicagobooth.edu</a></p>


<h3>See Also</h3>

<p>the <code>optimx</code> CRAN package</p>


<h3>Examples</h3>

<pre><code class='language-R'># SINGLE VARIABLE ESTIMATION:
### generate random variable
set.seed(7900)
n = 1000
x = rsgt(n, mu = 2, sigma = 2, lambda = -0.25, p = 1.7, q = 7)

### Get starting values and estimate the parameter values
start = list(mu = 0, sigma = 1, lambda = 0, p = 2, q = 10)
result = sgt.mle(X.f = ~ x, start = start, method = "nlminb")
print(result)
print(summary(result))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
