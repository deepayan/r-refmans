<!DOCTYPE html><html lang="en"><head><title>Help for package qra</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qra}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#qra-package'><p>qra: A package for calculations that relate to dose-mortality,</p>
or time-mortality, or other such models.</a></li>
<li><a href='#checkDisp'><p>Reproduce data for the linear model scale-location diagnostic plot</p></a></li>
<li><a href='#codling1988'><p>Dose-mortality data, for fumigation of codling moth with methyl bromide</p></a></li>
<li><a href='#extractLT'><p>Obtain complete set of LT or LD estimates</p></a></li>
<li><a href='#fieller'><p>Confidence Limits for Lethal Dose Estimate From Dose-response Line</p></a></li>
<li><a href='#foldp'><p>Title Function to calculate ratio of <code>p+eps</code> to <code>1-p+eps</code>.</p></a></li>
<li><a href='#fpower'><p>Folded Power Transformation</p></a></li>
<li><a href='#getRho'><p>Extract estimates of the intra-class correlation from a glmmTMB</p>
model object with beta-binomial error.</a></li>
<li><a href='#getScaleCoef'><p>Extract scaling coefficients from vector returned by <code>scale()</code></p></a></li>
<li><a href='#gpsWithin'><p>Use given vector to identify groups with specified categories</p></a></li>
<li><a href='#graphSum'><p>Draw graphs of insect mortality or other exposure-response data</p></a></li>
<li><a href='#HawCon'>
<p>Hawaiian Contemporary Cold Treatment Dataset</p></a></li>
<li><a href='#kerrich'>
<p>Kerrich Coin Toss Trial Outcomes</p></a></li>
<li><a href='#malesINfirst12'>
<p>Number of males among first 12 in families of 13 children</p></a></li>
<li><a href='#rayBlight'>
<p>Incidence of ray blight disease of pyrethrum</p></a></li>
<li><a href='#scaleLocAdjust'><p>Estimate dispersion as a function of predicted values</p></a></li>
<li><a href='#varRatio'><p>First order approximation to variance of y-ordinate to slope ratio</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantal Response Analysis for Dose-Mortality Data</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-10-29</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Maindonald &lt;john@statsresearch.co.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions are provided that implement the 
    use of the Fieller's formula methodology, for 
    calculating a confidence interval for a ratio of
    (commonly, correlated) means.  See Fieller (1954)
    &lt;<a href="https://doi.org/10.1111%2Fj.2517-6161.1954.tb00159.x">doi:10.1111/j.2517-6161.1954.tb00159.x</a>&gt;.  Here,
    the application of primary interest is to studies
    of insect mortality response to increasing doses
    of a fumigant, or, e.g., to time in coolstorage.
    The formula is used to calculate a confidence
    interval for the dose or time required to achieve
    a specified mortality proportion, commonly 0.5 
    or 0.99.  Vignettes demonstrate link functions
    that may be considered, checks on fitted models,
    and alternative choices of error family.  Note
    in particular the betabinomial error family.
    See also Maindonald, Waddell, and Petry (2001) 
    &lt;<a href="https://doi.org/10.1016%2FS0925-5214%2801%2900082-5">doi:10.1016/S0925-5214(01)00082-5</a>&gt;.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0), lattice, latticeExtra, knitr, rmarkdown</td>
</tr>
<tr>
<td>Imports:</td>
<td>lme4, splines, ggplot2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fitODBOD, VGAM, glmmTMB (&ge; 1.1.2), gamlss, prettydoc,
DHARMa, kableExtra (&ge; 1.2), plotrix, dfoptim, optimx, bookdown</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jhmaindonald/qra">https://github.com/jhmaindonald/qra</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jhmaindonald/qra/issues">https://github.com/jhmaindonald/qra/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown, bookdown, prettydoc</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-10-29 01:43:51 UTC; johnm1</td>
</tr>
<tr>
<td>Author:</td>
<td>John Maindonald <a href="https://orcid.org/0000-0002-0106-9224"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-10-29 04:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='qra-package'>qra: A package for calculations that relate to dose-mortality,
or time-mortality, or other such models.</h2><span id='topic+qra'></span><span id='topic+qra-package'></span>

<h3>Description</h3>

<p>The qra package provides the functions:
checkDisp,	getRho, extractLT, getScaleCoef, scaleLocAdjust,
fieller,	gpsWithin, varRatio, foldp,	graphSum, fpower
</p>


<h3>Details</h3>

<p>The three vignettes provide examples of the use of the functions.
</p>


<h3>qra functions</h3>

<p><code>fieller</code>: Calculates lethal dose estimates, using Fieller's
formula to calculate 95
of the functions noted below are useful ancillaries to <code>fieller</code>
and <code>fieller2</code>, notably <code>foldp</code>, <code>fpower</code>, <code>extractLT</code>,
and <code>getScaleCoef</code>.
</p>
<p><code>fieller2</code>: Use when a folded power link has been used.
See <code><a href="#topic+fpower">fpower</a></code>.
</p>
<p><code>extractLT</code>: Obtains complete set of LT or LD estimate, when it is
convenient to get results from several models at the same time.
</p>
<p><code>foldp</code>: Calculates the ratio of <code>p+eps</code> to <code>1-code+eps</code>
</p>
<p><code>getRho</code> Extracts estimates of the intra-class
correlation from a glmmTMB model object with betabinomial error.
See the vignette [timeMortality] for details of the parametization
used for the <code>betabinomial</code> error.
</p>
<p><code>getScaleCoef</code>: Extracts the scale coefficients from a vector
that has been scaled using <code>scale</code>, as needed so that the scaling
can be undone.
</p>
<p><code>gpsWithin</code> Renumbers group identifiers so that they run from
1 to number of groups within for each level of the specified factor.
</p>
<p><code>scaleLocAdjust</code>: Returns, for <code>glmmTMB</code> models with a
betabinomial error, dispersion factors (i.e., multipliers for the
binomial variance) as functions of predicted values.
</p>
<p><code>varRatio</code>: Returns a first order approximation to the variance
of the $y$-ordinate to slope ratio.  This is used in the
<code>type="Delta"</code> approximation, for calculation of LT and LD
confidence intervals.  Primarily, this is provided for purposes
of comparison, to make it easy to show how poor the approximation
can be, and to warn against its general dewvuse!
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: John Maindonald <a href="mailto:john@statsresearch.co.nz">john@statsresearch.co.nz</a> (<a href="https://orcid.org/0000-0002-0106-9224">ORCID</a>)
</p>

<hr>
<h2 id='checkDisp'>Reproduce data for the linear model scale-location diagnostic plot</h2><span id='topic+checkDisp'></span>

<h3>Description</h3>

<p>The values returned are those used for <code>plot(x.lm, which=3)</code>,
where <code>x.lm</code> is a linear model or a generalized linear model.
Plot the object returned to assess how successful the weights,
determined using the function <code><a href="#topic+scaleLocAdjust">scaleLocAdjust</a></code>, have been
in adjusting for heterogenous variances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDisp(x, span = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkDisp_+3A_x">x</code></td>
<td>
<p>Model fitted using <code>lm()</code> or <code>glm()</code></p>
</td></tr>
<tr><td><code id="checkDisp_+3A_span">span</code></td>
<td>
<p>span parameter for use in smoothing the square
root of standardized deviance residuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, with:
</p>
<table role = "presentation">
<tr><td><code>linpred</code></td>
<td>
<p>Predicted values, on the scale of the linear predictor</p>
</td></tr>
<tr><td><code>absrSmooth</code></td>
<td>
<p>Smoothed values of the square roots of absolute
values of standardised deviance residuals.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>royal &lt;- subset(qra::codling1988, Cultivar=="ROYAL")
royal.glm &lt;- glm(cbind(dead,total-dead)~ct, data=royal,
                 family=quasibinomial(link='cloglog'))
royalFix &lt;- qra::scaleLocAdjust(royal.glm, lambda=2)
## Check range of indicated prior weights
range(royalFix[[2]])
## Range of updated dispersion estimates
range(summary(royalFix[[1]])[['dispersion']]/royalFix[[2]])
xy &lt;- qra::checkDisp(royalFix[[1]])
plot(xy)
</code></pre>

<hr>
<h2 id='codling1988'>Dose-mortality data, for fumigation of codling moth with methyl bromide</h2><span id='topic+codling1988'></span><span id='topic+codling1989'></span>

<h3>Description</h3>

<p>Data are from trials that studied the mortality response of codling moth
to fumigation with methyl bromide, for the year 1988 only
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(codling1988)
data(codling1989)
</code></pre>


<h3>Format</h3>

<p>A data frame with 77 observations (<code>codling1988</code>), and with 40
observations (<code>codling1989</code>), on the following 8 variables.
</p>

<dl>
<dt>dose</dt><dd><p>Injected dose of methyl bromide, in gm per cubic meter</p>
</dd>
<dt>ct</dt><dd><p>Concentration-time sum</p>
</dd>
<dt>total</dt><dd><p>Number of insects in chamber</p>
</dd>
<dt>dead</dt><dd><p>Number of insects dying</p>
</dd>
<dt>PropDead</dt><dd><p>Proportion dying</p>
</dd>
<dt>Cultivar</dt><dd><p>a factor with 1988 levels <code>BRAEBURN</code>
<code>FUJI</code> <code>GRANNY</code> <code>Red Delicious</code> and <code>ROYAL</code>;
and with 1989 levels <code>Gala</code>, <code>Red Delicious</code>
and <code>Splendour</code></p>
</dd>
<dt>rep</dt><dd><p>replicate number, within <code>Cultivar</code></p>
</dd>
<dt>cultRep</dt><dd><p>Cultivar/replicate combination</p>
</dd>
</dl>



<h3>Details</h3>

<p>The research that generated these data was in part funded by New Zealand
pipfruit growers.  The published analysis was funded by New Zealand
pipfruit growers. See also <code>DAAG::sorption</code>.
</p>


<h3>Source</h3>

<p>Maindonald, J.H.; Waddell, B.C.; Petry, R.J. 2001.
Apple cultivar effects on codling moth (Lepidoptera: Tortricidae)
egg mortality following fumigation with methyl bromide.
Postharvest Biology and Technology 22: 99-110.
</p>

<hr>
<h2 id='extractLT'>Obtain complete set of LT or LD estimates</h2><span id='topic+extractLT'></span><span id='topic+extractLTpwr'></span>

<h3>Description</h3>

<p>When supplied with a model object that has fitted
dose-response lines for each of several levels of a factor,
<code>extractLT</code> calls the function <code>fieller</code> to calculate lethal time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractLT(
  obj,
  a = 1:3,
  b = 4:6,
  link = NULL,
  logscale = FALSE,
  p = 0.99,
  eps = 0,
  offset = 0,
  df.t = NULL
)

extractLTpwr(
  obj,
  a = 1:3,
  b = 1:3,
  link = "fpower",
  logscale = FALSE,
  p = 0.99,
  lambda = 0,
  eps = 0.015,
  offset = 0,
  df.t = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extractLT_+3A_obj">obj</code></td>
<td>
<p><code>merMod</code> object, created using <code>lmer()</code> or
<code>glmerMod</code> object, created using <code>glmer()</code>.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_a">a</code></td>
<td>
<p>Subscripts for intercepts.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_b">b</code></td>
<td>
<p>Subscripts for corresponding slopes.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_link">link</code></td>
<td>
<p>Link function, for use with objects where no
link was specified in the function call, but it is required
to back-transform a transformation that was performed prior
to the function call.  Otherwise leave as <code>link=NULL</code>, and
the link function will be extracted as <code>family(obj)[['link']]</code>.
For a folded power function, with <code>extractLTpwr()</code>, the only
available link is <code>fpower</code>, and the exponent <code>lambda</code> must be
specified.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_logscale">logscale</code></td>
<td>
<p>Logical.  Specify <code>TRUE</code>, if LT values are
to be back-transformed from a logarithmic scale.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_p">p</code></td>
<td>
<p>Target response proportion.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_eps">eps</code></td>
<td>
<p>Replace <code>prob</code> by <code>prob+eps</code> before transformation.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_offset">offset</code></td>
<td>
<p>Use to undo scaling of time or dose variable. This is
passed to the <code><a href="#topic+fieller">fieller</a></code> function that <code>extractLT</code>
calls.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_df.t">df.t</code></td>
<td>
<p>Degrees of freedom for a t-distribution approximation
for 't' or 'z' statistics.  If NULL, a conservative (low) value will
be used.  For linear (but not generalized linear) models and mixed
models, approximations are implemented in the <span class="pkg">afex</span> package.
See <code>vignette('introduction-mixed-models', package="afex")</code>, page 19.</p>
</td></tr>
<tr><td><code id="extractLT_+3A_lambda">lambda</code></td>
<td>
<p>(<code>extractLTpwr</code> only) Power for power function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fixed coefficients from <code>obj</code> must be for intercepts and
for slopes.  Starting the model formula with <code>0+</code> will commonly
do what is required. The coefficients <code>fixef(obj)[a]</code> are assumed
to specify line intercepts, while <code>fixef(obj)[b]</code> specify the
corresponding slopes.  These replace the arguments <code>nEsts</code>
(subscripts for intercepts were <code>1:nEsts)</code> and <code>slopeAdd</code>
(subscripts for slopes were <code>(nEsts+1):(nEsts+slopeAdd)</code>).
</p>


<h3>Value</h3>

<p>Matrix holding LD or LD estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcheck &lt;- suppressWarnings(requireNamespace("glmmTMB", quietly = TRUE))
if(pcheck) pcheck &amp; packageVersion("glmmTMB") &gt;= "1.1.2"
if(pcheck){
form &lt;- cbind(Dead,Live)~0+trtGp/TrtTime+(1|trtGpRep)
HawMed &lt;- droplevels(subset(HawCon, CN=="MedFly"&amp;LifestageTrt!="Egg"))
HawMed &lt;- within(HawMed,
                 {trtGp &lt;- factor(paste0(CN,LifestageTrt, sep=":"))
                 trtGpRep &lt;- paste0(CN,LifestageTrt,":",RepNumber)
                 scTime &lt;- scale(TrtTime) })
HawMedbb.cll &lt;- glmmTMB::glmmTMB(form, dispformula=~trtGp+splines::ns(scTime,2),
                                 family=glmmTMB::betabinomial(link="cloglog"),
                                 data=HawMed)
round(qra::extractLT(p=0.99, obj=HawMedbb.cll, link="cloglog",
               a=1:3, b=4:6, eps=0, df.t=NULL)[,-2], 2)} else
message("Example requires `glmmTMB` version &gt;= 1.1.2: not available")

</code></pre>

<hr>
<h2 id='fieller'>Confidence Limits for Lethal Dose Estimate From Dose-response Line</h2><span id='topic+fieller'></span><span id='topic+fieller2'></span>

<h3>Description</h3>

<p>This uses Fieller's formula to calculate a confidence
interval for a specified mortality proportion, commonly
0.50, or 0.90, or 0.99.  Here &quot;dose&quot; is a generic term for
any measure of intensity of a treatment that is designed
to induce insect death.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fieller(
  phat,
  b,
  vv,
  df.t = Inf,
  offset = 0,
  logscale = FALSE,
  link = "logit",
  eps = 0,
  type = c("Fieller", "Delta"),
  maxg = 0.99
)

fieller2(
  phat,
  b,
  vv,
  df.t = Inf,
  offset = 0,
  logscale = FALSE,
  link = "fpower",
  lambda = 0,
  eps = 0,
  type = c("Fieller", "Delta"),
  maxg = 0.99
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fieller_+3A_phat">phat</code></td>
<td>
<p>Mortality proportion</p>
</td></tr>
<tr><td><code id="fieller_+3A_b">b</code></td>
<td>
<p>Length 2 vector of intercept and slope</p>
</td></tr>
<tr><td><code id="fieller_+3A_vv">vv</code></td>
<td>
<p>Variance-covariance matrix for intercept and slope</p>
</td></tr>
<tr><td><code id="fieller_+3A_df.t">df.t</code></td>
<td>
<p>Degrees of freedom for variance-covariance
matrix</p>
</td></tr>
<tr><td><code id="fieller_+3A_offset">offset</code></td>
<td>
<p>Offset to be added to intercept. This can be of
length 2, in order to return values on the original scale,
in the case where <code>b</code> and <code>vv</code> are for values that
have been scaled by subtracting <code>offset[1]</code> and dividing by
<code>offset[2]</code>.</p>
</td></tr>
<tr><td><code id="fieller_+3A_logscale">logscale</code></td>
<td>
<p>Should confidence limits be back transformed
from log scale?</p>
</td></tr>
<tr><td><code id="fieller_+3A_link">link</code></td>
<td>
<p>Link function that transforms expected mortalities
to the scale of the linear predictor</p>
</td></tr>
<tr><td><code id="fieller_+3A_eps">eps</code></td>
<td>
<p>If <code>eps&gt;0</code> <code>phat</code> is replaced by
<code class="reqn">\frac{p+\epsilon}{1+2*\epsilon}</code> before applying
the transformation.</p>
</td></tr>
<tr><td><code id="fieller_+3A_type">type</code></td>
<td>
<p>The default is to use Fieller's formula.  The
Delta (<code>type="Delta"</code>) method, which relies on a first
order Taylor series approximation to the variance, is
provided so that it can be used for comparative purposes.
It can be reliably used only in cases where the interval
has been shown to be essentially the same as given by
<code>type="Fieller"</code>!</p>
</td></tr>
<tr><td><code id="fieller_+3A_maxg">maxg</code></td>
<td>
<p>Maximum value of <code>g</code> for which a
confidence interval will be calculated. Must be <code>&lt; 1</code>.</p>
</td></tr>
<tr><td><code id="fieller_+3A_lambda">lambda</code></td>
<td>
<p>The power <code class="reqn">\lambda</code>, when using the
<code>link="fpower"</code>. (This applies to <code>fieller2</code>
only.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the internal code for details of the value <code>g</code>.
The calculation gives increasing wide confidence intervals as
<code>g</code> approaches 1.  If <code class="reqn">g&gt;=1</code>, there are no limits.
The default value for <code>df.t</code> is a rough guess at what
might be reasonable. For models fitted using <code>lme4::lmer()</code>,
abilities in the <span class="pkg">lmerTest</span> package can be used to determine
a suitable degrees of freedom approximation &mdash; this does not
extend to use with <code>glmer()</code> or <code>glmmTMB</code>.
</p>


<h3>Value</h3>

<p>A vector, with elements
</p>
<table role = "presentation">
<tr><td><code>est</code></td>
<td>
<p>Estimate</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance, calculated using the Delta method</p>
</td></tr>
<tr><td><code>lwr</code></td>
<td>
<p>Lower bound of confidence interval</p>
</td></tr>
<tr><td><code>upr</code></td>
<td>
<p>upper bound of confidence interval</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>If <code>g</code> is close to 0 (perhaps <code>g &lt; 0.05</code>),
confidence intervals will be similar to those calculated
using the Delta method, and the variance can reasonably
be used for normal theory inference.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Joe Hirschberg &amp; Jenny Lye (2010) A Geometric
Comparison of the Delta and Fieller Confidence Intervals,
The American Statistician, 64:3, 234-241, DOI: 10.1198/ tast.2010.08130
</p>
<p>E C Fieller (1944). A Fundamental Formula in the Statistics
of Biological Assay, and Some Applications. Quarterly
Journal of Pharmacy and Pharmacology, 17, 117-123.
</p>
<p>David J Finney (1978). Statistical Method in Biological Assay (3rd ed.),
London, Charles Griffin and Company.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varRatio">varRatio</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redDel &lt;- subset(qra::codling1988, Cultivar=="Red Delicious")
redDel.glm &lt;- glm(cbind(dead,total-dead)~ct, data=redDel,
                  family=quasibinomial(link='cloglog'))
vv &lt;- summary(redDel.glm)$cov.scaled
fieller(0.99, b=coef(redDel.glm), vv=vv, link='cloglog')

</code></pre>

<hr>
<h2 id='foldp'>Title Function to calculate ratio of <code>p+eps</code> to <code>1-p+eps</code>.</h2><span id='topic+foldp'></span>

<h3>Description</h3>

<p>This is a convenience function that returns
<code class="reqn">\frac{p+\epsilon}{1-p+\epsilon}</code>.  It calculates
the argument that is supplied to the <code>log</code>
function in Tukey's &lsquo;flog&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foldp(p, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foldp_+3A_p">p</code></td>
<td>
<p>Proportion</p>
</td></tr>
<tr><td><code id="foldp_+3A_eps">eps</code></td>
<td>
<p>Offset. The choice <code>eps</code>=0.01 has the
same effect as replacing <code class="reqn">\frac{r}{n-r}</code> by
<code class="reqn">\frac{r+0.5}{n-r+0.5}</code> when <code class="reqn">n=50</code>, or by
<code class="reqn">\frac{r+1}{n-r+1}</code> when <code class="reqn">n=100</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>(p+eps)/(1-p+eps)</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>foldp(c(0.2,0.75), 0)
</code></pre>

<hr>
<h2 id='fpower'>Folded Power Transformation</h2><span id='topic+fpower'></span>

<h3>Description</h3>

<p>The name &ldquo;folded Power Transformation&rdquo; is used because
this does for power transformations what Tukey's folded logarithm
does for the logarithmic tranformation.  The function calculates
</p>
<p style="text-align: center;"><code class="reqn">f(p, \lambda, \epsilon) = \frac{p+\epsilon}{1-p+\epsilon}^\lambda</code>
</p>

<p>where <code class="reqn">\lambda</code> is the power and <code class="reqn">\epsilon</code> is a positive
offset that ensures that <code class="reqn">\frac{p+\epsilon}{1-p+\epsilon}</code> is
greater than 0 and finite.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fpower(p, lambda, eps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fpower_+3A_p">p</code></td>
<td>
<p>Mortality proportion</p>
</td></tr>
<tr><td><code id="fpower_+3A_lambda">lambda</code></td>
<td>
<p>Power <code>lambda</code> for the power transformation</p>
</td></tr>
<tr><td><code id="fpower_+3A_eps">eps</code></td>
<td>
<p>If <code>eps&gt;0</code> <code>phat</code> is replaced by
<code class="reqn">\frac{p+\epsilon}{1+\epsilon}</code> before applying
the power transformation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed values of <code>fpower(p)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- (0:10)/10
ytrans &lt;- fpower(p, lambda=0.25, eps=1/450)
</code></pre>

<hr>
<h2 id='getRho'>Extract estimates of the intra-class correlation from a glmmTMB
model object with beta-binomial error.</h2><span id='topic+getRho'></span>

<h3>Description</h3>

<p>The intra-class correlation is calculated as
<code class="reqn">(1+exp(\theta))^{-1}</code>, where <code class="reqn">\theta</code> is the
estimate given by the formula specified in the argument
<code>dispformula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRho(obj, varMult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRho_+3A_obj">obj</code></td>
<td>
<p><span class="pkg">glmmTMB</span> model object with betabinomial error,
and with a 'dispformula' argument supplied.</p>
</td></tr>
<tr><td><code id="getRho_+3A_varmult">varMult</code></td>
<td>
<p>If <code>TRUE</code> return, in addition to <code>rho</code>,
the factor <code>mult</code> by which the variance is inflated
relative to the binomial.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance for the betabinomial model is then
obtained by multiplying the binomial variance by
<code class="reqn">1+(n-1)\rho</code>, where $n$ is the binomial 'size'.
</p>


<h3>Value</h3>

<p>if <code>varMult==FALSE</code> return (as a vector) the estimates
<code class="reqn">\rho</code>, else (<code>varMult==TRUE</code>)  return
<code>list(rho, mult)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pcheck &lt;- suppressWarnings(requireNamespace("glmmTMB", quietly = TRUE))
if(pcheck) pcheck &amp; packageVersion("glmmTMB") &gt;= "1.1.2"
if(pcheck){
form &lt;- cbind(Dead,Live)~0+trtGp/TrtTime+(1|trtGpRep)
HawMed &lt;- droplevels(subset(HawCon, CN=="MedFly"&amp;LifestageTrt!="Egg"))
HawMed &lt;- within(HawMed,
                 {trtGp &lt;- factor(paste0(CN,LifestageTrt, sep=":"))
                 trtGpRep &lt;- paste0(CN,LifestageTrt,":",RepNumber)
                 scTime &lt;- scale(TrtTime) })
HawMedbb.TMB &lt;- glmmTMB::glmmTMB(form, dispformula=~trtGp+splines::ns(scTime,2),
                                 family=glmmTMB::betabinomial(link="cloglog"),
                                 data=HawMed)
rho &lt;- qra::getRho(HawMedbb.TMB)} else
message("Example requires `glmmTMB` version &gt;= 1.1.2: not available")

</code></pre>

<hr>
<h2 id='getScaleCoef'>Extract scaling coefficients from vector returned by <code>scale()</code></h2><span id='topic+getScaleCoef'></span>

<h3>Description</h3>

<p>The function <code>scale()</code> replaces <code>x</code> by <code>(x-a)/b</code>,
where <code>a</code> is <code>mean(x)</code> and <code>b</code> is <code>sd(x)</code>.
The quantities <code>a</code> and <code>b</code> are available as attributes
of the object that is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getScaleCoef(z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getScaleCoef_+3A_z">z</code></td>
<td>
<p>Object returned by <code>scale()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use of a scaled explanatory variable can be helpful in getting a
model to fit.  The scaling coefficient(s) will then be needed when
the fitted model is used with explanatory variable values on the
original scale.
</p>


<h3>Value</h3>

<p>A vector, whose elements are the scaling coefficients
<code>a</code> and <code>b</code>, or if <code>scale=FALSE</code> then <code>a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- scale(1:10)
qra::getScaleCoef(z)
</code></pre>

<hr>
<h2 id='gpsWithin'>Use given vector to identify groups with specified categories</h2><span id='topic+gpsWithin'></span>

<h3>Description</h3>

<p>Any one-dimensional object whose values distinguish groups
may be supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpsWithin(x, f)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gpsWithin_+3A_x">x</code></td>
<td>
<p>One-dimensional object whose values distinguish
groups</p>
</td></tr>
<tr><td><code id="gpsWithin_+3A_f">f</code></td>
<td>
<p>One-dimensional object or list of objects, the
combinations of whose values specify categories within
which groups are to be defined.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector whose values, within each specified
category, run from  1 to the number of groups
</p>


<h3>Examples</h3>

<pre><code class='language-R'>repnum &lt;- with(qra::codling1988, gpsWithin(cultRep, Cultivar))
table(codling1988$Cultivar,repnum)

</code></pre>

<hr>
<h2 id='graphSum'>Draw graphs of insect mortality or other exposure-response data</h2><span id='topic+graphSum'></span>

<h3>Description</h3>

<p>Datasets that are in mind hold, for each replicate of
each combination of each of a several factors (e.g.,
species, lifestages, temperatures), mortalities for
each of a number of values of &quot;dose&quot;.  See for example
the dataset help page <code><a href="#topic+codling1989">codling1989</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graphSum(
  df,
  subSet = NULL,
  link = "cloglog",
  logScale = FALSE,
  dead = "Dead",
  tot = "Tot",
  dosevar = "logCT",
  Rep = "Rep",
  fitRep = NULL,
  fitPanel = NULL,
  byFacet = ~Species,
  layout = NULL,
  maint = "Codling Moth, MeBr",
  ptSize = 2,
  xzeroOffsetFrac = 0.08,
  yzeroOneOffsets = c(-0.08, 0.08),
  yEps = 0.005,
  xlab = expression(bold("CT ") * "(gm.h." * m^{     -3 } * ")"),
  ylabel = NULL,
  ytiklab = c(0.01, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.99)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graphSum_+3A_df">df</code></td>
<td>
<p>Data frame from which data will be taken</p>
</td></tr>
<tr><td><code id="graphSum_+3A_subset">subSet</code></td>
<td>
<p>NULL, or an expression, such  as for example
<code>expression(LifeStage=='Eggs')</code>) that evaluates to a logical that
specifies the required data subset.  If not NULL then the subsetting
information is pasted on after the main title</p>
</td></tr>
<tr><td><code id="graphSum_+3A_link">link</code></td>
<td>
<p>Link function. If character, obtain from <code><a href="stats.html#topic+make.link">make.link</a></code>.
Alternatively, a function may be supplied as argument.</p>
</td></tr>
<tr><td><code id="graphSum_+3A_logscale">logScale</code></td>
<td>
<p>Logical, indicating whether the dose ($x$-variable)
is on a log scale.</p>
</td></tr>
<tr><td><code id="graphSum_+3A_dead">dead</code></td>
<td>
<p>Character; name of column holding number dead</p>
</td></tr>
<tr><td><code id="graphSum_+3A_tot">tot</code></td>
<td>
<p>Character; column holding total number</p>
</td></tr>
<tr><td><code id="graphSum_+3A_dosevar">dosevar</code></td>
<td>
<p>Character; column holding &quot;dose&quot; values</p>
</td></tr>
<tr><td><code id="graphSum_+3A_rep">Rep</code></td>
<td>
<p>Character; NULL, or column holding replicate number, within panel</p>
</td></tr>
<tr><td><code id="graphSum_+3A_fitrep">fitRep</code></td>
<td>
<p>Character; NULL, or column holding replicate fitted values</p>
</td></tr>
<tr><td><code id="graphSum_+3A_fitpanel">fitPanel</code></td>
<td>
<p>Character; NULL, or column holding panel fitted values</p>
</td></tr>
<tr><td><code id="graphSum_+3A_byfacet">byFacet</code></td>
<td>
<p>Graphics formula specifying factor combination that
determines panel</p>
</td></tr>
<tr><td><code id="graphSum_+3A_layout">layout</code></td>
<td>
<p>Graphics formula that can be supplied to <code>grid_facet</code></p>
</td></tr>
<tr><td><code id="graphSum_+3A_maint">maint</code></td>
<td>
<p>Main title</p>
</td></tr>
<tr><td><code id="graphSum_+3A_ptsize">ptSize</code></td>
<td>
<p>Pointsize, by default 2</p>
</td></tr>
<tr><td><code id="graphSum_+3A_xzerooffsetfrac">xzeroOffsetFrac</code></td>
<td>
<p>$x$-axis zero offset fraction, required when
scale is logarithmic</p>
</td></tr>
<tr><td><code id="graphSum_+3A_yzerooneoffsets">yzeroOneOffsets</code></td>
<td>
<p>Length two vector, giving 0
100
mortalities, on the scale of the link function.</p>
</td></tr>
<tr><td><code id="graphSum_+3A_yeps">yEps</code></td>
<td>
<p>Fractional increase at bottom and top of $y$ user range
to accommodate points for mortalities of 0 and 1.</p>
</td></tr>
<tr><td><code id="graphSum_+3A_xlab">xlab</code></td>
<td>
<p>Expression specifying x-axis label</p>
</td></tr>
<tr><td><code id="graphSum_+3A_ylabel">ylabel</code></td>
<td>
<p>If not <code>NULL</code>, $y$-axis label</p>
</td></tr>
<tr><td><code id="graphSum_+3A_ytiklab">ytiklab</code></td>
<td>
<p>Place $y$ axis tiks and labels at these mortalities</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='HawCon'>
Hawaiian Contemporary Cold Treatment Dataset
</h2><span id='topic+HawCon'></span>

<h3>Description</h3>

<p>The counts of live/dead were derived by injecting a known number of individuals of the target life stage into citrus fruits, subjecting them to treatment and then counting the number of individuals emerging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HawCon")</code></pre>


<h3>Format</h3>

<p>A data frame with 106 observations on the following 10 variables.
</p>

<dl>
<dt><code>Species</code></dt><dd><p>Species of fruitfly</p>
</dd>
<dt><code>CN</code></dt><dd><p>Common name, in abbreviated form.
MedFly is &lsquo;Mediterranean Fruit Fly&rsquo;.  MelonFly is
&lsquo;Melon Fly&rsquo;</p>
</dd>
<dt><code>LifestageTrt</code></dt><dd><p>Lifestage treated</p>
</dd>
<dt><code>RepNumber</code></dt><dd><p>Replicate number</p>
</dd>
<dt><code>PropDead</code></dt><dd><p>Fraction dead</p>
</dd>
<dt><code>TrtTime</code></dt><dd><p>Treatment time (days)</p>
</dd>
<dt><code>Dead</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Live</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>Total</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>The help page for <code>HawCon</code> in the <span class="pkg">ColdData</span> has further
details.
</p>


<h3>Source</h3>

<p>Dr Peter Follett
</p>


<h3>References</h3>

<p>A paper is in the course of preparation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(HawCon)
str(HawCon)
</code></pre>

<hr>
<h2 id='kerrich'>
Kerrich Coin Toss Trial Outcomes
</h2><span id='topic+kerrich'></span>

<h3>Description</h3>

<p>A data set containing 2,000 trials of coin flips from statistician John Edmund Kerrich's 1940s experiments while imprisoned by the Nazis during World War Two.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("kerrich")</code></pre>


<h3>Format</h3>

<p>The format is:
List of 1
$ : chr [1:2000] &quot;0&quot; &quot;0&quot; &quot;0&quot; &quot;1&quot; ...
</p>


<h3>Source</h3>

<p><a href="https://en.wikipedia.org/wiki/John_Edmund_Kerrich">https://en.wikipedia.org/wiki/John_Edmund_Kerrich</a>
</p>


<h3>References</h3>

<p>Kerrich, J. E. (1950). An experimental introduction to the theory of probability. Belgisk Import Company.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(kerrich)
</code></pre>

<hr>
<h2 id='malesINfirst12'>
Number of males among first 12 in families of 13 children
</h2><span id='topic+malesINfirst12'></span>

<h3>Description</h3>

<p>The number of male children among the first 12 children of family size 13 in 6115 families taken from the hospital records in the nineteenth century Saxony (Lindsey (1995), p.59). The thirteenth child is ignored to assuage the effect of families non-randomly stopping when a desired gender is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("malesINfirst12")</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on the following 2 variables.
</p>

<dl>
<dt><code>No_of_Males</code></dt><dd><p>a numeric vector</p>
</dd>
<dt><code>freq</code></dt><dd><p>a numeric vector</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data are available in the <span class="pkg">fitODBOD</span> package.
</p>


<h3>Source</h3>

<p><span class="pkg">fitODBOD</span> package
</p>


<h3>References</h3>

<p>Edwards, A. W. F. (1958). An analysis of Geissler's data on the human sex ratio. Annals of human genetics, 23(1), 6-15.
</p>
<p>Geissler, A. (1889) Beiträge zur Frage des Geschlechtsverhältnisses der Geborenen. Z. Köngl. Sächs. Statist. Bur., 35,
1±24.
</p>
<p>Lindsey, J. K., &amp; Altham, P. M. E. (1998). Analysis of the human sex ratio by using overdispersion models. Journal of the Royal Statistical Society: Series C (Applied Statistics), 47(1), 149-157.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(malesINfirst12)
boxplot(freq ~ No_of_Males, data=malesINfirst12)
</code></pre>

<hr>
<h2 id='rayBlight'>
Incidence of ray blight disease of pyrethrum
</h2><span id='topic+rayBlight'></span>

<h3>Description</h3>

<p>An assessment of the incidence of ray blight disease of pyrethrum in 62 sampling units, containing 6 plants each.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("rayBlight")</code></pre>


<h3>Format</h3>

<p>The format is:
int [1:62] 4 6 6 6 6 6 6 6 4 6 ...
</p>


<h3>Source</h3>

<p><span class="pkg">epiphy</span> package.
</p>


<h3>References</h3>

<p>Pethybridge SJ, Esker P, Hay F, Wilson C, Nutter FW. 2005. Spatiotemporal description of epidemics caused by Phoma ligulicola in Tasmanian pyrethrum fields. Phytopathology 95, 648-658.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rayBlight)
barplot(table(rayBlight))
</code></pre>

<hr>
<h2 id='scaleLocAdjust'>Estimate dispersion as a function of predicted values</h2><span id='topic+scaleLocAdjust'></span>

<h3>Description</h3>

<p>A loess smooth is applied to the square roots of the standardized
deviance residuals. The inverses of values from the smooth, raised
to the power of <code>lambda</code>, are then used as prior weights to
update the model.  A value of <code>lambda</code> that is a little more
than 2.0 has often worked well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scaleLocAdjust(x, lambda = 2, span = 0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scaleLocAdjust_+3A_x">x</code></td>
<td>
<p>Model fitted using <code>glm</code> or, possibly <code>lm</code></p>
</td></tr>
<tr><td><code id="scaleLocAdjust_+3A_lambda">lambda</code></td>
<td>
<p>Power of smooth of square roots of absolute
values of residuals, to try for values whose inverses will
be used as weights</p>
</td></tr>
<tr><td><code id="scaleLocAdjust_+3A_span">span</code></td>
<td>
<p>span parameter for use in smoothing the square
root of standardized deviance residuals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is primarily for experimental use, in investigating
possible ways to model a dispersion factor that varies with the
fitted value.
</p>


<h3>Value</h3>

<p>A list, with elements
</p>
<table role = "presentation">
<tr><td><code>model</code></td>
<td>
<p>Model updated to use the newly calculated weights</p>
</td></tr>
<tr><td><code>estDisp</code></td>
<td>
<p>Estimated dispersions</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The dispersion estimates that correspond to the updated
model are obtained by dividing the dispersion value given
by <code>summary()</code> for the updated model by the (prior) weights
supplied when the model was updated. The approach for obtaining
varying dispersion estimates is used because, empirically, it
has been found to work well for at least some sets of data.  In
particular, there seems no obvious theoretical basis for the
choice of <code>lambda</code>.  In the example given, used because the
data is publicly available, the method has limited success.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDisp">checkDisp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ROYAL &lt;- subset(qra::codling1988, Cultivar=="ROYAL")
ROYAL.glm &lt;- glm(cbind(dead,total-dead)~ct, data=ROYAL,
                  family=quasibinomial(link='cloglog'))
ROYALFix &lt;- qra::scaleLocAdjust(ROYAL.glm)
## Check range of indicated prior weights
range(ROYALFix[[2]])
## Range of updated dispersion estimates
range(summary(ROYALFix[[1]])[['dispersion']]/ROYALFix[[2]])
</code></pre>

<hr>
<h2 id='varRatio'>First order approximation to variance of y-ordinate to slope ratio</h2><span id='topic+varRatio'></span>

<h3>Description</h3>

<p>In contexts where an LD99 estimate will be used as a data value
in a further analysis step, the inverse of the variance may be
used as a weight.  The y-ordinate is for the link function
transformed value of a specified mortality proportion, commonly
0.50, or 0.90, or 0.99
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varRatio(phat = 0.99, b, vv, link = "cloglog")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varRatio_+3A_phat">phat</code></td>
<td>
<p>Mortality proportion</p>
</td></tr>
<tr><td><code id="varRatio_+3A_b">b</code></td>
<td>
<p>Length 2 vector of intercept and slope</p>
</td></tr>
<tr><td><code id="varRatio_+3A_vv">vv</code></td>
<td>
<p>Variance-covariance matrix for intercept and slope</p>
</td></tr>
<tr><td><code id="varRatio_+3A_link">link</code></td>
<td>
<p>Link function that transforms expected mortalities
to the scale of the linear predictor</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function should only be used, in order to speed up
calculations that use the function <code><a href="#topic+fieller">fieller</a></code>
(call <code>fieller</code> with (<code>type="Delta"</code>)),
in a context where it is to be used many times,
and where a check has been made that its use leads to
confidence intervals that are a close approximation to those
given with the default argument (<code>type="Fieller"</code>).
</p>


<h3>Value</h3>

<p>A vector, with elements
</p>
<table role = "presentation">
<tr><td><code>xhat</code></td>
<td>
<p>Estimate</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>Variance, calculated using the Delta method,  See
the help page for <code><a href="#topic+fieller">fieller</a></code> for further details
and references.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>redDel &lt;- subset(qra::codling1988, Cultivar=="Red Delicious")
redDel.glm &lt;- glm(cbind(dead,total-dead)~ct, data=redDel,
                  family=quasibinomial(link='cloglog'))
vv &lt;- summary(redDel.glm)$cov.scaled
qra::varRatio(0.99, b=coef(redDel.glm), vv=vv, link="cloglog")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
