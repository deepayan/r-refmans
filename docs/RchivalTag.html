<!DOCTYPE html><html><head><title>Help for package RchivalTag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RchivalTag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bin_TempTS'>
<p>bin depth-temperature time series data</p></a></li>
<li><a href='#classify_DayTime'>
<p>Classifying the time period of the day</p></a></li>
<li><a href='#combine_histos'>
<p>combine lists of TAD/TAT frequency data</p></a></li>
<li><a href='#dy_DepthTS'>
<p>plot time series data via the dygraphs interactive time series plotting interface.</p></a></li>
<li><a href='#get_DayTimeLimits'>
<p>Estimating the timing of sunrise, sunset, astronomical and nautical twilight events</p></a></li>
<li><a href='#get_thermalstrat'>
<p>estimate thermal stratification indices</p></a></li>
<li><a href='#ggboxplot_DepthTS_by_hour'>
<p>Boxplot on hourly aggregated DepthTS records</p></a></li>
<li><a href='#ggplot_geopos'>
<p>reads and plots geolocation estimates derived from archival tagging data</p></a></li>
<li><a href='#ggplotly_geopos'>
<p>Converts a ggplot2 object from ggplot_geopos() to plotly</p></a></li>
<li><a href='#hist_tad'>
<p>Time-at-Depth histogram</p></a></li>
<li><a href='#hist_tat'>
<p>Time-at-Temperature histogram</p></a></li>
<li><a href='#image_TempDepthProfiles'>
<p>plots interpolated daily temperature at depth profiles</p></a></li>
<li><a href='#interpolate_TempDepthProfiles'>
<p>interpolate daily temperature at depth profiles</p></a></li>
<li><a href='#leaflet_geopos'>
<p>reads and plots geolocation estimates derived from archival tagging data</p></a></li>
<li><a href='#merge_histos'>
<p>merge and/or rebin TAD/TAT-frequency data</p></a></li>
<li><a href='#plot_data_coverage'>
<p>Abacus plot to illustrate the data coverage of different data products per tag throughout their deployment period.</p></a></li>
<li><a href='#plot_DepthTempTS'>
<p>plot Depth Temperature time series data</p></a></li>
<li><a href='#plot_TS'>
<p>plot time series data</p></a></li>
<li><a href='#RchivalTag'>
<p>RchivalTag - Analyzing and Interactive Visualization of Archival Tagging Data</p></a></li>
<li><a href='#read_histos'>
<p>reads a TAD/TAT-histogram file from archival tags</p></a></li>
<li><a href='#read_PDT'>
<p>read PDT data from archival one or multiple tags</p></a></li>
<li><a href='#read_TS'>
<p>reads Time Series Data from Archival Tags</p></a></li>
<li><a href='#resample_PDT'>
<p>resample temperature at depth data from interpolated daily temperature at depth profiles or time series data</p></a></li>
<li><a href='#resample_TS'>
<p>resample time series data at a lower resolution</p></a></li>
<li><a href='#simulate_DepthTS'>
<p>simulate depth time series data</p></a></li>
<li><a href='#ts2histos'>
<p>convert depth and temperature time series data to discrete Time-at-Depth and Time-at-Temperature data (histogram data)</p></a></li>
<li><a href='#unmerge_histos'>
<p>unmerge previously grouped or merged lists of TAD/TAT frequency data</p></a></li>
<li><a href='#update_leaflet_elementId'>
<p>update elementID of the leaflet map to avoid rendering issues in RMarkdown</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analyzing and Interactive Visualization of Archival Tagging Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-10</td>
</tr>
<tr>
<td>Author:</td>
<td>Robert K. Bauer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robert K. Bauer &lt;rkbauer@hawaii.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to generate, access and analyze standard data products from archival tagging data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), maps, mapdata, leaflet</td>
</tr>
<tr>
<td>Imports:</td>
<td>plyr, oceanmap, cleangeo, suntools, graphics, stats, raster,
readr, ncdf4, pracma, dygraphs, xts, lubridate, shiny,
htmlwidgets, stringr, grDevices, sp, methods, ggplot2, ggedit,
plotly, leaflet.extras2, sf</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-10 10:43:19 UTC; work</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-10 11:40:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='bin_TempTS'>
bin depth-temperature time series data
</h2><span id='topic+bin_TempTS'></span>

<h3>Description</h3>

<p>bins depth-temperature time series data to a user-defined resolution, returning the minimum, maxmium and average temperature recorded at each depth interval (bin) per sampling day. The output is comparable to that of <a href="#topic+read_PDT">read_PDT</a>.
<br /><br /><strong>Why binning temperature data?</strong><br />
In case of archival tagging data, depth-temperature time series data at a given day may consist of multiple tempertaure profiles of different signatures, depending on the animal's behaviour. Slight differences in temperature profiles could impede further analyses (e.g. the estimation of the thermocline depth), if just the average profile is applied. To avoid such problmes, it is useful to calculate the average temperature at given depth intervals (bins) and thus smooth temperature profiles of a given period.
</p>
<p>In addition, temperature at depth profiles can be interpolated and then visualized using functions <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a> and <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a>, respectively. This faciliates the analysis of temporal changes of temperature profiles, for instance, in relation to animal behaviour (e.g. diving behaviour).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_TempTS(ts, res=8, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_TempTS_+3A_ts">ts</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> with columns <code>date</code>, <code>Depth</code> and <code>Temperature</code>
</p>
</td></tr>
<tr><td><code id="bin_TempTS_+3A_res">res</code></td>
<td>
<p>the depth interval at which temperatures should be binned.
</p>
</td></tr>
<tr><td><code id="bin_TempTS_+3A_verbose">verbose</code></td>
<td>

<p>whether the sampling dates should be indicated during the binning process (by default <code>FALSE</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the columns <code>date</code>, <code>MeanTemp</code>, <code>MinTemp</code>, <code>MaxTemp</code>, <code>bin</code> and <code>MeanPDT</code> (the latter being the average of the min and maximum water temperatures). Additional columns, used to distinguish tags, may include <code>Serial</code>, <code>DeployID</code> and <code>Ptt</code>, depending on their availability in the original ts-data.fralme.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_PDT">read_PDT</a>, <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# #### example 1) run on time series data:
## step I) read sample time series data file:
DepthTempTS &lt;- read.table(system.file("example_files/104659-Series.csv",
                                       package="RchivalTag"),header = TRUE,sep=',')
DepthTempTS$date &lt;- as.Date(DepthTempTS$Day,"%d-%b-%Y")
head(DepthTempTS)
# 
# 
# ## step Ib) bin temperature data on 10m depth bins 
# ##          to increase later estimate accuracy (see Bauer et al. 2015):
# # DepthTempTS_binned &lt;- bin_TempTS(DepthTempTS,res=10)
# 
# ## step II) interpolate average temperature fields (MeanTemp) from binned data:
# m &lt;- interpolate_TempDepthProfiles(DepthTempTS)
# # m &lt;- interpolate_PDTs(DepthTempTS_binned)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# ## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)

</code></pre>

<hr>
<h2 id='classify_DayTime'>
Classifying the time period of the day
</h2><span id='topic+classify_DayTime'></span>

<h3>Description</h3>

<p>Classifying the time period of the day based on the timing of sunrise, sunset (and twilight events) or alternatively, geolocation estimates, as specified in <a href="#topic+get_DayTimeLimits">get_DayTimeLimits</a>, that allow their internal estimation during the function call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_DayTime(pos, twilight.set="ast")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classify_DayTime_+3A_pos">pos</code></td>
<td>

<p>A <a href="base.html#topic+data.frame">data.frame</a> <code>pos</code> with the columns <code>sunrise</code>, <code>sunset</code>, <code>dawn.ast</code>,/<code>dawn.naut</code> and <code>dawn.ast</code>/<code>dawn.naut</code> in <code>POSIXct</code>-format. Note that the expected twilight vector (suffix <code>"ast"</code> for astronomical dawn and dusks; vs suffix <code>"naut"</code> for nautical twilight events) is defined by the function's second argument <code>twilight.set</code> (see description below).
</p>
</td></tr>
<tr><td><code id="classify_DayTime_+3A_twilight.set">twilight.set</code></td>
<td>

<p>character string, indicating the type of twilight used for the long daytime classifcation: <code>"ast"</code> (default) for astronomical and <code>"naut"</code> for nautical twilight events with sun angles of 18 vs 12 below the horizon, respectvely. Corresponding (expected) dawn and dusk vector names are <code>dawn.ast</code> &amp; <code>dusk.ast</code> vs <code>dawn.naut</code> &amp; <code>dusk.naut</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <a href="base.html#topic+data.frame">data.frame</a> <code>pos</code> extended by the time vectors <code>daytime</code> and <code>daytime.long</code>. In the former case, &quot;Day&quot; and &quot;Night&quot; periods are distinguished. In the latter case, &quot;Day&quot;, &quot;Night&quot;, &quot;Dawn&quot; and &quot;Dusk&quot;.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Meeus, J. (1991) Astronomical Algorithms. Willmann-Bell, Inc.
</p>


<h3>See Also</h3>

<p><a href="maptools.html#topic+sunriset">sunriset</a>, <a href="maptools.html#topic+crepuscule">crepuscule</a>, <a href="#topic+get_DayTimeLimits">get_DayTimeLimits</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### example 1) estimate current times of dawn, sunrise, dusk and sunset in Mainz, Germany:
pos &lt;- data.frame(Lat=8.2667, Lon=50)
pos$datetime &lt;- strptime(Sys.Date(),"%Y-%m-%d")
get_DayTimeLimits(pos)

#### example 1b) classify current ime of the day in Mainz, Germany:
classify_DayTime(get_DayTimeLimits(pos))

## convert 1c) back-to-back histogram showing day vs night TAD frequencies:
### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read.table(ts_file, header = TRUE, sep = ",")
tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)

ts_df$Lat &lt;- 4; ts_df$Lon=42.5 ## required geolocations to estimate daytime
ts_df$datetime &lt;- strptime(paste(ts_df$Day,ts_df$Time),"%d-%B-%Y %H:%M:%S")
head(ts_df)
ts_df2 &lt;- classify_DayTime(get_DayTimeLimits(ts_df)) # estimate daytime
head(ts_df2)

ts2histos(ts_df2, tad_breaks = tad_breaks,split_by = "daytime")
hist_tad(ts_df2, bin_breaks = tad_breaks,split_by = "daytime", do_mid.ticks = FALSE)


</code></pre>

<hr>
<h2 id='combine_histos'>
combine lists of TAD/TAT frequency data
</h2><span id='topic+combine_histos'></span>

<h3>Description</h3>

<p>This function allows to combine seperate lists of TAD/TAT frequency data from archival tags (i.e. by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>). The function requires ungrouped/unmerged TAD/TAT lists to avoid merging duplicate records (e.g. multiple TAD/TAT lists from the same individual). However, grouped/merged lists with TAD/TAT from multiple individuals and even duplicate records can be provided, as the function includes an internal call of <a href="#topic+unmerge_histos">unmerge_histos</a> to meet this requirement.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_histos(hist_list1, hist_list2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_histos_+3A_hist_list1">hist_list1</code>, <code id="combine_histos_+3A_hist_list2">hist_list2</code></td>
<td>

<p>Two list-of-lists to be combined, each containing TAD and TAT frequency data and the corresponding <code>bin_breaks</code> from one or several archival tags.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-of-lists of ungrouped/unmerged TAD and TAT frequency data.
</p>
<p>$ TAD:List<br />
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br />
$ TAT:List<br /> 
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br /> 
..$ ID2  : List of 2<br />
...
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+unmerge_histos">unmerge_histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tad">hist_tad</a>, <a href="#topic+hist_tat">hist_tat</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example 1) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)
</code></pre>

<hr>
<h2 id='dy_DepthTS'>
plot time series data via the dygraphs interactive time series plotting interface.
</h2><span id='topic+dy_DepthTS'></span><span id='topic+dy_TS'></span>

<h3>Description</h3>

<p>plot time series data (e.g. depth or temperature time series data from archival tags) via the dygraphs interactive time series plotting interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dy_TS(ts_df, y="Depth", xlim, ylim, 
           ylab=y, xlab, main,
           ID, ID_label="Serial", 
           plot_DayTimePeriods=TRUE, twilight.set="ast", 
           color="darkblue",
           doRangeSelector=TRUE, drawPoints=FALSE, pointSize=2, tz="UTC",...)


dy_DepthTS(ts_df, y="Depth", xlim, ylim, 
           ylab=y, xlab, main,
           ID, ID_label="Serial", 
           plot_DayTimePeriods=TRUE, twilight.set="ast", 
           color="darkblue",
           doRangeSelector=TRUE, drawPoints=FALSE, pointSize=2, tz="UTC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dy_DepthTS_+3A_ts_df">ts_df</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> holding the time series data to be plotted, including the x-vector 'datetime' (in <code>POSIXct</code>-format  and UTC), and the numeric y-vector whose label is defined by <code>y</code>.
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_y">y</code></td>
<td>
<p>character label of time series vector to be plotted (by default 'Depth').
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot (by default range(ts_df$datetime), but needs to be specified in <code>empty.plot_TS</code>).
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot (by default range(ts_df[[y]]), but needs to be specified in <code>empty.plot_TS</code>).
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_ylab">ylab</code>, <code id="dy_DepthTS_+3A_xlab">xlab</code></td>
<td>

<p>the y- and x-axis labels. 
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_main">main</code></td>
<td>

<p>main title (by default &quot;Tag ID&quot;) for the plot).
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_id">ID</code>, <code id="dy_DepthTS_+3A_id_label">ID_label</code></td>
<td>

<p>Tag ID and its label (column name; by default &quot;Serial&quot;) to be selected (e.g. if input data frame holds tagging data from several tags).
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_plot_daytimeperiods">plot_DayTimePeriods</code>, <code id="dy_DepthTS_+3A_twilight.set">twilight.set</code></td>
<td>

<p>whether day-time periods ('Night', 'Dawn', 'Day', 'Dusk') should be plotted as shaded areas. In case that <code>plot_DayTimePeriods</code> is set <code>TRUE</code>), the limits of each time period are required (columns <code>sunrise</code>, <code>sunset</code>, <code>dawn.ast</code>,/<code>dawn.naut</code> and <code>dawn.ast</code>/<code>dawn.naut</code> in <code>POSIXct</code>-format. In case of the twilight events, the additional argument <code>twilight.set</code> defines the suffix of the twlight-set to be selected ( <code>"ast"</code> for astronomical dawn and dusks vs <code>"naut"</code> for nautical twilight events).
If any of the day-time columns, described above, is missing, it/they will be calculated based on geolocation estimates (required columns <code>Lon</code> and <code>Lat</code>) through an internal call of function <code>get_DayTimeLimits</code>.<br />
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_color">color</code></td>
<td>

<p>color of the line to be plotted (by default &quot;darkblue&quot;)
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_dorangeselector">doRangeSelector</code></td>
<td>

<p>whether to add dygraph interactive range selection and zooming bar below the figure (by default <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_drawpoints">drawPoints</code>, <code id="dy_DepthTS_+3A_pointsize">pointSize</code></td>
<td>

<p>Whether to indicate add points to the figure at the sampling time steps as well their size.
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_tz">tz</code></td>
<td>

<p>The time zone in which the data should be illustrated (By default &quot;UTC&quot;). ATTENTION: The required date format of the input data is &quot;UTC&quot; (across all RchivalTag-functions). Run <code>OlsonNames(tzdir = NULL)</code> for valid time zone definitions.
</p>
</td></tr>
<tr><td><code id="dy_DepthTS_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to dygraph.Further arguments can be passed after the function call, e.g. via dyOptions.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An interactive dygraph plot object that can be altered further using for exemple the dyOptions.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_TS">plot_TS</a>, <a href="#topic+plot_DepthTempTS">plot_DepthTempTS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
# ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
# ts_df &lt;- read_TS(ts_file)
# ts_df$Serial &lt;- ts_df$DeployID
# head(ts_df)

## plot depth-time series data
# dy_DepthTS(ts_df)

## add missing Lon, Lat information for night-time and twilight shadings
# ts_df$Lon &lt;- 5; ts_df$Lat &lt;- 43

# dy_DepthTS(ts_df)

## same figure with plot_DepthTS:
# plot_DepthTS(ts_df, plot_DayTimePeriods = TRUE)

## some further arguments:
# dy_DepthTS(ts_df, xlim = unique(ts_df$date)[2:3], plot_DayTimePeriods = FALSE)

## add further options via dyOptions-call:
# dg &lt;- dy_DepthTS(ts_df, xlim = unique(ts_df$date)[2:3], 
#                  plot_DayTimePeriods = FALSE, drawPoints = TRUE)
# dg &lt;- dyOptions(dg,drawGrid=FALSE)
# dg

</code></pre>

<hr>
<h2 id='get_DayTimeLimits'>
Estimating the timing of sunrise, sunset, astronomical and nautical twilight events
</h2><span id='topic+get_DayTimeLimits'></span>

<h3>Description</h3>

<p>Estimating the timing of sunrise, sunset, astronomical and nautical twilight events in <code>POSIXct</code>-format based on geolocations and a similar time vector. The function is a simplified call of the <a href="maptools.html#topic+sunriset">sunriset</a> and <a href="maptools.html#topic+crepuscule">crepuscule</a> functions of the maptools-package that are based on algorithms provided by the National Oceanic &amp; Atmospheric Administration (NOAA). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_DayTimeLimits(pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_DayTimeLimits_+3A_pos">pos</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> with the columns <code>datetime</code> (a time vector in <code>POSIXct</code>-format), <code>Lon</code> and <code>Lat</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input <a href="base.html#topic+data.frame">data.frame</a> <code>pos</code> extended by the time vectors <code>sunrise</code>, <code>sunset</code>, <code>dawn.naut</code>, <code>dawn.ast</code>, <code>dusk.naut</code> and <code>dusk.ast</code>.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Meeus, J. (1991) Astronomical Algorithms. Willmann-Bell, Inc.
</p>


<h3>See Also</h3>

<p><a href="maptools.html#topic+sunriset">sunriset</a>, <a href="maptools.html#topic+crepuscule">crepuscule</a>, <a href="#topic+classify_DayTime">classify_DayTime</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### example 1) estimate current times of dawn, sunrise, dusk and sunset in Mainz, Germany:
pos &lt;- data.frame(Lat=8.2667, Lon=50)
pos$datetime &lt;- strptime(Sys.Date(),"%Y-%m-%d")
get_DayTimeLimits(pos)

#### example 1b) classify current ime of the day in Mainz, Germany:
classify_DayTime(get_DayTimeLimits(pos))


</code></pre>

<hr>
<h2 id='get_thermalstrat'>
estimate thermal stratification indices
</h2><span id='topic+get_thermalstrat'></span>

<h3>Description</h3>

<p>estimates thermal stratification indices, including thermocline depth, gradient, mixed later depth and stratifcation index from daily temperature at depth profiles, as illustrated by Bauer et al. (2015) for archival tagging data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_thermalstrat(x, dz=20, strat_lim=100, na.rm=FALSE, 
                 verbose=TRUE, Depth_res, all_info=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_thermalstrat_+3A_x">x</code></td>
<td>
<p>A list generated by <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, containing interpolated temperature at depth profiles and their corresponding date and depth vectors:
</p>
<p>$ Data_Source.ID_key:List of 3<br />
..$ Temperature_matrix: num<br />
..$ Depth             : num<br /> 
..$ Date              :Date<br />
..$ sm                :data.frame<br />  
.. ..$ Date              :chr<br />
.. ..$ nrecs            :int<br />
.. ..$ Depths           :chr<br />
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_dz">dz</code></td>
<td>

<p>size of the moving window in meters between which temperature values should be compared for the estimation of the thermocline gradient and depth (by default 20).
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_na.rm">na.rm</code></td>
<td>

<p>whether interpolated temperature at depth profiles with missing values should be treated (default is <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_strat_lim">strat_lim</code></td>
<td>

<p>up to which depth (in meters) temperature values should be considered for the estimation of the stratication index (by default 100).
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_depth_res">Depth_res</code></td>
<td>

<p>numeric value, defining the depth resolution at which the temperature data should be interpolated.
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_verbose">verbose</code></td>
<td>

<p>whether the process of the function run should be indicated (by default TRUE).
</p>
</td></tr>
<tr><td><code id="get_thermalstrat_+3A_all_info">all_info</code></td>
<td>

<p>whether the summary information of the input file should be generated in the output (by default FALSE).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="base.html#topic+data.frame">data.frame</a> composed of 
</p>

<dl>
<dt><code>Date</code></dt><dd><p>a date vector (see input argument <code>x</code>)</p>
</dd>
<dt><code>maxDepth_interp</code></dt><dd><p>the maxmium depth (in meters) of a daily temperature at depth profile to which its interpolation is limitied)</p>
</dd>
<dt><code>tgrad</code></dt><dd><p>the maximum temperature gradient of all possible moving windows of size <code>dz</code>)</p>
</dd>
<dt><code>tcline</code></dt><dd><p>the thermocline depth, defined as the average depth (of the depth range) of the moving window(s) with the maximum temperature gradient <code>tgrad</code>)</p>
</dd>
<dt><code>dz</code></dt><dd><p>size of the moving window in meters between which temperature values were compared</p>
</dd>
<dt><code>mld</code></dt><dd><p>mixed layer depth, defined as the average depth of the first moving window that meets maximum temperature gradient criterium)
</p>
</dd>
<dt><code>mld_0.5</code></dt><dd><p>mixed layer depth, defined as as the depth at which T = SST-0.5 degrees, the temperature criterion of Monterey and Levitus (1997).
</p>
</dd>
<dt><code>mld_0.8</code></dt><dd><p>mixed layer depth, defined as the depth at which T = SST-0.8 degrees, the temperature criterion of Kara et al. (2000, 2003).
</p>
</dd>
<dt><code>strat_index</code></dt><dd><p>stratification index, defined as the standard deviation of all interpolated temperature values up to the depth defined by the argument <code>strat_lim</code></p>
</dd>
<dt>...</dt><dd>
<p>optional columns to be taken from the <code>sm</code> data.frame of the input list (in case that <code>all_info=TRUE</code>)</p>

<dl>
<dt><code>nrecs</code></dt><dd><p>number of records of the non-interpolated daily temperature at depth profiles</p>
</dd>
<dt><code>Depths</code></dt><dd><p>unique depth records of the non-interpolated daily temperature at depth profiles, seperated by '; '</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>
<p>Kara, A. B., P. A. Rochford, and H. E. Hurlburt (2000). An optimal definition for ocean mixed layer depth. Journal of Geophysical Research, 105:16803-16821, <a href="https://doi.org/10.1029/2000JC900072">doi:10.1029/2000JC900072</a>
</p>
<p>Kara, A. B., P. A. Rochford, and H. E. Hurlburt (2003) Mixed layer depth variability over the global ocean. Journal of Geophysical Research, 108:3079, <a href="https://doi.org/10.1029/2000JC000736">doi:10.1029/2000JC000736</a>
</p>
<p>Monterey, G., and S. Levitus (1997) Seasonal variability of mixed layer depth for the world ocean. NOAA Atlas NESDIS 14, U. S. Govt. Printing Office.
</p>


<h3>See Also</h3>

<p><a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example 1) run on PDT file:
## step I) read sample PDT data file:
path &lt;- system.file("example_files",package="RchivalTag")
PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
head(PDT)
# 
# ## step II) interpolate average temperature fields (MeanPDT) from PDT file:
# m &lt;- interpolate_PDTs(PDT)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# 
# #### example 2) run on time series data:
# ## step I) read sample time series data file:
# DepthTempTS &lt;- read.table(system.file("example_files/104659-Series.csv",
#                                       package="RchivalTag"),header = TRUE,sep=',')
# DepthTempTS$date &lt;- as.Date(DepthTempTS$Day,"%d-%b-%Y")
# head(DepthTempTS)
# 
# 
# ## step Ib) bin temperature data on 10m depth bins 
# ##          to increase later estimate accuracy (see Bauer et al. 2015):
# # DepthTempTS_binned &lt;- bin_TempTS(DepthTempTS,res=10)
# 
# ## step II) interpolate average temperature fields (MeanTemp) from binned data:
# m &lt;- interpolate_TempDepthProfiles(DepthTempTS)
# # m &lt;- interpolate_PDTs(DepthTempTS_binned)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)


</code></pre>

<hr>
<h2 id='ggboxplot_DepthTS_by_hour'>
Boxplot on hourly aggregated DepthTS records
</h2><span id='topic+ggboxplot_DepthTS_by_hour'></span>

<h3>Description</h3>

<p>This function creates a boxplot via the ggplot library from hourly aggregated DepthTS records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggboxplot_DepthTS_by_hour(ts_df, ylim, min_perc=75,
                          main="", submain, add_ids_to_submain=FALSE, xlab,
                          ID, ID_label="Serial",
                          plot_DayTimePeriods=TRUE, twilight.set="ast",
                          box=TRUE, jitter=FALSE, 
                          color_by=ID_label, cb.title=color_by,
                          pal, opacity=0.1,tz="UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_ts_df">ts_df</code></td>
<td>

<p><code>data.frame</code> with DepthTS data, 
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_ylim">ylim</code></td>
<td>

<p>limits of the y-axis.  
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_min_perc">min_perc</code></td>
<td>

<p>the minimum data coverage (in percent) of daily DepthTS recoords (by default 75%).
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_main">main</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_submain">submain</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_add_ids_to_submain">add_ids_to_submain</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_xlab">xlab</code></td>
<td>

<p>The title and subtitle of the figure as well as the label of the x-axis.
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_id">ID</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_id_label">ID_label</code></td>
<td>

<p>Tag ID and its label (column name; by default &quot;Serial&quot;) to be selected (e.g. if input data frame holds tagging data from several tags).
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_plot_daytimeperiods">plot_DayTimePeriods</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_twilight.set">twilight.set</code></td>
<td>

<p>whether day-time periods ('Night', 'Dawn', 'Day', 'Dusk') should be plotted as shaded areas. In case that <code>plot_DayTimePeriods</code> is set <code>TRUE</code>), the limits of each time period are required (columns <code>sunrise</code>, <code>sunset</code>, <code>dawn.ast</code>,/<code>dawn.naut</code> and <code>dawn.ast</code>/<code>dawn.naut</code> in <code>POSIXct</code>-format. In case of the twilight events, the additional argument <code>twilight.set</code> defines the suffix of the twlight-set to be selected ( <code>"ast"</code> for astronomical dawn and dusks vs <code>"naut"</code> for nautical twilight events).
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_box">box</code></td>
<td>

<p>whether to draw a box around the figure (by default <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_jitter">jitter</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_color_by">color_by</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_cb.title">cb.title</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_pal">pal</code>, <code id="ggboxplot_DepthTS_by_hour_+3A_opacity">opacity</code></td>
<td>

<p>whether to draw all Depth records on top of the boxplot (by default <code>FALSE</code>).
If selected, records will be colored via the different groups in the column specified in <code>color_by</code> with colors specified by the color palette <code>pal</code> and the opacity value between 0 (transparent) and 1 (solid). 
</p>
</td></tr>
<tr><td><code id="ggboxplot_DepthTS_by_hour_+3A_tz">tz</code></td>
<td>

<p>The time zone in which the data should be illustrated (By default &quot;UTC&quot;). ATTENTION: The required date format of the input data is &quot;UTC&quot; (across all RchivalTag-functions). Run <code>OlsonNames(tzdir = NULL)</code> for valid time zone definitions. Be aware that changes of the time zone will alter the internal date definition and thus may result in different datasets to be displayed (depending on the <code>min_perc</code> requirements). This concerns mainly partially transmitted data sets.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+hist_tad">hist_tad</a>, <a href="#topic+plot_DepthTS">plot_DepthTS</a>, <a href="#topic+dy_DepthTS">dy_DepthTS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
# ts_df &lt;- read_TS(ts_file)
# ggboxplot_DepthTS_by_hour(ts_df)
# 
# ## Let's add position data to obtain twilight and nighttime shadings:
# 
# ts_df$Lon &lt;- 5; ts_df$Lat &lt;- 43
# ts_df2 &lt;- get_DayTimeLimits(ts_df)
# ggboxplot_DepthTS_by_hour(ts_df2,ylim=c(0,100))
# 
# ### Let's add the actual depth records on top of the boxplot
# ###(only meaningful in case of few amounts of data):
# 
# ggboxplot_DepthTS_by_hour(ts_df2,jitter = T,opacity = 0.1)
</code></pre>

<hr>
<h2 id='ggplot_geopos'>
reads and plots geolocation estimates derived from archival tagging data
</h2><span id='topic+ggplot_geopos'></span><span id='topic+get_geopos'></span>

<h3>Description</h3>

<p>In case that geolocations are provided by csv-files or data frames, line and scatter plots are implemented.
If ncdf-files or kmz-files, generated by the <a href="https://my.wildlifecomputers.com/">Wildlife Computers-data portal</a>, are selected, a <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a> will be created and a surface probability maps are illustrated. The netcdf transformation procedure is based on the R-code given in the <a href="https://static.wildlifecomputers.com/manuals/Location-Processing-User-Guide.pdf">location processing user guide</a> by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>. The kmz-files already include the contour lines of the 50, 95 and 99% likelihood areas that are being extracted and likewise transformed to a <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a>. In case of kmz-files, no other areas can be selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_geopos(x, ggobj, xlim, ylim, zlim, standard_year=FALSE, 
              full_year=standard_year, date_format, lang_format="en", tz="UTC", 
              Breaks, cb.title, cb.date_format, cbpos, cb.height = 10, cb.xlab = "",
              cb.reverse=FALSE, pal.reverse=cb.reverse, prob_lim=.75, color_by="date", 
              pal, alpha=70, type="p",
              main ,lwd=1, size=2, shape=19, verbose= FALSE, ...)
            
get_geopos(x, xlim, ylim, date_format, lang_format="en", tz="UTC", 
           proj4string, prob_lim=.5,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_geopos_+3A_x">x</code></td>
<td>

<p><a href="base.html#topic+data.frame">data.frame</a> containing horziontal position records (allowed column names are 'Most.Likely.Longitude', 'Longitude' or 'Lon' and 'Most.Likely.Latitude', 'Latitude' or 'Lat', respectively. path and file name of <code>.csv</code>, <code>.kmz</code>, <code>.kml</code> or <code>.nc</code>-files, or a loaded nc-file via <code>get_geopos</code>.
</p>
<p>Please note that netcdf- and kmz-file outputs from similiar probability thresholds (e.g. 0.50) may differ due to differences in the generation algorithm.
</p>
<p>Please also note that the kmz-files from WC include only a subsample (up to 50) of the GPE3 likelihood areas. The kmz-file transformation is very fast, but due to the limitation stated above, only recommended for display purposes. Please contact WC if you need the complete GPE3 likelihood areas or use the netcdf-file transformation.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_ggobj">ggobj</code></td>
<td>

<p>ggplot object.
</p>
</td></tr>



<tr><td><code id="ggplot_geopos_+3A_xlim">xlim</code>, <code id="ggplot_geopos_+3A_ylim">ylim</code></td>
<td>

<p>Numeric vector, defining the limts of the x and y-axes.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_zlim">zlim</code>, <code id="ggplot_geopos_+3A_breaks">Breaks</code>, <code id="ggplot_geopos_+3A_standard_year">standard_year</code>, <code id="ggplot_geopos_+3A_full_year">full_year</code></td>
<td>

<p>date range and breaks of the colorbar. If standard_year is set <code>TRUE</code>, positions are standardized on a yearly basis and tick breaks are ignored.
If full_year is set <code>TRUE</code> as well, the color scale will cover all months from January until December.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_date_format">date_format</code>, <code id="ggplot_geopos_+3A_lang_format">lang_format</code>, <code id="ggplot_geopos_+3A_tz">tz</code></td>
<td>

<p>character strings indicating the date format, language format and the corresponding time zone, defined by the vectors Date and Time (by default: date_format=&quot;%d-%b-%Y %H:%M:%S&quot;, lang_format=&quot;en&quot;, tz='UTC')
If formatting fails, please check as well the input language format, defined by <code>lang_format</code> (and use abbrviations such as &quot;en&quot; for English,&quot;es&quot; for Spanish, &quot;fr&quot; for French, etc.) as well.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_proj4string">proj4string</code></td>
<td>

<p>Coordinate reference system (CRS; projection).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_cb.title">cb.title</code></td>
<td>

<p>character string indicating the title of the colorbar (by default <code>'Date'</code>.)
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_cb.date_format">cb.date_format</code></td>
<td>

<p>character strings indicating the date format of the color bar ticks (by default &quot;%Y-%m-%d&quot;).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_cbpos">cbpos</code>, <code id="ggplot_geopos_+3A_cb.xlab">cb.xlab</code>, <code id="ggplot_geopos_+3A_cb.height">cb.height</code></td>
<td>

<p>position, xlab and height of the colorbar
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_prob_lim">prob_lim</code></td>
<td>

<p>in case that a kmz, kml, or netcdf-file (.nc) is selected, the value defines the limit of the probability surfaces in % (By default 0.50 for 50%). Note that in case of kmz, kml-files valid values are 0.50, 0.95 or 0.99). Otherwise ignored.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_color_by">color_by</code></td>
<td>

<p>colomn or vector by which the geolocations should be colored (by default <code>"date"</code>).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_pal">pal</code></td>
<td>

<p>color map to be plotted in case of polygon (.nc-files) or scatter plots (default is the 'jet'-colormap, and 'year.jet' in case <code>standard_year</code> &amp; <code>full_year</code> are set <code>TRUE</code>). See cmap for pre-installed color maps. Note that tracking data with constant time steps is being assumed in the color assignment. To verify this, a <a href="base.html#topic+data.frame">data.frame</a> containing the colors at each time steps will be returned for polygon and scatter plots.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_cb.reverse">cb.reverse</code>, <code id="ggplot_geopos_+3A_pal.reverse">pal.reverse</code></td>
<td>

<p>inverse order of ticks and colormap of colorscale.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_alpha">alpha</code></td>
<td>
<p>transparency of polygons and dots to be plotted in percent (By default 70%).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_type">type</code></td>
<td>

<p>character string giving the type of plot desired. The following values are possible, for details (By default &quot;p&quot; for points, but &quot;l&quot; for lines is also implemented).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_size">size</code>, <code id="ggplot_geopos_+3A_shape">shape</code></td>
<td>

<p>size and dot-type (by default '19' for solid dots) of the points to be plotted (requires <code>'type'</code> set to points or line-points).
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_lwd">lwd</code></td>
<td>

<p>line width
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <a href="oceanmap.html#topic+ggplotmap">ggplotmap</a>.
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_main">main</code></td>
<td>

<p>an overall title for the plot
</p>
</td></tr>
<tr><td><code id="ggplot_geopos_+3A_verbose">verbose</code></td>
<td>

<p>whether the file names should be printed during loading geolocation files(By default <code>TRUE</code> for <code>get_geopos()</code>, but <code>FALSE</code> for <code>ggplot_geopos()</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+leaflet_geopos">leaflet_geopos</a>, <a href="#topic+ggplotly_geopos">ggplotly_geopos</a>, <a href="oceanmap.html#topic+ggplotmap">ggplotmap</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># ## example 1a) line plot from several csv-files:
# library(oceanmap)
# csv_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
# pos &lt;- get_geopos(csv_file)  ## show tracks as line plot
# ggobj &lt;- ggplot_geopos(pos)
# ggobj
# ggplotly_geopos(ggobj)
# 
# ## load second file and add to plot:
# csv_file2 &lt;- system.file("example_files/14P0911-46177-1-GPE3.csv",package="RchivalTag")
# pos2 &lt;- get_geopos(csv_file2)  ## show tracks as line plot
# ggobj2 &lt;- ggplot_geopos(pos2)
# ggplotly_geopos(ggobj2)
# 
# pos3 &lt;- rbind(pos,pos2)
# ggobj3 &lt;- ggplot_geopos(pos3,type = "l")
# # ggobj3 &lt;- ggplot_geopos(pos3,type = "b")
# # ggobj3 &lt;- ggplot_geopos(pos3,type = "p")
# ggplotly_geopos(ggobj3)
# 
# 
# ## example 1b) scatter plot from csv-file on existing landmask:
# ggobj &lt;- oceanmap::ggplotmap('lion',grid.res = 5) # use keyword to derive area limits
# ggobj4 &lt;- ggplot_geopos(csv_file,ggobj)
# ggplotly_geopos(ggobj4)
# 
# ## alternatives:
# pos &lt;- get_geopos(csv_file)
# r &lt;- oceanmap::regions("lion")
# ggobj5 &lt;- ggplot_geopos(pos, xlim = r$xlim, ylim = r$ylim)
# ggplotly_geopos(ggobj5)
# 
# 
# ## example 2) probability surfaces of horizontal tracks from nc-file:
# ## this can take some time as it inlcudes time consuming data processing
# nc_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.nc",package="RchivalTag")
# ggobj6 &lt;- ggplot_geopos(nc_file)
# ggobj6
# ggplotly_geopos(ggobj6)
# 
# 
# ## alternative:
# pols_df &lt;- get_geopos(nc_file)
# ggplot_geopos(pols_df)
# 
# 
# ## example 3) probability surfaces of horizontal tracks from kmz-file:
# kmz_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.kmz",package="RchivalTag")
# ggobj7 &lt;- ggplot_geopos(kmz_file)
# ggobj7
# ggplotly_geopos(ggobj7)
# 
# 
# kmz_file2 &lt;- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
# ggobj8 &lt;- ggplot_geopos(kmz_file2)
# ggobj8
# ggplotly_geopos(ggobj8)
# 
# ## example 4) combine polygon tracks:
# k1 = get_geopos(kmz_file)
# k2 = get_geopos(kmz_file2)
# 
# ggobj &lt;- ggplotmap("mednw4")
# ## p1 &lt;- ggplot_geopos(k1,ggobj = ggobj) ## not working, need to change date format:
# p1 &lt;- ggplot_geopos(k1,grid.res=1)
# p1
# p2 &lt;- ggplot_geopos(k2,p1,zlim = as.Date(range(c(k1$datetime,k2$datetime))))
# ggplotly_geopos(p2)
# 
# ## change plot window:
# p1b &lt;- ggplot_geopos(k1,ggobj = ggobj)
# p2b &lt;- ggplot_geopos(k2,p1b,zlim = as.Date(range(c(k1$datetime,k2$datetime))))
# p2b
# ggplotly_geopos(p2b)

</code></pre>

<hr>
<h2 id='ggplotly_geopos'>
Converts a ggplot2 object from ggplot_geopos() to plotly
</h2><span id='topic+ggplotly_geopos'></span>

<h3>Description</h3>

<p>This function converts a ggplot2 object created by RchivalTag::ggplot_geopos() to a plotly object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplotly_geopos(ggobj, fixedrange=F, grid=F,expand=10)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplotly_geopos_+3A_ggobj">ggobj</code></td>
<td>

<p>Character string identifying regions predefined by the region_definitions-dataset, Raster* or Extent object (corresponds to <code>v_area</code> of the v-function). If missing, region is derived from geographical coordinates, denoted by lat and lon. See add.region to define new region definitions and delete.region to delete unproper region definitions.
</p>
</td></tr>
<tr><td><code id="ggplotly_geopos_+3A_fixedrange">fixedrange</code></td>
<td>

<p>Vector returning longitude coordinates of the area to be plotted.
</p>
</td></tr>
<tr><td><code id="ggplotly_geopos_+3A_grid">grid</code></td>
<td>

<p>whether a grid should be plotted (default is <code>TRUE</code>)
</p>
</td></tr>
<tr><td><code id="ggplotly_geopos_+3A_expand">expand</code></td>
<td>

<p>By default, the underlying <a href="plotly.html#topic+ggplotly">ggplotly</a>-function does not stick to the plotting region of the ggobj, but extends it. This can result in missing countries or islands. The <code>expand</code>-argument extends the plotly-plotting window in each direction in order to cover the corresponding landmasks.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ggoplotmaply</code> uses the <code>ggplotly</code> functions to convert the ggplot object into the plotly format.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

 <p><a href="#topic+leaflet_geopos">leaflet_geopos</a>, <code><a href="#topic+ggplot_geopos">ggplot_geopos</a>,  <a href="oceanmap.html#topic+ggplotmap">ggplotmap</a>, <a href="plotly.html#topic+ggplotly">ggplotly</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'># ## example 1a) line plot from several csv-files:
# library(oceanmap)
# csv_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
# pos &lt;- get_geopos(csv_file)  ## show tracks as line plot
# ggobj &lt;- ggplot_geopos(pos)
# ggobj
# ggplotly_geopos(ggobj)
# 
# ## load second file and add to plot:
# csv_file2 &lt;- system.file("example_files/14P0911-46177-1-GPE3.csv",package="RchivalTag")
# pos2 &lt;- get_geopos(csv_file2)  ## show tracks as line plot
# ggobj2 &lt;- ggplot_geopos(pos2)
# ggplotly_geopos(ggobj2)
# 
# pos3 &lt;- rbind(pos,pos2)
# ggobj3 &lt;- ggplot_geopos(pos3,type = "l")
# # ggobj3 &lt;- ggplot_geopos(pos3,type = "b")
# # ggobj3 &lt;- ggplot_geopos(pos3,type = "p")
# ggplotly_geopos(ggobj3)
# 
# 
# ## example 1b) scatter plot from csv-file on existing landmask:
# ggobj &lt;- oceanmap::ggplotmap('lion',grid.res = 5) # use keyword to derive area limits
# ggobj4 &lt;- ggplot_geopos(csv_file,ggobj)
# ggplotly_geopos(ggobj4)
# 
# ## alternatives:
# pos &lt;- get_geopos(csv_file)
# r &lt;- oceanmap::regions("lion")
# ggobj5 &lt;- ggplot_geopos(pos, xlim = r$xlim, ylim = r$ylim)
# ggplotly_geopos(ggobj5)
# 
# 
# ## example 2) probability surfaces of horizontal tracks from nc-file:
# ## this can take some time as it inlcudes time consuming data processing
# nc_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.nc",package="RchivalTag")
# ggobj6 &lt;- ggplot_geopos(nc_file)
# ggobj6
# ggplotly_geopos(ggobj6)
# 
# 
# ## alternative:
# pols_df &lt;- get_geopos(nc_file)
# ggplot_geopos(pols_df)
# 
# 
# ## example 3) probability surfaces of horizontal tracks from kmz-file:
# kmz_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.kmz",package="RchivalTag")
# ggobj7 &lt;- ggplot_geopos(kmz_file)
# ggobj7
# ggplotly_geopos(ggobj7)
# 
# 
# kmz_file2 &lt;- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
# ggobj8 &lt;- ggplot_geopos(kmz_file)
# ggobj8
# ggplotly_geopos(ggobj8)
# 
# ## example 4) combine polygon tracks:
# k1 = get_geopos(kmz_file)
# k2 = get_geopos(kmz_file2)
# 
# ggobj &lt;- ggplotmap("mednw4")
# ## p1 &lt;- ggplot_geopos(k1,ggobj = ggobj) ## not working, need to change date format:
# p1 &lt;- ggplot_geopos(k1,date_format = "%d-%b-%Y %H:%M:%S")
# p1
# p2 &lt;- ggplot_geopos(k2,p1,zlim = as.Date(range(c(k1$datetime,k2$datetime))),
#       date_format = "%d-%b-%Y %H:%M:%S")
# ggplotly_geopos(p2)
# 
# ## change plot window:
# p1b &lt;- ggplot_geopos(k1,ggobj = ggobj, date_format = "%d-%b-%Y %H:%M:%S")
# p2b &lt;- ggplot_geopos(k2,p1b,zlim = as.Date(range(c(k1$datetime,k2$datetime))),
#                     date_format = "%d-%b-%Y %H:%M:%S")
# p2b
# ggplotly_geopos(p2b)
</code></pre>

<hr>
<h2 id='hist_tad'>
Time-at-Depth histogram
</h2><span id='topic+hist_tad'></span>

<h3>Description</h3>

<p>generates daily or back-to-back (e.g. Day-vs-Night-) Time-at-Depth histograms from binned depth or depth time series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_tad(df, 
            bin_breaks=NULL, bin_prefix="Bin", 
            select_id, select_from='Ptt', aggregate_by='Ptt',
            date, min_perc,
            main, xlab='Time at Depth (%)', ylab="Depth (m)", labeling=TRUE,
            xlim=c(0, 100), adaptive.xlim=FALSE, 
            split_by=NULL, split_levels, xlab2=split_levels, 
            ylab.side=2, ylab.line, ylab.font=1,
            xlab.side=3, xlab.line=2.5, xlab.font=1,
            xlab2.side=1, xlab2.line=1, xlab2.font=2,
            main.side=3, main.line=3.8, main.font=1,
            col=c("darkgrey", "white"),
            xticks, ylabels,
            do_mid.ticks=TRUE, yaxis.pos=0, 
            mars, space=0,
            plot_sd=TRUE, plot_se, plot_nrec=TRUE, plot_ntags=TRUE,
            cex=1.2, cex.main=cex, cex.lab=cex, cex.inf=cex.axis,cex.axis=1, 
            return.sm=FALSE, 
            subplot=FALSE, inside=FALSE,Type="TAD")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_tad_+3A_df">df</code></td>
<td>
<p>dataframe that either contains depth time series data (as a vector &quot;Depth&quot;) or several vectors of Time-at-Depth frequencies. In the latter case, column names composed of a common <code>bin_prefix</code> (default is &quot;Bin.&quot;) hold the pre-binned Time-at-Depth frequencies whose depth limits are defined in <code>bin_breaks</code>.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_bin_breaks">bin_breaks</code>, <code id="hist_tad_+3A_bin_prefix">bin_prefix</code></td>
<td>

<p><code>bin_breaks</code> is a numeric vector of depth bin breaks for the histogram data. In case of binned data (e.g. from standard wildlife computer histogram files), column names with a <code>bin_prefix</code> are expected to contain the preprossesed data (by default: Bin1, Bin2, Bin3, etc.). Alternatively, depth time series data will be directly converted using function <a href="#topic+ts2histos">ts2histos</a>.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_select_id">select_id</code>, <code id="hist_tad_+3A_select_from">select_from</code></td>
<td>

<p>these arguments allow to take a direct subset of the input dataframe. <code>select_from</code> defines the vector whereas <code>select_id</code> defines the identification key(s) that should be selected.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_aggregate_by">aggregate_by</code></td>
<td>

<p>character vector defining the columns by which the tagging data should be aggregated. Should contain columns that identify tags (e.g. Serial, Ptt, DeployID) the date and/or day time period (to seperate records from night, day, dawn and dusk see <a href="#topic+classify_DayTime">classify_DayTime</a>). Default values are: date, Day and Ptt.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_date">date</code></td>
<td>

<p>An optional vector to select depth data of a specified date/-range.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_min_perc">min_perc</code></td>
<td>

<p>optional number, defining the minimum data coverage (in percent) of histogram entries obtained from depth time series data.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_main">main</code>, <code id="hist_tad_+3A_xlab">xlab</code>, <code id="hist_tad_+3A_ylab">ylab</code>, <code id="hist_tad_+3A_labeling">labeling</code></td>
<td>

<p>The titles for the plot, x- and y-axes to be plotted if <code>labeling</code> is set <code>TRUE</code> (default).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_xlim">xlim</code>, <code id="hist_tad_+3A_adaptive.xlim">adaptive.xlim</code></td>
<td>

<p>a vector defining the limits (x1,x2) of the x-axis, by default c(0,100). However, if <code>adaptive.xlim</code> is set <code>TRUE</code>, these limits will be overwritten, and the maximum value (xlim[2]) will be chosen from the histogram data.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_split_by">split_by</code></td>
<td>

<p>Name of the logical vector by which TaD data should be splitted (e.g. daytime; see <a href="#topic+classify_DayTime">classify_DayTime</a>).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_split_levels">split_levels</code>, <code id="hist_tad_+3A_xlab2">xlab2</code></td>
<td>

<p>Character vector defining the name and order of the levels of the split_by vector (e.g. c(&quot;Night&quot;, &quot;Day&quot;) for split_by vector 'day.time'. The same groups are plotted as a second x-axis label if not defined otherwise (<code>xlab2</code>=<code>split_levels</code>). 
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_ylab.side">ylab.side</code>, <code id="hist_tad_+3A_ylab.line">ylab.line</code>, <code id="hist_tad_+3A_ylab.font">ylab.font</code></td>
<td>

<p>side, line and font of second y-axis label.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_xlab.side">xlab.side</code>, <code id="hist_tad_+3A_xlab.line">xlab.line</code>, <code id="hist_tad_+3A_xlab.font">xlab.font</code></td>
<td>

<p>side, line and font of first x-axis label.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_xlab2.side">xlab2.side</code>, <code id="hist_tad_+3A_xlab2.line">xlab2.line</code>, <code id="hist_tad_+3A_xlab2.font">xlab2.font</code></td>
<td>

<p>side, line and font of second x-axis labels.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_main.side">main.side</code>, <code id="hist_tad_+3A_main.line">main.line</code>, <code id="hist_tad_+3A_main.font">main.font</code></td>
<td>

<p>side, line and font of plot title.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_col">col</code></td>
<td>

<p>colours to be used for the TaD-histogram, by default 'grey' and 'white' (corresponding to the values of split_by/split_levels).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_xticks">xticks</code>, <code id="hist_tad_+3A_ylabels">ylabels</code></td>
<td>

<p>tick labels of the x-axis and ylabels of the y-axis to show in the plot.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_do_mid.ticks">do_mid.ticks</code></td>
<td>

<p>whether centered tick-labels, indicating the depth range of histogram cells, shall be plotted (by default <code>FALSE</code>). Alternatively, tick labels will be indicated at the breakpoints of the histrogram cells.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_yaxis.pos">yaxis.pos</code></td>
<td>

<p>x-axis coordinate at which the y-axis should be plotted (by default xlim[1], and thus 0).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_mars">mars</code></td>
<td>

<p>a numerical vector of the form <code>c(bottom, left, top, right)</code>, decribing the number of margin lines to be specified on the each side of the plot. The default is <code>c(2.1, 4.1, 6.1, 2.1)</code>. In case that <code>do_mid.ticks</code> is <code>TRUE</code> margins are: <code>c(2.1, 8, 6.1, 2.1)</code>.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_space">space</code></td>
<td>

<p>the space between the histogram bars.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_plot_sd">plot_sd</code>, <code id="hist_tad_+3A_plot_se">plot_se</code>, <code id="hist_tad_+3A_plot_nrec">plot_nrec</code>, <code id="hist_tad_+3A_plot_ntags">plot_ntags</code></td>
<td>

<p>whether standard deviation or standard error bars, the number of records and tags shall be plotted (default is <code>TRUE</code>) inside the TaD/TaT histogram. (if plot_se is <code>TRUE</code>, plot_sd will be overwritten!).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_cex">cex</code>, <code id="hist_tad_+3A_cex.main">cex.main</code>, <code id="hist_tad_+3A_cex.lab">cex.lab</code>, <code id="hist_tad_+3A_cex.inf">cex.inf</code>, <code id="hist_tad_+3A_cex.axis">cex.axis</code></td>
<td>

<p>font size of the title (<code>cex.main</code>), x- and y-axes labels (<code>cex.lab</code>), other labels, like the number of records (<code>cex.inf</code>) as well as of the tick marks.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_return.sm">return.sm</code></td>
<td>

<p>whether summary information of the TaD histograms, including the number of records per summary period, the relative frequencies per bin and corresponding standard deviation, should be plotted (default is <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_subplot">subplot</code>, <code id="hist_tad_+3A_inside">inside</code></td>
<td>

<p>whether the TaD histogram is a subplot or an inner plot of a figure (default is <code>FALSE</code>). 
If <code>subplot</code> or <code>inside</code> are set <code>TRUE</code>, graphic margins will not be set by <code>hist_tad</code>.
In case that <code>inside</code> is <code>TRUE</code>, no axis-labels and titels wil be plotted.
</p>
</td></tr>
<tr><td><code id="hist_tad_+3A_type">Type</code></td>
<td>

<p>The Type of data to be plotted (<code>TAD</code>: Time-at-Depth histograms; <code>TAT</code>: Time-at-Temperature histograms)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-at-Temperature (Tat) and Time-at-Depth (TaD) fequencies are a standard data product of archival tags (incl. tag models TDR-Mk9, PAT-Mk10 and miniPAT by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>) that allow to assess habitat preferences of tagged animals (see function <a href="#topic+read_histos">read_histos</a>).  It can be likewise generated from transmitted or recovered time series data sets using function <a href="#topic+ts2histos">ts2histos</a>. 
</p>
<p>However, different depth and temperature bin breaks are often used during different deployment programs, which makes a later comparitive analysis of TaT and TaT data difficult. For such cases, the function <a href="#topic+combine_histos">combine_histos</a> and <a href="#topic+merge_histos">merge_histos</a> can be applied to merge TaT and TaD frequencies based on common bin breaks of different tags.
</p>
<p>The purpose of this function is the visualization of Time-at-Depth (TaD) histograms, whereas <a href="#topic+hist_tad">hist_tad</a> is the related function for Time-at-Temperature (TaT) data.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+combine_histos">combine_histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tat">hist_tat</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)

tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)
tat_breaks &lt;- c(10,12,15,17,18,19,20,21,22,23,24,27)

## example 1a) convert only DepthTS data to daily TAD frequencies:
ts2histos(ts_df, tad_breaks = tad_breaks)
hist_tad(ts_df, bin_breaks = tad_breaks)
hist_tad(ts_df, bin_breaks = tad_breaks, do_mid.ticks = FALSE)

## convert 1b) only TemperatureTS data to daily TAT frequencies:
tat &lt;- ts2histos(ts_df, tat_breaks = tat_breaks)
hist_tat(ts_df, bin_breaks = tat_breaks, do_mid.ticks = FALSE)
hist_tat(tat$TAT$merged, do_mid.ticks = FALSE)

## convert 1c) DepthTS &amp; TemperatureTS data to daily TAD &amp; TAT frequencies:
ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks)

## convert 1d) back-to-back histogram showing day vs night TAD frequencies:
ts_df$Lat &lt;- 4; ts_df$Lon=42.5 ## required geolocations to estimate daytime
head(ts_df)
ts_df2 &lt;- classify_DayTime(get_DayTimeLimits(ts_df)) # estimate daytime
head(ts_df2)

ts2histos(ts_df2, tad_breaks = tad_breaks,split_by = "daytime")
hist_tad(ts_df2, bin_breaks = tad_breaks,split_by = "daytime", do_mid.ticks = FALSE)


## example 2) rebin daily TAD frequencies:
tad &lt;- ts2histos(ts_df, tad_breaks = tad_breaks)
tad2 &lt;- rebin_histos(hist_list = tad, tad_breaks = tad_breaks[c(1:3,6:12)])
par(mfrow=c(2,2))
hist_tad(tad, do_mid.ticks = FALSE) ## example for multiple individuals
hist_tad(tad$TAD$merged, do_mid.ticks = FALSE)
hist_tad(tad$TAD$merged, bin_breaks = tad_breaks[c(1:3,6:12)]) ## from inside hist_tad


## example 3) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)
</code></pre>

<hr>
<h2 id='hist_tat'>
Time-at-Temperature histogram
</h2><span id='topic+hist_tat'></span>

<h3>Description</h3>

<p>generates daily or back-to-back (e.g. Day-vs-Night-) Time-at-Temperature histograms from binned Temperature or Temperature time series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist_tat(df, 
            bin_breaks=NULL, bin_prefix="Bin", 
            main, xlab="Time at Temperature (%)", 
            ylab=expression(paste("Temperature (",degree,"C)")), labeling=TRUE,
            Type="TAT", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_tat_+3A_df">df</code></td>
<td>
<p>dataframe that either contains Temperature time series data (as a vector &quot;Temperature&quot;) or several vectors of Time-at-Temperature frequencies. In the latter case, vector names are composed of a common <code>bin_prefix</code> (default is &quot;tad.&quot;), followed by the upper Temperature limit (bin break). 
</p>
</td></tr>
<tr><td><code id="hist_tat_+3A_bin_breaks">bin_breaks</code>, <code id="hist_tat_+3A_bin_prefix">bin_prefix</code></td>
<td>

<p><code>bin_breaks</code> is a numeric vector of depth bin breaks for the histogram data. In case of binned data (e.g. from standard wildlife computer histogram files), column names with a <code>bin_prefix</code> are expected to contain the preprossesed data (by default: Bin1, Bin2, Bin3, etc.). Alternatively, depth time series data will be directly converted using function <a href="#topic+ts2histos">ts2histos</a>.
</p>
</td></tr>
<tr><td><code id="hist_tat_+3A_main">main</code>, <code id="hist_tat_+3A_xlab">xlab</code>, <code id="hist_tat_+3A_ylab">ylab</code>, <code id="hist_tat_+3A_labeling">labeling</code></td>
<td>

<p>The titles for the plot, x- and y-axes to be plotted if <code>labeling</code> is set <code>TRUE</code> (default).
</p>
</td></tr>
<tr><td><code id="hist_tat_+3A_type">Type</code></td>
<td>

<p>The Type of data to be plotted (<code>TAD</code>: Time-at-Depth histograms; <code>TAT</code>: Time-at-Temperature histograms)
</p>
</td></tr>
<tr><td><code id="hist_tat_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed:
</p>

<dl>
<dt>select_id, select_from</dt><dd>
<p>these arguments allow to take a direct subset of the input dataframe. <code>select_from</code> defines the vector whereas <code>select_id</code> defines the identification key(s) that should be selected.
</p>
</dd>
<dt>aggregate_by</dt><dd>
<p>character vector defining the columns by which the tagging data should be aggregated. Should contain columns that identify tags (e.g. Serial, Ptt, DeployID) the date and/or day time period (to seperate records from night, day, dawn and dusk see <a href="#topic+classify_DayTime">classify_DayTime</a>). Default values are: date, Day and Ptt.
</p>
</dd>
<dt>date</dt><dd>
<p>An optional vector to select depth data of a specified date/-range.
</p>
</dd>
<dt>xlim, adaptive.xlim</dt><dd>
<p>a vector defining the limits (x1,x2) of the x-axis, by default c(0,100). However, if <code>adaptive.xlim</code> is set <code>TRUE</code>, these limits will be overwritten, and the maximum value (xlim[2]) will be chosen from the histogram data.
</p>
</dd>
<dt>split_by</dt><dd>
<p>Name of the logical vector by which TaD data should be splitted (e.g. daytime; see <a href="#topic+classify_DayTime">classify_DayTime</a>).
</p>
</dd>
<dt>split_levels, xlab2</dt><dd>
<p>Character vector defining the name and order of the levels of the split_by vector (e.g. c(&quot;Night&quot;, &quot;Day&quot;) for split_by vector 'day.time'. The same groups are plotted as a second x-axis label if not defined otherwise (<code>xlab2</code>=<code>split_levels</code>). 
</p>
</dd>
<dt>ylab.side, ylab.line, ylab.font</dt><dd>
<p>side, line and font of second y-axis label.
</p>
</dd>
<dt>xlab.side, xlab.line, xlab.font</dt><dd>
<p>side, line and font of first x-axis label.
</p>
</dd>
<dt>xlab2.side, xlab2.line, xlab2.font</dt><dd>
<p>side, line and font of second x-axis labels.
</p>
</dd>
<dt>main.side, main.line, main.font</dt><dd>
<p>side, line and font of plot title.
</p>
</dd>
<dt>col</dt><dd>
<p>colours to be used for the TaD-histogram, by default 'grey' and 'white' (corresponding to the values of split_by/split_levels).
</p>
</dd>
<dt>xticks, ylabels</dt><dd>
<p>tick labels of the x-axis and ylabels of the y-axis to show in the plot.
</p>
</dd>
<dt>do_mid.ticks</dt><dd>
<p>whether centered tick-labels, indicating the depth range of histogram cells, shall be plotted (by default <code>FALSE</code>). Alternatively, tick labels will be indicated at the breakpoints of the histrogram cells.
</p>
</dd>
<dt>yaxis.pos</dt><dd>
<p>x-axis coordinate at which the y-axis should be plotted (by default xlim[1], and thus 0).
</p>
</dd>
<dt>mars</dt><dd>
<p>a numerical vector of the form <code>c(bottom, left, top, right)</code>, decribing the number of margin lines to be specified on the each side of the plot. The default is <code>c(2.1, 4.1, 6.1, 2.1)</code>. In case that <code>do_mid.ticks</code> is <code>TRUE</code> margins are: <code>c(2.1, 8, 6.1, 2.1)</code>.
</p>
</dd>
<dt>space</dt><dd>
<p>the space between the histogram bars.
</p>
</dd>
<dt>plot_sd, plot_se, plot_nrec , plot_ntags</dt><dd>
<p>whether standard deviation or standard error bars, the number of records and tags shall be plotted (default is <code>TRUE</code>) inside the TaD/TaT histogram. (if plot_se is <code>TRUE</code>, plot_sd will be overwritten!).
</p>
</dd>
<dt>cex, cex.main, cex.lab, cex.inf</dt><dd>
<p>font size of the title (<code>cex.main</code>), x- and y-axes labels (<code>cex.lab</code>), and other labels, like the number of records (<code>cex.inf</code>).
</p>
</dd>
<dt>return.sm</dt><dd>
<p>whether summary information of the TaD histograms, including the number of records per summary period, the relative frequencies per bin and corresponding standard deviation, should be plotted (default is <code>TRUE</code>).
</p>
</dd>
<dt>subplot, inside</dt><dd>
<p>whether the TaD histogram is a subplot or an inner plot of a figure (default is <code>FALSE</code>). 
If <code>subplot</code> or <code>inside</code> are set <code>TRUE</code>, graphic margins will not be set by <code>hist_tat</code>.
In case that <code>inside</code> is <code>TRUE</code>, no axis-labels and titels wil be plotted.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-at-Temperature (Tat) and Time-at-Depth (TaD) fequencies are a standard data product of archival tags (incl. tag models TDR-Mk9, PAT-Mk10 and miniPAT by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>) that allow to assess habitat preferences of tagged animals (see function <a href="#topic+read_histos">read_histos</a>).  It can be likewise generated from transmitted or recovered time series data sets using function <a href="#topic+ts2histos">ts2histos</a>. 
</p>
<p>However, different depth and temperature bin breaks are often used during different deployment programs, which makes a later comparitive analysis of TaT and TaT data difficult. For such cases, the function <a href="#topic+combine_histos">combine_histos</a> and <a href="#topic+merge_histos">merge_histos</a> can be applied to merge TaT and TaD frequencies based on common bin breaks of different tags.
</p>
<p>The purpose of this function is the visualization of Time-at-Temperature (TaT) histograms, whereas <a href="#topic+hist_tad">hist_tad</a> is the related function for Time-at-Depth (TaD) data.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+combine_histos">combine_histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tad">hist_tad</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)

tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)
tat_breaks &lt;- c(10,12,15,17,18,19,20,21,22,23,24,27)

## example 1a) convert only DepthTS data to daily TAD frequencies:
ts2histos(ts_df, tad_breaks = tad_breaks)
# hist_tad(ts_df, bin_breaks = tad_breaks)
hist_tad(ts_df, bin_breaks = tad_breaks, do_mid.ticks = FALSE)

## convert 1b) only TemperatureTS data to daily TAT frequencies:
tat &lt;- ts2histos(ts_df, tat_breaks = tat_breaks)
hist_tat(ts_df, bin_breaks = tat_breaks, do_mid.ticks = FALSE)
hist_tat(tat$TAT$merged, do_mid.ticks = FALSE)

## convert 1c) DepthTS &amp; TemperatureTS data to daily TAD &amp; TAT frequencies:
ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks)

## convert 1d) back-to-back histogram showing day vs night TAD frequencies:
ts_df$Lat &lt;- 4; ts_df$Lon=42.5 ## required geolocations to estimate daytime
head(ts_df)
ts_df2 &lt;- classify_DayTime(get_DayTimeLimits(ts_df)) # estimate daytime
head(ts_df2)

ts2histos(ts_df2, tad_breaks = tad_breaks,split_by = "daytime")
hist_tad(ts_df2, bin_breaks = tad_breaks,split_by = "daytime", do_mid.ticks = FALSE)


## example 2) rebin daily TAD frequencies:
tad &lt;- ts2histos(ts_df, tad_breaks = tad_breaks)
tad2 &lt;- rebin_histos(hist_list = tad, tad_breaks = tad_breaks[c(1:3,6:12)])
par(mfrow=c(2,2))
hist_tad(tad, do_mid.ticks = FALSE) ## example for multiple individuals
hist_tad(tad$TAD$merged, do_mid.ticks = FALSE)
hist_tad(tad$TAD$merged, bin_breaks = tad_breaks[c(1:3,6:12)]) ## from inside hist_tad


## example 3) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)
</code></pre>

<hr>
<h2 id='image_TempDepthProfiles'>
plots interpolated daily temperature at depth profiles
</h2><span id='topic+image_TempDepthProfiles'></span>

<h3>Description</h3>

<p>plots interpolated daily temperature at depth profiles, thus faciliating the analysis of temporal changes of temperature profiles, for instance, in relation to animal behaviour (e.g. diving behaviour). See Bauer et al. (2015) for further examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>image_TempDepthProfiles(x, main=NULL, xlab='Date', ylab="Depth (m)", 
                        cb.xlab=expression(paste("Temperature (",degree,"C)")), 
                        cex.cb.xlab=1, cex.cb.ticks=1,
                        xlim, ylim, zlim, pal="jet", only.months, month.line=0, 
                        mars, axes=TRUE, do.colorbar=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image_TempDepthProfiles_+3A_x">x</code></td>
<td>

<p>A list , generated by <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a> or <a href="#topic+interpolate_PDTs">interpolate_PDTs</a>, containing interpolated temperature at depth profiles and their corresponding date and interpolated depth values as well as a summary table with the original depth values and their number per day:
</p>
<p>$ Temperature_matrix: num<br />
$ Depth           : num<br /> 
$ Date            :Date<br />
$ sm            :data.frame<br />
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_main">main</code>, <code id="image_TempDepthProfiles_+3A_xlab">xlab</code>, <code id="image_TempDepthProfiles_+3A_ylab">ylab</code></td>
<td>

<p>the title, x- and y-axis labels to be plotted. 
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_cb.xlab">cb.xlab</code></td>
<td>

<p>character string indicating the x-axis label of the colorbar.
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_cex.cb.xlab">cex.cb.xlab</code>, <code id="image_TempDepthProfiles_+3A_cex.cb.ticks">cex.cb.ticks</code></td>
<td>

<p><em>cex.cb.xlab</em>: font size of the x-axis label of the colorbar (by default 1).
<em>cex.cb.ticks</em>: font size of the x-axis tick labels of the colorbar (by default 1).
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_xlim">xlim</code>, <code id="image_TempDepthProfiles_+3A_ylim">ylim</code>, <code id="image_TempDepthProfiles_+3A_zlim">zlim</code></td>
<td>
<p>the x, y and z limits of the plot.
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_pal">pal</code></td>
<td>

<p>color map to be plotted (default is <code>'jet'</code>). See cmap for available color maps.
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_only.months">only.months</code>, <code id="image_TempDepthProfiles_+3A_month.line">month.line</code></td>
<td>

<p>whether only mid-months shall be plotted as tick labels of the x-axis (by default FALSE for time ranges of less than 3 months (93 days)).
In case, that only.months is set <code>TRUE</code>, <code>month.line</code> defines the line where the month labels shall be plotted.
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_mars">mars</code></td>
<td>

<p>a numerical vector defining the plot margins <code>c(bottom, left, top, right)</code> (by default <code>c(5,4,4,9)</code>).
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_axes">axes</code>, <code id="image_TempDepthProfiles_+3A_do.colorbar">do.colorbar</code></td>
<td>

<p>whether the axes and colorbar should be plotted.
</p>
</td></tr>
<tr><td><code id="image_TempDepthProfiles_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to set.colorbarp
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_PDT">read_PDT</a>, <a href="#topic+bin_TempTS">bin_TempTS</a>, <a href="#topic+get_thermalstrat">get_thermalstrat</a>, <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example 1) run on PDT file:
## step I) read sample PDT data file:
path &lt;- system.file("example_files",package="RchivalTag")
PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
head(PDT)
# 
# ## step II) interpolate average temperature fields (MeanPDT) from PDT file:
# m &lt;- interpolate_PDTs(PDT)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# ## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)
# 
# 
# #### example 2) run on time series data:
# ## step I) read sample time series data file:
# DepthTempTS &lt;- read.table(system.file("example_files/104659-Series.csv",
#                                       package="RchivalTag"),header = TRUE,sep=',')
# DepthTempTS$date &lt;- as.Date(DepthTempTS$Day,"%d-%b-%Y")
# head(DepthTempTS)
# 
# 
# ## step Ib) bin temperature data on 10m depth bins 
# ##          to increase later estimate accuracy (see Bauer et al. 2015):
# # DepthTempTS_binned &lt;- bin_TempTS(DepthTempTS,res=10)
# 
# ## step II) interpolate average temperature fields (MeanTemp) from binned data:
# m &lt;- interpolate_TempDepthProfiles(DepthTempTS)
# # m &lt;- interpolate_PDTs(DepthTempTS_binned)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# ## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)

</code></pre>

<hr>
<h2 id='interpolate_TempDepthProfiles'>
interpolate daily temperature at depth profiles
</h2><span id='topic+interpolate_TempDepthProfiles'></span><span id='topic+interpolate_PDTs'></span>

<h3>Description</h3>

<p>interpolates depth-temperature data and returns daily average temperature at depth profiles on a user-specified resolution (<code>Depth_res</code>). <br /> Results are returned as a list containing the interpolated Temperature-matrix, and the corresponding date and depth values. Thus interpolated temperature at depth profiles can be visualized using function <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a> and faciliates the analysis of temporal changes of temperature profiles, for instance, in relation to animal behaviour (e.g. diving behaviour).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interpolate_TempDepthProfiles(ts, Temp_field="Temperature", ID_key="Serial", 
                              Depth_res=.5, verbose=TRUE, Data_Source='station')
                              
interpolate_PDTs(ts, Temp_field="MeanPDT", ID_key="Serial", #return_as_matrix=FALSE, 
                             Depth_res=.5, verbose=TRUE, Data_Source='station')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interpolate_TempDepthProfiles_+3A_ts">ts</code>, <code id="interpolate_TempDepthProfiles_+3A_temp_field">Temp_field</code>, <code id="interpolate_TempDepthProfiles_+3A_id_key">ID_key</code></td>
<td>

<p><code>ts</code> is a <a href="base.html#topic+data.frame">data.frame</a> with temperature at depth data. Required columns are <code>Depth</code> for the depth data and a column containing temperature data, whose name is defined by <code>Temp_field</code>. <code>ID_key</code> specifies the name of an optional column on which sampling stations or tags can be distinguished (by default <code>Serial</code>).
</p>
</td></tr>
<tr><td><code id="interpolate_TempDepthProfiles_+3A_depth_res">Depth_res</code></td>
<td>

<p>numeric value, defining the depth resolution at which the temperature data should be interpolated.
</p>
</td></tr>
<tr><td><code id="interpolate_TempDepthProfiles_+3A_verbose">verbose</code></td>
<td>

<p>whether the sampling dates and ids of stations or tags, as defined by the columns <code>date</code> and <code>ID_key</code>,  
should be indicated during the interpolation process.
</p>
</td></tr>



<tr><td><code id="interpolate_TempDepthProfiles_+3A_data_source">Data_Source</code></td>
<td>

<p>a character string, defining the data source (by default <code>station</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the interpolated temperature at depth profiles and their corresponding date and interpolated depth values as well as a summary table with the original depth values and their number per day:
</p>
<p>$ Data_Source.ID_key:List of 4<br />
..$ Temperature_matrix: num<br />
..$ Depth           : num<br /> 
..$ Date            :Date<br />
..$ sm            :data.frame<br />
</p>
<p>Please see the examples for further understaning.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_PDT">read_PDT</a>, <a href="#topic+bin_TempTS">bin_TempTS</a>, <a href="#topic+get_thermalstrat">get_thermalstrat</a>, <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example 1) run on PDT file:
## step I) read sample PDT data file:
path &lt;- system.file("example_files",package="RchivalTag")
PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
head(PDT)
# 
# ## step II) interpolate average temperature fields (MeanPDT) from PDT file:
# m &lt;- interpolate_PDTs(PDT)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# ## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)
# 
# 
# #### example 2) run on time series data:
# ## step I) read sample time series data file:
# ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
# DepthTempTS &lt;- read_TS(ts_file)
# 
# 
# ## step Ib) bin temperature data on 10m depth bins 
# ##          to increase later estimate accuracy (see Bauer et al. 2015):
# # DepthTempTS_binned &lt;- bin_TempTS(DepthTempTS,res=10)
# 
# ## step II) interpolate average temperature fields (MeanTemp) from binned data:
# m &lt;- interpolate_TempDepthProfiles(DepthTempTS)
# # m &lt;- interpolate_PDTs(DepthTempTS_binned)
# str(m)
# m$sm
# 
# ## step III) calculate thermal stratifcation indicators per day (and tag):
# get_thermalstrat(m, all_info = TRUE)
# get_thermalstrat(m, all_info = FALSE)
# 
# ## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)

</code></pre>

<hr>
<h2 id='leaflet_geopos'>
reads and plots geolocation estimates derived from archival tagging data
</h2><span id='topic+leaflet_geopos'></span>

<h3>Description</h3>

<p>This function creates a Leaflet map widget using htmlwidgets from spatial tagging data. The widget can be rendered on HTML pages generated from R Markdown, Shiny, or other applications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaflet_geopos(data, ID_label, add_label=NULL, except_label=NULL, 
               collapsedLayers=TRUE, radius=1000, pal,
               layer_title=ID_label, colorby="date", cb.title, cbpos="bottomright",
               showScaleBar=TRUE, showSlideBar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaflet_geopos_+3A_data">data</code></td>
<td>
<p>spatial data such as <a href="base.html#topic+data.frame">data.frame</a> or <a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a>.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_id_label">ID_label</code></td>
<td>

<p>Vector in spatial data that defines the ID of the tracks to be plotted.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_add_label">add_label</code>, <code id="leaflet_geopos_+3A_except_label">except_label</code></td>
<td>

<p>additional labels or labels to be removed from hover.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_collapsedlayers">collapsedLayers</code></td>
<td>

<p>whether to collapse leaflet layer legend.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_radius">radius</code></td>
<td>

<p>circle size, in case of simple Lon/Lat tracking dataframes.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_pal">pal</code></td>
<td>

<p>color map to be plotted in case of polygon (.nc-files) or scatter plots (default is the 'jet'-colormap, and 'year.jet' in case <code>standard_year</code> &amp; <code>full_year</code> are set <code>TRUE</code>). See cmap for pre-installed color maps. Note that tracking data with constant time steps is being assumed in the color assignment. To verify this, a <a href="base.html#topic+data.frame">data.frame</a> containing the colors at each time steps will be returned for polygon and scatter plots.
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_layer_title">layer_title</code></td>
<td>

<p>character string indicating the title of the layer legend (by default defined by <code>'ID_label'</code>.)
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_colorby">colorby</code></td>
<td>

<p>character string indicating the vector for which to apply the colorbar (by default <code>'date'</code>.)
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_cb.title">cb.title</code></td>
<td>

<p>character string indicating the title of the colorbar (by default inferred from <code>colorby</code>),
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_cbpos">cbpos</code></td>
<td>

<p>position of the colorbar (by default <code>'bottomright'</code>.)
</p>
</td></tr>
<tr><td><code id="leaflet_geopos_+3A_showscalebar">showScaleBar</code>, <code id="leaflet_geopos_+3A_showslidebar">showSlideBar</code></td>
<td>

<p>whether to show the scale bar or the slide bar.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ggplotly_geopos">ggplotly_geopos</a>, <a href="#topic+ggplot_geopos">ggplot_geopos</a>, <a href="#topic+update_leaflet_elementId">update_leaflet_elementId</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# csv_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.csv",package="RchivalTag")
# s0 &lt;- get_geopos(csv_file)
# ggplot_geopos(s0)
# leaflet_geopos(s0,ID_label="DeployID")
# leaflet_geopos(s0,ID_label="DeployID",showSlideBar = T)
#
# kmz_file &lt;- system.file("example_files/15P1019-104659-1-GPE3.kmz",package="RchivalTag")
# k1 &lt;- get_geopos(kmz_file)
# kmz_file2 &lt;- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
# k2 &lt;- get_geopos(kmz_file2)
# k0 &lt;- k3 &lt;- rbind(k1,k2)
# ggplot_geopos(k0,ggobj = ggplotmap("lion"))
# 
# # ggobj &lt;- ggplot_geopos(k1)
# # ggplot_geopos(ggobj = ggobj,k2)
# leaflet_geopos(k0,ID_label="DeployID",collapsedLayers = F) %&gt;% addMiniMap()
# leaflet_geopos(k0,ID_label="DeployID",showSlideBar = T)
#
## Code to illustrate how to avoid rendering issues in RMarkdown:
## only valid in RMarkdown chunks:
# kmz_file2 &lt;- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
# k2 &lt;- get_geopos(kmz_file2)
# k0 &lt;- k3 &lt;- rbind(k1,k2)
#
# library(leaflet)
# map &lt;- leaflet_geopos(k0, ID_label="DeployID", collapsedLayers = F)
# map
# map # plot again to show rendering issues (in the layer menu title)
## this is required to avoid rendering issues when plotting the same map twice via RMarkdown 
# map &lt;- update_leaflet_elementId(map) 
#
# plot again with updated elementID:
# map %&gt;% addMiniMap()
</code></pre>

<hr>
<h2 id='merge_histos'>
merge and/or rebin TAD/TAT-frequency data
</h2><span id='topic+merge_histos'></span><span id='topic+rebin_histos'></span>

<h3>Description</h3>

<p>The joint analysis of archival tagging data from different tagging programs is often hampered by differences in the tags' setups, e.g. by the user-specified temporal resolution of time series data or the definition of summary data products. The latter particuarly concerns different selected bin breaks of Time-at-Depth (TAD) and Time-at-Temperature (TAT) frequency data from archival tags by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>.<br />
</p>
<p>The purpose of this function is to allow:<br /><br />1) a grouping of TAD and TAT data from multiple tags based on similiar bin breaks (For this, run the function with default statements, i.e. <code>force_merge</code> is <code>FALSE</code>),<br /><br />
2) merging (rebinning) of TAD and TAT data from multiple tags based on the bin breaks that all tags have in common (To do so, run the function with <code>force_merge</code> set <code>TRUE</code>).<br /><br />
3) merging (rebinning) of TAD and TAT data from multiple tags based on new user-specified <code>tad_breaks</code> and/or <code>tat_breaks</code>. In this case, the <code>force_merge</code>-statements <code>TRUE</code> and <code>FALSE</code> will omit or seperately group tags that do not share all user-specified bin breaks, respectively. <br /><br /> 
To combine of TAD/TAT data of several <code>hist_lists</code>, see <a href="#topic+combine_histos">combine_histos</a>.
</p>
<p>To visualize Time-at-Temperature (TaT) and Time-at-Depth (TaD) data, please see <a href="#topic+hist_tat">hist_tat</a> and <a href="#topic+hist_tad">hist_tad</a>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_histos(hist_list, tad_breaks=NULL, tat_breaks=NULL, force_merge=FALSE)
rebin_histos(hist_list, tad_breaks=NULL, tat_breaks=NULL, force_merge=FALSE)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_histos_+3A_hist_list">hist_list</code></td>
<td>

<p>A list-of-lists containing the TAD and TAT frequency data and the corresponding <code>bin_breaks</code> from one or several tags.
</p>
</td></tr>
<tr><td><code id="merge_histos_+3A_tad_breaks">tad_breaks</code></td>
<td>

<p>a numeric vector defining the <code>bin_breaks</code> for the merging (rebinning) of the TAD frequency data.<br />
In case that the additional argument <code>force_merge</code> is set <code>TRUE</code>, only tags whose original TAD bin breaks included all of the user-specified <code>tad_breaks</code> will be merged in a single group ('merged') based on the new bin breaks, while other tags will be omitted in the output. By contrast, if <code>force_merge</code> is set <code>FALSE</code>, tags that do not contain all specified <code>tad_breaks</code> will be merged in seperate groups (group2, group3, etc.), based on similar <code>bin_breaks</code>.
</p>
</td></tr>
<tr><td><code id="merge_histos_+3A_tat_breaks">tat_breaks</code></td>
<td>

<p>a numeric vector defining the <code>bin_breaks</code> for the merging (rebinning) of the TAT frequency data.<br />
In case that the additional argument <code>force_merge</code> is set <code>TRUE</code>, only tags whose original TAT bin breaks included all of the user-specified <code>tat_breaks</code> will be merged in a single group ('merged') based on the new bin breaks, while other tags will be omitted in the output. By contrast, if <code>force_merge</code> is set <code>FALSE</code>, tags that do not contain all specified <code>tat_breaks</code> will be merged in seperate groups (group2, group3, etc.), based on similar <code>bin_breaks</code>.
</p>
</td></tr>
<tr><td><code id="merge_histos_+3A_force_merge">force_merge</code></td>
<td>

<p>If <code>FALSE</code> (default), groups of tags with similar TAD and TAT-<code>bin_breaks</code> will be combined (no merging on new bin breaks) and identifier labels renamed as group1, group2, etc.<br /> If set <code>TRUE</code>, TAD and TAT frequency data will be merged on user-specified <code>tad/tat_breaks</code> or, if those arguments are missing, on the <code>bin_breaks</code> that all tags have in common. In both latter cases, identifier labels will be renamed &quot;merged&quot;.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-of-lists of grouped or merged TAD and TAT frequency data.
</p>
<p>$ TAD:List<br />
..$ group1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br />
$ TAT:List<br /> 
..$ group1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br /> 
..$ group2  : List of 2<br />
...
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+unmerge_histos">unmerge_histos</a>, <a href="#topic+combine_histos">combine_histos</a>, <a href="#topic+hist_tad">hist_tad</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example 1) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)
</code></pre>

<hr>
<h2 id='plot_data_coverage'>
Abacus plot to illustrate the data coverage of different data products per tag throughout their deployment period.
</h2><span id='topic+plot_data_coverage'></span><span id='topic+abacus_plot'></span>

<h3>Description</h3>

<p>Abacus plot to illustrate the data coverage of different data products per tag throughout their deployment period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_data_coverage(x, type, type2, meta, 
                   Identifier="Serial", fields=c("Serial","Ptt"),
                   date_range_std, show_fullmonths=TRUE, 
                   zlim, mars, na.omit=TRUE,
                   do.arrows=TRUE, xpos.arrows=-.25, xpos.years=-.27, 
                   xpos.fields=c(-.01,-.12), ypos.fields,
                   main, cex.main=1.2,
                   cb.xlab, cex.cb.xlab=1,
                   cb.ticks, cex.cb.ticks=.9,
                   pal="jet", bg="grey")
                   
abacus_plot(x, type, type2, meta,
            Identifier="Serial", fields=c("Serial","Ptt"),
            date_range_std, show_fullmonths=TRUE, 
            zlim, mars, na.omit=TRUE,
            do.arrows=TRUE, xpos.arrows=-.25, xpos.years=-.27, 
            xpos.fields=c(-.01,-.12), ypos.fields,
            main, cex.main=1.2,
            cb.xlab, cex.cb.xlab=1,
            cb.ticks, cex.cb.ticks=.9,
            pal="jet", bg="grey")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_data_coverage_+3A_x">x</code></td>
<td>
<p>a list with the tagging data whose data covereage will be illustrated as abacus plot
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_type">type</code>, <code id="plot_data_coverage_+3A_type2">type2</code></td>
<td>

<p>the data type of x (&quot;ts&quot;, &quot;lightlocs&quot;,&quot;tad&quot;,&quot;tat&quot;) and the name of the variable to be plotted: &quot;perc&quot; in case of lightlocation and time series data, &quot;perc_dat&quot; in case of histogram data (&quot;tad&quot;, &quot;tat&quot;).
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_meta">meta</code></td>
<td>

<p>a <code>data.frame</code> containing the meta data of the tagging program. Required column names include: 'dep.date', 'pop.date' as well as the definitions of the Identifier, fields vectors (see below).
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_identifier">Identifier</code></td>
<td>

<p>unit vector to identify the tags within the tagging data list (must appear in names of sublist) and meta table (column name). By default 'Serial' of the tag.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_date_range_std">date_range_std</code>, <code id="plot_data_coverage_+3A_show_fullmonths">show_fullmonths</code></td>
<td>

<p>standardized date range to be plotted (deplyoment years are reset to 0; e.g 0-10-03 and 01-02-17 for a fish that was in the water from 2017-10-03 until 2018-02-17. If missing, the date range will be estimated from the tagging data. If show_fullmonths=<code>TRUE</code>, the estimated date range will be rounded to full months (e.g. 0-10-01 and 01-03-01). However, show_fullmonths is ignored if date_range_std is specified.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_mars">mars</code></td>
<td>

<p>a numerical vector of the form <code>c(bottom, left, top, right)</code>, decribing the number of margin lines to be specified on the each side of the plot. The default is <code>c(5,12,4,8)</code>. In case of length(fields) &gt; 2 you may need to increase the space to the left as well as related arguments (i.e. xpos.arrows, xpos.years, xpos.fields), in order to provide the neccessary space for the columns of the meta data to be shown.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_na.omit">na.omit</code></td>
<td>

<p>whether missing data points within the time series shall be converted to 0. If FALSE, such missing points will be shaded in grey.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_zlim">zlim</code></td>
<td>

<p>the minimum and maximum z values for which colors should be plotted. By default c(0,100).
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_do.arrows">do.arrows</code>, <code id="plot_data_coverage_+3A_xpos.arrows">xpos.arrows</code>, <code id="plot_data_coverage_+3A_xpos.years">xpos.years</code></td>
<td>

<p>whether arrows shall be shown next to the deployment years as well as the horizontal position of arrows and deployment years.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_fields">fields</code>, <code id="plot_data_coverage_+3A_xpos.fields">xpos.fields</code>, <code id="plot_data_coverage_+3A_ypos.fields">ypos.fields</code></td>
<td>

<p>vectors to define the column(s) in meta data to be illustrated to the left of the data coverage abacus plot as well as related horizontal and vertical positions.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_main">main</code>, <code id="plot_data_coverage_+3A_cex.main">cex.main</code></td>
<td>

<p>the title and it's font size. if missing, title will be set to &quot;type&quot;.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_cb.xlab">cb.xlab</code>, <code id="plot_data_coverage_+3A_cex.cb.xlab">cex.cb.xlab</code></td>
<td>

<p>the title of the colorbar and it's font size.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_cb.ticks">cb.ticks</code>, <code id="plot_data_coverage_+3A_cex.cb.ticks">cex.cb.ticks</code></td>
<td>

<p>the tick labels of the colorbar and it's font size.
</p>
</td></tr>
<tr><td><code id="plot_data_coverage_+3A_pal">pal</code>, <code id="plot_data_coverage_+3A_bg">bg</code></td>
<td>

<p>the color palette of the colorbar (either a vector or a single keyword referring to a colorbar from the colorbars of the oceanmap package) as well as the background color of the data coverage abacus plot.
Please note also, that if the argument 'na.omit' is set to FALSE, missing data points will be shaded in grey.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Abacus plot to illustrate the data coverage of different data products per tag throughout their deployment period as shown in Figure 3 of Bauer et al. (2020).
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget, JM. Fromentin and M. Capello (2020) Surfacing and vertical behaviour of Atlantic bluefin tuna (Thunnus thynnus) in the Mediterranean Sea: implications for aerial surveys. ICES Journal of Marine Science. <a href="https://doi.org/10.1093/icesjms/fsaa083">doi:10.1093/icesjms/fsaa083</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_histos">read_histos</a>, <a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+read_TS">read_TS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'># sample_file &lt;- system.file("example_files/abacus_sample_data.rd",package="RchivalTag")
# load(sample_file, verbose=T)
#
# ## Please note: the sample data is contains only the columns required to produce the figures. 
# ## Other fields (e.g. Bins and bin breaks in the histos data are missing). 
# ## The basic structure has been mantained and needs to be adopted 
# ## to apply the plot_data_coverage-function.
#
# str(meta) # meta data example with all required columns
# str(lightlocs) ## not yet implemented, but can structure be adapted for other data sets.
# str(histos) ## combined but not merged histogram data. 
              ## Please compare with read_histos or ts2histos output and examples
# str(ts_list) ## list of depth time series data. compare with read_TS output
#
# plot_data_coverage(lightlocs, type="lightlocs", meta=meta)
# plot_data_coverage(histos, type="tad", meta=meta)
# plot_data_coverage(ts_list, type="ts", meta=meta)

</code></pre>

<hr>
<h2 id='plot_DepthTempTS'>
plot Depth Temperature time series data
</h2><span id='topic+plot_DepthTempTS'></span><span id='topic+plot_DepthTempTS_resampled'></span><span id='topic+plot_DepthTempTS_resampled_PDT'></span>

<h3>Description</h3>

<p>line plot for xyz-time series data with colorized z-variable (e.g. depth-temperature time series data from archival tags).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_DepthTempTS(ts_df, y="Depth", z="Temperature", 
                 xlim, ylim, zlim, show.colorbar=TRUE, 
                 pal="jet", cb.xlab, cb.xlab.line=0, 
                 pt.lwd, do_interp=TRUE, Return=FALSE, mars, tz="UTC", ...)
                 
plot_DepthTempTS_resampled(ts_df, y="Depth",z="Temperature", bin_res=10, 
                          xlim, ylim, zlim, show.colorbar=TRUE, 
                           pal="jet", cb.xlab, cb.xlab.line=0,
                           pt.lwd, do_interp=TRUE, Return=FALSE, mars, tz="UTC", ...)
                           
plot_DepthTempTS_resampled_PDT(ts_df, PDT, y="Depth", z="Temperature", 
                               xlim, ylim, zlim, show.colorbar=TRUE, 
                               pal="jet", cb.xlab, cb.xlab.line=0,  
                               pt.lwd, do_interp=TRUE, Return=FALSE, mars, tz="UTC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_DepthTempTS_+3A_ts_df">ts_df</code>, <code id="plot_DepthTempTS_+3A_pdt">PDT</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>s holding the time series data to be plotted, including the x-vector 'datetime' (in <code>POSIXct</code>-format  and UTC), and the numeric y-vector whose label is defined by <code>y</code>. In case of <code>plot_DepthTempTS_resampled</code> the depth temperature time series data will be interpolated on a daily basis and then resampled for temperature data by the depth records of the original time series data.
<code>plot_DepthTempTS_resampled_PDT</code> does the same but uses PDT data for resampling.
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_y">y</code></td>
<td>
<p>character label of time series vector to be plotted (by default 'Depth').
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_z">z</code></td>
<td>
<p>character label of time series vector to be plotted (by default 'Temperature').
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_bin_res">bin_res</code></td>
<td>
<p>specific argument for <code>plot_DepthTempTS_resampled</code>: the depth interval at which temperature records should be binned. (by default 10).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot (by default range(ts_df$datetime)).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot (by default range(ts_df[[y]])).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_zlim">zlim</code></td>
<td>
<p>the y limits of the plot (by default range(ts_df[[z]])).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_show.colorbar">show.colorbar</code></td>
<td>
<p>weather a colorbar should be plotted for image plots (default is <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_pal">pal</code></td>
<td>

<p>color map to be plotted (default is the 'jet'-colormap of the oceanmap-package. See cmap for available color maps.
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_cb.xlab">cb.xlab</code>, <code id="plot_DepthTempTS_+3A_cb.xlab.line">cb.xlab.line</code></td>
<td>

<p>character string indicating the label of the colorbar (default is Temperature in degrees) and <code>cb.xlab.line</code> its placement line (default is 0).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_pt.lwd">pt.lwd</code></td>
<td>
<p>size of points and lines.<br />
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_do_interp">do_interp</code></td>
<td>

<p>whether z-values shall be interpolated over the covered range of the time series data. The default <code>TRUE</code> value will produce a line plot. If set to FALSE only the available data points of the z-variable will be plotted.
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_return">Return</code></td>
<td>

<p>whether edited time series data set should be returned (by default <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_mars">mars</code></td>
<td>

<p>A numerical vector of the form c(bottom, left, top, right) which gives the number of lines of margin to be specified on the four sides of the plot. The default is c(5,4,4,10).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_tz">tz</code></td>
<td>

<p>The time zone in which the data should be illustrated (By default &quot;UTC&quot;). ATTENTION: The required date format of the input data is &quot;UTC&quot; (across all RchivalTag-functions).
</p>
</td></tr>
<tr><td><code id="plot_DepthTempTS_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <a href="#topic+plot_TS">plot_TS</a>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_DepthTS">plot_DepthTS</a>, <a href="#topic+plot_TS">plot_TS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)
ts_df$Serial &lt;- ts_df$DeployID
# plot_DepthTempTS(ts_df, do_interp = FALSE)
# plot_DepthTempTS(ts_df, do_interp = TRUE)
# plot_DepthTempTS_resampled(ts_df, do_interp = TRUE) # more accurate

# ts_df$Lon &lt;- 5; ts_df$Lat &lt;- 43
# plot_DepthTempTS(ts_df, plot_DayTimePeriods = TRUE, xlim = unique(ts_df$date)[2:3])
# plot_DepthTempTS(ts_df, plot_DayTimePeriods = TRUE, xlim = unique(ts_df$date)[2:3])
# plot_DepthTempTS_resampled(ts_df, plot_DayTimePeriods = TRUE, xlim = unique(ts_df$date)[2:3])
# plot_DepthTempTS_resampled_PDT(ts_df, PDT, plot_DayTimePeriods = TRUE)


</code></pre>

<hr>
<h2 id='plot_TS'>
plot time series data
</h2><span id='topic+plot_TS'></span><span id='topic+plot_DepthTS'></span><span id='topic+empty.plot_TS'></span>

<h3>Description</h3>

<p>plotting functions for time series data (e.g. depth or temperature time series data from archival tags) with user specified xtick intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_DepthTS(ts_df, y="Depth", xlim, ylim, xticks_interval,
             ylab=y, xlab, main, main.line=1, plot_info=TRUE, 
             ID, ID_label="Serial",
             plot_DayTimePeriods=FALSE, twilight.set="ast", 
             cex=1, cex.main=1.2*cex, cex.lab=1*cex, 
             cex.axis=.9*cex, cex.axis2=1*cex, 
             type="l", las=1, xaxs="i", yaxs="i", 
             plot_box=TRUE, bty="l", Return=FALSE, tz="UTC",...)
             
           
plot_TS(ts_df, y="Depth", xlim, ylim, xticks_interval,
        ylab=y, xlab, main, main.line=1, plot_info=TRUE, 
        ID, ID_label="Serial",
        plot_DayTimePeriods=FALSE, twilight.set="ast", 
        cex=1, cex.main=1.2*cex, cex.lab=1*cex, 
        cex.axis=.9*cex, cex.axis2=1*cex, 
        type="l", las=1, xaxs="i", yaxs="i", 
        plot_box=TRUE, bty="l", Return=FALSE, tz="UTC", ...)
       
empty.plot_TS(xlim, ylim, xticks_interval, ylab="", xlab, main="",
              cex=1, cex.main=1.2*cex, cex.lab=1*cex, 
              cex.axis=.9*cex, cex.axis2=1*cex,               
              las=1, xaxs="i", yaxs="i", do_xaxis=TRUE, do_yaxis = TRUE,
              plot_box=TRUE, bty="l", tz="UTC", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_TS_+3A_ts_df">ts_df</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> holding the time series data to be plotted, including the x-vector 'datetime' (in <code>POSIXct</code>-format  and UTC), and the numeric y-vector whose label is defined by <code>y</code>.
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_y">y</code></td>
<td>
<p>character label of time series vector to be plotted (by default 'Depth').
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_xlim">xlim</code></td>
<td>
<p>the x limits (x1, x2) of the plot (by default range(ts_df$datetime), but needs to be specified in <code>empty.plot_TS</code>).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot (by default range(ts_df[[y]]), but needs to be specified in <code>empty.plot_TS</code>).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_xticks_interval">xticks_interval</code></td>
<td>
<p>time step of the x-axis ticklabels in (full) hours. By default 3 hours for xlim differences &lt;= 1 day, and 6 hours for differences &gt; 1 day. 
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_ylab">ylab</code>, <code id="plot_TS_+3A_xlab">xlab</code></td>
<td>

<p>the y- and x-axis labels. By default xlab=&quot;Time (UTC)&quot; and ylab = &quot;Depth (m)&quot;
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_main">main</code>, <code id="plot_TS_+3A_main.line">main.line</code></td>
<td>

<p>main title (by default &quot;Tag ID&quot;) for the plot and its line (see <a href="graphics.html#topic+mtext">mtext</a> for reference).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_plot_info">plot_info</code></td>
<td>

<p>whether the plot title and axes labels should be shown (by default <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_id">ID</code>, <code id="plot_TS_+3A_id_label">ID_label</code></td>
<td>

<p>Tag ID and its label (column name; by default &quot;Serial&quot;) to be selected (e.g. if input data frame holds tagging data from several tags).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_type">type</code></td>
<td>

<p>what type of plot should be drawn. Possible types are:
</p>

<ul>
<li><p><code>"p"</code> for points,
</p>
</li>
<li><p><code>"l"</code> for lines (default),
</p>
</li>
<li><p><code>"b"</code> for both,
</p>
</li>
<li><p><code>"c"</code> for the lines part alone of &quot;b&quot;,
</p>
</li>
<li><p><code>"o"</code> for both 'overlapped',
</p>
</li>
<li><p><code>"n"</code> for nothing (similar to <code>empty.plot_TS</code>-function call)
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_TS_+3A_las">las</code></td>
<td>
<p>numeric in {0,1,2,3}; the style of axis labels
</p>

<dl>
<dt>0:</dt><dd><p>always parallel to the axis [<em>default</em>],</p>
</dd>
<dt>1:</dt><dd><p>always horizontal,</p>
</dd>
<dt>2:</dt><dd><p>always perpendicular to the axis,</p>
</dd>
<dt>3:</dt><dd><p>always vertical.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="plot_TS_+3A_xaxs">xaxs</code>, <code id="plot_TS_+3A_yaxs">yaxs</code></td>
<td>

<p>The style of axis interval calculation to be used for the x-and y-axes. Possible values are &quot;r&quot; and &quot;i&quot; (default). The styles are generally controlled by the range of data or xlim, if given.<br /><br />
Style &quot;r&quot; (regular) first extends the data range by 4 percent at each end and then finds an axis with pretty labels that fits within the extended range.<br /><br />
Style &quot;i&quot; (internal) just finds an axis with pretty labels that fits within the original data range.
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_cex">cex</code>, <code id="plot_TS_+3A_cex.main">cex.main</code>, <code id="plot_TS_+3A_cex.lab">cex.lab</code>, <code id="plot_TS_+3A_cex.axis">cex.axis</code>, <code id="plot_TS_+3A_cex.axis2">cex.axis2</code></td>
<td>
<p>The standard font size of title, axis labels and tick labels.<br />
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_plot_daytimeperiods">plot_DayTimePeriods</code>, <code id="plot_TS_+3A_twilight.set">twilight.set</code></td>
<td>

<p>whether day-time periods ('Night', 'Dawn', 'Day', 'Dusk') should be plotted as shaded areas. In case that plot_DayTimePeriods is set <code>TRUE</code>, the limits of each time period are required (columns <code>sunrise</code>, <code>sunset</code>, <code>dawn.ast</code>,/<code>dawn.naut</code> and <code>dawn.ast</code>/<code>dawn.naut</code> in <code>POSIXct</code>-format. In case of the twilight events, the additional argument <code>twilight.set</code> defines the suffix of the twlight-set to be selected ( <code>"ast"</code> for astronomical dawn and dusks vs <code>"naut"</code> for nautical twilight events).
If any of the day-time columns, described above, is missing, it/they will be calculated based on geolocation estimates (required columns <code>Lon</code> and <code>Lat</code>) through an internal call of function <code>get_DayTimeLimits</code>.<br />
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_do_xaxis">do_xaxis</code>, <code id="plot_TS_+3A_do_yaxis">do_yaxis</code></td>
<td>
<p>Optional arguments in empty.plot_TS to define whether a x and and y-axis shall be plotted (by default <code>TRUE</code>).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_plot_box">plot_box</code>, <code id="plot_TS_+3A_bty">bty</code></td>
<td>

<p>whether a box of box-type <code>bty</code> should be plotted (by default <code>TRUE</code>. <code>bty</code> is one of &quot;o&quot; (the default), &quot;l&quot;, &quot;7&quot;, &quot;c&quot;, &quot;u&quot;, or &quot;]&quot; the resulting box resembles the corresponding upper case letter.
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_return">Return</code></td>
<td>

<p>whether edited time series data set should be returned (by default <code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_tz">tz</code></td>
<td>

<p>The time zone in which the data should be illustrated (By default &quot;UTC&quot;). ATTENTION: The required date format of the input data is &quot;UTC&quot; (across all RchivalTag-functions). Run <code>OlsonNames(tzdir = NULL)</code> for valid time zone definitions.
</p>
</td></tr>
<tr><td><code id="plot_TS_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <a href="graphics.html#topic+plot">plot</a>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ggboxplot_DepthTS_by_hour">ggboxplot_DepthTS_by_hour</a>, <a href="#topic+dy_DepthTS">dy_DepthTS</a>, <a href="#topic+plot_DepthTempTS">plot_DepthTempTS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
ts_df$Serial &lt;- ts_df$DeployID
head(ts_df)

## load same data in LOTEK format
ts_file &lt;- system.file("example_files/104659_PSAT_Dive_Log.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file,date_format="%m/%d/%Y %H:%M:%S")
head(ts_df) ## attention no identifier (Ptt, Serial, DeployID) included!
ts_df$DeployID &lt;- ts_df$Ptt &lt;- "104659"
ts_df$Serial &lt;- "Tag1"

### select subsets (dates to plot)
# plot_DepthTS(ts_df, plot_DayTimePeriods = FALSE, xlim = unique(ts_df$date)[2:3])
# xlim &lt;- c("2016-08-10 6:10:00", "2016-08-11 17:40:00")
# plot_DepthTS(ts_df, plot_DayTimePeriods = FALSE, xlim = xlim)

### check xtick time step:
# plot_DepthTS(ts_df, plot_DayTimePeriods = FALSE, xlim = "2016-08-10")
# plot_DepthTS(ts_df, plot_DayTimePeriods = FALSE, xlim = "2016-08-10", xticks_interval = 2)


### add daytime periods during plot-function call and return extended data set
# ts_df$Lon &lt;- 5; ts_df$Lat &lt;- 43
# plot_DepthTS(ts_df, plot_DayTimePeriods = TRUE, xlim = unique(ts_df$date)[2:3])
# ts_df2 &lt;- plot_DepthTS(ts_df, plot_DayTimePeriods = TRUE, Return = TRUE) 
# names(ts_df)
# names(ts_df2)

### add daytime periods before function call
# ts_df_extended &lt;- get_DayTimeLimits(ts_df)
# plot_DepthTS(ts_df_extended, plot_DayTimePeriods = TRUE)
# plot_DepthTS(ts_df_extended, plot_DayTimePeriods = TRUE, twilight.set = "naut")

### introduce data transmission gaps that are then filled internally
### as well as daytime periods based on interpolated Lon &amp; Lat positions
# ts_df_cutted &lt;- ts_df[-c(200:400, 1800:2200), ]
# plot_DepthTS(ts_df_cutted, plot_DayTimePeriods = FALSE)
# plot_DepthTS(ts_df_cutted, plot_DayTimePeriods = TRUE) 

### example for empty.plotTS and adding time series data as line:
# empty.plot_TS(xlim="2016-08-10",ylim=c(100,0))
# lines(ts_df$datetime, ts_df$Depth)

### alternative:
# plot_DepthTS(ts_df, xlim=c("2016-08-10","2016-08-12"), plot_DayTimePeriods = TRUE, type='n') 
# lines(ts_df$datetime, ts_df$Depth)

</code></pre>

<hr>
<h2 id='RchivalTag'>
RchivalTag - Analyzing and Interactive Visualization of Archival Tagging Data
</h2><span id='topic+RchivalTag'></span>

<h3>Description</h3>

<p><code>RchivalTag</code> provides a set of functions to analyze and visualize different data products from Archival Tags (Supported Models include amongst others: MiniPAT, sPAT, mk10, mk9 from <a href="https://wildlifecomputers.com/">Wildlife Computers</a> as well as LOTEK PSAT Models <a href="https://www.lotek.com/products/psat-series/">LOTEK</a>. Models from other Manufactorers might be supported as well.
</p>

<ul>
<li><p>&quot;(Depth) time series data&quot; (See <a href="#topic+plot_TS">plot_TS</a>, <a href="#topic+plot_DepthTS">plot_DepthTS</a>,  <a href="#topic+dy_DepthTS">dy_DepthTS</a>, <a href="#topic+empty.plot_TS">empty.plot_TS</a>)
</p>
</li>
<li><p>&quot;Time-at-Depth (TaD) and Time-at-Temperature (TaT) fequencies&quot; (See <a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tad">hist_tad</a> &amp; <a href="#topic+hist_tat">hist_tat</a>)
</p>
</li>
<li><p>&quot;Depth Temperature profiles (time series data)&quot; (See <a href="#topic+plot_DepthTempTS">plot_DepthTempTS</a>, <a href="#topic+plot_DepthTempTS_resampled">plot_DepthTempTS_resampled</a>, <a href="#topic+plot_DepthTempTS_resampled_PDT">plot_DepthTempTS_resampled_PDT</a>, <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, <a href="#topic+get_thermalstrat">get_thermalstrat</a> &amp; <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a>)
</p>
</li>
<li><p>&quot;PDT (PAT-style Depth Temperature profiles) data&quot; (See <a href="#topic+read_PDT">read_PDT</a>, <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, <a href="#topic+get_thermalstrat">get_thermalstrat</a> &amp; <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a>)
</p>
</li>
<li><p>&quot;visualization of geolocation estimates&quot; (See: <a href="#topic+ggplot_geopos">ggplot_geopos</a>, <a href="#topic+ggplotly_geopos">ggplotly_geopos</a>)
</p>
</li></ul>



<h3>Details</h3>

<p><b>TaD-/TaT-histogram data</b><br />
- The package allows to read and calculate standard summary data products (TaD-/TaT-profiles, see above) from recovered or transmitted time series data sets as well as to merge and visualize such summary data products from different tag setups/tagging programs. For more information on these data products, please see: Wildlife Computers (2016).
</p>
<p><b>Depth time series data</b><br />
- data visualization, optionally highlighting daytime differences (dawn, day, dusk, night).
</p>
<p><b>Depth-temperature time series data</b><br />
- data visualization and examination of the thermal stratification of the water column (i.e. thermocline depth, gradient and stratification index), based on previously interpolated. The paper by Bauer et al. (2015) is highly recommended in this context. 
</p>
<p><b>Depth-temperature time series data</b><br />
- data visualization and examination of the thermal stratification of the water column (i.e. thermocline depth, gradient and stratification index), based on previously interpolated. The paper by Bauer et al. (2015) is highly recommended in this context. 
</p>
<p><b>interactive geolocation vizualiation</b><br />
- data visualization via <a href="https://ggplot2.tidyverse.org/">ggplot2</a> and <a href="https://plotly.com/r/">plot_ly</a> based on <a href="https://cran.r-project.org/package=oceanmap">oceanmap</a> standard maps.
</p>
<p><b>Compatibility</b><br />
So far, the package is mainly adapted for archival tagging data from <a href="https://wildlifecomputers.com/">Wildlife Computers</a>, but can also be applied to data from other tag manufacturers (e.g. see <a href="#topic+ts2histos">ts2histos</a> in order to calculate TaD &amp; TaT-frequencies from time series data). Function examples are based on the transmitted data sets of a miniPAT-tag from the <a href="https://anr.fr/Project-ANR-14-ACHN-0002">BLUEMED-project</a>, funded by the French National Research Agency (ANR; <a href="https://anr.fr">https://anr.fr</a>).
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, <a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>
<p>Bauer, R., JM. Fromentin, H. Demarcq and S. Bonhommeau (2017) Habitat use, vertical and horizontal behaviour of Atlantic bluefin tuna (Thunnus thynnus) in the Northwestern Mediterranean Sea in relation to oceanographic conditions. Deep-Sea Research Part II: Topical Studies in Oceanography, 141: 248-261, <a href="https://doi.org/10.1016/j.dsr2.2017.04.006">doi:10.1016/j.dsr2.2017.04.006</a>
</p>
<p>Bauer, R., F. Forget, JM. Fromentin and M. Capello (2020) Surfacing and vertical behaviour of Atlantic bluefin tuna (*Thunnus thynnus*) in the Mediterranean Sea: implications for aerial surveys. ICES Journal of Marine Science, 77(5): 1979-1991, <a href="https://doi.org/10.1093/icesjms/fsaa083">doi:10.1093/icesjms/fsaa083</a>
</p>
<p>Wildlife Computers (2016) MiniPAT-User-Guide, 4 April 2016, 26 pp. <a href="https://static.wildlifecomputers.com/MiniPAT-User-Guide1.pdf">https://static.wildlifecomputers.com/MiniPAT-User-Guide1.pdf</a>
</p>

<hr>
<h2 id='read_histos'>
reads a TAD/TAT-histogram file from archival tags
</h2><span id='topic+read_histos'></span>

<h3>Description</h3>

<p>reads or posttreats a manually loaded standard histogram data file, containing Time-at-Depth (TAD) and Time-at-Temperature (TAT) frequency data, from archival tags by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
read_histos(hist_file, date_format, lang_format="en", tz="UTC", dep.end, Serial, 
            force_24h=TRUE, min_perc, omit_negatives=TRUE, right_truncate=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_histos_+3A_hist_file">hist_file</code></td>
<td>

<p>character string indicating the name of a standard <a href="https://wildlifecomputers.com/">Wildlife Computers</a> file to read or the <a href="base.html#topic+data.frame">data.frame</a> of a manually loaded histogram data file. The combination of the columns <code>DeployID</code>, <code>Ptt</code> and <code>Serial</code> is assumed to provide an unique key to distinguish data from indiviudal tags.
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_force_24h">force_24h</code></td>
<td>

<p>whether histogram data with a time step of less than 24h should be merged to 24h (default is <code>TRUE</code>).
Note that the current version of <a href="#topic+hist_tad">hist_tad</a> and <a href="#topic+hist_tat">hist_tat</a> was written for 24h data!
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_date_format">date_format</code>, <code id="read_histos_+3A_lang_format">lang_format</code>, <code id="read_histos_+3A_tz">tz</code></td>
<td>

<p>character strings indicating the date format, language format and the corresponding time zone, defined by the vectors Date and Time (by default: date_format=&quot;%H:%M:%S %d-%b-%Y&quot;, lang_format=&quot;en&quot;, tz='UTC')
If formatting fails, please check as well the input language format, defined by <code>lang_format</code> (and use abbrviations such as &quot;en&quot; for English,&quot;es&quot; for Spanish, &quot;fr&quot; for French, etc.) as well.
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_dep.end">dep.end</code></td>
<td>

<p><a href="base.html#topic+Date">Date</a> specifying the deployment end of the tag.
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_serial">Serial</code></td>
<td>

<p>character-string indicating the Serial number of the tag to be selected. (in case of multi-tag histogram files.)
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_min_perc">min_perc</code></td>
<td>

<p>optional number, defining the minimum data coverage (in percent) of histogram entries obtained from depth time series data.
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_omit_negatives">omit_negatives</code></td>
<td>

<p>merge negative depth and temperature bins with next positive bin (&gt;= 0; default is <code>TRUE</code>). 
</p>
</td></tr>
<tr><td><code id="read_histos_+3A_right_truncate">right_truncate</code></td>
<td>

<p>truncate the values of the last tat- and tad-bin to 45 degrees and 2000 m, respectively (default is <code>TRUE</code>). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads or posttreats a manually loaded standard Wildlife Computers histogram file including Time-at-Depth (TAD) and Time-at-Temperature (TAT) frequency data. In the post-treatment, the histogram data is split in lists of TAD and TAT per individual (see below). Thus processed data from several histogram files (or similarly processed time series data) can be combined using the function <a href="#topic+combine_histos">combine_histos</a>. Merging of histogram data from several tags, based on similar or user-specified TAD and TAT-<code>bin_breaks</code>, can be done by applying function <a href="#topic+merge_histos">merge_histos</a>. To generate TAD/TAT histogram data from depth and temperature time series data, see <a href="#topic+ts2histos">ts2histos</a>.
</p>


<h3>Value</h3>

<p>A list-of-lists containing the loaded histogram data. Lists of TAD and TAT data are distinguished at the first nesting level. Further sublists include the <code>bin_breaks</code> and <a href="base.html#topic+data.frame">data.frame</a>s of the histogram data per tag (ID).
Tag IDs are constructed based on the columns <code>DeployID</code>, <code>Ptt</code> and <code>Serial</code> keys (e.g. DeployID.101_Ptt.102525). <strong>The data.frames of the histogram data also contain average (avg) and standard deviation (SD) of depth and temperature values that are estimated internally from the TAD and TAT data sets (not measured!). The accuracy of these estimates thus depends on the number and selection of bin breaks</strong>, unlike <a href="#topic+ts2histos">ts2histos</a>-generated values that are directly estimated from time series data. See statistics-example below.
</p>
<p>$ TAD:List<br />
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br />
.. .. ..$ DeployID <br />
.. .. ..$ Ptt <br />
.. .. ..$ datetime <br />
.. .. ..$ date <br />
.. .. ..$ Bin1 <br />
..
.. .. ..$ Bin? (up to number of bin breaks)<br />
.. .. ..$ avg (average depth estimated!! from histogram data)<br />
.. .. ..$ SD (average depth estimated!! from histogram data) <br />
</p>
<p>$ TAT:List<br /> 
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame (with columns as above)<br /> 
..$ ID2  : List of 2<br />
...
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+combine_histos">combine_histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tad">hist_tad</a>, <a href="#topic+hist_tat">hist_tat</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## read and merge 12h histogram data:
# 12h_hist_file &lt;- system.file("example_files/67851-12h-Histos.csv",package="RchivalTag")
# hist_dat_0 &lt;- read_histos(12h_hist_file,min_perc=100) # omit incomplete days
# hist_tad(hist_dat_0)
#hist_tat(hist_dat_0)

## example 1) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)

## part VI - statistics:
# get histogram data with histogram-derived average depth and temperature values
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
avg1 &lt;- hist_dat_1$TAD$DeployID.15P1019_Ptt.104659$df$avg # infered from the histogram data

# generate histogram data and average/sd-estimates from depth time series data of the same tag.
# attention! unlike for histogram files, the average/sd-estimates are calculated
# directly from depth time series data and not from the binned histogram data
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)

tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)
hist_dat_2 &lt;- ts2histos(ts_df, tad_breaks = tad_breaks)
avg2 &lt;- hist_dat_2$TAD$merged$df$avg # directly estimated from the depth time series data

# check accuracy of average depth values:
plot(avg1, avg2) 
avg1-avg2
abline(0,b = 1,lty="dotted")

## crosscheck!
# library(plyr)
# ts_stats &lt;- ddply(ts_df,c("date"),function(x) c(avg=mean(x$Depth,na.rm=T),SD=sd(x$Depth,na.rm=T)))
# avg2==ts_stats$avg

# path &lt;- system.file("example_files",package="RchivalTag")
# PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
# head(PDT)
# image_TempDepthProfiles(interpolate_PDTs(PDT)[[1]])

## add information
# lines(ts_stats$date+.5,ts_stats$avg)
# add &lt;- hist_dat_2$TAD$merged$df
# lines(add$date+.5,add$avg)
# axis(2,at=50,las=1)
# abline(h=20,lty="dashed",col="violet",lwd=3)


</code></pre>

<hr>
<h2 id='read_PDT'>
read PDT data from archival one or multiple tags
</h2><span id='topic+read_PDT'></span>

<h3>Description</h3>

<p>reads PDT data (PAT-style Depth Temperature profiles) from archival tags by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>).
The PDT file can contain data from one or multiple tags.
<br /><br /><strong>What are PDTs?</strong>
<br /> PDT data provides minimum and maximum water temperatures during a user-programmed interval (usually 24h) at 8 to 16 depths. The sampled depths are thereby rounded (binned) to multiples of 8 and include the minimum and maximum depth bins as well as the 6 to 14 most frequent depth bins at which the tagged animal was located. The total number of depth bins (8 or 16) also depends on the tagged animals' behaviour. If the animal was in waters deeper than 400 m during the summary data period, the range of temperature at 16 depth bins will be reported, otherwise 8.
<br /><br /><strong>Why using PDT data?</strong>
<br /> Despite its low resolution, PDT data can give accurate information on the in-situ thermal stratification of the water column (e.g. thermocline depth, stratification index, ocean heat content) experienced by the tagged animal, as illustrated by Bauer et al. (2015). Accordingly, PDT data can provide precious insights into the relations between animal behaviour and environmental conditions. See the example section below on how to obtain thermal stratification indicators of the water column from PDT data.
</p>
<p>For instance, daily PDT data can be interpolated and then visualized using functions <a href="#topic+interpolate_PDTs">interpolate_PDTs</a> and <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a>, respectively. This faciliates the analysis of temporal changes of temperature profiles, for instance, in relation to animal behaviour (e.g. diving behaviour).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_PDT(pdt_file, folder, sep=",",date_format,lang_format="en",tz="UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_PDT_+3A_pdt_file">pdt_file</code></td>
<td>

<p>character string indicating the name of a standard PDT-file. The Date-vector of the file is expected to be or the format &quot;%H:%M:%S %d-%b-%Y, tz='UTC'&quot;.
</p>
</td></tr>
<tr><td><code id="read_PDT_+3A_folder">folder</code></td>
<td>

<p>path to pdt-file.
</p>
</td></tr>
<tr><td><code id="read_PDT_+3A_sep">sep</code></td>
<td>

<p>the field separator character. Values on each line of the file are separated by this character (default is ',').
</p>
</td></tr>
<tr><td><code id="read_PDT_+3A_date_format">date_format</code>, <code id="read_PDT_+3A_lang_format">lang_format</code>, <code id="read_PDT_+3A_tz">tz</code></td>
<td>

<p>character strings indicating the date format, language format and the corresponding time zone, defined by the vectors Date and Time (by default: date_format=&quot;%H:%M:%S %d-%b-%Y&quot;, lang_format=&quot;en&quot;, tz='UTC')
If formatting fails, please check as well the input language format, defined by <code>lang_format</code> (and use abbrviations such as &quot;en&quot; for English,&quot;es&quot; for Spanish, &quot;fr&quot; for French, etc.) as well.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="base.html#topic+data.frame">data.frame</a> with the columns:<br />
&quot;pdt_file&quot;, &quot;DeployID&quot;, &quot;Ptt&quot;, &quot;NumBins&quot;, &quot;Depth&quot;, &quot;MinTemp&quot;, &quot;MaxTemp&quot;, &quot;datetime&quot;, &quot;date&quot;, &quot;MeanPDT&quot;
<br /> <b>Attention:  Column &quot;MeanPDT&quot; is not measured</b> but calculated as the average of &quot;MinTemp&quot; and &quot;MaxTemp&quot; values.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+bin_TempTS">bin_TempTS</a>, <a href="#topic+interpolate_PDTs">interpolate_PDTs</a>, <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## step I) read sample PDT data file:
path &lt;- system.file("example_files",package="RchivalTag")
PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
head(PDT)

## step II) interpolate average temperature fields (MeanPDT) from PDT file:
# m &lt;- interpolate_PDTs(PDT)
# str(m)
# m$sm

## step III) calculate thermal stratifcation indicators per day (and tag):
# strat &lt;- get_thermalstrat(m, all_info = TRUE)
# strat &lt;- get_thermalstrat(m, all_info = FALSE)

## step IV) plot interpolated profiles:
# image_TempDepthProfiles(m$station.1)


</code></pre>

<hr>
<h2 id='read_TS'>
reads Time Series Data from Archival Tags
</h2><span id='topic+read_TS'></span>

<h3>Description</h3>

<p>reads Time Series Data (e.g. Depth and Temperature) from Archival Tags (Supported Models: MiniPAT, sPAT, recovered mk10, mk9 from <a href="https://wildlifecomputers.com/">Wildlife Computers</a> as well as LOTEK PSAT Models <a href="https://www.lotek.com/products/psat-series/">LOTEK</a>. Models from other Manufactorers might be supported as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_TS(ts_file, header=TRUE, sep=",", skip = 0, 
        date_format, lang_format = "en", tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_TS_+3A_ts_file">ts_file</code></td>
<td>

<p>character string indicating the name of a standard <a href="https://wildlifecomputers.com/">Wildlife Computers</a> file to read or the <a href="base.html#topic+data.frame">data.frame</a> of a manually loaded histogram data file. The file is assumed to include the columns <code>Day</code>, <code>Time</code> (or a preformatted date-time vector termed <code>datetime</code> in &quot;UTC&quot; format.) as well as at one of the subsequent columns <code>DeployID</code>, <code>Ptt</code> and <code>Serial</code> to distinguish data from indiviudal tags.
</p>
</td></tr>
<tr><td><code id="read_TS_+3A_header">header</code></td>
<td>

<p>a logical value indicating whether the file contains the names of the variables as its first line. If missing, the value is determined from the file format: header is set to TRUE if and only if the first row contains one fewer field than the number of columns.
</p>
</td></tr>
<tr><td><code id="read_TS_+3A_sep">sep</code></td>
<td>

<p>the field separator character. Values on each line of the file are separated by this character. If sep = &quot;&quot; the separator is 'white space', that is one or more spaces, tabs, newlines or carriage returns.
</p>
</td></tr>
<tr><td><code id="read_TS_+3A_skip">skip</code></td>
<td>

<p>integer: the number of lines of the data file to skip before beginning to read data.
</p>
</td></tr>
<tr><td><code id="read_TS_+3A_date_format">date_format</code>, <code id="read_TS_+3A_lang_format">lang_format</code>, <code id="read_TS_+3A_tz">tz</code></td>
<td>

<p>character strings indicating the date format, language format and the corresponding time zone, defined by the vectors Date and Time (by default: date_format=&quot;%d-%b-%Y %H:%M:%S&quot;, lang_format=&quot;en&quot;, tz='UTC')
If formatting fails, please check as well the input language format, defined by <code>lang_format</code> (and use abbrviations such as &quot;en&quot; for English,&quot;es&quot; for Spanish, &quot;fr&quot; for French, etc.) as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads a time series data file from archival tags. Data sets are &quot;completed&quot; to facilitate an assessment of the data coverage (i.e. by <a href="#topic+ts2histos">ts2histos</a> or <a href="#topic+hist_tad">hist_tad</a>).
</p>


<h3>Value</h3>

<p>A data frame (<a href="base.html#topic+data.frame">data.frame</a>) containing a representation of the data in the file.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+ts2histos">ts2histos</a>, <a href="#topic+hist_tad">hist_tad</a>, <a href="#topic+plot_TS">plot_TS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)

## other date_format:
ts_file2 &lt;- system.file("example_files/104659-Series_date_format2.csv",package="RchivalTag")
# ts_miniPAT2 &lt;- read_TS(ts_file2) # run to see error message
ts_miniPAT2 &lt;- read_TS(ts_file2,date_format = "%d-%m-%Y %H:%M:%S")
head(ts_miniPAT2)

## other date_format and lang_format:
ts_file_ES &lt;- system.file("example_files/104659-Series_date_format_ES.csv",package="RchivalTag")
# ts_miniPAT_ES &lt;- read_TS(ts_file_ES) # run to see error message
ts_miniPAT_ES &lt;- read_TS(ts_file_ES,skip=1,sep=";",header = TRUE, 
                         date_format = "%d/%b/%y %H:%M:%S",lang_format = "es")
head(ts_miniPAT_ES)


## load same data in LOTEK format
ts_file &lt;- system.file("example_files/104659_PSAT_Dive_Log.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file,date_format="%m/%d/%Y %H:%M:%S")
head(ts_df) ## attention no identifier (Ptt, Serial, DeployID) included!
ts_df$DeployID &lt;- ts_df$Ptt &lt;- "104659"

## example 1) convert only DepthTS data to daily TaD frequencies:
tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)
tat_breaks &lt;- c(10,12,15,17,18,19,20,21,22,23,24,27)

histos &lt;- ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks)
histos$TAD$merged$df$nperc ## check completeness of TAD data sets
histos$TAT$merged$df$nperc ## check completeness of TAT data sets
# histos &lt;- ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks,min_perc = 90)


### example 2) add daytime (Day vs Night) information and plot results
# add daytime periods during plot-function call and return extended data set
# ts_df$Lon &lt;- 5; ts_df$Lat &lt;- 43
# plot_DepthTS(ts_df, plot_DayTimePeriods = TRUE, xlim = unique(ts_df$date)[2:3])
# ts_df2 &lt;- plot_DepthTS(ts_df, plot_DayTimePeriods = TRUE, Return = TRUE) 
# names(ts_df)
# names(ts_df2)

### add daytime periods before function call
# ts_df_extended &lt;- get_DayTimeLimits(ts_df)
# plot_DepthTS(ts_df_extended, plot_DayTimePeriods = TRUE)
# plot_DepthTS(ts_df_extended, plot_DayTimePeriods = TRUE, twilight.set = "naut")


</code></pre>

<hr>
<h2 id='resample_PDT'>
resample temperature at depth data from interpolated daily temperature at depth profiles or time series data
</h2><span id='topic+resample_PDT'></span><span id='topic+resample_DepthTempTS'></span>

<h3>Description</h3>

<p>interpolates depth-temperature data from a provided source (depth-temperature time series data or PDT data) and resamples the interpolated data by the depth time series data provided, to faciliate <a href="#topic+plot_DepthTempTS">plot_DepthTempTS</a>-plots even for tags with no temperature time series data or to improve interpolation results of the <a href="#topic+plot_DepthTempTS">plot_DepthTempTS</a>-plots from low-resolution depth-temperature time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_PDT(ts_df, PDT, ...)
resample_DepthTempTS(ts_df, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_PDT_+3A_ts_df">ts_df</code></td>
<td>

<p><code>ts_df</code> is a <a href="base.html#topic+data.frame">data.frame</a> with depth-temperature time series data data or only depth time series data. Required columns are <code>Depth</code> for the depth data and a column containing temperature data, whose name is defined by <code>Temp_field</code>, by default Temperature.
</p>
</td></tr>
<tr><td><code id="resample_PDT_+3A_pdt">PDT</code></td>
<td>

<p>an optional data.frame containing PDT-data from <a href="#topic+read_PDT">read_PDT</a>.
</p>
</td></tr>
<tr><td><code id="resample_PDT_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, or <a href="#topic+interpolate_PDTs">interpolate_PDTs</a>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <a href="base.html#topic+data.frame">data.frame</a> with depth-temperature time series data.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>References</h3>

<p>Bauer, R., F. Forget and JM. Fromentin (2015) Optimizing PAT data transmission: assessing the accuracy of temperature summary data to estimate environmental conditions. Fisheries Oceanography, 24(6): 533-539, 
<a href="https://doi.org/10.1111/fog.12127">doi:10.1111/fog.12127</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+read_PDT">read_PDT</a>, <a href="#topic+interpolate_TempDepthProfiles">interpolate_TempDepthProfiles</a>, <a href="#topic+get_thermalstrat">get_thermalstrat</a>, <a href="#topic+image_TempDepthProfiles">image_TempDepthProfiles</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## read in depth temperature time series data (sampling rate 5min)
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)

## run daily interpolation of depth temperature time series data
m &lt;- interpolate_TempDepthProfiles(ts_df)
image_TempDepthProfiles(m$station.1)
ts_df2 &lt;- resample_DepthTempTS(ts_df) ## reassign temperature at depth values

## read PDT data from same tag 
## (= low resolution depth temperature data (8 Depth and Temperature records per day))
path &lt;- system.file("example_files",package="RchivalTag")
PDT &lt;- read_PDT("104659-PDTs.csv",folder=path)
head(PDT)

m &lt;- interpolate_PDTs(PDT) ## interpolate PDTs
image_TempDepthProfiles(m$station.1)
ts_df3 &lt;- resample_PDT(ts_df, PDT) ## reassign temperature at depth values



#### plot results:
## 1) dot plots:

## dot plot of RECORDED depth temperature time series data
## plot_DepthTempTS(ts_df, do_interp = FALSE) 

## dot plot of RESAMPLED depth temperature time series data 
## from previously daily interpolated depth temperature time series data
# plot_DepthTempTS(ts_df2, do_interp = FALSE) 

## dot plot of RESAMPLED depth temperature time series data 
## from daily interpolated PDT data (external resampling)
# plot_DepthTempTS(ts_df3, do_interp = FALSE) 

## dot plot of RESAMPLED depth temperature time series data 
## from daily interpolated PDT data (internal resampling)
# plot_DepthTempTS_resampled_PDT(ts_df, PDT, do_interp = FALSE) 


## 2) line plots:

## line plot of depth temperature time series data
## (internal interpolation between neighboring temperature records)
## not recommended for low resolution time series data
# plot_DepthTempTS(ts_df, do_interp = TRUE) 

## line plot of depth temperature time series data 
## (based on internal daily interpolated depth temperature time series data)
# plot_DepthTempTS_resampled(ts_df, do_interp = TRUE) 

## line plot of depth temperature time series data 
## from daily interpolated PDT data (external resampling)
# plot_DepthTempTS(ts_df3, do_interp = TRUE) 

## line plot of depth temperature time series data
## from daily interpolated PDT data (internal resampling)
# plot_DepthTempTS_resampled_PDT(ts_df, PDT, do_interp = TRUE)

</code></pre>

<hr>
<h2 id='resample_TS'>
resample time series data at a lower resolution
</h2><span id='topic+resample_TS'></span><span id='topic+empty.resample_TS'></span>

<h3>Description</h3>

<p>resample time series data at a lower resolution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_TS(df, tstep, nsims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_TS_+3A_df">df</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> holding the time series data to be resampled, including a 'datetime'-vector (in <code>POSIXct</code>-format  and UTC).
</p>
</td></tr>
<tr><td><code id="resample_TS_+3A_tstep">tstep</code></td>
<td>
<p>numeric vector indicating the resampling resolution (in seconds).
</p>
</td></tr>
<tr><td><code id="resample_TS_+3A_nsims">nsims</code></td>
<td>
<p>number of simulated datasets to be generated. If missing, the maximum number of datasets will be returned, based on a moving window of the temporal resolution of the input dataset.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+plot_TS">plot_TS</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read.table(ts_file, header = TRUE, sep = ",")
head(ts_df)
ts_df$datetime &lt;- as.POSIXct(strptime(paste(ts_df$Day, ts_df$Time), 
                              "%d-%b-%Y %H:%M:%S",tz = "UTC"))

tsims &lt;- resample_TS(ts_df,600)
length(tsims)

</code></pre>

<hr>
<h2 id='simulate_DepthTS'>
simulate depth time series data
</h2><span id='topic+simulate_DepthTS'></span>

<h3>Description</h3>

<p>function to simulate depth series data from a template data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_DepthTS(ts_df, ndays=10, gaps=TRUE, trate=90, 
                 random_Depth=TRUE, ref_Depth_lim=300, random_Depth_lim=c(100, 700))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_DepthTS_+3A_ts_df">ts_df</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> holding the template depth time series data.
</p>
</td></tr>
<tr><td><code id="simulate_DepthTS_+3A_ndays">ndays</code></td>
<td>
<p>number of days of depth time series data that should be simulated).
</p>
</td></tr>
<tr><td><code id="simulate_DepthTS_+3A_gaps">gaps</code>, <code id="simulate_DepthTS_+3A_trate">trate</code></td>
<td>
<p>Whether gaps should be introduced into the dataset according to the transmission rate (<code>trate</code>), in addition to any potential gaps in the template data set.
</p>
</td></tr>
<tr><td><code id="simulate_DepthTS_+3A_random_depth">random_Depth</code>, <code id="simulate_DepthTS_+3A_ref_depth_lim">ref_Depth_lim</code>, <code id="simulate_DepthTS_+3A_random_depth_lim">random_Depth_lim</code></td>
<td>

<p>Whether depth records from the template data set should be additonaly randomized. In this case, depth records &gt;= <code>ref_Depth_lim</code> will be replaced by values between the limits of <code>random_Depth_lim</code> (i.e. in the default settings a record of &gt;= 300 will be replaced by a value between 100 and 700 m).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+dy_DepthTS">dy_DepthTS</a>, <a href="#topic+plot_DepthTS">plot_DepthTS</a>, <a href="#topic+plot_data_coverage">plot_data_coverage</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
# ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
# ts_df &lt;- read_TS(ts_file)
# ts_df$Serial &lt;- ts_df$DeployID
# head(ts_df)
# dy_DepthTS(ts_df) # plot original data
# 
# ts_df_sim &lt;- simulate_DepthTS(ts_df) # simulate data
# 
# dy_DepthTS(ts_df_sim) # plot simulated data
# 
# library(dplyr)
# meta &lt;- rbind(ts_df[,names(ts_df_sim)],ts_df_sim) %&gt;% 
#   group_by(DeployID, Serial, Ptt) %&gt;%
#   summarise(dep.date=min(date),pop.date=max(date)) %&gt;% 
#   as.data.frame()
# 
# ts_list &lt;- list(ts_df,ts_df_sim)
# names(ts_list) &lt;- meta$Serial
# 
# # plot data coverage
# plot_data_coverage(x = ts_list,type="ts", meta = meta)
</code></pre>

<hr>
<h2 id='ts2histos'>
convert depth and temperature time series data to discrete Time-at-Depth and Time-at-Temperature data (histogram data)
</h2><span id='topic+ts2histos'></span>

<h3>Description</h3>

<p>convert depth and temperature time series data to discrete Time-at-Depth (TaD) and Time-at-Temperature (TaT) data (histogram data) at user-defined breakpoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts2histos(ts_df, tad_breaks=NULL, tat_breaks=NULL, split_by=NULL, 
          aggregate_by="Ptt",min_perc, omit_negatives=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts2histos_+3A_ts_df">ts_df</code></td>
<td>

<p>dataframe of depth time series data. Obligatory columns are the numeric vector &quot;Depth&quot;, &quot;date&quot; (of class <a href="base.html#topic+Date">Date</a>) and &quot;Serial&quot;. <code>split.by</code> defines an optional vector to consider (e.g. <code>day.period</code>).
</p>
</td></tr>
<tr><td><code id="ts2histos_+3A_tad_breaks">tad_breaks</code>, <code id="ts2histos_+3A_tat_breaks">tat_breaks</code></td>
<td>

<p>a numeric vector, defining the depth and/or temperature breakpoints of the histogram cells.
</p>
</td></tr>
<tr><td><code id="ts2histos_+3A_split_by">split_by</code></td>
<td>

<p>Name of the column with logical entries by which TaD/TaT data shall be splitted (e.g. daytime; see <a href="#topic+classify_DayTime">classify_DayTime</a>.).
</p>
</td></tr>
<tr><td><code id="ts2histos_+3A_aggregate_by">aggregate_by</code></td>
<td>

<p>character vector defining the columns by which the tagging data should be aggregated. Should contain columns that identify tags (e.g. Serial, Ptt, DeployID) the date and/or day time period (to seperate records from night, day, dawn and dusk see <a href="#topic+classify_DayTime">classify_DayTime</a>). Default values are: date, Day and Ptt.
</p>
</td></tr>
<tr><td><code id="ts2histos_+3A_min_perc">min_perc</code></td>
<td>

<p>optional number, defining the minimum data coverage (in percent) of histogram entries obtained from depth time series data.
</p>
</td></tr>
<tr><td><code id="ts2histos_+3A_omit_negatives">omit_negatives</code></td>
<td>

<p>treat negative depth and temperature records as 0 (default is <code>TRUE</code>). 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time-at-Depth and Time-at-Temperature fequencies (histograms) are a standard data product of archival tags (incl. tag models TDR-Mk9, PAT-Mk10 and miniPAT by <a href="https://wildlifecomputers.com/">Wildlife Computers</a>) that allow to assess habitat preferences of tagged animals.  It can be likewise generated from transmitted or recovered time series data sets, which is the purpose of this function. 
</p>
<p>However, different depth and temperature bin breaks are often used during different deployment programs, which makes a later comparitive analysis of TaT and TaD data difficult. For such cases, the functions <a href="#topic+combine_histos">combine_histos</a> and <a href="#topic+merge_histos">merge_histos</a> can be applied to merge TaT and TaD frequencies based on common bin breaks of different tags.
</p>
<p>To visualize Time-at-Temperature (TaT) and Time-at-Depth (TaD) data, please see <a href="#topic+hist_tat">hist_tat</a> and <a href="#topic+hist_tad">hist_tad</a>, respectively.
</p>


<h3>Value</h3>

<p>A list-of-lists containing the loaded histogram data. Lists of TaD and TaT data are distinguished at the first nesting level. Further sublists include the <code>bin_breaks</code> and <a href="base.html#topic+data.frame">data.frame</a>s of the generated histogram data. <strong>The data.frames of the histogram data thereby also contain average (avg) and standard deviation (SD) of depth and temperature values that are likewise directly estimated from time series data</strong>, unlike <a href="#topic+read_histos">read_histos</a>-generated values that are estimated from the histogram data. The accuracy of latter estimates thus depends on the number and selection of bin breaks (see statistics-example in <a href="#topic+read_histos">read_histos</a>).
</p>
<p>$ TaD:List<br />
..$ merged  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br />
.. .. ..$ DeployID <br />
.. .. ..$ Ptt <br />
.. .. ..$ datetime <br />
.. .. ..$ date <br />
.. .. ..$ Bin1 <br />
..
.. .. ..$ Bin? (up to number of bin breaks)<br />
.. .. ..$ avg (average depth estimated!! from histogram data)<br />
.. .. ..$ SD (average depth estimated!! from histogram data) <br />
</p>
<p>$ TaT:List<br /> 
..$ merged  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame (with columns as above)<br /> 
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+read_histos">read_histos</a>, <a href="#topic+hist_tad">hist_tad</a>, <a href="#topic+merge_histos">merge_histos</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>### load sample depth and temperature time series data from miniPAT:
ts_file &lt;- system.file("example_files/104659-Series.csv",package="RchivalTag")
ts_df &lt;- read_TS(ts_file)
head(ts_df)

tad_breaks &lt;- c(0, 2, 5, 10, 20, 50, 100, 200, 300, 400, 600, 2000)
tat_breaks &lt;- c(10,12,15,17,18,19,20,21,22,23,24,27)


## example 1a) convert only DepthTS data to daily TaD frequencies:
ts2histos(ts_df, tad_breaks = tad_breaks)
# hist_tad(ts_df, bin_breaks = tad_breaks)
hist_tad(ts_df, bin_breaks = tad_breaks, do_mid.ticks = FALSE)

## convert 1b) only TemperatureTS data to daily TaT frequencies:
tat &lt;- ts2histos(ts_df, tat_breaks = tat_breaks)
hist_tat(ts_df, bin_breaks = tat_breaks, do_mid.ticks = FALSE)
hist_tat(tat$TAT$merged, do_mid.ticks = FALSE)

## convert 1c) DepthTS &amp; TemperatureTS data to daily TaD &amp; TaT frequencies:
histos &lt;- ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks)
histos$TAD$merged$df$nperc ## check completeness of TAD data sets
histos$TAT$merged$df$nperc ## check completeness of TAT data sets
# histos &lt;- ts2histos(ts_df, tad_breaks = tad_breaks, tat_breaks = tat_breaks,min_perc = 90)

## convert 1d) back-to-back histogram showing day vs night TaD frequencies:
ts_df$Lat &lt;- 4; ts_df$Lon=42.5 ## required geolocations to estimate daytime
head(ts_df)
ts_df2 &lt;- classify_DayTime(get_DayTimeLimits(ts_df)) # estimate daytime
head(ts_df2)

ts2histos(ts_df2, tad_breaks = tad_breaks,split_by = "daytime")
hist_tad(ts_df2, bin_breaks = tad_breaks,split_by = "daytime", do_mid.ticks = FALSE)


## example 2) rebin daily TaD frequencies:
tad &lt;- ts2histos(ts_df, tad_breaks = tad_breaks)
tad2 &lt;- rebin_histos(hist_list = tad, tad_breaks = tad_breaks[c(1:3,6:12)])
par(mfrow=c(2,2))
hist_tad(tad, do_mid.ticks = FALSE) ## example for multiple individuals
hist_tad(tad$TAD$merged, do_mid.ticks = FALSE)
hist_tad(tad$TAD$merged, bin_breaks = tad_breaks[c(1:3,6:12)]) ## from inside hist_tad


</code></pre>

<hr>
<h2 id='unmerge_histos'>
unmerge previously grouped or merged lists of TAD/TAT frequency data
</h2><span id='topic+unmerge_histos'></span>

<h3>Description</h3>

<p>This function unmerges previously grouped or merged lists of TAD/TAT frequency data, and thus allows to add TAD/TAT lists from new tags (see <a href="#topic+combine_histos">combine_histos</a>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unmerge_histos(hist_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unmerge_histos_+3A_hist_list">hist_list</code></td>
<td>

<p>A previously grouped or merged list-of-lists to be unmerged (seperated by tags).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-of-lists of ungrouped/unmerged TAD and TAT frequency data.
</p>
<p>$ TAD:List<br />
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br />
$ TAT:List<br /> 
..$ ID1  : List of 2<br />
.. ..$ bin_breaks: num<br /> 
.. ..$ df        : data.frame <br /> 
..$ ID2  : List of 2<br />
...
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+combine_histos">combine_histos</a>, <a href="#topic+merge_histos">merge_histos</a>, <a href="#topic+hist_tad">hist_tad</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## example 1) read, merge and plot TAD frequency data from several files:
## part I - read histogram data from two files:
hist_dat_1 &lt;- read_histos(system.file("example_files/104659-Histos.csv",package="RchivalTag"))
hist_dat_2 &lt;- read_histos(system.file("example_files/104659b-Histos.csv",package="RchivalTag"))
## note the second list is based on the same data (tag), but on different bin_breaks

## part II - combine TAD/TAT frecuency data from seperate files in one list:
hist_dat_combined &lt;- combine_histos(hist_dat_1, hist_dat_2)
par(mfrow=c(2,1))
hist_tad(hist_dat_combined)
hist_tat(hist_dat_combined)

## part III - force merge TAD/TAT frecuency data from seperate files 
# in one list, by applying common bin_breaks:
hist_dat_merged &lt;- merge_histos(hist_dat_combined,force_merge = TRUE)
hist_tad(hist_dat_merged)
hist_tat(hist_dat_merged)

## part IV - plot merged data:
hist_tad(hist_dat_merged) # of all tags
unique(hist_dat_merged$TAD$merged$df$DeployID) ## list unique tags in merged list
hist_tad(hist_dat_merged, select_id = "15P1019b", select_from = 'DeployID') # of one tag

## part V - unmerge data:
unmerge_histos(hist_dat_merged)

</code></pre>

<hr>
<h2 id='update_leaflet_elementId'>
update elementID of the leaflet map to avoid rendering issues in RMarkdown
</h2><span id='topic+update_leaflet_elementId'></span>

<h3>Description</h3>

<p>This function updates the elementID of the leaflet map to avoid rendering issues when plotting the same map twice in RMarkdown. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_leaflet_elementId(map)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_leaflet_elementId_+3A_map">map</code></td>
<td>

<p>a leaflet map
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the same leaflet map with an updated elementIDs.
</p>


<h3>Author(s)</h3>

<p>Robert K. Bauer
</p>


<h3>See Also</h3>

<p><a href="#topic+leaflet_geopos">leaflet_geopos</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>## only valid in RMarkdown chunks:
# kmz_file2 &lt;- system.file("example_files/15P0986-15P0986-2-GPE3.kmz",package="RchivalTag")
# k2 &lt;- get_geopos(kmz_file2)
# k0 &lt;- k3 &lt;- rbind(k1,k2)
#
# library(leaflet)
# map &lt;- leaflet_geopos(k0, ID_label="DeployID", collapsedLayers = F)
# map
# map # plot again to show rendering issues (in the layer menu title)
## this is required to avoid rendering issues when plotting the same map twice via RMarkdown 
# map &lt;- update_leaflet_elementId(map) 
#
# plot again with updated elementID:
# map %&gt;% addMiniMap()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
