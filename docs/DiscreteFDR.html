<!DOCTYPE html><html lang="en-US"><head><title>Help for package DiscreteFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DiscreteFDR'><p>FDR-based Multiple Testing Procedures with Adaptation for Discrete Tests</p></a></li>
<li><a href='#ADBH'><p>Wrapper Functions for the Adaptive Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#DBH'><p>Wrapper Functions for the Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#DBR'><p>The Discrete Blanchard-Roquain Procedure</p></a></li>
<li><a href='#DBY'><p>The Discrete Benjamini-Yekutieli Procedure</p></a></li>
<li><a href='#direct.discrete.BH'><p>Direct Application of Multiple Testing Procedures to Dataset</p></a></li>
<li><a href='#discrete.BH'><p>The Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#fast.Discrete'><p>Fast Application of Discrete Multiple Testing Procedures</p></a></li>
<li><a href='#fisher.pvalues.support'><p>Computing Discrete P-Values and Their Supports for Fisher's Exact Test</p></a></li>
<li><a href='#generate.pvalues'><p>Generation of P-Values and Their Supports After Data Transformations</p></a></li>
<li><a href='#hist.DiscreteFDR'><p>Histogram of Raw P-Values</p></a></li>
<li><a href='#kernel'><p>Kernel Functions</p></a></li>
<li><a href='#match.pvals'><p>Matching Raw P-Values with Supports</p></a></li>
<li><a href='#plot.DiscreteFDR'><p>Plot Method for <code>DiscreteFDR</code> objects</p></a></li>
<li><a href='#print.DiscreteFDR'><p>Printing DiscreteFDR results</p></a></li>
<li><a href='#summary.DiscreteFDR'><p>Summarizing Discrete FDR Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>FDR Based Multiple Testing Procedures with Adaptation for
Discrete Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-12-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the multiple testing procedures for discrete
  tests described in the paper Döhler, Durand and Roquain (2018) "New FDR
  bounds for discrete and heterogeneous tests" &lt;<a href="https://doi.org/10.1214%2F18-EJS1441">doi:10.1214/18-EJS1441</a>&gt;. The
  main procedures of the paper (HSU and HSD), their adaptive counterparts
  (AHSU and AHSD), and the HBR variant are available and are coded to take as
  input the results of a test procedure from package 'DiscreteTests', or a set
  of observed p-values and their discrete support under their nulls. A
  shortcut function to obtain such p-values and supports is also provided,
  along with a wrapper allowing to apply discrete procedures directly to data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.12), DiscreteTests (&ge; 0.2.1), lifecycle,
checkmate, DiscreteDatasets</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, R.rsp, kableExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-14 14:29:51 UTC; fjunge</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Döhler <a href="https://orcid.org/0000-0002-0321-6355"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Florian Junge <a href="https://orcid.org/0009-0001-6856-6938"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb, cre],
  Guillermo Durand <a href="https://orcid.org/0000-0003-4056-5631"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ctb],
  Etienne Roquain [ctb],
  Christina Kihn [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;diso.fbmn@h-da.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-14 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DiscreteFDR'>FDR-based Multiple Testing Procedures with Adaptation for Discrete Tests</h2><span id='topic+DiscreteFDR-package'></span><span id='topic+DiscreteFDR'></span>

<h3>Description</h3>

<p>This package implements the [HSU], [HSD],
[AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>] procedures for
discrete tests (see References).
</p>


<h3>Details</h3>

<p>The functions are reorganized from the reference paper in the following way.
<code><a href="#topic+discrete.BH">discrete.BH()</a></code> (for Discrete Benjamini-Hochberg) implements
[HSU], [HSD], [AHSU] and [AHSD], while <code><a href="#topic+DBR">DBR()</a></code> (for Discrete
Blanchard-Roquain) implements [HBR-<code class="reqn">\lambda</code>]. <code><a href="#topic+DBH">DBH()</a></code> and <code><a href="#topic+ADBH">ADBH()</a></code>
are wrapper functions for <code><a href="#topic+discrete.BH">discrete.BH()</a></code> to access [HSU] and [HSD], as
well as [AHSU] and [AHSD] directly.
</p>
<p>This package is part of a package family to which the
<code><a href="DiscreteDatasets.html#topic+DiscreteDatasets-package">DiscreteDatasets</a></code> and
<code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> packages also
belong. The latter allows to compute p-values and their respective supports
for various tests. The objects that contain these results can be used
directly by the <code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code> and <code><a href="#topic+DBR">DBR()</a></code>
functions. Alternatively, these functions also accept a vector of raw
observed p-values and a list of the respective discrete supports of the CDFs
of the p-values.
</p>
<p><strong>Note</strong>: The former function <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>, which allows to
compute such p-values and supports in the framework of a Fisher's exact test,
is now deprecated and should not be used anymore. It has been replaced by
<code><a href="#topic+generate.pvalues">generate.pvalues()</a></code>.
</p>
<p>The same applies for the function <code><a href="#topic+fast.Discrete">fast.Discrete()</a></code>, which is a wrapper for
<code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code> and <code><a href="#topic+discrete.BH">discrete.BH()</a></code> and allows to apply
discrete procedures directly to a data set of contingency tables and perform
data preprocessing before p-values are computed. It is also now deprecated
and has been replaced by <code><a href="#topic+direct.discrete.BH">direct.discrete.BH()</a></code>, but for more flexibility,
users may employ pipes, e.g.<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::*.test.pv(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  discrete.BH(&lt;args&gt;)&#8288;</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Junge <a href="mailto:diso.fbmn@h-da.de">diso.fbmn@h-da.de</a> (<a href="https://orcid.org/0009-0001-6856-6938">ORCID</a>) [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Döhler <a href="mailto:sebastian.doehler@h-da.de">sebastian.doehler@h-da.de</a> (<a href="https://orcid.org/0000-0002-0321-6355">ORCID</a>) [contributor]
</p>
</li>
<li><p> Guillermo Durand (<a href="https://orcid.org/0000-0003-4056-5631">ORCID</a>) [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Etienne Roquain [contributor]
</p>
</li>
<li><p> Christina Kihn [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>
<p>G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871. <a href="https://doi.org/10.48550/arXiv.0707.0536">doi:10.48550/arXiv.0707.0536</a>
</p>
<p>Döhler, S. (2018). A discrete modification of the Benjamini–Yekutieli
procedure. <em>Econometrics and Statistics</em>, <em>5</em>, pp. 137-147.
<a href="https://doi.org/10.1016/j.ecosta.2016.12.002">doi:10.1016/j.ecosta.2016.12.002</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ADBH'>Wrapper Functions for the Adaptive Discrete Benjamini-Hochberg Procedure</h2><span id='topic+ADBH'></span><span id='topic+ADBH.default'></span><span id='topic+ADBH.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>ADBH()</code> is a wrapper function of <code><a href="#topic+discrete.BH">discrete.BH()</a></code> for computing [AHSU] and
[AHSD], which are more powerful than [HSU] and [HSD], respectively. It
simply passes its arguments to <code><a href="#topic+discrete.BH">discrete.BH()</a></code> with fixed <code>adaptive = TRUE</code>
and is computationally more demanding than <code><a href="#topic+DBH">DBH()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADBH(test.results, ...)

## Default S3 method:
ADBH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
ADBH(
  test.results,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ADBH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="ADBH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection set in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>, <code><a href="#topic+DBY">DBY()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# ADBH (step-up) without critical values; using test results object
ADBH.su.fast &lt;- ADBH(test.result)
summary(ADBH.su.fast)

# ADBH (step-down) without critical values; using extracted p-values 
# and supports
ADBH.sd.fast &lt;- ADBH(raw.pvalues, pCDFlist, direction = "sd")
summary(ADBH.sd.fast)

# ADBH (step-up) with critical values; using extracted p-values and supports
ADBH.su.crit &lt;- ADBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(ADBH.su.crit)

# ADBH (step-down) with critical values; using test results object
ADBH.sd.crit &lt;- ADBH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(ADBH.sd.crit)

</code></pre>

<hr>
<h2 id='DBH'>Wrapper Functions for the Discrete Benjamini-Hochberg Procedure</h2><span id='topic+DBH'></span><span id='topic+DBH.default'></span><span id='topic+DBH.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>DBH()</code> is a wrapper function of <code><a href="#topic+discrete.BH">discrete.BH()</a></code> for computing [HSU] and
[HSD]. It simply passes its arguments to <code><a href="#topic+discrete.BH">discrete.BH()</a></code> with fixed
<code>adaptive = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBH(test.results, ...)

## Default S3 method:
DBH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DBH(
  test.results,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DBH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DBH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DBH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="DBH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="DBH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DBH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="DBH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection set in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>, <code><a href="#topic+DBY">DBY()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBH (step-up) without critical values; using test results object
DBH.su.fast &lt;- DBH(test.result)
summary(DBH.su.fast)

# DBH (step-down) without critical values; using extracted p-values 
# and supports
DBH.sd.fast &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd")
summary(DBH.sd.fast)

# DBH (step-up) with critical values; using extracted p-values and supports
DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBH.su.crit)

# DBH (step-down) with critical values; using test results object
DBH.sd.crit &lt;- DBH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(DBH.sd.crit)

</code></pre>

<hr>
<h2 id='DBR'>The Discrete Blanchard-Roquain Procedure</h2><span id='topic+DBR'></span><span id='topic+DBR.default'></span><span id='topic+DBR.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Applies the [HBR-<code class="reqn">\lambda</code>] procedure, with or without computing the
critical constants, to a set of p-values and their respective discrete
supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBR(test.results, ...)

## Default S3 method:
DBR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  lambda = NULL,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DBR(
  test.results,
  alpha = 0.05,
  lambda = NULL,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DBR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DBR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DBR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="DBR_+3A_lambda">lambda</code></td>
<td>
<p>real number strictly between 0 and 1 specifying the DBR tuning parameter; if <code>lambda = NULL</code> (the default), <code>lambda</code> is chosen to be equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DBR_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DBR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="DBR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>[DBR-<code class="reqn">\lambda</code>] is the discrete version of the
[Blanchard-Roquain-<code class="reqn">\lambda</code>] procedure (see References). The authors
of the latter suggest to take <code>lambda = alpha</code> (see their Proposition 17),
which explains the choice of the default value here.
</p>
<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection set in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$DBR.Tuning</code></td>
<td>
<p>value of the tuning parameter <code>lambda</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>:
G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871. <a href="https://doi.org/10.48550/arXiv.0707.0536">doi:10.48550/arXiv.0707.0536</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBY">DBY()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBR without critical values; using test results object
DBR.fast &lt;- DBR(test.result)
summary(DBR.fast)

# DBR with critical values; using extracted p-values and supports
DBR.crit &lt;- DBR(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBR.crit)

</code></pre>

<hr>
<h2 id='DBY'>The Discrete Benjamini-Yekutieli Procedure</h2><span id='topic+DBY'></span><span id='topic+DBY.default'></span><span id='topic+DBY.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Applies the Discrete Benjamini-Yekutieli procedure, with or without computing
the critical constants, to a set of <code class="reqn">p</code>-values and their respective
discrete supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBY(test.results, ...)

## Default S3 method:
DBY(
  test.results,
  pCDFlist,
  alpha = 0.05,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DBY(
  test.results,
  alpha = 0.05,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DBY_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DBY_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DBY_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DBY_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="DBY_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DBY_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="DBY_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection set in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S. (2018). A discrete modification of the Benjamini–Yekutieli
procedure. <em>Econometrics and Statistics</em>, <em>5</em>, pp. 137-147.
<a href="https://doi.org/10.1016/j.ecosta.2016.12.002">doi:10.1016/j.ecosta.2016.12.002</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBY without critical values; using test results object
DBY.fast &lt;- DBY(test.result)
summary(DBY.fast)

# DBY with critical values; using extracted p-values and supports
DBY.crit &lt;- DBY(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBY.crit)

</code></pre>

<hr>
<h2 id='direct.discrete.BH'>Direct Application of Multiple Testing Procedures to Dataset</h2><span id='topic+direct.discrete.BH'></span>

<h3>Description</h3>

<p>Apply the [HSU], [HSD], [AHSU] or [AHSD] procedure, with or without
computing the critical constants,
to a data set of 2x2 contingency tables using Fisher's exact tests which
may have to be transformed before computing p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.discrete.BH(
  dat,
  test.fun,
  test.args = NULL,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  preprocess.fun = NULL,
  preprocess.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="direct.discrete.BH_+3A_dat">dat</code></td>
<td>
<p>input data; must be suitable for the first parameter of the provided <code>preprocess.fun</code> function or, if <code>preprocess.fun</code> is <code>NULL</code>, for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_test.fun">test.fun</code></td>
<td>
<p>function <strong>from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code></strong>, i.e. one whose name ends with <code style="white-space: pre;">&#8288;*_test_pv&#8288;</code> and which performs hypothesis tests and provides an object with <code class="reqn">p</code>-values and their support sets; can be specified by a single character string (which is automatically checked for being a suitable function <strong>from that package</strong> and may be abbreviated) or a single function object.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_test.args">test.args</code></td>
<td>
<p>optional named list with arguments for <code>test.fun</code>; the names of the list fields must match the test function's parameter names. The first parameter of the test function (i.e. the data) MUST NOT be included!</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_preprocess.fun">preprocess.fun</code></td>
<td>
<p>optional function for pre-processing the input <code>data</code>; its result must be suitable for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_preprocess.args">preprocess.args</code></td>
<td>
<p>optional named list with arguments for <code>preprocess.fun</code>; the names of the list fields must match the pre-processing function's parameter names. The first parameter of the test function (i.e. the data) MUST NOT be included!</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DBH.su &lt;- direct.discrete.BH(df, "fisher", direction = "su")
summary(DBH.su)

DBH.sd &lt;- direct.discrete.BH(df, "fisher", direction = "sd")
DBH.sd$Adjusted
summary(DBH.sd)

ADBH.su &lt;- direct.discrete.BH(df, "fisher", direction = "su",
                              adaptive = TRUE)
summary(ADBH.su)

ADBH.sd &lt;- direct.discrete.BH(df, "fisher", direction = "sd",
                              adaptive = TRUE)
ADBH.sd$Adjusted
summary(ADBH.sd)

</code></pre>

<hr>
<h2 id='discrete.BH'>The Discrete Benjamini-Hochberg Procedure</h2><span id='topic+discrete.BH'></span><span id='topic+discrete.BH.default'></span><span id='topic+discrete.BH.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Applies the [HSU], [HSD], [AHSU] and [AHSD] procedures at a given FDR
level, with or without computing the critical constants, to a set of p-values
and their respective discrete supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.BH(test.results, ...)

## Default S3 method:
discrete.BH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
discrete.BH(
  test.results,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="discrete.BH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive variants [AHSU] and [AHSD], which are executed via
<code>adaptive = TRUE</code>, are often slightly more powerful than [HSU] and [HSD],
respectively. But they are also computationally more demanding.
</p>
<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection set in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>, <code><a href="#topic+DBY">DBY()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBH (step-up) without critical values; using test results object
DBH.su.fast &lt;- discrete.BH(test.result)
summary(DBH.su.fast)

# DBH (step-down) without critical values; using extracted p-values
# and supports
DBH.sd.fast &lt;- discrete.BH(raw.pvalues, pCDFlist, direction = "sd")
summary(DBH.sd.fast)

# DBH (step-up) with critical values; using extracted p-values and supports
DBH.su.crit &lt;- discrete.BH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBH.su.crit)

# DBH (step-down) with critical values; using test results object
DBH.sd.crit &lt;- discrete.BH(test.result, direction = "sd",
                           ret.crit.consts = TRUE)
summary(DBH.sd.crit)

# ADBH (step-up) without critical values; using test results object
ADBH.su.fast &lt;- discrete.BH(test.result, adaptive = TRUE)
summary(ADBH.su.fast)

# ADBH (step-down) without critical values; using extracted p-values
# and supports
ADBH.sd.fast &lt;- discrete.BH(raw.pvalues, pCDFlist, direction = "sd",
                             adaptive = TRUE)
summary(ADBH.sd.fast)

# ADBH (step-up) with critical values; using extracted p-values and supports
ADBH.su.crit &lt;- discrete.BH(raw.pvalues, pCDFlist, adaptive = TRUE,
                            ret.crit.consts = TRUE)
summary(ADBH.su.crit)

# ADBH (step-down) with critical values; using test results object
ADBH.sd.crit &lt;- discrete.BH(test.result, direction = "sd", adaptive = TRUE,
                            ret.crit.consts = TRUE)
summary(ADBH.sd.crit)

</code></pre>

<hr>
<h2 id='fast.Discrete'>Fast Application of Discrete Multiple Testing Procedures</h2><span id='topic+fast.Discrete'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Apply the [HSU], [HSD], [AHSU] or [AHSD] procedure,
without computing the critical constants, to a data set of 2x2 contingency
tables which may have to be preprocessed in order to have the correct
structure for computing p-values using Fisher's exact test.
</p>
<p><strong>Note</strong>: This function is deprecated and will be removed in a future
version. Please use <code><a href="#topic+direct.discrete.BH">direct.discrete.BH()</a></code> with
<code>test.fun = DiscreteTests::fisher.test.pv</code> and (optional)
<code>preprocess.fun = DiscreteDatasets::reconstruct_two</code> or
<code>preprocess.fun = DiscreteDatasets::reconstruct_four</code> instead. Alternatively,
use a pipeline, e.g.<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::*.test.pv(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  discrete.BH(&lt;args&gt;)&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.Discrete(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fast.Discrete_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line representing a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument (see Details
section of <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>. The three
possible values are <code>"greater"</code> (default), <code>"two.sided"</code>
or <code>"less"</code> (may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_input">input</code></td>
<td>
<p>the format of the input data frame (see Details section
of <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>. The three possible
values are <code>"noassoc"</code> (default), <code>"marginal"</code> or
<code>"HG2011"</code> (may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw <code class="reqn">p</code>-value to be considered, i.e. only <code class="reqn">p</code>-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw <code class="reqn">p</code>-values are selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table role = "presentation">
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted <code class="reqn">p</code>-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Data</code></td>
<td>
<p>list with input data.</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$Raw.pvalues</code></td>
<td>
<p>observed <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the <code class="reqn">p</code>-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>Select</code></td>
<td>
<p>list with data related to <code class="reqn">p</code>-value selection; only exists if <code>select.threshold &lt; 1</code>.</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p><code class="reqn">p</code>-value selection threshold (<code>select.threshold</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each <code class="reqn">p</code>-value CDF evaluated at the selection threshold.</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected <code class="reqn">p</code>-values that are <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected <code class="reqn">p</code>-values.</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected <code class="reqn">p</code>-values <code class="reqn">\leq</code> selection threshold.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>, <code><a href="#topic+discrete.BH">discrete.BH()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DBH.su &lt;- fast.Discrete(df, input = "noassoc", direction = "su")
summary(DBH.su)

DBH.sd &lt;- fast.Discrete(df, input = "noassoc", direction = "sd")
DBH.sd$Adjusted
summary(DBH.sd)

ADBH.su &lt;- fast.Discrete(df, input = "noassoc", direction = "su",
                         adaptive = TRUE)
summary(ADBH.su)

ADBH.sd &lt;- fast.Discrete(df, input = "noassoc", direction = "sd",
                         adaptive = TRUE)
ADBH.sd$Adjusted
summary(ADBH.sd)

</code></pre>

<hr>
<h2 id='fisher.pvalues.support'>Computing Discrete P-Values and Their Supports for Fisher's Exact Test</h2><span id='topic+fisher.pvalues.support'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Computes discrete raw p-values and their support for Fisher's exact test
applied to 2x2 contingency tables summarizing counts coming from two
categorical measurements.
</p>
<p><strong>Note</strong>: This function is deprecated and will be removed in a future
version. Please use <code><a href="#topic+generate.pvalues">generate.pvalues()</a></code> with
<code>test.fun = DiscreteTests::fisher.test.pv</code> and (optional)
<code>preprocess.fun = DiscreteDatasets::reconstruct_two</code> or
<code>preprocess.fun = DiscreteDatasets::reconstruct_four</code> instead. Alternatively,
use a pipeline like<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::fisher.test.pv(&lt;args&gt;)&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.pvalues.support(counts, alternative = "greater", input = "noassoc")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fisher.pvalues.support_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line represents a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument, see
Details.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>. The three
possible values are <code>"greater"</code> (default),
<code>"two.sided"</code> or <code>"less"</code> and you can specify
just the initial letter.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_input">input</code></td>
<td>
<p>the format of the input data frame, see Details. The
three possible values are <code>"noassoc"</code> (default),
<code>"marginal"</code> or <code>"HG2011"</code> and you can specify
just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that each contingency tables compares two variables and resumes the
counts of association or not with a condition. This can be resumed in the
following table:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;">   Association   </td><td style="text-align: center;"> No association  </td><td style="text-align: center;">   Total   </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 1  </td><td style="text-align: center;">    <code class="reqn">X_1</code>    </td><td style="text-align: center;">    <code class="reqn">Y_1</code>    </td><td style="text-align: center;"> <code class="reqn">N_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 2  </td><td style="text-align: center;">    <code class="reqn">X_2</code>    </td><td style="text-align: center;">    <code class="reqn">Y_2</code>    </td><td style="text-align: center;"> <code class="reqn">N_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total       </td><td style="text-align: center;"> <code class="reqn">X_1 + X_2</code> </td><td style="text-align: center;"> <code class="reqn">Y_1 + Y_2</code> </td><td style="text-align: center;"> <code class="reqn">N_1 + N_2</code>
</td>
</tr>

</table>

<p>If <code>input="noassoc"</code>, <code>counts</code> has four columns which respectively contain,
<code class="reqn">X_1</code>, <code class="reqn">Y_1</code>, <code class="reqn">X_2</code> and <code class="reqn">Y_2</code>. If <code>input="marginal"</code>,
<code>counts</code> has four columns which respectively contain <code class="reqn">X_1</code>, <code class="reqn">N_1</code>,
<code class="reqn">X_2</code> and <code class="reqn">N_2</code>.
</p>
<p>If <code>input="HG2011"</code>, we are in the situation of the <code>amnesia</code> data set as
in Heller &amp; Gur (2011, see References). Each contingency table is obtained
from one variable which is compared to all other variables of the study. That
is, counts for &quot;second variable&quot; are replaced by the sum of the counts of the
other variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Association </td><td style="text-align: center;"> No association </td><td style="text-align: center;"> Total </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable  <code class="reqn">j</code>      </td><td style="text-align: center;"> <code class="reqn">X_j</code>   </td><td style="text-align: center;"> <code class="reqn">Y_j</code> </td><td style="text-align: center;">  <code class="reqn">N_j</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variables <code class="reqn">\neq j</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} X_i</code>
</td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} Y_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} N_i</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total </td><td style="text-align: center;"> <code class="reqn">\sum X_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum Y_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum N_i</code>
</td>
</tr>

</table>

<p>Hence <code>counts</code> needs to have only two columns which respectively contain
<code class="reqn">X_j</code> and <code class="reqn">Y_j</code>.
</p>
<p>The code for the computation of the p-values of Fisher's exact test is
inspired by the example in the help page of <code>p.discrete.adjust</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN.
</p>
<p>See the Wikipedia article about Fisher's exact test, paragraph Example, for
a good depiction of what the code does for each possible value of
<code>alternative</code>.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>
<table role = "presentation">
<tr><td><code>raw</code></td>
<td>
<p>raw discrete p-values.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values.
Each support is represented by a vector in increasing order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures for
discrete tests. arXiv preprint.
<a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a>.
</p>
<p>&quot;Fisher's exact test&quot;, Wikipedia, The Free Encyclopedia, accessed 2024-12-14,
<a href="https://en.wikipedia.org/wiki/Fisher%27s_exact_test">link</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support
</code></pre>

<hr>
<h2 id='generate.pvalues'>Generation of P-Values and Their Supports After Data Transformations</h2><span id='topic+generate.pvalues'></span>

<h3>Description</h3>

<p>Simple wrapper for generating p-values of discrete tests and their supports
after preprocessing the input data. The user only has to provide 1.) a
function that generates p-values and supports and 2.) an optional function
that preprocesses (i.e. transforms) the input data (if necessary) before it
can be used for p-value calculations. The respective arguments are provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.pvalues(
  dat,
  test.fun,
  test.args = NULL,
  preprocess.fun = NULL,
  preprocess.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generate.pvalues_+3A_dat">dat</code></td>
<td>
<p>input data; must be suitable for the first parameter of the provided <code>preprocess.fun</code> function or, if <code>preprocess.fun</code> is <code>NULL</code>, for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_test.fun">test.fun</code></td>
<td>
<p>function <strong>from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code></strong>, i.e. one whose name ends with <code style="white-space: pre;">&#8288;*_test_pv&#8288;</code> and which performs hypothesis tests and provides an object with <code class="reqn">p</code>-values and their support sets; can be specified by a single character string (which is automatically checked for being a suitable function <strong>from that package</strong> and may be abbreviated) or a single function object.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_test.args">test.args</code></td>
<td>
<p>optional named list with arguments for <code>test.fun</code>; the names of the list fields must match the test function's parameter names. The first parameter of the test function (i.e. the data) MUST NOT be included!</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_preprocess.fun">preprocess.fun</code></td>
<td>
<p>optional function for pre-processing the input <code>data</code>; its result must be suitable for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_preprocess.args">preprocess.args</code></td>
<td>
<p>optional named list with arguments for <code>preprocess.fun</code>; the names of the list fields must match the pre-processing function's parameter names. The first parameter of the test function (i.e. the data) MUST NOT be included!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a> R6 class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# Compute p-values and their supports of Fisher's exact test 
# with preprocessing
df2 &lt;- data.frame(X1, N1, X2, N2)
generate.pvalues(
  dat = df2,
  test.fun = "fisher_test_pv",
  preprocess.fun = function(tab) {
    for(col in c(2, 4)) tab[, col] &lt;- tab[, col] - tab[, col - 1]
    return(tab)
  }
)

# Compute p-values and their supports of a binomial test with preprocessing
generate.pvalues(
  dat = rbind(c(5, 2, 7), c(3, 4, 0)), 
  test.fun = "binom_test_pv",
  test.args = list(n = c(9, 8, 11), p = 0.6, alternative = "two.sided"),
  preprocess.fun = colSums
)

</code></pre>

<hr>
<h2 id='hist.DiscreteFDR'>Histogram of Raw P-Values</h2><span id='topic+hist.DiscreteFDR'></span>

<h3>Description</h3>

<p>Computes a histogram of the raw p-values of a <code>DiscreteFDR</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
hist(x, breaks = "FD", mode = c("raw", "selected"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hist.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_breaks">breaks</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+hist">graphics::hist()</a></code>; here, the Friedman-Diaconis
algorithm (<code>"FD"</code>) is used as default.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_mode">mode</code></td>
<td>
<p>single character string specifying for which $p$-values the
histogram is to be generated; must either be <code>"raw"</code> or
<code>"selected"</code>.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+hist">graphics::hist()</a></code> or
<code><a href="graphics.html#topic+plothistogram">graphics::plot.histogram()</a></code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> does not contain results of a selection approach, a warning is issued
and a histogram of the raw p-values is drawn.
</p>


<h3>Value</h3>

<p>An object of class <code>histogram</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBH (SU)
DBH &lt;- DBH(raw.pvalues, pCDFlist)
hist(DBH)

</code></pre>

<hr>
<h2 id='kernel'>Kernel Functions</h2><span id='topic+kernel'></span><span id='topic+kernel_DBH_fast'></span><span id='topic+kernel_DBH_crit'></span><span id='topic+kernel_ADBH_fast'></span><span id='topic+kernel_ADBH_crit'></span><span id='topic+kernel_DBR_fast'></span><span id='topic+kernel_DBR_crit'></span><span id='topic+kernel_DBY_fast'></span><span id='topic+kernel_DBY_crit'></span>

<h3>Description</h3>

<p>Kernel functions that transform observed p-values or their support according
to [HSU], [HSD], [AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>]. The
output is used by <a href="#topic+discrete.BH">discrete.BH</a> or <a href="#topic+DBR">DBR</a>, respectively.
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> and <code>kernel_DBR_crit</code> additionally
compute and return the critical constants.
The end user should not use these functions directly.
</p>
<p><strong>Note</strong>: As of version 2.0, these functions are purely internal functions!
As a consequence, they have to be called directly via <code>:::</code>, e.g.
<code>DiscreteFDR:::kernel_DBH_fast()</code>. But users should <strong>not</strong> rely on them, as
parameters (including their names, order, etc.) may be changed without
notice!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_DBH_fast(
  pCDFlist,
  pvalues,
  stepUp = FALSE,
  tau_max = NULL,
  alpha = 0.05,
  support = numeric(),
  pCDFcounts = NULL
)

kernel_DBH_crit(
  pCDFlist,
  support,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_ADBH_fast(
  pCDFlist,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  support = numeric(),
  pCDFcounts = NULL
)

kernel_ADBH_crit(
  pCDFlist,
  support,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_DBR_fast(pCDFlist, sorted_pv, lambda = 0.05, pCDFcounts = NULL)

kernel_DBR_crit(
  pCDFlist,
  support,
  sorted_pv,
  lambda = 0.05,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_DBY_fast(pCDFlist, pvalues, pCDFcounts = NULL)

kernel_DBY_crit(pCDFlist, support, sorted_pv, alpha = 0.05, pCDFcounts = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernel_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pvalues">pvalues</code></td>
<td>
<p>numeric vector, sorted in increasing order, that either
must contain the entirety of all observable values of
the p-value supports (when computing critical constants)
or only the sorted raw p-values.</p>
</td></tr>
<tr><td><code id="kernel_+3A_stepup">stepUp</code></td>
<td>
<p>boolean specifying whether to conduct the step-up
(<code>TRUE</code>) or step-down (<code>FALSE</code>; the default)
procedure.</p>
</td></tr>
<tr><td><code id="kernel_+3A_tau_max">tau_max</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating
the largest critical value for step-up procedures; if
<code>NULL</code> (the default), it is computed automatically,
otherwise it needs to be computed manually by the user;
ignored if <code>stepUp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating
the target FDR level; for <code style="white-space: pre;">&#8288;*_fast&#8288;</code> kernels, it is only
needed, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_support">support</code></td>
<td>
<p>numeric vector, sorted in increasing order, that
contains the entirety of all observable values of the
p-value supports; for <code style="white-space: pre;">&#8288;*_fast&#8288;</code> kernels, it is ignored if
<code>stepUp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pcdfcounts">pCDFcounts</code></td>
<td>
<p>integer vector of counts that indicates to how many
p-values each <strong>unique</strong> p-value distributions belongs.</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_pv">sorted_pv</code></td>
<td>
<p>numeric vector containing the raw p-values, sorted in
increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_lambda">lambda</code></td>
<td>
<p>real number strictly between 0 and 1 specifying the DBR
tuning parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing critical constants under step-down, that is, when using
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> or <code>kernel_DBR_crit</code> with
<code>stepUp = FALSE</code> (i.e. the step-down case), we still need to get transformed
p-values to compute the adjusted p-values.
</p>


<h3>Value</h3>

<p>For <code>kernel_DBH_fast()</code>, <code>kernel_ADBH_fast()</code> and <code>kernel_DBR_fast()</code>, a
vector of transformed p-values is returned. <code>kernel_DBH_crit</code>,
<code>kernel_ADBH_crit</code> and <code>kernel_DBR_crit</code> return a list with critical
constants (<code style="white-space: pre;">&#8288;$crit.consts&#8288;</code>) and transformed p-values (<code style="white-space: pre;">&#8288;$pval.transf&#8288;</code>), but if
<code>stepUp = FALSE</code>, there are critical values only.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+direct.discrete.BH">direct.discrete.BH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>

<hr>
<h2 id='match.pvals'>Matching Raw P-Values with Supports</h2><span id='topic+match.pvals'></span>

<h3>Description</h3>

<p>Constructs the observed p-values from the raw observed p-values, by rounding
them to their nearest neighbor matching with the supports of their
respective CDFs (as in function <code>p.discrete.adjust()</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN).
</p>
<p><strong>Note</strong>: This is an internal function and has to be called directly via
<code>:::</code>, i.e. <code>DiscreteFDR:::match.pvals()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.pvals(test.results, pCDFlist, pCDFlist.indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match.pvals_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with <code class="reqn">p</code>-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the <code class="reqn">p</code>-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw <code class="reqn">p</code>-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Well computed raw p-values should already belong to their respective CDF
support. So this function is called at the beginning of <code><a href="#topic+discrete.BH">discrete.BH()</a></code>,
<code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code> and <code><a href="#topic+DBR">DBR()</a></code>, just in case raw p-values are biased.
</p>
<p>For each raw p-value that needs to be rounded, a warning is issued.
</p>


<h3>Value</h3>

<p>A vector where each raw p-value has been replaced by its nearest neighbor, if
necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>

<hr>
<h2 id='plot.DiscreteFDR'>Plot Method for <code>DiscreteFDR</code> objects</h2><span id='topic+plot.DiscreteFDR'></span>

<h3>Description</h3>

<p>Plots raw p-values of a <code>DiscreteFDR</code> object and highlights rejected and
accepted p-values. If present, the critical values are plotted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
plot(
  x,
  col = c(2, 4, 1),
  pch = c(20, 20, 17),
  lwd = rep(par()$lwd, 3),
  cex = rep(par()$cex, 3),
  type.crit = "b",
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_col">col</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
colors of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_pch">pch</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
point characters of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present and <code>type.crit</code>
is a plot type like <code>'p'</code>, <code>'b'</code> etc.).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_lwd">lwd</code></td>
<td>
<p>numeric vector of length 3 indicating the thickness of the
points and lines; defaults to current <code>par()$lwd</code> setting.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_cex">cex</code></td>
<td>
<p>numeric vector of length 3 indicating the size of point
characters or lines of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>

<p>defaults to current <code>par()$cex</code> setting.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_type.crit">type.crit</code></td>
<td>
<p>1-character string giving the type of plot desired for the
critical values (e.g.: <code>'p'</code>, <code>'l'</code> etc; see <code><a href="base.html#topic+plot">plot()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_legend">legend</code></td>
<td>
<p>if <code>NULL</code>, no legend is plotted; otherwise expecting a
character string like <code>"topleft"</code> etc. or a numeric vector
of two elements indicating (x, y) coordinates.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+plot.default">plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.su.fast &lt;- DBH(raw.pvalues, pCDFlist)
DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
DBH.sd.fast &lt;- DBH(test.result, direction = "sd")
DBH.sd.crit &lt;- DBH(test.result, direction = "sd", ret.crit.consts = TRUE)

plot(DBH.sd.fast)
plot(DBH.sd.crit, xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.fast, col = c(2, 4), pch = c(2, 3), lwd = c(2, 2), 
     legend = "topleft", xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.crit, col = c(2, 4, 1), pch = c(1, 1, 4), lwd = c(1, 1, 2), 
     type.crit = 'o', legend = c(1, 0.4), lty = 1, xlim = c(1, 5), 
     ylim = c(0, 0.4))

</code></pre>

<hr>
<h2 id='print.DiscreteFDR'>Printing DiscreteFDR results</h2><span id='topic+print.DiscreteFDR'></span>

<h3>Description</h3>

<p>Prints the results of discrete FDR analysis, stored in a <code>DiscreteFDR</code> class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="print.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They
are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code> is invisibly returned via <code>invisible(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "su",
                   ret.crit.consts = TRUE)
print(DBH.su.crit)

</code></pre>

<hr>
<h2 id='summary.DiscreteFDR'>Summarizing Discrete FDR Results</h2><span id='topic+summary.DiscreteFDR'></span><span id='topic+print.summary.DiscreteFDR'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>DiscreteFDR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
summary(object, ...)

## S3 method for class 'summary.DiscreteFDR'
print(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.DiscreteFDR_+3A_object">object</code></td>
<td>
<p>an object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximal number of
<em>rows</em> of the p-value table to be printed. By default,
when <code>NULL</code>, <code>getOption("max.print")</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.DiscreteFDR</code> objects contain all data of an <code>DiscreteFDR</code> object,
but also include an additional table which includes the raw p-values,
their indices, the respective critical values (if present), the adjusted
p-values (if present) and a logical column to indicate rejection. The table
is sorted in ascending order by the raw p-values.
</p>
<p><code>print.summary.DiscreteFDR</code> simply prints the same output as
<code>print.DiscreteFDR</code>, but also prints the p-value table.
</p>


<h3>Value</h3>

<p><code>summary.DiscreteFDR</code> computes and returns a list that includes all the
data of an input <code>DiscreteFDR</code> object, plus
</p>
<table role = "presentation">
<tr><td><code>Table</code></td>
<td>
<p><code>data.frame</code>, sorted by the raw p-values, that contains the
indices, the raw p-values themselves, their respective critical
values (if present), their adjusted p-values (if present) and a
logical column to indicate rejection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.sd.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd",
                   ret.crit.consts = TRUE)
summary(DBH.sd.crit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
