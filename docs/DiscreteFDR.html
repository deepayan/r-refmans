<!DOCTYPE html><html><head><title>Help for package DiscreteFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DiscreteFDR'><p>FDR-based Multiple Testing Procedures with Adaptation for Discrete Tests</p></a></li>
<li><a href='#ADBH'><p>Wrapper Functions for the Adaptive Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#amnesia'><p>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous</p>
reporting system</a></li>
<li><a href='#DBH'><p>Wrapper Functions for the Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#DBR'><p>The Discrete Blanchard-Roquain Procedure</p></a></li>
<li><a href='#direct.discrete.BH'><p>Direct Application of Multiple Testing Procedures to Dataset</p></a></li>
<li><a href='#discrete.BH'><p>The Discrete Benjamini-Hochberg Procedure</p></a></li>
<li><a href='#fast.Discrete'><p>Fast Application of Discrete Multiple Testing Procedures</p></a></li>
<li><a href='#fisher.pvalues.support'><p>Computing Discrete P-Values and Their Supports for Fisher's Exact Test</p></a></li>
<li><a href='#generate.pvalues'><p>Generation of P-Values and Their Supports After Data Transformations</p></a></li>
<li><a href='#hist.DiscreteFDR'><p>Histogram of Raw P-Values</p></a></li>
<li><a href='#kernel'><p>Kernel Functions</p></a></li>
<li><a href='#match.pvals'><p>Matching Raw P-Values with Supports</p></a></li>
<li><a href='#plot.DiscreteFDR'><p>Plot Method for <code>DiscreteFDR</code> objects</p></a></li>
<li><a href='#print.DiscreteFDR'><p>Printing DiscreteFDR results</p></a></li>
<li><a href='#summary.DiscreteFDR'><p>Summarizing Discrete FDR Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>FDR Based Multiple Testing Procedures with Adaptation for
Discrete Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the multiple testing procedures for discrete
    tests described in the paper Döhler, Durand and Roquain (2018) "New FDR
    bounds for discrete and heterogeneous tests" &lt;<a href="https://doi.org/10.1214%2F18-EJS1441">doi:10.1214/18-EJS1441</a>&gt;. The
    main procedures of the paper (HSU and HSD), their adaptive counterparts
    (AHSU and AHSD), and the HBR variant are available and are coded to take as
    input the results of a test procedure from package 'DiscreteTests', or a set
    of observed p-values and their discrete support under their nulls. A
    shortcut function to obtain such p-values and supports is also provided,
    along with a wrapper allowing to apply discrete procedures directly to data.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, R.rsp, kableExtra</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.12), DiscreteTests, lifecycle, checkmate,
DiscreteDatasets</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-08 09:14:03 UTC; fjunge</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Döhler [aut, ctb],
  Florian Junge [aut, ctb, cre],
  Guillermo Durand [aut, ctb],
  Etienne Roquain [ctb],
  Christina Kihn [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;diso.fbmn@h-da.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-08 09:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DiscreteFDR'>FDR-based Multiple Testing Procedures with Adaptation for Discrete Tests</h2><span id='topic+DiscreteFDR-package'></span><span id='topic+DiscreteFDR'></span>

<h3>Description</h3>

<p>This package implements the [HSU], [HSD],
[AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>] procedures for
discrete tests (see References).
</p>


<h3>Details</h3>

<p>The functions are reorganized from the reference paper in the following way.
<code><a href="#topic+discrete.BH">discrete.BH()</a></code> (for Discrete Benjamini-Hochberg) implements
[HSU], [HSD], [AHSU] and [AHSD], while <code><a href="#topic+DBR">DBR()</a></code> (for Discrete
Blanchard-Roquain) implements [HBR-<code class="reqn">\lambda</code>]. <code><a href="#topic+DBH">DBH()</a></code> and <code><a href="#topic+ADBH">ADBH()</a></code>
are wrapper functions for <code><a href="#topic+discrete.BH">discrete.BH()</a></code> to access [HSU] and [HSD], as
well as [AHSU] and [AHSD] directly.
</p>
<p>This package is part of a package family to which the
<code><a href="DiscreteDatasets.html#topic+DiscreteDatasets-package">DiscreteDatasets</a></code> and
<code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code> packages also
belong. The latter allows to compute p-values and their respective supports
for various tests. The objects that contain these results can be used
directly by the <code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code> and <code><a href="#topic+DBR">DBR()</a></code>
functions. Alternatively, these functions also accept a vector of raw
observed p-values and a list of the respective discrete supports of the CDFs
of the p-values.
</p>
<p><strong>Note</strong>: The former function <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>, which allows to
compute such p-values and supports in the framework of a Fisher's exact test,
is now deprecated and should not be used anymore. It has been replaced by
<code><a href="#topic+generate.pvalues">generate.pvalues()</a></code>.
</p>
<p>The same applies for the function <code><a href="#topic+fast.Discrete">fast.Discrete()</a></code>, which is a wrapper for
<code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code> and <code><a href="#topic+discrete.BH">discrete.BH()</a></code> and allows to apply
discrete procedures directly to a data set of contingency tables and perform
data pre-processing before p-values are computed. It is also now deprecated
and has been replaced by <code><a href="#topic+direct.discrete.BH">direct.discrete.BH()</a></code>, but for more flexibility,
users may employ pipes, e.g.<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::*.test.pv(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  discrete.BH(&lt;args&gt;)&#8288;</code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Florian Junge <a href="mailto:diso.fbmn@h-da.de">diso.fbmn@h-da.de</a> [contributor]
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Döhler [contributor]
</p>
</li>
<li><p> Guillermo Durand [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Etienne Roquain [contributor]
</p>
</li>
<li><p> Christina Kihn [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>
<p>G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ADBH'>Wrapper Functions for the Adaptive Discrete Benjamini-Hochberg Procedure</h2><span id='topic+ADBH'></span><span id='topic+ADBH.default'></span><span id='topic+ADBH.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>ADBH()</code> is a wrapper function of <code><a href="#topic+discrete.BH">discrete.BH()</a></code> for computing [AHSU] and
[AHSD], which are more powerful than [HSU] and [HSD], respectively. It
simply passes its arguments to <code><a href="#topic+discrete.BH">discrete.BH()</a></code> with fixed <code>adaptive = TRUE</code>
and is computationally more demanding than <code><a href="#topic+DBH">DBH()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADBH(test.results, ...)

## Default S3 method:
ADBH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
ADBH(
  test.results,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADBH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="ADBH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="ADBH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p>p-value selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each p-value CDF evaluated at the selection threshold (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected p-values that are <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of p-values <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected p-values (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected p-values <code class="reqn">\leq</code> <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>observed p-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the p-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# ADBH (SU) without critical values; using extracted p-values and supports
ADBH.su.fast &lt;- ADBH(raw.pvalues, pCDFlist)
summary(ADBH.su.fast)

# ADBH (SD) without critical values; using extracted p-values and supports
ADBH.sd.fast &lt;- ADBH(raw.pvalues, pCDFlist, direction = "sd")
summary(ADBH.sd.fast)

# ADBH (SU) with critical values; using test results
ADBH.su.crit &lt;- ADBH(test.result, ret.crit.consts = TRUE)
summary(ADBH.su.crit)

# ADBH (SD) with critical values; using test results
ADBH.sd.crit &lt;- ADBH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(ADBH.sd.crit)

</code></pre>

<hr>
<h2 id='amnesia'>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous
reporting system</h2><span id='topic+amnesia'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>For each of 2,446 drugs in the MHRA database (column 1),
the number of cases with amnesia as an adverse event (column 2),
and the number of cases with other adverse event for this drug (column 3).
In total, 682,648 adverse drug reactions were reported, among them 2,044
cases of amnesia.
</p>
<p><strong>Note</strong>: In future versions, this dataset will be removed. Please use the
<code><a href="DiscreteDatasets.html#topic+amnesia">amnesia</a></code> dataset from package
<code><a href="DiscreteDatasets.html#topic+DiscreteDatasets-package">DiscreteDatasets</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amnesia)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2,446 rows representing drugs with the following
three columns:
</p>

<dl>
<dt>DrugName</dt><dd><p>The name of the drug.</p>
</dd>
<dt>AmnesiaCases</dt><dd><p>Number of the amnesia cases reported for the drug.</p>
</dd>
<dt>OtherAdverseCases</dt><dd><p>Number of other adverse drug reactions reported
for the drug.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was collected from the Drug Analysis Prints published
by the Medicines and Healthcare products Regulatory Agency (MHRA),
by Heller &amp; Gur. See references for more details.
</p>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures
for discrete tests.
<a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a> (preprint).
</p>


<h3>Source</h3>

<p><a href="https://yellowcard.mhra.gov.uk/idaps">Drug Analysis Prints on MHRA site</a>
</p>

<hr>
<h2 id='DBH'>Wrapper Functions for the Discrete Benjamini-Hochberg Procedure</h2><span id='topic+DBH'></span><span id='topic+DBH.default'></span><span id='topic+DBH.DiscreteTestResults'></span>

<h3>Description</h3>

<p><code>DBH()</code> is a wrapper function of <code><a href="#topic+discrete.BH">discrete.BH()</a></code> for computing [HSU] and
[HSD]. It simply passes its arguments to <code><a href="#topic+discrete.BH">discrete.BH()</a></code> with fixed
<code>adaptive = FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBH(test.results, ...)

## Default S3 method:
DBH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DBH(
  test.results,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DBH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DBH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DBH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="DBH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="DBH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DBH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DBH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p>p-value selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each p-value CDF evaluated at the selection threshold (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected p-values that are <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of p-values <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected p-values (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected p-values <code class="reqn">\leq</code> <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>observed p-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the p-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBH (SU) without critical values; using extracted p-values and supports
DBH.su.fast &lt;- DBH(raw.pvalues, pCDFlist)
summary(DBH.su.fast)

# DBH (SD) without critical values; using extracted p-values and supports
DBH.sd.fast &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd")
summary(DBH.sd.fast)

# DBH (SU) with critical values; using test results
DBH.su.crit &lt;- DBH(test.result, ret.crit.consts = TRUE)
summary(DBH.su.crit)

# DBH (SD) with critical values; using test results
DBH.sd.crit &lt;- DBH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(DBH.sd.crit)

</code></pre>

<hr>
<h2 id='DBR'>The Discrete Blanchard-Roquain Procedure</h2><span id='topic+DBR'></span><span id='topic+DBR.default'></span><span id='topic+DBR.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Applies the [HBR-<code class="reqn">\lambda</code>] procedure, with or without computing the
critical constants, to a set of p-values and their respective discrete
supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBR(test.results, ...)

## Default S3 method:
DBR(
  test.results,
  pCDFlist,
  alpha = 0.05,
  lambda = NULL,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
DBR(
  test.results,
  alpha = 0.05,
  lambda = NULL,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBR_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="DBR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="DBR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="DBR_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="DBR_+3A_lambda">lambda</code></td>
<td>
<p>real number strictly between 0 and 1 specifying the DBR tuning parameter; if <code>lambda = NULL</code> (the default), <code>lambda</code> is chosen to be equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DBR_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="DBR_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="DBR_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>[DBR-<code class="reqn">\lambda</code>] is the discrete version of the
[Blanchard-Roquain-<code class="reqn">\lambda</code>] procedure (see References). The authors
of the latter suggest to take <code>lambda = alpha</code> (see their Proposition 17),
which explains the choice of the default value here.
</p>
<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted p-values.</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p>p-value selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each p-value CDF evaluated at the selection threshold (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected p-values that are <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of p-values <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected p-values (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected p-values <code class="reqn">\leq</code> <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>observed p-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the p-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
<tr><td><code>DBR.Tuning</code></td>
<td>
<p>value of the tuning parameter <code>lambda</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBR without critical values; using extracted p-values and supports
DBR.fast &lt;- DBR(raw.pvalues, pCDFlist)
summary(DBR.fast)

# DBR with critical values; using test results
DBR.crit &lt;- DBR(test.result, ret.crit.consts = TRUE)
summary(DBR.crit)

</code></pre>

<hr>
<h2 id='direct.discrete.BH'>Direct Application of Multiple Testing Procedures to Dataset</h2><span id='topic+direct.discrete.BH'></span>

<h3>Description</h3>

<p>Apply the [HSU], [HSD], [AHSU] or [AHSD] procedure, with or without
computing the critical constants,
to a data set of 2x2 contingency tables using Fisher's exact tests which
may have to be transformed before computing p-values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direct.discrete.BH(
  dat,
  test.fun,
  test.args = NULL,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  preprocess.fun = NULL,
  preprocess.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direct.discrete.BH_+3A_dat">dat</code></td>
<td>
<p>input data; must be suitable for the first parameter of the provided <code>preprocess.fun</code> function or, if <code>preprocess.fun</code> is <code>NULL</code>, for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_test.fun">test.fun</code></td>
<td>
<p>function <strong>from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code></strong>, i.e. one whose name ends with <code style="white-space: pre;">&#8288;*.test.pv&#8288;</code> and which performs hypothesis tests and provides an object with p-values and their support sets; can be specified by a single character string (which is automatically checked for being a suitable function <strong>from that package</strong> and may be abbreviated) or a single function object.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_test.args">test.args</code></td>
<td>
<p>optional named list with arguments for <code>test.fun</code>; the names of the list fields must match the test function's parameter names. The first parameter of the test function MUST NOT be included!</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_preprocess.fun">preprocess.fun</code></td>
<td>
<p>optional function for pre-processing the input <code>data</code>; its result must be suitable for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="direct.discrete.BH_+3A_preprocess.args">preprocess.args</code></td>
<td>
<p>optional named list with arguments for <code>preprocess.fun</code>; the names of the list fields must match the pre-processing function's parameter names. The first parameter of the test function MUST NOT be included!</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DBH.su &lt;- direct.discrete.BH(df, "fisher", direction = "su")
summary(DBH.su)

DBH.sd &lt;- direct.discrete.BH(df, "fisher", direction = "sd")
DBH.sd$Adjusted
summary(DBH.sd)

ADBH.su &lt;- direct.discrete.BH(df, "fisher", direction = "su", adaptive = TRUE)
summary(ADBH.su)

ADBH.sd &lt;- direct.discrete.BH(df, "fisher", direction = "sd", adaptive = TRUE)
ADBH.sd$Adjusted
summary(ADBH.sd)

</code></pre>

<hr>
<h2 id='discrete.BH'>The Discrete Benjamini-Hochberg Procedure</h2><span id='topic+discrete.BH'></span><span id='topic+discrete.BH.default'></span><span id='topic+discrete.BH.DiscreteTestResults'></span>

<h3>Description</h3>

<p>Applies the [HSU], [HSD], [AHSU] and [AHSD] procedures at a given FDR
level, with or without computing the critical constants, to a set of p-values
and their respective discrete supports.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.BH(test.results, ...)

## Default S3 method:
discrete.BH(
  test.results,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  pCDFlist.indices = NULL,
  ...
)

## S3 method for class 'DiscreteTestResults'
discrete.BH(
  test.results,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE,
  select.threshold = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.BH_+3A_test.results">test.results</code></td>
<td>
<p>either a numeric vector with p-values or an R6 object of class <code><a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a></code> from package <a href="DiscreteTests.html#topic+DiscreteTests">DiscreteTests</a> for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods. They are ignored here.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>single boolean specifying whether critical constants are to be computed.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The adaptive variants [AHSU] and [AHSD], which are executed via
<code>adaptive = TRUE</code>, are often slightly more powerful than [HSU] and [HSD],
respectively. But they are also computationally more demanding.
</p>
<p>Computing critical constants (<code>ret.crit.consts = TRUE</code>) requires considerably
more execution time, especially if the number of unique supports is large.
We recommend that users should only have them calculated when they need them,
e.g. for illustrating the rejection area in a plot or other theoretical
reasons.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p>p-value selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each p-value CDF evaluated at the selection threshold (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected p-values that are <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of p-values <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected p-values (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected p-values <code class="reqn">\leq</code> <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>observed p-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the p-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# DBH (SU) without critical values; using extracted p-values and supports
DBH.su.fast &lt;- discrete.BH(raw.pvalues, pCDFlist)
summary(DBH.su.fast)

# DBH (SD) without critical values; using extracted p-values and supports
DBH.sd.fast &lt;- discrete.BH(raw.pvalues, pCDFlist, direction = "sd")
summary(DBH.sd.fast)

# DBH (SU) with critical values; using test results
DBH.su.crit &lt;- discrete.BH(test.result, ret.crit.consts = TRUE)
summary(DBH.su.crit)

# DBH (SD) with critical values; using test results
DBH.sd.crit &lt;- discrete.BH(test.result, direction = "sd", ret.crit.consts = TRUE)
summary(DBH.sd.crit)

# ADBH (SU) without critical values; using extracted p-values and supports
ADBH.su.fast &lt;- discrete.BH(raw.pvalues, pCDFlist, adaptive = TRUE)
summary(ADBH.su.fast)

# ADBH (SD) without critical values; using extracted p-values and supports
ADBH.sd.fast &lt;- discrete.BH(raw.pvalues, pCDFlist, direction = "sd", adaptive = TRUE)
summary(ADBH.sd.fast)

# ADBH (SU) with critical values; using test results
ADBH.su.crit &lt;- discrete.BH(test.result, adaptive = TRUE, ret.crit.consts = TRUE)
summary(ADBH.su.crit)

# ADBH (SD) with critical values; using test results
ADBH.sd.crit &lt;- discrete.BH(test.result, direction = "sd", adaptive = TRUE, ret.crit.consts = TRUE)
summary(ADBH.sd.crit)

</code></pre>

<hr>
<h2 id='fast.Discrete'>Fast Application of Discrete Multiple Testing Procedures</h2><span id='topic+fast.Discrete'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Apply the [HSU], [HSD], [AHSU] or [AHSD] procedure,
without computing the critical constants, to a data set of 2x2 contingency
tables which may have to be pre-processed in order to have the correct
structure for computing p-values using Fisher's exact test.
</p>
<p><strong>Note</strong>: This function is deprecated and will be removed in a future
version. Please use <code><a href="#topic+direct.discrete.BH">direct.discrete.BH()</a></code> with
<code>test.fun = DiscreteTests::fisher.test.pv</code> and (optional)
<code>preprocess.fun = DiscreteDatasets::reconstruct_two</code> or
<code>preprocess.fun = DiscreteDatasets::reconstruct_four</code> instead. Alternatively,
use a pipeline, e.g.<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::*.test.pv(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  discrete.BH(&lt;args&gt;)&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.Discrete(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  select.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.Discrete_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line representing a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument (see Details
section of <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>. The three
possible values are <code>"greater"</code> (default), <code>"two.sided"</code>
or <code>"less"</code> (may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_input">input</code></td>
<td>
<p>the format of the input data frame (see Details section
of <code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>. The three possible
values are <code>"noassoc"</code> (default), <code>"marginal"</code> or
<code>"HG2011"</code> (may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_direction">direction</code></td>
<td>
<p>single character string specifying whether to perform a step-up (<code>"su"</code>; the default) or step-down procedure (<code>"sd"</code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>single boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_select.threshold">select.threshold</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the largest raw p-value to be considered, i.e. only p-values below this threshold are considered and the procedures are adjusted in order to take this selection effect into account; if <code>threshold = 1</code> (the default), all raw p-values are selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>rejected raw p-values.</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>indices of rejected hypotheses.</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>number of rejections.</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>critical values (only exists if computations where performed with <code>ret.crit.consts = TRUE</code>).</p>
</td></tr>
<tr><td><code>Select$Threshold</code></td>
<td>
<p>p-value selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Effective.Thresholds</code></td>
<td>
<p>results of each p-value CDF evaluated at the selection threshold (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Pvalues</code></td>
<td>
<p>selected p-values that are <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Indices</code></td>
<td>
<p>indices of p-values <code class="reqn">\leq</code> selection <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Scaled</code></td>
<td>
<p>scaled selected p-values (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Select$Number</code></td>
<td>
<p>number of selected p-values <code class="reqn">\leq</code> <code>threshold</code> (only exists if <code>threshold &lt; 1</code>).</p>
</td></tr>
<tr><td><code>Data$Method</code></td>
<td>
<p>character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>observed p-values.</p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>list of the p-value supports.</p>
</td></tr>
<tr><td><code>Data$FDR.level</code></td>
<td>
<p>FDR level <code>alpha</code>.</p>
</td></tr>
<tr><td><code>Data$Data.name</code></td>
<td>
<p>the respective variable names of the input data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fisher.pvalues.support">fisher.pvalues.support()</a></code>, <code><a href="#topic+discrete.BH">discrete.BH()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DBH.su &lt;- fast.Discrete(df, input = "noassoc", direction = "su")
summary(DBH.su)

DBH.sd &lt;- fast.Discrete(df, input = "noassoc", direction = "sd")
DBH.sd$Adjusted
summary(DBH.sd)

ADBH.su &lt;- fast.Discrete(df, input = "noassoc", direction = "su", adaptive = TRUE)
summary(ADBH.su)

ADBH.sd &lt;- fast.Discrete(df, input = "noassoc", direction = "sd", adaptive = TRUE)
ADBH.sd$Adjusted
summary(ADBH.sd)

</code></pre>

<hr>
<h2 id='fisher.pvalues.support'>Computing Discrete P-Values and Their Supports for Fisher's Exact Test</h2><span id='topic+fisher.pvalues.support'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Computes discrete raw p-values and their support for Fisher's exact test
applied to 2x2 contingency tables summarizing counts coming from two
categorical measurements.
</p>
<p><strong>Note</strong>: This function is deprecated and will be removed in a future
version. Please use <code><a href="#topic+generate.pvalues">generate.pvalues()</a></code> with
<code>test.fun = DiscreteTests::fisher.test.pv</code> and (optional)
<code>preprocess.fun = DiscreteDatasets::reconstruct_two</code> or
<code>preprocess.fun = DiscreteDatasets::reconstruct_four</code> instead. Alternatively,
use a pipeline like<br />
<code style="white-space: pre;">&#8288;data |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteDatasets::reconstruct_*(&lt;args&gt;) |&gt;&#8288;</code><br />
<code style="white-space: pre;">&#8288;  DiscreteTests::fisher.test.pv(&lt;args&gt;)&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.pvalues.support(counts, alternative = "greater", input = "noassoc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.pvalues.support_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line represents a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument, see
Details.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <code><a href="stats.html#topic+fisher.test">stats::fisher.test()</a></code>. The three
possible values are <code>"greater"</code> (default),
<code>"two.sided"</code> or <code>"less"</code> and you can specify
just the initial letter.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_input">input</code></td>
<td>
<p>the format of the input data frame, see Details. The
three possible values are <code>"noassoc"</code> (default),
<code>"marginal"</code> or <code>"HG2011"</code> and you can specify
just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that each contingency tables compares two variables and resumes the
counts of association or not with a condition. This can be resumed in the
following table:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Association </td><td style="text-align: center;"> No association  </td><td style="text-align: center;">      Total      </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 1  </td><td style="text-align: center;">    <code class="reqn">X_1</code>    </td><td style="text-align: center;">    <code class="reqn">Y_1</code>    </td><td style="text-align: center;"> <code class="reqn">N_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 2  </td><td style="text-align: center;">    <code class="reqn">X_2</code>    </td><td style="text-align: center;">    <code class="reqn">Y_2</code>    </td><td style="text-align: center;"> <code class="reqn">N_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total       </td><td style="text-align: center;"> <code class="reqn">X_1 + X_2</code> </td><td style="text-align: center;"> <code class="reqn">Y_1 + Y_2</code> </td><td style="text-align: center;"> <code class="reqn">N_1 + N_2</code>
</td>
</tr>

</table>

<p>If <code>input="noassoc"</code>, <code>counts</code> has four columns which respectively contain,
<code class="reqn">X_1</code>, <code class="reqn">Y_1</code>, <code class="reqn">X_2</code> and <code class="reqn">Y_2</code>. If <code>input="marginal"</code>,
<code>counts</code> has four columns which respectively contain <code class="reqn">X_1</code>, <code class="reqn">N_1</code>,
<code class="reqn">X_2</code> and <code class="reqn">N_2</code>.
</p>
<p>If <code>input="HG2011"</code>, we are in the situation of the <code>amnesia</code> data set as
in Heller &amp; Gur (2011, see References). Each contingency table is obtained
from one variable which is compared to all other variables of the study. That
is, counts for &quot;second variable&quot; are replaced by the sum of the counts of the
other variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Association            </td><td style="text-align: center;"> No association            </td><td style="text-align: center;"> Total                     </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable <code class="reqn">j</code>       </td><td style="text-align: center;"> <code class="reqn">X_j</code>                 </td><td style="text-align: center;"> <code class="reqn">Y_j</code>                 </td><td style="text-align: center;"> <code class="reqn">N_j</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variables <code class="reqn">\neq j</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} X_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} Y_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} N_i</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total                  </td><td style="text-align: center;"> <code class="reqn">\sum X_i</code>            </td><td style="text-align: center;"> <code class="reqn">\sum Y_i</code>            </td><td style="text-align: center;"> <code class="reqn">\sum N_i</code>
</td>
</tr>

</table>

<p>Hence <code>counts</code> needs to have only two columns which respectively contain <code class="reqn">X_j</code> and <code class="reqn">Y_j</code>.
</p>
<p>The code for the computation of the p-values of Fisher's exact test is
inspired by the example in the help page of <code>p.discrete.adjust</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN.
</p>
<p>See the Wikipedia article about Fisher's exact test, paragraph Example, for
a good depiction of what the code does for each possible value of
<code>alternative</code>.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>raw discrete p-values.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values.
Each support is represented by a vector in increasing order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures for
discrete tests. arXiv preprint.
<a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a>.
</p>
<p>&quot;Fisher's exact test&quot;, Wikipedia, The Free Encyclopedia, accessed 2018-03-20,
<a href="https://en.wikipedia.org/w/index.php?title=Fisher's_exact_test&amp;oldid=823327889">link</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support
</code></pre>

<hr>
<h2 id='generate.pvalues'>Generation of P-Values and Their Supports After Data Transformations</h2><span id='topic+generate.pvalues'></span>

<h3>Description</h3>

<p>Simple wrapper for generating p-values of discrete tests and their supports
after pre-processing the input data. The user only has to provide 1.) a
function that generates p-values and supports and 2.) an optional function
that pre-processes (i.e. transforms) the input data (if necessary) before it
can be used for p-value calculations. The respective arguments are provided
by named lists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate.pvalues(
  dat,
  test.fun,
  test.args = NULL,
  preprocess.fun = NULL,
  preprocess.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate.pvalues_+3A_dat">dat</code></td>
<td>
<p>input data; must be suitable for the first parameter of the provided <code>preprocess.fun</code> function or, if <code>preprocess.fun</code> is <code>NULL</code>, for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_test.fun">test.fun</code></td>
<td>
<p>function <strong>from package <code><a href="DiscreteTests.html#topic+DiscreteTests-package">DiscreteTests</a></code></strong>, i.e. one whose name ends with <code style="white-space: pre;">&#8288;*.test.pv&#8288;</code> and which performs hypothesis tests and provides an object with p-values and their support sets; can be specified by a single character string (which is automatically checked for being a suitable function <strong>from that package</strong> and may be abbreviated) or a single function object.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_test.args">test.args</code></td>
<td>
<p>optional named list with arguments for <code>test.fun</code>; the names of the list fields must match the test function's parameter names. The first parameter of the test function MUST NOT be included!</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_preprocess.fun">preprocess.fun</code></td>
<td>
<p>optional function for pre-processing the input <code>data</code>; its result must be suitable for the first parameter of the <code>test.fun</code> function.</p>
</td></tr>
<tr><td><code id="generate.pvalues_+3A_preprocess.args">preprocess.args</code></td>
<td>
<p>optional named list with arguments for <code>preprocess.fun</code>; the names of the list fields must match the pre-processing function's parameter names. The first parameter of the test function MUST NOT be included!</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <a href="DiscreteTests.html#topic+DiscreteTestResults">DiscreteTestResults</a> R6 class object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

# Compute p-values and their supports of Fisher's exact test with pre-processing
df2 &lt;- data.frame(X1, N1, X2, N2)
generate.pvalues(
  dat = df2,
  test.fun = "fisher.test.pv",
  preprocess.fun = function(tab) {
    for(col in c(2, 4)) tab[, col] &lt;- tab[, col] - tab[, col - 1]
    return(tab)
  }
)

# Compute p-values and their supports of a binomial test with pre-processing
generate.pvalues(
  dat = rbind(c(5, 2, 7), c(3, 4, 0)), 
  test.fun = "binom.test.pv",
  test.args = list(n = c(9, 8, 11), p = 0.6, alternative = "two.sided"),
  preprocess.fun = colSums
)

</code></pre>

<hr>
<h2 id='hist.DiscreteFDR'>Histogram of Raw P-Values</h2><span id='topic+hist.DiscreteFDR'></span>

<h3>Description</h3>

<p>Computes a histogram of the raw p-values of a <code>DiscreteFDR</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
hist(x, breaks = "FD", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_breaks">breaks</code></td>
<td>
<p>as in <code><a href="graphics.html#topic+hist">hist</a></code>; here, the Friedman-Diaconis algorithm
(<code>"FD"</code>) is used as default.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_plot">plot</code></td>
<td>
<p>a boolean; if <code>TRUE</code> (the default), a histogram is plotted,
otherwise a list of breaks and counts is returned.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+hist">hist</a></code> or <code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>,
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method simply calls <code><a href="graphics.html#topic+hist">hist</a></code> and passes the raw p-values of the object.
</p>


<h3>Value</h3>

<p>An object of class <code>histogram</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH &lt;- DBH(raw.pvalues, pCDFlist)
hist(DBH)

</code></pre>

<hr>
<h2 id='kernel'>Kernel Functions</h2><span id='topic+kernel'></span><span id='topic+kernel_DBH_fast'></span><span id='topic+kernel_DBH_crit'></span><span id='topic+kernel_ADBH_fast'></span><span id='topic+kernel_ADBH_crit'></span><span id='topic+kernel_DBR_fast'></span><span id='topic+kernel_DBR_crit'></span>

<h3>Description</h3>

<p>Kernel functions that transform observed p-values or their support according
to [HSU], [HSD], [AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>]. The
output is used by <a href="#topic+discrete.BH">discrete.BH</a> or <a href="#topic+DBR">DBR</a>, respectively.
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> and <code>kernel_DBR_crit</code> additionally
compute and return the critical constants.
The end user should not use these functions directly.
</p>
<p><strong>Note</strong>: As of version 2.0, these functions are purely internal functions!
As a consequence, they have to be called directly via <code>:::</code>, e.g.
<code>DiscreteFDR:::kernel_DBH_fast()</code>. But users should <strong>not</strong> rely on them, as
parameters (including their names, order, etc.) may be changed without
notice!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_DBH_fast(
  pCDFlist,
  pvalues,
  stepUp = FALSE,
  alpha = 0.05,
  support = numeric(),
  pCDFcounts = NULL
)

kernel_DBH_crit(
  pCDFlist,
  support,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_ADBH_fast(
  pCDFlist,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  support = numeric(),
  pCDFcounts = NULL
)

kernel_ADBH_crit(
  pCDFlist,
  support,
  sorted_pv,
  stepUp = FALSE,
  alpha = 0.05,
  pCDFcounts = NULL
)

kernel_DBR_fast(pCDFlist, sorted_pv, lambda = 0.05, pCDFcounts = NULL)

kernel_DBR_crit(
  pCDFlist,
  support,
  sorted_pv,
  lambda = 0.05,
  alpha = 0.05,
  pCDFcounts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pvalues">pvalues</code></td>
<td>
<p>numeric vector, sorted in increasing order, that either must contain the entirety of all observable values of the p-value supports (when computing critical constants) or only the sorted raw p-values.</p>
</td></tr>
<tr><td><code id="kernel_+3A_stepup">stepUp</code></td>
<td>
<p>boolean specifying whether to conduct the step-up (<code>TRUE</code>) or step-down (<code>FALSE</code>; the default) procedure.</p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>single real number strictly between 0 and 1 indicating the target FDR level; for <code style="white-space: pre;">&#8288;*.fast&#8288;</code> kernels, it is only needed, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_support">support</code></td>
<td>
<p>numeric vector, sorted in increasing order, that contains the entirety of all observable values of the p-value supports; for <code style="white-space: pre;">&#8288;*.fast&#8288;</code> kernels, it is ignored if <code>stepUp = FALSE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pcdfcounts">pCDFcounts</code></td>
<td>
<p>integer vector of counts that indicates to how many p-values each <strong>unique</strong> p-value distributions belongs.</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_pv">sorted_pv</code></td>
<td>
<p>numeric vector containing the raw p-values, sorted in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_lambda">lambda</code></td>
<td>
<p>real number strictly between 0 and 1 specifying the DBR tuning parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing critical constants under step-down, that is, when using
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> or <code>kernel_DBR_crit</code> with
<code>stepUp = FALSE</code> (i.e. the step-down case), we still need to get transformed
p-values to compute the adjusted p-values.
</p>


<h3>Value</h3>

<p>For <code>kernel.DBH.fast</code>, <code>kernel.ADBH.fast</code> and <code>kernel.DBR.fast</code>, a vector
of transformed p-values is returned. <code>kernel.DBH.crit</code>, <code>kernel.ADBH.crit</code>
<code>kernel.DBR.crit</code> return a list with critical constants (<code style="white-space: pre;">&#8288;$crit.consts&#8288;</code>)
and transformed p-values (<code style="white-space: pre;">&#8288;$pval.transf&#8288;</code>), but if <code>stepUp = FALSE</code>, there
are critical values only.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH</a></code>, <code><a href="#topic+fast.Discrete">fast.Discrete</a></code>, <code><a href="#topic+DBR">DBR</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

alpha &lt;- 0.05

# Compute the step functions from the supports

# If not searching for critical constants, we use only the observed p-values
sorted.pvals   &lt;- sort(raw.pvalues)
y.DBH.sd.fast  &lt;- kernel_DBH_fast(pCDFlist, sorted.pvals)
y.ADBH.sd.fast &lt;- kernel_ADBH_fast(pCDFlist, sorted.pvals)
y.DBR.fast     &lt;- kernel_DBR_fast(pCDFlist, sorted.pvals)
# transformed values
y.DBH.sd.fast
y.ADBH.sd.fast
y.DBR.fast

# compute transformed support
pv.list        &lt;- sort(unique(unlist(pCDFlist)))
y.DBH.sd.crit  &lt;- kernel_DBH_crit(pCDFlist, pv.list, sorted.pvals)
y.ADBH.sd.crit &lt;- kernel_ADBH_crit(pCDFlist, pv.list, sorted.pvals)
y.DBR.crit     &lt;- kernel_DBR_crit(pCDFlist, pv.list, sorted.pvals)
# critical constants
y.DBH.sd.crit$crit.consts
y.ADBH.sd.crit$crit.consts
y.DBR.crit$crit.consts
# The following exist only for step-down direction or DBR
y.DBH.sd.crit$pval.transf
y.ADBH.sd.crit$pval.transf
y.DBR.crit$pval.transf

## End(Not run)

</code></pre>

<hr>
<h2 id='match.pvals'>Matching Raw P-Values with Supports</h2><span id='topic+match.pvals'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Constructs the observed p-values from the raw observed p-values, by rounding
them to their nearest neighbor matching with the supports of their
respective CDFs (as in function <code>p.discrete.adjust()</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN).
</p>
<p><strong>Note</strong>: In the next version, this is to become an internal function and
will have to be called directly via <code>:::</code>, i.e.
<code>DiscreteFDR:::match.pvals()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.pvals(pCDFlist, raw.pvalues, pCDFlist.indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.pvals_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>list of the supports of the CDFs of the p-values; each list item must be a numeric vector, which is sorted in increasing order and whose last element equals 1.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>numeric vector with raw p-values for which a discrete FDR procedure is to be performed.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_pcdflist.indices">pCDFlist.indices</code></td>
<td>
<p>list of numeric vectors containing the test indices that indicate to which raw p-value each <strong>unique</strong> support in <code>pCDFlist</code> belongs; ignored if the lengths of <code>test.results</code> and <code>pCDFlist</code> are equal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Well computed raw p-values should already belong to their respective CDF
support. So this function is called at the beginning of <code><a href="#topic+discrete.BH">discrete.BH()</a></code>,
<code><a href="#topic+DBH">DBH()</a></code>, <code><a href="#topic+ADBH">ADBH()</a></code> and <code><a href="#topic+DBR">DBR()</a></code>, just in case raw p-values are biased.
</p>
<p>For each raw p-value that needs to be rounded, a warning is issued.
</p>


<h3>Value</h3>

<p>A vector where each raw p-value has been replaced by its nearest neighbor, if
necessary.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+discrete.BH">discrete.BH()</a></code>, <code><a href="#topic+DBR">DBR()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
toyList &lt;- list(c(0.3,0.7,1),c(0.1,0.65,1))
toyRaw1 &lt;- c(0.3,0.65)
match.pvals(toyList,toyRaw1)
toyRaw2 &lt;- c(0.31,0.6)
match.pvals(toyList,toyRaw2)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot.DiscreteFDR'>Plot Method for <code>DiscreteFDR</code> objects</h2><span id='topic+plot.DiscreteFDR'></span>

<h3>Description</h3>

<p>Plots raw p-values of a <code>DiscreteFDR</code> object and highlights rejected and
accepted p-values. If present, the critical values are plotted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
plot(
  x,
  col = c(2, 4, 1),
  pch = c(20, 20, 17),
  lwd = rep(par()$lwd, 3),
  cex = rep(par()$cex, 3),
  type.crit = "b",
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_col">col</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
colors of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_pch">pch</code></td>
<td>
<p>numeric or character vector of length 3 indicating the
point characters of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present and <code>type.crit</code>
is a plot type like <code>'p'</code>, <code>'b'</code> etc.).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_lwd">lwd</code></td>
<td>
<p>numeric vector of length 3 indicating the thickness of the
points and lines; defaults to current <code>par()$lwd</code> setting.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_cex">cex</code></td>
<td>
<p>numeric vector of length 3 indicating the size of point
characters or lines of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>

<p>defaults to current <code>par()$cex</code> setting.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_type.crit">type.crit</code></td>
<td>
<p>1-character string giving the type of plot desired for the
critical values (e.g.: <code>'p'</code>, <code>'l'</code> etc; see <code><a href="base.html#topic+plot">plot()</a></code>).</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_legend">legend</code></td>
<td>
<p>if <code>NULL</code>, no legend is plotted; otherwise expecting a
character string like <code>"topleft"</code> etc. or a numeric vector
of two elements indicating (x, y) coordinates.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="graphics.html#topic+plot.default">plot.default()</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.su.fast &lt;- DBH(raw.pvalues, pCDFlist)
DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
DBH.sd.fast &lt;- DBH(test.result, direction = "sd")
DBH.sd.crit &lt;- DBH(test.result, direction = "sd", ret.crit.consts = TRUE)

plot(DBH.sd.fast)
plot(DBH.sd.crit, xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.fast, col = c(2, 4), pch = c(2, 3), lwd = c(2, 2), 
     legend = "topleft", xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.crit, col = c(2, 4, 1), pch = c(1, 1, 4), lwd = c(1, 1, 2), 
     type.crit = 'o', legend = c(1, 0.4), lty = 1, xlim = c(1, 5), 
     ylim = c(0, 0.4))

</code></pre>

<hr>
<h2 id='print.DiscreteFDR'>Printing DiscreteFDR results</h2><span id='topic+print.DiscreteFDR'></span>

<h3>Description</h3>

<p>Prints the results of discrete FDR analysis, stored in a <code>DiscreteFDR</code> class
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="print.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input object <code>x</code> is invisibly returned via <code>invisible(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "su", ret.crit.consts = TRUE)
print(DBH.su.crit)

</code></pre>

<hr>
<h2 id='summary.DiscreteFDR'>Summarizing Discrete FDR Results</h2><span id='topic+summary.DiscreteFDR'></span><span id='topic+print.summary.DiscreteFDR'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>DiscreteFDR</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
summary(object, ...)

## S3 method for class 'summary.DiscreteFDR'
print(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DiscreteFDR_+3A_object">object</code></td>
<td>
<p>an object of class <code>DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class <code>summary.DiscreteFDR</code>.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximal number of
<em>rows</em> of the p-value table to be printed. By default,
when <code>NULL</code>, <code>getOption("max.print")</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.DiscreteFDR</code> objects contain all data of an <code>DiscreteFDR</code> object,
but also include an additional table which includes the raw p-values,
their indices, the respective critical values (if present), the adjusted
p-values (if present) and a logical column to indicate rejection. The table
is sorted in ascending order by the raw p-values.
</p>
<p><code>print.summary.DiscreteFDR</code> simply prints the same output as
<code>print.DiscreteFDR</code>, but also prints the p-value table.
</p>


<h3>Value</h3>

<p><code>summary.DiscreteFDR</code> computes and returns a list that includes all the
data of an input <code>DiscreteFDR</code> object, plus
</p>
<table>
<tr><td><code>Table</code></td>
<td>
<p><code>data.frame</code>, sorted by the raw p-values, that contains the
indices, the raw p-values themselves, their respective critical
values (if present), their adjusted p-values (if present) and a
logical column to indicate rejection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

# Compute p-values and their supports of Fisher's exact test
test.result &lt;- generate.pvalues(df, "fisher")
raw.pvalues &lt;- test.result$get_pvalues()
pCDFlist &lt;- test.result$get_pvalue_supports()

DBH.sd.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd", ret.crit.consts = TRUE)
summary(DBH.sd.crit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
