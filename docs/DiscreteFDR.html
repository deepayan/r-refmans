<!DOCTYPE html><html><head><title>Help for package DiscreteFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DiscreteFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DiscreteFDR'><p>DiscreteFDR</p></a></li>
<li><a href='#amnesia'><p>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous</p>
reporting system</a></li>
<li><a href='#DBR'><p>[HBR-<code class="reqn">\lambda</code>] procedure</p></a></li>
<li><a href='#discrete.BH'><p>[HSU], [HSD], [AHSU] and [AHSD] procedures</p></a></li>
<li><a href='#fast.Discrete'><p>Fast application of discrete procedures</p></a></li>
<li><a href='#fisher.pvalues.support'><p>Computing discrete p-values and their support for binomial and Fisher's</p>
exact tests</a></li>
<li><a href='#hist.DiscreteFDR'><p>Histogram of Raw p-Values</p></a></li>
<li><a href='#kernel'><p>Kernel functions</p></a></li>
<li><a href='#match.pvals'><p>Matching raw p-values with supports</p></a></li>
<li><a href='#plot.DiscreteFDR'><p>Plot Method for <code>DiscreteFDR</code> objects</p></a></li>
<li><a href='#print.DiscreteFDR'><p>Printing DiscreteFDR results</p></a></li>
<li><a href='#summary.DiscreteFDR'><p>Summarizing Discrete FDR Results</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiple Testing Procedures with Adaptation for Discrete Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Multiple testing procedures described in the paper Döhler, Durand and Roquain (2018) "New FDR bounds for discrete and heterogeneous tests" &lt;<a href="https://doi.org/10.1214%2F18-EJS1441">doi:10.1214/18-EJS1441</a>&gt;. The main procedures of the paper (HSU and HSD), their adaptive counterparts (AHSU and AHSD), and the HBR variant are available and are coded to take as input a set of observed p-values and their discrete support under the null. A function to compute such p-values and supports for Fisher's exact tests is also provided, along with a wrapper allowing to apply discrete procedures directly from contingency tables.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.00)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp, knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), methods, lifecycle</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-08 12:50:39 UTC; Florian Junge</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Döhler [aut, ctb],
  Florian Junge [aut, ctb, cre],
  Guillermo Durand [aut, ctb],
  Etienne Roquain [ctb],
  Christina Kihn [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Florian Junge &lt;diso.fbmn@h-da.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-08 23:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='DiscreteFDR'>DiscreteFDR</h2><span id='topic+DiscreteFDR-package'></span><span id='topic+DiscreteFDR'></span>

<h3>Description</h3>

<p>This package implements the [HSU], [HSD],
[AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>] procedures for
discrete tests (see References).
</p>


<h3>Details</h3>

<p>The functions are reorganized from the reference paper in the following way.
<a href="#topic+discrete.BH">discrete.BH</a> (for Discrete Benjamini-Hochberg) implements
[HSU], [HSD], [AHSU] and [AHSD], while <a href="#topic+DBR">DBR</a> (for Discrete
Blanchard-Roquain) implements [HBR-<code class="reqn">\lambda</code>]. <a href="#topic+DBH">DBH</a> and <a href="#topic+ADBH">ADBH</a> are
wrapper functions for <a href="#topic+discrete.BH">discrete.BH</a> to access [HSU] and [HSD], as well as
[AHSU] and [AHSD] directly. Their main arguments are a vector of raw
observed p-values, and a list of the same length, whose elements are the
discrete supports of the CDFs of the p-values.
</p>
<p>The function <a href="#topic+fisher.pvalues.support">fisher.pvalues.support</a> allows to compute such p-values and
support in the framework of a Fisher's exact test of association. It has been
inspired by a help page of the package <code>discreteMTP</code>, which is no longer
available on CRAN.
</p>
<p>The function <a href="#topic+fast.Discrete">fast.Discrete</a> is a wrapper for <a href="#topic+fisher.pvalues.support">fisher.pvalues.support</a> and
<a href="#topic+discrete.BH">discrete.BH</a> which allows to apply discrete procedures directly to a data
set of contingency tables.
</p>
<p>We also provide the <code>amnesia</code> data set, used in our examples and in our
paper. It is basically the <code>amnesia</code> data set of package <code>discreteMTP</code> (no
longer on CRAN), but slightly reformatted such that each line represents a
2x2 contingency table.
</p>
<p>No other function of the package should be used directly, as they are only
internal functions called by the main ones.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Darmstadt Institute of Statistics and Operations Research <a href="mailto:diso.fbmn@h-da.de">diso.fbmn@h-da.de</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Sebastian Döhler [contributor]
</p>
</li>
<li><p> Florian Junge [contributor]
</p>
</li>
<li><p> Guillermo Durand [contributor]
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Etienne Roquain [contributor]
</p>
</li>
<li><p> Christina Kihn [contributor]
</p>
</li></ul>



<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>
<p>G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/DISOhda/DiscreteFDR">https://github.com/DISOhda/DiscreteFDR</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/DISOhda/DiscreteFDR/issues">https://github.com/DISOhda/DiscreteFDR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='amnesia'>Amnesia and other drug reactions in the MHRA pharmacovigilance spontaneous
reporting system</h2><span id='topic+amnesia'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>For each of 2,446 drugs in the MHRA database (column 1),
the number of cases with amnesia as an adverse event (column 2),
and the number of cases with other adverse event for this drug (column 3).
In total, 682,648 adverse drug reactions were reported, among them 2,044
cases of amnesia.
</p>
<p><strong>Note</strong>: In future versions, this dataset will be removed. It will be part
of a new R package that this package will be depending on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(amnesia)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2,446 rows representing drugs with the following
three columns:
</p>

<dl>
<dt>DrugName</dt><dd><p>The name of the drug.</p>
</dd>
<dt>AmnesiaCases</dt><dd><p>Number of the amnesia cases reported for the drug.</p>
</dd>
<dt>OtherAdverseCases</dt><dd><p>Number of other adverse drug reactions reported
for the drug.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was collected from the Drug Analysis Prints published
by the Medicines and Healthcare products Regulatory Agency (MHRA),
by Heller &amp; Gur. See references for more details.
</p>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures
for discrete tests.
<a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a> (preprint).
</p>


<h3>Source</h3>

<p><a href="https://yellowcard.mhra.gov.uk/idap">Drug Analysis Prints on MHRA site</a>
</p>

<hr>
<h2 id='DBR'>[HBR-<code class="reqn">\lambda</code>] procedure</h2><span id='topic+DBR'></span>

<h3>Description</h3>

<p>Apply the [HBR-<code class="reqn">\lambda</code>] procedure, with or without computing the
critical constants, to a set of p-values and their discrete support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DBR(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  lambda = NULL,
  ret.crit.consts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DBR_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="DBR_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="DBR_+3A_alpha">alpha</code></td>
<td>
<p>the target FDR level, a number strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="DBR_+3A_lambda">lambda</code></td>
<td>
<p>a number strictly between 0 and 1. If <code>lambda=NULL</code> (by default), then <code>lambda</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
<tr><td><code id="DBR_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>[DBR-<code class="reqn">\lambda</code>] is the discrete version of the
[Blanchard-Roquain-<code class="reqn">\lambda</code>] procedure (see References). The authors
of the latter suggest to take <code>lambda = alpha</code> (see their Proposition 17),
which explains the choice of the default value here.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values </p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>Critical constants (if requested)</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>Character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Signif.level</code></td>
<td>
<p>Significance level <code>alpha</code></p>
</td></tr>
<tr><td><code>Lambda</code></td>
<td>
<p>Value of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code></p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code></p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>G. Blanchard and E. Roquain (2009). Adaptive false discovery rate control
under independence and dependence. <em>Journal of Machine Learning Research</em>,
<em>10</em>, pp. 2837-2871.
</p>


<h3>See Also</h3>

<p><a href="#topic+discrete.BH">discrete.BH</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DBR.fast &lt;- DBR(raw.pvalues, pCDFlist)
summary(DBR.fast)
DBR.crit &lt;- DBR(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBR.crit)

</code></pre>

<hr>
<h2 id='discrete.BH'>[HSU], [HSD], [AHSU] and [AHSD] procedures</h2><span id='topic+discrete.BH'></span><span id='topic+DBH'></span><span id='topic+ADBH'></span>

<h3>Description</h3>

<p>Apply the [HSU], [HSD], [AHSU] and [AHSD] procedures, with or without
computing the critical constants, to a set of p-values and their discrete
support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discrete.BH(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE,
  ret.crit.consts = FALSE
)

DBH(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE
)

ADBH(
  raw.pvalues,
  pCDFlist,
  alpha = 0.05,
  direction = "su",
  ret.crit.consts = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discrete.BH_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_alpha">alpha</code></td>
<td>
<p>the target FDR level, a number strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_direction">direction</code></td>
<td>
<p>a character string specifying whether to conduct a step-up (<code>direction="su"</code>, by default) or step-down procedure (<code>direction="sd"</code>).</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
<tr><td><code id="discrete.BH_+3A_ret.crit.consts">ret.crit.consts</code></td>
<td>
<p>a boolean. If <code>TRUE</code>, critical constants are computed and returned (this is computationally intensive).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>DBH</code> and <code>ADBH</code> are wrapper functions for <code>discrete.BH</code>. <code>DBH</code> simply passes
all its parameters to <code>discrete.BH</code> with <code>adaptive = FALSE</code>. <code>ADBH</code> does the
same with <code>adaptive = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Critical.constants</code></td>
<td>
<p>Critical constants (if requested)</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>Character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Signif.level</code></td>
<td>
<p>Significance level <code>alpha</code></p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code></p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code></p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The respective variable names of <code>raw.pvalues</code> and <code>pCDFlist</code></p>
</td></tr>
</table>


<h3>References</h3>

<p>Döhler, S., Durand, G., &amp; Roquain, E. (2018). New FDR bounds for discrete
and heterogeneous tests. <em>Electronic Journal of Statistics</em>, <em>12</em>(1),
pp. 1867-1900. <a href="https://doi.org/10.1214/18-EJS1441">doi:10.1214/18-EJS1441</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+fast.Discrete">fast.Discrete</a>, <a href="#topic+DBR">DBR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support
DBH.su.fast &lt;- DBH(raw.pvalues, pCDFlist)
summary(DBH.su.fast)
DBH.sd.fast &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd")
DBH.sd.fast$Adjusted
summary(DBH.sd.fast)

DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(DBH.su.crit)
DBH.sd.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd",
                   ret.crit.consts = TRUE)
DBH.sd.crit$Adjusted
summary(DBH.sd.crit)

ADBH.su.fast &lt;- ADBH(raw.pvalues, pCDFlist)
summary(ADBH.su.fast)
ADBH.sd.fast &lt;- ADBH(raw.pvalues, pCDFlist, direction = "sd")
ADBH.sd.fast$Adjusted
summary(ADBH.sd.fast)

ADBH.su.crit &lt;- ADBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
summary(ADBH.su.crit)
ADBH.sd.crit &lt;- ADBH(raw.pvalues, pCDFlist, direction = "sd",
                     ret.crit.consts = TRUE)
ADBH.sd.crit$Adjusted
summary(ADBH.sd.crit)

</code></pre>

<hr>
<h2 id='fast.Discrete'>Fast application of discrete procedures</h2><span id='topic+fast.Discrete'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Apply the [HSU], [HSD], [AHSU] or [AHSD] procedure,
without computing the critical constants,
to a data set of 2x2 contingency tables using Fisher's exact tests.
</p>
<p><strong>Note</strong>: In future versions, this function will be removed and replaced by a
more flexible one, which will not be limited to Fisher's exact test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast.Discrete(
  counts,
  alternative = "greater",
  input = "noassoc",
  alpha = 0.05,
  direction = "su",
  adaptive = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast.Discrete_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line representing a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument (see Details
section of <a href="#topic+fisher.pvalues.support">fisher.pvalues.support</a>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <a href="stats.html#topic+fisher.test">fisher.test</a>. The three
possible values are <code>"greater"</code> (default), <code>"two.sided"</code>
or <code>"less"</code> (may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_input">input</code></td>
<td>
<p>the format of the input data frame (see Details section
of <a href="#topic+fisher.pvalues.support">fisher.pvalues.support</a>. The three possible values
are <code>"noassoc"</code> (default), <code>"marginal"</code> or <code>"HG2011"</code>
(may be abbreviated).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_alpha">alpha</code></td>
<td>
<p>the target FDR level, a number strictly between 0 and 1.</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_direction">direction</code></td>
<td>
<p>a character string specifying whether to conduct a step-up (<code>direction="su"</code>, by default) or step-down procedure (<code>direction="sd"</code>).</p>
</td></tr>
<tr><td><code id="fast.Discrete_+3A_adaptive">adaptive</code></td>
<td>
<p>a boolean specifying whether to conduct an adaptive procedure or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>DiscreteFDR</code> S3 class object whose elements are:
</p>
<table>
<tr><td><code>Rejected</code></td>
<td>
<p>Rejected raw p-values</p>
</td></tr>
<tr><td><code>Indices</code></td>
<td>
<p>Indices of rejected hypotheses</p>
</td></tr>
<tr><td><code>Num.rejected</code></td>
<td>
<p>Number of rejections</p>
</td></tr>
<tr><td><code>Adjusted</code></td>
<td>
<p>Adjusted p-values (only for step-down direction).</p>
</td></tr>
<tr><td><code>Method</code></td>
<td>
<p>Character string describing the used algorithm, e.g. 'Discrete Benjamini-Hochberg procedure (step-up)'</p>
</td></tr>
<tr><td><code>Signif.level</code></td>
<td>
<p>Significance level <code>alpha</code></p>
</td></tr>
<tr><td><code>Data$raw.pvalues</code></td>
<td>
<p>The values of <code>raw.pvalues</code></p>
</td></tr>
<tr><td><code>Data$pCDFlist</code></td>
<td>
<p>The values of <code>pCDFlist</code></p>
</td></tr>
<tr><td><code>Data$data.name</code></td>
<td>
<p>The variable name of the <code>counts</code> dataset</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+fisher.pvalues.support">fisher.pvalues.support</a>, <a href="#topic+discrete.BH">discrete.BH</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

DBH.su &lt;- fast.Discrete(counts = df, input = "noassoc", direction = "su")
summary(DBH.su)

DBH.sd &lt;- fast.Discrete(counts = df, input = "noassoc", direction = "sd")
DBH.sd$Adjusted
summary(DBH.sd)

ADBH.su &lt;- fast.Discrete(counts = df, input = "noassoc", direction = "su", adaptive = TRUE)
summary(ADBH.su)

ADBH.sd &lt;- fast.Discrete(counts = df, input = "noassoc", direction = "sd", adaptive = TRUE)
ADBH.sd$Adjusted
summary(ADBH.sd)

</code></pre>

<hr>
<h2 id='fisher.pvalues.support'>Computing discrete p-values and their support for binomial and Fisher's
exact tests</h2><span id='topic+fisher.pvalues.support'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Computes discrete raw p-values and their support
for binomial test or Fisher's exact test applied to 2x2 contingency tables
summarizing counts coming from two categorical measurements.
</p>
<p><strong>Note</strong>: In future versions, this function will be removed. Generation of
p-value supports for different exact tests, including Fisher's, will be
moved to a separate package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fisher.pvalues.support(counts, alternative = "greater", input = "noassoc")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fisher.pvalues.support_+3A_counts">counts</code></td>
<td>
<p>a data frame of two or four columns and any number of
lines; each line represents a 2x2 contingency table to
test. The number of columns and what they must contain
depend on the value of the <code>input</code> argument, see
Details.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_alternative">alternative</code></td>
<td>
<p>same argument as in <a href="stats.html#topic+fisher.test">stats::fisher.test</a>. The three
possible values are <code>"greater"</code> (default),
<code>"two.sided"</code> or <code>"less"</code> and you can specify
just the initial letter.</p>
</td></tr>
<tr><td><code id="fisher.pvalues.support_+3A_input">input</code></td>
<td>
<p>the format of the input data frame, see Details. The
three possible values are <code>"noassoc"</code> (default),
<code>"marginal"</code> or <code>"HG2011"</code> and you can specify
just the initial letter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assume that each contingency tables compares two variables and resumes the
counts of association or not with a condition. This can be resumed in the
following table:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Association </td><td style="text-align: center;"> No association  </td><td style="text-align: center;">      Total      </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 1  </td><td style="text-align: center;">    <code class="reqn">X_1</code>    </td><td style="text-align: center;">    <code class="reqn">Y_1</code>    </td><td style="text-align: center;"> <code class="reqn">N_1</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable 2  </td><td style="text-align: center;">    <code class="reqn">X_2</code>    </td><td style="text-align: center;">    <code class="reqn">Y_2</code>    </td><td style="text-align: center;"> <code class="reqn">N_2</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total       </td><td style="text-align: center;"> <code class="reqn">X_1 + X_2</code> </td><td style="text-align: center;"> <code class="reqn">Y_1 + Y_2</code> </td><td style="text-align: center;"> <code class="reqn">N_1 + N_2</code>
</td>
</tr>

</table>

<p>If <code>input="noassoc"</code>, <code>counts</code> has four columns which respectively contain,
<code class="reqn">X_1</code>, <code class="reqn">Y_1</code>, <code class="reqn">X_2</code> and <code class="reqn">Y_2</code>. If <code>input="marginal"</code>,
<code>counts</code> has four columns which respectively contain <code class="reqn">X_1</code>, <code class="reqn">N_1</code>,
<code class="reqn">X_2</code> and <code class="reqn">N_2</code>.
</p>
<p>If <code>input="HG2011"</code>, we are in the situation of the <a href="#topic+amnesia">amnesia</a> data set as
in Heller &amp; Gur (2011, see References). Each contingency table is obtained
from one variable which is compared to all other variables of the study. That
is, counts for &quot;second variable&quot; are replaced by the sum of the counts of the
other variables:
</p>

<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> Association            </td><td style="text-align: center;"> No association            </td><td style="text-align: center;"> Total                     </td>
</tr>
<tr>
 <td style="text-align: left;">
Variable <code class="reqn">j</code>       </td><td style="text-align: center;"> <code class="reqn">X_j</code>                 </td><td style="text-align: center;"> <code class="reqn">Y_j</code>                 </td><td style="text-align: center;"> <code class="reqn">N_j</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Variables <code class="reqn">\neq j</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} X_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} Y_i</code> </td><td style="text-align: center;"> <code class="reqn">\sum_{i \neq j} N_i</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
Total                  </td><td style="text-align: center;"> <code class="reqn">\sum X_i</code>            </td><td style="text-align: center;"> <code class="reqn">\sum Y_i</code>            </td><td style="text-align: center;"> <code class="reqn">\sum N_i</code>
</td>
</tr>

</table>

<p>Hence <code>counts</code> needs to have only two columns which respectively contain <code class="reqn">X_j</code> and <code class="reqn">Y_j</code>.
</p>
<p>The code for the computation of the p-values of Fisher's exact test is
inspired by the example in the help page of <code>p.discrete.adjust</code> of package
<code>discreteMTP</code>, which is no longer available on CRAN.
</p>
<p>See the Wikipedia article about Fisher's exact test, paragraph Example, for
a good depiction of what the code does for each possible value of
<code>alternative</code>.
</p>


<h3>Value</h3>

<p>A list of two elements:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>raw discrete p-values.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values.
Each support is represented by a vector in increasing order.</p>
</td></tr>
</table>


<h3>References</h3>

<p>R. Heller and H. Gur (2011). False discovery rate controlling procedures for
discrete tests. arXiv preprint.
<a href="https://arxiv.org/abs/1112.4627v2">arXiv:1112.4627v2</a>.
</p>
<p>&quot;Fisher's exact test&quot;, Wikipedia, The Free Encyclopedia, accessed 2018-03-20,
<a href="https://en.wikipedia.org/w/index.php?title=Fisher's_exact_test&amp;oldid=823327889">link</a>.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+fisher.test">fisher.test</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

data(amnesia)
#We only keep the first 100 lines to keep the computations fast.
#We also drop the first column to keep only columns of counts, in the Heller &amp; Gur (2011) setting.
amnesia &lt;- amnesia[1:100,2:3]

#Construction of the p-values and their support
amnesia.formatted &lt;- fisher.pvalues.support(counts = amnesia, input = "HG2011")
raw.pvalues &lt;- amnesia.formatted$raw
pCDFlist &lt;- amnesia.formatted$support
</code></pre>

<hr>
<h2 id='hist.DiscreteFDR'>Histogram of Raw p-Values</h2><span id='topic+hist.DiscreteFDR'></span>

<h3>Description</h3>

<p>Computes a histogram of the raw p-values of a <code>DiscreteFDR</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
hist(x, breaks = "FD", plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_breaks">breaks</code></td>
<td>
<p>as in <a href="graphics.html#topic+hist">hist</a>; here, the Friedman-Diaconis
algorithm(<code>"FD"</code>) is used as default.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_plot">plot</code></td>
<td>
<p>a boolean If <code>TRUE</code> (the default), a histogram is plotted,
otherwise a list of breaks and counts is returned.</p>
</td></tr>
<tr><td><code id="hist.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <a href="graphics.html#topic+hist">hist</a> or <a href="graphics.html#topic+plot.histogram">plot.histogram</a>,
respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method simply calls <a href="graphics.html#topic+hist">hist</a> and passes the raw p-values of the object.
</p>


<h3>Value</h3>

<p>An object of class <code>histogram</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DBH &lt;- DBH(raw.pvalues, pCDFlist)
hist(DBH)

</code></pre>

<hr>
<h2 id='kernel'>Kernel functions</h2><span id='topic+kernel'></span><span id='topic+kernel_DBH_fast'></span><span id='topic+kernel_DBH_crit'></span><span id='topic+kernel_ADBH_fast'></span><span id='topic+kernel_ADBH_crit'></span><span id='topic+kernel_DBR_fast'></span><span id='topic+kernel_DBR_crit'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Kernel functions that transform observed p-values or their support according
to [HSU], [HSD], [AHSU], [AHSD] and [HBR-<code class="reqn">\lambda</code>]. The
output is used by <a href="#topic+discrete.BH">discrete.BH</a> or <a href="#topic+DBR">DBR</a>, respectively.
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> and <code>kernel_DBR_crit</code> additionally
compute and return the critical constants.
The end user should not use these functions directly.
</p>
<p><strong>Note</strong>: In future versions, these functions will no longer be exported to
the global namespace. Instead, they will be purely internal functions and
will have to be called directly via <code>:::</code>, e.g.
<code>DiscreteFDR:::kernel_DBH_fast()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_DBH_fast(pCDFlist, pvalues, stepUp = FALSE, alpha = 0.05, support = 0L)

kernel_DBH_crit(pCDFlist, pvalues, sorted_pv, stepUp = FALSE, alpha = 0.05)

kernel_ADBH_fast(pCDFlist, pvalues, stepUp = FALSE, alpha = 0.05, support = 0L)

kernel_ADBH_crit(pCDFlist, pvalues, sorted_pv, stepUp = FALSE, alpha = 0.05)

kernel_DBR_fast(pCDFlist, pvalues, lambda = 0.05)

kernel_DBR_crit(pCDFlist, pvalues, sorted_pv, lambda = 0.05, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_pvalues">pvalues</code></td>
<td>
<p>a numeric vector. Contains all values of the p-values supports if we search for the critical constants. If not, contains only the observed p-values. Must be sorted in increasing order!</p>
</td></tr>
<tr><td><code id="kernel_+3A_stepup">stepUp</code></td>
<td>
<p>a numeric vector. Identical to <code>pvalues</code> for a step-down procedure. Equals <code>c.m</code> for a step-up procedure.</p>
</td></tr>
<tr><td><code id="kernel_+3A_alpha">alpha</code></td>
<td>
<p>the target FDR level, a number strictly between 0 and 1. For <code>*.fast</code> kernels, it is only necessary, if <code>stepUp = TRUE</code>.</p>
</td></tr>
<tr><td><code id="kernel_+3A_support">support</code></td>
<td>
<p>a numeric vector. Contains all values of the p-values supports. Ignored, if <code>stepUp = FALSE</code>. Must be sorted in increasing order!</p>
</td></tr>
<tr><td><code id="kernel_+3A_sorted_pv">sorted_pv</code></td>
<td>
<p>a vector of observed p-values, in increasing order.</p>
</td></tr>
<tr><td><code id="kernel_+3A_lambda">lambda</code></td>
<td>
<p>a number strictly between 0 and 1. If <code>lambda=NULL</code> (by default), then <code>lambda</code> is chosen equal to <code>alpha</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When computing critical constants under step-down, that is, when using
<code>kernel_DBH_crit</code>, <code>kernel_ADBH_crit</code> or <code>kernel_DBR_crit</code> with
<code>stepUp = FALSE</code> (i.e. the step-down case), we still need to get transformed
p-values to compute the adjusted p-values.
</p>


<h3>Value</h3>

<p>For <code>kernel.DBH.fast</code>, <code>kernel.ADBH.fast</code> and <code>kernel.DBR.fast</code>, a vector
of transformed p-values is returned. <code>kernel.DBH.crit</code>, <code>kernel.ADBH.crit</code>
<code>kernel.DBR.crit</code> return a list with critical constants (<code style="white-space: pre;">&#8288;$crit.consts&#8288;</code>)
and transformed p-values (<code style="white-space: pre;">&#8288;$pval.transf&#8288;</code>), but if <code>stepUp = FALSE</code>, there
are critical values only.
</p>


<h3>See Also</h3>

<p><a href="#topic+discrete.BH">discrete.BH</a>, <a href="#topic+fast.Discrete">fast.Discrete</a>, <a href="#topic+DBR">DBR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

alpha &lt;- 0.05

# Compute the step functions from the supports

# We stay in a step-down context, where pv.numer = pv.denom,
# for the sake of simplicity

# If not searching for critical constants, we use only the observed p-values
sorted.pvals &lt;- sort(raw.pvalues)
y.DBH.fast &lt;- kernel_DBH_fast(pCDFlist, sorted.pvals)
y.ADBH.fast &lt;- kernel_ADBH_fast(pCDFlist, sorted.pvals)
# transformed values
y.DBH.fast
y.ADBH.fast

# compute transformed support
pv.list &lt;- sort(unique(unlist(pCDFlist)))
y.DBH.crit &lt;- kernel_DBH_crit(pCDFlist, pv.list, sorted.pvals)
y.ADBH.crit &lt;- kernel_ADBH_crit(pCDFlist, pv.list, sorted.pvals)
y.DBR.crit &lt;- kernel_DBR_crit(pCDFlist, pv.list, sorted.pvals)
# critical constants
y.DBH.crit$crit.consts
y.ADBH.crit$crit.consts
y.DBR.crit$crit.consts
# The following exist only for step-down direction or DBR
y.DBH.crit$pval.transf
y.ADBH.crit$pval.transf
y.DBR.crit$pval.transf

</code></pre>

<hr>
<h2 id='match.pvals'>Matching raw p-values with supports</h2><span id='topic+match.pvals'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
</p>
<p>Constructs the observed p-values from the raw observed p-values, by rounding
them to their nearest neighbor matching with the supports of their
respective CDFs (as in function <code>p.discrete.adjust</code> of package <code>discreteMTP</code>,
which is no longer available on CRAN).
The end user should not use it directly.
</p>
<p><strong>Note</strong>: In future versions, this function will no longer be exported to the
global namespace. Instead, it will be a purely internal function and will
have to be called directly via <code>:::</code>, i.e. <code>DiscreteFDR:::match.pvals()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.pvals(pCDFlist, raw.pvalues)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.pvals_+3A_pcdflist">pCDFlist</code></td>
<td>
<p>a list of the supports of the CDFs of the p-values. Each support is represented by a vector that must be in increasing order.</p>
</td></tr>
<tr><td><code id="match.pvals_+3A_raw.pvalues">raw.pvalues</code></td>
<td>
<p>vector of the raw observed p-values, as provided by the end user and before matching with their nearest neighbor in the CDFs supports.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Well computed raw p-values should already belong to their respective CDF
support. So this function is called at the beginning of <a href="#topic+discrete.BH">discrete.BH</a>,
<a href="#topic+DBH">DBH</a>, <a href="#topic+ADBH">ADBH</a> and <a href="#topic+DBR">DBR</a>, just in case raw p-values are biased.
</p>
<p>For each raw p-value that needs to be rounded, a warning is issued.
</p>


<h3>Value</h3>

<p>A vector where each raw p-value has been
replaced by its nearest neighbor.
</p>


<h3>See Also</h3>

<p><a href="#topic+discrete.BH">discrete.BH</a>, <a href="#topic+DBR">DBR</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>toyList &lt;- list(c(0.3,0.7,1),c(0.1,0.65,1))
toyRaw1 &lt;- c(0.3,0.65)
match.pvals(toyList,toyRaw1)
toyRaw2 &lt;- c(0.31,0.6)
match.pvals(toyList,toyRaw2)

</code></pre>

<hr>
<h2 id='plot.DiscreteFDR'>Plot Method for <code>DiscreteFDR</code> objects</h2><span id='topic+plot.DiscreteFDR'></span>

<h3>Description</h3>

<p>Plots raw p-values of a <code>DiscreteFDR</code> object and highlights rejected and
accepted p-values. If present, the critical values are plotted, too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
plot(
  x,
  col = c(2, 4, 1),
  pch = c(1, 1, 1),
  lwd = c(1, 1, 1),
  type.crit = "b",
  legend = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_col">col</code></td>
<td>
<p>a numeric or character vector of length 3 indicating the
colors of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_pch">pch</code></td>
<td>
<p>a numeric or character vector of length 3 indicating the
point characters of the </p>

<ol>
<li><p> rejected p-values
</p>
</li>
<li><p> accepted p-values
</p>
</li>
<li><p> critical values (if present and <code>type.crit</code>
is a plot type like <code>'p'</code>, <code>'b'</code> etc.).
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_lwd">lwd</code></td>
<td>
<p>a numeric vector of length 3 indicating the thickness of
the points and lines.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_type.crit">type.crit</code></td>
<td>
<p>1-character string giving the type of plot desired for the
critical values (e.g.: <code>'p'</code>, <code>'l'</code> etc; see <a href="graphics.html#topic+plot">plot</a>).</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_legend">legend</code></td>
<td>
<p>if NULL, no legend is plotted; otherwise expecting a
character string like &quot;topleft&quot; etc. or a numeric vector
of two elements indicating (x, y) coordinates.</p>
</td></tr>
<tr><td><code id="plot.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to <a href="graphics.html#topic+plot.default">plot.default</a>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DBH.su.fast &lt;- DBH(raw.pvalues, pCDFlist)
DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, ret.crit.consts = TRUE)
DBH.sd.fast &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd")
DBH.sd.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd", ret.crit.consts = TRUE)

plot(DBH.sd.fast)
plot(DBH.sd.crit, xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.fast, col = c(2, 4), pch = c(2, 3), lwd = c(2, 2), 
    legend = "topleft", xlim = c(1, 5), ylim = c(0, 0.4))
plot(DBH.su.crit, col = c(2, 4, 1), pch = c(1, 1, 4), lwd = c(1, 1, 2), 
    type.crit = 'o', legend = c(1, 0.4), lty = 1, xlim = c(1, 5), 
    ylim = c(0, 0.4))

</code></pre>

<hr>
<h2 id='print.DiscreteFDR'>Printing DiscreteFDR results</h2><span id='topic+print.DiscreteFDR'></span>

<h3>Description</h3>

<p>Prints the results of discrete FDR analysis, stored in a <code>DiscreteFDR</code>
S3 class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="print.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from other methods.
They are ignored in this function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The respective input object is invisibly returned via <code>invisible(x)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DBH.su.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "su",
                   ret.crit.consts = TRUE)
print(DBH.su.crit)

</code></pre>

<hr>
<h2 id='summary.DiscreteFDR'>Summarizing Discrete FDR Results</h2><span id='topic+summary.DiscreteFDR'></span><span id='topic+print.summary.DiscreteFDR'></span>

<h3>Description</h3>

<p><code>summary</code> method for class &quot;<code>DiscreteFDR</code>&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DiscreteFDR'
summary(object, ...)

## S3 method for class 'summary.DiscreteFDR'
print(x, max = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DiscreteFDR_+3A_object">object</code></td>
<td>
<p>an object of class &quot;<code>DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_x">x</code></td>
<td>
<p>an object of class &quot;<code>summary.DiscreteFDR</code>&quot;.</p>
</td></tr>
<tr><td><code id="summary.DiscreteFDR_+3A_max">max</code></td>
<td>
<p>numeric or <code>NULL</code>, specifying the maximal number of
<em>rows</em> of the p-value table to be printed. By default,
when <code>NULL</code>, <code>getOption("max.print")</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.DiscreteFDR</code> objects include all data of an <code>DiscreteFDR</code>
object, but also include an additional table which includes the raw p-values,
their indices, the respective critical values (if present), the adjusted
p-values (if present) and a logical column to indicate rejection. The table
is sorted in ascending order by the raw p-values.
</p>
<p><code>print.summary.DiscreteFDR</code> simply prints the same output as
<code>print.DiscreteFDR</code>, but also prints the p-value table.
</p>


<h3>Value</h3>

<p><code>summary.DiscreteFDR</code> computes and returns a list that includes all the
data of an input <code>DiscreteFDR</code>, plus
</p>
<table>
<tr><td><code>Table</code></td>
<td>
<p>a <code>data.frame</code>, sorted by the raw p-values, that contains
the indices, that raw p-values themselves, their respective
critical values (if present), their adjusted p-values (if
present) and a logical column to indicate rejection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>X1 &lt;- c(4, 2, 2, 14, 6, 9, 4, 0, 1)
X2 &lt;- c(0, 0, 1, 3, 2, 1, 2, 2, 2)
N1 &lt;- rep(148, 9)
N2 &lt;- rep(132, 9)
Y1 &lt;- N1 - X1
Y2 &lt;- N2 - X2
df &lt;- data.frame(X1, Y1, X2, Y2)
df

#Construction of the p-values and their support
df.formatted &lt;- fisher.pvalues.support(counts = df, input = "noassoc")
raw.pvalues &lt;- df.formatted$raw
pCDFlist &lt;- df.formatted$support

DBH.sd.crit &lt;- DBH(raw.pvalues, pCDFlist, direction = "sd",
                   ret.crit.consts = TRUE)
summary(DBH.sd.crit)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
