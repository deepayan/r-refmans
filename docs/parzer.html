<!DOCTYPE html><html><head><title>Help for package parzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dms'><p>extract degree, minutes, and seconds</p></a></li>
<li><a href='#parse_hemisphere'><p>get hemisphere from long/lat coordinates</p></a></li>
<li><a href='#parse_lat'><p>Parse latitude values</p></a></li>
<li><a href='#parse_llstr'><p>parse string with lat and lon together</p></a></li>
<li><a href='#parse_lon'><p>Parse longitude values</p></a></li>
<li><a href='#parse_lon_lat'><p>parse longitude and latitude</p></a></li>
<li><a href='#parse_parts'><p>parse coordinates into degrees, minutes and seconds</p></a></li>
<li><a href='#parzer-package'><p>parzer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parse Messy Geographic Coordinates</td>
</tr>
<tr>
<td>Description:</td>
<td>Parse messy geographic coordinates from various character formats
    to decimal degree numeric values. Parse coordinates into
    their parts (degree, minutes, seconds); calculate hemisphere
    from coordinates; pull out individually degrees,
    minutes, or seconds; add and subtract degrees, minutes,
    and seconds. C++ code herein originally inspired from code
    written by Jeffrey D. Bogan, but then completely re-written.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alban Sagouis &lt;sagouis@pm.me&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ropensci/parzer">https://github.com/ropensci/parzer</a> (devel)
<a href="https://docs.ropensci.org/parzer/">https://docs.ropensci.org/parzer/</a> (docs)</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/parzer/issues">https://github.com/ropensci/parzer/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.2), withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, randgeo, knitr, rmarkdown, callr, pkgbuild, pkgload</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>X-schema.org-applicationCategory:</td>
<td>Geospatial</td>
</tr>
<tr>
<td>X-schema.org-keywords:</td>
<td>geospatial, data, latitude, longitude, parser,
coordinates</td>
</tr>
<tr>
<td>X-schema.org-isPartOf:</td>
<td>https://ropensci.org</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-12-20 09:35:29 UTC; as80fywe</td>
</tr>
<tr>
<td>Author:</td>
<td>Scott Chamberlain <a href="https://orcid.org/0000-0003-1444-9135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alban Sagouis <a href="https://orcid.org/0000-0002-3827-1063"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Alec L. Robitaille [ctb],
  Maëlle Salmon <a href="https://orcid.org/0000-0002-2815-0399"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Hiroaki Yutani [ctb],
  Jeffrey Bogan [ctb] (C++ code originally from Jeffrey Bogan, but
    completely re-written),
  Julien Brun [rev] (Julien Brun reviewed the package, see
    https://github.com/ropensci/onboarding/issues/341),
  Maria Munafó [rev] (Maria Munafó reviewed the package, see
    https://github.com/ropensci/onboarding/issues/341),
  rOpenSci [fnd] (https://ropensci.org)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-12-20 16:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='dms'>extract degree, minutes, and seconds</h2><span id='topic+dms'></span><span id='topic+pz_degree'></span><span id='topic+pz_minute'></span><span id='topic+pz_second'></span><span id='topic+print.pz'></span><span id='topic+pz_d'></span><span id='topic+pz_m'></span><span id='topic+pz_s'></span><span id='topic++2B.pz'></span><span id='topic+-.pz'></span><span id='topic++2F.pz'></span><span id='topic++2A.pz'></span>

<h3>Description</h3>

<p>extract degree, minutes, and seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pz_degree(lon = NULL, lat = NULL)

pz_minute(lon = NULL, lat = NULL)

pz_second(lon = NULL, lat = NULL)

## S3 method for class 'pz'
print(x, ...)

pz_d(x)

pz_m(x)

pz_s(x)

## S3 method for class 'pz'
e1 + e2

## S3 method for class 'pz'
e1 - e2

## S3 method for class 'pz'
e1 / e2

## S3 method for class 'pz'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dms_+3A_lon">lon</code>, <code id="dms_+3A_lat">lat</code></td>
<td>
<p>(numeric/integer/character) one or more longitude or
latitude values. values are internally validated. only one of
lon or lat accepted</p>
</td></tr>
<tr><td><code id="dms_+3A_x">x</code></td>
<td>
<p>(integer) an integer representing a degree, minute or second</p>
</td></tr>
<tr><td><code id="dms_+3A_...">...</code></td>
<td>
<p>print dots</p>
</td></tr>
<tr><td><code id="dms_+3A_e1">e1</code>, <code id="dms_+3A_e2">e2</code></td>
<td>
<p>objects of class pz, from using <code>pz_d()</code>, <code>pz_m()</code>, or <code>pz_s()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematics operators are exported for <code>+</code>, <code>-</code>, <code>/</code>, and <code>*</code>,
but <code>/</code> and <code>*</code> are only exported with a stop message to say it's not
supported; otherwise you'd be allow to divide degrees by minutes, leading
to nonsense.
</p>


<h3>Value</h3>

<p><code>pz_degree</code>: integer, <code>pz_minute</code>: integer, <code>pz_second</code>: numeric,
<code>pz_d</code>: numeric, <code>pz_m</code>: numeric, <code>pz_s</code>: numeric (adding/subtracting
these also gives numeric)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># extract parts of a coordinate value
pz_degree(-45.23323)
pz_minute(-45.23323)
pz_second(-45.23323)

pz_degree(lon = 178.23423)
pz_minute(lon = 178.23423)
pz_second(lon = 178.23423)
## Not run: 
pz_degree(lat = c(45.23323, "40:25:6N", "40° 25´ 5.994 S"))
pz_minute(lat = c(45.23323, "40:25:6N", "40° 25´ 5.994 S"))
pz_second(lat = c(45.23323, "40:25:6N", "40° 25´ 5.994 S"))

# invalid
pz_degree(445.23323)

# add or subtract
pz_d(31)
pz_m(44)
pz_s(3)
pz_d(31) + pz_m(44)
pz_d(-31) - pz_m(44)
pz_d(-31) + pz_m(44) + pz_s(59)
pz_d(31) - pz_m(44) + pz_s(59)
pz_d(-121) + pz_m(1) + pz_s(33)
unclass(pz_d(31) + pz_m(44) + pz_s(59))

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_hemisphere'>get hemisphere from long/lat coordinates</h2><span id='topic+parse_hemisphere'></span>

<h3>Description</h3>

<p>BEWARE: EXPERIMENTAL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_hemisphere(lon, lat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_hemisphere_+3A_lon">lon</code></td>
<td>
<p>(character/numeric/integer) one or more longitude values</p>
</td></tr>
<tr><td><code id="parse_hemisphere_+3A_lat">lat</code></td>
<td>
<p>(character/numeric/integer) one or more latitude values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>length(lon) == length(lat)
</p>


<h3>Value</h3>

<p>character vector of quadrants, one of: NE, NW, SE, SW.
if one of the coordinate values is invalid, and one is valid, you get
a length 1 string. if both coordinate values are bad, you get
a zero length string.
</p>
<p>Warnings are thrown on invalid values
</p>


<h3>Examples</h3>

<pre><code class='language-R'># NE
parse_hemisphere("74.123E", "45N54.2356")
## Not run: 
# NW
parse_hemisphere(-120, 40.4183318)
# SW
parse_hemisphere(-120, -40.4183318)
# SE
parse_hemisphere(120, -40.4183318)

# bad inputs, get one of the two strings
parse_hemisphere(-181, -40.4183318)
parse_hemisphere(-120, -192.4183318)

# many inputs
library(randgeo)
pts &lt;- rg_position(count = 1000)
lons &lt;- as.character(vapply(pts, "[[", 1, 1))
lats &lt;- as.character(vapply(pts, "[[", 1, 2))
parse_hemisphere(lons, lats)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_lat'>Parse latitude values</h2><span id='topic+parse_lat'></span>

<h3>Description</h3>

<p>Parse latitude values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_lat(lat, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_lat_+3A_lat">lat</code></td>
<td>
<p>(numeric/integer/character) one or more latitude values</p>
</td></tr>
<tr><td><code id="parse_lat_+3A_format">format</code></td>
<td>
<p>(character) format, default often works</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Errors</h3>

<p>Throws warnings on parsing errors, and returns <code>NaN</code> in each case
</p>
<p>Types of errors:
</p>

<ul>
<li><p> invalid argument: e.g., letters passed instead of numbers,
see <a href="https://en.cppreference.com/w/cpp/error/invalid_argument">https://en.cppreference.com/w/cpp/error/invalid_argument</a>
</p>
</li>
<li><p> out of range: numbers of out acceptable range, see
<a href="https://en.cppreference.com/w/cpp/error/out_of_range">https://en.cppreference.com/w/cpp/error/out_of_range</a>
</p>
</li>
<li><p> out of latitude range: not within -90/90 range
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>parse_lat("")
## Not run: 
parse_lat("-91")
parse_lat("95")
parse_lat("asdfaf")

parse_lat("45")
parse_lat("-45")
parse_lat("-45.2323")

# out of range with std::stod?
parse_lat("-45.23232e24")
parse_lat("-45.23232e2")

# numeric input
parse_lat(1:10)
parse_lat(85:94)

# different formats
parse_lat("40.4183318 N")
parse_lat("40.4183318 S")
parse_lat("40 25 5.994") # =&gt; 40.41833

parse_lat("40.4183318N")
parse_lat("N40.4183318")
parse_lat("40.4183318S")
parse_lat("S40.4183318")

parse_lat("N 39 21.440") # =&gt; 39.35733
parse_lat("S 56 1.389") # =&gt; -56.02315

parse_lat("N40°25’5.994") # =&gt; 40.41833
parse_lat("40° 25´ 5.994\" N") # =&gt; 40.41833
parse_lat("40:25:6N")
parse_lat("40:25:5.994N")
parse_lat("40d 25’ 6\" N")

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_llstr'>parse string with lat and lon together</h2><span id='topic+parse_llstr'></span>

<h3>Description</h3>

<p>parse string with lat and lon together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_llstr(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_llstr_+3A_str">str</code></td>
<td>
<p>(character) string with latitude and longitude, one or more in a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with parsed latitude and longitude in decimal degrees.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_llstr("N 04.1683, E 101.5823")
parse_llstr("N04.82344, E101.61320")
parse_llstr("N 04.25164, E 101.70695")
parse_llstr("N05.03062, E101.75172")
parse_llstr("N05.03062,E101.75172")
parse_llstr("N4.9196, E101.345")
parse_llstr("N4.9196, E101.346")
parse_llstr("N4.9196, E101.347")
# no comma
parse_llstr("N4.9196 E101.347")
# no space
parse_llstr("N4.9196E101.347")

# DMS
parse_llstr("N4 51'36\", E101 34'7\"")
parse_llstr(c("4 51'36\"S, 101 34'7\"W", "N4 51'36\", E101 34'7\""))
</code></pre>

<hr>
<h2 id='parse_lon'>Parse longitude values</h2><span id='topic+parse_lon'></span>

<h3>Description</h3>

<p>Parse longitude values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_lon(lon, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_lon_+3A_lon">lon</code></td>
<td>
<p>(numeric/integer/character) one or more longitude values</p>
</td></tr>
<tr><td><code id="parse_lon_+3A_format">format</code></td>
<td>
<p>(character) format, default often works</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Errors</h3>

<p>Throws warnings on parsing errors, and returns <code>NaN</code> in each case
</p>
<p>Types of errors:
</p>

<ul>
<li><p> invalid argument: e.g., letters passed instead of numbers,
see <a href="https://en.cppreference.com/w/cpp/error/invalid_argument">https://en.cppreference.com/w/cpp/error/invalid_argument</a>
</p>
</li>
<li><p> out of range: numbers of out acceptable range, see
<a href="https://en.cppreference.com/w/cpp/error/out_of_range">https://en.cppreference.com/w/cpp/error/out_of_range</a>
</p>
</li>
<li><p> out of longitude range: not within -180/360 range
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>parse_lon("")
## Not run: 
parse_lon("-181")
parse_lon("-361")
parse_lon("95")
parse_lon("asdfaf")

parse_lon("45")
parse_lon("-45")
parse_lon("-45.2323")
parse_lon("334")

# out of range with std::stod?
parse_lon("-45.23232e24")
parse_lon("-45.23232e2")
parse_lon("-45.23232")

# numeric input
parse_lon(1:10)
parse_lon(85:94)

# different formats
parse_lon("40.4183318 E")
parse_lon("40.4183318 W")
parse_lon("40 25 5.994") # =&gt; 40.41833

parse_lon("40.4183318W")
parse_lon("W40.4183318")
parse_lon("E40.4183318")
parse_lon("40.4183318E")

parse_lon("E 39 21.440") # =&gt; 39.35733
parse_lon("W 56 1.389") # =&gt; -56.02315

parse_lon("E40°25’5.994") # =&gt; 40.41833
parse_lon("40° 25´ 5.994\" E") # =&gt; 40.41833
parse_lon("40:25:6E")
parse_lon("40:25:5.994E")
parse_lon("40d 25’ 6\" E")

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_lon_lat'>parse longitude and latitude</h2><span id='topic+parse_lon_lat'></span>

<h3>Description</h3>

<p>parse longitude and latitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_lon_lat(lon, lat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_lon_lat_+3A_lon">lon</code></td>
<td>
<p>(character/numeric/integer) one or more longitude values</p>
</td></tr>
<tr><td><code id="parse_lon_lat_+3A_lat">lat</code></td>
<td>
<p>(character/numeric/integer) one or more latitude values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>length(lon) == length(lat)
</p>


<h3>Value</h3>

<p>data.frame, with columns lon, lat. on an invalid values, an <code>NA</code>
is returned. In addition, warnings are thrown on invalid values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_lon_lat(-120.43, 49.12)
## Not run: 
parse_lon_lat(-120.43, 93)
parse_lon_lat(-190, 49.12)
parse_lon_lat(240, 49.12)
parse_lon_lat(-190, 92)
# many
lons &lt;- c("45W54.2356", "181", 45, 45.234234, "-45.98739874")
lats &lt;- c("40.123°", "40.123N74.123W", "191.89", 12, "N45 04.25764")
parse_lon_lat(lons, lats)

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_parts'>parse coordinates into degrees, minutes and seconds</h2><span id='topic+parse_parts'></span><span id='topic+parse_parts_lon'></span><span id='topic+parse_parts_lat'></span>

<h3>Description</h3>

<p>parse coordinates into degrees, minutes and seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_parts_lon(str)

parse_parts_lat(str)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_parts_+3A_str">str</code></td>
<td>
<p>(character) string including longitude or latitude</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with columns for:
</p>

<ul>
<li><p> deg (integer)
</p>
</li>
<li><p> min (integer)
</p>
</li>
<li><p> sec (numeric)
</p>
</li></ul>

<p>NA/NaN given upon error
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parse_parts_lon("140.4183318")
## Not run: 
parse_parts_lon("174.6411133")
parse_parts_lon("-45.98739874")
parse_parts_lon("40.123W")

parse_parts_lat("45N54.2356")
parse_parts_lat("40.4183318")
parse_parts_lat("-74.6411133")
parse_parts_lat("-45.98739874")
parse_parts_lat("40.123N")
parse_parts_lat("N40°25’5.994")

# not working, needs format input
parse_parts_lat("N455698735")

# multiple
x &lt;- c("40.123°", "40.123N74.123W", "191.89", 12, "N45 04.25764")
parse_parts_lat(x)
system.time(parse_parts_lat(rep(x, 10^2)))

## End(Not run)

</code></pre>

<hr>
<h2 id='parzer-package'>parzer</h2><span id='topic+parzer-package'></span><span id='topic+parzer'></span>

<h3>Description</h3>

<p>parse geographic coordinates
</p>


<h3>Author(s)</h3>

<p>Scott Chamberlain
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
