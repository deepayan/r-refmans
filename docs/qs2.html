<!DOCTYPE html><html lang="en"><head><title>Help for package qs2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {qs2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#base85_decode'><p>Z85 Decoding</p></a></li>
<li><a href='#base85_encode'><p>Z85 Encoding</p></a></li>
<li><a href='#base91_decode'><p>basE91 Decoding</p></a></li>
<li><a href='#base91_encode'><p>basE91 Encoding</p></a></li>
<li><a href='#blosc_shuffle_raw'><p>Shuffle a raw vector</p></a></li>
<li><a href='#blosc_unshuffle_raw'><p>Un-shuffle a raw vector</p></a></li>
<li><a href='#catquo'><p>catquo</p></a></li>
<li><a href='#decode_source'><p>Decode a compressed string</p></a></li>
<li><a href='#encode_source'><p>Encode and compress a file or string</p></a></li>
<li><a href='#qd_deserialize'><p>qd_deserialize</p></a></li>
<li><a href='#qd_read'><p>qd_read</p></a></li>
<li><a href='#qd_save'><p>qd_save</p></a></li>
<li><a href='#qd_serialize'><p>qd_serialize</p></a></li>
<li><a href='#qopt'><p>qs2 Option Getter/Setter</p></a></li>
<li><a href='#qs_deserialize'><p>qs_deserialize</p></a></li>
<li><a href='#qs_read'><p>qs_read</p></a></li>
<li><a href='#qs_readm'><p>qs_readm</p></a></li>
<li><a href='#qs_save'><p>qs_save</p></a></li>
<li><a href='#qs_savem'><p>qs_savem</p></a></li>
<li><a href='#qs_serialize'><p>qs_serialize</p></a></li>
<li><a href='#qs_to_rds'><p>qs2 to RDS format</p></a></li>
<li><a href='#qx_dump'><p>qx_dump</p></a></li>
<li><a href='#rds_to_qs'><p>RDS to qs2 format</p></a></li>
<li><a href='#starnames'><p>Official list of IAU Star Names</p></a></li>
<li><a href='#xxhash_raw'><p>XXH3_64 hash</p></a></li>
<li><a href='#zstd_compress_bound'><p>Zstd compress bound</p></a></li>
<li><a href='#zstd_compress_raw'><p>Zstd compression</p></a></li>
<li><a href='#zstd_decompress_raw'><p>Zstd decompression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Serialization of R Objects</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-3-7</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Travers Ching &lt;traversc@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamlines and accelerates the process of saving and loading R objects, improving speed and compression compared to other methods. The package provides two compression formats: the 'qs2' format, which uses R serialization via the C API while optimizing compression and disk I/O, and the 'qdata' format, featuring custom serialization for slightly faster performance and better compression. Additionally, the 'qs2' format can be directly converted to the standard 'RDS' format, ensuring long-term compatibility with future versions of R.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, stringfish (&ge; 0.15.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, stringfish, RcppParallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, dplyr, data.table, stringi</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package includes code from the 'zstd' library owned by
Facebook, Inc. and created by Yann Collet; and code derived
from the 'Blosc' library created and owned by Francesc Alted.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/qsbase/qs2">https://github.com/qsbase/qs2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/qsbase/qs2/issues">https://github.com/qsbase/qs2/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 19:13:22 UTC; tching</td>
</tr>
<tr>
<td>Author:</td>
<td>Travers Ching [aut, cre, cph],
  Yann Collet [ctb, cph] (Yann Collet is the author of the bundled zstd),
  Facebook, Inc. [cph] (Facebook is the copyright holder of the bundled
    zstd code),
  Reichardt Tino [ctb, cph] (Contributor/copyright holder of zstd bundled
    code),
  Skibinski Przemyslaw [ctb, cph] (Contributor/copyright holder of zstd
    bundled code),
  Mori Yuta [ctb, cph] (Contributor/copyright holder of zstd bundled
    code),
  Francesc Alted [ctb, cph] (Shuffling routines derived from Blosc
    library)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='base85_decode'>Z85 Decoding</h2><span id='topic+base85_decode'></span>

<h3>Description</h3>

<p>Decodes a Z85 encoded string back to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base85_decode(encoded_string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base85_decode_+3A_encoded_string">encoded_string</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original raw vector.
</p>

<hr>
<h2 id='base85_encode'>Z85 Encoding</h2><span id='topic+base85_encode'></span>

<h3>Description</h3>

<p>Encodes binary data (a raw vector) as ASCII text using <a href="https://rfc.zeromq.org/spec/32/">Z85 encoding format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base85_encode(rawdata)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base85_encode_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Z85 is a binary to ASCII encoding format created by Pieter Hintjens in 2010 and is part of the ZeroMQ RFC.
The encoding has a dictionary using 85 out of 94 printable ASCII characters.
There are other base 85 encoding schemes, including Ascii85, which is popularized and used by Adobe.
Z85 is distinguished by its choice of dictionary, which is suitable for easier inclusion into source code for many programming languages.
The dictionary excludes all quote marks and other control characters, and requires no special treatment in R and most other languages.
Note: although the official specification restricts input length to multiples of four bytes, the implementation here works with any input length.
The overhead (extra bytes used relative to binary) is 25%. In comparison, base 64 encoding has an overhead of 33.33%.
</p>


<h3>Value</h3>

<p>A string representation of the raw vector.
</p>


<h3>References</h3>

<p>https://rfc.zeromq.org/spec/32/
</p>

<hr>
<h2 id='base91_decode'>basE91 Decoding</h2><span id='topic+base91_decode'></span>

<h3>Description</h3>

<p>Decodes a basE91 encoded string back to binary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base91_decode(encoded_string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base91_decode_+3A_encoded_string">encoded_string</code></td>
<td>
<p>A string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original raw vector.
</p>

<hr>
<h2 id='base91_encode'>basE91 Encoding</h2><span id='topic+base91_encode'></span>

<h3>Description</h3>

<p>Encodes binary data (a raw vector) as ASCII text using <a href="https://base91.sourceforge.net/">basE91 encoding format</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base91_encode(rawdata, quote_character = "\"")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="base91_encode_+3A_rawdata">rawdata</code></td>
<td>
<p>A raw vector.</p>
</td></tr>
<tr><td><code id="base91_encode_+3A_quote_character">quote_character</code></td>
<td>
<p>The character to use in the encoding, replacing the double quote character. Must be either a single quote (<code>"'"</code>), a double quote
(<code style="white-space: pre;">&#8288;"\""&#8288;</code>) or a dash (<code>"-"</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>basE91 (capital E for stylization) is a binary to ASCII encoding format created by Joachim Henke in 2005.
The overhead (extra bytes used relative to binary) is 22.97% on average. In comparison, base 64 encoding has an overhead of 33.33%.
The original encoding uses a dictionary of 91 out of 94 printable ASCII characters excluding <code>-</code> (dash), <code style="white-space: pre;">&#8288;\&#8288;</code> (backslash) and <code style="white-space: pre;">&#8288;'&#8288;</code> (single quote).
The original encoding does include double quote characters, which are less than ideal for strings in R. Therefore,
you can use the <code>quote_character</code> parameter to substitute dash or single quote.
</p>


<h3>Value</h3>

<p>A string representation of the raw vector.
</p>


<h3>References</h3>

<p>https://base91.sourceforge.net/
</p>

<hr>
<h2 id='blosc_shuffle_raw'>Shuffle a raw vector</h2><span id='topic+blosc_shuffle_raw'></span>

<h3>Description</h3>

<p>Shuffles a raw vector using BLOSC shuffle routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blosc_shuffle_raw(data, bytesofsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blosc_shuffle_raw_+3A_data">data</code></td>
<td>
<p>A raw vector to be shuffled.</p>
</td></tr>
<tr><td><code id="blosc_shuffle_raw_+3A_bytesofsize">bytesofsize</code></td>
<td>
<p>Either <code>4</code> or <code>8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The shuffled vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- serialize(1L:1000L, NULL)
xshuf &lt;- blosc_shuffle_raw(x, 4)
xunshuf &lt;- blosc_unshuffle_raw(xshuf, 4)
</code></pre>

<hr>
<h2 id='blosc_unshuffle_raw'>Un-shuffle a raw vector</h2><span id='topic+blosc_unshuffle_raw'></span>

<h3>Description</h3>

<p>Un-shuffles a raw vector using BLOSC un-shuffle routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blosc_unshuffle_raw(data, bytesofsize)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blosc_unshuffle_raw_+3A_data">data</code></td>
<td>
<p>A raw vector to be unshuffled.</p>
</td></tr>
<tr><td><code id="blosc_unshuffle_raw_+3A_bytesofsize">bytesofsize</code></td>
<td>
<p>Either <code>4</code> or <code>8</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The unshuffled vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- serialize(1L:1000L, NULL)
xshuf &lt;- blosc_shuffle_raw(x, 4)
xunshuf &lt;- blosc_unshuffle_raw(xshuf, 4)
</code></pre>

<hr>
<h2 id='catquo'>catquo</h2><span id='topic+catquo'></span>

<h3>Description</h3>

<p>Prints a string with single quotes on a new line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catquo(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catquo_+3A_...">...</code></td>
<td>
<p>Arguments passed on to <code><a href="base.html#topic+cat">cat()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='decode_source'>Decode a compressed string</h2><span id='topic+decode_source'></span>

<h3>Description</h3>

<p>A helper function for encoding and compressing a file or string to ASCII using <code><a href="#topic+base91_encode">base91_encode()</a></code> and <code><a href="#topic+qs_serialize">qs_serialize()</a></code> with the highest compression level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decode_source(string)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decode_source_+3A_string">string</code></td>
<td>
<p>A string to decode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original (decoded) object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+encode_source">encode_source()</a></code> for more details.
</p>

<hr>
<h2 id='encode_source'>Encode and compress a file or string</h2><span id='topic+encode_source'></span>

<h3>Description</h3>

<p>A helper function for encoding and compressing a file or string to ASCII using <code><a href="#topic+base91_encode">base91_encode()</a></code> and <code><a href="#topic+qs_serialize">qs_serialize()</a></code> with the highest compression level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encode_source(x = NULL, file = NULL, width = 120)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encode_source_+3A_x">x</code></td>
<td>
<p>The object to encode (if <code>file</code> is not NULL)</p>
</td></tr>
<tr><td><code id="encode_source_+3A_file">file</code></td>
<td>
<p>The file to encode (if <code>x</code> is not NULL)</p>
</td></tr>
<tr><td><code id="encode_source_+3A_width">width</code></td>
<td>
<p>The output will be broken up into individual strings, with <code>width</code> being the longest allowable string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+encode_source">encode_source()</a></code> and <code><a href="#topic+decode_source">decode_source()</a></code> functions are useful for storing small amounts of data or text inline to a .R or .Rmd file.
</p>


<h3>Value</h3>

<p>A character vector in base91 representing the compressed original file or object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1); data &lt;- sample(500)
result &lt;- encode_source(data)
# Note: the result string is not guaranteed to be consistent between qs or zstd versions
#       but will always properly decode regardless
print(result)
result &lt;- decode_source(result) # [1]  1  2  3  4  5  6  7  8  9 10
</code></pre>

<hr>
<h2 id='qd_deserialize'>qd_deserialize</h2><span id='topic+qd_deserialize'></span>

<h3>Description</h3>

<p>Deserializes a raw vector to an object using the <code>qdata</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd_deserialize(input,
         use_alt_rep = qopt("use_alt_rep"),
         validate_checksum = qopt("validate_checksum"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qd_deserialize_+3A_input">input</code></td>
<td>
<p>The raw vector to deserialize.</p>
</td></tr>
<tr><td><code id="qd_deserialize_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qd_deserialize_+3A_validate_checksum">validate_checksum</code></td>
<td>
<p>Whether to validate the stored checksum in the file (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qd_deserialize_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when reading data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deserialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
xserialized &lt;- qd_serialize(x)
x2 &lt;- qd_deserialize(xserialized)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qd_read'>qd_read</h2><span id='topic+qd_read'></span>

<h3>Description</h3>

<p>Reads an object that was saved to disk in the <code>qdata</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd_read(file,
         use_alt_rep = qopt("use_alt_rep"),
         validate_checksum = qopt("validate_checksum"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qd_read_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qd_read_+3A_use_alt_rep">use_alt_rep</code></td>
<td>
<p>Use ALTREP when reading in string data (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qd_read_+3A_validate_checksum">validate_checksum</code></td>
<td>
<p>Whether to validate the stored checksum in the file (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qd_read_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when reading data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object stored in <code>file</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qd_save(x, myfile)
x2 &lt;- qd_read(myfile)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qd_save'>qd_save</h2><span id='topic+qd_save'></span>

<h3>Description</h3>

<p>Saves an object to disk using the <code>qdata</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd_save(object, file,
         compress_level = qopt("compress_level"),
         shuffle = qopt("shuffle"),
         warn_unsupported_types = qopt("warn_unsupported_types"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qd_save_+3A_object">object</code></td>
<td>
<p>The object to save.</p>
</td></tr>
<tr><td><code id="qd_save_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qd_save_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used (the initial value is 3L).
</p>
<p>The maximum and minimum possible values depend on the version of the ZSTD library used.
As of ZSTD 1.5.6 the maximum compression level is 22, and the minimum is -131072.
Usually, values in the low positive range offer very good performance in terms
of speed and compression.</p>
</td></tr>
<tr><td><code id="qd_save_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to allow byte shuffling when compressing data (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qd_save_+3A_warn_unsupported_types">warn_unsupported_types</code></td>
<td>
<p>Whether to warn when saving an object with an unsupported type (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qd_save_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when compressing data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned. The file is written to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qd_save(x, myfile)
x2 &lt;- qd_read(myfile)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qd_serialize'>qd_serialize</h2><span id='topic+qd_serialize'></span>

<h3>Description</h3>

<p>Serializes an object to a raw vector using the <code>qdata</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd_serialize(object,
         compress_level = qopt("compress_level"),
         shuffle = qopt("shuffle"),
         warn_unsupported_types = qopt("warn_unsupported_types"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qd_serialize_+3A_object">object</code></td>
<td>
<p>The object to save.</p>
</td></tr>
<tr><td><code id="qd_serialize_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used (the initial value is 3L).
</p>
<p>The maximum and minimum possible values depend on the version of the ZSTD library used.
As of ZSTD 1.5.6 the maximum compression level is 22, and the minimum is -131072.
Usually, values in the low positive range offer very good performance in terms
of speed and compression.</p>
</td></tr>
<tr><td><code id="qd_serialize_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to allow byte shuffling when compressing data (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qd_serialize_+3A_warn_unsupported_types">warn_unsupported_types</code></td>
<td>
<p>Whether to warn when saving an object with an unsupported type (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qd_serialize_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when compressing data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The serialized object as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
xserialized &lt;- qd_serialize(x)
x2 &lt;- qd_deserialize(xserialized)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qopt'>qs2 Option Getter/Setter</h2><span id='topic+qopt'></span>

<h3>Description</h3>

<p>Get or set a global qs2 option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qopt(parameter, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qopt_+3A_parameter">parameter</code></td>
<td>
<p>A character string specifying the option to access. Must be one of
&quot;compress_level&quot;, &quot;shuffle&quot;, &quot;nthreads&quot;, &quot;validate_checksum&quot;, &quot;warn_unsupported_types&quot;,
or &quot;use_alt_rep&quot;.</p>
</td></tr>
<tr><td><code id="qopt_+3A_value">value</code></td>
<td>
<p>If <code>NULL</code> (the default), the current value is retrieved.
Otherwise, the global option is set to <code>value</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function provides an interface to retrieve or update internal qs2 options
such as compression level, shuffle flag, number of threads, checksum validation,
warning for unsupported types, and ALTREP usage. It directly calls the underlying
C-level functions.
</p>
<p>The default settings are:
</p>

<ul>
<li> <p><code>compress_level</code>: 3L
</p>
</li>
<li> <p><code>shuffle</code>: TRUE
</p>
</li>
<li> <p><code>nthreads</code>: 1L
</p>
</li>
<li> <p><code>validate_checksum</code>: FALSE
</p>
</li>
<li> <p><code>warn_unsupported_types</code>: TRUE (used only in <code>qd_save</code>)
</p>
</li>
<li> <p><code>use_alt_rep</code>: FALSE (used only in <code>qd_read</code>)
</p>
</li></ul>

<p>When <code>value</code> is <code>NULL</code>, the current value of the specified option is returned.
Otherwise, the option is set to <code>value</code> and the new value is returned invisibly.
</p>


<h3>Value</h3>

<p>If <code>value</code> is <code>NULL</code>, returns the current value of the specified option.
Otherwise, sets the option and returns the new value invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Get the current compression level:
qopt("compress_level")

# Set the compression level to 5:
qopt("compress_level", value = 5)

# Get the current shuffle setting:
qopt("shuffle")

# Get the current setting for warn_unsupported_types (used in qd_save):
qopt("warn_unsupported_types")

# Get the current setting for use_alt_rep (used in qd_read):
qopt("use_alt_rep")

</code></pre>

<hr>
<h2 id='qs_deserialize'>qs_deserialize</h2><span id='topic+qs_deserialize'></span>

<h3>Description</h3>

<p>Deserializes a raw vector to an object using the <code>qs2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_deserialize(input,
         validate_checksum = qopt("validate_checksum"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_deserialize_+3A_input">input</code></td>
<td>
<p>The raw vector to deserialize.</p>
</td></tr>
<tr><td><code id="qs_deserialize_+3A_validate_checksum">validate_checksum</code></td>
<td>
<p>Whether to validate the stored checksum in the file (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qs_deserialize_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when reading data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The deserialized object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
xserialized &lt;- qs_serialize(x)
x2 &lt;- qs_deserialize(xserialized)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qs_read'>qs_read</h2><span id='topic+qs_read'></span>

<h3>Description</h3>

<p>Reads an object that was saved to disk in the <code>qs2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_read(file,
         validate_checksum = qopt("validate_checksum"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_read_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qs_read_+3A_validate_checksum">validate_checksum</code></td>
<td>
<p>Whether to validate the stored checksum in the file (the initial value is FALSE).</p>
</td></tr>
<tr><td><code id="qs_read_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when reading data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object stored in <code>file</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qs_save(x, myfile)
x2 &lt;- qs_read(myfile)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qs_readm'>qs_readm</h2><span id='topic+qs_readm'></span>

<h3>Description</h3>

<p>Reads an object in a file serialized to disk using <code><a href="#topic+qs_savem">qs_savem()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_readm(file, env = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_readm_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qs_readm_+3A_env">env</code></td>
<td>
<p>The environment where the data should be loaded. Default is the calling environment (<code><a href="base.html#topic+parent.frame">parent.frame()</a></code>).</p>
</td></tr>
<tr><td><code id="qs_readm_+3A_...">...</code></td>
<td>
<p>additional arguments will be passed to <a href="#topic+qs_read">qs_read</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends <a href="#topic+qs_read">qs_read</a> to replicate the functionality of <code><a href="base.html#topic+load">base::load()</a></code> to load multiple saved objects into your workspace.
</p>


<h3>Value</h3>

<p>Nothing is explicitly returned, but the function will load the saved objects into the workspace.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
x2 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qs_savem(x1, x2, file=myfile)
rm(x1, x2)
qs_readm(myfile)
exists('x1') &amp;&amp; exists('x2') # returns true
</code></pre>

<hr>
<h2 id='qs_save'>qs_save</h2><span id='topic+qs_save'></span>

<h3>Description</h3>

<p>Saves an object to disk using the <code>qs2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_save(object, file,
         compress_level = qopt("compress_level"),
         shuffle = qopt("shuffle"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_save_+3A_object">object</code></td>
<td>
<p>The object to save.</p>
</td></tr>
<tr><td><code id="qs_save_+3A_file">file</code></td>
<td>
<p>The file name/path.</p>
</td></tr>
<tr><td><code id="qs_save_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used (the initial value is 3L).
</p>
<p>The maximum and minimum possible values depend on the version of the ZSTD library used.
As of ZSTD 1.5.6 the maximum compression level is 22, and the minimum is -131072.
Usually, values in the low positive range offer very good performance in terms
of speed and compression.</p>
</td></tr>
<tr><td><code id="qs_save_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to allow byte shuffling when compressing data (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qs_save_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when compressing data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned. The file is written to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qs_save(x, myfile)
x2 &lt;- qs_read(myfile)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qs_savem'>qs_savem</h2><span id='topic+qs_savem'></span>

<h3>Description</h3>

<p>Saves (serializes) multiple objects to disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_savem(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_savem_+3A_...">...</code></td>
<td>
<p>Objects to serialize. Named arguments will be passed to <code><a href="#topic+qs_save">qs_save()</a></code> during saving. Un-named arguments will be saved. A named <code>file</code> argument is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function extends <code><a href="#topic+qs_save">qs_save()</a></code> to replicate the functionality of <code><a href="base.html#topic+save">base::save()</a></code> to save multiple objects. Read them back with <code><a href="#topic+qs_readm">qs_readm()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
x2 &lt;- data.frame(int = sample(1e3, replace=TRUE),
                 num = rnorm(1e3),
                 char = sample(starnames$`IAU Name`, 1e3, replace=TRUE),
                 stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qs_savem(x1, x2, file=myfile)
rm(x1, x2)
qs_readm(myfile)
exists('x1') &amp;&amp; exists('x2') # returns true
</code></pre>

<hr>
<h2 id='qs_serialize'>qs_serialize</h2><span id='topic+qs_serialize'></span>

<h3>Description</h3>

<p>Serializes an object to a raw vector using the <code>qs2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_serialize(object,
         compress_level = qopt("compress_level"),
         shuffle = qopt("shuffle"),
         nthreads = qopt("nthreads"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_serialize_+3A_object">object</code></td>
<td>
<p>The object to save.</p>
</td></tr>
<tr><td><code id="qs_serialize_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used (the initial value is 3L).
</p>
<p>The maximum and minimum possible values depend on the version of the ZSTD library used.
As of ZSTD 1.5.6 the maximum compression level is 22, and the minimum is -131072.
Usually, values in the low positive range offer very good performance in terms
of speed and compression.</p>
</td></tr>
<tr><td><code id="qs_serialize_+3A_shuffle">shuffle</code></td>
<td>
<p>Whether to allow byte shuffling when compressing data (the initial value is TRUE).</p>
</td></tr>
<tr><td><code id="qs_serialize_+3A_nthreads">nthreads</code></td>
<td>
<p>The number of threads to use when compressing data (the initial value is 1L).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The serialized object as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
xserialized &lt;- qs_serialize(x)
x2 &lt;- qs_deserialize(xserialized)
identical(x, x2) # returns TRUE
</code></pre>

<hr>
<h2 id='qs_to_rds'>qs2 to RDS format</h2><span id='topic+qs_to_rds'></span>

<h3>Description</h3>

<p>Converts a file saved in the <code>qs2</code> format to the <code>RDS</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qs_to_rds(input_file, output_file, compress_level = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qs_to_rds_+3A_input_file">input_file</code></td>
<td>
<p>The <code>qs2</code> file to convert.</p>
</td></tr>
<tr><td><code id="qs_to_rds_+3A_output_file">output_file</code></td>
<td>
<p>The <code>RDS</code> file to write.</p>
</td></tr>
<tr><td><code id="qs_to_rds_+3A_compress_level">compress_level</code></td>
<td>
<p>The gzip compression level to use when writing the RDS file (a value between 0 and 9).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned. The converted file is written to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qs_tmp &lt;- tempfile(fileext = ".qs2")
rds_tmp &lt;- tempfile(fileext = ".RDS")

x &lt;- runif(1e6)
qs_save(x, qs_tmp)
qs_to_rds(input_file = qs_tmp, output_file = rds_tmp)
x2 &lt;- readRDS(rds_tmp)
stopifnot(identical(x, x2))

</code></pre>

<hr>
<h2 id='qx_dump'>qx_dump</h2><span id='topic+qx_dump'></span>

<h3>Description</h3>

<p>Exports the uncompressed binary serialization to a list of raw vectors for both <code>qs2</code> and <code>qdata</code> formats.
For testing and exploratory purposes mainly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qx_dump(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qx_dump_+3A_file">file</code></td>
<td>
<p>A file name/path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing uncompressed binary serialization and metadata.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(int = sample(1e3, replace=TRUE),
         num = rnorm(1e3),
         char = sample(state.name, 1e3, replace=TRUE),
         stringsAsFactors = FALSE)
myfile &lt;- tempfile()
qs_save(x, myfile)
binary_data &lt;- qx_dump(myfile)
</code></pre>

<hr>
<h2 id='rds_to_qs'>RDS to qs2 format</h2><span id='topic+rds_to_qs'></span>

<h3>Description</h3>

<p>Converts a file saved in the <code>RDS</code> format to the <code>qs2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rds_to_qs(input_file, output_file, compress_level = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rds_to_qs_+3A_input_file">input_file</code></td>
<td>
<p>The <code>RDS</code> file to convert.</p>
</td></tr>
<tr><td><code id="rds_to_qs_+3A_output_file">output_file</code></td>
<td>
<p>The <code>qs2</code> file to write.</p>
</td></tr>
<tr><td><code id="rds_to_qs_+3A_compress_level">compress_level</code></td>
<td>
<p>The zstd compression level to use when writing the <code>qs2</code> file. See the <code>qs_save</code> help file for more details on this parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>shuffle</code> parameters is currently not supported when converting from <code>RDS</code> to <code>qs2</code>.
When reading the resulting <code>qs2</code> file, <code>validate_checksum</code> must be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>No value is returned. The converted file is written to disk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qs_tmp &lt;- tempfile(fileext = ".qs2")
rds_tmp &lt;- tempfile(fileext = ".RDS")

x &lt;- runif(1e6)
saveRDS(x, rds_tmp)
rds_to_qs(input_file = rds_tmp, output_file = qs_tmp)
x2 &lt;- qs_read(qs_tmp, validate_checksum = FALSE)
stopifnot(identical(x, x2))
</code></pre>

<hr>
<h2 id='starnames'>Official list of IAU Star Names</h2><span id='topic+starnames'></span>

<h3>Description</h3>

<p>Data from the International Astronomical Union.
An official list of the 336 internationally recognized named stars,
updated as of June 1, 2018.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(starnames)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with official IAU star names and several properties, such as coordinates.
</p>


<h3>Source</h3>

<p><a href="https://www.iau.org/public/themes/naming_stars/">Naming Stars | International Astronomical Union.</a>
</p>


<h3>References</h3>

<p>E Mamajek et. al. (2018),
<em>WG Triennial Report (2015-2018) - Star Names</em>, Reports on Astronomy, 22 Mar 2018.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(starnames)
</code></pre>

<hr>
<h2 id='xxhash_raw'>XXH3_64 hash</h2><span id='topic+xxhash_raw'></span>

<h3>Description</h3>

<p>Calculates a 64-bit XXH3 hash.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xxhash_raw(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="xxhash_raw_+3A_data">data</code></td>
<td>
<p>The data to hash.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The 64-bit hash.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.raw(c(1,2,3))
xxhash_raw(x)
</code></pre>

<hr>
<h2 id='zstd_compress_bound'>Zstd compress bound</h2><span id='topic+zstd_compress_bound'></span>

<h3>Description</h3>

<p>Exports the compress bound function from the zstd library. Returns the maximum potential compressed size of an object of length <code>size</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_compress_bound(size)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zstd_compress_bound_+3A_size">size</code></td>
<td>
<p>An integer size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum compressed size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>zstd_compress_bound(100000)
zstd_compress_bound(1e9)
</code></pre>

<hr>
<h2 id='zstd_compress_raw'>Zstd compression</h2><span id='topic+zstd_compress_raw'></span>

<h3>Description</h3>

<p>Compresses to a raw vector using the zstd algorithm. Exports the main zstd compression function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_compress_raw(data, compress_level = qopt("compress_level"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zstd_compress_raw_+3A_data">data</code></td>
<td>
<p>Raw vector to be compressed.</p>
</td></tr>
<tr><td><code id="zstd_compress_raw_+3A_compress_level">compress_level</code></td>
<td>
<p>The compression level used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The compressed data as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- zstd_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(zstd_decompress_raw(xcompressed))
</code></pre>

<hr>
<h2 id='zstd_decompress_raw'>Zstd decompression</h2><span id='topic+zstd_decompress_raw'></span>

<h3>Description</h3>

<p>Decompresses a zstd compressed raw vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zstd_decompress_raw(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zstd_decompress_raw_+3A_data">data</code></td>
<td>
<p>A raw vector to be decompressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The decompressed data as a raw vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:1e6
xserialized &lt;- serialize(x, connection=NULL)
xcompressed &lt;- zstd_compress_raw(xserialized, compress_level = 1)
xrecovered &lt;- unserialize(zstd_decompress_raw(xcompressed))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
