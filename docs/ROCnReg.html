<!DOCTYPE html><html><head><title>Help for package ROCnReg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ROCnReg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ROCnReg-package'>
<p>ROC Curve Inference with and without Covariates</p></a></li>
<li><a href='#AROC.bnp'>
<p>Nonparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#AROC.kernel'>
<p>Nonparametric kernel-based estimation of the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#AROC.sp'>
<p>Semiparametric frequentist inference for the covariate-adjusted ROC curve (AROC).</p></a></li>
<li><a href='#compute.threshold.AROC'>
<p>AROC based threshold values.</p></a></li>
<li><a href='#compute.threshold.cROC'>
<p>Covariate-specific ROC based threshold values.</p></a></li>
<li><a href='#compute.threshold.pooledROC'>
<p>Pooled ROC based threshold values.</p></a></li>
<li><a href='#cROC.bnp'>
<p>Nonparametric Bayesian inference for the covariate-specific ROC curve (cROC).</p></a></li>
<li><a href='#cROC.kernel'>
<p>Nonparametric kernel-based estimation of the covariate-specific ROC curve (cROC).</p></a></li>
<li><a href='#cROC.sp'>
<p>Parametric and semiparametric frequentist inference of the covariate-specific ROC curve (cROC).</p></a></li>
<li><a href='#cROCData'>
<p>Selects an adequate set of points from a data set for obtaining predictions.</p></a></li>
<li><a href='#densitycontrol'>
<p>(Conditional) density estimates of test outcomes</p></a></li>
<li><a href='#densitycontrol.aroc'>
<p>Conditional density estimates of test outcomes in the healthy population</p></a></li>
<li><a href='#endosyn'>
<p>Simulated endocrine data.</p></a></li>
<li><a href='#mcmccontrol'>
<p>Markov chain Monte Carlo (MCMC) parameters</p></a></li>
<li><a href='#pauccontrol'>
<p>Partial area under the covariate-adjusted/covariate-specific/pooled ROC curve</p></a></li>
<li><a href='#plot.AROC'>
<p>Default AROC plotting</p></a></li>
<li><a href='#plot.cROC'>
<p>Default cROC plotting</p></a></li>
<li><a href='#plot.pooledROC'>
<p>Default pooledROC plotting</p></a></li>
<li><a href='#pooledROC.BB'>
<p>Bayesian bootstrap estimation of the pooled ROC curve.</p></a></li>
<li><a href='#pooledROC.dpm'>
<p>Nonparametric Bayesian inference of the pooled ROC curve</p></a></li>
<li><a href='#pooledROC.emp'>
<p>Empirical estimation of the pooled ROC curve.</p></a></li>
<li><a href='#pooledROC.kernel'>
<p>Kernel-based estimation of the pooled ROC curve.</p></a></li>
<li><a href='#predictive.checks'>
<p>Posterior predictive checks.</p></a></li>
<li><a href='#print.AROC'>
<p>Print method for <code>AROC</code> objects</p></a></li>
<li><a href='#print.cROC'>
<p>Print method for <code>cROC</code> objects</p></a></li>
<li><a href='#print.pooledROC'>
<p>Print method for <code>pooledROC</code> objects</p></a></li>
<li><a href='#priorcontrol.bnp'>
<p>Prior information for the <code>AROC.bnp</code> and <code>cROC.bnp</code></p></a></li>
<li><a href='#priorcontrol.dpm'>
<p>Prior information for the <code>pooledROC.dpm</code></p></a></li>
<li><a href='#psa'>
<p>Prostate specific antigen (PSA) biomarker study.</p></a></li>
<li><a href='#summary.AROC'>
<p>Summary method for <code>AROC</code> objects</p></a></li>
<li><a href='#summary.cROC'>
<p>Summary method for <code>cROC</code> objects</p></a></li>
<li><a href='#summary.pooledROC'>
<p>Summary method for <code>pooledROC</code> objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>ROC Curve Inference with and without Covariates</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-09</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, grDevices, graphics, splines, np, Matrix, moments,
nor1mix, spatstat.geom, spatstat (&ge; 2.0-0), lattice, MASS,
pbivnorm, parallel</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates the pooled (unadjusted) Receiver Operating Characteristic (ROC) curve, the covariate-adjusted ROC (AROC) curve, and the covariate-specific/conditional ROC (cROC) curve by different methods, both Bayesian and frequentist. Also, it provides functions to obtain ROC-based optimal cutpoints utilizing several criteria. Based on Erkanli, A. et al. (2006) &lt;<a href="https://doi.org/10.1002%2Fsim.2496">doi:10.1002/sim.2496</a>&gt;; Faraggi, D. (2003) &lt;<a href="https://doi.org/10.1111%2F1467-9884.00350">doi:10.1111/1467-9884.00350</a>&gt;; Gu, J. et al. (2008) &lt;<a href="https://doi.org/10.1002%2Fsim.3366">doi:10.1002/sim.3366</a>&gt;; Inacio de Carvalho, V. et al. (2013) &lt;<a href="https://doi.org/10.1214%2F13-BA825">doi:10.1214/13-BA825</a>&gt;; Inacio de Carvalho, V., and Rodriguez-Alvarez, M.X. (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1806.00473">doi:10.48550/arXiv.1806.00473</a>&gt;; Janes, H., and Pepe, M.S. (2009) &lt;<a href="https://doi.org/10.1093%2Fbiomet%2Fasp002">doi:10.1093/biomet/asp002</a>&gt;; Pepe, M.S. (1998) <a href="http://www.jstor.org/stable/2534001?seq=1">http://www.jstor.org/stable/2534001?seq=1</a>; Rodriguez-Alvarez, M.X. et al. (2011a) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2010.07.018">doi:10.1016/j.csda.2010.07.018</a>&gt;; Rodriguez-Alvarez, M.X. et al. (2011a) &lt;<a href="https://doi.org/10.1007%2Fs11222-010-9184-1">doi:10.1007/s11222-010-9184-1</a>&gt;. Please see Rodriguez-Alvarez, M.X. and Inacio, V. (20208) &lt;<a href="https://doi.org/10.48550/arXiv.2003.13111">doi:10.48550/arXiv.2003.13111</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-10 12:40:56 UTC; mrodriguez</td>
</tr>
<tr>
<td>Author:</td>
<td>Maria Xose Rodriguez-Alvarez
    <a href="https://orcid.org/0000-0002-1329-9238"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Vanda Inacio <a href="https://orcid.org/0000-0001-8084-1616"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.es&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 17:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='ROCnReg-package'>
ROC Curve Inference with and without Covariates
</h2><span id='topic+ROCnReg-package'></span><span id='topic+ROCnReg'></span>

<h3>Description</h3>

<p>Estimates the pooled (unadjusted) Receiver Operating Characteristic (ROC) curve, the covariate-adjusted ROC (AROC) curve, and the covariate-specific/conditional ROC (cROC) curve by different methods, both Bayesian and frequentist. Also, it provides functions to obtain ROC-based optimal cutpoints utilizing several criteria. Based on Erkanli, A. et al. (2006) &lt;doi:10.1002/sim.2496&gt;; Faraggi, D. (2003) &lt;doi:10.1111/1467-9884.00350&gt;; Gu, J. et al. (2008) &lt;doi:10.1002/sim.3366&gt;; Inacio de Carvalho, V. et al. (2013) &lt;doi:10.1214/13-BA825&gt;; Inacio de Carvalho, V., and Rodriguez-Alvarez, M.X. (2018) &lt;arXiv:1806.00473&gt;; Janes, H., and Pepe, M.S. (2009) &lt;doi:10.1093/biomet/asp002&gt;; Pepe, M.S. (1998) &lt;http://www.jstor.org/stable/2534001?seq=1&gt;; Rodriguez-Alvarez, M.X. et al. (2011a) &lt;doi:10.1016/j.csda.2010.07.018&gt;; Rodriguez-Alvarez, M.X. et al. (2011a) &lt;doi:10.1007/s11222-010-9184-1&gt;. Please see Rodriguez-Alvarez, M.X. and Inacio, V. (20208) &lt;arXiv:2003.13111&gt; for more details.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ROCnReg</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-03-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maria Xose Rodriguez-Alvarez and Vanda Inacio 
Maintainer: Maria Xose Rodriguez-Alvarez &lt;mxrodriguez@uvigo.es&gt;
</p>


<h3>References</h3>

<p>Erkanli, A., Sung M., Jane Costello, E., and Angold, A. (2006). Bayesian semi-parametric ROC analysis. Statistics in Medicine, <b>25</b>, 3905&ndash;3928.
</p>
<p>Faraggi, D. (2003). Adjusting receiver operating characteristic curves and related indices for covariates. <em>The Statistician</em> <b>52</b>, 179&ndash;192.
</p>
<p>Gu, J., Ghosal, S., and Roy, A. (2008). Bayesian bootstrap estimation of ROC curve. Statistics in Medicine, <b>27</b>, 5407&ndash;5420.
</p>
<p>Inacio de Carvalho, V., Jara, A., Hanson, T. E., and de Carvalho, M. (2013). Bayesian nonparametric ROC regression modeling. Bayesian Analysis, <b>8</b>, 623&ndash;646.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, <b>96</b>, 371&ndash;382.
</p>
<p>Pepe, M.S. (1998). Three approaches to regression analysis of receiver operating characteristic curves for continuous test results. <em>Biometrics</em> <b>54</b>, 124&ndash;135.
</p>
<p>Rodriguez-Alvarez, M. X. and Inacio, V., and  (2020). ROCnReg: An R Package for Receiver Operating Characteristic Curve Inference with and without Covariate Information. arXiv preprint arXiv:2003.13111.
</p>
<p>Rodriguez-Alvarez, M.X., Tahoces, P. G., Cadarso-Suarez, C., and Lado, M.J. (2011). Comparative study of ROC regression techniques&ndash;Applications for the computer-aided diagnostic system in breast cancer detection. Computational Statistics and Data Analysis, <b>55</b>, 888&ndash;902.
</p>
<p>Rodriguez-Alvarez, M.X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483&ndash;499.
</p>

<hr>
<h2 id='AROC.bnp'>
Nonparametric Bayesian inference of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.bnp'></span>

<h3>Description</h3>

<p>This function estimates the covariate-adjusted ROC curve (AROC) using the nonparametric Bayesian approach proposed by Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.bnp(formula.h, group, tag.h, data, standardise = TRUE, 
  p = seq(0, 1, l = 101), ci.level = 0.95, compute.lpml = FALSE, compute.WAIC = FALSE, 
  compute.DIC = FALSE, pauc = pauccontrol(), density = densitycontrol.aroc(),
  prior.h = priorcontrol.bnp(), mcmc = mcmccontrol(),
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.bnp_+3A_formula.h">formula.h</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the regression function associated to each component of the single-weights linear dependent Dirichlet process mixture model used to estimate the conditional distribution function of the diagnostic test outcome in the healthy population. Regarding the modelling of continuous covariates, both linear and nonlinear effects are allowed, with nonlinear effects being modelled through B-spline basis expansions (see Note).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy/nondiseased from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_data">data</code></td>
<td>
<p> A data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_standardise">standardise</code></td>
<td>
<p>A logical value. If TRUE both the test outcomes and the continuous covariates assumed to have a linear effect are standardised (i.e., the resulting variables have mean zero and standard deviation of one). The default is TRUE.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_compute.lpml">compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_compute.waic">compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_compute.dic">compute.DIC</code></td>
<td>
<p>A logical value. If TRUE, the deviance information criterion (DIC)(Celeux et al., 2006, Spiegelhalter et al., 2002) is computed.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve (pAAUC) should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_density">density</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+densitycontrol.aroc">densitycontrol.aroc</a></code>. This argument is used to indicate whether the conditional densities of the marker in the healthy population should be computed, and in case it is to be computed, at which grid of test outcomes the conditional densities should be evaluated, and at which covariate values they should be predicted.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_prior.h">prior.h</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code>. See <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code> for details.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_mcmc">mcmc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+mcmccontrol">mcmccontrol</a></code>. See <code><a href="#topic+mcmccontrol">mcmccontrol</a></code> for details.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="AROC.bnp_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(p\right) = Pr\{1 - F_{\bar{D}}(Y_D | \mathbf{X}_{D}) \leq p\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> denotes the distribution function of <code class="reqn">Y_{\bar{D}}</code> conditional on the vector of covariates <code class="reqn">\mathbf{X}_{\bar{D}}</code>. 
</p>
<p>The method implemented in this function combines a single-weights linear dependent Dirichlet process mixture model (De Iorio et al., 2009) to estimate <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{X}_{\bar{D}})</code> and the Bayesian bootstrap (Rubin, 1981) to estimate the outside probability. More precisely, and letting <code class="reqn">\{(\mathbf{x}_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code> be a random sample from the nondiseased population, our postulated model for the conditional distribution function takes the following form 
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}|\mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = \sum_{l=1}^{L}\omega_l\Phi(y_{\bar{D}i}\mid\mu_{l}(\mathbf{x}_{\bar{D}i}),\sigma_l^2),</code>
</p>

<p>where <code class="reqn">\Phi(y|\mu, \sigma^2)</code> denotes the cumulative distribution function of the normal distribution, evaluated at <code class="reqn">y</code>, with mean <code class="reqn">\mu</code> and variance <code class="reqn">\sigma^2</code>. The regression function <code class="reqn">\mu_{l}(\mathbf{x}_{\bar{D}i})</code> can incorportate both linear and nonlinear (through B-splines) effects of continuous covariates, categorical covariates (factors) as well as interactions. Interactions between categorical and (nonlinear) continuous covariates are also allowed (factor-by curve interactions). For the sake of simplicity we write <code class="reqn">\mu_{l}(\mathbf{x}_{\bar{D}i}) = \mathbf{z}_{\bar{D}i}^{T}\mathbf{\beta}_l</code> (<code class="reqn">l=1,...,L</code>), where <code class="reqn">\mathbf{z}_{\bar{D}i}</code> is the <code class="reqn">i</code>th column of the design matrix (possibly containing a basis representation of some/all continuous covariates). Here <code class="reqn">L</code> is a pre-specified upper bound on the number of mixture components. The <code class="reqn">\omega_l</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_1=v_1</code>; <code class="reqn">\omega_l=v_l\prod_{r&lt;l}(1-v_r)</code>, <code class="reqn">l=2,\ldots,L</code>; <code class="reqn">v_1,\ldots,v_{L-1}\sim</code> Beta <code class="reqn">(1,\alpha)</code>; <code class="reqn">v_L=1</code>, <code class="reqn">\alpha \sim \Gamma(a_{\alpha},b_{\alpha})</code>), <code class="reqn">\mathbf{\beta}_l\sim N_{Q}(\mathbf{m},\mathbf{S})</code>, and <code class="reqn">\sigma_l^{-2}\sim\Gamma(a,b)</code>. It is further assumed that <code class="reqn">\mathbf{m} \sim N_{Q}(\mathbf{m}_0,\mathbf{S}_0)</code> and <code class="reqn">\mathbf{S}^{-1}\sim W(\nu,(\nu\Psi)^{-1})</code>. Here <code class="reqn">\Gamma(a,b)</code> denotes a Gamma distribution with shape parameter <code class="reqn">a</code> and rate parameter <code class="reqn">b</code>, <code class="reqn">W(\nu,(\nu\Psi)^{-1})</code> denotes a Wishart distribution with <code class="reqn">\nu</code> degrees of freedom and expectation <code class="reqn">\Psi^{-1}</code>, and <code class="reqn">Q</code> denotes the dimension of the vector <code class="reqn">\mathbf{z}_{\bar{D}i}</code>. It is worth mentioning that when <code class="reqn">L=1</code>, the model for the conditional distribution of the test outcomes (in the healthy population) reduces to a normal regression model (where continuous covariates effects are modelled either parametrically or nonparametrically). For a detailed description, we refer to Inacio de Carvalho and Rodriguez-Alvarez (2018).
</p>
<p>Regarding the area under the curve, we note that
</p>
<p style="text-align: center;"><code class="reqn">AAUC = \int_{0}^{1}AROC(p)dp = 1 - E\{U_D\},</code>
</p>

<p>where <code class="reqn">U_D = 1 - F_{\bar{D}}(Y_D |\mathbf{X}_D)</code>. In our implementation, the expectation is computed using the Bayesian bootstrap (using the same weights as those used to estimate the AROC, see Inacio de Carvalho and Rodriguez-Alvarez (2018) for details). As far as the partial area under the curve is concerned, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is 
</p>
<p style="text-align: center;"><code class="reqn">pAAUC_{FPF}(u_1)=\int_0^{u_1} AROC(p)dp = u_1 - E\{U_{D,u_1}\},</code>
</p>
 
<p>where <code class="reqn">U_{D,u_1} = min\{u_1, 1 - F_{\bar{D}}(Y_D |\mathbf{X}_D)\}</code>. Again, the expectation is computed using the Bayesian bootstrap. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as 
</p>
<p style="text-align: center;"><code class="reqn">pAAUC_{TPF}(u_2)=\int_{AROC^{-1}(u_2)}^{1}AROC(p)dp-\{1-AROC^{-1}(u_2)\}\times u_2.</code>
</p>

<p>Here, the computation of the integral is done numerically. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>
<p>Finally, it is important referring that with respect to the computation of the DIC, when <code class="reqn">L=1</code>, it is computed as in Spiegelhalter et al. (2002), and when <code class="reqn">L&gt;1</code>, DIC3 as described in Celeux et al. (2006) is computed. Also, for the computation of the conditional predictive ordinates (CPO) we follow the stable version proposed by Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-adjusted ROC curve (AROC) has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A list returning the hyperparameter values.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC) (posterior mean) and <code>ci.level</code>*100% pointwise credible band.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC) (posterior mean), and <code>ci.level</code>*100% credible interval.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve (pAAUC) (posterior mean) and <code>ci.level</code>*100% credible
interval. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>If <code>compute</code> is set to <code>TRUE</code> in the argument <code>density</code>, a data frame containing the values of the covariates at which the regression function and conditional densities were computed (see below).</p>
</td></tr>
<tr><td><code>reg.fun.h</code></td>
<td>
<p>If <code>compute</code> is set to <code>TRUE</code> in the argument <code>density</code>, a data frame containing the predicted regression function (posterior mean) and <code>ci.level</code>*100% pointwise credible band.</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>If <code>compute</code> is set to <code>TRUE</code> in the argument <code>density</code>, a list with two components (only for the healthy population): <code>grid</code> (grid of test outcomes where the densities were evaluated) and <code>dens</code> (MCMC realisations of the corresponding conditional densities).</p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>If computed, a list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>If computed, widely applicable information criterion (WAIC) and associated complexity penalty (pW).</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>If computed, deviance information criterion (DIC) and associated complexity penalty (pD).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Results of the fitting process. A list with the following components: (1) <code>formula</code>: the value of the argument <code>formula.h</code> used in the call. (2) <code>mm</code>: information needed to construct the model design matrix associated with the single weights linear dependent Dirichlet process mixture model. (3) <code>beta</code>: array of dimension <code>nsave</code>x<code>L</code>x<code>Q</code> with the sampled regression coefficients. (4) <code>sd</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled variances. (4) <code>probs</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled components' weights. Here, <code>nsave</code> is the number of Gibbs sampler iterations saved, <code>L</code> is the upper bound on the number of mixture components, and <code>Q</code> is the dimension of vector <code class="reqn">\mathbf{z}_{\bar{D}}</code> (see also Details).</p>
</td></tr>
<tr><td><code>data_model</code></td>
<td>
<p>List with the data used in the fit: observed diagnostic test outcome and design matrices, separately for the healthy and diseased groups.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The input argument <code>formula.h</code> is similar to that used for the <code><a href="stats.html#topic+glm">glm</a></code> function, except that flexible specifications can be added by means of the function <code>f()</code>. For instance, specification <code class="reqn">y \sim x1 + f(x2, K = 3)</code> would assume a linear effect of <code>x1</code> (if <code>x1</code> continuous) and the effect of <code>x2</code> would be modeled using B-splines basis functions. The argument <code>K = 3</code> indicates that <code>3</code> internal knots will be used, with the quantiles of <code>x2</code> used for their location. Categorical variables (factors) can be also incorporated, as well as interaction terms. For example, to include the factor-by-curve interaction between <code>age</code> and <code>gender</code> we need to specify, e.g., <code class="reqn">y \sim gender + f(age, by = gender, K = c(3, 5))</code>. Note that, in this case, the number of knots can be different for each level of the factor. The order of the vector <code>K</code> of knots should match the levels of the factor.</p>


<h3>References</h3>

<p>Celeux, G., Forbes, F., Robert C. P., and Titerrington, D. M. (2006). Deviance information criteria for missing data models. Bayesian Analysis, <b>1</b>, 651&ndash;674.
</p>
<p>De Iorio, M., Johnson, W. O., Muller, P., and Rosner, G. L. (2009). Bayesian nonparametric nonproportional hazards survival modeling. Biometrics, <b>65</b>, 762&ndash;775.
</p>
<p>Geisser, S. and Eddy, W.F. (1979) A Predictive Approach to Model Selection, Journal of the American Statistical Association, <b>74</b>, 153&ndash;160.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., and Rubin, D.B. (2014). Bayesian Data Analysis, 3rd ed. CRC Press: Boca Raton, FL.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, <b>24</b>, 997&ndash;1010.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rubin, D. B. (1981). The Bayesian bootstrap. The Annals of Statistics, <b>9</b>, 130&ndash;134.
</p>
<p>Speigelhalter, D. J., Best, N. G., Carlin, B. P., and van der Linde, A. (2002). Bayesian measures of model comparison and fit. Journal of the Royal Statistical Society, Ser. B, <b>64</b>, 583&ndash;639.
</p>
<p>Watanabe, S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. Journal of Machine Learning Research, <b>11</b>, 3571&ndash;3594.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

AROC_bnp &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
              group = "status", 
              tag.h = 0, 
              data = newpsa,
              standardise = TRUE,
              p = seq(0,1,l=101),
              compute.lpml = TRUE,
              compute.WAIC = TRUE,
              compute.DIC = TRUE,
              pauc = pauccontrol(compute = TRUE, focus = "FPF", value = 0.5),
              density = densitycontrol.aroc(compute = TRUE, grid.h = NA, newdata = NA),
              prior.h = priorcontrol.bnp(m0 = rep(0, 4), S0 = 10*diag(4), nu = 6, Psi = diag(4),
              a = 2, b = 0.5, alpha = 1, L =10),
              mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

summary(AROC_bnp)

plot(AROC_bnp)


</code></pre>

<hr>
<h2 id='AROC.kernel'>
Nonparametric kernel-based estimation of the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.kernel'></span>

<h3>Description</h3>

<p>This function estimates the covariate-adjusted ROC curve (AROC) using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011). The method, as it stands now, can only deal with one continuous covariate. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.kernel(marker, covariate, group, tag.h, 
    bw = c("LS", "AIC"), 
    regtype = c("LC", "LL"),
    pauc = pauccontrol(), 
    data, p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95,
    parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.kernel_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_covariate">covariate</code></td>
<td>
<p>A character string with the name of the continuous covariate.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_bw">bw</code></td>
<td>
<p>A character string specifying which method to use to select the bandwidths. AIC specifies expected Kullback-Leibler cross-validation, and LS specifies least-squares cross-validation. Defaults to LS. For details see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_regtype">regtype</code></td>
<td>
<p>A character string specifying which type of kernel estimator to use for the regression function (see Details). LC specifies a local-constant estimator (Nadaraya-Watson) and LL specifies a local-linear estimator. Defaults to LC. For details see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve (pAAUC) should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_data">data</code></td>
<td>
<p>A data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve. This set is also used to compute the area under the covariate-adjusted ROC curve (AAUC) using Simpson's rule. Thus, the length of the set should be an odd number and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="AROC.kernel_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(p\right) = Pr\{1 - F_{\bar{D}}(Y_D | X_{D}) \leq p\},</code>
</p>

<p>where <code class="reqn">F_{\bar{D}}(y|x) = Pr\{Y_{\bar{D}} \leq y | X_{\bar{D}} = x\}</code>. In particular, the method implemented in this function estimates the outer probability empirically (see Janes and Pepe, 2009) and <code class="reqn">F_{\bar{D}}(y|x)</code> is estimated assuming a nonparametric location-scale regression model for <code class="reqn">Y_{\bar{D}}</code>, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mu_{\bar{D}}(X_{\bar{D}}) + \sigma_{\bar{D}}(X_{\bar{D}})\varepsilon_{\bar{D}},</code>
</p>

<p>where <code class="reqn">\mu_{\bar{D}}(x) = E(Y_{\bar{D}} | X_{\bar{D}} = x)</code> is the regression funcion, <code class="reqn">\sigma^2_{\bar{D}}(x) = Var(Y_{\bar{D}} | X_{\bar{D}} = x)</code> is the variance function, and <code class="reqn">\varepsilon_{\bar{D}}</code> has zero mean, variance one, and distribution function <code class="reqn">G_{\bar{D}}</code>. As a consequence,
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y | x) = G_{\bar{D}}\left(\frac{y - \mu_{\bar{D}}(x)}{\sigma_{\bar{D}}(x)}\right).</code>
</p>
 
<p>By default, both the regression and variance functions are estimated using the Nadaraya-Watson estimator (LC), and the bandwidths are selected using least-squares cross-validation (LS). Implementation relies on the <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. No assumption is made about <code class="reqn">G_{\bar{D}}</code>, which is empirically estimated on the basis of the standardised residuals. 
</p>
<p>The area under the AROC curve is
</p>
<p style="text-align: center;"><code class="reqn">AAUC=\int_0^1 AROC(p)dp,</code>
</p>

<p>and there exists a closed-form estimator. With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAAUC_{FPF}(u_1)=\int_0^{u_1} AROC(p)dp,</code>
</p>

<p>where again there exists a closed-form estimator. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as 
</p>
<p style="text-align: center;"><code class="reqn">pAAUC_{TPF}(u_2)=\int_{AROC^{-1}(u_2)}^{1}AROC(p)dp-\{1-AROC^{-1}(u_2)\}\times u_2.</code>
</p>

<p>Here, the computation of the integral is done numerically. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>covariate</code></td>
<td>
<p>The value of the argument <code>covariate</code> used in the call.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-adjusted ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC), and <code>ci.level</code>*100% pointwise confidence band (if computed).</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC), and <code>ci.level</code>*100% confidence interval (if computed).</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve (pAAUC) and <code>ci.level</code>*100%  confidence interval (if computed). Note that the returned values are normalised, so that the maximum value is one.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>List with the following components: (1) <code>bw.mean</code>: An object of class <code><a href="np.html#topic+np.regression.bw">npregbw</a></code> with the selected bandwidth for the nonparametric regression function. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (2) <code>bw.var</code>: An object of class <code><a href="np.html#topic+np.regression.bw">npregbw</a></code> with the selected bandwidth for the nonparametric variance function. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (3) <code>fit.mean</code>: An object of class <code><a href="np.html#topic+np.regression">npreg</a></code> with the nonparametric regression function estimate. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (4) <code>fit.var</code>: An object of class <code><a href="np.html#topic+np.regression">npreg</a></code> with the nonparametric variance function estimate. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hayfield, T., and Racine, J. S. (2008). Nonparametric Econometrics: The np Package. Journal of Statistical Software 27(5). URL http://www.jstatsoft.org/v27/i05/.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, <b>96</b>, 371&ndash;382.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m2 &lt;- AROC.kernel(marker = "l_marker1", 
covariate = "age",
group = "status", 
tag.h = 0,
data = newpsa, 
bw = "LS",
regtype = "LC",
pauc = pauccontrol(compute = TRUE, focus = "FPF", value = 0.5),
B = 500)

summary(m2)

plot(m2)


</code></pre>

<hr>
<h2 id='AROC.sp'>
Semiparametric frequentist inference for the covariate-adjusted ROC curve (AROC).
</h2><span id='topic+AROC.sp'></span>

<h3>Description</h3>

<p>This function estimates the covariate-adjusted ROC curve (AROC) using the semiparametric approach proposed by Janes and Pepe (2009).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AROC.sp(formula.h, group, tag.h, data, 
    est.cdf.h = c("normal", "empirical"), pauc = pauccontrol(),
    p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95, 
  	parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AROC.sp_+3A_formula.h">formula.h</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the location regression model to be fitted in the healthy population (see Details).</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_data">data</code></td>
<td>
<p>A data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_est.cdf.h">est.cdf.h</code></td>
<td>
<p>A character string. It indicates how the conditional distribution function of the diagnostic test in the healthy population is estimated. Options are <code>"normal"</code> and <code>"empirical"</code> (see Details). The default is <code>"normal"</code>.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve (pAAUC) should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-adjusted ROC curve. This set is also used to compute the area under the covariate-adjusted ROC curve (AAUC) using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="AROC.sp_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-adjusted ROC curve (AROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">AROC\left(p\right) = Pr\{1 - F_{\bar{D}}(Y_D | \mathbf{X}_{D}) \leq p\},</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr\{Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}\}.</code>
</p>
<p> The method implemented in this function estimates the outer probability empirically (see Janes and Pepe, 2009) and <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{x})</code> is estimated assuming a semiparametric location regression model for <code class="reqn">Y_{\bar{D}}</code>, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mathbf{X}_{\bar{D}}^{T}\mathbf{\beta}_{\bar{D}} + \sigma_{\bar{D}}\varepsilon_{\bar{D}},</code>
</p>

<p>where <code class="reqn">\varepsilon_{\bar{D}}</code> has zero mean, variance one, and distribution function <code class="reqn">G_{\bar{D}}</code>. As a consequence, we have
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y | \mathbf{x}) = G_{\bar{D}}\left(\frac{y-\mathbf{x}^{T}\mathbf{\beta}_{\bar{D}}}{\sigma_{\bar{D}}}\right).</code>
</p>

<p>In line with the assumptions made about the distribution of <code class="reqn">\varepsilon_{\bar{D}}</code>, estimators will be referred to as: (a) &quot;normal&quot;, where a standard Gaussian error is assumed, i.e., <code class="reqn">G_{\bar{D}}(y) = \Phi(y)</code>; and, (b) &quot;empirical&quot;, where no assumption is made about the distribution (in this case, <code class="reqn">G_{\bar{D}}</code> is empirically estimated on the basis of standardised residuals).
</p>
<p>The area under the AROC curve is
</p>
<p style="text-align: center;"><code class="reqn">AAUC=\int_0^1 AROC(p)dp,</code>
</p>

<p>and there exists a closed-form estimator. With regard to the partial area under the AROC curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAAUC_{FPF}(u_1)=\int_0^{u_1} AROC(p)dp,</code>
</p>

<p>where again there exists a closed-form estimator. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as </p>
<p style="text-align: center;"><code class="reqn">pAAUC_{TPF}(u_2)=\int_{AROC^{-1}(u_2)}^{1}AROC(p)dp-\{1-AROC^{-1}(u_2)\}\times u_2.</code>
</p>
<p> Here, the computation of the integral is done numerically. The returned value is the normalised pAAUC, <code class="reqn">pAAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The value of the argument <code>formula.h</code> used in the call.</p>
</td></tr>
<tr><td><code>est.cdf.h</code></td>
<td>
<p>The value of the argument <code>est.cdf.h</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-adjusted ROC (AROC) curve has been estimated</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-adjusted ROC curve (AROC), and <code>ci.level</code>*100% pointwise confidence bands (if computed)</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-adjusted ROC curve (AAUC), and <code>ci.level</code>*100% confidence intervals (if required).</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve (pAAUC) and <code>ci.level</code>*100%  confidence interval (if computed). Note that the returned values are normalised, so that the maximum value is one.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Object of class <code><a href="stats.html#topic+lm">lm</a></code> with the fitted regression model in the healthy population.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>Estimated regression coefficients (and <code>ci.level</code>*100% confidence interval if <code>B</code> greater than zero) from the fit of the linear model in the healthy population, as specified in <code>formula.h</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Janes, H., and Pepe, M.S. (2009). Adjusting for covariate effects on classification accuracy using the covariate-adjusted receiver operating characteristic curve. Biometrika, 96(2), 371 - 382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m3 &lt;- AROC.sp(formula.h = l_marker1 ~ age,
group = "status", 
tag.h = 0,
data = newpsa,
est.cdf.h = "normal",
pauc = pauccontrol(compute = TRUE, focus = "FPF", value = 0.5),
p = seq(0,1,l=101), 
B = 500)

summary(m3)

plot(m3)


</code></pre>

<hr>
<h2 id='compute.threshold.AROC'>
AROC based threshold values.
</h2><span id='topic+compute.threshold.AROC'></span>

<h3>Description</h3>

<p>This function implements methods for estimating AROC-based threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.AROC(object, criterion = c("FPF", "YI"), FPF, newdata,
  ci.level = 0.95, parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.AROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_criterion">criterion</code></td>
<td>
<p>A character string indicating whether the covariate-adjusted threshold values should be computed based on the Youden index (&ldquo;YI&rdquo;) or for a fixed set of false positive fractions (&ldquo;FPF&rdquo;).</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_fpf">FPF</code></td>
<td>
<p>For criterion = FPF, a numeric vector with the FPF at which to calculate the AROC-based threshold values. Atomic values are also valid.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the AROC-based threshold values will be computed. If not supplied, the function <code><a href="#topic+cROCData">cROCData</a></code> is used to build a default dataset.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="compute.threshold.AROC_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates AROC-based threshold values based on two different criteria, namely, the Youden index (YI) and the one that gives rise to a pre-specified FPF. Before proceeding, we would like to mention that when the accuracy of a test is not affected by covariates, this does not necessarily imply that the covariate-specific ROC curve (which in this case is the same for all covariate values) coincides with the pooled ROC curve. It does coincide, however, with the AROC curve. Consequently, in all cases where covariates affect the test, even though they might not affect its discriminatory capacity, inferences based on the pooled ROC curve might be misleading. In such cases the AROC curve should be used instead. This also applies to the selection of (optimal) threshold values, which, as will be seen, might be covariate-specific (i.e., possibly different for different covariate values).
</p>
<p>For the AROC curve, the Youden Index is defined as
</p>
<p style="text-align: center;"><code class="reqn">YI = \max_{p}\{AROC(p) - p\},</code>
</p>

<p>The value <code class="reqn">p^{*}</code> (FPF) that achieves the maximum is then used to calculate the optimal (covariate-specific) YI threshold as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{\bar{D}}^{-1}(1-p^{*}|\mathbf{x}),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>In a similar way, when using the criterion for a fixed FPF, the covariate-specific threshold values are obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{\bar{D}}^{-1}(1-FPF|\mathbf{x}).</code>
</p>

<p>In both cases, we use the notation <code class="reqn">c^{*}_{\mathbf{x}}</code> to emphasise that this value depends on covariate <code class="reqn">\mathbf{x}</code>.
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>Data frame containing the values of the covariates at which the AROC-based thresholds were computed.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>If method = &quot;YI&quot;, the estimated AROC-based threshold corresponding to the Youden index, and if method = &quot;FPF&quot;, AROC-based threshold corresponding to the specified FPF. For the Bayesian approach (<code>AROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td></tr>
<tr><td><code>YI</code></td>
<td>
<p>If criterion = &quot;YI&quot;, the AROC-based Youden index. For the Bayesian approach (<code>AROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td></tr>
<tr><td><code>FPF</code></td>
<td>
<p>If criterion = &quot;YI&quot;, the FPF where the Youden index is attained, and if criterion = &quot;FPF&quot;, the supplied FPF argument. For the Bayesian approach (<code>AROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483&ndash;499.
</p>
<p>Rutter, C.M. and Miglioretti, D. L. (2003). Estimating the Accuracy of Psychological Scales Using Longitudinal Data. Biostatistics, <b>4</b>, 97&ndash;107.
</p>
<p>Youden, W. J. (1950). Index for rating diagnostic tests. Cancer, <b>3</b>, 32&ndash;35.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code> or <code><a href="#topic+AROC.sp">AROC.sp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

AROC_bnp &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
              group = "status", 
              tag.h = 0, 
              data = newpsa,
              standardise = TRUE,
              p = seq(0,1,l=101),
              prior = priorcontrol.bnp(m0 = rep(0, 4), 
              S0 = 10*diag(4), nu = 6, Psi = diag(4),
              a = 2, b = 0.5, alpha = 1, L =10),
              mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

### Threshold values based on the YI
th_AROC_bnp_yi &lt;- compute.threshold.AROC(AROC_bnp, criterion = "YI")

# Plot results
plot(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_yi$thresholds[,"est"], 
	type = "l", xlab = "Age", 
	ylab = "log(PSA)", ylim = c(0,3), 
	main = "Threshold values based on the Youden Index")
lines(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_yi$thresholds[,"qh"], lty = 2)
lines(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_yi$thresholds[,"ql"], lty = 2)

### Threshold values for a fixed FPF
th_AROC_bnp_fpf &lt;- compute.threshold.AROC(AROC_bnp, criterion = "FPF", FPF = 0.1)

# Plot results
plot(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_fpf$thresholds[["0.1"]][,"est"], 
	type = "l", xlab = "Age", 
	ylab = "log(PSA)", ylim = c(0,3), 
	main = "Threshold values for a FPF = 0.1")
lines(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_fpf$thresholds[["0.1"]][,"qh"], lty = 2)
lines(th_AROC_bnp_yi$newdata$age, th_AROC_bnp_fpf$thresholds[["0.1"]][,"ql"], lty = 2)



</code></pre>

<hr>
<h2 id='compute.threshold.cROC'>
Covariate-specific ROC based threshold values.
</h2><span id='topic+compute.threshold.cROC'></span>

<h3>Description</h3>

<p>This function implements methods for estimating covariate-specific ROC-based threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.cROC(object, criterion = c("FPF", "TPF", "YI"), FPF, TPF, newdata,
  ci.level = 0.95, parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.cROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>cROC</code> as produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_criterion">criterion</code></td>
<td>
<p>A character string indicating whether the covariate-specific threshold values should be computed based on the Youden index (&ldquo;YI&rdquo;) or for fixed false positive fractions (&ldquo;FPF&rdquo;) or true positive fractions (&ldquo;TPF&rdquo;). </p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_fpf">FPF</code></td>
<td>
<p>For <code>criterion = "FPF"</code>, a numeric vector with the FPF at which to calculate the covariate-specific threshold values. Atomic values are also valid.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_tpf">TPF</code></td>
<td>
<p>For <code>criterion = "TPF"</code>, a numeric vector with the TPF at which to calculate the covariate-specific threshold values. Atomic values are also valid.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific threshold values will be computed. If not supplied, the function <code><a href="#topic+cROCData">cROCData</a></code> is used to build a default dataset.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="compute.threshold.cROC_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates covariate-specific ROC-based threshold values based on three different criteria, namely, the Youden index (YI), one that gives rise to a pre-specified FPF, and one that gives rise to a pre-specified TPF.
</p>
<p>In the conditional case, the Youden index is defined as
</p>
<p style="text-align: center;"><code class="reqn">YI(\mathbf{x}) = \max_{c}|TPF(c|\mathbf{x}) - FPF(c|\mathbf{x})| = \max_{c}|F_{\bar{D}}(c|\mathbf{x}) - F_{D}(c|\mathbf{x})|,</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|\mathbf{x}) = Pr(Y_{D} \leq y | \mathbf{X}_{D} = \mathbf{x}),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>The value <code class="reqn">c^{*}_{\mathbf{x}}</code> that achieves the maximum is called the optimal covariate-specific YI threshold. Regarding the criterion for a fixed FPF, the covariate-specific threshold values are obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{\bar{D}}^{-1}(1-FPF|\mathbf{x}),</code>
</p>

<p>and for a fixed TPF we have
</p>
<p style="text-align: center;"><code class="reqn">c^{*}_{\mathbf{x}} = F_{D}^{-1}(1-TPF|\mathbf{x}),</code>
</p>

<p>In all cases, we use the notation <code class="reqn">c^{*}_{\mathbf{x}}</code> to emphasise that this value depends on covariate <code class="reqn">\mathbf{x}</code>.
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>Data frame containing the values of the covariates at which the covariate-specific thresholds were computed.</p>
</td></tr>
<tr><td><code>thresholds</code></td>
<td>
<p>If method = &quot;YI&quot;, the estimated covariate-specific (optimal) threshold corresponding to the covariate-specific Youden index (the one that maximises TPF/sensitivity + TNF/specificity). If method = &quot;FPF&quot;, the covariate-specific threshold corresponding to the specified FPF, and if method = &quot;TPF&quot;, the covariate-specific threshold corresponding to the specified TPF. For the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td></tr>
<tr><td><code>YI</code></td>
<td>
<p>If method = &quot;YI&quot;, the estimated covariate-specific Youden index. For the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.</p>
</td></tr>
<tr><td><code>FPF</code></td>
<td>
<p>If method = &quot;YI&quot; or method = &quot;TPF&quot;, the FPF corresponding to the estimated (optimal) covariate-specific thresholds (for the Bayesian approach (<code>cROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned.). If method = &quot;FPF&quot;, the supplied FPF argument.</p>
</td></tr>
<tr><td><code>TPF</code></td>
<td>
<p>If method = &quot;YI&quot; or method = &quot;FPF&quot;, the covariate-specific TPF/sensitivity corresponding to the estimated covariate-specific (optimal) threshold. For the Bayesian approach (<code>AROC.bnp</code>), in addition to the posterior mean, the <code>ci.level</code>*100% pointwise credible band is also returned. If method = &quot;TPF&quot;, the supplied TPF argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Inacio de Carvalho, V., de Carvalho, M. and Branscum, A. J. (2017). Nonparametric Bayesian Covariate-Adjusted Estimation of the Youden Index. Biometrics, <b>73</b>, 1279-1288.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483&ndash;499.
</p>
<p>Rutter, C.M. and Miglioretti, D. L. (2003). Estimating the Accuracy of Psychological Scales Using Longitudinal Data. Biostatistics, <b>4</b>, 97&ndash;107.
</p>
<p>Youden, W. J. (1950). Index for rating diagnostic tests. Cancer, <b>3</b>, 32&ndash;35.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.kernel">cROC.kernel</a></code> or <code><a href="#topic+cROC.sp">cROC.sp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
			  formula.d = l_marker1 ~ f(age, K = 0),
              group = "status", 
              tag.h = 0, 
              data = newpsa,
              standardise = TRUE,
              p = seq(0,1,l=101),
              mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

### Threshold values based on the YI
th_cROC_bnp_yi &lt;- compute.threshold.cROC(cROC_bnp, criterion = "YI")

# Plot results
	# Threshold values
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,3), 
		main = "Threshold values based on the Youden Index")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$thresholds[,"ql"], lty = 2)

	# Youden Index
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,1), 
		main = "Threshold values based on the Youden Index")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_yi$YI[,"ql"], lty = 2)

### Threshold values for a fixed FPF
th_cROC_bnp_fpf &lt;- compute.threshold.cROC(cROC_bnp, criterion = "FPF", FPF = 0.1)

# Plot results
	# Threshold values
	plot(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"est"], 
		type = "l", xlab = "Age", 
		ylab = "log(PSA)", ylim = c(0,3), main = "Threshold values for a FPF = 0.1")
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"qh"], lty = 2)
	lines(th_cROC_bnp_yi$newdata$age, th_cROC_bnp_fpf$thresholds[["0.1"]][,"ql"], lty = 2)



</code></pre>

<hr>
<h2 id='compute.threshold.pooledROC'>
Pooled ROC based threshold values.
</h2><span id='topic+compute.threshold.pooledROC'></span>

<h3>Description</h3>

<p>This function implements methods for estimating pooled ROC-based threshold values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute.threshold.pooledROC(object, criterion = c("FPF", "TPF", "YI"), FPF, TPF, 
  ci.level = 0.95, parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute.threshold.pooledROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>pooledROC</code> as produced by <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code> functions.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_criterion">criterion</code></td>
<td>
<p>A character string indicating if the threshold value should be computed based on the Youden index (&ldquo;YI&rdquo;), or for fixed false positive fractions (&ldquo;FPF&rdquo;) or true positive fractions (&ldquo;TPF&rdquo;). </p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_fpf">FPF</code></td>
<td>
<p>For <code>criterion = "FPF"</code>, a numeric vector with the FPF at which to calculate the threshold values. Atomic values are also valid.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_tpf">TPF</code></td>
<td>
<p>For <code>criterion = "TPF"</code>, a numeric vector with the TPF at which to calculate the threshold values. Atomic values are also valid.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="compute.threshold.pooledROC_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates pooled ROC-based threshold values based on three different criteria, namely, the Youden index (YI), one that gives rise to a pre-specified FPF, and one that gives rise to a pre-specified TPF.
</p>
<p>The Youden Index is defined as
</p>
<p style="text-align: center;"><code class="reqn">YI = \max_{c}\{TPF(c) - FPF(c)\} = \max_{c}\{F_{\bar{D}}(c) - F_{D}(c)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The value <code class="reqn">c^{*}</code> that achieves the maximum is called the optimal YI threshold. Regarding the criterion for a fixed FPF, the threshold value is obtained as follows
</p>
<p style="text-align: center;"><code class="reqn">c = F_{\bar{D}}^{-1}(1-FPF).</code>
</p>

<p>and for a fixed TPF we have
</p>
<p style="text-align: center;"><code class="reqn">c = F_{D}^{-1}(1-TPF).</code>
</p>



<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>If method = &quot;YI&quot;, the estimated (optimal) threshold corresponding to the Youden index (the one that maximises TPF/sensitivity + TNF/specificity). If method = &quot;FPF&quot;, the estimated threshold corresponding to the specified FPF, and if method = &quot;TPF&quot;, the estimated threshold corresponding to the specified TPF. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), and in both cases, in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned.</p>
</td></tr>
<tr><td><code>YI</code></td>
<td>
<p>If method = &quot;YI&quot;, the estimated Youden index. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned.</p>
</td></tr>
<tr><td><code>FPF</code></td>
<td>
<p>If method = &quot;YI&quot; or method = &quot;TPF&quot;, the FPF corresponding to the estimated (optimal) threshold (For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned). If method = &quot;FPF&quot;, the supplied FPF argument.</p>
</td></tr>
<tr><td><code>TPF</code></td>
<td>
<p>If method = &quot;YI&quot; or method = &quot;FPF&quot;, the TPF/sensitivity corresponding to the estimated (optimal) threshold. For the Bayesian approaches (<code>pooledROC.dpm</code> and <code>pooledROC.BB</code>), in addition to the posterior mean, the <code>ci.level</code>*100% credible interval is also returned. If method = &quot;TPF&quot;, the supplied TPF argument.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Rutter, C.M. and Miglioretti, D. L. (2003). Estimating the Accuracy of Psychological Scales Using Longitudinal Data. Biostatistics, <b>4</b>, 97&ndash;107.
</p>
<p>Youden, W. J. (1<code>ci.level</code>*1000). Index for rating diagnostic tests. Cancer, <b>3</b>, 32&ndash;35.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code> or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_dpm &lt;- pooledROC.dpm(marker = "l_marker1", group = "status",
            tag.h = 0, data = newpsa, standardise = TRUE, 
            p = seq(0,1,l=101), compute.WAIC = TRUE, compute.lpml = TRUE, 
            compute.DIC = TRUE, 
            prior.h = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            prior.d = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            mcmc = mcmccontrol(nsave = 400, nburn = 100, nskip = 1))


## Threshold values based on the YI
th_m0_dpm_yi &lt;- compute.threshold.pooledROC(m0_dpm, criterion = "YI")

th_m0_dpm_yi$threshold
th_m0_dpm_yi$YI

### Threshold values for a fixed FPF
th_m0_dpm_fpf &lt;- compute.threshold.pooledROC(m0_dpm, criterion = "FPF", FPF = 0.1)

th_m0_dpm_fpf$threshold

  
</code></pre>

<hr>
<h2 id='cROC.bnp'>
Nonparametric Bayesian inference for the covariate-specific ROC curve (cROC).
</h2><span id='topic+cROC.bnp'></span>

<h3>Description</h3>

<p>This function estimates the covariate-specific ROC curve (cROC) using the nonparametric Bayesian approach proposed by Inacio de Carvalho et al. (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cROC.bnp(formula.h, formula.d, group, tag.h, data, 
    newdata, standardise = TRUE, p = seq(0, 1, l = 101), ci.level = 0.95,
    compute.lpml = FALSE, compute.WAIC = FALSE, compute.DIC = FALSE, 
    pauc = pauccontrol(), density = densitycontrol(),
    prior.h = priorcontrol.bnp(), prior.d = priorcontrol.bnp(), 
    mcmc = mcmccontrol(),
    parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cROC.bnp_+3A_formula.h">formula.h</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the regression function associated to each component of the single-weights linear dependent Dirichlet process mixture of normals model used to estimate the conditional distribution function of the diagnostic test outcome in the healthy population. Regarding the modelling of continuous covariates, both linear and nonlinear effects are allowed, with nonlinear effects being modelled through B-spline basis expansions (see Note).</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_formula.d">formula.d</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the regression function associated to each component of the single weights linear dependent Dirichlet process mixture model used to estimate the conditional distribution function of the diagnostic test outcome in the diseased population. Both linear and nonlinear (through the use of smooth functions approximated by linear combinations of cubic B-splines basis functions) covariate effects are allowed (see Note).</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_data">data</code></td>
<td>
<p>A data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if computed) will be computed. If not supplied, the function <code><a href="#topic+cROCData">cROCData</a></code> is used to build a default dataset.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_standardise">standardise</code></td>
<td>
<p>A logical value. If TRUE both the test outcomes and the continuous covariates assumed to have a linear effect are standardised (i.e., the resulting variables have mean zero and standard deviation of one). The default is TRUE.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-specific ROC curve.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_compute.lpml">compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_compute.waic">compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_compute.dic">compute.DIC</code></td>
<td>
<p>A logical value. If TRUE, the deviance information criterion (DIC)(Celeux et al., 2006, Spiegelhalter et al., 2002) is computed.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_density">density</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+densitycontrol">densitycontrol</a></code>. This argument is used to indicate whether the conditional densities of the marker in the healthy and diseased population should be computed, and in case it is to be computed, at which grid of test outcomes in each of the populations the conditional densities should be evaluated.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_prior.h">prior.h</code></td>
<td>
<p>Hyparameter specification for the healthy population. A list of control values to replace the default values returned by the function <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code>. See <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code> for details.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_prior.d">prior.d</code></td>
<td>
<p>Hyparameter specification for the diseased population.  A list of control values to replace the default values returned by the function <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code>. See <code><a href="#topic+priorcontrol.bnp">priorcontrol.bnp</a></code> for details.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_mcmc">mcmc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+mcmccontrol">mcmccontrol</a></code>. See <code><a href="#topic+mcmccontrol">mcmccontrol</a></code> for details.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cROC.bnp_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-specific ROC curve (cROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|\mathbf{x}) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p|\mathbf{x})|\mathbf{x}\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|\mathbf{x}) = Pr(Y_{D} \leq y | \mathbf{X}_{D} = \mathbf{x}),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>Note that, for the sake of clarity, we assume that the covariates of interest are the same in both the healthy and diseased populations. The method implemented in this function estimates <code class="reqn">F_{D}(\cdot|\mathbf{x})</code> and <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{x})</code> by means of a single-weights linear dependent Dirichlet process mixture of normals model (De Iorio et al., 2009). More precisely, and letting <code class="reqn">\{(\mathbf{x}_{\bar{D}i},y_{\bar{D}i})\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{(\mathbf{x}_{Dj},y_{Dj})\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, our postulated model for the conditional distribution in each group function takes the following form 
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}|\mathbf{X}_{\bar{D}}=\mathbf{x}_{\bar{D}i}) = \sum_{l=1}^{L_{\bar{D}}}\omega_{l\bar{D}}\Phi(y_{\bar{D}i}\mid\mu_{l\bar{D}}(\mathbf{x}_{\bar{D}i}),\sigma_{l\bar{D}}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{D}(y_{Dj}|\mathbf{X}_{D} = \mathbf{x}_{Dj}) = \sum_{l=1}^{L_{D}}\omega_{lD}\Phi(y_{Dj}\mid\mu_{lD}(\mathbf{x}_{\bar{D}i}),\sigma_{lD}^2),</code>
</p>

<p>where <code class="reqn">\Phi(y|\mu, \sigma^2)</code> denotes the cumulative distribution function of the normal distribution, evaluated at <code class="reqn">y</code>, with mean <code class="reqn">mu</code> and variance <code class="reqn">\sigma^2</code>. The regression function <code class="reqn">\mu_{ld}(\mathbf{x}_{di})</code> can incorportate both linear and nonlinear (through B-splines) effects of continuous covariates, categorical covariates (factors) as well as interactions. Interactions between categorical and (nonlinear) continuous covariates are also allowed (factor-by curve interactions). For the sake of simplicity we write <code class="reqn">\mu_{ld}(\mathbf{x}_{di}) = \mathbf{z}_{di}^{T}\mathbf{\beta}_{ld}</code>, where <code class="reqn">\mathbf{z}_{di}</code> is the <code class="reqn">i</code>th column of the design matrix (possibly containing a basis representation of some/all continuous covariates), <code class="reqn">d \in \{D, \bar{D}\}</code>. Here <code class="reqn">L_d</code> is a pre-specified upper bound on the number of mixture components. The <code class="reqn">\omega_{ld}</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_{1d} = v_{1d}</code>; <code class="reqn">\omega_{ld} = v_{ld}\prod_{r&lt;l}(1-v_{dr})</code>, <code class="reqn">l=2,\ldots,L_{d}</code>; <code class="reqn">v_{d1},\ldots,v_{L_{d}-1}\sim</code> Beta <code class="reqn">(1,\alpha_{d})</code>; <code class="reqn">v_{Ld} = 1</code>, <code class="reqn">\alpha_d \sim \Gamma(a_{\alpha_d},b_{\alpha_d})</code>), <code class="reqn">\mathbf{\beta}_{ld}\sim N_{Q_d}(\mathbf{m}_{d},\mathbf{S}_{d})</code>, and <code class="reqn">\sigma_{ld}^{-2}\sim\Gamma(a_{d},b_{d})</code>. It is further assumed that <code class="reqn">\mathbf{m}_{d} \sim N_{Q_k}(\mathbf{m}_{0d},\mathbf{S}_{0d})</code> and <code class="reqn">\mathbf{S}_{d}^{-1}\sim W(\nu,(\nu_k\Psi_d)^{-1})</code>. Here <code class="reqn">W(\nu,(\nu\Psi)^{-1})</code> denotes a Wishart distribution with <code class="reqn">\nu</code> degrees of freedom and expectation <code class="reqn">\Psi^{-1}</code>, Here <code class="reqn">\Gamma(a,b)</code> denotes a Gamma distribution with shape parameter <code class="reqn">a</code> and rate parameter <code class="reqn">b</code>, and <code class="reqn">Q_d</code> denotes the dimension of the vector <code class="reqn">\mathbf{z}_{di}</code>. It is worth mentioning that when <code class="reqn">L_d=1</code>, the model for the conditional distribution of the test outcomes reduces to a normal regression model (where continuous covariates effects are modelled either parametrically or nonparametrically). For a detailed description, we refer to Inacio de Carvalho et al. (2013). 
</p>
<p>The covariate-specific area under the curve is
</p>
<p style="text-align: center;"><code class="reqn">AUC(\mathbf{x})=\int_{0}^{1}ROC(p|\mathbf{x})dp.</code>
</p>

<p>When the upper bound on the number of mixture components is 1, i.e., <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the covariate-specific AUC (binormal model), which is used in the package. In contrast, when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code>, the integral is computed numerically using Simpson's rule. With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})=\int_0^{u_1} ROC(p|\mathbf{x})dp.</code>
</p>
 
<p>As for the AUC, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{FPF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})=\int_{u_2}^{1}ROC_{TNF}(p|\mathbf{x})dp,</code>
</p>

<p>where <code class="reqn">ROC_{TNF}(p|\mathbf{x})</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p|\mathbf{x}) = F_{\bar{D}}\{F_{D}^{-1}(1-p|\mathbf{x})|\mathbf{x}\}.</code> Again, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{TNF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>
<p>It is worth referring that with respect to the computation of the DIC, when <code class="reqn">L=1</code>, it is computed as in Spiegelhalter et al. (2002), and when <code class="reqn">L&gt;1</code>, DIC3 as described in Celeux et al. (2006) is computed. Also, for the computation of the conditional predictive ordinates (CPO) we follow the stable version proposed by Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>A data frame containing the values of the covariates at which the covariate-specific ROC curve (as well as the AUC, pAUC, dens and reg.fun, if required) was computed.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-specific ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A list returning the hyperparameter values in the healthy and diseased populations.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>A list returning the <code>np</code> (length of the vector <code>p</code>) by npred predicted covariate-specific ROC curves (cROC) (posterior mean) and <code>ci.level</code>*100% pointwise posterior credible bands.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-specific ROC curve (posterior mean) and <code>ci.level</code>*100% posterior credible band.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve (posterior mean) and <code>ci.level</code>*100%  credible
band. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: <code>grid</code> (grid of test outcomes where the conditional densities were evaluated) and <code>dens</code> (MCMC realisations of the corresponding conditional densities).</p>
</td></tr>
<tr><td><code>reg.fun</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a data frame containing the predicted regression function (posterior mean) and <code>ci.level</code>*100% credible band.</p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: widely applicable information criterion (WAIC) and associated complexity penalty (pW).</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: deviance information criterion (DIC) and associated complexity penalty (pD).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Named list of length two, with components <code>h</code> (healthy) and <code>d</code> (diseased). Each component is a list with the following information: (1) <code>formula</code>: the value of the argument <code>formula.h</code> or <code>formula.d</code> used in the call. (2) <code>mm</code>: information needed to construct the model matrix associated with single-weights linear dependent Dirichlet process mixture of normals model. (3) <code>beta</code>: array of dimension <code>nsave</code>x<code>L</code>x<code>Q</code> with the sampled regression coefficients. (4) <code>sd</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled variances. (4) <code>probs</code>: matrix of dimension <code>nsave</code>x<code>L</code> with the sampled components' weights. Here, <code>nsave</code> is the number of Gibbs sampler iterations saved, <code>L</code> is the maximum number of mixture components, and <code>Q</code> is the dimension of vector <code class="reqn">\mathbf{z}_{d}</code>, <code class="reqn">d \in \{D, \bar{D}\}</code>. (see also Details). (see also Details).</p>
</td></tr>
<tr><td><code>data_model</code></td>
<td>
<p>A list with the data used in the fit: observed diagnostic test outcome and design matrices, separately for the healthy and diseased groups.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The input arguments <code>formula.h</code> and <code>formula.d</code> are similar to that used for the <code><a href="stats.html#topic+glm">glm</a></code> function, except that flexible specifications can be added by means of the function <code>f()</code>. For instance, specification <code class="reqn">y \sim x1 + f(x2, K = 3)</code> would assume a linear effect of <code>x1</code> (if <code>x1</code> continuous) and the effect of <code>x2</code> would be modeled using B-splines basis functions. The argument <code>K = 3</code> indicates that <code>3</code> internal knots will be used, with the quantiles of <code>x2</code> used for their location. Categorical variables (factors) can be also incorporated, as well as interaction terms. For example, to include the factor-by-curve interaction between <code>age</code> and <code>gender</code> we need to specify, e.g., <code class="reqn">y \sim gender + f(age, by = gender, K = c(3, 5))</code>. Note that, in this case, the number of knots can be different for each level of the factor. The order of the vector <code>K</code> of knots should match the levels of the factor.</p>


<h3>References</h3>

<p>Celeux, G., Forbes, F., Robert C. P., and Titerrington, D. M. (2006). Deviance information criteria for missing data models. Bayesian Analysis, <b>1</b>, 651&ndash;674.
</p>
<p>De Iorio, M., Johnson, W. O., Muller, P., and Rosner, G. L. (2009). Bayesian nonparametric nonproportional hazards survival modeling. Biometrics, <b>65</b>, 762&ndash;775.
</p>
<p>Geisser, S. and Eddy, W.F. (1979) A Predictive Approach to Model Selection, Journal of the American Statistical Association, <b>74</b>, 153&ndash;160.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., and Rubin, D.B. (2014). Bayesian Data Analysis, 3rd ed. CRC Press: Boca Raton, FL.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, <b>24</b>, 997&ndash;1010.
</p>
<p>Hillis, S. L. and Metz, C.E. (2012). An Analytic Expression for the Binormal Partial Area under the ROC Curve. Academic Radiology, <b>19</b>, 1491&ndash;1498.
</p>
<p>Inacio de Carvalho, V., Jara, A., Hanson, T. E., and de Carvalho, M. (2013). Bayesian nonparametric ROC regression modeling. Bayesian Analysis, <b>8</b>, 623&ndash;646.
</p>
<p>Speigelhalter, D. J., Best, N. G., Carlin, B. P., and van der Linde, A. (2002). Bayesian measures of model comparison and fit. Journal of the Royal Statistical Society, Ser. B, <b>64</b>, 583&ndash;639.
</p>
<p>Watanabe, S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. Journal of Machine Learning Research, <b>11</b>, 3571&ndash;3594.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))
summary(cROC_bnp)

plot(cROC_bnp)


</code></pre>

<hr>
<h2 id='cROC.kernel'>
Nonparametric kernel-based estimation of the covariate-specific ROC curve (cROC).
</h2><span id='topic+cROC.kernel'></span>

<h3>Description</h3>

<p>This function estimates the covariate-specific ROC curve (cROC) using the nonparametric kernel-based method proposed by Rodriguez-Alvarez et al. (2011). The method, as it stands now, can only deal with one continuous covariate. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cROC.kernel(marker, covariate, group, tag.h, 
  bw = c("LS", "AIC"), regtype = c("LC", "LL"), 
  data, newdata, pauc = pauccontrol(),  
  p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95,
    parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cROC.kernel_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_covariate">covariate</code></td>
<td>
<p>A character string with the name of the continuous covariate.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_bw">bw</code></td>
<td>
<p>A character string specifying which method to use to select the bandwidths. AIC specifies expected Kullback-Leibler cross-validation, and LS specifies least-squares cross-validation. Defaults to LS. For details see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_regtype">regtype</code></td>
<td>
<p>A character string specifying which type of kernel estimator to use for the regression function (see Details). LC specifies a local-constant estimator (Nadaraya-Watson) and LL specifies a local-linear estimator. Defaults to LC. For details see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if computed) will be computed. If not supplied, the function <code><a href="#topic+cROCData">cROCData</a></code> is used to build a default dataset.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve should be computed, and in case it is computed, , whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-specific ROC curve. This set is also used to compute the area under the covariate-specific ROC curve using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cROC.kernel_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-specific ROC curve (cROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|x) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p|x)|x\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|x) = Pr(Y_{D} \leq y | X_{D} = x ),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|x) = Pr(Y_{\bar{D}} \leq y | X_{\bar{D}} = x).</code>
</p>

<p>Note that, for the sake of clarity, we assume that the covariate of interest is the same in both healthy and diseased populations. In particular, the method implemented in this function estimates <code class="reqn">F_{D}(\cdot|x)</code> and <code class="reqn">F_{\bar{D}}(\cdot|x)</code> assuming a nonparametric location-scale regression model for <code class="reqn">Y</code> in each population separately, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{D} = \mu_{D}(X_{D}) + \sigma_{D}(X_{D})\varepsilon_{D},</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mu_{\bar{D}}(X_{\bar{D}}) + \sigma_{\bar{D}}(X_{\bar{D}})\varepsilon_{\bar{D}},</code>
</p>

<p>where <code class="reqn">\mu_{D}(x) = E(Y_D | X_D = x)</code>,  <code class="reqn">\mu_{\bar{D}}(x) = E(Y_{\bar{D}} | X_{\bar{D}} = x)</code> (regression function), <code class="reqn">\sigma^2_{D}(x) = Var(Y_D | X_D = x)</code>, <code class="reqn">\sigma^2_{\bar{D}}(x) = Var(Y_{\bar{D}} | X_{\bar{D}} = x)</code> (variance functions), and <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code> have zero mean, variance one, and distribution functions <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code>, respectively. In this case, the covariate-specific ROC curve can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|x) = 1 - G_{D}\{a(\mathbf{x}) + b(\mathbf{x})G_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where <code class="reqn">a(x) = \frac{\mu_{\bar{D}}(x) - \mu_{D}(x)}{\sigma_{D}(x)}</code>, <code class="reqn">b(x) = \frac{\sigma_{\bar{D}}(x)}{\sigma_{D}(x)}</code>, and <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code> are the distribution functions of <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code>, respectively.
By default, for both the healthy and diseased population, both the regression and variance functions are estimated using the Nadaraya-Watson estimator (LC), and the bandwidth are selected using least-squares cross-validation (LS). Implementation relies on the <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. No assumptions are made about <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code>, which are empirically estimated on the basis of standardised residuals. 
</p>
<p>The covariate-specific area under the curve is
</p>
<p style="text-align: center;"><code class="reqn">AUC(\mathbf{x})=\int_{0}^{1}ROC(p|\mathbf{x})dp,</code>
</p>

<p>and is computed numerically (using Simpson's rule). With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})=\int_0^{u_1} ROC(p|\mathbf{x})dp,</code>
</p>

<p>where again the integral is approximated numerically (Simpson's rule). The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})=\int_{u_2}^{1}ROC_{TNF}(p|\mathbf{x})dp,</code>
</p>

<p>where <code class="reqn">ROC_{TNF}(p|\mathbf{x})</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p|\mathbf{x}) = F_{\bar{D}}\{F_{D}^{-1}(1-p|\mathbf{x})|\mathbf{x}\}=G_{\bar{D}}\{\frac{\mu_{D}(x)-\mu_{\bar{D}}(x)}{\sigma_{\bar{D}}(x)}+G_{D}^{-1}(1-p)\frac{\sigma_{D}(x)}{\sigma_{\bar{D}}(x)}\}.</code> Again, the computation of the integral is done via Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>A data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if required) was computed.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>covariate</code></td>
<td>
<p>The value of the argument <code>covariate</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-specific ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-specific ROC curve (AROC), and <code>ci.level</code>*100% pointwise confidence band (if computed).</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-specific ROC curve, and <code>ci.level</code>*100% confidence interval (if computed).</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve and <code>ci.level</code>*100%  confidence interval (if computed). Note that the returned values are normalised, so that the maximum value is one.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component of the list contains the following information: (1) <code>bw.mean</code>: An object of class <code><a href="np.html#topic+np.regression.bw">npregbw</a></code> with the selected bandwidth for the nonparametric regression function. For further details, see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (2) <code>bw.var</code>: An object of class <code><a href="np.html#topic+np.regression.bw">npregbw</a></code> with the selected bandwidth for the nonparametric variance function. For further details, see  <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (3) <code>fit.mean</code>: An object of class <code><a href="np.html#topic+np.regression">npreg</a></code> with the nonparametric regression function estimate. For further details, see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>. (4) <code>fit.var</code>: An object of class <code><a href="np.html#topic+np.regression">npreg</a></code> with the nonparametric variance function estimate. For further details, see <code>R</code>-package <code><a href="np.html#topic+np-package">np</a></code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hayfield, T., and Racine, J. S.(2008). Nonparametric Econometrics: The np Package. Journal of Statistical Software 27(5). URL http://www.jstatsoft.org/v27/i05/.
</p>
<p>Rodriguez-Alvarez, M. X., Roca-Pardinas, J., and Cadarso-Suarez, C. (2011). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, <b>21</b>, 483&ndash;499.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.kernel">cROC.kernel</a></code> or <code><a href="#topic+cROC.sp">cROC.sp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_kernel &lt;- cROC.kernel(marker = "l_marker1",
               covariate = "age",
               group = "status", 
               tag.h = 0,
               data = newpsa, 
               bw = "LS",
               regtype = "LC",
               p = seq(0, 1, len = 101),
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               B = 500)

plot(cROC_kernel)

summary(cROC_kernel )


</code></pre>

<hr>
<h2 id='cROC.sp'>
Parametric and semiparametric frequentist inference of the covariate-specific ROC curve (cROC).
</h2><span id='topic+cROC.sp'></span>

<h3>Description</h3>

<p>This function estimates the covariate-specific ROC curve (cROC) using the parametric approach proposed by Faraggi (2003) and the semiparametric approach proposed by Pepe (1998).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cROC.sp(formula.h, formula.d, group, tag.h, data, 
  newdata, est.cdf = c("normal", "empirical"),
  pauc = pauccontrol(), p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95,
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cROC.sp_+3A_formula.h">formula.h</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the location regression model to be fitted in the healthy population (see Details).</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_formula.d">formula.d</code></td>
<td>
<p>A <code><a href="stats.html#topic+formula">formula</a></code> object specifying the location regression model to be fitted in the diseased population (see Details).</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying the healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_newdata">newdata</code></td>
<td>
<p>Optional data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if required) will be computed. If not supplied, the function <code><a href="#topic+cROCData">cROCData</a></code> is used to build a default dataset.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_est.cdf">est.cdf</code></td>
<td>
<p>A character string. It indicates how the conditional distribution functions of the diagnostic test in healthy and diseased populations are estimated. Options are &quot;normal&quot; and &quot;empirical&quot; (see Details). The default is &quot;normal&quot;.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the covariate-adjusted ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the covariate-specific ROC curve. This set is also used to compute the area under the covariate-specific ROC curve using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. By default 1000.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="cROC.sp_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the covariate-specific ROC curve (cROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|\mathbf{x}) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p|\mathbf{x})|\mathbf{x}\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y|\mathbf{x}) = Pr(Y_{D} \leq y | \mathbf{X}_{D} = \mathbf{x}),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y|\mathbf{x}) = Pr(Y_{\bar{D}} \leq y | \mathbf{X}_{\bar{D}} = \mathbf{x}).</code>
</p>

<p>Note that, for the sake of clarity, we assume that the covariates of interest are the same in both healthy and diseased populations. In particular, the method implemented in this function estimates <code class="reqn">F_{D}(\cdot|\mathbf{x})</code> and <code class="reqn">F_{\bar{D}}(\cdot|\mathbf{x})</code> assuming a (semiparametric) location regression model for <code class="reqn">Y</code> in each population separately, i.e., 
</p>
<p style="text-align: center;"><code class="reqn">Y_{D} = \mathbf{X}_{D}^{T}\mathbf{\beta}_{D} + \sigma_{D}\varepsilon_{D},</code>
</p>

<p style="text-align: center;"><code class="reqn">Y_{\bar{D}} = \mathbf{X}_{\bar{D}}^{T}\mathbf{\beta}_{\bar{D}} + \sigma_{\bar{D}}\varepsilon_{\bar{D}},</code>
</p>

<p>such that the covariate-specific ROC curve can be expressed as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p|\mathbf{x}) = 1 - G_{D}\{a(\mathbf{x}) + b G_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where <code class="reqn">a(\mathbf{x}) = \mathbf{x}^{T}\frac{\mathbf{\beta}_{\bar{D}} - \mathbf{\beta}_{D}}{\sigma_{D}}</code>, <code class="reqn">b = \frac{\sigma_{\bar{D}}}{\sigma_{D}}</code>, and <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code> are the distribution functions of <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code>, respectively. In line with the assumptions made about the distributions of <code class="reqn">\varepsilon_{D}</code> and <code class="reqn">\varepsilon_{\bar{D}}</code>, estimators will be referred to as: (a) &quot;normal&quot;, where Gaussian errors are assumed, i.e., <code class="reqn">G_{D}(y) = G_{\bar{D}}(y) = \Phi(y)</code> (Faraggi, 2003); and, (b) &quot;empirical&quot;, where no assumptios are made about the distribution (in this case, <code class="reqn">G_{D}</code> and <code class="reqn">G_{\bar{D}}</code> are empirically estimated on the basis of standardised residuals (Pepe, 1998)).
</p>
<p>The covariate-specific area under the curve is
</p>
<p style="text-align: center;"><code class="reqn">AUC(\mathbf{x})=\int_{0}^{1}ROC(p|\mathbf{x})dp.</code>
</p>

<p>When Gaussian errors are assumed, there is a closed-form expression for the covariate-specific AUC, which is used in the package. In contrast, when no assumptios are made about the distributionis of the errors, the integral is computed numerically using Simpson's rule. With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})=\int_0^{u_1} ROC(p|\mathbf{x})dp.</code>
</p>

<p>Again, when Gaussian errors are assumed, there is a closed-form expression (Hillis and Metz, 2012). Otherwise, the integral is approximated numerically (Simpson's rule). The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1|\mathbf{x})/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})=\int_{u_2}^{1}ROC_{TNF}(p|\mathbf{x})dp,</code>
</p>

<p>where <code class="reqn">ROC_{TNF}(p|\mathbf{x})</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as<code class="reqn">ROC_{TNF}(p|\mathbf{x}) = F_{\bar{D}}\{F_{D}^{-1}(1-p|\mathbf{x})|\mathbf{x}\}=G_{\bar{D}}\{\frac{\mu_{D}(\mathbf{x})-\mu_{\bar{D}}(\mathbf{x})}{\sigma_{\bar{D}}(\mathbf{x})}+G_{D}^{-1}(1-p)\frac{\sigma_{D}(\mathbf{x})}{\sigma_{\bar{D}}(\mathbf{x})}\}.</code> Again, when Gaussian errors are assumed, there is a closed-form expression (Hillis and Metz, 2012). Otherwise, the integral is approximated numerically (Simpson's rule). The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2|\mathbf{x})/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>newdata</code></td>
<td>
<p>A data frame containing the values of the covariates at which the covariate-specific ROC curve (AUC and pAUC, if required) was computed.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>The original supplied data argument.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether for each pair of observations (test outcomes and covariates) missing values occur.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>The name of the diagnostic test variable in the dataframe.</p>
</td></tr>
<tr><td><code>group</code></td>
<td>
<p>The value of the argument <code>group</code> used in the call.</p>
</td></tr>
<tr><td><code>tag.h</code></td>
<td>
<p>The value of the argument <code>tag.h</code> used in the call.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Named list of length two with the value of the arguments <code>formula.h</code> and <code>formula.d</code> used in the call.</p>
</td></tr>
<tr><td><code>est.cdf</code></td>
<td>
<p>The value of the argument <code>est.cdf</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the covariate-specific ROC curves have been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated covariate-specific ROC curve, and <code>ci.level</code>*100% pointwise confidence intervals (if computed).</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated area under the covariate-specific ROC curve, and <code>ci.level</code>*100% confidence interval (if computed). </p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the covariate-adjusted ROC curve and <code>ci.level</code>*100%  confidence interval (if computed). Note that the returned values are normalised, so that the maximum value is one.</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component contains an object of class <code><a href="stats.html#topic+lm">lm</a></code> with the fitted regression model.</p>
</td></tr>
<tr><td><code>coeff</code></td>
<td>
<p>Estimated regression coefficients (and <code>ci.level</code>*100% confidence interval if <code>B</code> greater than zero) from the fit of the linear model in the healthy and diseased population, as specified in <code>formula.h</code> and <code>formula.d</code>, respectively.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Faraggi, D. (2003). Adjusting receiver operating characteristic curves and related indices for covariates. <em>The Statistician</em> <b>52</b>, 179&ndash;192.
</p>
<p>Hillis, S. L. and Metz, C.E. (2012). An Analytic Expression for the Binormal Partial Area under the ROC Curve. Academic Radiology, <b>19</b>, 1491&ndash;1498.
</p>
<p>Pepe, M.S. (1998). Three approaches to regression analysis of receiver operating characteristic curves for continuous test results. <em>Biometrics</em> <b>54</b>, 124&ndash;135.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

# Covariate for prediction
agep &lt;- seq(min(newpsa$age), max(newpsa$age), length = 50)
df.pred &lt;- data.frame(age = agep)


cROC_sp_normal &lt;- cROC.sp(formula.h = l_marker1 ~ age,
                          formula.d = l_marker1 ~ age,
                          group = "status", 
                          tag.h = 0,
                          data = newpsa,
                          newdata = df.pred,
                          est.cdf = "normal",
                          pauc = list(compute = TRUE, value = 0.5, focus = "FPF"),
                          p = seq(0, 1, l = 101), 
                          B = 500)
summary(cROC_sp_normal)

plot(cROC_sp_normal)


</code></pre>

<hr>
<h2 id='cROCData'>
Selects an adequate set of points from a data set for obtaining predictions.
</h2><span id='topic+cROCData'></span>

<h3>Description</h3>

<p>Selects an adequate set of points from a data set for obtaining predictions 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cROCData(data, names.cov, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cROCData_+3A_data">data</code></td>
<td>
<p>Data set from which the new set of covariate values is obtained.</p>
</td></tr>
<tr><td><code id="cROCData_+3A_names.cov">names.cov</code></td>
<td>
<p>Character vector with the names of the covariates to be included in the new data set.</p>
</td></tr>
<tr><td><code id="cROCData_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable in the original data set that distinguishes healthy from diseased individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing selected values of all needed covariates. For those that are continuous, 30 different values are selected.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code>, <code><a href="#topic+cROC.kernel">cROC.kernel</a></code>, <code><a href="#topic+compute.threshold.cROC">compute.threshold.cROC</a></code> or <code><a href="#topic+compute.threshold.AROC">compute.threshold.AROC</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

newdf &lt;- cROCData(newpsa, "age", "status")

summary(newdf)
</code></pre>

<hr>
<h2 id='densitycontrol'>
(Conditional) density estimates of test outcomes
</h2><span id='topic+densitycontrol'></span>

<h3>Description</h3>

<p>This function is used to set various parameters controlling the estimation of the (conditional) density (densities) of test outcomes in both the healthy and diseased groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densitycontrol(compute = FALSE, grid.h = NA, grid.d = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densitycontrol_+3A_compute">compute</code></td>
<td>
<p>Logical value. If TRUE the (conditional) density (densities) of test outcomes in each group, healthy and diseased, are estimated.</p>
</td></tr>
<tr><td><code id="densitycontrol_+3A_grid.h">grid.h</code></td>
<td>
<p>Grid of test outcomes in the healthy group where the (conditional) density (densities) estimates are to be evaluated. Value <code>NA</code> signals autoinitialization, with default a vector of length 200 in the range of test outcomes in the healthy group.</p>
</td></tr>
<tr><td><code id="densitycontrol_+3A_grid.d">grid.d</code></td>
<td>
<p>Grid of test outcomes in the diseased group where the (conditional) density (densities) estimates are to be evaluated. Value <code>NA</code> signals autoinitialization, with default a vector of length 200 in the range of test outcomes in the diseased group.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by this function is used as a control argument of the <code><a href="#topic+cROC.bnp">cROC.bnp</a></code> and <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code> functions.
</p>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cROC.bnp">cROC.bnp</a></code> and <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))


</code></pre>

<hr>
<h2 id='densitycontrol.aroc'>
Conditional density estimates of test outcomes in the healthy population
</h2><span id='topic+densitycontrol.aroc'></span>

<h3>Description</h3>

<p>This function is used to set various parameters controlling the estimation of the conditional densities of test outcomes in the healthy group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>densitycontrol.aroc(compute = FALSE, grid.h = NA, newdata = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="densitycontrol.aroc_+3A_compute">compute</code></td>
<td>
<p>Logical value. If TRUE the conditional densities of test outcomes in the healthy group are estimated.</p>
</td></tr>
<tr><td><code id="densitycontrol.aroc_+3A_grid.h">grid.h</code></td>
<td>
<p>Grid of test outcomes in the healthy group where the conditional density estimates are to be evaluated. Value <code>NA</code> signals autoinitialization, with default a vector of length 200 in the range of test outcomes in the healthy group.</p>
</td></tr>
<tr><td><code id="densitycontrol.aroc_+3A_newdata">newdata</code></td>
<td>
<p>Data frame containing the values of the covariates at which the conditional density estimates are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by this function is used as a control argument of the <code><a href="#topic+AROC.bnp">AROC.bnp</a></code> function.
</p>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

# Covariate for prediction
agep &lt;- seq(min(newpsa$age), max(newpsa$age), length = 5)
df.pred &lt;- data.frame(age = agep)


AROC_bnp &lt;- AROC.bnp(formula.h =  l_marker1 ~ f(age, K = 0),
                     group = "status", 
                     tag.h = 0,
                     data = newpsa,
                     standardise = TRUE,
                     p = seq(0, 1, len = 101),
                     compute.lpml = TRUE,
                     compute.WAIC = TRUE,
                     compute.DIC = TRUE,
                     pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
                     density = densitycontrol.aroc(compute = TRUE, grid.h = NA, newdata = df.pred),
                     mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1)
)


</code></pre>

<hr>
<h2 id='endosyn'>
Simulated endocrine data.
</h2><span id='topic+endosyn'></span>

<h3>Description</h3>

<p>The <code>endosyn</code> data set was simulated based on the data analysed in Rodriguez-Alvarez et al. (2011a,b) and Inacio de Carvalho and Rodriguez-Alvarez (2018); and presented in Botana et al. (2007) and Tome et al. (2008). The aim of these studies was to use the body mass index (BMI) to detect patients having a higher risk of cardiovascular problems, ascertaining the possible effect of age and gender on the accuracy of this measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("endosyn")</code></pre>


<h3>Format</h3>

<p>A data frame with 2840 observations on the following 4 variables.
</p>

<dl>
<dt><code>gender</code></dt><dd><p>patient's gender. Factor with <code>Men</code> and <code>Women</code> levels.</p>
</dd>
<dt><code>age</code></dt><dd><p>patient's age.</p>
</dd>
<dt><code>cvd_idf</code></dt><dd><p>true disease status (presence/absence of two of more cardiovascular risk factors according to the International Diabetes Federation). Numerical vector (0 = absence, 1 = presence).</p>
</dd>
<dt><code>bmi</code></dt><dd><p>patient's body mass index.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Botana, M.A., Mato, J.A., Cadarso-Suarez, C., Tome, M.A., Perez-Fernandez, R., Fernandez-Mario, A., Rego-Iraeta, A., Solache, I. (2007). Overweight, obesity and central obesity prevalences in the region of Galicia in Northwest Spain. Obesity and Metabolism, 3, 106&ndash;115.
</p>
<p>Tome, M.A., Botana, M.A., Cadarso-Suarez, C., Rego-Iraeta, A., Fernandez-Mario, A., Mato, J.A, Solache, I., Perez-Fernandez, R. (2008). Prevalence of metabolic syndrome in Galicia (NW Spain) on four alternative definitions and association with insulin resistance. Journal of Endocrinological Investigation, 32, 505&ndash;511.
</p>


<h3>References</h3>

<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>
<p>Rodriguez-Alvarez, M.X., Roca-Pardinas, J. and Cadarso-Suarez, C. (2011a). ROC curve and covariates: extending induced methodology to the non-parametric framework. Statistics and Computing, 21(4), 483&ndash;49.
</p>
<p>Rodriguez- Alvarez, M.X., Roca-Pardinas, J. and Cadarso-Suarez, C. (2011b). A new flexible direct ROC regression model - Application to the detection of cardiovascular risk factors by anthropometric measures. Computational Statistics and Data Analysis, 55(12), 3257&ndash;3270.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(endosyn)
summary(endosyn)
</code></pre>

<hr>
<h2 id='mcmccontrol'>
Markov chain Monte Carlo (MCMC) parameters
</h2><span id='topic+mcmccontrol'></span>

<h3>Description</h3>

<p>This function is used to set various parameters controlling the Markov chain Monte Carlo (MCMC) parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmccontrol(nsave = 8000, nburn = 2000, nskip = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmccontrol_+3A_nsave">nsave</code></td>
<td>
<p>An integer giving the total number of scans to be saved (does not include the burn-in and thinning iterations). </p>
</td></tr>
<tr><td><code id="mcmccontrol_+3A_nburn">nburn</code></td>
<td>
<p>An integer giving the number of burn-in scans.</p>
</td></tr>
<tr><td><code id="mcmccontrol_+3A_nskip">nskip</code></td>
<td>
<p>An integer giving the thinning interval,</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by this function is used as a control argument of the <code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, and <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code> functions.
</p>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+AROC.bnp">AROC.bnp</a></code> and <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))


</code></pre>

<hr>
<h2 id='pauccontrol'>
Partial area under the covariate-adjusted/covariate-specific/pooled ROC curve
</h2><span id='topic+pauccontrol'></span>

<h3>Description</h3>

<p>Used to set various parameters controlling the estimation of the partial area under the covariate-adjusted/covariate-specific/pooled ROC curve .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pauccontrol(compute = FALSE, focus = c("FPF", "TPF"), value = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pauccontrol_+3A_compute">compute</code></td>
<td>
<p>Logical value. If TRUE the partial area under the covariate-adjusted/covariate-specific/pooled ROC curve is estimated.</p>
</td></tr>
<tr><td><code id="pauccontrol_+3A_focus">focus</code></td>
<td>
<p>Whether computation should be done over a restricted range of false positive fractions (FPF) or a restricted range of true positive fractions (TPF).</p>
</td></tr>
<tr><td><code id="pauccontrol_+3A_value">value</code></td>
<td>
<p>Numeric value. Pre-specified upper bound for the FPF (if focus = &quot;FPF&quot;) or lower bound for the TPF (if focus = &quot;TPF&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The value returned by this function is used as a control argument of the <code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code>, <code><a href="#topic+cROC.kernel">cROC.kernel</a></code> functions.
</p>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

# Covariate for prediction
agep &lt;- seq(min(newpsa$age), max(newpsa$age), length = 5)
df.pred &lt;- data.frame(age = agep)


cROC_sp_normal &lt;- cROC.sp(formula.h = l_marker1 ~ age,
                          formula.d = l_marker1 ~ age,
                          group = "status", 
                          tag.h = 0,
                          data = newpsa,
                          newdata = df.pred,
                          est.cdf = "normal",
                          pauc = list(compute = TRUE, value = 0.5, focus = "FPF"),
                          p = seq(0, 1, l = 101), 
                          B = 10)


</code></pre>

<hr>
<h2 id='plot.AROC'>
Default AROC plotting
</h2><span id='topic+plot.AROC'></span>

<h3>Description</h3>

<p>Takes a fitted <code>AROC</code> object produced by <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code> and plots the covariate-adjusted ROC curve (AROC) and associated area under the AROC (AAUC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
plot(x, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.AROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="plot.AROC_+3A_main">main</code></td>
<td>
<p>Character string with the overall title for the plot. If NULL, the default, the method used to estimate the AROC curve is depicted.</p>
</td></tr>
<tr><td><code id="plot.AROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

AROC_bnp &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
group = "status", tag.h = 0, data = newpsa, standardise = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE,
compute.DIC = TRUE)

plot(AROC_bnp)


</code></pre>

<hr>
<h2 id='plot.cROC'>
Default cROC plotting
</h2><span id='topic+plot.cROC'></span>

<h3>Description</h3>

<p>Takes a fitted <code>cROC</code> object produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code> and plots the covariate-specific ROC curve (cROC) and associated area under the cROC curve. The suitable type of graphic is chosen according to the number and nature of the covariates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cROC'
plot(x, ask = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>cROC</code> as produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="plot.cROC_+3A_ask">ask</code></td>
<td>
<p>A logical value. If TRUE, the default, the user is asked for confirmation, before a new figure is drawn.</p>
</td></tr>
<tr><td><code id="plot.cROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+cROC.kernel">cROC.kernel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

plot(cROC_bnp)


</code></pre>

<hr>
<h2 id='plot.pooledROC'>
Default pooledROC plotting
</h2><span id='topic+plot.pooledROC'></span>

<h3>Description</h3>

<p>Takes a fitted <code>pooledROC</code> object produced by <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code>, or <code>pooledROC.dpm</code> and plots the pooled ROC curve and associated area under the ROC curve (AUC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pooledROC'
plot(x, main = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pooledROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>pooledROC</code> as produced by <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code> or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>.</p>
</td></tr>
<tr><td><code id="plot.pooledROC_+3A_main">main</code></td>
<td>
<p>Character string with the overall title for the plot. If NULL, the default, the method used to estimate the pooled ROC curve is depicted.</p>
</td></tr>
<tr><td><code id="plot.pooledROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code> or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_emp &lt;- pooledROC.emp(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 500)

summary(m0_emp)

plot(m0_emp)


</code></pre>

<hr>
<h2 id='pooledROC.BB'>
Bayesian bootstrap estimation of the pooled ROC curve.
</h2><span id='topic+pooledROC.BB'></span>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using the Bayesian bootstrap estimator proposed by Gu et al. (2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.BB(marker, group, tag.h, data, 
	p = seq(0, 1, l = 101), B = 5000, ci.level = 0.95, pauc = pauccontrol(),
  	parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.BB_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of Bayesian bootstrap resamples. By default 5000.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="pooledROC.BB_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function makes use of the equivalence (see Gu et al., 2008)
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\} = 1 - Pr(1 - F_{\bar{D}}(Y_D) \leq p),</code>
</p>

<p>and estimates both <code class="reqn">F_{\bar{D}}</code> and the outer probability using the Bayesian bootstrap resampling distribution. 
</p>
<p>Regarding the area under the curve, we note that
</p>
<p style="text-align: center;"><code class="reqn">AUC = \int_{0}^{1}ROC(p)dp = 1 - E\{U_D\},</code>
</p>

<p>where <code class="reqn">U_D = 1 - F_{\bar{D}}(Y_D)</code>. In our implementation, the expectation is computed using the Bayesian bootstrap (using the same weights as those used to estimate the pooled ROC). As far as the partial area under the curve is concerned, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is 
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp = u_1 - E\{U_{D,u_1}\},</code>
</p>
 
<p>where <code class="reqn">U_{D,u_1} = \min\{u_1, 1 - F_{\bar{D}}(Y_D)\}</code>. Again, the expectation is computed using the Bayesian bootstrap. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as 
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
 
<p>where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}</code>. Thus
</p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp = E\{U_{\bar{D}, u_2} - u_2\},</code>
</p>
 
<p>where <code class="reqn">U_{\bar{D}, u_2} = \max\{u_2, 1 - F_{D}(Y_{\bar{D}})\}</code>, and the expectation is computed using the Bayesian bootstrap. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise credible band.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% credible interval.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve (posterior mean) and <code>ci.level</code>*100% credible interval. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>list with the Dirichlet weights (involved in the estimation) in the healthy (h) and diseased (d) groups. These are matrices of dimension n0 x B and n1 x B, where n0 is the number of healthy individuals and n1 is the number of diseased individuals. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Gu, J., Ghosal, S., and Roy, A. (2008). Bayesian bootstrap estimation of ROC curve. Statistics in Medicine, <b>27</b>, 5407&ndash;5420.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_BB &lt;- pooledROC.BB(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 5000)

summary(m0_BB)

plot(m0_BB)


</code></pre>

<hr>
<h2 id='pooledROC.dpm'>
Nonparametric Bayesian inference of the pooled ROC curve 
</h2><span id='topic+pooledROC.dpm'></span>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using a Dirichlet process mixture of normals model as proposed by Erkanli et al. (2006).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.dpm(marker, group, tag.h, data, 
  standardise = TRUE, p = seq(0, 1, l = 101), ci.level = 0.95, 
  compute.lpml = FALSE, compute.WAIC = FALSE, compute.DIC = FALSE, 
  pauc = pauccontrol(), density = densitycontrol(), 
  prior.h = priorcontrol.dpm(), prior.d = priorcontrol.dpm(),
  mcmc = mcmccontrol(),
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.dpm_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_standardise">standardise</code></td>
<td>
<p>A logical value. If TRUE the test outcomes are standardised (so that the resulting test outcomes have mean zero and standard deviation of one). The default is TRUE.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve. This set is also used to compute the area under the ROC curve (AUC) using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the level for the credible interval. The default is 0.95.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_compute.lpml">compute.lpml</code></td>
<td>
<p>A logical value. If TRUE, the log pseudo marginal likelihood (LPML, Geisser and Eddy, 1979) and the conditional predictive ordinates (CPO) are computed.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_compute.waic">compute.WAIC</code></td>
<td>
<p>A logical value. If TRUE, the widely applicable information criterion (WAIC, Gelman et al., 2014; Watanabe, 2010) is computed.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_compute.dic">compute.DIC</code></td>
<td>
<p>A logical value. If TRUE, the deviance information criterion is computed.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_density">density</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+densitycontrol">densitycontrol</a></code>. This argument is used to indicate whether the densities of the marker in the healthy and diseased population should be computed, and in case it is to be computed, at which grid of test outcomes in each of the populations.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_prior.h">prior.h</code></td>
<td>
<p>Hyparameter specification for the healthy population. A list of control values to replace the default values returned by the function <code><a href="#topic+priorcontrol.dpm">priorcontrol.dpm</a></code>. See <code><a href="#topic+priorcontrol.dpm">priorcontrol.dpm</a></code> for details.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_prior.d">prior.d</code></td>
<td>
<p>Hyparameter specification for the diseased population. A list of control values to replace the default values returned by the function <code><a href="#topic+priorcontrol.dpm">priorcontrol.dpm</a></code>. See <code><a href="#topic+priorcontrol.dpm">priorcontrol.dpm</a></code> for details.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_mcmc">mcmc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+mcmccontrol">mcmccontrol</a></code>. See <code><a href="#topic+mcmccontrol">mcmccontrol</a></code> for details.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="pooledROC.dpm_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function estimates <code class="reqn">F_{D}(\cdot)</code> and <code class="reqn">F_{\bar{D}}(\cdot)</code> by means of a Dirichlet process mixture of normals model. More precisely, and letting <code class="reqn">\{y_{\bar{D}i}\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{y_{Dj}\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, the model postulated for the distribution function is as follows
</p>
<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y_{\bar{D}i}) = \sum_{l=1}^{L_{\bar{D}}}\omega_{l\bar{D}}\Phi(y_{\bar{D}i}\mid\mu_{l\bar{D}},\sigma_{l\bar{D}}^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{D}(y_{Dj}) = \sum_{l=1}^{L_{D}}\omega_{lD}\Phi(y_{Dj}\mid\mu_{lD},\sigma_{lD}^2),</code>
</p>

<p>where <code class="reqn">L_{d}</code> is pre-specified is a pre-specified upper bound on the number of mixture components (<code class="reqn">d \in \{D, \bar{D}\}</code>). The <code class="reqn">\omega_{ld}</code>'s result from a truncated version of the stick-breaking construction (<code class="reqn">\omega_{1d} = v_{1d}</code>; <code class="reqn">\omega_{ld} = v_{ld}\prod_{r&lt;l}(1-v_{dr})</code>, <code class="reqn">l=2,\ldots,L_{d}</code>; <code class="reqn">v_{d1},\ldots,v_{L_{d}-1}\sim</code> Beta <code class="reqn">(1,\alpha_{d})</code>; <code class="reqn">v_{Ld} = 1</code>, <code class="reqn">\alpha_d \sim \Gamma(a_{\alpha_d},b_{\alpha_d})</code>), <code class="reqn">\beta_{ld}\sim N(m_{0d},S_{0d})</code>, and <code class="reqn">\sigma_{ld}^{-2}\sim\Gamma(a_{d},b_{d})</code>.
</p>
<p>The area under the curve is 
</p>
<p style="text-align: center;"><code class="reqn">AUC=\int_{0}^{1}ROC(p)dp.</code>
</p>
 
<p>When the upper bound on the number of mixture components is 1, i.e., <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the AUC (binormal model), which is used in the package. In contrast, when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code>, the AUC is computed using results presented in Erkanli et al. (2006). With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is </p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp.</code>
</p>
 
<p>As for the AUC, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{FPF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as </p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
<p> where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}.</code> Again, when <code class="reqn">L_d = 1</code> (<code class="reqn">d \in \{D, \bar{D}\}</code>), there is a closed-form expression for the <code class="reqn">pAUC_{TNF}</code> (Hillis and Metz, 2012), and when <code class="reqn">L_D &gt; 1</code> or <code class="reqn">L_{\bar{D}} &gt; 1</code> the integral is approximated numerically using Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>
<p>It is worth referring that with respect to the computation of the DIC, when <code class="reqn">L=1</code>, it is computed as in Spiegelhalter et al. (2002), and when <code class="reqn">L&gt;1</code>, DIC3 as described in Celeux et al. (2006) is computed. Also, for the computation of the conditional predictive ordinates (CPO) we follow the stable version proposed by Gelman et al. (2014).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>prior</code></td>
<td>
<p>A list returning the hyperparameter values in the healthy and diseased populations.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise credible band.</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% credible interval.</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve (posterior mean) and <code>ci.level</code>*100% pointwise credible band. Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
<tr><td><code>dens</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: <code>grid</code> (grid of test outcomes where the densities are evaluated) and <code>dens</code> (MCMC realisations of the corresponding densities).</p>
</td></tr>
<tr><td><code>lpml</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: the log pseudo marginal likelihood (LPML) and the conditional predictive ordinates (CPO).</p>
</td></tr>
<tr><td><code>WAIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: widely applicable information criterion (WAIC) and associated complexity penalty (pW).</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>If computed, named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with two components: deviance information criterion (DIC) and associated complexity penalty (pD).</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>Named list of length two, with components 'h' (healthy) and 'd' (diseased). Each component is a list with the following information: (1)<code>probs</code>: matrix of dimension nsave x L with the sampled components' weights; (2) <code>mu</code>: matrix of dimension nsave x L with the sampled means; and (3) <code>sd</code>: matrix of dimension nsave x L with the sampled standard deviations. Here, nsave is the number of Gibbs sampler iterates saved, and L is the upper bound on the number of mixture components.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Erkanli, A., Sung M., Jane Costello, E., and Angold, A. (2006). Bayesian semi-parametric ROC analysis. Statistics in Medicine, <b>25</b>, 3905&ndash;3928.
</p>
<p>Geisser, S. and Eddy, W.F. (1979) A Predictive Approach to Model Selection, Journal of the American Statistical Association, <b>74</b>, 153&ndash;160.
</p>
<p>Gelman, A., Carlin, J.B., Stern, H.S., Dunson, D.B., Vehtari, A., and Rubin, D.B. (2014). Bayesian Data Analysis, 3rd ed. CRC Press: Boca Raton, FL.
</p>
<p>Gelman, A., Hwang, J., and Vehtari, A. (2014). Understanding predictive information criteria for Bayesian models. Statistics and Computing, <b>24</b>, 997&ndash;1010.
</p>
<p>Hillis, S. L. and Metz, C.E. (2012). An Analytic Expression for the Binormal Partial Area under the ROC Curve. Academic Radiology, <b>19</b>, 1491&ndash;1498.
</p>
<p>Watanabe, S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely Applicable Information Criterion in Singular Learning Theory. Journal of Machine Learning Research, <b>11</b>, 3571&ndash;3594.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_dpm &lt;- pooledROC.dpm(marker = "l_marker1", group = "status",
            tag.h = 0, data = newpsa, standardise = TRUE, 
            p = seq(0,1,l=101), compute.WAIC = TRUE, compute.lpml = TRUE, 
            compute.DIC = TRUE, 
            prior.h = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            prior.d = priorcontrol.dpm(m0 = 0, S0 = 10, a = 2, b = 0.5, alpha = 1, 
            L =10),
            mcmc = mcmccontrol(nsave = 400, nburn = 100, nskip = 1))

summary(m0_dpm)

plot(m0_dpm)

  
</code></pre>

<hr>
<h2 id='pooledROC.emp'>
Empirical estimation of the pooled ROC curve.
</h2><span id='topic+pooledROC.emp'></span>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using the empirical estimator proposed by Hsieh and Turnbull (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.emp(marker, group, tag.h, data, 
	p = seq(0, 1, l = 101), B = 1000, ci.level = 0.95, 
    method = c("ncoutcome", "coutcome"), pauc = pauccontrol(),
  	parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.emp_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_method">method</code></td>
<td>
<p>A character string specifying if bootstrap resampling (for the confidence intervals) should be done with or without regard to the disease status (&ldquo;coutcome&rdquo; or &ldquo;noutcome&rdquo;). In both cases, a naive bootstrap is used. By default, the resampling is done conditionally on the disease status.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="pooledROC.emp_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function estimates <code class="reqn">F_{D}(\cdot)</code> and <code class="reqn">F_{\bar{D}}(\cdot)</code> by means of the empirical dsitributions. More precisely, and letting <code class="reqn">\{y_{\bar{D}i}\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{y_{Dj}\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, the distribution functions in each group take the form
</p>
<p style="text-align: center;"><code class="reqn">\widehat{F}_{D}(y)=\frac{1}{n_D}\sum_{j=1}^{n_D}I(y_{Dj}\leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">\widehat{F}_{\bar{D}}(y)=\frac{1}{n_{\bar{D}}}\sum_{i=1}^{n_{\bar{D}}}I(y_{\bar{D}i}\leq y).</code>
</p>

<p>The area under the curve is </p>
<p style="text-align: center;"><code class="reqn">AUC=\int_{0}^{1}ROC(p)dp</code>
</p>
<p> and is estimated empirically by means of the Mann-Whitney U-statistic. With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is </p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp,</code>
</p>
<p> where again is estimated empirically. The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as </p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
<p> where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}.</code> Again, <code class="reqn">ROC_{TNF}(p)</code> is estimated empirically. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise confidence band (if computed).</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% confidence interval (if computed).</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve along with its <code>ci.level</code>*100% confidence interval (if B greater than zero). Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hsieh, F., and Turnbull, B.W. (1996). Nonparametric and semiparametric estimation of the receiver operating characteristic curve, The Annals of Statistics, <b>24</b>, 25&ndash;40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_emp &lt;- pooledROC.emp(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 10,
method = "coutcome", pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"))

summary(m0_emp)

plot(m0_emp)


</code></pre>

<hr>
<h2 id='pooledROC.kernel'>
Kernel-based estimation of the pooled ROC curve.
</h2><span id='topic+pooledROC.kernel'></span>

<h3>Description</h3>

<p>This function estimates the pooled ROC curve using the kernel-based density estimator proposed by Zhou et al. (1997).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROC.kernel(marker, group, tag.h, data, 
	p = seq(0, 1, l = 101), 
	bw = c("SRT", "UCV"), B = 1000, ci.level = 0.95, 
	method = c("ncoutcome", "coutcome"), pauc = pauccontrol(),
  parallel = c("no", "multicore", "snow"), ncpus = 1, cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROC.kernel_+3A_marker">marker</code></td>
<td>
<p>A character string with the name of the diagnostic test variable.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_group">group</code></td>
<td>
<p>A character string with the name of the variable that distinguishes healthy from diseased individuals.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_tag.h">tag.h</code></td>
<td>
<p>The value codifying healthy individuals in the variable <code>group</code>.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_data">data</code></td>
<td>
<p>Data frame representing the data and containing all needed variables.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_p">p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which to estimate the pooled ROC curve. This set is also used to compute the area under the ROC curve (AUC) using Simpson's rule. Thus, the length of the set should be an odd number, and it should be rich enough for an accurate estimation.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_bw">bw</code></td>
<td>
<p>A character string specifying the density bandwidth selection method. &ldquo;SRT&rdquo;: Silverman's rule-of-thumb; &ldquo;UCV&rdquo;: unbiased cross-validation. The default is &ldquo;SRT&rdquo;. </p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_b">B</code></td>
<td>
<p>An integer value specifying the number of bootstrap resamples for the construction of the confidence intervals. The default is 1000.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_ci.level">ci.level</code></td>
<td>
<p>An integer value (between 0 and 1) specifying the confidence level. The default is 0.95.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_method">method</code></td>
<td>
<p>A character string specifying if bootstrap resampling (for the confidence intervals) should be done with or without regard to the disease status (&ldquo;coutcome&rdquo; or &ldquo;noutcome&rdquo;). In both cases, a naive bootstrap is used. By default, the resampling is done conditionally on the disease status.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_pauc">pauc</code></td>
<td>
<p>A list of control values to replace the default values returned by the function <code><a href="#topic+pauccontrol">pauccontrol</a></code>. This argument is used to indicate whether the partial area under the pooled ROC curve should be computed, and in case it is computed, whether the focus should be placed on restricted false positive fractions (FPFs) or on restricted true positive fractions (TPFs), and the upper bound for the FPF (if focus is FPF) or the lower bound for the TPF (if focus is TPF).</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_parallel">parallel</code></td>
<td>
<p>A characters string with the type of parallel operation: either &quot;no&quot; (default), &quot;multicore&quot; (not available on Windows) or &quot;snow&quot;.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_ncpus">ncpus</code></td>
<td>
<p>An integer with the number of processes to be used in parallel operation. Defaults to 1.</p>
</td></tr>
<tr><td><code id="pooledROC.kernel_+3A_cl">cl</code></td>
<td>
<p>An object inheriting from class <code>cluster</code> (from the <code>parallel</code> package), specifying an optional parallel or snow cluster if parallel = &quot;snow&quot;. If not supplied, a cluster on the local machine is created for the duration of the call.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimates the pooled ROC curve (ROC) defined as
</p>
<p style="text-align: center;"><code class="reqn">ROC(p) = 1 - F_{D}\{F_{\bar{D}}^{-1}(1-p)\},</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y) = Pr(Y_{D} \leq y),</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y) = Pr(Y_{\bar{D}} \leq y).</code>
</p>

<p>The method implemented in this function estimates <code class="reqn">F_{D}(\cdot)</code> and <code class="reqn">F_{\bar{D}}(\cdot)</code> by means of kernel methods. More precisely, and letting <code class="reqn">\{y_{\bar{D}i}\}_{i=1}^{n_{\bar{D}}}</code>  and <code class="reqn">\{y_{Dj}\}_{j=1}^{n_{D}}</code> be two independent random samples from the nondiseased and diseased populations, respectively, the distribution functions in each group take the form
</p>
<p style="text-align: center;"><code class="reqn">F_{D}(y)=\frac{1}{n_{D}}\sum_{j=1}^{n_D}\Phi\left(\frac{y-y_{Dj}}{h_D}\right).</code>
</p>

<p style="text-align: center;"><code class="reqn">F_{\bar{D}}(y)=\frac{1}{n_{\bar{D}}}\sum_{i=1}^{n_D}\Phi\left(\frac{y-y_{\bar{D}i}}{h_{\bar{D}}}\right).</code>
</p>

<p>where <code class="reqn">\Phi(y)</code> stands for the standard normal distribution function evaluated at <code class="reqn">y</code>. For the bandwidth <code class="reqn">h_d</code>, <code class="reqn">d \in \{D,\bar{D}\}</code> which controls the amount of smoothing, two options are available. When <code>bw = "SRT"</code>, </p>
<p style="text-align: center;"><code class="reqn">h_{d}=0.9\min\{SD(\mathbf{y}_d),IQR(\mathbf{y}_d)/1.34\}n_{d}^{-0.2},</code>
</p>
<p> where <code class="reqn">SD(\mathbf{y}_d)</code> and <code class="reqn">IQR(\mathbf{y}_d)</code> are the standard deviation and interquantile range, respectively, of <code class="reqn">\mathbf{y}_d=(y_{d1},\ldots,y_{dn_{d}})</code>. In turn, when <code>bw = "UCV"</code>, the bandwidth is selected via unbiased cross-validation, for further details we refer to <code>bw.ucv</code> from the base package <code>stats</code>.
</p>
<p>The area under the curve is </p>
<p style="text-align: center;"><code class="reqn">AUC=\int_{0}^{1}ROC(p)dp</code>
</p>
<p> and is computed numerically (using Simpson's rule). With regard to the partial area under the curve, when <code>focus = "FPF"</code> and assuming an upper bound <code class="reqn">u_1</code> for the FPF, what it is computed is </p>
<p style="text-align: center;"><code class="reqn">pAUC_{FPF}(u_1)=\int_0^{u_1} ROC(p)dp,</code>
</p>
<p> where again the integral is approximated numerically (Simpson's rule). The returned value is the normalised pAUC, <code class="reqn">pAUC_{FPF}(u_1)/u_1</code> so that it ranges from <code class="reqn">u_1/2</code> (useless test) to 1 (perfect marker). Conversely, when <code>focus = "TPF"</code>, and assuming a lower bound for the TPF of <code class="reqn">u_2</code>, the partial area corresponding to TPFs lying in the interval <code class="reqn">(u_2,1)</code> is computed as </p>
<p style="text-align: center;"><code class="reqn">pAUC_{TPF}(u_2)=\int_{u_2}^{1}ROC_{TNF}(p)dp,</code>
</p>
<p> where <code class="reqn">ROC_{TNF}(p)</code> is a <code class="reqn">270^\circ</code> rotation of the ROC curve, and it can be expressed as <code class="reqn">ROC_{TNF}(p) = F_{\bar{D}}\{F_{D}^{-1}(1-p)\}.</code> Again, the computation of the integral is done via Simpson's rule. The returned value is the normalised pAUC, <code class="reqn">pAUC_{TPF}(u_2)/(1-u_2)</code>, so that it ranges from <code class="reqn">(1-u_2)/2</code> (useless test) to 1 (perfect test).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>marker</code></td>
<td>
<p>A list with the diagnostic test outcomes in the healthy (h) and diseased (d) groups.</p>
</td></tr>
<tr><td><code>missing.ind</code></td>
<td>
<p>A logical value indicating whether missing values occur.</p>
</td></tr>
<tr><td><code>bws</code></td>
<td>
<p>Named list of length two with components 'h' (healthy) and 'd' (diseased). Each component is a numeric value with the selected bandwidth.</p>
</td></tr>
<tr><td><code>bw</code></td>
<td>
<p>The value of the argument <code>bw</code> used in the call.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>Set of false positive fractions (FPF) at which the pooled ROC curve has been estimated.</p>
</td></tr>
<tr><td><code>ci.level</code></td>
<td>
<p>The value of the argument <code>ci.level</code> used in the call.</p>
</td></tr>
<tr><td><code>ROC</code></td>
<td>
<p>Estimated pooled ROC curve, and corresponding <code>ci.level</code>*100% pointwise confidence band (if computed).</p>
</td></tr>
<tr><td><code>AUC</code></td>
<td>
<p>Estimated pooled AUC, and corresponding <code>ci.level</code>*100% confidence interval (if computed).</p>
</td></tr>
<tr><td><code>pAUC</code></td>
<td>
<p>If computed, estimated partial area under the pooled ROC curve along with its <code>ci.level</code>*100% confidence interval (if B greater than zero). Note that the returned values are normalised, so that the maximum value is one (see more on Details).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zou, K.H., Hall, W.J., Shapiro, D.E. (1997) Smooth non-parametric receiver operating characteristic (ROC) curves for continuous diagnostic tests. Statistics in Medicine, <b>16</b>, 2143&ndash;2156.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code>, <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>, <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_kernel &lt;- pooledROC.kernel(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), bw = "SRT",
B = 500, method = "coutcome", 
pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"))

summary(m0_kernel)

plot(m0_kernel)


</code></pre>

<hr>
<h2 id='predictive.checks'>
Posterior predictive checks.
</h2><span id='topic+predictive.checks'></span>

<h3>Description</h3>

<p>Implements posterior predictive checks for objects of <code>AROC</code> or <code>cROC</code> as produced by <code>AROC.bnp</code> or <code>cROC.bnp</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predictive.checks(object, 
	statistics = c("min", "max", "kurtosis", "skewness"), 
	ndensity = 512, devnew = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predictive.checks_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> or <code>cROC</code> as produced by <code>AROC.bnp</code> or <code>cROC.bnp</code>.</p>
</td></tr>
<tr><td><code id="predictive.checks_+3A_statistics">statistics</code></td>
<td>
<p>Character vector. Statistics to be used for the posterior predictive checking. By default, &quot;min&quot;, &quot;max&quot;, &quot;kurtosis&quot; and &quot;skewness&quot;</p>
</td></tr>
<tr><td><code id="predictive.checks_+3A_ndensity">ndensity</code></td>
<td>
<p>An integer giving the number of equally spaced points at which the density of the test outcomes and of the simulated datasets from the posterior predictive distribution (see more on Details) is to be estimated (for more details see the help of the function <code>density</code> in the <code>stats</code> package).</p>
</td></tr>
<tr><td><code id="predictive.checks_+3A_devnew">devnew</code></td>
<td>
<p>A logical value. If TRUE, each plot is depicted in a new graphic device.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Compares a selected test statistic computed based on the observed diagnostic test outcome (either in the nondiseased group, <code>AROC</code> object, or in both the nondiseased and diseased groups, <code>cROC</code> object) against the same test statistics computed based on simulated data from the posterior predictive distribution of the diagnostic test outcome obtained using a single-weights linear dependent Dirichlet process mixture of normals model.
The following graphics are depicted: (1) histograms of the desired statistics computed from simulated datasets (nsave of them) from the posterior predictive distribution of the diagnostic test outcome. In these plots, the estimated statistics from the observed diagnostic test outcome are also depicted. (2) Kernel density estimates computed computed from simulated datasets (nsave of them) from the posterior predictive distribution of the diagnostic test outcome. In these plots, the kernel density estimate of the observed diagnostic test outcome is also depicted. In the case of an object of class <code>AROC</code>, the abovementioned graphics are depicted only for the diagnostic test outcome in the nondiseased group. However, for an object of class <code>cROC</code>, the graphics are depicted, separately, for both the nondiseased and diseased groups. For a detailed discussion about predictive checks, see Gabry et al. (2019).
</p>


<h3>Value</h3>

<p>As a result, the function provides a list with the following components:
</p>
<table>
<tr><td><code>yrep</code></td>
<td>
<p>List of matrices associated with the diseased (d) and nondiseased (h) groups. Each column of the matrix (there are nsave of them) corresponds to a dataset generated from the posterior predictive distribution of the diagnostic test outcomes. For <code>AROC</code> objects, the list only contains results for the nondiseased group.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>List of numeric vectors associated with the diseased (d) and nondiseased (h) groups. The vector contains the observed diagnostic test outcomes. For <code>AROC</code> objects, the list only contains results for the nondiseased group.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gabry, J., Simpson, D., Vehtari, A., Betancourt, M., and Gelman, A. (2019). Visualization in Bayesian workflow. Journal of the Royal Statistical Society, Series A, 182, 1&ndash;14.
</p>
<p>Inacio de Carvalho, V., and Rodriguez-Alvarez, M. X. (2018). Bayesian nonparametric inference for the covariate-adjusted ROC curve. arXiv preprint arXiv:1806.00473.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

AROC_bnp &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
group = "status", tag.h = 0, data = newpsa, standardise = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE)

predictive.checks(AROC_bnp, statistics = "skewness")


</code></pre>

<hr>
<h2 id='print.AROC'>
Print method for <code>AROC</code> objects
</h2><span id='topic+print.AROC'></span>

<h3>Description</h3>

<p>Default print method for objects fitted with <code>AROC.bnp()</code>, <code>AROC.sp()</code>, and <code>AROC.kernel()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.AROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="print.AROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed including the area under the covariate-adjusted ROC curve (AAUC), and if required, the partial area under the covariate-adjusted ROC curve (pAAUC).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

AROC_bnp &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
group = "status", tag.h = 0, data = newpsa, standardise = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE)

AROC_bnp


</code></pre>

<hr>
<h2 id='print.cROC'>
Print method for <code>cROC</code> objects
</h2><span id='topic+print.cROC'></span>

<h3>Description</h3>

<p>Default print method for objects fitted with <code>cROC.bnp()</code>, <code>cROC.sp()</code> and <code>cROC.kernel()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cROC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>cROC</code> as produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code> or <code>cROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="print.cROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+cROC.kernel">cROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

cROC_bnp


</code></pre>

<hr>
<h2 id='print.pooledROC'>
Print method for <code>pooledROC</code> objects
</h2><span id='topic+print.pooledROC'></span>

<h3>Description</h3>

<p>Default print method for objects fitted with <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code> or <code>pooledROC.dpm</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pooledROC'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pooledROC_+3A_x">x</code></td>
<td>
<p>An object of class <code>pooledROC</code> as produced by <code>pooledROC.BB</code>, <code>pooledROC.emp</code>, <code>pooledROC.kernel</code> or <code>pooledROC.dpm</code> functions.</p>
</td></tr>
<tr><td><code id="print.pooledROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed including the area under the pooled ROC curve (AUC).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code> or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_emp &lt;- pooledROC.emp(marker = "l_marker1", group = "status",
tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 500)

summary(m0_emp)

plot(m0_emp)


</code></pre>

<hr>
<h2 id='priorcontrol.bnp'>
Prior information for the <code>AROC.bnp</code> and <code>cROC.bnp</code>
</h2><span id='topic+priorcontrol.bnp'></span>

<h3>Description</h3>

<p>This function is used to set various parameters controlling the prior information to be used in the <code>AROC.bnp</code> and  <code>cROC.bnp</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorcontrol.bnp(m0 = NA, S0 = NA, nu = NA, Psi = NA, a = 2, b = NA, 
	alpha = 1, L = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorcontrol.bnp_+3A_m0">m0</code></td>
<td>
<p>A numeric vector. Hyperparameter; mean vector of the (multivariate) normal prior distribution for the mean of the normal component of the centring distribution. <code>NA</code> signals autoinitialization, with defaults: a vector, of length <code class="reqn">Q</code>, of zeros, if the data are standardised and the least squares estimates of the regression coefficients if the data are not standardised.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_s0">S0</code></td>
<td>
<p>A numeric matrix. Hyperparameter; covariance matrix of the (multivariate) normal prior distribution for the mean of the normal component of the centring distribution. <code>NA</code> signals autoinitialization, with defaults: 10<code class="reqn">I_{Q\times Q}</code> if the data are standardised and <code class="reqn">\mathbf{\hat{\Sigma}}</code> if the data are not standardised, where <code class="reqn">\mathbf{\hat{\Sigma}}</code> is the estimated covariance matrix of the regression coefficients obtained by fitting a linear model to the data.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_nu">nu</code></td>
<td>
<p>A numeric value. Hyperparameter; degrees of freedom of the Wishart prior distribution for the precision matrix of the the normal component of the centring distribution.<code>NA</code> signals autoinitialization, with default: <code class="reqn">Q+2</code> where <code class="reqn">Q</code> is the number of columns of the design matrix.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_psi">Psi</code></td>
<td>
<p>A numeric matrix. Hyperparameter; scale matrix of the Wishart distribution for the precision matrix of the the normal component of the centring distribution. <code>NA</code> signals autoinitialization, with defaults: <code class="reqn">I_{Q\times Q}</code> if the data are standardised and to 30<code class="reqn">\mathbf{\hat{\Sigma}}</code> if the data are not standardised, where <code class="reqn">\mathbf{\hat{\Sigma}}</code> is the estimated covariance matrix of the regression coefficients obtained by fitting a linear model to the data.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_a">a</code></td>
<td>
<p>A numeric value. Hyperparameter; shape parameter of the gamma prior distribution for the precisions (inverse variances) of each component. The default is 2.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_b">b</code></td>
<td>
<p>A numeric value. Hyperparameter; shape parameter of the gamma prior distribution for the precisions (inverse variances) of each component. <code>NA</code> signals autoinitialization, with defaults: 0.5 if the data are standardised and <code class="reqn">\frac{\hat{\sigma}^2}{2}</code> if the data are not standardised</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value. Precision parameter of the Dirichlet Process. The default is 1.</p>
</td></tr>
<tr><td><code id="priorcontrol.bnp_+3A_l">L</code></td>
<td>
<p>A numeric value. Upper bound on the number of mixture components. Setting L = 1 corresponds to a normal model. The default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code> and  <code><a href="#topic+cROC.bnp">cROC.bnp</a></code>
</p>

<hr>
<h2 id='priorcontrol.dpm'>
Prior information for the <code>pooledROC.dpm</code>
</h2><span id='topic+priorcontrol.dpm'></span>

<h3>Description</h3>

<p>This function is used to set various parameters controlling the prior information to be used in the <code>pooledROC.dpm</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priorcontrol.dpm(m0 = NA, S0 = NA, a = 2, b = NA, alpha = 1, L = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priorcontrol.dpm_+3A_m0">m0</code></td>
<td>
<p>A numeric value. Hyperparameter; mean of the normal prior distribution for the means of each component. <code>NA</code> signals autoinitialization, with defaults: 0 if the data are standardised and <code class="reqn">\bar{y}_d</code> (<code class="reqn">d \in \{D, \bar{D}\}</code> if the data are not standardised.</p>
</td></tr>
<tr><td><code id="priorcontrol.dpm_+3A_s0">S0</code></td>
<td>
<p>A numeric value. Hyperparameter; variance of the normal prior distribution for the means of each component. <code>NA</code> signals autoinitialization, with defaults: 10 if the data are standardised and 100*<code class="reqn">\frac{s^2_d}{n_d}</code> (<code class="reqn">d \in \{D, \bar{D}\}</code> if the data are not standardised, where <code class="reqn">s_d</code> denotes the sample standard deviation.</p>
</td></tr>
<tr><td><code id="priorcontrol.dpm_+3A_a">a</code></td>
<td>
<p>A numeric value. Hyperparameter; shape parameter of the gamma prior distribution for the precisions (inverse variances) of each component. The default is 2.</p>
</td></tr>
<tr><td><code id="priorcontrol.dpm_+3A_b">b</code></td>
<td>
<p>A numeric value. Hyperparameter; rate parameter of the gamma prior distribution for the precisions (inverse variances) of each component. <code>NA</code> signals autoinitialization, with defaults: 0.5 if the data are standardised and <code class="reqn">\frac{s^2_d}{2}</code> (<code class="reqn">d \in \{D, \bar{D}\}</code> if the data are not standardised.</p>
</td></tr>
<tr><td><code id="priorcontrol.dpm_+3A_alpha">alpha</code></td>
<td>
<p>A numeric value. Precision parameter of the Dirichlet Process. The default is 1.</p>
</td></tr>
<tr><td><code id="priorcontrol.dpm_+3A_l">L</code></td>
<td>
<p>A numeric value. Upper bound on the number of mixture components. Setting L=1 corresponds to a normal model. The default is 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components for each of the possible arguments.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>
</p>

<hr>
<h2 id='psa'>
Prostate specific antigen (PSA) biomarker study.
</h2><span id='topic+psa'></span>

<h3>Description</h3>

<p>The dataset contains 71 prostate cases and 71 controls who participated in a lung cancer prevention trial (CARET, Beta-carotene and retinol trial). For details, see  Etzioni et al. (1999) and Pepe (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("psa")</code></pre>


<h3>Format</h3>

<p>A data frame with 683 observations on the following 6 variables.
</p>

<dl>
<dt><code>id</code></dt><dd><p>Patient identifier.</p>
</dd>
<dt><code>marker1</code></dt><dd><p>Total prostate specific antigen (PSA).</p>
</dd>
<dt><code>marker2</code></dt><dd><p>Free prostate specific antigen (PSA)</p>
</dd>
<dt><code>status</code></dt><dd><p>Presence/absence of prostate cancer. The non-cancer patients are controls matched to cases on age and number of serum samples available for analysis (see Details).</p>
</dd>
<dt><code>age</code></dt><dd><p>Patient age at blood draw (serum sample).</p>
</dd>
<dt><code>t</code></dt><dd><p>Time (years) relative to prostate cancer diagnosis.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The CARET enrolled 12000 men, aged between 50 and 65 years, at high risk of lung cancer. For each subject on the study, serum samples were drawn at baseline and at two-year intervals after that. The data presented here represent a subsample of the original sample, and it was reported by Etzioni et al. (1999). It contains 71 cases of prostate cancer that occurred during the study. All these cases had, at least, three and up to eight serum samples. As far as controls are concerned, they were selected from the participants of the CARET study verifying that they had not been diagnosed with prostate cancer by the time of the original study, and the selection was done by matching to cases on date of birth and number of serum samples available for analysis.
</p>


<h3>Source</h3>

<p>The dataset can be downloaded from <a href="https://research.fredhutch.org/diagnostic-biomarkers-center/en/datasets.html">https://research.fredhutch.org/diagnostic-biomarkers-center/en/datasets.html</a>.										
</p>


<h3>References</h3>

<p>Pepe, M. S. (2003). The Statistical Evaluation of Medical Tests for Classification and Prediction. Oxford Statistical Science Series. Oxford University Press, New York. 
</p>
<p>Etzioni, R., Pepe, M. S., Longton, G., Hu. C., and Goodman, G. (1999). Incorporating the time dimension in receiver operating characteristic curves: A case study of prostate cancer. Medical Decision Making, 19(3), 242-251.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(psa)
summary(psa)
</code></pre>

<hr>
<h2 id='summary.AROC'>
Summary method for <code>AROC</code> objects
</h2><span id='topic+summary.AROC'></span>

<h3>Description</h3>

<p>Default summary method for objects fitted with <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'AROC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.AROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>AROC</code> as produced by <code>AROC.bnp()</code>, <code>AROC.sp()</code>, or <code>AROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="summary.AROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information printed depends on the method. In all cases, the call to the function, the method, the area under the covariate-adjusted ROC curve (AAUC), the partial area under the covariate-adjusted ROC curve (if required) (AAUC), and the sample sizes are printed. For the semiparametric approach (<code>AROC.sp()</code>), the estimated coefficients (and 95% confidence intervals, if required) of the model for the healthy population are printed. In addition, the function provides the Akaike Information Criterion (AIC) and the Bayesian Information Criterion (BIC). For the nonparametric Bayesian approach (<code>AROC.bnp()</code>), and if required, the function provides the log pseudo marginal likelihood (LPML), the widely applicable information criterion (WAIC) and/or the deviance information criterion (DIC). For the kernel-based approach (<code>AROC.kernel()</code>), information regarding the selected bandwidth and the type of kernel estimator (for both regression and variance functions) is printed.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AROC.bnp">AROC.bnp</a></code>, <code><a href="#topic+AROC.sp">AROC.sp</a></code> or <code><a href="#topic+AROC.kernel">AROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0 &lt;- AROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
group = "status", tag.h = 0, data = newpsa, standardise = TRUE,
p = seq(0,1,l=101), compute.lpml = TRUE, compute.WAIC = TRUE)

summary(m0)


</code></pre>

<hr>
<h2 id='summary.cROC'>
Summary method for <code>cROC</code> objects
</h2><span id='topic+summary.cROC'></span>

<h3>Description</h3>

<p>Default summary method for objects fitted with <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cROC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>cROC</code> as produced by <code>cROC.bnp()</code>, <code>cROC.sp()</code>, or <code>cROC.kernel()</code>.</p>
</td></tr>
<tr><td><code id="summary.cROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information printed depends on the method. In all cases, the call to the function, the method, and the sample sizes are printed. For the semiparametric approach (<code>cROC.sp()</code>), the estimated coefficients (and 95% confidence intervals, if required) of the model for the healthy population, the diseased population and the conditional ROC curve, are printed. In addition, the function provides the Akaike Information Criterion (AIC) and the Bayesian Information Criterion (BIC). For the nonparametric Bayesian approach (<code>cROC.bnp()</code>), and if required, the function provides the log pseudo marginal likelihood (LPML), the widely applicable information criterion (WAIC) and/or the deviance information criterion (DIC) (for both healthy and diseased populations). For the kernel-based approach (<code>cROC.kernel()</code>), information regarding the selected bandwidths and the type of kernel estimator(for both healthy and diseased populations and for both regression and variance functions) is printed.
</p>


<h3>References</h3>

<p>Rodriguez-Alvarez, M.X., Tahoces, P.G., Cadarso-Suarez, C. and Lado, M.J. (2011). Comparative study of ROC regression techniques. Applications for the computer-aided diagnostic system in breast cancer detection. <em>Computational Statistics and Data Analysis</em>, <b>55</b>, 888&ndash;902.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cROC.bnp">cROC.bnp</a></code>, <code><a href="#topic+cROC.sp">cROC.sp</a></code> or <code><a href="#topic+cROC.kernel">cROC.kernel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

cROC_bnp &lt;- cROC.bnp(formula.h = l_marker1 ~ f(age, K = 0),
               formula.d = l_marker1 ~ f(age, K = 0),
               group = "status", 
               tag.h = 0,
               data = newpsa,
               standardise = TRUE, 
               p = seq(0, 1, len = 101),
               compute.lpml = TRUE, 
               compute.WAIC = TRUE,
               compute.DIC = TRUE, 
               pauc = pauccontrol(compute = TRUE, value = 0.5, focus = "FPF"),
               density = densitycontrol(compute = TRUE, grid.h = NA, grid.d = NA),
               mcmc = mcmccontrol(nsave = 500, nburn = 100, nskip = 1))

summary(cROC_bnp)


</code></pre>

<hr>
<h2 id='summary.pooledROC'>
Summary method for <code>pooledROC</code> objects
</h2><span id='topic+summary.pooledROC'></span>

<h3>Description</h3>

<p>Default summary method for objects fitted with <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pooledROC'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pooledROC_+3A_object">object</code></td>
<td>
<p>An object of class <code>pooledROC</code> as produced by <code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code>, or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>.</p>
</td></tr>
<tr><td><code id="summary.pooledROC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods. Not yet implemented.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A short summary is printed including the call to the function, the method, samples sizes, the area under the pooled ROC curve (AUC), and if required, the partial area under the pooled ROC curve. For the nonparametric Bayesian approach (<code>pooledROC.dpm()</code>), and if required, the function provides the log pseudo marginal likelihood (LPML), the widely applicable information criterion (WAIC) and/or the deviance information criterion (DIC). For the kernel-based approach (<code>pooledROC.dpm()</code>), information regarding the selected bandwidths and the density bandwidth selection method is presented. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pooledROC.BB">pooledROC.BB</a></code>, <code><a href="#topic+pooledROC.emp">pooledROC.emp</a></code>, <code><a href="#topic+pooledROC.kernel">pooledROC.kernel</a></code> or <code><a href="#topic+pooledROC.dpm">pooledROC.dpm</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(ROCnReg)
data(psa)
# Select the last measurement
newpsa &lt;- psa[!duplicated(psa$id, fromLast = TRUE),]

# Log-transform the biomarker
newpsa$l_marker1 &lt;- log(newpsa$marker1)

m0_emp &lt;- pooledROC.emp(marker = "l_marker1", group = "status",
            tag.h = 0, data = newpsa, p = seq(0,1,l=101), B = 500)

summary(m0_emp)

plot(m0_emp)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
