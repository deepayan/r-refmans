<!DOCTYPE html><html><head><title>Help for package rematch2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rematch2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bind_re_match'><p>Match results from a data frame column and attach results</p></a></li>
<li><a href='#re_exec'><p>Extract Data From First Regular Expression Match Into a Data Frame</p></a></li>
<li><a href='#re_exec_all'><p>Extract Data From All Regular Expression Matches Into a Data Frame</p></a></li>
<li><a href='#re_match'><p>Extract Regular Expression Matches Into a Data Frame</p></a></li>
<li><a href='#re_match_all'><p>Extract All Regular Expression Matches Into a Data Frame</p></a></li>
<li><a href='#rematch2-package'><p>Match Regular Expressions with a Nicer 'API'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Output from Regular Expression Matching</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrappers on 'regexpr' and 'gregexpr' to return the match
    results in tidy data frames.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/r-lib/rematch2#readme">https://github.com/r-lib/rematch2#readme</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/r-lib/rematch2/issues">https://github.com/r-lib/rematch2/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>Imports:</td>
<td>tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, testthat</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-30 10:31:13 UTC; gaborcsardi</td>
</tr>
<tr>
<td>Author:</td>
<td>Gábor Csárdi [aut, cre],
  Matthew Lincoln [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gábor Csárdi &lt;csardi.gabor@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-01 06:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bind_re_match'>Match results from a data frame column and attach results</h2><span id='topic+bind_re_match'></span><span id='topic+bind_re_match_'></span>

<h3>Description</h3>

<p>Taking a data frame and a column name as input, this function will run
<code><a href="#topic+re_match">re_match</a></code> and bind the results as new columns to the original
table., returning a <code><a href="tibble.html#topic+tibble">tibble</a></code>. This makes it friendly for
pipe-oriented programming with <a href="magrittr.html#topic+magrittr">magrittr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_re_match(df, from, ..., keep_match = FALSE)

bind_re_match_(df, from, ..., keep_match = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_re_match_+3A_df">df</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="bind_re_match_+3A_from">from</code></td>
<td>
<p>Name of column to use as input for <code><a href="#topic+re_match">re_match</a></code>.
<code><a href="#topic+bind_re_match">bind_re_match</a></code> takes unquoted names, while
<code><a href="#topic+bind_re_match_">bind_re_match_</a></code> takes quoted names.</p>
</td></tr>
<tr><td><code id="bind_re_match_+3A_...">...</code></td>
<td>
<p>Arguments (including <code>pattern</code>) to pass to
<code><a href="#topic+re_match">re_match</a></code>.</p>
</td></tr>
<tr><td><code id="bind_re_match_+3A_keep_match">keep_match</code></td>
<td>
<p>Should the column <code>.match</code> be included in the results?
Defaults to <code>FALSE</code>, to avoid column name collisions in the case that
<code><a href="#topic+bind_re_match">bind_re_match</a></code> is called multiple times in succession.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>bind_re_match_</code>: Standard-evaluation version that takes a quoted column name.
</p>
</li></ul>


<h3>Note</h3>

<p>If named capture groups will result in multiple columns with the same
column name, <code><a href="tibble.html#topic+repair_names">repair_names</a></code> will be called on the
resulting table.
</p>


<h3>See Also</h3>

<p>Standard-evaluation version <code><a href="#topic+bind_re_match_">bind_re_match_</a></code> that is
suitable for programming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>match_cars &lt;- tibble::rownames_to_column(mtcars)
bind_re_match(match_cars, rowname, "^(?&lt;make&gt;\\w+) ?(?&lt;model&gt;.+)?$")

</code></pre>

<hr>
<h2 id='re_exec'>Extract Data From First Regular Expression Match Into a Data Frame</h2><span id='topic+re_exec'></span><span id='topic++24.rematch_records'></span><span id='topic++24.rematch_allrecords'></span>

<h3>Description</h3>

<p>Match a regular expression to a string, and return matches, match positions,
and capture groups.  This function is like its
<code><a href="#topic+re_match">match</a></code> counterpart, except it returns match/capture
group start and end positions in addition to the matched values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_exec(text, pattern, perl = TRUE, ...)

## S3 method for class 'rematch_records'
x$name

## S3 method for class 'rematch_allrecords'
x$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_exec_+3A_text">text</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="re_exec_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression. See <code><a href="base.html#topic+regex">regex</a></code> for more
about regular expressions.</p>
</td></tr>
<tr><td><code id="re_exec_+3A_perl">perl</code></td>
<td>
<p>logical should perl compatible regular expressions be used?
Defaults to TRUE, setting to FALSE will disable capture groups.</p>
</td></tr>
<tr><td><code id="re_exec_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
<code><a href="base.html#topic+gregexpr">gregexpr</a></code> (or <code><a href="base.html#topic+regexpr">regexpr</a></code> if
<code>text</code> is of length zero).</p>
</td></tr>
<tr><td><code id="re_exec_+3A_x">x</code></td>
<td>
<p>Object returned by <code>re_exec</code> or <code>re_exec_all</code>.</p>
</td></tr>
<tr><td><code id="re_exec_+3A_name">name</code></td>
<td>
<p><code>match</code>, <code>start</code> or <code>end</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame (see Section &ldquo;Tidy Data&rdquo;).  Match record
entries are one length vectors that are set to NA if there is no match.
</p>


<h3>Tidy Data</h3>

<p>The return value is a tidy data frame where each row
corresponds to an element of the input character vector <code>text</code>.  The
values from <code>text</code> appear for reference in the <code>.text</code> character
column.  All other columns are list columns containing the match data.  The
<code>.match</code> column contains the match information for full regular
expression matches while other columns correspond to capture groups if there
are any, and PCRE matches are enabled with <code>perl = TRUE</code> (this is on by
default).  If capture groups are named the corresponding columns will bear
those names.
</p>
<p>Each match data column list contains match records, one for each element in
<code>text</code>.  A match record is a named list, with entries <code>match</code>,
<code>start</code> and <code>end</code> that are respectively the matching (sub) string,
the start, and the end positions (using one based indexing).
</p>


<h3>Extracting Match Data</h3>

<p>To make it easier to extract matching substrings or positions, a special
<code>$</code> operator is defined on match columns, both for the <code>.match</code>
column and the columns corresponding to the capture groups.  See examples
below.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+regexpr">regexpr</a></code>, which this function wraps
</p>
<p>Other tidy regular expression matching: 
<code><a href="#topic+re_exec_all">re_exec_all</a>()</code>,
<code><a href="#topic+re_match_all">re_match_all</a>()</code>,
<code><a href="#topic+re_match">re_match</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name_rex &lt;- paste0(
  "(?&lt;first&gt;[[:upper:]][[:lower:]]+) ",
  "(?&lt;last&gt;[[:upper:]][[:lower:]]+)"
)
notables &lt;- c(
  "  Ben Franklin and Jefferson Davis",
  "\tMillard Fillmore"
)
# Match first occurrence
pos &lt;- re_exec(notables, name_rex)
pos

# Custom $ to extract matches and positions
pos$first$match
pos$first$start
pos$first$end
</code></pre>

<hr>
<h2 id='re_exec_all'>Extract Data From All Regular Expression Matches Into a Data Frame</h2><span id='topic+re_exec_all'></span>

<h3>Description</h3>

<p>Match a regular expression to a string, and return matches, match positions,
and capture groups.  This function is like its
<code><a href="#topic+re_match_all">match</a></code> counterpart, except it returns
match/capture group start and end positions in addition to the matched
values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_exec_all(text, pattern, perl = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_exec_all_+3A_text">text</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="re_exec_all_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression. See <code><a href="base.html#topic+regex">regex</a></code> for more
about regular expressions.</p>
</td></tr>
<tr><td><code id="re_exec_all_+3A_perl">perl</code></td>
<td>
<p>logical should perl compatible regular expressions be used?
Defaults to TRUE, setting to FALSE will disable capture groups.</p>
</td></tr>
<tr><td><code id="re_exec_all_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
<code><a href="base.html#topic+gregexpr">gregexpr</a></code> (or <code><a href="base.html#topic+regexpr">regexpr</a></code> if
<code>text</code> is of length zero).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame (see Section &ldquo;Tidy Data&rdquo;).  The entries
within the match records within the list columns will be one vectors
as long as there are matches for the corresponding text element.
</p>


<h3>Tidy Data</h3>

<p>The return value is a tidy data frame where each row
corresponds to an element of the input character vector <code>text</code>.  The
values from <code>text</code> appear for reference in the <code>.text</code> character
column.  All other columns are list columns containing the match data.  The
<code>.match</code> column contains the match information for full regular
expression matches while other columns correspond to capture groups if there
are any, and PCRE matches are enabled with <code>perl = TRUE</code> (this is on by
default).  If capture groups are named the corresponding columns will bear
those names.
</p>
<p>Each match data column list contains match records, one for each element in
<code>text</code>.  A match record is a named list, with entries <code>match</code>,
<code>start</code> and <code>end</code> that are respectively the matching (sub) string,
the start, and the end positions (using one based indexing).
</p>


<h3>Extracting Match Data</h3>

<p>To make it easier to extract matching substrings or positions, a special
<code>$</code> operator is defined on match columns, both for the <code>.match</code>
column and the columns corresponding to the capture groups.  See examples
below.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+gregexpr">gregexpr</a></code>, which this function wraps
</p>
<p>Other tidy regular expression matching: 
<code><a href="#topic+re_exec">re_exec</a>()</code>,
<code><a href="#topic+re_match_all">re_match_all</a>()</code>,
<code><a href="#topic+re_match">re_match</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name_rex &lt;- paste0(
  "(?&lt;first&gt;[[:upper:]][[:lower:]]+) ",
  "(?&lt;last&gt;[[:upper:]][[:lower:]]+)"
)
notables &lt;- c(
  "  Ben Franklin and Jefferson Davis",
  "\tMillard Fillmore"
)
# All occurrences
allpos &lt;- re_exec_all(notables, name_rex)
allpos

# Custom $ to extract matches and positions
allpos$first$match
allpos$first$start
allpos$first$end
</code></pre>

<hr>
<h2 id='re_match'>Extract Regular Expression Matches Into a Data Frame</h2><span id='topic+re_match'></span>

<h3>Description</h3>

<p><code>re_match</code> wraps <code><a href="base.html#topic+regexpr">regexpr</a></code> and returns the
match results in a convenient data frame. The data frame has one
column for each capture group if <code>perl=TRUE</code>, and one final columns
called <code>.match</code> for the matching (sub)string. The columns of the capture
groups are named if the groups themselves are named.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_match(text, pattern, perl = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_match_+3A_text">text</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="re_match_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression. See <code><a href="base.html#topic+regex">regex</a></code> for more
about regular expressions.</p>
</td></tr>
<tr><td><code id="re_match_+3A_perl">perl</code></td>
<td>
<p>logical should perl compatible regular expressions be used?
Defaults to TRUE, setting to FALSE will disable capture groups.</p>
</td></tr>
<tr><td><code id="re_match_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="base.html#topic+regexpr">regexpr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of character vectors: one column per capture
group, named if the group was named, and additional columns for
the input text and the first matching (sub)string. Each row
corresponds to an element in the <code>text</code> vector.
</p>


<h3>Note</h3>

<p><code>re_match</code> uses PCRE compatible regular expressions by default
(i.e. <code>perl = TRUE</code> in <code><a href="base.html#topic+regexpr">regexpr</a></code>).  You can switch
this off but if you do so capture groups will no longer be reported as they
are only supported by PCRE.
</p>


<h3>See Also</h3>

<p>Other tidy regular expression matching: 
<code><a href="#topic+re_exec_all">re_exec_all</a>()</code>,
<code><a href="#topic+re_exec">re_exec</a>()</code>,
<code><a href="#topic+re_match_all">re_match_all</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dates &lt;- c("2016-04-20", "1977-08-08", "not a date", "2016",
  "76-03-02", "2012-06-30", "2015-01-21 19:58")
isodate &lt;- "([0-9]{4})-([0-1][0-9])-([0-3][0-9])"
re_match(text = dates, pattern = isodate)

# The same with named groups
isodaten &lt;- "(?&lt;year&gt;[0-9]{4})-(?&lt;month&gt;[0-1][0-9])-(?&lt;day&gt;[0-3][0-9])"
re_match(text = dates, pattern = isodaten)
</code></pre>

<hr>
<h2 id='re_match_all'>Extract All Regular Expression Matches Into a Data Frame</h2><span id='topic+re_match_all'></span>

<h3>Description</h3>

<p>This function is a thin wrapper on the <code><a href="base.html#topic+gregexpr">gregexpr</a></code>
base R function, to extract the matching (sub)strings as a data frame.
It extracts all matches, and potentially their capture groups as well.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_match_all(text, pattern, perl = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_match_all_+3A_text">text</code></td>
<td>
<p>Character vector.</p>
</td></tr>
<tr><td><code id="re_match_all_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression. See <code><a href="base.html#topic+regex">regex</a></code> for more
about regular expressions.</p>
</td></tr>
<tr><td><code id="re_match_all_+3A_perl">perl</code></td>
<td>
<p>logical should perl compatible regular expressions be used?
Defaults to TRUE, setting to FALSE will disable capture groups.</p>
</td></tr>
<tr><td><code id="re_match_all_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to
<code><a href="base.html#topic+gregexpr">gregexpr</a></code> (or <code><a href="base.html#topic+regexpr">regexpr</a></code> if
<code>text</code> is of length zero).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidy data frame (see Section &ldquo;Tidy Data&rdquo;).  The list columns
contain character vectors with as many entries as there are matches for
each input element.
</p>


<h3>Tidy Data</h3>

<p>The return value is a tidy data frame where each row
corresponds to an element of the input character vector <code>text</code>.  The
values from <code>text</code> appear for reference in the <code>.text</code> character
column.  All other columns are list columns containing the match data.  The
<code>.match</code> column contains the match information for full regular
expression matches while other columns correspond to capture groups if there
are any, and PCRE matches are enabled with <code>perl = TRUE</code> (this is on by
default).  If capture groups are named the corresponding columns will bear
those names.
</p>
<p>Each match data column list contains match records, one for each element in
<code>text</code>.  A match record is a named list, with entries <code>match</code>,
<code>start</code> and <code>end</code> that are respectively the matching (sub) string,
the start, and the end positions (using one based indexing).
</p>


<h3>Note</h3>

<p>If the input text character vector has length zero,
<code><a href="base.html#topic+regexpr">regexpr</a></code> is called instead of
<code><a href="base.html#topic+gregexpr">gregexpr</a></code>, because the latter cannot extract the
number and names of the capture groups in this case.
</p>


<h3>See Also</h3>

<p>Other tidy regular expression matching: 
<code><a href="#topic+re_exec_all">re_exec_all</a>()</code>,
<code><a href="#topic+re_exec">re_exec</a>()</code>,
<code><a href="#topic+re_match">re_match</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>name_rex &lt;- paste0(
  "(?&lt;first&gt;[[:upper:]][[:lower:]]+) ",
  "(?&lt;last&gt;[[:upper:]][[:lower:]]+)"
)
notables &lt;- c(
  "  Ben Franklin and Jefferson Davis",
  "\tMillard Fillmore"
)
re_match_all(notables, name_rex)
</code></pre>

<hr>
<h2 id='rematch2-package'>Match Regular Expressions with a Nicer 'API'</h2><span id='topic+rematch2'></span><span id='topic+rematch2-package'></span>

<h3>Description</h3>

<p>A small wrapper on 'regexpr' to extract the matches and captured
groups from the match of a regular expression to a character vector.
See <code><a href="#topic+re_match">re_match</a></code>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Gábor Csárdi <a href="mailto:csardi.gabor@gmail.com">csardi.gabor@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Matthew Lincoln <a href="mailto:matthew.d.lincoln@gmail.com">matthew.d.lincoln@gmail.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/r-lib/rematch2#readme">https://github.com/r-lib/rematch2#readme</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/r-lib/rematch2/issues">https://github.com/r-lib/rematch2/issues</a>
</p>
</li></ul>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
